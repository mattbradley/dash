{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./js/physics/Car.js","webpack:///./js/autonomy/StaticObstacle.js","webpack:///./js/autonomy/path-planning/CubicPath.js","webpack:///./js/autonomy/LanePath.js","webpack:///./js/autonomy/DynamicObstacle.js","webpack:///./js/GPGPU.js","webpack:///./js/autonomy/path-planning/QuinticPath.js","webpack:///./js/autonomy/path-planning/gpgpu-programs/xyObstacleGrid.js","webpack:///./js/autonomy/path-planning/gpgpu-programs/slObstacleGrid.js","webpack:///./js/autonomy/path-planning/gpgpu-programs/slObstacleGridDilation.js","webpack:///./js/autonomy/path-planning/gpgpu-programs/slDynamicObstacleGrid.js","webpack:///./js/autonomy/path-planning/gpgpu-programs/xyslMap.js","webpack:///./js/autonomy/path-planning/gpgpu-programs/optimizeCubicPaths.js","webpack:///./js/autonomy/path-planning/gpgpu-programs/optimizeQuinticPaths.js","webpack:///./js/autonomy/path-planning/gpgpu-programs/graphSearchShared.js","webpack:///./js/autonomy/path-planning/gpgpu-programs/pathFromVehicleCosts.js","webpack:///./js/autonomy/path-planning/gpgpu-programs/graphSearch.js","webpack:///./js/autonomy/path-planning/PathPlanner.js","webpack:///./node_modules/script-loader/addScript.js","webpack:///./js/Utils.js","webpack:///./js/Utils.js?f695","webpack:///./vendor/three.js","webpack:///./vendor/three.js?b376","webpack:///./workers/PathPlannerWorker.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","default","object","property","prototype","hasOwnProperty","p","s","t","e","Car","[object Object]","x","y","rotation","this","setPose","pos","rot","THREE","Vector2","fromAngle","multiplyScalar","WHEEL_BASE","add","frontToRearAxlePosition","REAR_AXLE_POS","pose","rearAxlePosition","clone","velocity","curv","curvature","dCurv","ddCurv","Math","tan","wheelAngle","position","cos","sin","frontAxlePosition","FRONT_AXLE_POS","wrapAngle","acceleration","wheelAngularVelocity","dt","curvPrev","dCurvPrev","drag","DRAG_COEFF","FRONTAL_AREA","DENSITY_OF_AIR","abs","ROLL_RESIST","MASS","velocitySq","maxWheelAngle","clamp","atan","MAX_LATERAL_ACCEL","MAX_WHEEL_ANGLE","angularVelocity","dist","controls","gas","brake","steer","sign","MAX_BRAKE_DECEL","newVelocity","MAX_GAS_ACCEL","MAX_STEER_SPEED","HALF_CAR_LENGTH","HALF_CAR_WIDTH","HALF_WHEEL_LENGTH","HALF_WHEEL_WIDTH","PI","WHEEL_LATERAL_POS","StaticObstacle","obj","setPrototypeOf","json","w","h","width","height","updateVertices","trunc","toFixed","vertices","cosRot","sinRot","halfWidth","halfHeight","hWcR","hWsR","hHcR","hHsR","v1","v2","v3","v4","__webpack_exports__","CubicPath","SIMPSONS_INTERVALS","NEWTON_ITERATIONS","RELAXATION_ITERATIONS","CONVERGENCE_ERROR","jacobian","Matrix3","invJacobian","start","end","params","assign","diffX","diffY","goal","p0","p3","guessInitialParams","converged","originalGoal","dStartCurv","dGoalY","dGoalRot","dGoalCurv","p1","p2","sG","iterate","ds","sG_2","sG_3","theta","cosTheta","sinTheta","dT_p1","dT_p2","dT_sG","dX_p1","dX_p2","dX_sG","dY_p1","dY_p2","dY_sG","guessX","guessY","coeff","s_sG","hOver3","deltaX","deltaY","deltaRot","set","m11","m21","m31","m12","m22","m32","m13","m23","m33","getInverse","elements","num","a","b","path","dx","dy","prevCosRot","prevSinRot","push","LanePath","halfLaneWidth","Geometry","anchors","centerlines","sampleLengths","arcLengths","leftBoundaries","rightBoundaries","centerline","concat","leftBoundary","rightBoundary","arcLength","reduce","sum","startStation","interval","samples","anchorIndex","sampleIndex","totalLength","nextStation","length","anchorsForSplineIndex","weight","catmullRomVec","tangent","tangentAt","atan2","curvatureAt","aroundAnchorIndex","sampleStation","prevSampleStation","_findClosestSample","prevPoint","nextPoint","prevStation","possibleNext","sub","dot","distanceToSquared","progress","projectedPosition","distanceTo","bestAnchorIndex","bestSampleIndex","bestStation","bestPrevStation","closest","Number","POSITIVE_INFINITY","currStation","startAnchorIndex","endAnchorIndex","max","min","distSq","resample","index","splice","segmentIndex","points","lengths","pointsPerSegment","ceil","numPoints","point","normal","slice","catmullRom","v0","t2","t1","prev","normalize","t3","pt1","pt2","pt3","DynamicObstacle","VEHICLE_SIZE","CYCLIST_SIZE","PEDESTRIAN_SIZE","startPos","type","parallel","size","time","startTime","endTime","numFrames","positions","positionAtTime","config","positionsInTimeRange","numDynamicSubframes","hazardHalfWidth","dynamicHazardDilationS","collisionDilationS","hazardHalfHeight","dynamicHazardDilationL","collisionDilationL","forEach","collisionHalfWidth","collisionHalfHeight","GPGPU","vertexShaderCode","fragmentShaderHeader","stride","isInteger","Error","squareSize","pow","sqrt","data","Float32Array","gpgpuSize","gpgpuStride","configs","shared","_setUpGL","outputTextures","sharedTextures","programs","map","_prepareProgram","options","channels","_createTexture","gl","deleteTexture","programOrProgramIndex","program","inputs","meta","updateProgramSize","uniforms","updateProgramUniforms","programIndex","inputTextures","previousInputWidth","inputWidth","previousInputHeight","inputHeight","inputDataSize","_prepareProgramInputs","useProgram","glProgram","uniform2i","kernelSizeLocation","_prepareProgramOutput","uniformName","uniform","_setUniform","location","uniformTextures","texture","outputs","viewport","bindFramebuffer","FRAMEBUFFER","frameBuffer","inputTexture","entries","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","uniformTexture","target","draw","bindBuffer","ARRAY_BUFFER","textureBuffer","enableVertexAttribArray","textureLocation","vertexAttribPointer","FLOAT","positionBuffer","positionLocation","ELEMENT_ARRAY_BUFFER","indexBuffer","drawProxy","drawElements","TRIANGLES","UNSIGNED_SHORT","bind","output","read","readPixels","RGBA","subarray","canvas","self","document","createElement","OffscreenCanvas","attr","alpha","antialias","getContext","getExtension","_newBuffer","Uint16Array","kernel","fragmentShaderConfig","Array","isArray","textureType","TEXTURE_3D","TEXTURE_2D_ARRAY","vertexShader","createShader","VERTEX_SHADER","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","fragmentShaderMain","keys","join","fragmentShader","FRAGMENT_SHADER","fragmentShaderSource","source","split","dbgMsg","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","textureIndex","input","getUniformLocation","uniform1i","getAttribLocation","createFramebuffer","outputTexture","framebufferTexture2D","COLOR_ATTACHMENT0","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","uniform1fv","uniform1f","uniform2fv","uniform3fv","uniform4fv","uniformMatrix3fv","klass","buf","createBuffer","bufferData","STATIC_DRAW","createTexture","internalFormat","format","R32F","RED","RG32F","RG","RGB32F","RGB","RGBA32F","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_WRAP_R","TEXTURE_MIN_FILTER","filter","LINEAR","NEAREST","TEXTURE_MAG_FILTER","texImage3D","depth","texImage2D","QuinticPath","p5","p4","f","obstacleVertices","obstacleXform","xyObstacleGrid","setUp","gpgpu","clearColor","clear","COLOR_BUFFER_BIT","xformLocation","drawArrays","deleteBuffer","xyWidth","xyHeight","xyCenterPoint","vehicleXform","obstacles","apply","translate","scale","xyGridCellSize","multiply","slObstacleGrid","slGridCellSize","slCenterPoint","centerlineStationInterval","update","slWidth","slHeight","SL_OBSTACLE_DILATION_KERNEL","slObstacleGridDilation","delta","collisionDilation","hazardDilation","hazardDilationS","hazardDilationL","slDynamicObstacleGrid_obstacleVertices","slDynamicObstacleGrid_obstacleXform","slDynamicObstacleGrid","enable","DEPTH_TEST","renderbuffer","createRenderbuffer","bindRenderbuffer","RENDERBUFFER","renderbufferStorage","DEPTH_COMPONENT16","framebufferRenderbuffer","DEPTH_ATTACHMENT","frame","framebufferTextureLayer","DEPTH_BUFFER_BIT","obstacleGrid","_dynamicObstacleGrid","deleteRenderbuffer","disable","vehicleStation","dynamicFrameTime","dynamicObstacles","verticesInTimeRange","xyslMap","optimizeCubicPaths","OPTIMIZE_CUBIC_SHARED","lattice","numStations","numLatitudes","stationConnectivity","latitudeConnectivity","curvVehicle","optimizeQuinticPaths","dCurvVehicle","ddCurvVehicle","SHARED_SHADER","SAMPLE_CUBIC_PATH_FN","SAMPLE_QUINTIC_PATH_FN","SHARED_UNIFORMS","accelerationProfiles","finalVelocityProfiles","laneCenterLatitude","laneShoulderLatitude","laneCostSlope","lanePreference","lanePreferenceDiscount","obstacleHazardCost","speedLimit","speedLimitPenalty","hardAccelerationPenalty","hardDecelerationPenalty","softLateralAccelerationLimit","softLateralAccelerationPenalty","linearLateralAccelerationPenalty","dCurvatureMax","pathSamplingStep","rearAxleToCenter","buildUniformValues","fromVehiclePathCostsKernel","pathType","pathFromVehicleCosts","pathsFromVehicle","firstLatticePoint","secondLatticePoint","velocityVehicle","numAccelerations","cubicPathPenalty","hysteresisDiscount","accelerationChangePenalty","SOLVE_STATION_KERNEL","graphSearch","costTable","cubicPaths","cubicPathFromVehicleCosts","quinticPathFromVehicleCosts","extraTimePenalty","numVelocities","numTimes","velocityRanges","NUM_VELOCITY_RANGES","timeRanges","NUM_TIME_RANGES","station","NUM_ACCELERATION_PROFILES","copyTexSubImage3D","_graphSearchCostTable","L","PathPlanner_NUM_ACCELERATION_PROFILES","PathPlanner_NUM_VELOCITY_RANGES","PathPlanner_NUM_TIME_RANGES","PathPlanner_PathPlanner","previousStartStation","previousFirstLatticePoint","previousSecondLatticePoint","previousFirstAcceleration","performance","now","vehiclePose","lanePath","staticObstacles","latticeStationInterval","_latticeStationInterval","centerlineRaw","sampleStations","spatialHorizon","rotate","applyMatrix3","centerlineData","maxPoint","minPoint","sample","diff","divideScalar","gridMargin","stationWidth","roadWidth","_buildLattice","numDynamicFrames","updateProgram","updateSharedTextures","run","cubicPathParams","cubicPathFromVehicleParams","quinticPathFromVehicleParams","bestEntryIndex","bestEntry","numEntries","entryUnpacked","_unpackCostTableIndex","entry","_terminalCost","inverseVehicleXform","bestTrajectory","fromVehicleSegment","fromVehicleParams","firstAcceleration","secondAcceleration","isFinite","_reconstructTrajectory","previousSecondAcceleration","latticeStartStation","dynamicObstacleGrid","vehicleRot","offset","floor","latitude","stationIndex","latitudeIndex","timeIndex","velocityIndex","accelerationIndex","cost","finalVelocity","finalTime","incomingIndex","stationReachDiscount","numPerTime","numPerLatitude","numPerStation","unpacked","nodes","count","unshift","prevLatitude","_pt","_pv","_pa","prevVelocity","_t","_v","_a","pathBuilder","endIndex","startIndex","slIndex","cubicPathIndex","buildPath","prevVelocitySq","accel","shift","src","log","error","console","execScript","attachEvent","addEventListener","eval","init","pathPlanner","_js_autonomy_path_planning_PathPlanner_js__WEBPACK_IMPORTED_MODULE_2__","postMessage","onmessage","event","reset","_js_autonomy_LanePath_js__WEBPACK_IMPORTED_MODULE_3__","hydrate","_js_autonomy_StaticObstacle_js__WEBPACK_IMPORTED_MODULE_4__","_js_autonomy_DynamicObstacle_js__WEBPACK_IMPORTED_MODULE_5__","plan","window","dash_initPathPlannerWorker"],"mappings":"mDACA,IAAAA,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAC,QAGA,IAAAC,EAAAJ,EAAAE,IACAG,EAAAH,EACAI,KACAH,YAUA,OANAI,EAAAL,GAAAM,KAAAJ,EAAAD,QAAAC,IAAAD,QAAAF,GAGAG,EAAAE,KAGAF,EAAAD,QAKAF,EAAAQ,EAAAF,EAGAN,EAAAS,EAAAV,EAGAC,EAAAU,EAAA,SAAAR,EAAAS,EAAAC,GACAZ,EAAAa,EAAAX,EAAAS,IACAG,OAAAC,eAAAb,EAAAS,GACAK,gBACAC,cACAC,IAAAN,KAMAZ,EAAAmB,EAAA,SAAAjB,GACAY,OAAAC,eAAAb,EAAA,cAAiDkB,YAIjDpB,EAAAqB,EAAA,SAAAlB,GACA,IAAAS,EAAAT,KAAAmB,WACA,WAA2B,OAAAnB,EAAAoB,SAC3B,WAAiC,OAAApB,GAEjC,OADAH,EAAAU,EAAAE,EAAA,IAAAA,GACAA,GAIAZ,EAAAa,EAAA,SAAAW,EAAAC,GAAsD,OAAAX,OAAAY,UAAAC,eAAApB,KAAAiB,EAAAC,IAGtDzB,EAAA4B,EAAA,GAIA5B,IAAA6B,EAAA,eAAAC,EAAAT,EAAAU,GAAA,aAAAA,EAAArB,EAAAW,EAAA,sBAAAF,UCnEAa,EACAC,YAAAC,EAAA,EAAAC,EAAA,EAAAC,EAAA,GACAC,KAAAC,QAAAJ,EAAAC,EAAAC,GAGAH,4BAAAM,EAAAC,GACA,OAAAC,MAAAC,QAAAC,UAAAH,GAAAI,eAAAZ,EAAAa,YAAAC,IAAAP,GAGAN,2BAAAM,EAAAC,GACA,OAAAR,EAAAe,wBAAAR,EAAAC,GAGAP,gCAAAM,EAAAC,GACA,OAAAC,MAAAC,QAAAC,UAAAH,GAAAI,eAAAZ,EAAAgB,eAAAF,IAAAP,GAGAN,+BAAAM,EAAAC,GACA,OAAAC,MAAAC,QAAAC,UAAAH,GAAAI,gBAAAZ,EAAAa,YAAAC,IAAAP,GAGAU,WACA,OAAYV,IAAAF,KAAAa,iBAAAC,QAAAX,IAAAH,KAAAD,SAAAgB,SAAAf,KAAAe,SAAAC,KAAAhB,KAAAiB,UAAAC,MAAAlB,KAAAkB,MAAAC,OAAAnB,KAAAmB,QAGZF,gBACA,OAAAG,KAAAC,IAAArB,KAAAsB,YAAA3B,EAAAa,WAGAK,uBACA,MAAAhB,EAAWA,EAAAC,KAAOE,KAAAuB,SAClBpB,EAAAH,KAAAD,SACA,WAAAK,MAAAC,QAAAR,EAAAuB,KAAAI,IAAArB,GAAAR,EAAAgB,cAAAb,EAAAsB,KAAAK,IAAAtB,GAAAR,EAAAgB,eAGAe,wBACA,MAAA7B,EAAWA,EAAAC,KAAOE,KAAAuB,SAClBpB,EAAAH,KAAAD,SACA,WAAAK,MAAAC,QAAAR,EAAAuB,KAAAI,IAAArB,GAAAR,EAAAgC,eAAA7B,EAAAsB,KAAAK,IAAAtB,GAAAR,EAAAgC,gBAGA/B,QAAAC,EAAAC,EAAAC,GAEAF,GAAAF,EAAAgB,cAAAS,KAAAI,IAAAzB,GACAD,GAAAH,EAAAgB,cAAAS,KAAAK,IAAA1B,GAEAC,KAAAuB,SAAA,IAAAnB,MAAAC,QAAAR,EAAAC,GACAE,KAAAD,SAAAqB,KAAAQ,UAAA7B,GACAC,KAAAe,SAAA,EACAf,KAAA6B,aAAA,EACA7B,KAAAsB,WAAA,EACAtB,KAAA8B,qBAAA,EACA9B,KAAAkB,MAAA,EACAlB,KAAAmB,OAAA,EAGAvB,KAAAmC,GACA,MAAAC,EAAAhC,KAAAiB,UACAgB,EAAAjC,KAAAkB,MAEAgB,GAAA,GAAAvC,EAAAwC,WAAAxC,EAAAyC,aAAAzC,EAAA0C,eAAAjB,KAAAkB,IAAAtC,KAAAe,UAAApB,EAAA4C,cAAAvC,KAAAe,SACAf,KAAAe,WAAAf,KAAA6B,aAAAK,EAAAvC,EAAA6C,MAAAT,EAEA,MAAAU,EAAAzC,KAAAe,SAAAf,KAAAe,SACA2B,EAAAtB,KAAAuB,MAAAvB,KAAAwB,KAAAjD,EAAAkD,kBAAAlD,EAAAa,WAAAiC,GAAA,IAAA9C,EAAAmD,iBACA9C,KAAAsB,WAAAF,KAAAuB,MAAAvB,KAAAQ,UAAA5B,KAAAsB,WAAAtB,KAAA8B,qBAAAC,IAAAW,KAEA,MAAAK,EAAA/C,KAAAe,SAAAf,KAAAiB,UACAjB,KAAAD,SAAAqB,KAAAQ,UAAA5B,KAAAD,SAAAgD,EAAAhB,GAEA,MAAAiB,EAAAhD,KAAAe,SAAAgB,EACA/B,KAAAuB,SAAAnB,MAAAC,QAAAC,UAAAN,KAAAD,UAAAQ,eAAAyC,GAAAvC,IAAAT,KAAAuB,UAEAvB,KAAAkB,MAAA8B,EAAA,IAAAhD,KAAAiB,UAAAe,GAAAgB,EAAA,EACAhD,KAAAmB,OAAA6B,EAAA,IAAAhD,KAAAkB,MAAAe,GAAAe,EAAA,EAGApD,OAAAqD,EAAAlB,GACA,MAAAmB,EAAA9B,KAAAuB,MAAAM,EAAAC,KAAA,KACAC,EAAA/B,KAAAuB,MAAAM,EAAAE,MAAA,KACAC,EAAAhC,KAAAuB,MAAAM,EAAAG,OAAA,KAEA,GAAAD,EAAA,GACAnD,KAAA6B,cAAAT,KAAAiC,KAAArD,KAAAe,UAAApB,EAAA2D,gBAAAH,EACA,MAAAI,EAAAvD,KAAAe,SAAAf,KAAA6B,aAAAE,EAIAX,KAAAiC,KAAAE,IAAAnC,KAAAiC,KAAArD,KAAAe,YACAf,KAAAe,SAAA,EACAf,KAAA6B,aAAA,QAGA7B,KAAA6B,aAAAlC,EAAA6D,cAAAN,EAIAlD,KAAA8B,qBADA,GAAAsB,EACAA,EAAAzD,EAAA8D,gBAEArC,KAAAuB,OAAA3C,KAAAsB,WAAA3B,EAAAmD,gBAAA9C,KAAAe,SAAAf,KAAAe,SAAAgB,GAAApC,EAAA8D,gBAAA9D,EAAA8D,kBAKA9D,EAAA+D,gBAAA,IACA/D,EAAAgE,eAAA,EACAhE,EAAAiE,kBAAA,IACAjE,EAAAkE,iBAAA,IACAlE,EAAAmD,gBAAA,OAAA1B,KAAA0C,GACAnE,EAAA6C,KAAA,KACA7C,EAAAwC,WAAA,GACAxC,EAAA0C,eAAA,UACA1C,EAAAyC,aAAA,KACAzC,EAAA4C,YAAA,EACA5C,EAAA8D,gBAAA,GACA9D,EAAA6D,cAAA,IACA7D,EAAA2D,gBAAA,IACA3D,EAAAoE,kBAAA,KACApE,EAAAgC,eAAA,IACAhC,EAAAgB,eAAA,KACAhB,EAAAa,WAAAb,EAAAgC,eAAAhC,EAAAgB,cACAhB,EAAAkD,kBAAA,eAAApD,EAAAT,EAAAU,GAAA,aAAAA,EAAArB,EAAAW,EAAA,sBAAAF,UCzHAkF,EACApE,eAAAqE,GACAxF,OAAAyF,eAAAD,EAAAD,EAAA3E,WACAZ,OAAAyF,eAAAD,EAAA/D,IAAAE,MAAAC,QAAAhB,WAGAO,gBAAAuE,GACA,WAAAH,EAAA,IAAA5D,MAAAC,QAAA8D,EAAA5E,EAAA,GAAA4E,EAAA5E,EAAA,IAAA4E,EAAArF,EAAAqF,EAAAC,EAAAD,EAAAE,GAGAzE,YAAAM,EAAAC,EAAAmE,EAAAC,GACAvE,KAAAE,MACAF,KAAAG,MACAH,KAAAsE,QACAtE,KAAAuE,SAEAvE,KAAAwE,iBAGA5E,SACA,MAAA6E,EAAAzF,MAAA0F,QAAA,GAEA,OACAnF,GAAAkF,EAAAzE,KAAAE,IAAAL,GAAA4E,EAAAzE,KAAAE,IAAAJ,IACAhB,EAAA2F,EAAAzE,KAAAG,KACAiE,EAAAK,EAAAzE,KAAAsE,OACAD,EAAAI,EAAAzE,KAAAuE,SAIA3E,iBACAI,KAAA2E,YAEA,MAAAC,EAAAxD,KAAAI,IAAAxB,KAAAG,KACA0E,EAAAzD,KAAAK,IAAAzB,KAAAG,KACA2E,EAAA9E,KAAAsE,MAAA,EACAS,EAAA/E,KAAAuE,OAAA,EAEAS,EAAAF,EAAAF,EACAK,EAAAH,EAAAD,EACAK,EAAAH,EAAAH,EACAO,EAAAJ,EAAAF,EAEAO,IAAAJ,EAAAG,EAAAnF,KAAAE,IAAAL,GAAAoF,EAAAC,EAAAlF,KAAAE,IAAAJ,GACAuF,IAAAL,EAAAG,EAAAnF,KAAAE,IAAAL,GAAAoF,EAAAC,EAAAlF,KAAAE,IAAAJ,GACAwF,GAAAN,EAAAG,EAAAnF,KAAAE,IAAAL,EAAAoF,EAAAC,EAAAlF,KAAAE,IAAAJ,GACAyF,GAAAP,EAAAG,EAAAnF,KAAAE,IAAAL,EAAAoF,EAAAC,EAAAlF,KAAAE,IAAAJ,GAEAE,KAAA2E,UACAS,EAAA,GAAAA,EAAA,GACAC,EAAA,GAAAA,EAAA,GACAC,EAAA,GAAAA,EAAA,GACAA,EAAA,GAAAA,EAAA,GACAC,EAAA,GAAAA,EAAA,GACAH,EAAA,GAAAA,EAAA,gBAAA3F,EAAAT,EAAAU,GAAA,aCtDA/B,EAAAU,EAAAmH,EAAA,sBAAAC,IAAA,MAAAC,EAAA,EACAC,EAAA,GACAC,EAAA,GACAC,EAAA,IAEAC,EAAA,IAAA1F,MAAA2F,QACAC,EAAA,IAAA5F,MAAA2F,cAGAN,EACA7F,YAAAqG,EAAAC,EAAAC,EAAA,MACAnG,KAAAiG,MAAAxH,OAAA2H,UAAiCH,GACjCjG,KAAAkG,IAAAzH,OAAA2H,UAA+BF,GAE/BD,EAAA/F,MACAF,KAAAiG,MAAApG,EAAAoG,EAAA/F,IAAAL,EACAG,KAAAiG,MAAAnG,EAAAmG,EAAA/F,IAAAJ,GAGAoG,EAAAhG,MACAF,KAAAkG,IAAArG,EAAAqG,EAAAhG,IAAAL,EACAG,KAAAkG,IAAApG,EAAAoG,EAAAhG,IAAAJ,GAGA,MAAAuG,EAAArG,KAAAkG,IAAArG,EAAAG,KAAAiG,MAAApG,EACAyG,EAAAtG,KAAAkG,IAAApG,EAAAE,KAAAiG,MAAAnG,EACA+E,EAAAzD,KAAAK,IAAAzB,KAAAiG,MAAA9F,KACAyE,EAAAxD,KAAAI,IAAAxB,KAAAiG,MAAA9F,KAEAH,KAAAuG,MACA1G,EAAA+E,EAAAyB,EAAAxB,EAAAyB,EACAxG,GAAA+E,EAAAwB,EAAAzB,EAAA0B,EACAnG,IAAAiB,KAAAQ,UAAA5B,KAAAkG,IAAA/F,IAAAH,KAAAiG,MAAA9F,KACAa,KAAAhB,KAAAkG,IAAAlF,MAGAmF,EACAnG,KAAAmG,OAAA1H,OAAA2H,UAAoCD,GAAWK,GAAAxG,KAAAiG,MAAAjF,KAAAyF,GAAAzG,KAAAkG,IAAAlF,OAE/ChB,KAAA0G,qBAEA1G,KAAA2G,aAGA/G,qBACA,MAAAgH,EAAA5G,KAAAuG,KACAM,EAAA7G,KAAAiG,MAAAjF,KAAA4E,EACAkB,EAAAF,EAAA9G,EAAA8F,EACAmB,EAAAH,EAAAzG,IAAAyF,EACAoB,EAAAJ,EAAA5F,KAAA4E,EAEA5F,KAAAuG,MACA1G,EAAA+G,EAAA/G,EACAC,EAAA,EACAK,IAAA,EACAa,KAAA,GAGAhB,KAAAmG,QACAK,GAAA,EACAS,GAAA,EACAC,GAAA,EACAT,GAAA,EACAU,GAAAP,EAAA/G,GAGA,QAAA9B,EAAA,EAAmBA,EAAA6H,EAA2B7H,IAC9CiC,KAAAmG,OAAAK,IAAAK,EACA7G,KAAAmG,OAAAM,IAAAO,EACAhH,KAAAuG,KAAAzG,GAAAgH,EACA9G,KAAAuG,KAAApG,KAAA4G,EACA/G,KAAAuG,KAAAvF,MAAAgG,EAEAhH,KAAAoH,UAGApH,KAAAuG,KAAAK,EAGAhH,WACA,QAAA7B,EAAA,EAAmBA,EAAA4H,EAAuB5H,IAC1C,GAAAiC,KAAAoH,UAEA,OADApH,KAAA2G,cAAA,EAMA,OADA3G,KAAA2G,cAAA,EAIA/G,UACA,MAAA4G,GAAWA,EAAAS,KAAAC,KAAAT,KAAAU,MAAqBnH,KAAAmG,OAEhCkB,EAAAF,EAAAzB,EACA4B,EAAAH,IACAI,EAAAD,EAAAH,EAEA,IASAK,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EATAC,EAAA,EACAC,EAAA,EACAC,EAAA,EACAC,EAAA,EACAC,EAAA,EACAC,EAAA,EACAC,EAAA,EACAC,EAAA,EAIA,QAAAtK,EAAA,EAAAyB,EAAA,EAA0BzB,GAAA2H,EAAyB3H,IAAAyB,GAAA6H,EAAA,CACnD,MAAAiB,EAAA,GAAAvK,MAAA2H,EAAA,EAAA3H,EAAA,SAOAyJ,MAFA,KAAAhB,EAAA,EAAAS,EAAA,EAAAC,EAAAT,GAAAc,EAEA/H,EAAA,GAHA,EAAAgH,EAAA,KAAAS,EAAA,GAAAC,EAAA,IAAAT,GAAAa,EAGA,GAAA9H,IAJA,IAAAgH,EAAA,EAAAS,EAAA,IAAAC,EAAAT,GAAAU,EAIA,GAAA3H,EALAgH,GAKAhH,EACAiI,EAAArG,KAAAI,IAAAgG,GAGA,MAAAe,EAAA/I,EAAA2H,EAKAW,GAAAQ,GAPAZ,EAAAtG,KAAAK,IAAA+F,KAGAG,IAAA,MAAAY,EAAA,KAAAA,EAAA,KAAAA,EAAA/I,GAKAuI,GAAAO,EAAAZ,GAJAE,KAAA,MAAAW,EAAA,GAAAA,EAAA,MAAAA,EAAA/I,GAKAwI,GAAAM,EAAAZ,GAJAG,IAAA,OAAArB,EAAA,EAAAS,EAAA,EAAAC,EAAAT,GAAA8B,EAAA,KAAA/B,EAAA,EAAAS,EAAA,EAAAC,EAAAT,IAAA8B,EAAA,QAAA/B,EAAA,GAAAS,EAAA,EAAAC,EAAA,EAAAT,IAAA8B,KAMAN,GAAAK,EAAAb,EAAAE,EACAO,GAAAI,EAAAb,EAAAG,EACAO,GAAAG,EAAAb,EAAAI,EAEAO,GAAAE,EAAAb,EACAY,GAAAC,EAAAZ,EAMA,MAAAc,EAAArB,EAAAzB,EAAA,EAEA+C,EAAAzI,KAAAuG,KAAA1G,EAAAuI,EAAAI,EACAE,EAAA1I,KAAAuG,KAAAzG,EAAAuI,EAAAG,EACAG,EAAAvH,KAAAQ,UAAA5B,KAAAuG,KAAApG,IAAAqH,GAEA,GAAApG,KAAAkB,IAAAmG,GAAArH,KAAAkB,IAAAoG,GAAAtH,KAAAkB,IAAAqG,GAAA9C,EACA,SAEAC,EAAA8C,IACAd,EAAAU,EAAAT,EAAAS,EAAAf,EAAAO,EAAAQ,EACAP,EAAAO,EAAAN,EAAAM,EAAAd,EAAAS,EAAAK,EACAb,EAAAC,EAAAC,GAGA,MAAAgB,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAAArD,EAAAsD,WAAAxD,GAAAyD,SAMA,OAJAvJ,KAAAmG,OAAAc,IAAA4B,EAAAJ,EAAAO,EAAAN,EAAAS,EAAAR,EACA3I,KAAAmG,OAAAe,IAAA4B,EAAAL,EAAAQ,EAAAP,EAAAU,EAAAT,EACA3I,KAAAmG,OAAAgB,IAAA4B,EAAAN,EAAAS,EAAAR,EAAAW,EAAAV,KAKA/I,UAAA4J,GACA,MAAAhD,GAAWA,EAAAS,KAAAC,KAAAT,KAAAU,MAAqBnH,KAAAmG,OAEhCmB,EAAAH,IAGAsC,EAAAjD,EACAkD,IAAA,IAAAlD,EAAA,EAAAS,EAAA,IAAAC,EAAAT,GAAAU,EACA/I,GAAA,EAAAoI,EAAA,KAAAS,EAAA,GAAAC,EAAA,IAAAT,GAAAa,EACAjJ,GAAA,KAAAmI,EAAA,EAAAS,EAAA,EAAAC,EAAAT,IALAa,EAAAH,GAOAwC,IAAmBzJ,IAAA,IAAAE,MAAAC,QAAAL,KAAAiG,MAAApG,EAAAG,KAAAiG,MAAAnG,GAAAK,IAAAH,KAAAiG,MAAA9F,IAAAa,KAAAhB,KAAAiG,MAAAjF,OACnBqG,EAAAF,GAAAqC,EAAA,GACA,IAAAhK,EAAA6H,EACAuC,EAAA,EACAC,EAAA,EACAC,EAAA1I,KAAAI,IAAAmI,EAAA,GAAAxJ,KACA4J,EAAA3I,KAAAK,IAAAkI,EAAA,GAAAxJ,KAEA,QAAApC,EAAA,EAAmBA,EAAAyL,EAAA,EAAazL,IAAA,CAChC,MAAAoC,KAAA9B,EAAAmB,EAAA,EAAApB,EAAA,GAAAoB,EAAAkK,EAAA,GAAAlK,EAAAiK,GAAAjK,EAAAQ,KAAAiG,MAAA9F,IACAa,IAAA3C,EAAAmB,EAAApB,GAAAoB,EAAAkK,GAAAlK,EAAAiK,EACA7E,EAAAxD,KAAAI,IAAArB,GACA0E,EAAAzD,KAAAK,IAAAtB,GAEAyJ,KAAA7L,EAAA,GAAAA,GAAA6G,EAAAkF,IAAA,EAAA/L,GACA8L,KAAA9L,EAAA,GAAAA,GAAA8G,EAAAkF,IAAA,EAAAhM,GAEA4L,EAAAK,MAAiB9J,IAAA,IAAAE,MAAAC,QAAAb,EAAAoK,EAAA5J,KAAAiG,MAAApG,EAAAL,EAAAqK,EAAA7J,KAAAiG,MAAAnG,GAAAK,MAAAa,SAEjBxB,GAAA6H,EACAyC,EAAAlF,EACAmF,EAAAlF,EAKA,OAFA8E,EAAAK,MAAe9J,IAAA,IAAAE,MAAAC,QAAAL,KAAAkG,IAAArG,EAAAG,KAAAkG,IAAApG,GAAAK,IAAAH,KAAAkG,IAAA/F,IAAAa,KAAAhB,KAAAkG,IAAAlF,OAEf2I,kCC1MAhM,EAAAU,EAAAmH,EAAA,sBAAAyE,IAAA,MAAAC,EAAA,IAEA,IAAA9J,MAAA+J,SACA,IAAA/J,MAAA+J,SACA,IAAA/J,MAAA+J,eAEAF,EACArK,eAAAqE,GACAxF,OAAAyF,eAAAD,EAAAgG,EAAA5K,WAGAO,cACAI,KAAAoK,WACApK,KAAAqK,eACArK,KAAAsK,iBACAtK,KAAAuK,cACAvK,KAAAwK,kBACAxK,KAAAyK,mBAGAC,iBACA,SAAAC,UAAA3K,KAAAqK,aAGAO,mBACA,SAAAD,UAAA3K,KAAAwK,gBAGAK,oBACA,SAAAF,UAAA3K,KAAAyK,iBAGAK,gBACA,OAAA9K,KAAAuK,WAAAQ,OAAA,CAAAC,EAAAhN,IAAAgN,EAAAhN,EAAA,GAGA4B,eAAAqL,EAAAzB,EAAA0B,GACA,MAAAC,KACA,IAAAC,EAAA,EACAC,EAAA,EACAC,EAAA,EACAC,EAAAN,EAEA,KAAAK,EAAAtL,KAAAuK,WAAAa,GAAAG,GAGA,GAFAD,GAAAtL,KAAAuK,WAAAa,KAEAA,GAAApL,KAAAuK,WAAAiB,OACA,OAAAL,EAGA,QAAApN,EAAA,EAAmBA,EAAAyL,EAASzL,IAAA,CAC5B,IAAAyN,EAAAxL,KAAAsK,cAAAc,GAAAC,GACA,KAAAC,EAAAE,EAAAD,GAAA,CAGA,GAFAD,GAAAE,IAEAH,GAAArL,KAAAsK,cAAAc,GAAAI,SACAH,EAAA,IAEAD,GAAApL,KAAAsK,cAAAkB,QACA,OAAAL,EAGAK,EAAAxL,KAAAsK,cAAAc,GAAAC,GAGA,MAAA7E,EAAAS,EAAAC,EAAAT,GAAAzG,KAAAyL,sBAAAL,GACAM,GAAAL,GAAAE,EAAAD,GAAAE,GAAAxL,KAAAsK,cAAAc,GAAAI,OACAtL,EAAAyL,EAAAD,EAAAlF,EAAAS,EAAAC,EAAAT,GACAmF,EAAAC,EAAAH,EAAAlF,EAAAS,EAAAC,EAAAT,GACAtG,EAAAiB,KAAA0K,MAAAF,EAAA9L,EAAA8L,EAAA/L,GACAmB,EAAA+K,EAAAL,EAAAlF,EAAAS,EAAAC,EAAAT,GAEA0E,EAAAnB,MAAoB9J,MAAAC,MAAAa,SACpBuK,GAAAL,EAGA,OAAAC,EAGAvL,4BAAA2B,EAAAyK,EAAA,MACA,MAAAZ,EAAAC,EAAAY,EAAAC,GAAAlM,KAAAmM,mBAAA5K,EAAAyK,GAEA,YAAAZ,EAAA,cAEA,IAAAgB,EACAC,EACAC,EACAf,EAEA,MAAAH,GAAA,GAAAC,EACAe,EAAApM,KAAAqK,YAAAe,GAAAC,GACAgB,EAAArM,KAAAqK,YAAAe,GAAAC,EAAA,GACAiB,EAAA,EACAf,EAAAvL,KAAAsK,cAAAc,GAAAC,QACK,GAAAD,GAAApL,KAAAqK,YAAAmB,OAAA,GAAAH,GAAArL,KAAAqK,YAAAe,GAAAI,OAAA,EACLY,EAAApM,KAAAqK,YAAAe,GAAAC,EAAA,GACAgB,EAAArM,KAAAqK,YAAAe,GAAAC,GACAiB,EAAAJ,EACAX,EAAAU,MACK,CACLG,EAAA,GAAAf,EAAArL,KAAAqK,YAAAe,EAAA,GAAApL,KAAAqK,YAAAe,EAAA,GAAAI,OAAA,GAAAxL,KAAAqK,YAAAe,GAAAC,EAAA,GACAgB,EAAAhB,GAAArL,KAAAqK,YAAAe,GAAAI,OAAA,EAAAxL,KAAAqK,YAAAe,EAAA,MAAApL,KAAAqK,YAAAe,GAAAC,EAAA,GAEA,MAAAkB,EAAAvM,KAAAqK,YAAAe,GAAAC,GACA9J,EAAAT,QAAA0L,IAAAJ,GAAAK,IAAAF,EAAAzL,QAAA0L,IAAAJ,MAAAM,kBAAAH,GAEA,GACAF,EAAAE,EACAD,EAAAJ,EACAX,EAAAU,IAEAG,EAAAG,EACAD,EAAAL,EACAV,EAAAU,EAAAjM,KAAAsK,cAAAc,GAAAC,IAIA,MAAAsB,EAAAvL,KAAAuB,MAAApB,EAAAT,QAAA0L,IAAAJ,GAAAK,IAAAJ,EAAAvL,QAAA0L,IAAAJ,MAAAM,kBAAAL,GAAA,KACAO,EAAAP,EAAAvL,QAAA0L,IAAAJ,GAAA7L,eAAAoM,GAAAlM,IAAA2L,GAKA,OAHAE,GAAAf,EAAAe,GAAAK,EACAvL,KAAAiC,MAAAgJ,EAAAxM,EAAAuM,EAAAvM,IAAA0B,EAAAzB,EAAAsM,EAAAtM,IAAAuM,EAAAvM,EAAAsM,EAAAtM,IAAAyB,EAAA1B,EAAAuM,EAAAvM,IAAA0B,EAAAsL,WAAAD,GAEAxB,GAGAxL,mBAAA2B,EAAAyK,EAAA,MACA,IACAc,EACAC,EACAC,EACAC,EAJAC,EAAAC,OAAAC,kBAMAC,EAAA,EACAf,EAAA,EAEAgB,EAAA,EACAC,EAAAvN,KAAAqK,YAAAmB,OAAA,EAOA,GALA,OAAAQ,IACAsB,EAAAlM,KAAAoM,IAAA,EAAAxB,EAAA,GACAuB,EAAAnM,KAAAqM,IAAAzN,KAAAqK,YAAAmB,OAAA,EAAAQ,EAAA,IAGAsB,EAAA,GACA,QAAAlC,EAAA,EAA+BA,EAAAkC,EAAgClC,IAC/DiC,GAAArN,KAAAuK,WAAAa,GAGAkB,EAAAe,EAAArN,KAAAsK,cAAAgD,EAAA,GAAAtN,KAAAsK,cAAAgD,EAAA,GAAA9B,OAAA,GAGA,QAAAJ,EAAAkC,EAA4ClC,GAAAmC,EAA+BnC,IAAA,CAC3E,MAAAV,EAAA1K,KAAAqK,YAAAe,GACA,QAAAC,EAAA,EAA+BA,EAAAX,EAAAc,OAAiCH,IAAA,CAChE,MAAAqC,EAAAnM,EAAAmL,kBAAAhC,EAAAW,IACAqC,EAAAR,IACAA,EAAAQ,EACAZ,EAAA1B,EACA2B,EAAA1B,EACA2B,EAAAK,EACAJ,EAAAX,GAGAA,EAAAe,EACAA,GAAArN,KAAAsK,cAAAc,GAAAC,IAIA,OAAAyB,EAAAC,EAAAC,EAAAC,GAGArN,UAAA2B,EAAAoM,MACA,MAAAC,EAAA5N,KAAAoK,QAAAJ,KAAAzI,GAAA,EAEA,GAAAoM,EACA,QAAA5P,EAAA6P,EAAA,EAA6B7P,EAAA6P,EAAW7P,IACxCiC,KAAA2N,SAAA5P,GAIA6B,aAAAgO,EAAArM,GACAvB,KAAAoK,QAAAwD,GAAArM,EAEA,QAAAxD,EAAA6P,EAAA,EAA2B7P,GAAA6P,EAAA,EAAgB7P,IAC3CiC,KAAA2N,SAAA5P,GAGA6B,aAAAgO,GACA,GAAAA,EAAA,GAAAA,GAAA5N,KAAAoK,QAAAoB,OAAA,OAEAxL,KAAAoK,QAAAyD,OAAAD,EAAA,GAEA,MAAAE,EAAAF,EAAA5N,KAAAoK,QAAAoB,OAAAoC,IAAA,EACA5N,KAAAqK,YAAAwD,OAAAC,EAAA,GACA9N,KAAAsK,cAAAuD,OAAAC,EAAA,GACA9N,KAAAwK,eAAAqD,OAAAC,EAAA,GACA9N,KAAAyK,gBAAAoD,OAAAC,EAAA,GACA9N,KAAAuK,WAAAsD,OAAAC,EAAA,GAEA,QAAA/P,EAAA+P,EAAA,EAAkC/P,GAAA+P,EAAmB/P,IACrDiC,KAAA2N,SAAA5P,GAGA6B,SAAAgO,GACA,GAAAA,EAAA,GAAAA,EAAA5N,KAAAoK,QAAAoB,OAAA,SAEA,MAAAhF,EAAAS,EAAAC,EAAAT,GAAAzG,KAAAyL,sBAAAmC,GACAG,KACAC,KACApD,KACAC,KACA,IAAAuB,EAAA,KAEA,MAAA6B,EAAA7M,KAAAoM,IAAA,GAAApM,KAAA8M,KAAAjH,EAAA4F,WAAA3F,GAAA,IACAiH,EAAAP,GAAA5N,KAAAoK,QAAAoB,OAAA,EAAAyC,EAAA,EAAAA,EAEA,QAAAlQ,EAAA,EAAmBA,EAAAoQ,EAAepQ,IAAA,CAClC,MAAA0B,EAAA1B,EAAAkQ,EACAG,EAAAzC,EAAAlM,EAAA+G,EAAAS,EAAAC,EAAAT,GACAsH,EAAA/D,KAAAoE,GAEA,MAAAhC,GACA4B,EAAAhE,KAAAoC,EAAAS,WAAAuB,IACAhC,EAAAgC,EAEA,MAAAxC,EAAAC,EAAApM,EAAA+G,EAAAS,EAAAC,EAAAT,GACA4H,EAAA,IAAAjO,MAAAC,SAAAuL,EAAA9L,EAAA8L,EAAA/L,GAEA+K,EAAAZ,KAAAqE,EAAAvN,QAAAP,gBAAA2J,GAAAzJ,IAAA2N,IACAvD,EAAAb,KAAAqE,EAAAvN,QAAAP,eAAA2J,GAAAzJ,IAAA2N,IAGAJ,EAAAhE,KAAAoC,EAAAS,WAAA3F,IAEAlH,KAAAqK,YAAAuD,GAAAG,EACA/N,KAAAsK,cAAAsD,GAAAI,EACAhO,KAAAwK,eAAAoD,GAAAhD,EACA5K,KAAAyK,gBAAAmD,GAAA/C,EACA7K,KAAAuK,WAAAqD,GAAAI,EAAAjD,OAAA,CAAAC,EAAAhN,IAAAgN,EAAAhN,EAAA,GAGA4B,cACA,QAAA7B,EAAA,EAAmBA,EAAAiC,KAAAoK,QAAAoB,OAAyBzN,IAC5CiC,KAAA2N,SAAA5P,GAGA6B,sBAAAgO,GACA,IAAArO,EASA,iBAPAA,EADA,GAAAqO,GACA5N,KAAAoK,QAAA,IAAAO,OAAA3K,KAAAoK,QAAAkE,MAAA,MAEAtO,KAAAoK,QAAAkE,MAAAV,EAAA,EAAAA,EAAA,IAEA,KACArO,EAAA,GAAAA,EAAA,IAEAA,GAIA,SAAAgP,EAAA9O,EAAA+G,EAAAS,EAAAC,EAAAT,GACA,MAAA+H,EAAA,IAAAtH,EAAAV,GACApB,EAAA,IAAAqB,EAAAQ,GACAwH,EAAAhP,IAEA,SAAAwH,EAAA,EAAAC,EAAAsH,EAAApJ,IADA3F,EAAAgP,KACA,EAAAxH,EAAA,EAAAC,EAAA,EAAAsH,EAAApJ,GAAAqJ,EAAAD,EAAA/O,EAAAwH,EAGA,SAAA0E,EAAAlM,EAAA+G,EAAAS,EAAAC,EAAAT,GACA,WAAArG,MAAAC,QAAAkO,EAAA9O,EAAA+G,EAAA3G,EAAAoH,EAAApH,EAAAqH,EAAArH,EAAA4G,EAAA5G,GAAA0O,EAAA9O,EAAA+G,EAAA1G,EAAAmH,EAAAnH,EAAAoH,EAAApH,EAAA2G,EAAA3G,IAGA,SAAA+L,EAAApM,EAAA+G,EAAAS,EAAAC,EAAAT,GAEA,IAAAiI,EAAAjP,EADA,KAEAgP,EAAAhP,EAFA,KAIAiP,EAAA,IAAAA,EAAA,GACAD,EAAA,IAAAA,EAAA,GAEA,MAAAE,EAAAhD,EAAA+C,EAAAlI,EAAAS,EAAAC,EAAAT,GAGA,OAFAkF,EAAA8C,EAAAjI,EAAAS,EAAAC,EAAAT,GAEA+F,IAAAmC,GAAAC,YAGA,SAAA7C,EAAA0C,EAAAjI,EAAAS,EAAAC,EAAAT,GAKA,GAAAgI,MAJA,MAKA,GAAAA,MAAA,OAEA,IAAAC,EAAAD,EAPA,KAQAI,EAAAJ,EARA,KAUAC,EAAA,IAAAA,EAAA,GACAG,EAAA,IAAAA,EAAA,GAEA,MAAAC,EAAAnD,EAAA+C,EAAAlI,EAAAS,EAAAC,EAAAT,GACAsI,EAAApD,EAAA8C,EAAAjI,EAAAS,EAAAC,EAAAT,GACAuI,EAAArD,EAAAkD,EAAArI,EAAAS,EAAAC,EAAAT,GAEA,OAAArF,KAAA0K,MAAAkD,EAAAlP,EAAAiP,EAAAjP,EAAAkP,EAAAnP,EAAAkP,EAAAlP,GAAAuB,KAAA0K,MAAAiD,EAAAjP,EAAAgP,EAAAhP,EAAAiP,EAAAlP,EAAAiP,EAAAjP,IAAAkP,EAAAlC,WAAAiC,kCCjTAnR,EAAAU,EAAAmH,EAAA,sBAAAyJ,IACA,MAAAC,GAAsB9K,EAAA,IAAAC,EAAA,GACtB8K,GAAsB/K,EAAA,IAAAC,EAAA,IACtB+K,GAAyBhL,EAAA,GAAAC,EAAA,UAEzB4K,EACArP,eAAAqE,GACAxF,OAAAyF,eAAAD,EAAAgL,EAAA5P,WACAZ,OAAAyF,eAAAD,EAAAoL,SAAAjP,MAAAC,QAAAhB,WACAZ,OAAAyF,eAAAD,EAAAlD,SAAAX,MAAAC,QAAAhB,WAGAO,YAAA0P,EAAAD,EAAAtO,EAAAwO,GAMA,OALAvP,KAAAsP,OACAtP,KAAAqP,WACArP,KAAAe,WACAf,KAAAuP,WAEAD,GACA,cACAtP,KAAAwP,KAAA/Q,OAAA2H,UAAsC+I,GACtC,MAEA,iBACAnP,KAAAwP,KAAA/Q,OAAA2H,UAAsCgJ,GACtC,MAEA,QACApP,KAAAwP,KAAA/Q,OAAA2H,UAAsC8I,GAGtCK,KACAvP,KAAAwP,KAAApL,EAAApE,KAAAwP,KAAAnL,IAAArE,KAAAwP,KAAAnL,EAAArE,KAAAwP,KAAApL,IAGAxE,eAAA6P,GACA,OAAAzP,KAAAe,SAAAD,QAAAP,eAAAkP,GAAAhP,IAAAT,KAAAqP,UAGAzP,qBAAA8P,EAAAC,EAAAC,GACA,MAAA7N,GAAA4N,EAAAD,GAAAE,EACAC,KACA,IAAAJ,EAAAC,EAEA,QAAA3R,EAAA,EAAmBA,GAAA6R,EAAgB7R,IACnC8R,EAAA7F,KAAAhK,KAAA8P,eAAAL,IACAA,GAAA1N,EAGA,OAAA8N,EAGAjQ,oBAAA8P,EAAAC,EAAAI,GACA,MAAAF,EAAA7P,KAAAgQ,qBAAAN,EAAAC,EAAAI,EAAAE,qBACAtL,KAGAuL,EAAAlQ,KAAAwP,KAAApL,EAAA2L,EAAAI,uBAAAJ,EAAAK,mBACAC,EAAArQ,KAAAwP,KAAAnL,EAAA0L,EAAAO,uBAAAP,EAAAQ,mBAEAV,EAAAW,QAAAjR,IACA,MAAA6F,IAAA8K,EAAA3Q,EAAAM,EAAAwQ,EAAA9Q,EAAAO,GACAuF,GAAA6K,EAAA3Q,EAAAM,EAAAwQ,EAAA9Q,EAAAO,GACAwF,GAAA4K,EAAA3Q,EAAAM,GAAAwQ,EAAA9Q,EAAAO,GACAyF,IAAA2K,EAAA3Q,EAAAM,GAAAwQ,EAAA9Q,EAAAO,GAEA6E,EAAAqF,KACA5E,EAAA,GAAAA,EAAA,OACAC,EAAA,GAAAA,EAAA,OACAC,EAAA,GAAAA,EAAA,OACAA,EAAA,GAAAA,EAAA,OACAC,EAAA,GAAAA,EAAA,OACAH,EAAA,GAAAA,EAAA,UAKA,MAAAqL,EAAAzQ,KAAAwP,KAAApL,EAAA2L,EAAAK,mBACAM,EAAA1Q,KAAAwP,KAAAnL,EAAA0L,EAAAQ,mBAkBA,OAhBAV,EAAAW,QAAAjR,IACA,MAAA6F,IAAAqL,EAAAlR,EAAAM,EAAA6Q,EAAAnR,EAAAO,GACAuF,GAAAoL,EAAAlR,EAAAM,EAAA6Q,EAAAnR,EAAAO,GACAwF,GAAAmL,EAAAlR,EAAAM,GAAA6Q,EAAAnR,EAAAO,GACAyF,IAAAkL,EAAAlR,EAAAM,GAAA6Q,EAAAnR,EAAAO,GAEA6E,EAAAqF,KACA5E,EAAA,GAAAA,EAAA,OACAC,EAAA,GAAAA,EAAA,OACAC,EAAA,GAAAA,EAAA,OACAA,EAAA,GAAAA,EAAA,OACAC,EAAA,GAAAA,EAAA,OACAH,EAAA,GAAAA,EAAA,UAIAT,kCChGAhH,EAAAU,EAAAmH,EAAA,sBAAAmL,IAwBA,MAAAC,EAAA,sLAWAC,EAAA,0QAaAF,EACA/Q,aAAA4P,EAAAsB,GACA,IAAA3D,OAAA4D,UAAAD,MAAA,GAAAA,EAAA,EACA,UAAAE,MAAA,mDAGA,MAAAC,EAAA7P,KAAA8P,IAAA9P,KAAA8M,KAAA9M,KAAA+P,KAAA3B,IAAA,GAEA4B,EAAA,IAAAC,aAAAJ,EAAAH,GAGA,OAFAM,EAAAE,UAAA9B,EACA4B,EAAAG,YAAAT,EACAM,EAGAxR,YAAA4R,EAAAC,MACAzR,KAAA0R,WAEA1R,KAAA2R,kBACA3R,KAAA4R,kBAEA5R,KAAA6R,SAAAL,EAAAM,IAAA1T,GAAA4B,KAAA+R,gBAAA3T,IAEA,UAAAE,KAAAmT,EAAA,CACA,MAAAO,EAAAP,EAAAnT,IACAgG,MAAaA,EAAAC,SAAA0N,WAAAb,QAAgCY,EAC7ChS,KAAA4R,eAAAtT,GAAA0B,KAAAkS,eAAAd,EAAA9M,EAAAC,EAAA0N,EAAAD,IAIApS,qBAAA6R,GACAzR,KAAA4R,kBAEA,UAAAtT,KAAAmT,EAAA,CACA,MAAAO,EAAAP,EAAAnT,IACAgG,MAAaA,EAAAC,SAAA0N,WAAAb,QAAgCY,EAC7ChS,KAAA4R,eAAAtT,IAAA0B,KAAAmS,GAAAC,cAAApS,KAAA4R,eAAAtT,IACA0B,KAAA4R,eAAAtT,GAAA0B,KAAAkS,eAAAd,EAAA9M,EAAAC,EAAA0N,EAAAD,IAIApS,cAAAyS,EAAAtC,GACA,MAAAuC,EAAA,iBAAA7S,EAAAO,KAAA6R,SAAAQ,KAEA,IAAAC,EACA,UAAAtB,4BAA4CqB,qBAE5C,GAAAtC,EAAAwC,OACA,UAAAvB,MAAA,oGAEAjB,EAAAyC,OACAF,EAAAE,KAAA/T,OAAA2H,OAAAkM,EAAAE,KAAAzC,EAAAyC,gBAEAzC,EAAAzL,gBAAAyL,EAAAxL,QACAvE,KAAAyS,kBAAAH,EAAAvC,EAAAzL,MAAAyL,EAAAxL,QAEA,iBAAAwL,EAAA2C,UACA1S,KAAA2S,sBAAAL,EAAAvC,EAAA2C,UAGA9S,oBAAAgT,EAAAL,GACA,MAAAD,EAAAtS,KAAA6R,SAAAe,GAEA,IAAAN,EACA,UAAAtB,4BAA4C4B,qBAE5C,GAAAN,EAAAO,cAAArH,QAAA+G,EAAA/G,OACA,UAAAwF,wFAAwGuB,EAAA/G,uBAA8B8G,EAAAO,cAAArH,WAEtI,MAAAsH,EAAAR,EAAAS,WACAC,EAAAV,EAAAW,YAEAlD,EAAAuC,EAAAvC,gBAEAA,EAAAzL,gBAAAyL,EAAAxL,SACA+N,EAAAS,kBACAT,EAAAW,mBACAX,EAAAY,sBAGAlT,KAAAmT,sBAAAb,EAAAC,GAEAD,EAAAS,YAAAD,GAAAR,EAAAW,aAAAD,IACAhT,KAAAmS,GAAAiB,WAAAd,EAAAe,WACArT,KAAAmS,GAAAmB,UAAAhB,EAAAiB,mBAAAjB,EAAAS,WAAAT,EAAAW,aACAjT,KAAAwT,sBAAAlB,IAIA1S,kBAAAyS,EAAA/N,EAAAC,GACA,MAAA+N,EAAA,iBAAA7S,EAAAO,KAAA6R,SAAAQ,KAEA,IAAAC,EACA,UAAAtB,4BAA4CqB,qBAE5C,MAAAC,EAAAO,cAAArH,OACA,UAAAwF,MAAA,wDAEA1M,GAAAgO,EAAAS,YAAAxO,GAAA+N,EAAAW,cAEAX,EAAAS,WAAAzO,EACAgO,EAAAW,YAAA1O,EACA+N,EAAAY,cAAA5O,EAAAC,EAEAvE,KAAAmS,GAAAiB,WAAAd,EAAAe,WACArT,KAAAmS,GAAAmB,UAAAhB,EAAAiB,mBAAAjB,EAAAS,WAAAT,EAAAW,aACAjT,KAAAwT,sBAAAlB,IAGA1S,sBAAAyS,EAAAK,GACA,MAAAJ,EAAA,iBAAA7S,EAAAO,KAAA6R,SAAAQ,KAGA,GAFArS,KAAAmS,GAAAiB,WAAAd,EAAAe,YAEAf,EACA,UAAAtB,4BAA4CqB,qBAE5C,UAAAoB,KAAAf,EAAA,CACA,MAAA3T,EAAA2T,EAAAe,GACA,IAAAC,EAEA,GAAAA,EAAApB,EAAAI,SAAAe,GACAzT,KAAA2T,YAAAD,EAAApE,KAAAoE,EAAAE,SAAA7U,OACO,MAAA2U,EAAApB,EAAAuB,gBAAAJ,IAQP,UAAAzC,qBAAuCyC,qCARhC,CACP,oBAAA3U,GAAA,WAAAC,EAAAuQ,KACA,UAAA0B,2CAA+DyC,MAE/D,MAAAnP,MAAeA,EAAAC,SAAA0N,WAAAb,QAAgCsC,EAC/CpB,EAAAuB,gBAAAJ,GAAAK,SAAA9T,KAAAmS,GAAAC,cAAAE,EAAAuB,gBAAAJ,GAAAK,SACAxB,EAAAuB,gBAAAJ,GAAAK,QAAA9T,KAAAkS,eAAAd,EAAA9M,EAAAC,EAAA0N,EAAAyB,MAOA9T,MACA,MAAAmU,KAEA,UAAAzB,KAAAtS,KAAA6R,SAAA,CACA7R,KAAAmS,GAAAiB,WAAAd,EAAAe,WACArT,KAAAmS,GAAA6B,SAAA,IAAA1B,EAAAS,WAAAT,EAAAW,aACAjT,KAAAmS,GAAA8B,gBAAAjU,KAAAmS,GAAA+B,YAAA5B,EAAA6B,aAEA,UAAAvG,EAAAwG,KAAA9B,EAAAO,cAAAwB,UACArU,KAAAmS,GAAAmC,cAAAtU,KAAAmS,GAAAoC,SAAA3G,GACA5N,KAAAmS,GAAAqC,YAAAxU,KAAAmS,GAAAsC,WAAAL,GAGA,UAAAX,KAAAnB,EAAAuB,gBAAA,CACA,MAAAa,EAAApC,EAAAuB,gBAAAJ,GACAzT,KAAAmS,GAAAmC,cAAAtU,KAAAmS,GAAAoC,SAAAG,EAAA9G,OACA5N,KAAAmS,GAAAqC,YAAAE,EAAAC,OAAAD,EAAAZ,SAAA9T,KAAA4R,eAAA8C,EAAApW,OAAA0B,KAAA2R,eAAA+C,EAAApW,OAGA,sBAAAgU,EAAAsC,KACAtC,EAAAsC,KAAA5U,KAAAsS,QAUA,GARAtS,KAAAmS,GAAA0C,WAAA7U,KAAAmS,GAAA2C,aAAA9U,KAAA+U,eACA/U,KAAAmS,GAAA6C,wBAAA1C,EAAA2C,iBACAjV,KAAAmS,GAAA+C,oBAAA5C,EAAA2C,gBAAA,EAAAjV,KAAAmS,GAAAgD,SAAA,KACAnV,KAAAmS,GAAA0C,WAAA7U,KAAAmS,GAAA2C,aAAA9U,KAAAoV,gBACApV,KAAAmS,GAAA6C,wBAAA1C,EAAA+C,kBACArV,KAAAmS,GAAA+C,oBAAA5C,EAAA+C,iBAAA,EAAArV,KAAAmS,GAAAgD,SAAA,KACAnV,KAAAmS,GAAA0C,WAAA7U,KAAAmS,GAAAmD,qBAAAtV,KAAAuV,aAEAjD,EAAAkD,UAAA,CACA,MAAAZ,OAAA5U,KAAAmS,GAAAsD,aAAAzV,KAAAmS,GAAAuD,UAAA,EAAA1V,KAAAmS,GAAAwD,eAAA,IAAAC,KAAA5V,MACAsS,EAAAkD,UAAAxV,KAAAsS,EAAAsC,QAEA5U,KAAAmS,GAAAsD,aAAAzV,KAAAmS,GAAAuD,UAAA,EAAA1V,KAAAmS,GAAAwD,eAAA,GAIA,GAAArD,EAAAuD,QAAAvD,EAAAuD,OAAAvX,OAAAgU,EAAAuD,OAAAC,KACA/B,EAAA/J,KAAA,UACO,CACP,MAAA6L,EAAA,IAAAxE,aAAAiB,EAAAS,WAAAT,EAAAW,YAAA,GACAjT,KAAAmS,GAAA4D,WAAA,IAAAzD,EAAAS,WAAAT,EAAAW,YAAAjT,KAAAmS,GAAA6D,KAAAhW,KAAAmS,GAAAgD,MAAAU,GACA9B,EAAA/J,KAAA6L,EAAAI,SAAA,IAAA3D,EAAAY,iBAIA,OAAAa,EAGAnU,WACA,IAAAsW,EAEA,GAAAC,KAAAC,SACAF,EAAAE,SAAAC,cAAA,cACA,KAAAF,KAAAG,gBAGA,UAAAtF,MAAA,8BAFAkF,EAAA,IAAAI,gBAAA,KAIA,MAAAC,GAAkBC,SAAAC,cAGlB,GAFAzW,KAAAmS,GAAA+D,EAAAQ,WAAA,SAAAH,IAAAL,EAAAQ,WAAA,sBAAAH,IAEAvW,KAAAmS,GACA,UAAAnB,MAAA,iEAEA,IAAAhR,KAAAmS,GAAAwE,aAAA,0BACA,UAAA3F,MAAA,kEAEA,IAAAhR,KAAAmS,GAAAwE,aAAA,4BACA,UAAA3F,MAAA,oEAEAhR,KAAAoV,eAAApV,KAAA4W,aAAA,qBACA5W,KAAA+U,cAAA/U,KAAA4W,YAAA,kBACA5W,KAAAuV,YAAAvV,KAAA4W,YAAA,aAAAC,YAAA7W,KAAAmS,GAAAmD,sBAGA1V,gBAAAmQ,GACA,MAAAuC,GAAqBvC,UAErBuC,EAAAsC,KAAA7E,EAAA6E,KACAtC,EAAAkD,UAAAzF,EAAAyF,UACAlD,EAAAE,KAAA/T,OAAA2H,UAAmC2J,EAAAyC,MAEnCzC,EAAAzL,OAAAyL,EAAAxL,SACA+N,EAAAS,WAAAhD,EAAAzL,MACAgO,EAAAW,YAAAlD,EAAAxL,OACA+N,EAAAY,cAAAnD,EAAAzL,MAAAyL,EAAAxL,QAGA+N,EAAAuD,OAAA9F,EAAA8F,OAEA,MAAAiB,EAAA/G,EAAA+G,OAEA,oBAAApX,GAAA,GAAAoX,EAAAtL,OACA,UAAAwF,MAAA,gCAEA,MAAAuB,EAAAxC,EAAAwC,WACAG,EAAA3C,EAAA2C,aAEA1S,KAAAmT,sBAAAb,EAAAC,GAEA,IAAAwE,EAAA,GAEA,UAAAnJ,KAAA2E,EACAwE,8BAAyDnJ,OAEzD,YAAA0E,EAAAS,qBAAAT,EAAAW,YACA,UAAAjC,MAAA,sHAEAsB,EAAAuB,mBACAvB,EAAAI,YAEA,UAAAe,KAAAf,EAAA,CACA,MAAAgB,EAAAhB,EAAAe,GAEA,oBAAA/T,EACA4S,EAAAI,SAAAe,IACAnE,KAAA,QACAvQ,MAAA2U,GAEAqD,oBAAiDtD,YAC1C,GAAAuD,MAAAC,QAAAvD,GAAA,CACP,GAAAA,EAAAlI,OAAA,GAAAkI,EAAAlI,OAAA,EACA,UAAAwF,MAAA,wGAEA,MAAA1B,GAAA,sBAAAoE,EAAAlI,OAAA,GACA8G,EAAAI,SAAAe,IACAnE,OACAvQ,MAAA2U,GAEAqD,cAA2CzH,KAAQmE,WAC5C,CACP,MAAAnE,KAAeA,EAAAhL,QAAAC,SAAA0N,WAAAb,OAAArS,QAAAyM,SAAAlN,QAA2DoV,EAE1E,cAAApE,GAAA,iBAAAA,GAAA,iBAAAA,EAAA,CACA,IAAAqF,EAAArF,EAEA,MAAAoE,EAAAwD,aACAvC,EAAA3U,KAAAmS,GAAAgF,WACA7H,EAAA,aACW,WAAAoE,EAAAwD,aACXvC,EAAA3U,KAAAmS,GAAAiF,iBACA9H,EAAA,mBAEAqF,EAAA3U,KAAAmS,GAAAsC,WACAnF,EAAA,aAIAgD,EAAAuB,gBAAAJ,GADA,WAAAnE,GACoDqF,SAAAb,QAAA1C,EAAApR,KAAAkS,eAAAd,EAAA9M,EAAAC,EAAA0N,EAAAyB,GAAA,OAEAiB,SAAAb,QAAA,KAAAxV,QAAAmV,GAGpDsD,cAA6CzH,KAAQmE,YAErDnB,EAAAI,SAAAe,IAA2CnE,OAAAvQ,SAE3CgY,YADAvL,aAC+C8D,KAAQmE,KAAejI,mBAEvB8D,KAAQmE,QAKvD,MAAA4D,EAAArX,KAAAmS,GAAAmF,aAAAtX,KAAAmS,GAAAoF,eAIA,GAHAvX,KAAAmS,GAAAqF,aAAAH,EAAAtH,EAAAsH,cAAAzG,GACA5Q,KAAAmS,GAAAsF,cAAAJ,IAEArX,KAAAmS,GAAAuF,mBAAAL,EAAArX,KAAAmS,GAAAwF,gBACA,UAAA3G,MACA,iEACAjB,EAAAsH,cAAAzG,GAAA,0BACA5Q,KAAAmS,GAAAyF,iBAAAP,IAIA,MAAAQ,oDAE4Bb,MAAAzE,EAAA/G,QAAAsM,QAAAhG,IAAA/T,oBAA2DA,sBAAEga,KAAA,oBAIzFC,EAAAhY,KAAAmS,GAAAmF,aAAAtX,KAAAmS,GAAA8F,iBACAC,EAAArH,EAAAkG,EAAAD,EAAAe,EAIA,GAHA7X,KAAAmS,GAAAqF,aAAAQ,EAAAE,GACAlY,KAAAmS,GAAAsF,cAAAO,IAEAhY,KAAAmS,GAAAuF,mBAAAM,EAAAhY,KAAAmS,GAAAwF,gBAAA,CACA,MAAAQ,EAAAD,EAAAE,MAAA,MACA,IAAAC,EAAA,qGAEA,QAAAra,EAAA,EAAqBA,EAAAma,EAAA3M,OAAmBxN,IACxCqa,MAAqBra,EAAA,MAAUma,EAAAna,OAI/B,MAFAqa,GAAA,6DAAArY,KAAAmS,GAAAyF,iBAAAI,GAEA,IAAAhH,MAAAqH,GASA,GANA/F,EAAAe,UAAArT,KAAAmS,GAAAmG,gBACAtY,KAAAmS,GAAAoG,aAAAjG,EAAAe,UAAAgE,GACArX,KAAAmS,GAAAoG,aAAAjG,EAAAe,UAAA2E,GACAhY,KAAAmS,GAAAqG,YAAAlG,EAAAe,WACArT,KAAAmS,GAAAiB,WAAAd,EAAAe,YAEArT,KAAAmS,GAAAsG,oBAAAnG,EAAAe,UAAArT,KAAAmS,GAAAuG,aACA,UAAA1H,MAAA,qCAEA,IAAA2H,EAAA,EAEA,UAAAC,KAAAtG,EAAAO,cAAA,CACA,MAAAe,EAAA5T,KAAAmS,GAAA0G,mBAAAvG,EAAAe,mBAA8EsF,KAC9E3Y,KAAAmS,GAAA2G,UAAAlF,EAAA+E,GACAA,IAGA,UAAAlF,KAAAnB,EAAAuB,gBAAA,CACAvB,EAAAuB,gBAAAJ,GAAA7F,MAAA+K,EACA,MAAA/E,EAAA5T,KAAAmS,GAAA0G,mBAAAvG,EAAAe,UAAAI,GACAzT,KAAAmS,GAAA2G,UAAAlF,EAAA+E,GACAA,IAGA,UAAAlF,KAAAnB,EAAAI,SAAA,CACA,MAAApD,KAAaA,EAAAvQ,SAAcuT,EAAAI,SAAAe,GAC3BG,EAAAtB,EAAAI,SAAAe,GAAAG,SAAA5T,KAAAmS,GAAA0G,mBAAAvG,EAAAe,UAAAI,YAEA1U,GACAiB,KAAA2T,YAAArE,EAAAsE,EAAA7U,UAEAuT,EAAAI,SAAAe,GAAA1U,MAYA,OATAuT,EAAAiB,mBAAAvT,KAAAmS,GAAA0G,mBAAAvG,EAAAe,UAAA,cACArT,KAAAmS,GAAAmB,UAAAhB,EAAAiB,mBAAAjB,EAAAS,WAAAT,EAAAW,aAEAX,EAAA+C,iBAAArV,KAAAmS,GAAA4G,kBAAAzG,EAAAe,UAAA,YACAf,EAAA2C,gBAAAjV,KAAAmS,GAAA4G,kBAAAzG,EAAAe,UAAA,WAEAf,EAAA6B,YAAAnU,KAAAmS,GAAA6G,oBACAhZ,KAAAwT,sBAAAlB,GAEAA,EAGA1S,sBAAA0S,EAAAC,GACAD,EAAAO,eACAP,EAAAO,cAAArC,QAAA/Q,GAAAO,KAAAmS,GAAAC,cAAA3S,IAEA6S,EAAAO,iBAEA,UAAAjF,EAAAwD,KAAAmB,EAAA8B,UAAA,CACA,YAAAjD,EAAAE,oBAAAF,EAAAG,YACA,UAAAP,MAAA,yDAEA,MAAAxB,EAAApO,KAAA+P,KAAAC,EAAA5F,OAAA4F,EAAAG,aACA,GAAA/B,GAAA,GAAAA,EAAA,KACA,UAAAwB,MAAA,wDAEA,YAAAsB,EAAAS,qBAAAT,EAAAW,YACAX,EAAAS,WAAAvD,EACA8C,EAAAW,YAAAzD,EACA8C,EAAAY,cAAA9B,EAAAE,eACO,GAAA9B,GAAA8C,EAAAS,YAAAvD,GAAA8C,EAAAW,YACP,UAAAjC,6DAA+EI,EAAAE,uBAA4B9B,qBAA6B8C,EAAAY,2BAAmCZ,EAAAS,WAAAT,EAAAW,iBAG3KX,EAAAO,cAAA7I,KAAAhK,KAAAkS,eAAAd,EAAA5B,IAAA4B,EAAAG,eAIA3R,sBAAA0S,GACAtS,KAAAmS,GAAA8B,gBAAAjU,KAAAmS,GAAA+B,YAAA5B,EAAA6B,aAEA,MAAA8E,EAAAjZ,KAAAkS,eAAA,KAAAI,EAAAS,WAAAT,EAAAW,YAAA,EAAAX,EAAAuD,QAEA,GAAAvD,EAAAuD,QAAA,OAAAvD,EAAAuD,OAAAqB,aAAA,YAAA5E,EAAAuD,OAAAqB,cACAlX,KAAAmS,GAAA+G,qBAAAlZ,KAAAmS,GAAA+B,YAAAlU,KAAAmS,GAAAgH,kBAAAnZ,KAAAmS,GAAAsC,WAAAwE,EAAA,GACAjZ,KAAAmS,GAAAiH,uBAAApZ,KAAAmS,GAAA+B,cAAAlU,KAAAmS,GAAAkH,sBAEA,UAAArI,MAAA,gGAGAsB,EAAA2G,eACAjZ,KAAAmS,GAAAC,cAAAE,EAAA2G,eACA3G,EAAA2G,gBAEA3G,EAAAuD,QAAAvD,EAAAuD,OAAAvX,OACA0B,KAAA2R,eAAAW,EAAAuD,OAAAvX,MAAA2a,GAGArZ,YAAA0P,EAAAsE,EAAA7U,GACA,OAAAuQ,GACA,UAAAtP,KAAAmS,GAAA2G,UAAAlF,EAAA7U,GAAqD,MACrD,YAAAiY,MAAAC,QAAAlY,GAAAiB,KAAAmS,GAAAmH,WAAA1F,EAAA7U,GAAAiB,KAAAmS,GAAAoH,UAAA3F,EAAA7U,GAAoH,MACpH,WAAAiB,KAAAmS,GAAAqH,WAAA5F,EAAA7U,GAAuD,MACvD,WAAAiB,KAAAmS,GAAAsH,WAAA7F,EAAA7U,GAAuD,MACvD,WAAAiB,KAAAmS,GAAAuH,WAAA9F,EAAA7U,GAAuD,MACvD,WAAAiB,KAAAmS,GAAAwH,iBAAA/F,EAAA7U,GAA6D,MAC7D,kBAAAiS,8BAAuD1B,OAIvD1P,WAAAwR,EAAAwI,EAAAjF,GACA,MAAAkF,EAAA7Z,KAAAmS,GAAA2H,eAKA,OAHA9Z,KAAAmS,GAAA0C,WAAAF,GAAA3U,KAAAmS,GAAA2C,aAAA+E,GACA7Z,KAAAmS,GAAA4H,WAAApF,GAAA3U,KAAAmS,GAAA2C,aAAA,IAAA8E,GAAAvI,cAAAD,GAAApR,KAAAmS,GAAA6H,aAEAH,EAGAja,eAAAwR,EAAA9M,EAAAC,EAAA0N,EAAAD,MACA,MAAA8B,EAAA9T,KAAAmS,GAAA8H,gBAEA,IAAAC,EAAAC,EAEA,OAAAlI,GACA,OACAiI,EAAAla,KAAAmS,GAAAiI,KACAD,EAAAna,KAAAmS,GAAAkI,IACA,MACA,OACAH,EAAAla,KAAAmS,GAAAmI,MACAH,EAAAna,KAAAmS,GAAAoI,GACA,MACA,OACAL,EAAAla,KAAAmS,GAAAqI,OACAL,EAAAna,KAAAmS,GAAAsI,IACA,MACA,OACAP,EAAAla,KAAAmS,GAAAuI,QACAP,EAAAna,KAAAmS,GAAA6D,KACA,MACA,QACA,8CAGA,MAAArB,EAAA,MAAA3C,EAAAkF,YAAAlX,KAAAmS,GAAAgF,WAAA,WAAAnF,EAAAkF,YAAAlX,KAAAmS,GAAAiF,iBAAApX,KAAAmS,GAAAsC,WAiBA,OAfAzU,KAAAmS,GAAAqC,YAAAG,EAAAb,GACA9T,KAAAmS,GAAAwI,cAAAhG,EAAA3U,KAAAmS,GAAAyI,eAAA5a,KAAAmS,GAAA0I,eACA7a,KAAAmS,GAAAwI,cAAAhG,EAAA3U,KAAAmS,GAAA2I,eAAA9a,KAAAmS,GAAA0I,eACA7a,KAAAmS,GAAAwI,cAAAhG,EAAA3U,KAAAmS,GAAA4I,eAAA/a,KAAAmS,GAAA0I,eACA7a,KAAAmS,GAAAwI,cAAAhG,EAAA3U,KAAAmS,GAAA6I,mBAAA,UAAAhJ,EAAAiJ,OAAAjb,KAAAmS,GAAA+I,OAAAlb,KAAAmS,GAAAgJ,SACAnb,KAAAmS,GAAAwI,cAAAhG,EAAA3U,KAAAmS,GAAAiJ,mBAAA,UAAApJ,EAAAiJ,OAAAjb,KAAAmS,GAAA+I,OAAAlb,KAAAmS,GAAAgJ,SAEA,MAAAnJ,EAAAkF,aAAA,WAAAlF,EAAAkF,YACAlX,KAAAmS,GAAAkJ,WAAA1G,EAAA,EAAAuF,EAAA5V,EAAAC,EAAAyN,EAAAsJ,MAAA,EAAAnB,EAAAna,KAAAmS,GAAAgD,MAAA/D,GAEApR,KAAAmS,GAAAoJ,WAAA5G,EAAA,EAAAuF,EAAA5V,EAAAC,EAAA,EAAA4V,EAAAna,KAAAmS,GAAAgD,MAAA/D,GAGApR,KAAAmS,GAAAqC,YAAAG,EAAA,MAEAb,iEC3hBA0H,EACA5b,YAAAqG,EAAAC,EAAAC,GACAnG,KAAAiG,MAAAxH,OAAA2H,UAAiCH,GACjCjG,KAAAkG,IAAAzH,OAAA2H,UAA+BF,GAE/BD,EAAA/F,MACAF,KAAAiG,MAAApG,EAAAoG,EAAA/F,IAAAL,EACAG,KAAAiG,MAAAnG,EAAAmG,EAAA/F,IAAAJ,GAGAoG,EAAAhG,MACAF,KAAAkG,IAAArG,EAAAqG,EAAAhG,IAAAL,EACAG,KAAAkG,IAAApG,EAAAoG,EAAAhG,IAAAJ,GAGA,MAAAuG,EAAArG,KAAAkG,IAAArG,EAAAG,KAAAiG,MAAApG,EACAyG,EAAAtG,KAAAkG,IAAApG,EAAAE,KAAAiG,MAAAnG,EACA+E,EAAAzD,KAAAK,IAAAzB,KAAAiG,MAAA9F,KACAyE,EAAAxD,KAAAI,IAAAxB,KAAAiG,MAAA9F,KAEAH,KAAAuG,MACA1G,EAAA+E,EAAAyB,EAAAxB,EAAAyB,EACAxG,GAAA+E,EAAAwB,EAAAzB,EAAA0B,EACAnG,IAAAiB,KAAAQ,UAAA5B,KAAAkG,IAAA/F,IAAAH,KAAAiG,MAAA9F,KACAa,KAAAhB,KAAAkG,IAAAlF,MAGAhB,KAAAmG,OAAA1H,OAAA2H,UAAkCD,GAAWK,GAAAxG,KAAAiG,MAAAjF,KAAAiG,GAAAjH,KAAAiG,MAAA/E,OAAA,EAAAgG,GAAAlH,KAAAiG,MAAA9E,QAAA,EAAAsa,GAAAzb,KAAAkG,IAAAlF,OAG7CpB,UAAA4J,GACA,MAAAhD,GAAWA,EAAAS,KAAAC,KAAAT,KAAAiV,KAAAD,KAAAtU,MAA6BnH,KAAAmG,OAExCmB,EAAAH,IACAI,EAAAD,EAAAH,EAEAsC,EAAAjD,EACAkD,EAAAzC,EACA7I,EAAA8I,EAAA,EACA7I,IAAA,OAAAmI,EAAA,GAAAC,EAAA,OAAAiV,EAAAD,EAAA,MAAAxU,EAAAE,EAAA,KAAAD,EAAAI,GAAAC,EACA7H,GAAA,MAAA8G,EAAA,MAAAC,EAAA,KAAAiV,EAAA,IAAAD,EAAA,GAAAxU,EAAAE,EAAA,IAAAD,EAAAI,SACAqU,IAAA,OAAAnV,EAAA,MAAAC,EAAA,OAAAiV,EAAA,IAAAD,EAAA,MAAAxU,EAAAE,EAAA,KAAAD,EAAAI,MAAAC,GAEAoC,IAAmBzJ,IAAA,IAAAE,MAAAC,QAAAL,KAAAiG,MAAApG,EAAAG,KAAAiG,MAAAnG,GAAAK,IAAAH,KAAAiG,MAAA9F,IAAAa,KAAAhB,KAAAiG,MAAAjF,OACnBqG,EAAAF,GAAAqC,EAAA,GACA,IAAAhK,EAAA6H,EACAuC,EAAA,EACAC,EAAA,EACAC,EAAA1I,KAAAI,IAAAmI,EAAA,GAAAxJ,KACA4J,EAAA3I,KAAAK,IAAAkI,EAAA,GAAAxJ,KAEA,QAAApC,EAAA,EAAmBA,EAAAyL,EAAA,EAAazL,IAAA,CAChC,MAAAoC,OAAAwb,EAAAnc,EAAA,EAAAE,EAAA,GAAAF,EAAAnB,EAAA,GAAAmB,EAAApB,EAAA,GAAAoB,EAAAkK,EAAA,GAAAlK,EAAAiK,GAAAjK,EAAAQ,KAAAiG,MAAA9F,IACAa,MAAA2a,EAAAnc,EAAAE,GAAAF,EAAAnB,GAAAmB,EAAApB,GAAAoB,EAAAkK,GAAAlK,EAAAiK,EACA7E,EAAAxD,KAAAI,IAAArB,GACA0E,EAAAzD,KAAAK,IAAAtB,GAEAyJ,KAAA7L,EAAA,GAAAA,GAAA6G,EAAAkF,IAAA,EAAA/L,GACA8L,KAAA9L,EAAA,GAAAA,GAAA8G,EAAAkF,IAAA,EAAAhM,GAEA4L,EAAAK,MAAiB9J,IAAA,IAAAE,MAAAC,QAAAb,EAAAoK,EAAA5J,KAAAiG,MAAApG,EAAAL,EAAAqK,EAAA7J,KAAAiG,MAAAnG,GAAAK,MAAAa,SAEjBxB,GAAA6H,EACAyC,EAAAlF,EACAmF,EAAAlF,EAKA,OAFA8E,EAAAK,MAAe9J,IAAA,IAAAE,MAAAC,QAAAL,KAAAkG,IAAArG,EAAAG,KAAAkG,IAAApG,GAAAK,IAAAH,KAAAkG,IAAA/F,IAAAa,KAAAhB,KAAAkG,IAAAlF,OAEf2I,GCtDA,IAAAiS,EACAC,EAGA,IAAAC,GACAC,MAAA,MAEAjF,OAbA,2DAcAO,aAvBA,iJAwBAxB,QAAevX,KAAA,kBACfsW,KAAA,CAAAoH,EAAA1J,KACA,MAAAH,EAAA6J,EAAA7J,GAKA,GAHAA,EAAA8J,WAAA,SACA9J,EAAA+J,MAAA/J,EAAAgK,kBAEAP,EAAApQ,OAAA,GACA,MAAAqO,EAAA1H,EAAA2H,eAEA3H,EAAA0C,WAAA1C,EAAA2C,aAAA+E,GACA1H,EAAA4H,WAAA5H,EAAA2C,aAAA8G,EAAAzJ,EAAA6H,aACA7H,EAAA6C,wBAAA1C,EAAA+C,kBACAlD,EAAA+C,oBAAA5C,EAAA+C,iBAAA,EAAAlD,EAAAgD,SAAA,KAEA,MAAAiH,EAAAjK,EAAA0G,mBAAAvG,EAAAe,UAAA,SACAlB,EAAAwH,iBAAAyC,KAAAP,EAAAtS,UAEA4I,EAAAkK,WAAAlK,EAAAuD,UAAA,EAAAkG,EAAApQ,OAAA,GAEA2G,EAAAmK,aAAAzC,OAMAja,OAAAmQ,EAAAwM,EAAAC,EAAAC,EAAAC,EAAAC,GACAf,EAAA,IAAAvK,aAAA2F,MAAA3X,UAAAsL,OAAAiS,SAAAD,EAAA7K,IAAAtT,KAAAmG,YAEA,MAAAkY,EAAA,IAAAzc,MAAA2F,QACA8W,EAAAjU,IACA,KAAA6T,EAAA5c,EACA,KAAA4c,EAAA3c,EACA,OAGA,MAAAgd,EAAA,IAAA1c,MAAA2F,QASA,OARA+W,EAAAlU,IACA,GAAA2T,EAAAxM,EAAAgN,gBAAA,IACA,KAAAP,EAAAzM,EAAAgN,gBAAA,EACA,OAGAlB,EAAAiB,EAAAE,SAAAH,GAAAG,SAAAN,IAGApY,MAAAiY,EACAhY,OAAAiY,KCnDAS,GACAlB,MAAA,MAEAjF,OAvBA,kyBAwBAjB,QAAevX,KAAA,kBACfoU,UACAoJ,gBAAyBxM,KAAA,iBACzB4N,gBAAyB5N,KAAA,SACzByN,gBAAyBzN,KAAA,SACzB6N,eAAwB7N,KAAA,QACxBmN,eAAwBnN,KAAA,QACxB8N,2BAAoC9N,KAAA,SACpC5E,YAAqB4E,KAAA,oBAKrB+N,OAAA,CAAAtN,EAAAuN,EAAAC,EAAAJ,EAAAV,MAEAnY,MAAAgZ,EACA/Y,OAAAgZ,EACA7K,UACAwK,eAAAnN,EAAAmN,eACAH,eAAAhN,EAAAgN,eACAI,iBAAAtd,EAAAsd,EAAArd,GACA2c,iBAAA5c,EAAA4c,EAAA3c,GACAsd,0BAAArN,EAAAqN,8BC9CA,MAAAI,EAAA,+qBAuBA,IAAAC,GACA1B,MAAA,MAGAjF,OAAA0G,EACA3H,QAAiBvX,KAAA,gCACjBoU,UACAuK,gBAA2B3N,KAAA,iBAC3BoO,OAAkBpO,KAAA,QAClBqO,mBAA8BrO,KAAA,OAC9BsO,gBAA2BtO,KAAA,UAI3BwH,OAAA0G,EACA3H,QAAiBvX,KAAA,yBACjBoU,UACAuK,gBAA2B3N,KAAA,gBAAAhR,KAAA,gCAC3Bof,OAAkBpO,KAAA,QAClBqO,mBAA8BrO,KAAA,OAC9BsO,gBAA2BtO,KAAA,UAM3B+N,OAAA,CAAAtN,EAAAuN,EAAAC,MAGAjZ,MAAAgZ,EACA/Y,OAAAgZ,EACA7K,UACAgL,OAAA,EAAAJ,EAAA,GACAK,kBAAAvc,KAAA8M,KAAA6B,EAAAK,mBAAAL,EAAAmN,gBACAU,eAAAxc,KAAA8M,KAAA6B,EAAA8N,gBAAA9N,EAAAmN,mBAIA5Y,MAAAgZ,EACA/Y,OAAAgZ,EACA7K,UACAgL,OAAA,IAAAH,GACAI,kBAAAvc,KAAA8M,KAAA6B,EAAAQ,mBAAAR,EAAAmN,gBACAU,eAAAxc,KAAA8M,KAAA6B,EAAA+N,gBAAA/N,EAAAmN,oBC3CA,IAAAa,EACAC,EAIA,IAAAC,GACAlC,MAAA,MAEAjF,OAhBA,oFAiBAO,aAhCA,uaAiCAxB,QAAevX,KAAA,wBAAA4Y,YAAA,UAAAoE,MARf,IASA1G,KAAA,CAAAoH,EAAA1J,KACA,MAAAH,EAAA6J,EAAA7J,GAEAA,EAAA+L,OAAA/L,EAAAgM,YAEA,MAAAC,EAAAjM,EAAAkM,qBACAlM,EAAAmM,iBAAAnM,EAAAoM,aAAAH,GACAjM,EAAAqM,oBAAArM,EAAAoM,aAAApM,EAAAsM,kBAAAnM,EAAAS,WAAAT,EAAAW,aACAd,EAAAuM,wBAAAvM,EAAA+B,YAAA/B,EAAAwM,iBAAAxM,EAAAoM,aAAAH,GAEA,QAAAQ,EAAA,EAA2BA,EAnB3B,GAmBqDA,IAAA,CAGrD,GAFAzM,EAAA0M,wBAAA1M,EAAA+B,YAAA/B,EAAAgH,kBAAA7G,EAAA2G,cAAA,EAAA2F,GACAzM,EAAAiH,uBAAAjH,EAAA+B,cAAA/B,EAAAkH,qBAEA,UAAArI,MAAA,uFAKA,GAHAmB,EAAA8J,WAAA,SACA9J,EAAA+J,MAAA/J,EAAAgK,iBAAAhK,EAAA2M,kBAEAf,EAAAa,GAAApT,OAAA,GACA,MAAAqO,EAAA1H,EAAA2H,eAEA3H,EAAA0C,WAAA1C,EAAA2C,aAAA+E,GACA1H,EAAA4H,WAAA5H,EAAA2C,aAAAiJ,EAAAa,GAAAzM,EAAA6H,aACA7H,EAAA6C,wBAAA1C,EAAA+C,kBACAlD,EAAA+C,oBAAA5C,EAAA+C,iBAAA,EAAAlD,EAAAgD,SAAA,KAEA,MAAAiH,EAAAjK,EAAA0G,mBAAAvG,EAAAe,UAAA,SAKA,GAJAlB,EAAAwH,iBAAAyC,KAAA4B,EAAAzU,UAEA4I,EAAAkK,WAAAlK,EAAAuD,UAAA,EAAAqI,EAAAa,GAAApT,OAAA,GAEA,GAAAoT,EAAA,CACA,MAAAG,EAAA,IAAA1N,aAAAiB,EAAAS,WAAAT,EAAAW,YAAA,GACAd,EAAA4D,WAAA,IAAAzD,EAAAS,WAAAT,EAAAW,YAAAd,EAAA6D,KAAA7D,EAAAgD,MAAA4J,GACA/C,EAAAgD,qBAAAD,EAGA5M,EAAAmK,aAAAzC,IAIA1H,EAAAmM,iBAAAnM,EAAAoM,aAAA,MACApM,EAAA8M,mBAAAb,GACAjM,EAAA+M,QAAA/M,EAAAgM,eAKAve,OAAAmQ,EAAAuN,EAAAC,EAAAJ,EAAAgC,EAAAzP,EAAA0P,EAAAC,GACAtB,KAEA,IAAAtO,EAAAC,EACA,QAAAkP,EAAA,EAAuBA,EA9DvB,GA8DiDA,IAAA,CACjD,MAAAja,EAAAqS,MAAA3X,UAAAsL,OAAAiS,SAAAyC,EAAAvN,IAAAtT,KAAA8gB,oBAAA7P,IAAA2P,EAAArP,KACAgO,EAAA/T,KAAA,IAAAqH,aAAA1M,IACA8K,GAAA2P,EAGA,MAAAvC,EAAA,IAAAzc,MAAA2F,QACA8W,EAAAjU,IACA,KAAAuU,EAAAtd,EAAAsf,EACA,KAAAhC,EAAArd,EACA,OAGA,MAAAgd,EAAA,IAAA1c,MAAA2F,QASA,OARA+W,EAAAlU,IACA,GAAA0U,EAAAvN,EAAAmN,gBAAA,IACA,KAAAK,EAAAxN,EAAAmN,gBAAA,EACA,OAGAc,EAAAlB,EAAAE,SAAAH,IAGAvY,MAAAgZ,EACA/Y,OAAAgZ,KCjDAgC,GACAxD,MAAA,MAEAjF,OAjEA,2tDAkEAjB,QAAevX,KAAA,UAAA2c,OAAA,UACfvI,UACAhI,YAAqB4E,KAAA,iBACrBmN,eAAwBnN,KAAA,QACxByN,gBAAyBzN,KAAA,SACzB8N,2BAAoC9N,KAAA,YAKpC+N,OAAA,CAAAtN,EAAAwM,EAAAC,EAAAC,MAEAnY,MAAAiY,EACAhY,OAAAiY,EACA9J,UACA+J,iBAAA5c,EAAA4c,EAAA3c,GACAid,eAAAhN,EAAAgN,eACAK,0BAAArN,EAAAqN,8BC2IAoC,GACAzD,MAAA,MAGAjF,OA9CA2I,inKA+CA5J,QAAiBvX,KAAA,aAAAwX,SACjBpD,UACAgN,SAAoBpQ,KAAA,iBACpBqQ,aAAwBrQ,KAAA,OACxBsQ,cAAyBtQ,KAAA,OACzBuQ,qBAAgCvQ,KAAA,OAChCwQ,sBAAiCxQ,KAAA,UAIjCwH,OA5BA2I,89IA6BA5J,QAAiBvX,KAAA,wBAAAwX,SACjBpD,UACAgN,SAAoBpQ,KAAA,iBACpByQ,aAAwBzQ,KAAA,YAMxB+N,OAAA,CAAAtN,EAAAnP,MAGA0D,MAAAyL,EAAA2P,QAAAC,YAAA5P,EAAA2P,QAAAE,aACArb,OAAAwL,EAAA2P,QAAAG,oBAAA9P,EAAA2P,QAAAI,qBACApN,UACAiN,YAAA5P,EAAA2P,QAAAC,YACAC,aAAA7P,EAAA2P,QAAAE,aACAC,oBAAA9P,EAAA2P,QAAAG,oBACAC,qBAAA/P,EAAA2P,QAAAI,wBAIAxb,MAAAyL,EAAA2P,QAAAE,aACArb,OAAAwL,EAAA2P,QAAAG,oBACAnN,UACAqN,YAAAnf,EAAAI,SCrFAgf,GACAjE,MAAA,MAEAjF,OArLA,4yJAsLAjB,QAAevX,KAAA,0BAAAwX,SACfpD,UACAgN,SAAkBpQ,KAAA,iBAClByQ,aAAsBzQ,KAAA,SACtB2Q,cAAuB3Q,KAAA,SACvB4Q,eAAwB5Q,KAAA,YAKxB+N,OAAA,CAAAtN,EAAAnP,MAEA0D,MAAAyL,EAAA2P,QAAAE,aACArb,OAAAwL,EAAA2P,QAAAG,oBACAnN,UACAqN,YAAAnf,EAAAI,KACAif,aAAArf,EAAAM,MACAgf,cAAAtf,EAAAO,WCvMA,MAAAgf,EAAA,otKAyIAC,EAAA,iuCA+CAC,EAAA,ujDAuDAC,GACAf,SAAYjQ,KAAA,iBACZ2N,gBAAmB3N,KAAA,gBAAAhR,KAAA,yBACnB2f,uBAA0B3O,KAAA,gBAAAhR,KAAA,wBAAA4Y,YAAA,WAC1BqJ,sBAAyBjR,KAAA,QAAA9D,OAAA,GACzBgV,uBAA0BlR,KAAA,QAAA9D,OAAA,GAC1BiR,eAAkBnN,KAAA,QAClByN,gBAAmBzN,KAAA,SACnB6N,eAAkB7N,KAAA,QAClB4N,gBAAmB5N,KAAA,SACnBmR,oBAAuBnR,KAAA,SACvBoR,sBAAyBpR,KAAA,SACzBqR,eAAkBrR,KAAA,SAClBsR,gBAAmBtR,KAAA,SACnBuR,wBAA2BvR,KAAA,SAC3BwR,oBAAuBxR,KAAA,SACvByR,YAAezR,KAAA,SACf0R,mBAAsB1R,KAAA,SACtB2R,yBAA4B3R,KAAA,SAC5B4R,yBAA4B5R,KAAA,SAC5B6R,8BAAiC7R,KAAA,SACjC8R,gCAAmC9R,KAAA,SACnC+R,kCAAqC/R,KAAA,SACrCgS,eAAkBhS,KAAA,SAClBiS,kBAAqBjS,KAAA,SACrBkS,kBAAqBlS,KAAA,SACrB8P,kBAAqB9P,KAAA,UAGrB,SAAAmS,EAAA1R,EAAA0M,EAAAU,EAAAiC,GACA,OACAmB,sBAAA,iBACAC,uBAAA,KAAAzQ,EAAAgR,WAAA,OACAtE,iBAAA5c,EAAA4c,EAAA3c,GACAid,eAAAhN,EAAAgN,eACAI,iBAAAtd,EAAAsd,EAAArd,GACAod,eAAAnN,EAAAmN,eACAuD,mBAAA1Q,EAAA0Q,mBACAC,qBAAA3Q,EAAA2Q,qBACAC,cAAA5Q,EAAA4Q,cACAC,eAAA7Q,EAAA6Q,eACAC,uBAAA9Q,EAAA8Q,uBACAC,mBAAA/Q,EAAA+Q,mBACAC,WAAAhR,EAAAgR,WACAC,kBAAAjR,EAAAiR,kBACAC,wBAAAlR,EAAAkR,wBACAC,wBAAAnR,EAAAmR,wBACAC,6BAAApR,EAAAoR,6BACAC,+BAAArR,EAAAqR,+BACAC,iCAAAtR,EAAAsR,iCACAC,cAAAvR,EAAAuR,cACAC,iBAAAxR,EAAAwR,iBACAC,iBAAAzR,EAAAyR,iBACApC,oBClSA,SAAAsC,EAAAC,GACA,OAAAxB,GAAA,SAAAwB,EAAAvB,EAAAC,uuBAuBqB,SAAAsB,EAAA,giCAuB2C,SAAAA,EAAA,oFAC5D,SAAAA,EAAA,oBAAwC,4DAES,SAAAA,EAAA,qBAMrD,IAAAC,GACA7F,MAAA,MAGAjF,OAAA4K,EAAA,SACA7L,QAAiBvX,KAAA,6BACjBoU,SAAAjU,OAAA2H,UAAkCka,GAClCZ,SAAoBpQ,KAAA,iBACpBuS,kBAA6BvS,KAAA,gBAAAhR,KAAA,yBAC7BwjB,mBAA8BxS,KAAA,OAC9ByS,oBAA+BzS,KAAA,OAC/B0S,iBAA4B1S,KAAA,SAC5ByQ,aAAwBzQ,KAAA,SACxB2S,kBAA6B3S,KAAA,OAC7B4S,kBAA6B5S,KAAA,SAC7B6S,oBAA+B7S,KAAA,SAC/B8S,2BAAsC9S,KAAA,aAItCwH,OAAA4K,EAAA,WACA7L,QAAiBvX,KAAA,+BACjBoU,SAAAjU,OAAA2H,UAAkCka,GAClCZ,SAAoBpQ,KAAA,iBACpBuS,kBAA6BvS,KAAA,gBAAAhR,KAAA,2BAC7BwjB,mBAA8BxS,KAAA,OAC9ByS,oBAA+BzS,KAAA,OAC/B0S,iBAA4B1S,KAAA,SAC5ByQ,aAAwBzQ,KAAA,SACxB2Q,cAAyB3Q,KAAA,SACzB4Q,eAA0B5Q,KAAA,SAC1B2S,kBAA6B3S,KAAA,OAC7B6S,oBAA+B7S,KAAA,SAC/B8S,2BAAsC9S,KAAA,aAMtC+N,OAAA,CAAAtN,EAAAnP,EAAA6b,EAAAU,EAAA2E,EAAAC,EAAA3C,MAGA9a,MAAAyL,EAAA2P,QAAAE,aACArb,ODsIA,ECtIAwL,EAAA2P,QAAAG,oBACAnN,SAAAjU,OAAA2H,UAAkCqb,EAAA1R,EAAA0M,EAAAU,EAAAiC,IAClC0C,oBACAC,qBACAC,gBAAAphB,EAAAG,SACAgf,YAAAnf,EAAAI,KACAihB,iBDgIA,EC/HAC,iBAAAnS,EAAAmS,iBACAC,mBAAApS,EAAAoS,mBACAC,0BAAArS,EAAAqS,8BAIA9d,MAAAyL,EAAA2P,QAAAE,aACArb,ODwHA,ECxHAwL,EAAA2P,QAAAG,oBACAnN,SAAAjU,OAAA2H,UAAkCqb,EAAA1R,EAAA0M,EAAAU,EAAAiC,IAClC0C,oBACAC,qBACAC,gBAAAphB,EAAAG,SACAgf,YAAAnf,EAAAI,KACAif,aAAArf,EAAAM,MACAgf,cAAAtf,EAAAO,OACA8gB,iBDgHA,EC/GAE,mBAAApS,EAAAoS,mBACAC,0BAAArS,EAAAqS,+BClFA,MAAAC,EACAlC,EACAC,EACAC,EAEA,+nLA0IA,IAAAiC,GACAvG,MAAA,MAEAjF,OAAAuL,EACAxM,QAAevX,KAAA,eACfoU,SAAAjU,OAAA2H,UAAgCka,GAChCZ,SAAkBpQ,KAAA,iBAClBiT,WAAoBjT,KAAA,gBAAA4H,YAAA,WACpBsL,YAAqBlT,KAAA,iBACrBmT,2BAAoCnT,KAAA,iBACpCoT,6BAAsCpT,KAAA,iBACtCwS,mBAA4BxS,KAAA,OAC5ByS,oBAA6BzS,KAAA,OAC7B0S,iBAA0B1S,KAAA,SAC1ByQ,aAAsBzQ,KAAA,SACtB2Q,cAAuB3Q,KAAA,SACvB4Q,eAAwB5Q,KAAA,SACxBqT,kBAA2BrT,KAAA,SAC3B6S,oBAA6B7S,KAAA,SAC7B8S,2BAAoC9S,KAAA,SACpCqQ,aAAsBrQ,KAAA,OACtBsQ,cAAuBtQ,KAAA,OACvB2S,kBAA2B3S,KAAA,OAC3BsT,eAAwBtT,KAAA,OACxBuT,UAAmBvT,KAAA,OACnBuQ,qBAA8BvQ,KAAA,OAC9BwQ,sBAA+BxQ,KAAA,OAC/BwT,gBAAyBxT,KAAA,QAAA9D,OAAAuX,GACzBC,YAAqB1T,KAAA,QAAA9D,OAAAyX,GACrBC,SAAkB5T,KAAA,SAElBkG,UAAA,CAAAwG,EAAA1J,EAAAsC,KACA,MACArQ,EAAA+N,EAAAE,KAAAkN,QAAAE,aACA2C,EAAA,IAAAlR,aAFA8R,GAEA5e,EAAA+N,EAAAE,KAAAkN,QAAAC,YAAA,GAEA,QAAAngB,EAAA,EAAuBA,EAAA8S,EAAAE,KAAAkN,QAAAC,YAAsCngB,IAC7Dwc,EAAArJ,sBAAAL,GAAgD4Q,QAAA1jB,IAChDoV,IAEAoH,EAAA7J,GAAA4D,WAAA,IARAoN,GAQA5e,EAAAyX,EAAA7J,GAAA6D,KAAAgG,EAAA7J,GAAAgD,MAAAoN,EARAY,GAQA3jB,EAAA+E,EAAA,GAEAyX,EAAA7J,GAAAqC,YAAAwH,EAAA7J,GAAAiF,iBAAA4E,EAAApK,eAAA2Q,WACAvG,EAAA7J,GAAAiR,kBAAApH,EAAA7J,GAAAiF,iBAAA,MAAA5X,EAAA,IAXA2jB,GAWA5e,GAGAyX,EAAAqH,sBAAAd,KAKAlF,OAAA,CAAAtN,EAAAnP,EAAA6b,EAAAU,EAAA2E,EAAAC,EAAA3C,MAEA9a,MAAA6e,GACA5e,OAAAwL,EAAA2P,QAAAE,aACApN,MACAkN,QAAA3P,EAAA2P,SAEAhN,SAAAjU,OAAA2H,UAAgCqb,EAAA1R,EAAA0M,EAAAU,EAAAiC,IAChC0C,oBACAC,qBACAC,gBAAAphB,EAAAG,SACAgf,YAAAnf,EAAAI,KACAif,aAAArf,EAAAM,MACAgf,cAAAtf,EAAAO,OACAwhB,iBAAA5S,EAAA4S,iBACAR,mBAAApS,EAAAoS,mBACAC,0BAAArS,EAAAqS,0BACAzC,YAAA5P,EAAA2P,QAAAC,YACAC,aAAA7P,EAAA2P,QAAAE,aACAqC,iBFrBA,EEsBAW,cFrBA,EEsBAC,SFrBA,EEsBAhD,oBAAA9P,EAAA2P,QAAAG,oBACAC,qBAAA/P,EAAA2P,QAAAI,qBACAgD,gBAAA,EAAA/S,EAAAgR,WAAA,IAAAhR,EAAAgR,WAAA,EAAAhR,EAAAgR,WAAA,KACAiC,YAAA,eAAAtjB,EAAArB,EAAAW,EAAA,sBAAAskB,ICvPA,MAAAC,EAAA,EACAC,EAAA,EACAC,EAAA,QAiBAC,EACA9jB,cACAI,KAAA2jB,qBAAA,KACA3jB,KAAA4jB,2BAAA,EACA5jB,KAAA6jB,4BAAA,EACA7jB,KAAA8jB,2BAAA,EACA9jB,KAAA6jB,4BAAA,EAEAE,YAAAC,MACA,MAAAnS,GACAiK,EAAAC,QACAkB,EAAAlB,WACA0B,EAAA1B,QACAkC,EAAAlC,QACAwD,EAAAxD,WACAyD,EAAAzD,QACAiE,EAAAjE,WACA6F,EAAA7F,QACAuG,EAAAvG,SACAjK,IAAAvS,GAAAd,OAAA2H,UAA+B7G,GAAM+E,MAAA,EAAAC,OAAA,KAErCvE,KAAAgc,MAAA,IAAArL,EAAAlH,EAAAoI,GAGAjS,QACAI,KAAA2jB,qBAAA,KACA3jB,KAAA4jB,2BAAA,EACA5jB,KAAA6jB,4BAAA,EACA7jB,KAAA8jB,2BAAA,EACA9jB,KAAA6jB,4BAAA,EAGAjkB,KAAAqkB,EAAA9E,EAAA+E,EAAAxU,EAAAyU,EAAA9E,GACA,MAAA+E,EAAApkB,KAAAqkB,0BAEAC,EAAAJ,EAAAK,eAAApF,EAAA/d,KAAA8M,MAAAlO,KAAA+P,OAAAyU,eAAAJ,GAAApkB,KAAA+P,OAAAqN,2BAAA,EAAApd,KAAA+P,OAAAqN,2BAGAV,EAwWA,UAAAxc,IAA2BA,EAAAC,QAC3B,MAAA0c,EAAA,IAAAzc,MAAA2F,QACA8W,EAAAjU,IACA,KAAA1I,EAAAL,EACA,KAAAK,EAAAJ,EACA,OAGA,MAAA8E,EAAAxD,KAAAI,IAAArB,GACA0E,EAAAzD,KAAAK,IAAAtB,GAEAskB,EAAA,IAAArkB,MAAA2F,QAOA,OANA0e,EAAA7b,IACAhE,EAAAC,EAAA,GACAA,EAAAD,EAAA,EACA,OAGA6f,EAAAzH,SAAAH,GAlBA,CAxWAoH,GACAvZ,EAAA4Z,EAAAxS,IAAA1T,KAAwD8B,IAAA9B,EAAA8B,IAAAY,QAAA4jB,aAAAhI,GAAAvc,IAAA/B,EAAA+B,IAAA8jB,EAAA9jB,IAAAa,KAAA5C,EAAA4C,QAExD2jB,EAAA,IAAAtT,aAAA,EAAA3G,EAAAc,QACAoZ,EAAA,IAAAxkB,MAAAC,QAAA,KACAwkB,EAAA,IAAAzkB,MAAAC,QAAA,KAEA,QAAAtC,EAAA,EAAmBA,EAAA2M,EAAAc,OAAuBzN,IAAA,CAC1C,MAAA+mB,EAAApa,EAAA3M,GACAmC,EAAA4kB,EAAA5kB,IACAykB,EAAA,EAAA5mB,EAAA,GAAAmC,EAAAL,EACA8kB,EAAA,EAAA5mB,EAAA,GAAAmC,EAAAJ,EACA6kB,EAAA,EAAA5mB,EAAA,GAAA+mB,EAAA3kB,IAEAykB,EAAApX,IAAAtN,GACA2kB,EAAApX,IAAAvN,GAGA,MAAA6kB,EAAAH,EAAA9jB,QAAA0L,IAAAqY,GACApI,EAAAoI,EAAA/jB,QAAAL,IAAAmkB,GAAAI,aAAA,GAGAzI,EAAAnb,KAAA8M,MAAA6W,EAAAllB,EAAA,EAAAG,KAAA+P,OAAAkV,YAAAjlB,KAAA+P,OAAAgN,gBACAP,EAAApb,KAAA8M,MAAA6W,EAAAjlB,EAAA,EAAAE,KAAA+P,OAAAkV,YAAAjlB,KAAA+P,OAAAgN,gBAEAmI,EAAAllB,KAAA+P,OAAAyU,eAAA,EAAAJ,EACAjH,EAAA,IAAA/c,MAAAC,QAAAL,KAAA+P,OAAAyU,eAAA,KAGAlH,EAAAlc,KAAA8M,KAAAgX,EAAAllB,KAAA+P,OAAAmN,gBACAK,EAAAnc,KAAA8M,MAAAlO,KAAA+P,OAAAoV,UAAA,EAAAnlB,KAAA+P,OAAAkV,YAAAjlB,KAAA+P,OAAAmN,gBAEA,IAAAjS,EAEA,OAAAjL,KAAA2jB,sBAAAxE,EAAAiF,EAAA,EAAApkB,KAAA2jB,sBACA1Y,GAAA,OAAAjL,KAAA2jB,qBAAAxE,EAAAnf,KAAA2jB,sBAAAS,EACApkB,KAAA2jB,qBAAA1Y,EACAjL,KAAA4jB,2BAAA5jB,KAAA+P,OAAA2P,QAAAE,aACA5f,KAAA6jB,4BAAA7jB,KAAA+P,OAAA2P,QAAAE,cAEA3U,EAAAjL,KAAA2jB,qBAGA,MAAAjE,EAAA1f,KAAAolB,cAAAlB,EAAAjZ,EAAAgZ,EAAA9jB,IAAAuc,GAGA0C,EADApf,KAAA+P,OAAAyU,eAAAxkB,KAAA+P,OAAAgR,WACA/gB,KAAA+P,OAAAsV,iBAEA,UAAAtnB,EAAAwB,KACAuc,EAAAuB,OAAArd,KAAA+P,OAAAwM,EAAAC,EAAAC,EAAAC,EAAAyH,GACAlH,EAAAI,OAAArd,KAAA+P,OAAAuN,EAAAC,EAAAJ,EAAAV,MACAgB,EAAAJ,OAAArd,KAAA+P,OAAAuN,EAAAC,GACAU,EAAAZ,OAAArd,KAAA+P,OAAAuN,EAAAC,EAAAJ,EAAAgC,EAAAzP,EAAA0P,EAAAC,GACAE,EAAAlC,OAAArd,KAAA+P,OAAAwM,EAAAC,EAAAC,MACA+C,EAAAnC,OAAArd,KAAA+P,OAAAkU,GACAjE,EAAA3C,OAAArd,KAAA+P,OAAAkU,MACArC,EAAAvE,OAAArd,KAAA+P,OAAAkU,EAAAxH,EAAAU,EAAAnd,KAAA4jB,0BAAA5jB,KAAA6jB,2BAAAzE,GACAkD,EAAAjF,OAAArd,KAAA+P,OAAAkU,EAAAxH,EAAAU,EAAAnd,KAAA4jB,0BAAA5jB,KAAA6jB,2BAAAzE,IACA/K,UACArU,KAAAgc,MAAAsJ,cAAAvnB,EAAAwB,GAGAS,KAAAgc,MAAAuJ,sBACA7a,YACApG,MAAAoG,EAAAc,OACAjH,OAAA,EACA0N,SAAA,EACAgJ,OAAA,SACA7J,KAAAuT,GAEApC,WACAje,MAAAif,EAAAC,EAAAC,EACAlf,OAAAvE,KAAA+P,OAAA2P,QAAAE,aACAtE,MAAAtb,KAAA+P,OAAA2P,QAAAC,YACA1N,SAAA,EACAiF,YAAA,WAEAwI,SACApb,MAAAtE,KAAA+P,OAAA2P,QAAAE,aACArb,OAAAvE,KAAA+P,OAAA2P,QAAAC,YACA1N,SAAA,EACAb,KAAAsO,KAIA1f,KAAAgc,MAAAqH,sBAAA,KACArjB,KAAAgc,MAAAgD,qBAAA,KAEA+E,YAAAC,MACA,MAAAjQ,EAAA/T,KAAAgc,MAAAwJ,MACAjD,EAAAviB,KAAAgc,MAAAqH,sBACAoC,EAAA1R,EAAA,GACA2R,EAAA3R,EAAA,GACA4R,EAAA5R,EAAA,GAEA,IACA6R,EADAC,GAAA1Y,OAAAC,mBAEA,MAAA0Y,EAAAvD,EAAA/W,OAAA,EAEA,QAAAzN,EAAA,EAAmBA,EAAA+nB,EAAgB/nB,IAAA,CACnC,MAAAgoB,EAAA/lB,KAAAgmB,sBAAAjoB,GACAkoB,GACA1D,EAAA,EAAAxkB,GACAwkB,EAAA,EAAAxkB,EAAA,GACAwkB,EAAA,EAAAxkB,EAAA,GACAwkB,EAAA,EAAAxkB,EAAA,IAGAkoB,EAAA,OAEAA,EAAA,IAAAjmB,KAAAkmB,cAAAH,EAAAE,GAEAA,EAAA,GAAAJ,EAAA,KACAD,EAAA7nB,EACA8nB,EAAAI,IAIA,MAAAE,OAAA/lB,MAAA2F,SAAAuD,WAAAoT,GACA,IAAA0J,EAAA,KACAC,EAAA,KACAC,EAAA,KACAxE,GAAA,EACAyE,GAAA,EACAxE,GAAA,EACAyE,GAAA,EA6BA,OA3BAC,SAAAZ,EAAA,OACAO,EAAAC,EAAAC,EAAAxE,EAAAyE,EAAAxE,EAAAyE,GAAAxmB,KAAA0mB,uBACAd,EACArD,EACAkD,EACAC,EACAC,EACA1B,EACAvE,GAGA2G,EAAA7V,QAAAjR,IACAA,EAAAW,IAAAX,EAAAW,IAAAwkB,aAAAyB,GACA5mB,EAAAY,KAAA8jB,EAAA9jB,MAGAimB,EAAA5V,QAAAjR,IACAA,EAAAW,IAAAX,EAAAW,IAAAwkB,aAAAyB,GACA5mB,EAAAY,KAAA8jB,EAAA9jB,OAIAH,KAAA4jB,0BAAA9B,EACA9hB,KAAA8jB,0BAAAyC,EACAvmB,KAAA6jB,2BAAA9B,EACA/hB,KAAA2mB,2BAAAH,GAGA7c,KAAAyc,EACAC,qBACAC,oBACAM,oBAAA5mB,KAAA2jB,qBACAkD,qBAA4BzV,KAAApR,KAAAgc,MAAAgD,qBAAA1a,MAAAgZ,EAAA/Y,OAAAgZ,IAI5B3d,cAAAskB,EAAAjZ,EAAA6b,EAAApK,GACA,MAAAhS,EAAAwZ,EAAAK,eAAAtZ,EAAAjL,KAAA+P,OAAA2P,QAAAC,YAAA3f,KAAAqkB,2BACA0C,EAAA3lB,KAAA4lB,MAAAhnB,KAAA+P,OAAA2P,QAAAE,aAAA,GACAF,EAAA,IAAArO,aAAArR,KAAA+P,OAAA2P,QAAAC,YAAA3f,KAAA+P,OAAA2P,QAAAE,aAAA,GACA,IAAAhS,EAAA,EAEA,QAAApO,EAAA,EAAmBA,EAAAkL,EAAAc,OAAuBhM,IAAA,CAC1C,MAAAslB,EAAApa,EAAAlL,GAEA,QAAAxB,EAAA,EAAqBA,EAAAgC,KAAA+P,OAAA2P,QAAAE,aAAsC5hB,IAAA,CAC3D,MAAAipB,GAAAjpB,EAAA+oB,KAAA/mB,KAAA+P,OAAAoV,UAAA,EACAhlB,EAAA2kB,EAAA3kB,IAAA2mB,EACA5mB,EAAAE,MAAAC,QAAAC,UAAAH,EAAAiB,KAAA0C,GAAA,GAAAvD,eAAA0mB,GAAAxmB,IAAAqkB,EAAA5kB,IAAAY,QAAA4jB,aAAAhI,IACA1b,EAAA,GAAA8jB,EAAA9jB,KAAA,OAAA8jB,EAAA9jB,KAAAimB,GAEAvH,EAAA9R,KAAA1N,EAAAL,EACA6f,EAAA9R,KAAA1N,EAAAJ,EACA4f,EAAA9R,KAAAzN,EACAuf,EAAA9R,KAAA5M,GAIA,OAAA0e,EAGA9f,0BACA,OAAAI,KAAA+P,OAAAyU,eAAAxkB,KAAA+P,OAAA2P,QAAAC,YAGA/f,eAAAsnB,EAAAC,EAAAC,EAAAC,EAAAC,IAAAC,EAAAC,EAAAC,EAAAC,IAEA,OAAAR,GAAAlnB,KAAA+P,OAAA2P,QAAAC,YAAA,GAAA6H,EAAA,IACAra,OAAAC,kBAEApN,KAAA+P,OAAAyU,eAAAxkB,KAAA+P,OAAA2P,QAAAC,aAAAuH,EAAA,IAEAlnB,KAAA+P,OAAA4X,qBAAAF,EAAAznB,KAAA+P,OAAA4S,iBAGA/iB,sBAAAgO,GACA,GAAAA,EAAA,YAAAA,EAAA,kBAEA,MAAAga,EAAArE,EAAAC,EACAqE,EAAAD,EAAAnE,EACAqE,EAAA9nB,KAAA+P,OAAA2P,QAAAE,aAAAiI,EAEAX,EAAA9lB,KAAA4lB,MAAApZ,EAAAka,GACAla,GAAAsZ,EAAAY,EAEA,MAAAX,EAAA/lB,KAAA4lB,MAAApZ,EAAAia,GACAja,GAAAuZ,EAAAU,EAEA,MAAAT,EAAAhmB,KAAA4lB,MAAApZ,EAAAga,GAMA,OALAha,GAAAwZ,EAAAQ,GAKAV,EAAAC,EAAAC,EAHAhmB,KAAA4lB,MAAApZ,EAAA2V,GACA3V,EAAA2V,GAKA3jB,uBAAAgO,EAAA2U,EAAAkD,EAAAC,EAAAC,EAAA1B,EAAAvE,GACA,IAAAqI,EAAA/nB,KAAAgmB,sBAAApY,GACAma,EAAA/d,KAAAuY,EAAA,EAAA3U,EAAA,IACA,MAAAoa,GAAAD,GAEA,IAAAE,EAAA,EACA,KAAAF,EAAA,OAAAE,IAAA,MACAra,EAAA2U,EAAA,EAAA3U,EAAA,GAGA,MAAA4Z,GAFAO,EAAA/nB,KAAAgmB,sBAAApY,IAEA,MAAA2U,EAAA,EAAA3U,EAAA,GAAAqW,EAAAljB,SACAgnB,EAAA/d,KAAAwd,GAEAQ,EAAAE,QAAAH,GAEA,GAAAE,GAAA,cAAAjX,MAAA,8DAEA,MAAAjD,KACA,IAAAsY,KACAC,EAAA,KAEA,QAAAvoB,EAAA,EAAmBA,EAAAiqB,EAAAxc,OAAA,EAAsBzN,IAAA,CACzC,MAAAuO,EAAA6b,EAAAC,EAAAC,EAAAC,EAAAC,GAAAP,EAAAjqB,IACAmlB,EAAA+D,EAAAuB,EAAAC,EAAAC,EAAA3nB,GAAAinB,EAAAjqB,EAAA,GAEA,IAAAyN,EACAmd,EAEA,GAAArc,EAAA,GACA,MAAArG,GACA/F,IAAA,IAAAE,MAAAC,QAAA,KACAF,IAAA,EACAa,KAAAijB,EAAAjjB,MAGA4nB,EAAA,GAAA1F,EAAAljB,KAAA+P,OAAA2P,QAAAE,aAAAqH,GACA/gB,GACAhG,IAAA,IAAAE,MAAAC,QAAAqf,EAAAkJ,GAAAlJ,EAAAkJ,EAAA,IACAzoB,IAAAuf,EAAAkJ,EAAA,GACA5nB,KAAA0e,EAAAkJ,EAAA,IAGA,MAAAT,EAAA,CACA3c,EAAAka,EAAAkD,EAAA,GAEA,MAAAziB,GACAc,GAAAye,EAAAkD,GACA1hB,GAAAwe,EAAAkD,EAAA,GACAzhB,GAAAqE,GAGAmd,EAAA,IAAAljB,EAAAgE,EAAAxD,EAAAC,EAAAC,GAEAmgB,GAA+BhX,KAAA,QAAAnJ,cACtB,CACTqF,EAAAma,EAAAiD,EAAA,GAEA,MAAAziB,GACAM,GAAAkf,EAAAiD,GACAlN,GAAAiK,EAAAiD,EAAA,GACAzhB,GAAAqE,GAGAmd,EAAA,IAAAnN,EAAAvV,EAAAC,EAAAC,GAEAmgB,GAA+BhX,KAAA,UAAAnJ,eAExB,CACP,MAAA0iB,EAAA,GAAAvc,EAAAtM,KAAA+P,OAAA2P,QAAAE,aAAAuI,GACAS,EAAA,GAAA1F,EAAAljB,KAAA+P,OAAA2P,QAAAE,aAAAqH,GAEAhhB,GACA/F,IAAA,IAAAE,MAAAC,QAAAqf,EAAAmJ,GAAAnJ,EAAAmJ,EAAA,IACA1oB,IAAAuf,EAAAmJ,EAAA,GACA7nB,KAAA0e,EAAAmJ,EAAA,IAGA3iB,GACAhG,IAAA,IAAAE,MAAAC,QAAAqf,EAAAkJ,GAAAlJ,EAAAkJ,EAAA,IACAzoB,IAAAuf,EAAAkJ,EAAA,GACA5nB,KAAA0e,EAAAkJ,EAAA,IAGAE,EAAA5F,EAAAljB,KAAA+P,OAAA2P,QAAAE,aAAAqH,EAEA8B,EAAA,KADAzc,EAAA4W,EAAAljB,KAAA+P,OAAA2P,QAAAG,qBAAA7f,KAAA+P,OAAA2P,QAAAI,qBAAAqI,EAAAlB,EAAA7lB,KAAA4lB,MAAAhnB,KAAA+P,OAAA2P,QAAAI,qBAAA,IACA9f,KAAA+P,OAAA2P,QAAAC,YAAA3f,KAAA+P,OAAA2P,QAAAE,aAAAkJ,GAEAtd,EAAAia,EAAAsD,EAAA,GAEAJ,EAAA,IAAAljB,EAAAgE,EAAAxD,EAAAC,GACAe,GAAAwe,EAAAsD,GACA7hB,GAAAue,EAAAsD,EAAA,GACA5hB,GAAAqE,IAIA,MAAA7B,EAAAgf,EAAAK,UAAA5nB,KAAA8M,KAAA1C,EAAA,MAEAyd,EAAAV,IACAW,GAAAnoB,IAAAkoB,GAAA,EAAAzd,EACAnE,EAAAmE,GAAA7B,EAAA6B,OAAA,GACA,IAAAhM,EAAA,EAEA,QAAAD,EAAA,EAAqBA,EAAAoK,EAAA6B,OAAiBjM,IACtCoK,EAAApK,GAAAwB,SAAAK,KAAA+P,KAAA,EAAA+X,EAAA1pB,EAAAypB,GACAtf,EAAApK,GAAAsC,aAAAqnB,EACA1pB,GAAA6H,EAGAiF,EAAA,EACA+Z,EAAA1c,GAEA5L,EAAA,GAAA4L,EAAAwf,QACApb,EAAA/D,QAAAL,IAIA,IAAAmY,EAAA,KACAyE,EAAA,KACAxE,EAAA,KACAyE,EAAA,KAYA,OAVAwB,EAAAxc,QAAA,IACAsW,EAAAkG,EAAA,MAAAhoB,KAAA+P,OAAA2P,QAAAE,aAAAoI,EAAA,MACAzB,EAAAyB,EAAA,OAGAA,EAAAxc,QAAA,IACAuW,EAAAiG,EAAA,MAAAhoB,KAAA+P,OAAA2P,QAAAE,aAAAoI,EAAA,MACAxB,EAAAwB,EAAA,QAGAja,EAAAsY,EAAAC,EAAAxE,EAAAyE,EAAAxE,EAAAyE,oBCxaA1oB,EAAAD,QAAA,SAAAurB,GACA,SAAAC,EAAAC,GACA,oBAAAC,UACAA,QAAAD,OAAAC,QAAAF,KAAA,kBAAAC,GAQA,IACA,oBAAAE,YAJA,oBAAAC,aAAA,oBAAAC,iBAKAF,WAAAJ,GACG,oBAAAO,KACHA,KAAAzrB,KAAA,KAAAkrB,GAEAC,EAAA,yCAEE,MAAAC,GACFD,EAAAC,qBCxBAxrB,EAAAD,QAAA,45BAAA4B,EAAAT,EAAAU,GCAA/B,EAAA,EAAAA,GAAA,cAAA8B,EAAAT,GCAAlB,EAAAD,QAAA,yo3pCAAA4B,EAAAT,EAAAU,GCAA/B,EAAA,EAAAA,GAAA,eAAA8B,EAAAT,EAAAU,GAAA,aAAAA,EAAAZ,EAAAE,GAAAU,EAAA,IAAAA,EAAA,QAAAZ,EAAAY,EAAA,GAAA3B,EAAA2B,EAAA,GAAA+J,EAAA/J,EAAA,GAAAlB,EAAAkB,EAAA,GCOA,SAAAkqB,IACA,IAAAC,EACA,IACAA,EAAA,IAAAC,EAAArgB,EACG,MAAA/J,GAMH,OALA6pB,QAAAF,IAAA,oCACAE,QAAAF,IAAA3pB,QAEAyW,KAAA4T,aAAsBT,WAKtBnT,KAAA6T,UAAA,SAAAC,GACA,MAAAla,OAAWA,EAAAkU,cAAA9E,iBAAA+E,WAAAxU,YAAAyU,kBAAA9E,mBAAA6K,SAAqGD,EAAA7Y,KAEhH+Y,EAAA1gB,EAAA2gB,QAAAlG,GACAC,EAAA3T,QAAAhS,GAAA6rB,EAAA5gB,EAAA2gB,QAAA5rB,IACA6gB,EAAA7O,QAAAhS,GAAA8rB,EAAA7gB,EAAA2gB,QAAA5rB,IAEA0rB,GAAAL,EAAAK,QAEAL,EAAA9Z,SAEA,IACA,MAAApG,KAAaA,EAAA0c,qBAAAC,oBAAAM,sBAAAC,uBAAwFgD,EAAAU,KAAAtG,EAAA9E,EAAA+E,EAAAxU,EAAAyU,EAAA9E,GAErGlJ,KAAA4T,aAAwBpgB,OAAA0c,qBAAAC,oBAAArC,cAAA9E,iBAAAyH,sBAAA7W,SAAA8W,wBACnB,MAAAyC,GACLC,QAAAF,IAAA,2BACAE,QAAAF,IAAAC,KAKA,oBAAAkB,OACAZ,IAEAY,OAAAC,2BAAAb","file":"PathPlannerWorker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 13);\n","export default class Car {\n  constructor(x = 0, y = 0, rotation = 0) {\n    this.setPose(x, y, rotation);\n  }\n\n  static getFrontAxlePosition(pos, rot) {\n    return THREE.Vector2.fromAngle(rot).multiplyScalar(Car.WHEEL_BASE).add(pos);\n  }\n\n  static getFakeAxlePosition(pos, rot) {\n    return Car.frontToRearAxlePosition(pos, rot);\n  }\n\n  static centerToRearAxlePosition(pos, rot) {\n    return THREE.Vector2.fromAngle(rot).multiplyScalar(Car.REAR_AXLE_POS).add(pos);\n  }\n\n  static frontToRearAxlePosition(pos, rot) {\n    return THREE.Vector2.fromAngle(rot).multiplyScalar(-Car.WHEEL_BASE).add(pos);\n  }\n\n  get pose() {\n    return { pos: this.rearAxlePosition.clone(), rot: this.rotation, velocity: this.velocity, curv: this.curvature, dCurv: this.dCurv, ddCurv: this.ddCurv };\n  }\n\n  get curvature() {\n    return Math.tan(this.wheelAngle) / Car.WHEEL_BASE;\n  }\n\n  get rearAxlePosition() {\n    const { x, y } = this.position;\n    const rot = this.rotation;\n    return new THREE.Vector2(x + Math.cos(rot) * Car.REAR_AXLE_POS, y + Math.sin(rot) * Car.REAR_AXLE_POS);\n  }\n\n  get frontAxlePosition() {\n    const { x, y } = this.position;\n    const rot = this.rotation;\n    return new THREE.Vector2(x + Math.cos(rot) * Car.FRONT_AXLE_POS, y + Math.sin(rot) * Car.FRONT_AXLE_POS);\n  }\n\n  setPose(x, y, rotation) {\n    // Translate so that x and y become the center of the vehicle (instead of the center of the rear axle)\n    x -= Car.REAR_AXLE_POS * Math.cos(rotation);\n    y -= Car.REAR_AXLE_POS * Math.sin(rotation);\n\n    this.position = new THREE.Vector2(x, y);\n    this.rotation = Math.wrapAngle(rotation);\n    this.velocity = 0;\n    this.acceleration = 0;\n    this.wheelAngle = 0;\n    this.wheelAngularVelocity = 0;\n    this.dCurv = 0; // derivative with respect to arc length\n    this.ddCurv = 0; // derivative with respect to arc length\n  }\n\n  step(dt) {\n    const curvPrev = this.curvature;\n    const dCurvPrev = this.dCurv;\n\n    const drag = (0.5 * Car.DRAG_COEFF * Car.FRONTAL_AREA * Car.DENSITY_OF_AIR * Math.abs(this.velocity) + Car.ROLL_RESIST) * -this.velocity;\n    this.velocity += (this.acceleration + drag / Car.MASS) * dt;\n\n    const velocitySq = this.velocity * this.velocity;\n    const maxWheelAngle = Math.clamp(Math.atan(Car.MAX_LATERAL_ACCEL * Car.WHEEL_BASE / velocitySq), 0.07, Car.MAX_WHEEL_ANGLE);\n    this.wheelAngle = Math.clamp(Math.wrapAngle(this.wheelAngle + this.wheelAngularVelocity * dt), -maxWheelAngle, maxWheelAngle);\n\n    const angularVelocity = this.velocity * this.curvature;\n    this.rotation = Math.wrapAngle(this.rotation + angularVelocity * dt);\n\n    const dist = this.velocity * dt;\n    this.position = THREE.Vector2.fromAngle(this.rotation).multiplyScalar(dist).add(this.position);\n\n    this.dCurv = dist > 0.1 ? (this.curvature - curvPrev) / dist : 0;\n    this.ddCurv = dist > 0.1 ? (this.dCurv - dCurvPrev) / dist : 0;\n  }\n\n  update(controls, dt) {\n    const gas = Math.clamp(controls.gas, -1, +1);\n    const brake = Math.clamp(controls.brake, 0, 1);\n    const steer = Math.clamp(controls.steer, -1, +1);\n\n    if (brake > 0) {\n      this.acceleration = -Math.sign(this.velocity) * Car.MAX_BRAKE_DECEL * brake;\n      const newVelocity = this.velocity + this.acceleration * dt;\n\n      // If applying the braking deceleration at the next step would cause the velocity\n      // to change directions, then just set the car as stopped.\n      if (Math.sign(newVelocity) != Math.sign(this.velocity)) {\n        this.velocity = 0;\n        this.acceleration = 0;\n      }\n    } else {\n      this.acceleration = Car.MAX_GAS_ACCEL * gas;\n    }\n\n    if (steer != 0) {\n      this.wheelAngularVelocity = steer * Car.MAX_STEER_SPEED;\n    } else {\n      this.wheelAngularVelocity = Math.clamp(-this.wheelAngle / Car.MAX_WHEEL_ANGLE * this.velocity * this.velocity * dt, -Car.MAX_STEER_SPEED, Car.MAX_STEER_SPEED);\n    }\n  }\n}\n\nCar.HALF_CAR_LENGTH = 2.5; // meters\nCar.HALF_CAR_WIDTH = 1; // meters\nCar.HALF_WHEEL_LENGTH = 0.38; // meters\nCar.HALF_WHEEL_WIDTH = 0.12; // meters\nCar.MAX_WHEEL_ANGLE = 32 / 180 * Math.PI; // radians\nCar.MASS = 1600; // kg\nCar.DRAG_COEFF = 0.7;\nCar.DENSITY_OF_AIR = 1.8580608; // (kg/m^3)\nCar.FRONTAL_AREA = 1.85; // m^2\nCar.ROLL_RESIST = 0;\nCar.MAX_STEER_SPEED = 0.8;//1.2; // Radians per second\nCar.MAX_GAS_ACCEL = 3.5; // m / s^2\nCar.MAX_BRAKE_DECEL = 6.5; // m / s^2\nCar.WHEEL_LATERAL_POS = 0.843; // meters\nCar.FRONT_AXLE_POS = 1.6; // meters\nCar.REAR_AXLE_POS = -1.43; // meters\nCar.WHEEL_BASE = Car.FRONT_AXLE_POS - Car.REAR_AXLE_POS; // meters\nCar.MAX_LATERAL_ACCEL = 9.81; // m / s^2\n","export default class StaticObstacle {\n  static hydrate(obj) {\n    Object.setPrototypeOf(obj, StaticObstacle.prototype);\n    Object.setPrototypeOf(obj.pos, THREE.Vector2.prototype);\n  }\n\n  static fromJSON(json) {\n    return new StaticObstacle(new THREE.Vector2(json.p[0], json.p[1]), json.r, json.w, json.h);\n  }\n\n  constructor(pos, rot, width, height) {\n    this.pos = pos;\n    this.rot = rot;\n    this.width = width;\n    this.height = height;\n\n    this.updateVertices();\n  }\n\n  toJSON() {\n    const trunc = n => +n.toFixed(5);\n\n    return {\n      p: [trunc(this.pos.x), trunc(this.pos.y)],\n      r: trunc(this.rot),\n      w: trunc(this.width),\n      h: trunc(this.height)\n    };\n  }\n\n  updateVertices() {\n    this.vertices = [];\n\n    const cosRot = Math.cos(this.rot);\n    const sinRot = Math.sin(this.rot);\n    const halfWidth = this.width / 2;\n    const halfHeight = this.height / 2;\n\n    const hWcR = halfWidth * cosRot;\n    const hWsR = halfWidth * sinRot;\n    const hHcR = halfHeight * cosRot;\n    const hHsR = halfHeight * sinRot;\n\n    const v1 = [-hWcR - hHsR + this.pos.x, -hWsR + hHcR + this.pos.y];\n    const v2 = [-hWcR + hHsR + this.pos.x, -hWsR - hHcR + this.pos.y];\n    const v3 = [hWcR + hHsR + this.pos.x, hWsR - hHcR + this.pos.y];\n    const v4 = [hWcR - hHsR + this.pos.x, hWsR + hHcR + this.pos.y];\n\n    this.vertices = [\n      v1[0], v1[1],\n      v2[0], v2[1],\n      v3[0], v3[1],\n      v3[0], v3[1],\n      v4[0], v4[1],\n      v1[0], v1[1]\n    ];\n  }\n}\n","const SIMPSONS_INTERVALS = 8;\nconst NEWTON_ITERATIONS = 16;\nconst RELAXATION_ITERATIONS = 32;\nconst CONVERGENCE_ERROR = 0.01;\n\nconst jacobian = new THREE.Matrix3();\nconst invJacobian = new THREE.Matrix3();\n\n// Alternate reference implementation: https://github.com/ApolloAuto/apollo/blob/master/modules/planning/math/spiral_curve/cubic_spiral_curve.cc\nexport default class CubicPath {\n  constructor(start, end, params = null) {\n    this.start = Object.assign({}, start);\n    this.end = Object.assign({}, end);\n\n    if (start.pos) {\n      this.start.x = start.pos.x;\n      this.start.y = start.pos.y\n    }\n\n    if (end.pos) {\n      this.end.x = end.pos.x;\n      this.end.y = end.pos.y\n    }\n\n    const diffX = this.end.x - this.start.x;\n    const diffY = this.end.y - this.start.y;\n    const sinRot = Math.sin(this.start.rot);\n    const cosRot = Math.cos(this.start.rot);\n\n    this.goal = {\n      x: cosRot * diffX + sinRot * diffY,\n      y: -sinRot * diffX + cosRot * diffY,\n      rot: Math.wrapAngle(this.end.rot - this.start.rot),\n      curv: this.end.curv\n    };\n\n    if (params)\n      this.params = Object.assign({}, params, { p0: this.start.curv, p3: this.end.curv });\n    else\n      this.guessInitialParams();\n\n    this.converged = false;\n  }\n\n  guessInitialParams() {\n    const originalGoal = this.goal;\n    const dStartCurv = this.start.curv / RELAXATION_ITERATIONS;\n    const dGoalY = originalGoal.y / RELAXATION_ITERATIONS;\n    const dGoalRot = originalGoal.rot / RELAXATION_ITERATIONS;\n    const dGoalCurv = originalGoal.curv / RELAXATION_ITERATIONS;\n\n    this.goal = {\n      x: originalGoal.x,\n      y: 0,\n      rot: 0,\n      curv: 0\n    };\n\n    this.params = {\n      p0: 0,\n      p1: 0,\n      p2: 0,\n      p3: 0,\n      sG: originalGoal.x\n    };\n\n    for (let i = 0; i < RELAXATION_ITERATIONS; i++) {\n      this.params.p0 += dStartCurv;\n      this.params.p3 += dGoalCurv;\n      this.goal.y += dGoalY;\n      this.goal.rot += dGoalRot;\n      this.goal.curv += dGoalCurv;\n\n      this.iterate();\n    }\n\n    this.goal = originalGoal;\n  }\n\n  optimize() {\n    for (let i = 0; i < NEWTON_ITERATIONS; i++) {\n      if (this.iterate()) {\n        this.converged = true;\n        return true;\n      }\n    }\n\n    this.converged = false;\n    return false;\n  }\n\n  iterate() {\n    const { p0, p1, p2, p3, sG } = this.params;\n\n    const ds = sG / SIMPSONS_INTERVALS;\n    const sG_2 = sG * sG;\n    const sG_3 = sG_2 * sG;\n\n    let dX_p1 = 0;\n    let dX_p2 = 0;\n    let dX_sG = 0;\n    let dY_p1 = 0;\n    let dY_p2 = 0;\n    let dY_sG = 0;\n    let guessX = 0;\n    let guessY = 0;\n\n    let theta, cosTheta, sinTheta, dT_p1, dT_p2, dT_sG;\n\n    for (let i = 0, s = 0; i <= SIMPSONS_INTERVALS; i++, s += ds) {\n      const coeff = i == 0 || i == SIMPSONS_INTERVALS ? 1 : i % 2 == 0 ? 2 : 4;\n\n      const a = p0;\n      const b = (-5.5 * p0 + 9 * p1 - 4.5 * p2 + p3) / sG;\n      const c = (9 * p0 - 22.5 * p1 + 18 * p2 - 4.5 * p3) / sG_2;\n      const d = (-4.5 * (p0 - 3 * p1 + 3 * p2 - p3)) / sG_3;\n\n      theta = (((d * s / 4 + c / 3) * s + b / 2) * s + a) * s;\n      cosTheta = Math.cos(theta);\n      sinTheta = Math.sin(theta);\n\n      const s_sG = s / sG;\n      dT_p1 = ((3.375 * s_sG - 7.5) * s_sG + 4.5) * s_sG * s;\n      dT_p2 = ((-3.375 * s_sG + 6) * s_sG - 2.25) * s_sG * s;\n      dT_sG = ((3.375 * (p0 - 3 * p1 + 3 * p2 - p3) * s_sG - 3 * (2 * p0 - 5 * p1 + 4 * p2 - p3)) * s_sG + 0.25 * (11 * p0 - 18 * p1 + 9 * p2 - 2 * p3)) * s_sG * s_sG;\n\n      dX_p1 -= coeff * sinTheta * dT_p1;\n      dX_p2 -= coeff * sinTheta * dT_p2;\n      dX_sG -= coeff * sinTheta * dT_sG;\n\n      dY_p1 += coeff * cosTheta * dT_p1;\n      dY_p2 += coeff * cosTheta * dT_p2;\n      dY_sG += coeff * cosTheta * dT_sG;\n\n      guessX += coeff * cosTheta;\n      guessY += coeff * sinTheta;\n    }\n\n    // After the Simpson's integration loop, `theta`, `cosTheta`, `sinTheta`,\n    // `dT_p1`, `dT_p2`, and `dT_sG` hold the appropriate values for `sG`.\n\n    const hOver3 = sG / SIMPSONS_INTERVALS / 3;\n\n    const deltaX = this.goal.x - guessX * hOver3;\n    const deltaY = this.goal.y - guessY * hOver3;\n    const deltaRot = Math.wrapAngle(this.goal.rot - theta);\n\n    if (Math.abs(deltaX) + Math.abs(deltaY) + Math.abs(deltaRot) < CONVERGENCE_ERROR)\n      return true;\n\n    jacobian.set(\n      dX_p1 * hOver3, dX_p2 * hOver3, cosTheta + dX_sG * hOver3,\n      dY_p1 * hOver3, dY_p2 * hOver3, sinTheta + dY_sG * hOver3,\n      dT_p1, dT_p2, dT_sG\n    );\n\n    const [m11, m21, m31, m12, m22, m32, m13, m23, m33] = invJacobian.getInverse(jacobian).elements;\n\n    this.params.p1 += m11 * deltaX + m12 * deltaY + m13 * deltaRot;\n    this.params.p2 += m21 * deltaX + m22 * deltaY + m23 * deltaRot;\n    this.params.sG += m31 * deltaX + m32 * deltaY + m33 * deltaRot;\n\n    return false;\n  }\n\n  buildPath(num) {\n    const { p0, p1, p2, p3, sG } = this.params;\n\n    const sG_2 = sG * sG;\n    const sG_3 = sG_2 * sG;\n\n    const a = p0;\n    const b = (-5.5 * p0 + 9 * p1 - 4.5 * p2 + p3) / sG;\n    const c = (9 * p0 - 22.5 * p1 + 18 * p2 - 4.5 * p3) / sG_2;\n    const d = (-4.5 * (p0 - 3 * p1 + 3 * p2 - p3)) / sG_3;\n\n    const path = [{ pos: new THREE.Vector2(this.start.x, this.start.y), rot: this.start.rot, curv: this.start.curv }];\n    const ds = sG / (num - 1);\n    let s = ds;\n    let dx = 0;\n    let dy = 0;\n    let prevCosRot = Math.cos(path[0].rot);\n    let prevSinRot = Math.sin(path[0].rot);\n\n    for (let i = 1; i < num - 1; i++) {\n      const rot = (((d * s / 4 + c / 3) * s + b / 2) * s + a) * s + this.start.rot;\n      const curv = ((d * s + c) * s + b) * s + a;\n      const cosRot = Math.cos(rot);\n      const sinRot = Math.sin(rot);\n\n      dx = dx * (i - 1) / i + (cosRot + prevCosRot) / (2 * i);\n      dy = dy * (i - 1) / i + (sinRot + prevSinRot) / (2 * i);\n\n      path.push({ pos: new THREE.Vector2(s * dx + this.start.x, s * dy + this.start.y), rot: rot, curv: curv });\n\n      s += ds;\n      prevCosRot = cosRot;\n      prevSinRot = sinRot;\n    }\n\n    path.push({ pos: new THREE.Vector2(this.end.x, this.end.y), rot: this.end.rot, curv: this.end.curv });\n\n    return path;\n  }\n}\n","const halfLaneWidth = 3.7;\n\nconst centerlineGeometry = new THREE.Geometry();\nconst leftBoundaryGeometry = new THREE.Geometry();\nconst rightBoundaryGeometry = new THREE.Geometry();\n\nexport default class LanePath {\n  static hydrate(obj) {\n    Object.setPrototypeOf(obj, LanePath.prototype);\n  }\n\n  constructor() {\n    this.anchors = [];\n    this.centerlines = [];\n    this.sampleLengths = [];\n    this.arcLengths = [];\n    this.leftBoundaries = [];\n    this.rightBoundaries = [];\n  }\n\n  get centerline() {\n    return [].concat(...this.centerlines);\n  }\n\n  get leftBoundary() {\n    return [].concat(...this.leftBoundaries);\n  }\n\n  get rightBoundary() {\n    return [].concat(...this.rightBoundaries);\n  }\n\n  get arcLength() {\n    return this.arcLengths.reduce((sum, l) => sum + l, 0);\n  }\n\n  sampleStations(startStation, num, interval) {\n    const samples = [];\n    let anchorIndex = 0;\n    let sampleIndex = 0;\n    let totalLength = 0;\n    let nextStation = startStation;\n\n    while (totalLength + this.arcLengths[anchorIndex] < nextStation) {\n      totalLength += this.arcLengths[anchorIndex];\n\n      if (++anchorIndex >= this.arcLengths.length)\n        return samples;\n    }\n\n    for (let i = 0; i < num; i++) {\n      let length = this.sampleLengths[anchorIndex][sampleIndex];\n      while (totalLength + length < nextStation) {\n        totalLength += length;\n\n        if (++sampleIndex >= this.sampleLengths[anchorIndex].length) {\n          sampleIndex = 0;\n\n          if (++anchorIndex >= this.sampleLengths.length)\n            return samples;\n        }\n\n        length = this.sampleLengths[anchorIndex][sampleIndex];\n      }\n\n      const [p0, p1, p2, p3] = this.anchorsForSplineIndex(anchorIndex);\n      const weight = (sampleIndex + (nextStation - totalLength) / length) / this.sampleLengths[anchorIndex].length;\n      const pos = catmullRomVec(weight, p0, p1, p2, p3);\n      const tangent = tangentAt(weight, p0, p1, p2, p3);\n      const rot = Math.atan2(tangent.y, tangent.x);\n      const curv = curvatureAt(weight, p0, p1, p2, p3);\n\n      samples.push({ pos, rot, curv });\n      nextStation += interval;\n    }\n\n    return samples;\n  }\n\n  stationLatitudeFromPosition(position, aroundAnchorIndex = null) {\n    const [anchorIndex, sampleIndex, sampleStation, prevSampleStation] = this._findClosestSample(position, aroundAnchorIndex);\n\n    if (anchorIndex === undefined) return [0, 0, 0];\n\n    let prevPoint;\n    let nextPoint;\n    let prevStation;\n    let nextStation;\n\n    if (anchorIndex == 0 && sampleIndex == 0) {\n      prevPoint = this.centerlines[anchorIndex][sampleIndex];\n      nextPoint = this.centerlines[anchorIndex][sampleIndex + 1];\n      prevStation = 0;\n      nextStation = this.sampleLengths[anchorIndex][sampleIndex];\n    } else if (anchorIndex == this.centerlines.length - 1 && sampleIndex == this.centerlines[anchorIndex].length - 1) {\n      prevPoint = this.centerlines[anchorIndex][sampleIndex - 1];\n      nextPoint = this.centerlines[anchorIndex][sampleIndex];\n      prevStation = prevSampleStation;\n      nextStation = sampleStation;\n    } else {\n      prevPoint = sampleIndex == 0 ? this.centerlines[anchorIndex - 1][this.centerlines[anchorIndex - 1].length - 1] : this.centerlines[anchorIndex][sampleIndex - 1];\n      nextPoint = sampleIndex == this.centerlines[anchorIndex].length - 1 ? this.centerlines[anchorIndex + 1][0] : this.centerlines[anchorIndex][sampleIndex + 1];\n\n      const possibleNext = this.centerlines[anchorIndex][sampleIndex];\n      const possibleProgress = position.clone().sub(prevPoint).dot(possibleNext.clone().sub(prevPoint)) / prevPoint.distanceToSquared(possibleNext);\n\n      if (possibleProgress < 1) {\n        nextPoint = possibleNext;\n        prevStation = prevSampleStation;\n        nextStation = sampleStation;\n      } else {\n        prevPoint = possibleNext;\n        prevStation = sampleStation;\n        nextStation = sampleStation + this.sampleLengths[anchorIndex][sampleIndex];\n      }\n    }\n\n    const progress = Math.clamp(position.clone().sub(prevPoint).dot(nextPoint.clone().sub(prevPoint)) / prevPoint.distanceToSquared(nextPoint), 0, 1);\n    const projectedPosition = nextPoint.clone().sub(prevPoint).multiplyScalar(progress).add(prevPoint);\n\n    const station = prevStation + (nextStation - prevStation) * progress;\n    const latitude = Math.sign((nextPoint.x - prevPoint.x) * (position.y - prevPoint.y) - (nextPoint.y - prevPoint.y) * (position.x - prevPoint.x)) * position.distanceTo(projectedPosition);\n\n    return [station, latitude, anchorIndex];\n  }\n\n  _findClosestSample(position, aroundAnchorIndex = null) {\n    let closest = Number.POSITIVE_INFINITY;\n    let bestAnchorIndex;\n    let bestSampleIndex;\n    let bestStation;\n    let bestPrevStation;\n\n    let currStation = 0;\n    let prevStation = 0;\n\n    let startAnchorIndex = 0;\n    let endAnchorIndex = this.centerlines.length - 1;\n\n    if (aroundAnchorIndex !== null) {\n      startAnchorIndex = Math.max(0, aroundAnchorIndex - 2);\n      endAnchorIndex = Math.min(this.centerlines.length - 1, aroundAnchorIndex + 2);\n    }\n\n    if (startAnchorIndex > 0) {\n      for (let anchorIndex = 0; anchorIndex < startAnchorIndex; anchorIndex++) {\n        currStation += this.arcLengths[anchorIndex];\n      }\n\n      prevStation = currStation - this.sampleLengths[startAnchorIndex - 1][this.sampleLengths[startAnchorIndex - 1].length - 1];\n    }\n\n    for (let anchorIndex = startAnchorIndex; anchorIndex <= endAnchorIndex; anchorIndex++) {\n      const centerline = this.centerlines[anchorIndex];\n      for (let sampleIndex = 0; sampleIndex < centerline.length; sampleIndex++) {\n        const distSq = position.distanceToSquared(centerline[sampleIndex]);\n        if (distSq < closest) {\n          closest = distSq;\n          bestAnchorIndex = anchorIndex;\n          bestSampleIndex = sampleIndex;\n          bestStation = currStation;\n          bestPrevStation = prevStation;\n        }\n\n        prevStation = currStation;\n        currStation += this.sampleLengths[anchorIndex][sampleIndex];\n      }\n    }\n\n    return [bestAnchorIndex, bestSampleIndex, bestStation, bestPrevStation];\n  }\n\n  addAnchor(position, resample = true) {\n    const index = this.anchors.push(position) - 1;\n\n    if (resample) {\n      for (let i = index - 2; i < index; i++)\n        this.resample(i);\n    }\n  }\n\n  updateAnchor(index, position) {\n    this.anchors[index] = position;\n\n    for (let i = index - 2; i <= index + 1; i++)\n      this.resample(i);\n  }\n\n  removeAnchor(index) {\n    if (index < 0 || index >= this.anchors.length) return;\n\n    this.anchors.splice(index, 1);\n\n    const segmentIndex = index < this.anchors.length ? index : index - 1;\n    this.centerlines.splice(segmentIndex, 1);\n    this.sampleLengths.splice(segmentIndex, 1);\n    this.leftBoundaries.splice(segmentIndex, 1);\n    this.rightBoundaries.splice(segmentIndex, 1);\n    this.arcLengths.splice(segmentIndex, 1);\n\n    for (let i = segmentIndex - 2; i <= segmentIndex; i++)\n      this.resample(i);\n  }\n\n  resample(index) {\n    if (index < 0 || index > this.anchors.length - 2) return;\n\n    const [p0, p1, p2, p3] = this.anchorsForSplineIndex(index);\n    const points = [];\n    const lengths = [];\n    const leftBoundary = [];\n    const rightBoundary = [];\n    let prevPoint = null;\n\n    const pointsPerSegment = Math.max(10, Math.ceil(p1.distanceTo(p2) / 1));\n    const numPoints = index == this.anchors.length - 2 ? pointsPerSegment + 1 : pointsPerSegment;\n\n    for (let i = 0; i < numPoints; i++) {\n      const t = i / pointsPerSegment;\n      const point = catmullRomVec(t, p0, p1, p2, p3);\n      points.push(point);\n\n      if (prevPoint != null)\n        lengths.push(prevPoint.distanceTo(point));\n      prevPoint = point;\n\n      const tangent = tangentAt(t, p0, p1, p2, p3);\n      const normal = new THREE.Vector2(-tangent.y, tangent.x);\n\n      leftBoundary.push(normal.clone().multiplyScalar(-halfLaneWidth).add(point));\n      rightBoundary.push(normal.clone().multiplyScalar(halfLaneWidth).add(point));\n    }\n\n    lengths.push(prevPoint.distanceTo(p2));\n\n    this.centerlines[index] = points;\n    this.sampleLengths[index] = lengths;\n    this.leftBoundaries[index] = leftBoundary;\n    this.rightBoundaries[index] = rightBoundary;\n    this.arcLengths[index] = lengths.reduce((sum, l) => sum + l, 0);\n  }\n\n  resampleAll() {\n    for (let i = 0; i < this.anchors.length; i++)\n      this.resample(i);\n  }\n\n  anchorsForSplineIndex(index) {\n    let p;\n    if (index == 0)\n      p = [this.anchors[0]].concat(this.anchors.slice(0, 3));\n    else\n      p = this.anchors.slice(index - 1, index + 3);\n\n    if (p[3] === undefined)\n      p[3] = p[2];\n\n    return p;\n  }\n}\n\nfunction catmullRom(t, p0, p1, p2, p3) {\n  const v0 = (p2 - p0) * 0.5;\n  const v1 = (p3 - p1) * 0.5;\n  const t2 = t * t;\n  const t3 = t * t2;\n  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n}\n\nfunction catmullRomVec(t, p0, p1, p2, p3) {\n  return new THREE.Vector2(catmullRom(t, p0.x, p1.x, p2.x, p3.x), catmullRom(t, p0.y, p1.y, p2.y, p3.y));\n}\n\nfunction tangentAt(t, p0, p1, p2, p3) {\n  const delta = 0.0001;\n  let t1 = t - delta;\n  let t2 = t + delta;\n\n  if (t1 < 0) t1 = 0;\n  if (t2 > 1) t2 = 1;\n\n  const prev = catmullRomVec(t1, p0, p1, p2, p3);\n  const next = catmullRomVec(t2, p0, p1, p2, p3);\n\n  return next.sub(prev).normalize();\n}\n\nfunction curvatureAt(t2, p0, p1, p2, p3) {\n  const delta = 0.0001;\n\n  // If we're estimating curvature at one of the endpoints of the spline,\n  // slightly shift it inwards to avoid infinite curvature.\n  if (t2 == 0) t2 = delta;\n  if (t2 == 1) t2 = 1 - delta;\n\n  let t1 = t2 - delta;\n  let t3 = t2 + delta;\n\n  if (t1 < 0) t1 = 0;\n  if (t3 > 1) t3 = 1;\n\n  const pt1 = catmullRomVec(t1, p0, p1, p2, p3);\n  const pt2 = catmullRomVec(t2, p0, p1, p2, p3);\n  const pt3 = catmullRomVec(t3, p0, p1, p2, p3);\n\n  return (Math.atan2(pt3.y - pt2.y, pt3.x - pt2.x) - Math.atan2(pt2.y - pt1.y, pt2.x - pt1.x)) / pt2.distanceTo(pt1);\n}\n","// Half width and half height\nconst VEHICLE_SIZE = { w: 2.5, h: 1 };\nconst CYCLIST_SIZE = { w: 1.2, h: 0.6 };\nconst PEDESTRIAN_SIZE = { w: 0.6, h: 0.6 };\n\nexport default class DynamicObstacle {\n  static hydrate(obj) {\n    Object.setPrototypeOf(obj, DynamicObstacle.prototype);\n    Object.setPrototypeOf(obj.startPos, THREE.Vector2.prototype);\n    Object.setPrototypeOf(obj.velocity, THREE.Vector2.prototype);\n  }\n\n  constructor(type, startPos, velocity, parallel) {\n    this.type = type;\n    this.startPos = startPos;\n    this.velocity = velocity;\n    this.parallel = parallel;\n\n    switch (type) {\n        case 'cyclist':\n          this.size = Object.assign({}, CYCLIST_SIZE);\n          break;\n\n        case 'pedestrian':\n          this.size = Object.assign({}, PEDESTRIAN_SIZE);\n          break;\n\n        default:\n          this.size = Object.assign({}, VEHICLE_SIZE);\n    }\n\n    if (!parallel)\n      [this.size.w, this.size.h] = [this.size.h, this.size.w];\n  }\n\n  positionAtTime(time) {\n    return this.velocity.clone().multiplyScalar(time).add(this.startPos);\n  }\n\n  positionsInTimeRange(startTime, endTime, numFrames) {\n    const dt = (endTime - startTime) / numFrames;\n    const positions = [];\n    let time = startTime;\n\n    for (let i = 0; i <= numFrames; i++) {\n      positions.push(this.positionAtTime(time));\n      time += dt;\n    }\n\n    return positions;\n  }\n\n  verticesInTimeRange(startTime, endTime, config) {\n    const positions = this.positionsInTimeRange(startTime, endTime, config.numDynamicSubframes);\n    const vertices = [];\n\n    // Hazard dilation (drawn behind, z = 0.75)\n    const hazardHalfWidth = this.size.w + config.dynamicHazardDilationS + config.collisionDilationS;\n    const hazardHalfHeight = this.size.h + config.dynamicHazardDilationL + config.collisionDilationL;\n\n    positions.forEach(p => {\n      const v1 = [-hazardHalfWidth + p.x, hazardHalfHeight + p.y];\n      const v2 = [hazardHalfWidth + p.x, hazardHalfHeight + p.y];\n      const v3 = [hazardHalfWidth + p.x, -hazardHalfHeight + p.y];\n      const v4 = [-hazardHalfWidth + p.x, -hazardHalfHeight + p.y];\n\n      vertices.push(\n        v1[0], v1[1], 0.75,\n        v2[0], v2[1], 0.75,\n        v3[0], v3[1], 0.75,\n        v3[0], v3[1], 0.75,\n        v4[0], v4[1], 0.75,\n        v1[0], v1[1], 0.75\n      );\n    });\n    \n    // Collision dilation (drawn in front, z = 0.25)\n    const collisionHalfWidth = this.size.w + config.collisionDilationS;\n    const collisionHalfHeight = this.size.h + config.collisionDilationL;\n\n    positions.forEach(p => {\n      const v1 = [-collisionHalfWidth + p.x, collisionHalfHeight + p.y];\n      const v2 = [collisionHalfWidth + p.x, collisionHalfHeight + p.y];\n      const v3 = [collisionHalfWidth + p.x, -collisionHalfHeight + p.y];\n      const v4 = [-collisionHalfWidth + p.x, -collisionHalfHeight + p.y];\n\n      vertices.push(\n        v1[0], v1[1], 0.25,\n        v2[0], v2[1], 0.25,\n        v3[0], v3[1], 0.25,\n        v3[0], v3[1], 0.25,\n        v4[0], v4[1], 0.25,\n        v1[0], v1[1], 0.25\n      );\n    });\n\n    return vertices;\n  }\n}\n","/* Partially adapted from https://github.com/turbo/js/blob/master/turbo.js\n *\n * Turbo.js License:\n * Copyright (c) 2016 minxomat\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nconst vertexShaderCode = `#version 300 es\nin vec2 position;\nin vec2 texture;\nout vec2 kernelPosition;\n\nvoid main(void) {\n  kernelPosition = texture;\n  gl_Position = vec4(position.xy, 0.0, 1.0);\n}\n`;\n\nconst fragmentShaderHeader = `#version 300 es\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp sampler2DArray;\nprecision highp sampler3D;\nprecision highp samplerCube;\n\nin vec2 kernelPosition;\nout vec4 kernelOut;\nuniform ivec2 kernelSize;\n`;\n\nexport default class GPGPU {\n  static alloc(size, stride) {\n    if (!Number.isInteger(stride) || stride < 1 || stride > 4)\n      throw new Error(\"Data stride must be an integer between 1 and 4.\");\n\n    // Find the smallest perfect square greater than or equal to size\n    const squareSize = Math.pow(Math.ceil(Math.sqrt(size)), 2);\n\n    const data = new Float32Array(squareSize * stride);\n    data.gpgpuSize = size;\n    data.gpgpuStride = stride;\n    return data;\n  }\n\n  constructor(configs, shared = {}) {\n    this._setUpGL();\n\n    this.outputTextures = {};\n    this.sharedTextures = {};\n\n    this.programs = configs.map(c => this._prepareProgram(c));\n\n    for (const name in shared) {\n      const options = shared[name];\n      const { width, height, channels, data } = options;\n      this.sharedTextures[name] = this._createTexture(data, width, height, channels, options);\n    }\n  }\n\n  updateSharedTextures(shared) {\n    this.sharedTextures = {};\n\n    for (const name in shared) {\n      const options = shared[name];\n      const { width, height, channels, data } = options;\n      if (this.sharedTextures[name]) this.gl.deleteTexture(this.sharedTextures[name]);\n      this.sharedTextures[name] = this._createTexture(data, width, height, channels, options);\n    }\n  }\n\n  updateProgram(programOrProgramIndex, config) {\n    const program = typeof(programOrProgramIndex) == 'number' ? this.programs[programOrProgramIndex] : programOrProgramIndex;\n\n    if (!program)\n      throw new Error(`Program with index ${programOrProgramIndex} does not exist.`);\n\n    if (config.inputs)\n      throw new Error('The `updateProgram` function cannot be used to update inputs. Use `updateProgramInputs` instead.');\n\n    if (config.meta)\n      program.meta = Object.assign(program.meta, config.meta);\n\n    if (config.width !== undefined && config.height !== undefined)\n      this.updateProgramSize(program, config.width, config.height);\n\n    if (typeof(config.uniforms) == 'object')\n      this.updateProgramUniforms(program, config.uniforms);\n  }\n\n  updateProgramInputs(programIndex, inputs) {\n    const program = this.programs[programIndex];\n\n    if (!program)\n      throw new Error(`Program with index ${programIndex} does not exist.`);\n\n    if (program.inputTextures.length != inputs.length)\n      throw new Error(`You must provide the same number of inputs as when the program was set up: got ${inputs.length} but expected ${program.inputTextures.length}.`);\n\n    const previousInputWidth = program.inputWidth;\n    const previousInputHeight = program.inputHeight;\n\n    const config = program.config;\n\n    if (config.width === undefined || config.height === undefined) {\n      program.inputWidth = undefined;\n      program.inputHeight = undefined;\n      program.inputDataSize = undefined;\n    }\n\n    this._prepareProgramInputs(program, inputs);\n\n    if (program.inputWidth != previousInputWidth || program.inputHeight != previousInputHeight) {\n      this.gl.useProgram(program.glProgram);\n      this.gl.uniform2i(program.kernelSizeLocation, program.inputWidth, program.inputHeight);\n      this._prepareProgramOutput(program);\n    }\n  }\n\n  updateProgramSize(programOrProgramIndex, width, height) {\n    const program = typeof(programOrProgramIndex) == 'number' ? this.programs[programOrProgramIndex] : programOrProgramIndex;\n\n    if (!program)\n      throw new Error(`Program with index ${programOrProgramIndex} does not exist.`);\n\n    if (program.inputTextures.length != 0)\n      throw new Error(`Size can only be updated on programs with no inputs.`);\n\n    if (width == program.inputWidth && height == program.inputHeight) return;\n\n    program.inputWidth = width;\n    program.inputHeight = height;\n    program.inputDataSize = width * height;\n\n    this.gl.useProgram(program.glProgram);\n    this.gl.uniform2i(program.kernelSizeLocation, program.inputWidth, program.inputHeight);\n    this._prepareProgramOutput(program);\n  }\n\n  updateProgramUniforms(programOrProgramIndex, uniforms) {\n    const program = typeof(programOrProgramIndex) == 'number' ? this.programs[programOrProgramIndex] : programOrProgramIndex;\n    this.gl.useProgram(program.glProgram);\n\n    if (!program)\n      throw new Error(`Program with index ${programOrProgramIndex} does not exist.`);\n\n    for (const uniformName in uniforms) {\n      const value = uniforms[uniformName];\n      let uniform;\n\n      if (uniform = program.uniforms[uniformName]) {\n        this._setUniform(uniform.type, uniform.location, value)\n      } else if (uniform = program.uniformTextures[uniformName]) {\n        if (typeof(value) != 'object' || value.type != 'texture')\n          throw new Error(`Expected texture type for uniform ${uniformName}.`);\n\n        const { width, height, channels, data } = uniform;\n        if (program.uniformTextures[uniformName].texture) this.gl.deleteTexture(program.uniformTextures[uniformName].texture);\n        program.uniformTextures[uniformName].texture = this._createTexture(data, width, height, channels, uniform);\n      } else {\n        throw new Error(`The uniform ${uniformName} does not exist in this program.`);\n      }\n    }\n  }\n\n  run() {\n    const outputs = [];\n\n    for (const program of this.programs) {\n      this.gl.useProgram(program.glProgram);\n      this.gl.viewport(0, 0, program.inputWidth, program.inputHeight);\n      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, program.frameBuffer);\n\n      for (const [index, inputTexture] of program.inputTextures.entries()) {\n        this.gl.activeTexture(this.gl.TEXTURE0 + index);\n        this.gl.bindTexture(this.gl.TEXTURE_2D, inputTexture);\n      }\n\n      for (const uniformName in program.uniformTextures) {\n        const uniformTexture = program.uniformTextures[uniformName];\n        this.gl.activeTexture(this.gl.TEXTURE0 + uniformTexture.index);\n        this.gl.bindTexture(uniformTexture.target, uniformTexture.texture || this.sharedTextures[uniformTexture.name] || this.outputTextures[uniformTexture.name]);\n      }\n\n      if (typeof(program.draw) == 'function') {\n        program.draw(this, program);\n      } else {\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.textureBuffer);\n        this.gl.enableVertexAttribArray(program.textureLocation);\n        this.gl.vertexAttribPointer(program.textureLocation, 2, this.gl.FLOAT, false, 0, 0);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);\n        this.gl.enableVertexAttribArray(program.positionLocation);\n        this.gl.vertexAttribPointer(program.positionLocation, 2, this.gl.FLOAT, false, 0, 0);\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n        if (program.drawProxy) {\n          const draw = (() => this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_SHORT, 0)).bind(this);\n          program.drawProxy(this, program, draw);\n        } else {\n          this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_SHORT, 0);\n        }\n      }\n\n      if (program.output && program.output.name && !program.output.read) {\n        outputs.push(null);\n      } else {\n        const output = new Float32Array(program.inputWidth * program.inputHeight * 4);\n        this.gl.readPixels(0, 0, program.inputWidth, program.inputHeight, this.gl.RGBA, this.gl.FLOAT, output);\n        outputs.push(output.subarray(0, program.inputDataSize * 4));\n      }\n    }\n\n    return outputs;\n  }\n\n  _setUpGL() {\n    let canvas;\n\n    if (self.document)\n      canvas = document.createElement('canvas');\n    else if (self.OffscreenCanvas)\n      canvas = new OffscreenCanvas(0, 0);\n    else\n      throw new Error('Could not create a canvas.');\n\n    const attr = { alpha: false, antialias: false };\n    this.gl = canvas.getContext(\"webgl2\", attr) || canvas.getContext(\"experimental-webgl2\", attr);\n\n    if (!this.gl)\n      throw new Error(\"Unable to initialize WebGL2. Your browser may not support it.\");\n\n    if (!this.gl.getExtension('EXT_color_buffer_float'))\n      throw new Error('Required WebGL extension EXT_color_buffer_float not supported.');\n\n    if (!this.gl.getExtension('OES_texture_float_linear'))\n      throw new Error('Required WebGL extension OES_texture_float_linear not supported.');\n\n    this.positionBuffer = this._newBuffer([-1, -1, 1, -1, 1, 1, -1, 1]);\n    this.textureBuffer = this._newBuffer([0, 0, 1, 0, 1, 1, 0, 1]);\n    this.indexBuffer = this._newBuffer([1, 2, 0, 3, 0, 2], Uint16Array, this.gl.ELEMENT_ARRAY_BUFFER);\n  }\n\n  _prepareProgram(config) {\n    const program = { config };\n\n    program.draw = config.draw;\n    program.drawProxy = config.drawProxy;\n    program.meta = Object.assign({}, config.meta);\n\n    if (config.width && config.height) {\n      program.inputWidth = config.width;\n      program.inputHeight = config.height;\n      program.inputDataSize = config.width * config.height;\n    }\n\n    program.output = config.output;\n\n    const kernel = config.kernel;\n\n    if (typeof(kernel) != 'string' || kernel.length == 0)\n      throw new Error(\"Kernel code cannot be empty.\");\n\n    const inputs = config.inputs || [];\n    const uniforms = config.uniforms || {};\n\n    this._prepareProgramInputs(program, inputs);\n\n    let fragmentShaderConfig = \"\";\n    \n    for (const index in inputs)\n      fragmentShaderConfig += `uniform sampler2D _input${index};\\n`;\n\n    if (program.inputWidth === undefined || program.inputHeight === undefined)\n      throw new Error(\"Unknown kernel size. You must provide either an input or the `width` and `height` parameters in the kernel config.\");\n\n    program.uniformTextures = {};\n    program.uniforms = {};\n\n    for (const uniformName in uniforms) {\n      const uniform = uniforms[uniformName];\n\n      if (typeof(uniform) == 'number') {\n        program.uniforms[uniformName] = {\n          type: 'float',\n          value: uniform\n        };\n        fragmentShaderConfig += `uniform float ${uniformName};\\n`;\n      } else if (Array.isArray(uniform)) {\n        if (uniform.length < 2 || uniform.length > 4)\n          throw new Error(`Array uniforms can only have lengths of 2, 3, or 4 elements (corresponding to vec2, vec3, and vec4).`);\n\n        const type = ['vec2', 'vec3', 'vec4'][uniform.length - 2];\n        program.uniforms[uniformName] = {\n          type: type,\n          value: uniform\n        };\n        fragmentShaderConfig += `uniform ${type} ${uniformName};\\n`;\n      } else {\n        const { type, width, height, channels, data, value, length, name } = uniform;\n\n        if (type == 'texture' || type == 'outputTexture' || type == 'sharedTexture') {\n          let target, type;\n\n          if (uniform.textureType == '3D') {\n            target = this.gl.TEXTURE_3D;\n            type = 'sampler3D';\n          } else if (uniform.textureType == '2DArray') {\n            target = this.gl.TEXTURE_2D_ARRAY;\n            type = 'sampler2DArray';\n          } else {\n            target = this.gl.TEXTURE_2D;\n            type = 'sampler2D';\n          }\n\n          if (type == 'texture') {\n            program.uniformTextures[uniformName] = { target, texture: data ? this._createTexture(data, width, height, channels, uniform) : null };\n          } else {\n            program.uniformTextures[uniformName] = { target, texture: null, name: name || uniformName };\n          }\n\n          fragmentShaderConfig += `uniform ${type} ${uniformName};\\n`;\n        } else {\n          program.uniforms[uniformName] = { type, value };\n          if (length !== undefined)\n            fragmentShaderConfig += `uniform ${type} ${uniformName}[${length}];\\n`;\n          else\n            fragmentShaderConfig += `uniform ${type} ${uniformName};\\n`;\n        }\n      }\n    }\n\n    const vertexShader = this.gl.createShader(this.gl.VERTEX_SHADER);\n    this.gl.shaderSource(vertexShader, config.vertexShader || vertexShaderCode);\n    this.gl.compileShader(vertexShader);\n\n    if (!this.gl.getShaderParameter(vertexShader, this.gl.COMPILE_STATUS)) {\n      throw new Error(\n        \"Could not build vertex shader (fatal).\\n\" + \"\\n\" +\n        \"--- CODE DUMP ---\\n\" + (config.vertexShader || vertexShaderCode) + \"\\n\\n\" +\n        \"--- ERROR LOG ---\\n\" + this.gl.getShaderInfoLog(vertexShader)\n      );\n    }\n\n    const fragmentShaderMain = `\nvoid main() {\n  kernelOut = vec4(kernel(${[...Array(inputs.length).keys()].map(i => `texture(_input${i}, kernelPosition)`).join(', ')}));\n}\n    `;\n\n    const fragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);\n    const fragmentShaderSource = fragmentShaderHeader + fragmentShaderConfig + kernel + fragmentShaderMain;\n    this.gl.shaderSource(fragmentShader, fragmentShaderSource);\n    this.gl.compileShader(fragmentShader);\n\n    if (!this.gl.getShaderParameter(fragmentShader, this.gl.COMPILE_STATUS)) {\n      const source = fragmentShaderSource.split('\\n');\n      let dbgMsg = \"ERROR: Could not build shader (fatal).\\n\\n------------------ KERNEL CODE DUMP ------------------\\n\"\n\n      for (let l = 0; l < source.length; l++)\n        dbgMsg += `${l + 1}> ${source[l]}\\n`;\n\n      dbgMsg += \"\\n--------------------- ERROR  LOG ---------------------\\n\" + this.gl.getShaderInfoLog(fragmentShader);\n\n      throw new Error(dbgMsg);\n    }\n\n    program.glProgram = this.gl.createProgram();\n    this.gl.attachShader(program.glProgram, vertexShader);\n    this.gl.attachShader(program.glProgram, fragmentShader);\n    this.gl.linkProgram(program.glProgram);\n    this.gl.useProgram(program.glProgram);\n\n    if (!this.gl.getProgramParameter(program.glProgram, this.gl.LINK_STATUS))\n      throw new Error('Failed to link GLSL program code.');\n\n    let textureIndex = 0;\n\n    for (const input of program.inputTextures) {\n      const location = this.gl.getUniformLocation(program.glProgram, `_input${textureIndex}`);\n      this.gl.uniform1i(location, textureIndex);\n      textureIndex++;\n    }\n\n    for (const uniformName in program.uniformTextures) {\n      program.uniformTextures[uniformName].index = textureIndex;\n      const location = this.gl.getUniformLocation(program.glProgram, uniformName);\n      this.gl.uniform1i(location, textureIndex);\n      textureIndex++;\n    }\n\n    for (const uniformName in program.uniforms) {\n      const { type, value } = program.uniforms[uniformName];\n      const location = program.uniforms[uniformName].location = this.gl.getUniformLocation(program.glProgram, uniformName);\n\n      if (value !== undefined)\n        this._setUniform(type, location, value);\n\n      delete program.uniforms[uniformName].value;\n    }\n\n    program.kernelSizeLocation = this.gl.getUniformLocation(program.glProgram, 'kernelSize');\n    this.gl.uniform2i(program.kernelSizeLocation, program.inputWidth, program.inputHeight);\n\n    program.positionLocation = this.gl.getAttribLocation(program.glProgram, 'position');\n    program.textureLocation = this.gl.getAttribLocation(program.glProgram, 'texture');\n\n    program.frameBuffer = this.gl.createFramebuffer();\n    this._prepareProgramOutput(program);\n\n    return program;\n  }\n\n  _prepareProgramInputs(program, inputs) {\n    if (program.inputTextures)\n      program.inputTextures.forEach(t => this.gl.deleteTexture(t));\n\n    program.inputTextures = [];\n\n    for (const [index, data] of inputs.entries()) {\n      if (data.gpgpuSize === undefined || data.gpgpuStride === undefined)\n        throw new Error('GPGPU inputs must be created by the `alloc` function.');\n\n      const size = Math.sqrt(data.length / data.gpgpuStride);\n      if (size <= 0 || size % 1 != 0)\n        throw new Error('GPGPU input size is expected to be a perfect square.');\n\n      if (program.inputWidth === undefined || program.inputHeight === undefined) {\n        program.inputWidth = size;\n        program.inputHeight = size;\n        program.inputDataSize = data.gpgpuSize;\n      } else if (size != program.inputWidth || size != program.inputHeight) {\n        throw new Error(`All GPGPU inputs must be of the same size. Received ${data.gpgpuSize} (internal ${size * size}) but expected ${program.inputDataSize} (internal ${program.inputWidth * program.inputHeight}).`);\n      }\n\n      program.inputTextures.push(this._createTexture(data, size, size, data.gpgpuStride));\n    }\n  }\n\n  _prepareProgramOutput(program) {\n    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, program.frameBuffer);\n\n    const outputTexture = this._createTexture(null, program.inputWidth, program.inputHeight, 4, program.output);\n\n    if (program.output && program.output.textureType !== '3D' && program.output.textureType !== '2DArray') {\n      this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, outputTexture, 0);\n      const frameBufferStatus = (this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER) == this.gl.FRAMEBUFFER_COMPLETE);\n      if (!frameBufferStatus)\n        throw new Error('Error attaching float texture to framebuffer. Your device is probably incompatible.');\n    }\n\n    if (program.outputTexture !== undefined)\n      this.gl.deleteTexture(program.outputTexture);\n    program.outputTexture = outputTexture;\n\n    if (program.output && program.output.name)\n      this.outputTextures[program.output.name] = outputTexture;\n  }\n\n  _setUniform(type, location, value) {\n    switch (type) {\n      case 'int': this.gl.uniform1i(location, value); break;\n      case 'float': Array.isArray(value) ? this.gl.uniform1fv(location, value) : this.gl.uniform1f(location, value); break;\n      case 'vec2': this.gl.uniform2fv(location, value); break;\n      case 'vec3': this.gl.uniform3fv(location, value); break;\n      case 'vec4': this.gl.uniform4fv(location, value); break;\n      case 'mat3': this.gl.uniformMatrix3fv(location, value); break;\n      default: throw new Error(`Unknown uniform type ${type}.`);\n    }\n  }\n\n  _newBuffer(data, klass, target) {\n    const buf = this.gl.createBuffer();\n\n    this.gl.bindBuffer((target || this.gl.ARRAY_BUFFER), buf);\n    this.gl.bufferData((target || this.gl.ARRAY_BUFFER), new (klass || Float32Array)(data), this.gl.STATIC_DRAW);\n\n    return buf;\n  }\n\n  _createTexture(data, width, height, channels, options = {}) {\n    const texture = this.gl.createTexture();\n\n    let internalFormat, format;\n\n    switch (channels) {\n      case 1:\n        internalFormat = this.gl.R32F;\n        format = this.gl.RED;\n        break;\n      case 2:\n        internalFormat = this.gl.RG32F;\n        format = this.gl.RG;\n        break;\n      case 3:\n        internalFormat = this.gl.RGB32F;\n        format = this.gl.RGB;\n        break;\n      case 4:\n        internalFormat = this.gl.RGBA32F;\n        format = this.gl.RGBA;\n        break;\n      default:\n        throw(\"Texture channels must between 1 and 4.\");\n    }\n\n    const target = options.textureType == '3D' ? this.gl.TEXTURE_3D : options.textureType == '2DArray' ? this.gl.TEXTURE_2D_ARRAY : this.gl.TEXTURE_2D;\n\n    this.gl.bindTexture(target, texture);\n    this.gl.texParameteri(target, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\n    this.gl.texParameteri(target, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\n    this.gl.texParameteri(target, this.gl.TEXTURE_WRAP_R, this.gl.CLAMP_TO_EDGE);\n    this.gl.texParameteri(target, this.gl.TEXTURE_MIN_FILTER, options.filter == 'linear' ? this.gl.LINEAR : this.gl.NEAREST);\n    this.gl.texParameteri(target, this.gl.TEXTURE_MAG_FILTER, options.filter == 'linear' ? this.gl.LINEAR : this.gl.NEAREST);\n\n    if (options.textureType == '3D' || options.textureType == '2DArray') {\n      this.gl.texImage3D(target, 0, internalFormat, width, height, options.depth, 0, format, this.gl.FLOAT, data);\n    } else {\n      this.gl.texImage2D(target, 0, internalFormat, width, height, 0, format, this.gl.FLOAT, data);\n    }\n\n    this.gl.bindTexture(target, null);\n\n    return texture;\n  }\n}\n","export default class QuinticPath {\n  constructor(start, end, params) {\n    this.start = Object.assign({}, start);\n    this.end = Object.assign({}, end);\n\n    if (start.pos) {\n      this.start.x = start.pos.x;\n      this.start.y = start.pos.y\n    }\n\n    if (end.pos) {\n      this.end.x = end.pos.x;\n      this.end.y = end.pos.y\n    }\n\n    const diffX = this.end.x - this.start.x;\n    const diffY = this.end.y - this.start.y;\n    const sinRot = Math.sin(this.start.rot);\n    const cosRot = Math.cos(this.start.rot);\n\n    this.goal = {\n      x: cosRot * diffX + sinRot * diffY,\n      y: -sinRot * diffX + cosRot * diffY,\n      rot: Math.wrapAngle(this.end.rot - this.start.rot),\n      curv: this.end.curv\n    };\n\n    this.params = Object.assign({}, params, { p0: this.start.curv, p1: this.start.dCurv || 0, p2: this.start.ddCurv || 0, p5: this.end.curv });\n  }\n\n  buildPath(num) {\n    const { p0, p1, p2, p3, p4, p5, sG } = this.params;\n\n    const sG_2 = sG * sG;\n    const sG_3 = sG_2 * sG;\n\n    const a = p0;\n    const b = p1;\n    const c = p2 / 2.0;\n    const d = (-71.875 * p0 + 81.0 * p3 - 10.125 * p4 + p5 - 21.25 * p1 * sG - 2.75 * p2 * sG_2) / sG_3;\n    const e = (166.5 * p0 - 202.5 * p3 + 40.5 * p4 - 4.5 * p5 + 45.0 * p1 * sG + 4.5 * p2 * sG_2) / (sG_2 * sG_2);\n    const f = (-95.625 * p0 + 121.5 * p3 - 30.375 * p4 + 4.5 * p5 - 24.75 * p1 * sG - 2.25 * p2 * sG_2) / (sG_2 * sG_3);\n\n    const path = [{ pos: new THREE.Vector2(this.start.x, this.start.y), rot: this.start.rot, curv: this.start.curv }];\n    const ds = sG / (num - 1);\n    let s = ds;\n    let dx = 0;\n    let dy = 0;\n    let prevCosRot = Math.cos(path[0].rot);\n    let prevSinRot = Math.sin(path[0].rot);\n\n    for (let i = 1; i < num - 1; i++) {\n      const rot = (((((f * s / 6.0 + e / 5.0) * s + d / 4.0) * s + c / 3.0) * s + b / 2.0) * s + a) * s + this.start.rot;\n      const curv = ((((f * s + e) * s + d) * s + c) * s + b) * s + a;\n      const cosRot = Math.cos(rot);\n      const sinRot = Math.sin(rot);\n\n      dx = dx * (i - 1) / i + (cosRot + prevCosRot) / (2 * i);\n      dy = dy * (i - 1) / i + (sinRot + prevSinRot) / (2 * i);\n\n      path.push({ pos: new THREE.Vector2(s * dx + this.start.x, s * dy + this.start.y), rot: rot, curv: curv });\n\n      s += ds;\n      prevCosRot = cosRot;\n      prevSinRot = sinRot;\n    }\n\n    path.push({ pos: new THREE.Vector2(this.end.x, this.end.y), rot: this.end.rot, curv: this.end.curv });\n\n    return path;\n  }\n}\n","const OBSTACLE_VERTEX_SHADER = `#version 300 es\nuniform mat3 xform;\nin vec2 position;\n\nvoid main(void) {\n  gl_Position = vec4((xform * vec3(position, 1)).xy, 0, 1);\n}\n`;\n\nconst OBSTACLE_KERNEL = `\n  vec4 kernel() {\n    return vec4(1, 0, 0, 1);\n  }\n`;\n\nlet obstacleVertices;\nlet obstacleXform;\n\n// Draw obstacle triangles to XY-space obstacle grid\nexport default {\n  setUp() {\n    return {\n      kernel: OBSTACLE_KERNEL,\n      vertexShader: OBSTACLE_VERTEX_SHADER,\n      output: { name: 'xyObstacleGrid' },\n      draw: (gpgpu, program) => {\n        const gl = gpgpu.gl;\n\n        gl.clearColor(0, 0, 0, 0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        if (obstacleVertices.length > 0) {\n          const buf = gl.createBuffer();\n\n          gl.bindBuffer(gl.ARRAY_BUFFER, buf);\n          gl.bufferData(gl.ARRAY_BUFFER, obstacleVertices, gl.STATIC_DRAW);\n          gl.enableVertexAttribArray(program.positionLocation);\n          gl.vertexAttribPointer(program.positionLocation, 2, gl.FLOAT, false, 0, 0);\n\n          const xformLocation = gl.getUniformLocation(program.glProgram, 'xform');\n          gl.uniformMatrix3fv(xformLocation, false, obstacleXform.elements);\n\n          gl.drawArrays(gl.TRIANGLES, 0, obstacleVertices.length / 2);\n\n          gl.deleteBuffer(buf);\n        }\n      }\n    };\n  },\n\n  update(config, xyWidth, xyHeight, xyCenterPoint, vehicleXform, obstacles) {\n    obstacleVertices = new Float32Array(Array.prototype.concat.apply([], obstacles.map(o => o.vertices)));\n\n    const translate = new THREE.Matrix3();\n    translate.set(\n      1, 0, -xyCenterPoint.x,\n      0, 1, -xyCenterPoint.y,\n      0, 0, 1\n    );\n\n    const scale = new THREE.Matrix3();\n    scale.set(\n      2 / (xyWidth * config.xyGridCellSize), 0, 0,\n      0, 2 / (xyHeight * config.xyGridCellSize), 0,\n      0, 0, 1\n    );\n\n    obstacleXform = scale.multiply(translate).multiply(vehicleXform);\n\n    return {\n      width: xyWidth,\n      height: xyHeight\n    }\n  }\n}\n","const SL_OBSTACLE_KERNEL = `\n\nvec4 kernel() {\n  float centerlineWidth = float(textureSize(centerline, 0).x);\n\n  vec2 sl = (kernelPosition - 0.5) * vec2(kernelSize) * vec2(slGridCellSize) + slCenterPoint;\n  float centerlineCoord = sl.x / centerlineStationInterval / centerlineWidth * (centerlineWidth - 1.0) / centerlineWidth + (0.5 / centerlineWidth);\n  if (centerlineCoord < 0.0 || centerlineCoord > 1.0) return vec4(0);\n\n  vec3 centerlineSample = texture(centerline, vec2(centerlineCoord, 0)).xyz;\n  float perpindicular = centerlineSample.z + radians(90.0);\n  vec2 xy = centerlineSample.xy + sl.yy * vec2(cos(perpindicular), sin(perpindicular));\n\n  vec2 xyTexCoords = (xy - xyCenterPoint) / vec2(textureSize(xyObstacleGrid, 0)) / vec2(xyGridCellSize) + 0.5;\n  return texture(xyObstacleGrid, xyTexCoords);\n}\n\n`;\n\n// Convert XY-space obstacle grid to SL-space obstacle grid\nexport default {\n  setUp() {\n    return {\n      kernel: SL_OBSTACLE_KERNEL,\n      output: { name: 'slObstacleGrid' },\n      uniforms: {\n        xyObstacleGrid: { type: 'outputTexture' },\n        slGridCellSize: { type: 'float' },\n        xyGridCellSize: { type: 'float' },\n        slCenterPoint: { type: 'vec2' },\n        xyCenterPoint: { type: 'vec2' },\n        centerlineStationInterval: { type: 'float' },\n        centerline: { type: 'sharedTexture' }\n      }\n    }\n  },\n\n  update(config, slWidth, slHeight, slCenterPoint, xyCenterPoint) {\n    return {\n      width: slWidth,\n      height: slHeight,\n      uniforms: {\n        slGridCellSize: config.slGridCellSize,\n        xyGridCellSize: config.xyGridCellSize,\n        slCenterPoint: [slCenterPoint.x, slCenterPoint.y],\n        xyCenterPoint: [xyCenterPoint.x, xyCenterPoint.y],\n        centerlineStationInterval: config.centerlineStationInterval\n      }\n    }\n  }\n}\n","const SL_OBSTACLE_DILATION_KERNEL = `\n\n// TODO: test performance of returning early if non-zero pixel found\nvec4 kernel() {\n  float val = 0.0;\n\n  for (int d = 0; d <= collisionDilation; d++) {\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(d)).r);\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(-d)).r);\n  }\n\n  for (int d = collisionDilation + 1; d <= collisionDilation + hazardDilation; d++) {\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(d)).r * 0.5);\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(-d)).r * 0.5);\n  }\n\n  val = max(val, step(0.1, val) * 0.5);\n\n  return vec4(val, 0, 0, 1);\n}\n\n`;\n\nexport default {\n  setUp() {\n    return [\n      { // SL-space obstacle grid S dilation\n        kernel: SL_OBSTACLE_DILATION_KERNEL,\n        output: { name: 'slObstacleGridStationDilated' },\n        uniforms: {\n          slObstacleGrid: { type: 'outputTexture' },\n          delta: { type: 'vec2' },\n          collisionDilation: { type: 'int' },\n          hazardDilation: { type: 'int' }\n        }\n      },\n      { // SL-space obstacle grid L dilation\n        kernel: SL_OBSTACLE_DILATION_KERNEL,\n        output: { name: 'slObstacleGridDilated' },\n        uniforms: {\n          slObstacleGrid: { type: 'outputTexture', name: 'slObstacleGridStationDilated' },\n          delta: { type: 'vec2' },\n          collisionDilation: { type: 'int' },\n          hazardDilation: { type: 'int' }\n        }\n      }\n    ];\n  },\n\n  update(config, slWidth, slHeight) {\n    return [\n      { // SL-space obstacle grid S dilation\n        width: slWidth,\n        height: slHeight,\n        uniforms: {\n          delta: [1 / slWidth, 0],\n          collisionDilation: Math.ceil(config.collisionDilationS / config.slGridCellSize),\n          hazardDilation: Math.ceil(config.hazardDilationS / config.slGridCellSize)\n        }\n      },\n      { // SL-space obstacle grid L dilation\n        width: slWidth,\n        height: slHeight,\n        uniforms: {\n          delta: [0, 1 / slHeight],\n          collisionDilation: Math.ceil(config.collisionDilationL / config.slGridCellSize),\n          hazardDilation: Math.ceil(config.hazardDilationL / config.slGridCellSize)\n        }\n      }\n    ];\n  }\n}\n","const DYNAMIC_OBSTACLE_VERTEX_SHADER = `#version 300 es\nuniform mat3 xform;\nin vec3 position;\nout float color;\n\nvoid main(void) {\n  gl_Position = vec4((xform * vec3(position.xy, 1)).xy, position.z, 1);\n\n  // The z coordinate is 0.25 for collision zone and 0.75 for hazard zone,\n  // so that the collision zone is drawn on top.\n  // Convert this to 1.0 for collision zone, 0.5 for hazard zone\n  color = (1.0 - step(0.5, position.z)) * 0.5 + 0.5;\n}\n`;\n\nconst DYNAMIC_OBSTACLE_KERNEL = `\n  in float color;\n\n  vec4 kernel() {\n    return vec4(color, 0, 0, 1);\n  }\n`;\n\nlet obstacleVertices;\nlet obstacleXform;\nconst numDynamicFrames = 20;\n\n// Draw dynamic obstacle triangles to SL-space obstacle grid\nexport default {\n  setUp() {\n    return {\n      kernel: DYNAMIC_OBSTACLE_KERNEL,\n      vertexShader: DYNAMIC_OBSTACLE_VERTEX_SHADER,\n      output: { name: 'slDynamicObstacleGrid', textureType: '2DArray', depth: numDynamicFrames },\n      draw: (gpgpu, program) => {\n        const gl = gpgpu.gl;\n\n        gl.enable(gl.DEPTH_TEST);\n\n        const renderbuffer = gl.createRenderbuffer();\n        gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);\n        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, program.inputWidth, program.inputHeight);\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);\n\n        for (let frame = 0; frame < numDynamicFrames; frame++) {\n          gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, program.outputTexture, 0, frame);\n          const frameBufferStatus = (gl.checkFramebufferStatus(gl.FRAMEBUFFER) == gl.FRAMEBUFFER_COMPLETE);\n          if (!frameBufferStatus)\n            throw new Error('Error attaching float texture to framebuffer. Your device is probably incompatible.');\n\n          gl.clearColor(0, 0, 0, 0);\n          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n          if (obstacleVertices[frame].length > 0) {\n            const buf = gl.createBuffer();\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, buf);\n            gl.bufferData(gl.ARRAY_BUFFER, obstacleVertices[frame], gl.STATIC_DRAW);\n            gl.enableVertexAttribArray(program.positionLocation);\n            gl.vertexAttribPointer(program.positionLocation, 3, gl.FLOAT, false, 0, 0);\n\n            const xformLocation = gl.getUniformLocation(program.glProgram, 'xform');\n            gl.uniformMatrix3fv(xformLocation, false, obstacleXform.elements);\n\n            gl.drawArrays(gl.TRIANGLES, 0, obstacleVertices[frame].length / 3);\n\n            if (frame == 0) {\n              const obstacleGrid = new Float32Array(program.inputWidth * program.inputHeight * 4);\n              gl.readPixels(0, 0, program.inputWidth, program.inputHeight, gl.RGBA, gl.FLOAT, obstacleGrid);\n              gpgpu._dynamicObstacleGrid = obstacleGrid;\n            }\n\n            gl.deleteBuffer(buf);\n          }\n        }\n\n        gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n        gl.deleteRenderbuffer(renderbuffer);\n        gl.disable(gl.DEPTH_TEST);\n      }\n    };\n  },\n\n  update(config, slWidth, slHeight, slCenterPoint, vehicleStation, startTime, dynamicFrameTime, dynamicObstacles) {\n    obstacleVertices = [];\n\n    let time = startTime;\n    for (let frame = 0; frame < numDynamicFrames; frame++) {\n      const vertices = Array.prototype.concat.apply([], dynamicObstacles.map(o => o.verticesInTimeRange(time, time + dynamicFrameTime, config)));\n      obstacleVertices.push(new Float32Array(vertices));\n      time += dynamicFrameTime;\n    }\n\n    const translate = new THREE.Matrix3();\n    translate.set(\n      1, 0, -slCenterPoint.x - vehicleStation,\n      0, 1, -slCenterPoint.y,\n      0, 0, 1\n    );\n\n    const scale = new THREE.Matrix3();\n    scale.set(\n      2 / (slWidth * config.slGridCellSize), 0, 0,\n      0, 2 / (slHeight * config.slGridCellSize), 0,\n      0, 0, 1\n    );\n\n    obstacleXform = scale.multiply(translate);\n\n    return {\n      width: slWidth,\n      height: slHeight\n    }\n  }\n}\n","const XYSL_MAP_KERNEL = `\n\nvec4 kernel() {\n  vec2 xy = (kernelPosition - 0.5) * vec2(kernelSize) * vec2(xyGridCellSize) + xyCenterPoint;\n\n  int numSamples = textureSize(centerline, 0).x;\n  int closest = 0;\n  float closestDist = distance(xy, texelFetch(centerline, ivec2(0, 0), 0).xy);\n  for (int i = 1; i < numSamples; i++) {\n    float dist = distance(xy, texelFetch(centerline, ivec2(i, 0), 0).xy);\n    if (dist < closestDist) {\n      closestDist = dist;\n      closest = i;\n    }\n  }\n\n  vec2 closestPos = texelFetch(centerline, ivec2(closest, 0), 0).xy;\n  vec2 prev, next;\n  int prevIndex, nextIndex;\n\n  if (closest == 0) {\n    prevIndex = 0;\n    nextIndex = 1;\n    prev = closestPos;\n    next = texelFetch(centerline, ivec2(1, 0), 0).xy;\n  } else if (closest == numSamples - 1) {\n    prevIndex = closest - 1;\n    nextIndex = closest;\n    prev = texelFetch(centerline, ivec2(prevIndex, 0), 0).xy;\n    next = closestPos;\n  } else {\n    vec2 before = texelFetch(centerline, ivec2(closest - 1, 0), 0).xy;\n    vec2 after = texelFetch(centerline, ivec2(closest + 1, 0), 0).xy;\n\n    if (distance(before, xy) < distance(after, xy)) {\n      prevIndex = closest - 1;\n      nextIndex = closest;\n      prev = before;\n      next = closestPos;\n    } else {\n      prevIndex = closest;\n      nextIndex = closest + 1;\n      prev = closestPos;\n      next = after;\n    }\n  }\n\n  float dist = distance(prev, next);\n  float progress = clamp(dot(xy - prev, next - prev) / dist / dist, 0.0, 1.0);\n  vec2 projectedPos = (next - prev) * vec2(progress) + prev;\n\n  return vec4(\n    (float(prevIndex) + progress) * centerlineStationInterval,\n    sign(determinant(mat2(next - prev, xy - prev))) * distance(xy, projectedPos),\n    0,\n    0\n  );\n}\n\n`;\n\n// Build XY-SL map\nexport default {\n  setUp() {\n    return {\n      kernel: XYSL_MAP_KERNEL,\n      output: { name: 'xyslMap', filter: 'linear' },\n      uniforms: {\n        centerline: { type: 'sharedTexture' },\n        xyCenterPoint: { type: 'vec2' },\n        xyGridCellSize: { type: 'float'},\n        centerlineStationInterval: { type: 'float'}\n      }\n    };\n  },\n\n  update(config, xyWidth, xyHeight, xyCenterPoint) {\n    return {\n      width: xyWidth,\n      height: xyHeight,\n      uniforms: {\n        xyCenterPoint: [xyCenterPoint.x, xyCenterPoint.y],\n        xyGridCellSize: config.xyGridCellSize,\n        centerlineStationInterval: config.centerlineStationInterval\n      }\n    };\n  }\n}\n","// Config:\n// num stations\n// num latitudes\n// station connectivity\n// latitude connectivity\n//\n// Shared:\n// lattice\n\nconst OPTIMIZE_CUBIC_SHARED = `\n\nconst int NEWTON_ITERATIONS = 16;\nconst int RELAXATION_ITERATIONS = 16;\nconst float CONVERGENCE_ERROR = 0.01;\n\n// These two consts must stay in sync.\nconst int SIMPSONS_INTERVALS = 8;\n//const float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\nconst float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float TWO_PI = PI + PI;\n\nconst float RELAXATION_ITERATIONS_F = float(RELAXATION_ITERATIONS);\nconst float SIMPSONS_INTERVALS_F = float(SIMPSONS_INTERVALS);\n\nfloat wrapAngle(float angle) {\n  angle = mod(angle, TWO_PI);\n  if (angle <= -PI) return angle + TWO_PI;\n  else if (angle > PI) return angle - TWO_PI;\n  return angle;\n}\n\nvec4 iterate(vec4 goal, float p0, float p1, float p2, float p3, float sG) {\n  float ds = sG / SIMPSONS_INTERVALS_F;\n  float sG_2 = sG * sG;\n  float sG_3 = sG_2 * sG;\n\n  vec3 dX_p = vec3(0.0);\n  vec3 dY_p = vec3(0.0);\n  vec2 guess = vec2(0.0);\n  float s = 0.0;\n\n  float theta, cosTheta, sinTheta;\n  vec3 dT_p;\n\n  for (int i = 0; i <= SIMPSONS_INTERVALS; i++) {\n    float coeff = SIMPSONS_COEFFS[i];\n\n    float a = p0;\n    float b = (-5.5 * p0 + 9.0 * p1 - 4.5 * p2 + p3) / sG;\n    float c = (9.0 * p0 - 22.5 * p1 + 18.0 * p2 - 4.5 * p3) / sG_2;\n    float d = (-4.5 * (p0 - 3.0 * p1 + 3.0 * p2 - p3)) / sG_3;\n\n    theta = (((d * s / 4.0 + c / 3.0) * s + b / 2.0) * s + a) * s;\n    cosTheta = cos(theta);\n    sinTheta = sin(theta);\n\n    float s_sG = s / sG;\n\n    dT_p = vec3(\n      // p1\n      ((3.375 * s_sG - 7.5) * s_sG + 4.5) * s_sG * s,\n\n      // p2\n      ((-3.375 * s_sG + 6.0) * s_sG - 2.25) * s_sG * s,\n\n      // sG\n      ((3.375 * (p0 - 3.0 * p1 + 3.0 * p2 - p3) * s_sG - 3.0 * (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3)) * s_sG + 0.25 * (11.0 * p0 - 18.0 * p1 + 9.0 * p2 - 2.0 * p3)) * s_sG * s_sG\n    );\n\n    dX_p -= coeff * sinTheta * dT_p;\n    dY_p += coeff * cosTheta * dT_p;\n\n    guess += coeff * vec2(cosTheta, sinTheta);\n\n    s += ds;\n  }\n\n  float hOver3 = sG / SIMPSONS_INTERVALS_F / 3.0;\n\n  vec3 delta;\n  delta.xy = goal.xy - guess * hOver3;\n  delta.z = wrapAngle(goal.z - theta);\n\n  if (abs(delta.x) + abs(delta.y) + abs(delta.z) < CONVERGENCE_ERROR)\n    return vec4(p1, p2, sG, 1.0);\n\n  dX_p.xyz *= hOver3;\n  dY_p.xyz *= hOver3;\n  dX_p.z += cosTheta;\n  dY_p.z += sinTheta;\n\n  mat3 invJacobian = inverse(transpose(mat3(dX_p, dY_p, dT_p)));\n\n  vec3 deltaP = invJacobian * delta;\n  vec4 params = vec4(p1, p2, sG, 0.0);\n  params.xyz += deltaP;\n\n  return params;\n}\n\n/* Input:\n *   start: (vec4)\n *     x: x position,\n *     y: y position,\n *     z: theta rotation,\n *     w: k curvature\n *   end: (vec4)\n *     x: x position,\n *     y: y position,\n *     z: theta rotation,\n *     w: k curvature\n *\n * Output: (vec4)\n *   x: p1,\n *   y: p2,\n *   z: sG,\n *   w: 1 if converged, 0 if not\n */\n\nvec4 optimize(vec4 start, vec4 end) {\n  // Translate and rotate start and end so that start is at the origin\n  float sinRot = sin(start.z);\n  float cosRot = cos(start.z);\n\n  vec4 diff = end - start;\n  vec4 goal;\n  goal.xy = mat2(cosRot, -sinRot, sinRot, cosRot) * diff.xy;\n  goal.z = wrapAngle(diff.z);\n  goal.w = end.w;\n\n  vec4 originalGoal = goal;\n  vec4 dGoal;\n  dGoal.x = 0.0;\n  dGoal.yzw = goal.yzw / RELAXATION_ITERATIONS_F;\n  float dK0 = start.w / RELAXATION_ITERATIONS_F;\n\n  // Relax the goal to (x, 0, 0, 0)\n  goal.yzw = vec3(0, 0, 0);\n\n  // Relax the params to (0, 0, 0, 0, goal.x)\n  float p0 = 0.0;\n  float p1 = 0.0;\n  float p2 = 0.0;\n  float p3 = 0.0;\n  float sG = goal.x;\n\n  if (sG < 0.1) return vec4(0.0);\n\n  for (int i = 0; i < RELAXATION_ITERATIONS; i++) {\n    p0 += dK0;\n    p3 += dGoal.w;\n    goal += dGoal;\n    \n    vec4 result = iterate(goal, p0, p1, p2, p3, sG);\n    p1 = result.x;\n    p2 = result.y;\n    sG = result.z;\n  }\n\n  goal = originalGoal;\n\n  for (int i = 0; i < NEWTON_ITERATIONS; i++) {\n    vec4 result = iterate(goal, p0, p1, p2, p3, sG);\n    if (result.w == 1.0) {\n      result.w = step(0.0, result.z);\n      return result;\n    }\n\n    p1 = result.x;\n    p2 = result.y;\n    sG = result.z;\n  }\n\n  return vec4(p1, p2, sG, 0.0);\n}\n\n`;\n\nconst OPTIMIZE_CUBIC_KERNEL = OPTIMIZE_CUBIC_SHARED + `\n\n// width: station * latitude index\n// height: station_conn * lattice_conn\n//\n// lattice:\n// width: latitudes\n// height: stations\n\nvec4 kernel() {\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\n\n  int endStation = indexes.x / numLatitudes;\n  int endLatitude = int(mod(float(indexes.x), float(numLatitudes)));\n\n  int startStation = endStation - stationConnectivity + indexes.y / latitudeConnectivity;\n  int startLatitude = endLatitude - latitudeConnectivity / 2 + int(mod(float(indexes.y), float(latitudeConnectivity)));\n\n  if (startStation < 0 || startStation >= numStations || startLatitude < 0 || startLatitude >= numLatitudes)\n    return vec4(0.0);\n\n  vec4 start = texelFetch(lattice, ivec2(startLatitude, startStation), 0);\n  vec4 end = texelFetch(lattice, ivec2(endLatitude, endStation), 0);\n\n  return optimize(start, end);\n}\n\n`;\n\nconst OPTIMIZE_CUBIC_FROM_VEHICLE_KERNEL = OPTIMIZE_CUBIC_SHARED + `\n\nvec4 kernel() {\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\n\n  vec4 start = vec4(0, 0, 0, curvVehicle);\n  vec4 end = texelFetch(lattice, indexes, 0);\n\n  return optimize(start, end);\n}\n\n`;\n\nexport default {\n  setUp() {\n    return [\n      { // Cubic paths between lattice nodes\n        kernel: OPTIMIZE_CUBIC_KERNEL,\n        output: { name: 'cubicPaths', read: true },\n        uniforms: {\n          lattice: { type: 'sharedTexture' },\n          numStations: { type: 'int' },\n          numLatitudes: { type: 'int' },\n          stationConnectivity: { type: 'int' },\n          latitudeConnectivity: { type: 'int' }\n        }\n      },\n      { // Cubic paths from vehicle to lattice nodes\n        kernel: OPTIMIZE_CUBIC_FROM_VEHICLE_KERNEL,\n        output: { name: 'cubicPathsFromVehicle', read: true },\n        uniforms: {\n          lattice: { type: 'sharedTexture' },\n          curvVehicle: { type: 'float' }\n        }\n      }\n    ]\n  },\n\n  update(config, pose) {\n    return [\n      { // Cubic paths between lattice nodes\n        width: config.lattice.numStations * config.lattice.numLatitudes,\n        height: config.lattice.stationConnectivity * config.lattice.latitudeConnectivity,\n        uniforms: {\n          numStations: config.lattice.numStations,\n          numLatitudes: config.lattice.numLatitudes,\n          stationConnectivity: config.lattice.stationConnectivity,\n          latitudeConnectivity: config.lattice.latitudeConnectivity,\n        }\n      },\n      { // Cubic paths from vehicle to lattice nodes\n        width: config.lattice.numLatitudes,\n        height: config.lattice.stationConnectivity,\n        uniforms: {\n          curvVehicle: pose.curv\n        }\n      }\n    ];\n  }\n}\n","const OPTIMIZE_KERNEL = `\n\nconst int NEWTON_ITERATIONS = 32;\nconst int RELAXATION_ITERATIONS = 32;\nconst float CONVERGENCE_ERROR = 0.01;\n\n// These two consts must stay in sync.\nconst int SIMPSONS_INTERVALS = 8;\nconst float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float TWO_PI = PI + PI;\n\nconst float RELAXATION_ITERATIONS_F = float(RELAXATION_ITERATIONS);\nconst float SIMPSONS_INTERVALS_F = float(SIMPSONS_INTERVALS);\n\nfloat wrapAngle(float angle) {\n  angle = mod(angle, TWO_PI);\n  if (angle <= -PI) return angle + TWO_PI;\n  else if (angle > PI) return angle - TWO_PI;\n  return angle;\n}\n\nvec4 iterate(vec4 goal, float p0, float p1, float p2, float p3, float p4, float p5, float sG) {\n  float ds = sG / SIMPSONS_INTERVALS_F;\n  float sG_2 = sG * sG;\n  float sG_3 = sG_2 * sG;\n\n  vec3 dX_p = vec3(0.0);\n  vec3 dY_p = vec3(0.0);\n  vec2 guess = vec2(0.0);\n  float s = 0.0;\n\n  float theta, cosTheta, sinTheta;\n  vec3 dT_p;\n\n  for (int i = 0; i <= SIMPSONS_INTERVALS; i++) {\n    float coeff = SIMPSONS_COEFFS[i];\n\n    float a = p0;\n    float b = p1;\n    float c = p2 / 2.0;\n    float d = (-71.875 * p0 + 81.0 * p3 - 10.125 * p4 + p5 - 21.25 * p1 * sG - 2.75 * p2 * sG_2) / sG_3;\n    float e = (166.5 * p0 - 202.5 * p3 + 40.5 * p4 - 4.5 * p5 + 45.0 * p1 * sG + 4.5 * p2 * sG_2) / (sG_2 * sG_2);\n    float f = (-95.625 * p0 + 121.5 * p3 - 30.375 * p4 + 4.5 * p5 - 24.75 * p1 * sG - 2.25 * p2 * sG_2) / (sG_2 * sG_3);\n\n    theta = (((((f * s / 6.0 + e / 5.0) * s + d / 4.0) * s + c / 3.0) * s + b / 2.0) * s + a) * s;\n    cosTheta = cos(theta);\n    sinTheta = sin(theta);\n\n    float s_2 = s * s;\n    float s_sG = s / sG;\n    float s_sG_2 = s_sG * s_sG;\n    float s_sG_3 = s_sG_2 * s_sG;\n    float s_sG_4 = s_sG_3 * s_sG;\n    float s_sG_5 = s_sG_4 * s_sG;\n\n    dT_p = vec3(\n      // p3\n      ((20.25 * s_sG - 40.5) * s_sG + 20.25) * s_sG_3 * s,\n\n      // p4\n      ((-5.0625 * s_sG + 8.1) * s_sG - 2.53125) * s_sG_3 * s,\n\n      // sG\n      (53.90625 * p0 - 60.75 * p3 + 7.59375 * p4 - 0.75 * p5) * s_sG_4 + 10.625 * p1 * s * s_sG_3 + 0.6875 * p2 * s_2 * s_sG_2 + (-133.2 * p0 + 162.0 * p3 - 32.4 * p4 + 3.6 * p5) * s_sG_5 + (-27.0) * p1 * s * s_sG_4 - 1.8 * p2 * s_2 * s_sG_3 + (79.6875 * p0 - 101.25 * p3 + 25.3125 * p4 - 3.75 * p5) * s_sG_5 * s_sG + 16.5 * p1 * s * s_sG_5 + 1.125 * p2 * s_2 * s_sG_4\n    );\n\n    dX_p -= coeff * sinTheta * dT_p;\n    dY_p += coeff * cosTheta * dT_p;\n\n    guess += coeff * vec2(cosTheta, sinTheta);\n\n    s += ds;\n  }\n\n  float hOver3 = sG / SIMPSONS_INTERVALS_F / 3.0;\n\n  vec3 delta;\n  delta.xy = goal.xy - guess * hOver3;\n  delta.z = wrapAngle(goal.z - theta);\n\n  if (abs(delta.x) + abs(delta.y) + abs(delta.z) < CONVERGENCE_ERROR)\n    return vec4(p3, p4, sG, 1.0);\n\n  dX_p.xyz *= hOver3;\n  dY_p.xyz *= hOver3;\n  dX_p.z += cosTheta;\n  dY_p.z += sinTheta;\n\n  mat3 invJacobian = inverse(transpose(mat3(dX_p, dY_p, dT_p)));\n\n  vec3 deltaP = invJacobian * delta;\n  vec4 params = vec4(p3, p4, sG, 0.0);\n  params.xyz += deltaP;\n\n  return params;\n}\n\nvec4 optimize(vec4 start, vec4 end) {\n  // Translate and rotate start and end so that start is at the origin\n  float sinRot = sin(start.z);\n  float cosRot = cos(start.z);\n\n  vec4 diff = end - start;\n  vec4 goal;\n  goal.xy = mat2(cosRot, -sinRot, sinRot, cosRot) * diff.xy;\n  goal.z = wrapAngle(diff.z);\n  goal.w = end.w;\n\n  vec4 originalGoal = goal;\n  vec4 dGoal;\n  dGoal.x = 0.0;\n  dGoal.yzw = goal.yzw / RELAXATION_ITERATIONS_F;\n  float d_K0 = start.w / RELAXATION_ITERATIONS_F;\n  float d_dK0 = dCurvVehicle / RELAXATION_ITERATIONS_F;\n  float d_ddK0 = ddCurvVehicle / RELAXATION_ITERATIONS_F;\n\n  // Relax the goal to (x, 0, 0, 0)\n  goal.yzw = vec3(0, 0, 0);\n\n  // Relax the params to (0, 0, 0, 0, goal.x)\n  float p0 = 0.0;\n  float p1 = 0.0;\n  float p2 = 0.0;\n  float p3 = 0.0;\n  float p4 = 0.0;\n  float p5 = 0.0;\n  float sG = goal.x;\n\n  if (sG < 0.1) return vec4(0.0);\n\n  for (int i = 0; i < RELAXATION_ITERATIONS; i++) {\n    p0 += d_K0;\n    p1 += d_dK0;\n    p2 += d_ddK0;\n    p5 += dGoal.w;\n    goal += dGoal;\n    \n    vec4 result = iterate(goal, p0, p1, p2, p3, p4, p5, sG);\n    p3 = result.x;\n    p4 = result.y;\n    sG = result.z;\n  }\n\n  goal = originalGoal;\n\n  for (int i = 0; i < NEWTON_ITERATIONS; i++) {\n    vec4 result = iterate(goal, p0, p1, p2, p3, p4, p5, sG);\n    if (result.w == 1.0) {\n      result.w = step(0.0, result.z);\n      return result;\n    }\n\n    p3 = result.x;\n    p4 = result.y;\n    sG = result.z;\n  }\n\n  return vec4(p3, p4, sG, 0.0);\n}\n\nvec4 kernel() {\n  ivec2 latticeIndexes = ivec2(kernelPosition * vec2(kernelSize));\n\n  vec4 start = vec4(0, 0, 0, curvVehicle);\n  vec4 end = texelFetch(lattice, latticeIndexes, 0);\n\n  return optimize(start, end);\n}\n\n`;\n\n// Quintic spiral path optimizer\n//   * Start of paths is the vehicle pose\n//     * x-pos, y-pos, and rotation aren't needed, since the lattice origin is the vehicle pose\n//     * So assume position and rotation are 0\n//   * Ends of paths are all latitudes within the first (stationConnectivity) stations\nexport default {\n  setUp() {\n    return {\n      kernel: OPTIMIZE_KERNEL,\n      output: { name: 'quinticPathsFromVehicle', read: true },\n      uniforms: {\n        lattice: { type: 'sharedTexture' },\n        curvVehicle: { type: 'float' },\n        dCurvVehicle: { type: 'float' },\n        ddCurvVehicle: { type: 'float' }\n      }\n    };\n  },\n\n  update(config, pose) {\n    return {\n      width: config.lattice.numLatitudes,\n      height: config.lattice.stationConnectivity,\n      uniforms: {\n        curvVehicle: pose.curv,\n        dCurvVehicle: pose.dCurv,\n        ddCurvVehicle: pose.ddCurv\n      }\n    };\n  }\n}\n","const SHARED_SHADER = `\n\nconst float smallV = 0.01;\nvec4 pathSamples[128];\nfloat pathSampleCurvRates[128];\n\nfloat calculateAcceleration(int index, float initialVelocitySq, float distance) {\n  if (index <= 4) {\n    // [aMaxHard, aMinHard, aMaxSoft, aMinSoft, 0]\n    return accelerationProfiles[index];\n  } else {\n    float finalVelocity = finalVelocityProfiles[index - 5];\n    if (distance < 0.001) return 0.0;\n    return clamp((finalVelocity * finalVelocity - initialVelocitySq) / (2.0 * distance), accelerationProfiles[1], accelerationProfiles[0]);\n  }\n}\n\nvec2 xy2sl(vec4 xytk) {\n  vec2 xy = xytk.xy + rearAxleToCenter * vec2(cos(xytk.z), sin(xytk.z));\n  vec2 xyTexCoords = (xy - xyCenterPoint) / vec2(textureSize(xyslMap, 0)) / vec2(xyGridCellSize) + 0.5;\n  return texture(xyslMap, xyTexCoords).xy;\n}\n\nfloat sampleStaticCost(vec4 xytk) {\n  vec2 sl = xy2sl(xytk);\n  vec2 slTexCoords = (sl - slCenterPoint) / vec2(textureSize(slObstacleGrid, 0)) / vec2(slGridCellSize) + 0.5;\n  float obstacleCost = texture(slObstacleGrid, slTexCoords).r;\n\n  if (obstacleCost >= 0.75) return -1.0; // Infinite cost\n\n  obstacleCost = step(0.25, obstacleCost) * obstacleHazardCost;\n\n  float absLatitude = abs(sl.y);\n  if (absLatitude >= laneShoulderLatitude) return -1.0;\n\n  float laneCost = abs(absLatitude - laneCenterLatitude) * laneCostSlope + step(0.0, -sl.y * sign(lanePreference)) * lanePreferenceDiscount;\n\n  return obstacleCost + laneCost;\n}\n\nfloat sampleDynamicCost(vec4 xytk, float time, float velocity, float acceleration) {\n  vec2 sl = xy2sl(xytk);\n  vec2 slTexCoords = (sl - slCenterPoint) / vec2(textureSize(slDynamicObstacleGrid, 0).xy) / vec2(slGridCellSize) + 0.5;\n  float dynamicFrame = floor(time / dynamicFrameTime);\n\n  float obstacleCost = texture(slDynamicObstacleGrid, vec3(slTexCoords, dynamicFrame)).r;\n\n  if (obstacleCost > 0.75) return -1.0; // Infinite cost\n\n  return step(0.25, obstacleCost) * obstacleHazardCost;\n}\n\nfloat calculateAverageStaticCost(int numSamples) {\n  float averageStaticCost = 0.0;\n\n  for (int i = 0; i < numSamples; i++) {\n    float cost = sampleStaticCost(pathSamples[i]);\n\n    if (cost < 0.0) return cost;\n\n    averageStaticCost += cost;\n  }\n\n  averageStaticCost /= float(numSamples);\n\n  return averageStaticCost;\n}\n\nfloat calculateAverageDynamicCost(int numSamples, float pathLength, float initialTime, float initialVelocity, float acceleration, float abandonThreshold) {\n  float s = 0.0;\n  float ds = pathLength / float(numSamples - 1);\n  float averageDynamicCost = 0.0;\n  float maxVelocity = 0.0;\n  float maxLateralAcceleration = 0.0;\n  float numSamples_f = float(numSamples);\n\n  for (int i = 0; i < numSamples; i++) {\n    vec4 pathSample = pathSamples[i]; // vec4(x-pos, y-pos, theta (rotation), kappa (curvature))\n\n    float velocitySq = 2.0 * acceleration * s + initialVelocity * initialVelocity;\n    float velocity = max(smallV, sqrt(max(0.0, velocitySq)));\n    maxVelocity = max(maxVelocity, velocity);\n    maxLateralAcceleration = max(maxLateralAcceleration, abs(pathSample.w * velocity * velocity));\n\n    float time = 2.0 * s / (initialVelocity + velocity) + initialTime;\n\n    float dCurv = pathSampleCurvRates[i] * velocity;\n    if (dCurv > dCurvatureMax) return -1.0;\n\n    float cost = sampleDynamicCost(pathSample, time, velocity, acceleration);\n    if (cost < 0.0) return cost;\n\n    averageDynamicCost += cost;\n    if (averageDynamicCost / numSamples_f >= abandonThreshold) return -1.0;\n\n    s += ds;\n  }\n\n  averageDynamicCost /= numSamples_f;\n\n  // Apply speeding penality if any velocity along the trajectory is over the speed limit\n  averageDynamicCost += step(speedLimit, maxVelocity) * speedLimitPenalty;\n\n  // Apply hard acceleration/deceleration penalties if the acceleration/deceleration exceeds the soft limits\n  averageDynamicCost += step(accelerationProfiles[2] + 0.0001, acceleration) * hardAccelerationPenalty;\n  averageDynamicCost += (1.0 - step(accelerationProfiles[3], acceleration)) * hardDecelerationPenalty;\n\n  // Penalize lateral acceleration\n  averageDynamicCost += step(softLateralAccelerationLimit, maxLateralAcceleration) * softLateralAccelerationPenalty;\n  averageDynamicCost += linearLateralAccelerationPenalty * maxLateralAcceleration;\n\n  return averageDynamicCost;\n}\n\nvec3 calculateAVT(int accelerationIndex, float initialVelocity, float initialTime, float pathLength) {\n  float initialVelocitySq = initialVelocity * initialVelocity;\n  float acceleration = calculateAcceleration(accelerationIndex, initialVelocitySq, pathLength);\n\n  float finalVelocitySq = 2.0 * acceleration * pathLength + initialVelocitySq;\n  float finalVelocity = max(smallV, sqrt(max(0.0, finalVelocitySq)));\n\n  float finalTime = initialTime;\n\n  if (acceleration == 0.0) {\n    finalTime += pathLength / finalVelocity;\n  } else if (finalVelocitySq <= 0.0) { // Calculate final time if the vehicle stops before the end of the trajectory\n    float distanceLeft = pathLength - (smallV * smallV - initialVelocitySq) / (2.0 * acceleration);\n    finalTime += (finalVelocity - initialVelocity) / acceleration + distanceLeft / smallV;\n  } else {\n    finalTime += 2.0 * pathLength / (finalVelocity + initialVelocity);\n  }\n\n  return vec3(acceleration, finalVelocity, finalTime);\n}\n\n`;\n\nconst SAMPLE_CUBIC_PATH_FN = `\n\nint sampleCubicPath(vec4 start, vec4 end, vec4 cubicPathParams) {\n  float p0 = start.w;\n  float p1 = cubicPathParams.x;\n  float p2 = cubicPathParams.y;\n  float p3 = end.w;\n  float sG = cubicPathParams.z;\n\n  if (sG <= 0.0) return 0;\n\n  int numSamples = int(ceil(sG / pathSamplingStep)) + 1;\n\n  float sG_2 = sG * sG;\n  float sG_3 = sG_2 * sG;\n\n  float a = p0;\n  float b = (-5.5 * p0 + 9.0 * p1 - 4.5 * p2 + p3) / sG;\n  float c = (9.0 * p0 - 22.5 * p1 + 18.0 * p2 - 4.5 * p3) / sG_2;\n  float d = (-4.5 * (p0 - 3.0 * p1 + 3.0 * p2 - p3)) / sG_3;\n\n  pathSamples[0] = start;\n\n  float ds = sG / float(numSamples - 1);\n  float s = ds;\n  vec2 dxy = vec2(0);\n  vec2 prevCosSin = vec2(cos(start.z), sin(start.z));\n\n  for (int i = 1; i < numSamples; i++) {\n    float rot = (((d * s / 4.0 + c / 3.0) * s + b / 2.0) * s + a) * s + start.z;\n    float curv = ((d * s + c) * s + b) * s + a;\n\n    vec2 cosSin = vec2(cos(rot), sin(rot));\n    dxy = dxy * vec2(float(i - 1) / float(i)) + (cosSin + prevCosSin) / vec2(2 * i);\n\n    pathSamples[i] = vec4(dxy * vec2(s) + start.xy, rot, curv);\n    pathSampleCurvRates[i] = b + s * (2.0 * c + 3.0 * d * s);\n\n    s += ds;\n    prevCosSin = cosSin;\n  }\n\n  return numSamples;\n}\n\n`;\n\nconst SAMPLE_QUINTIC_PATH_FN = `\n\nint sampleQuinticPath(vec4 start, vec4 end, vec4 quinticPathParams) {\n  float p0 = start.w;\n  float p1 = dCurvVehicle;\n  float p2 = ddCurvVehicle;\n  float p3 = quinticPathParams.x;\n  float p4 = quinticPathParams.y;\n  float p5 = end.w;\n  float sG = quinticPathParams.z;\n\n  if (sG <= 0.0) return 0;\n\n  int numSamples = int(ceil(sG / pathSamplingStep)) + 1;\n\n  float sG_2 = sG * sG;\n  float sG_3 = sG_2 * sG;\n\n  float a = p0;\n  float b = p1;\n  float c = p2 / 2.0;\n  float d = (-71.875 * p0 + 81.0 * p3 - 10.125 * p4 + p5 - 21.25 * p1 * sG - 2.75 * p2 * sG_2) / sG_3;\n  float e = (166.5 * p0 - 202.5 * p3 + 40.5 * p4 - 4.5 * p5 + 45.0 * p1 * sG + 4.5 * p2 * sG_2) / (sG_2 * sG_2);\n  float f = (-95.625 * p0 + 121.5 * p3 - 30.375 * p4 + 4.5 * p5 - 24.75 * p1 * sG - 2.25 * p2 * sG_2) / (sG_2 * sG_3);\n\n  pathSamples[0] = start;\n\n  float ds = sG / float(numSamples - 1);\n  float s = ds;\n  vec2 dxy = vec2(0);\n  vec2 prevCosSin = vec2(cos(start.z), sin(start.z));\n\n  for (int i = 1; i < numSamples; i++) {\n    float rot = (((((f * s / 6.0 + e / 5.0) * s + d / 4.0) * s + c / 3.0) * s + b / 2.0) * s + a) * s + start.z;\n    float curv = ((((f * s + e) * s + d) * s + c) * s + b) * s + a;\n\n    vec2 cosSin = vec2(cos(rot), sin(rot));\n    dxy = dxy * vec2(float(i - 1) / float(i)) + (cosSin + prevCosSin) / vec2(2 * i);\n\n    pathSamples[i] = vec4(dxy * vec2(s) + start.xy, rot, curv);\n    pathSampleCurvRates[i] = b + s * (2.0 * c + s * (3.0 * d + s * (4.0 * e + 5.0 * f * s)));\n\n    s += ds;\n    prevCosSin = cosSin;\n  }\n\n  return numSamples;\n}\n\n`;\n\nconst NUM_ACCELERATION_PROFILES = 8;\nconst NUM_VELOCITY_RANGES = 4;\nconst NUM_TIME_RANGES = 2;\n\nconst SHARED_UNIFORMS = {\n  xyslMap: { type: 'outputTexture' },\n  slObstacleGrid: { type: 'outputTexture', name: 'slObstacleGridDilated' },\n  slDynamicObstacleGrid: { type: 'outputTexture', name: 'slDynamicObstacleGrid', textureType: '2DArray' },\n  accelerationProfiles: { type: 'float', length: 5 },\n  finalVelocityProfiles: { type: 'float', length: 3 },\n  xyCenterPoint: { type: 'vec2' },\n  xyGridCellSize: { type: 'float' },\n  slCenterPoint: { type: 'vec2' },\n  slGridCellSize: { type: 'float'},\n  laneCenterLatitude: { type: 'float'},\n  laneShoulderLatitude: { type: 'float'},\n  laneCostSlope: { type: 'float'},\n  lanePreference: { type: 'float' },\n  lanePreferenceDiscount: { type: 'float' },\n  obstacleHazardCost: { type: 'float' },\n  speedLimit: { type: 'float' },\n  speedLimitPenalty: { type: 'float' },\n  hardAccelerationPenalty: { type: 'float' },\n  hardDecelerationPenalty: { type: 'float' },\n  softLateralAccelerationLimit: { type: 'float' },\n  softLateralAccelerationPenalty: { type: 'float' },\n  linearLateralAccelerationPenalty: { type: 'float' },\n  dCurvatureMax: { type: 'float' },\n  pathSamplingStep: { type: 'float' },\n  rearAxleToCenter: { type: 'float' },\n  dynamicFrameTime: { type: 'float' }\n};\n\nfunction buildUniformValues(config, xyCenterPoint, slCenterPoint, dynamicFrameTime) {\n  return {\n    accelerationProfiles: [3.5, -6.5, 2.0, -3.0, 0],\n    finalVelocityProfiles: [0.999 * config.speedLimit, 1.0, 0.01],\n    xyCenterPoint: [xyCenterPoint.x, xyCenterPoint.y],\n    xyGridCellSize: config.xyGridCellSize,\n    slCenterPoint: [slCenterPoint.x, slCenterPoint.y],\n    slGridCellSize: config.slGridCellSize,\n    laneCenterLatitude: config.laneCenterLatitude,\n    laneShoulderLatitude: config.laneShoulderLatitude,\n    laneCostSlope: config.laneCostSlope,\n    lanePreference: config.lanePreference,\n    lanePreferenceDiscount: config.lanePreferenceDiscount,\n    obstacleHazardCost: config.obstacleHazardCost,\n    speedLimit: config.speedLimit,\n    speedLimitPenalty: config.speedLimitPenalty,\n    hardAccelerationPenalty: config.hardAccelerationPenalty,\n    hardDecelerationPenalty: config.hardDecelerationPenalty,\n    softLateralAccelerationLimit: config.softLateralAccelerationLimit,\n    softLateralAccelerationPenalty: config.softLateralAccelerationPenalty,\n    linearLateralAccelerationPenalty: config.linearLateralAccelerationPenalty,\n    dCurvatureMax: config.dCurvatureMax,\n    pathSamplingStep: config.pathSamplingStep,\n    rearAxleToCenter: config.rearAxleToCenter,\n    dynamicFrameTime: dynamicFrameTime\n  };\n}\n\nexport {\n  SHARED_SHADER,\n  SAMPLE_CUBIC_PATH_FN,\n  SAMPLE_QUINTIC_PATH_FN,\n\n  NUM_ACCELERATION_PROFILES,\n  NUM_VELOCITY_RANGES,\n  NUM_TIME_RANGES,\n\n  SHARED_UNIFORMS,\n  buildUniformValues\n}\n","import { SHARED_SHADER, SAMPLE_CUBIC_PATH_FN, SAMPLE_QUINTIC_PATH_FN, NUM_ACCELERATION_PROFILES, SHARED_UNIFORMS, buildUniformValues } from \"./graphSearchShared.js\";\n\nfunction fromVehiclePathCostsKernel(pathType) {\n  return SHARED_SHADER + (pathType == 'cubic' ? SAMPLE_CUBIC_PATH_FN : SAMPLE_QUINTIC_PATH_FN) +\n\n`\n\n/* Calculate cost of a {cubic|quintic} path from vehicle to (stationConnectivity * numLatitudes * numAccelerations) nodes\n *   width: numLatitudes\n *   height: station * numAccelerations\n */\nvec4 kernel() {\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\n\n  int latitude = indexes.x;\n  int station = indexes.y / numAccelerations;\n  int accelerationIndex = int(mod(float(indexes.y), float(numAccelerations)));\n\n  vec4 pathStart = vec4(0, 0, 0, curvVehicle);\n  vec4 pathEnd = texelFetch(lattice, ivec2(latitude, station), 0);\n\n  vec4 pathParams = texelFetch(pathsFromVehicle, ivec2(latitude, station), 0);\n\n  // If the path didn't converge\n  if (pathParams.w == 0.0) return vec4(-1);\n\n  int numSamples = ${pathType == 'cubic' ? 'sampleCubicPath' : 'sampleQuinticPath'}(pathStart, pathEnd, pathParams);\n  float pathLength = pathParams.z;\n\n  if (numSamples < 2) return vec4(-1);\n\n  float averageStaticCost = calculateAverageStaticCost(numSamples);\n  if (averageStaticCost < 0.0) return vec4(-1);\n\n  int slIndex = station * kernelSize.x + latitude;\n  float hysteresisAdjustment = (slIndex == firstLatticePoint || slIndex == secondLatticePoint) ?  0.0 : hysteresisDiscount;\n  averageStaticCost += hysteresisAdjustment;\n\n  vec3 avt = calculateAVT(accelerationIndex, velocityVehicle, 0.0, pathLength);\n  float acceleration = avt.x;\n  float finalVelocity = avt.y;\n  float finalTime = avt.z;\n\n  float averageDynamicCost = calculateAverageDynamicCost(numSamples, pathLength, 0.0, velocityVehicle, acceleration, 1.0 / 0.0);\n  if (averageDynamicCost < 0.0) return vec4(-1);\n\n  averageDynamicCost += accelerationChangePenalty;\n\n  // The cost of a trajectory is the average sample cost scaled by the path length\n  float totalCost = (averageStaticCost + averageDynamicCost + ${pathType == 'cubic' ? '(cubicPathPenalty * velocityVehicle * velocityVehicle)' : '0.0'}) * pathLength;\n  ${pathType != 'cubic' ? 'totalCost = -1.0;' : ''}\n\n  return vec4(totalCost, finalVelocity, finalTime, ${pathType == 'cubic' ? '-2' : '-1'});\n}\n\n`;\n}\n\nexport default {\n  setUp() {\n    return [\n      {\n        kernel: fromVehiclePathCostsKernel('cubic'),\n        output: { name: 'cubicPathFromVehicleCosts' },\n        uniforms: Object.assign({}, SHARED_UNIFORMS, {\n          lattice: { type: 'sharedTexture' },\n          pathsFromVehicle: { type: 'outputTexture', name: 'cubicPathsFromVehicle' },\n          firstLatticePoint: { type: 'int' },\n          secondLatticePoint: { type: 'int' },\n          velocityVehicle: { type: 'float' },\n          curvVehicle: { type: 'float' },\n          numAccelerations: { type: 'int' },\n          cubicPathPenalty: { type: 'float' },\n          hysteresisDiscount: { type: 'float' },\n          accelerationChangePenalty: { type: 'float' }\n        })\n      },\n      {\n        kernel: fromVehiclePathCostsKernel('quintic'),\n        output: { name: 'quinticPathFromVehicleCosts' },\n        uniforms: Object.assign({}, SHARED_UNIFORMS, {\n          lattice: { type: 'sharedTexture' },\n          pathsFromVehicle: { type: 'outputTexture', name: 'quinticPathsFromVehicle' },\n          firstLatticePoint: { type: 'int' },\n          secondLatticePoint: { type: 'int' },\n          velocityVehicle: { type: 'float' },\n          curvVehicle: { type: 'float' },\n          dCurvVehicle: { type: 'float' },\n          ddCurvVehicle: { type: 'float' },\n          numAccelerations: { type: 'int' },\n          hysteresisDiscount: { type: 'float' },\n          accelerationChangePenalty: { type: 'float' }\n        })\n      }\n    ];\n  },\n\n  update(config, pose, xyCenterPoint, slCenterPoint, firstLatticePoint, secondLatticePoint, dynamicFrameTime) {\n    return [\n      {\n        width: config.lattice.numLatitudes,\n        height: config.lattice.stationConnectivity * NUM_ACCELERATION_PROFILES,\n        uniforms: Object.assign({}, buildUniformValues(config, xyCenterPoint, slCenterPoint, dynamicFrameTime), {\n          firstLatticePoint: firstLatticePoint,\n          secondLatticePoint: secondLatticePoint,\n          velocityVehicle: pose.velocity,\n          curvVehicle: pose.curv,\n          numAccelerations: NUM_ACCELERATION_PROFILES,\n          cubicPathPenalty: config.cubicPathPenalty,\n          hysteresisDiscount: config.hysteresisDiscount,\n          accelerationChangePenalty: config.accelerationChangePenalty\n        })\n      },\n      {\n        width: config.lattice.numLatitudes,\n        height: config.lattice.stationConnectivity * NUM_ACCELERATION_PROFILES,\n        uniforms: Object.assign({}, buildUniformValues(config, xyCenterPoint, slCenterPoint, dynamicFrameTime), {\n          firstLatticePoint: firstLatticePoint,\n          secondLatticePoint: secondLatticePoint,\n          velocityVehicle: pose.velocity,\n          curvVehicle: pose.curv,\n          dCurvVehicle: pose.dCurv,\n          ddCurvVehicle: pose.ddCurv,\n          numAccelerations: NUM_ACCELERATION_PROFILES,\n          hysteresisDiscount: config.hysteresisDiscount,\n          accelerationChangePenalty: config.accelerationChangePenalty\n        })\n      }\n    ];\n  }\n}\n","/* State Lattice Cost Map\n * \n * 5-dimensional node: station, latitude, acceleration profile, velocity, time\n *\n * A draw call per station s\n *   * Input to kernel: latitude l, acceleration profile a, velocity range v, time range t\n *   * Find all SL vertices that can connect to this node\n *   * For each of those vertices, check if any terminate in this specific velocity and time range\n *     * Based on initial velocity, initial time, and acceleration\n *     * Each connected SL vertex should have a * v * t nodes that could possibly terminate at this node\n *   * For all valid edges, find the one with the lowest cost\n *\n * Input:\n *   * 2D texture array cost map\n *     * Height: num of latitudes (~20)\n *     * Width: num of acceleration profiles * num of time ranges * num of velocity ranges (8 * 2 * 4 = ~64)\n *       * A flattened 3D array:\n *         d1: acceleration\n *         d2: velocity\n *         d3: time\n *     * Layer: num of stations (~10)\n *   \n * Output:\n *   * 2D texture slice of the next station in the input 2D texture array cost map\n *\n * Cost Map Elements:\n *   * Traversal cost so far\n *   * Ending velocity\n *   * Ending time\n *   * Index of parent node\n *\n * Since one cubic path can be shared between multiple trajectories, they need to be pre-optimized.\n *\n * Quintic Paths:\n *   Stations 0 through (numStations - 1) correspond to the stations on the lattice; however,\n *   a new station (station -1) will be used to signifiy the single vehicle pose node. Either\n *   a cubic path or quintic path can be used to connect this single node to the lattice\n *   (depending on vehicle velocity). At station -1, latitude 0 will correspond to a cubic path,\n *   and latitude 1 will correspond to a quintic path. All other latitudes will be skipped.\n */\n\nimport { SHARED_SHADER, SAMPLE_CUBIC_PATH_FN, SAMPLE_QUINTIC_PATH_FN, NUM_ACCELERATION_PROFILES, NUM_VELOCITY_RANGES, NUM_TIME_RANGES, SHARED_UNIFORMS, buildUniformValues } from \"./graphSearchShared.js\";\n\nconst SOLVE_STATION_KERNEL =\n  SHARED_SHADER +\n  SAMPLE_CUBIC_PATH_FN +\n  SAMPLE_QUINTIC_PATH_FN +\n\n`\n\nvec4 kernel() {\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\n\n  int latitude = indexes.y;\n\n  int numPerTime = numAccelerations * numVelocities;\n  int timeIndex = indexes.x / numPerTime;\n  indexes.x -= timeIndex * numPerTime;\n  int velocityIndex = indexes.x / numAccelerations;\n  int accelerationIndex = int(mod(float(indexes.x), float(numAccelerations)));\n\n  int minLatitude = max(latitude - latitudeConnectivity / 2, 0);\n  int maxLatitude = min(latitude + latitudeConnectivity / 2, numLatitudes - 1);\n\n  int slIndex = station * numLatitudes + latitude;\n\n  vec4 pathEnd = texelFetch(lattice, ivec2(latitude, station), 0);\n\n  float minVelocity = velocityRanges[velocityIndex];\n  float maxVelocity = velocityRanges[velocityIndex + 1];\n\n  float minTime = timeRanges[timeIndex];\n  float maxTime = timeRanges[timeIndex + 1];\n\n  vec4 bestTrajectory = vec4(-1); // -1 means infinite cost\n  float bestTerminalCost = 1.0 / 0.0;\n\n  float hysteresisAdjustment = (slIndex == firstLatticePoint || slIndex == secondLatticePoint) ?  0.0 : hysteresisDiscount;\n\n  for (int prevStation = max(station - stationConnectivity, 0); prevStation < station; prevStation++) {\n    int stationConnectivityIndex = prevStation - station + stationConnectivity;\n\n    for (int prevLatitude = minLatitude; prevLatitude <= maxLatitude; prevLatitude++) {\n      int latitudeConnectivityIndex = prevLatitude - latitude + latitudeConnectivity / 2;\n      int connectivityIndex = stationConnectivityIndex * latitudeConnectivity + latitudeConnectivityIndex;\n\n      vec4 pathStart = texelFetch(lattice, ivec2(prevLatitude, prevStation), 0);\n      vec4 cubicPathParams = texelFetch(cubicPaths, ivec2(slIndex, connectivityIndex), 0);\n\n      // If the path didn't converge\n      if (cubicPathParams.w == 0.0) continue;\n\n      int numSamples = sampleCubicPath(pathStart, pathEnd, cubicPathParams);\n      float pathLength = cubicPathParams.z;\n\n      if (numSamples < 2) continue;\n\n      float averageStaticCost = calculateAverageStaticCost(numSamples);\n      if (averageStaticCost < 0.0) continue;\n\n      averageStaticCost += hysteresisAdjustment;\n\n      if (averageStaticCost * pathLength >= bestTerminalCost) continue;\n\n      for (int prevVelocity = 0; prevVelocity < numVelocities; prevVelocity++) {\n        for (int prevTime = 0; prevTime < numTimes; prevTime++) {\n          for (int prevAccel = 0; prevAccel < numAccelerations; prevAccel++) {\n            int avtIndex = prevTime * numPerTime + prevVelocity * numAccelerations + prevAccel;\n\n            // Cost table entry:\n            //   x: cost so far\n            //   y: end velocity\n            //   z: end time\n            //   w: parent index\n            vec4 costTableEntry = texelFetch(costTable, ivec3(avtIndex, prevLatitude, prevStation), 0);\n\n            // If cost entry is infinity\n            if (costTableEntry.x < 0.0 || averageStaticCost * pathLength + costTableEntry.x >= bestTerminalCost) continue;\n\n            vec3 avt = calculateAVT(accelerationIndex, costTableEntry.y, costTableEntry.z, pathLength);\n            float acceleration = avt.x;\n            float finalVelocity = avt.y;\n            float finalTime = avt.z;\n\n            if (averageStaticCost * pathLength + costTableEntry.x + extraTimePenalty * finalTime >= bestTerminalCost) continue;\n\n            // If the calculated final velocity does not match this fragment's velocity range, then skip this trajectory\n            if (finalVelocity < minVelocity || finalVelocity >= maxVelocity) continue;\n\n            // If the calculated final time does not match this fragment's time range, then skip this trajectory\n            if (finalTime < minTime || finalTime >= maxTime) continue;\n\n            float abandonThreshold = (bestTerminalCost - extraTimePenalty * finalTime - costTableEntry.x) / pathLength - averageStaticCost;\n            float averageDynamicCost = calculateAverageDynamicCost(numSamples, pathLength, costTableEntry.z, costTableEntry.y, acceleration, abandonThreshold);\n            if (averageDynamicCost < 0.0) continue;\n\n            if (accelerationIndex != prevAccel)\n              averageDynamicCost += accelerationChangePenalty;\n\n            // The cost of a trajectory is the average sample cost scaled by the path length\n            float totalCost = (averageStaticCost + averageDynamicCost) * pathLength + costTableEntry.x;\n\n            float terminalCost = totalCost + extraTimePenalty * finalTime;\n            if (terminalCost >= bestTerminalCost) continue;\n            bestTerminalCost = terminalCost;\n\n            int incomingIndex = avtIndex + numPerTime * numTimes * (prevLatitude + numLatitudes * prevStation);\n            bestTrajectory = vec4(totalCost, finalVelocity, finalTime, incomingIndex);\n          }\n        }\n      }\n    }\n  }\n\n  if (station < stationConnectivity) {\n    ivec2 slaIndex = ivec2(latitude, station * numAccelerations + accelerationIndex);\n\n    vec4 costTableEntry = texelFetch(cubicPathFromVehicleCosts, slaIndex, 0);\n    float terminalCost;\n\n    if (costTableEntry.x >= 0.0) {\n      terminalCost = costTableEntry.x + extraTimePenalty * costTableEntry.z;\n\n      if (terminalCost < bestTerminalCost) {\n        bestTerminalCost = terminalCost;\n        bestTrajectory = costTableEntry;\n      }\n    }\n\n    costTableEntry = texelFetch(quinticPathFromVehicleCosts, slaIndex, 0);\n\n    if (costTableEntry.x >= 0.0) {\n      terminalCost = costTableEntry.x + extraTimePenalty * costTableEntry.z;\n\n      if (terminalCost < bestTerminalCost) {\n        bestTerminalCost = terminalCost;\n        bestTrajectory = costTableEntry;\n      }\n    }\n  }\n\n  return bestTrajectory;\n}\n\n`;\n\nexport default {\n  setUp() {\n    return {\n      kernel: SOLVE_STATION_KERNEL,\n      output: { name: 'graphSearch' },\n      uniforms: Object.assign({}, SHARED_UNIFORMS, {\n        lattice: { type: 'sharedTexture' },\n        costTable: { type: 'sharedTexture', textureType: '2DArray' },\n        cubicPaths: { type: 'outputTexture' },\n        cubicPathFromVehicleCosts: { type: 'outputTexture' },\n        quinticPathFromVehicleCosts: { type: 'outputTexture' },\n        firstLatticePoint: { type: 'int' },\n        secondLatticePoint: { type: 'int' },\n        velocityVehicle: { type: 'float' },\n        curvVehicle: { type: 'float' },\n        dCurvVehicle: { type: 'float' },\n        ddCurvVehicle: { type: 'float' },\n        extraTimePenalty: { type: 'float' },\n        hysteresisDiscount: { type: 'float' },\n        accelerationChangePenalty: { type: 'float' },\n        numStations: { type: 'int' },\n        numLatitudes: { type: 'int' },\n        numAccelerations: { type: 'int' },\n        numVelocities: { type: 'int' },\n        numTimes: { type: 'int' },\n        stationConnectivity: { type: 'int' },\n        latitudeConnectivity: { type: 'int' },\n        velocityRanges: { type: 'float', length: NUM_VELOCITY_RANGES + 1 },\n        timeRanges: { type: 'float', length: NUM_TIME_RANGES + 1 },\n        station: { type: 'int' } // Updated in `drawProxy`\n      }),\n      drawProxy: (gpgpu, program, draw) => {\n        const width = NUM_ACCELERATION_PROFILES * NUM_VELOCITY_RANGES * NUM_TIME_RANGES;\n        const height = program.meta.lattice.numLatitudes;\n        const costTable = new Float32Array(width * height * program.meta.lattice.numStations * 4);\n\n        for (let s = 0; s < program.meta.lattice.numStations; s++) {\n          gpgpu.updateProgramUniforms(program, { station: s });\n          draw();\n\n          gpgpu.gl.readPixels(0, 0, width, height, gpgpu.gl.RGBA, gpgpu.gl.FLOAT, costTable, s * width * height * 4);\n\n          gpgpu.gl.bindTexture(gpgpu.gl.TEXTURE_2D_ARRAY, gpgpu.sharedTextures.costTable);\n          gpgpu.gl.copyTexSubImage3D(gpgpu.gl.TEXTURE_2D_ARRAY, 0, 0, 0, s, 0, 0, width, height);\n        }\n\n        gpgpu._graphSearchCostTable = costTable;\n      }\n    };\n  },\n\n  update(config, pose, xyCenterPoint, slCenterPoint, firstLatticePoint, secondLatticePoint, dynamicFrameTime) {\n    return {\n      width: NUM_ACCELERATION_PROFILES * NUM_VELOCITY_RANGES * NUM_TIME_RANGES,\n      height: config.lattice.numLatitudes,\n      meta: {\n        lattice: config.lattice\n      },\n      uniforms: Object.assign({}, buildUniformValues(config, xyCenterPoint, slCenterPoint, dynamicFrameTime), {\n        firstLatticePoint: firstLatticePoint,\n        secondLatticePoint: secondLatticePoint,\n        velocityVehicle: pose.velocity,\n        curvVehicle: pose.curv,\n        dCurvVehicle: pose.dCurv,\n        ddCurvVehicle: pose.ddCurv,\n        extraTimePenalty: config.extraTimePenalty,\n        hysteresisDiscount: config.hysteresisDiscount,\n        accelerationChangePenalty: config.accelerationChangePenalty,\n        numStations: config.lattice.numStations,\n        numLatitudes: config.lattice.numLatitudes,\n        numAccelerations: NUM_ACCELERATION_PROFILES,\n        numVelocities: NUM_VELOCITY_RANGES,\n        numTimes: NUM_TIME_RANGES,\n        stationConnectivity: config.lattice.stationConnectivity,\n        latitudeConnectivity: config.lattice.latitudeConnectivity,\n        velocityRanges: [0, config.speedLimit / 3, config.speedLimit * 2 / 3, config.speedLimit, 1000000],\n        timeRanges: [0, 10, 1000000]\n      })\n    };\n  }\n}\n","import GPGPU from \"../../GPGPU.js\";\nimport Car from \"../../physics/Car.js\";\nimport CubicPath from \"./CubicPath.js\";\nimport QuinticPath from \"./QuinticPath.js\";\nimport xyObstacleGrid from \"./gpgpu-programs/xyObstacleGrid.js\";\nimport slObstacleGrid from \"./gpgpu-programs/slObstacleGrid.js\";\nimport slObstacleGridDilation from \"./gpgpu-programs/slObstacleGridDilation.js\";\nimport slDynamicObstacleGrid from \"./gpgpu-programs/slDynamicObstacleGrid.js\";\nimport xyslMap from \"./gpgpu-programs/xyslMap.js\";\nimport optimizeCubicPaths from \"./gpgpu-programs/optimizeCubicPaths.js\";\nimport optimizeQuinticPaths from \"./gpgpu-programs/optimizeQuinticPaths.js\";\nimport pathFromVehicleCosts from \"./gpgpu-programs/pathFromVehicleCosts.js\";\nimport graphSearch from \"./gpgpu-programs/graphSearch.js\";\nimport xyObstacleCostGrid from \"./gpgpu-programs/xyObstacleCostGrid.js\";\n\nconst NUM_ACCELERATION_PROFILES = 8;\nconst NUM_VELOCITY_RANGES = 4;\nconst NUM_TIME_RANGES = 2;\n\n/* Obstacle cost map:\n *\n * 1. Rasterize triangles from polygonal obstacles into XY-space occupancy grid\n * 2. Convert occupancy grid to SL-space\n *    * Width is spatial horizon of the state lattice\n *    * Height is lane width\n *    * Resolution should be higher than XY-grid\n *    * Get XY position from centerline texture\n *    * Lookup XY in XY occupancy grid (nearest)\n * 3. Dilate SL-space grid using two passes (along station, then along latitude)\n *    * collision area: half car size + 0.3m\n *    * high cost area: 1 meter\n * 4. Convert back to XY-space using XYSL map\n */\n\nexport default class PathPlanner {\n  constructor() {\n    this.previousStartStation = null;\n    this.previousFirstLatticePoint = -1;\n    this.previousSecondLatticePoint = -1;\n    this.previousFirstAcceleration = -1;\n    this.previousSecondLatticePoint = -1;\n\n    let start = performance.now();\n    const programs = [\n      xyObstacleGrid.setUp(),\n      slObstacleGrid.setUp(),\n      ...slObstacleGridDilation.setUp(),\n      slDynamicObstacleGrid.setUp(),\n      xyslMap.setUp(),\n      ...optimizeCubicPaths.setUp(),\n      optimizeQuinticPaths.setUp(),\n      ...pathFromVehicleCosts.setUp(),\n      graphSearch.setUp(),\n    ].map(p => Object.assign({}, p, { width: 1, height: 1 }));\n\n    this.gpgpu = new GPGPU(programs);\n  }\n\n  reset() {\n    this.previousStartStation = null;\n    this.previousFirstLatticePoint = -1;\n    this.previousSecondLatticePoint = -1;\n    this.previousFirstAcceleration = -1;\n    this.previousSecondLatticePoint = -1;\n  }\n\n  plan(vehiclePose, vehicleStation, lanePath, startTime, staticObstacles, dynamicObstacles) {\n    const latticeStationInterval = this._latticeStationInterval();\n\n    const centerlineRaw = lanePath.sampleStations(vehicleStation, Math.ceil((this.config.spatialHorizon + latticeStationInterval) / this.config.centerlineStationInterval) + 1, this.config.centerlineStationInterval);\n\n    // Transform all centerline points into vehicle frame\n    const vehicleXform = vehicleTransform(vehiclePose);\n    const centerline = centerlineRaw.map(c => { return { pos: c.pos.clone().applyMatrix3(vehicleXform), rot: c.rot - vehiclePose.rot, curv: c.curv } });\n\n    const centerlineData = new Float32Array(centerline.length * 3);\n    const maxPoint = new THREE.Vector2(0, 0);\n    const minPoint = new THREE.Vector2(0, 0);\n\n    for (let i = 0; i < centerline.length; i++) {\n      const sample = centerline[i];\n      const pos = sample.pos;\n      centerlineData[i * 3 + 0] = pos.x;\n      centerlineData[i * 3 + 1] = pos.y;\n      centerlineData[i * 3 + 2] = sample.rot;\n\n      maxPoint.max(pos);\n      minPoint.min(pos);\n    }\n\n    const diff = maxPoint.clone().sub(minPoint);\n    const xyCenterPoint = minPoint.clone().add(maxPoint).divideScalar(2);\n\n    // Sizes of the xy grids (in pixels, not meters)\n    const xyWidth = Math.ceil((diff.x + this.config.gridMargin * 2) / this.config.xyGridCellSize);\n    const xyHeight = Math.ceil((diff.y + this.config.gridMargin * 2) / this.config.xyGridCellSize);\n\n    const stationWidth = this.config.spatialHorizon + latticeStationInterval * 2;\n    const slCenterPoint = new THREE.Vector2(this.config.spatialHorizon / 2, 0);\n\n    // Sizes of the sl grids (in pixels, not meters)\n    const slWidth = Math.ceil(stationWidth / this.config.slGridCellSize);\n    const slHeight = Math.ceil((this.config.roadWidth + this.config.gridMargin * 2) / this.config.slGridCellSize);\n\n    let startStation;\n\n    if (this.previousStartStation === null || vehicleStation + latticeStationInterval / 2 > this.previousStartStation) {\n      startStation = (this.previousStartStation === null ? vehicleStation : this.previousStartStation) + latticeStationInterval;\n      this.previousStartStation = startStation;\n      this.previousFirstLatticePoint -= this.config.lattice.numLatitudes;\n      this.previousSecondLatticePoint -= this.config.lattice.numLatitudes;\n    } else {\n      startStation = this.previousStartStation;\n    }\n\n    const lattice = this._buildLattice(lanePath, startStation, vehiclePose.rot, vehicleXform);\n\n    const temporalHorizon = this.config.spatialHorizon / this.config.speedLimit;\n    const dynamicFrameTime = temporalHorizon / this.config.numDynamicFrames;\n\n    for (const [i, p] of [\n      xyObstacleGrid.update(this.config, xyWidth, xyHeight, xyCenterPoint, vehicleXform, staticObstacles),\n      slObstacleGrid.update(this.config, slWidth, slHeight, slCenterPoint, xyCenterPoint),\n      ...slObstacleGridDilation.update(this.config, slWidth, slHeight),\n      slDynamicObstacleGrid.update(this.config, slWidth, slHeight, slCenterPoint, vehicleStation, startTime, dynamicFrameTime, dynamicObstacles),\n      xyslMap.update(this.config, xyWidth, xyHeight, xyCenterPoint),\n      ...optimizeCubicPaths.update(this.config, vehiclePose),\n      optimizeQuinticPaths.update(this.config, vehiclePose),\n      ...pathFromVehicleCosts.update(this.config, vehiclePose, xyCenterPoint, slCenterPoint, this.previousFirstLatticePoint, this.previousSecondLatticePoint, dynamicFrameTime),\n      graphSearch.update(this.config, vehiclePose, xyCenterPoint, slCenterPoint, this.previousFirstLatticePoint, this.previousSecondLatticePoint, dynamicFrameTime)\n    ].entries()) {\n      this.gpgpu.updateProgram(i, p);\n    }\n\n    this.gpgpu.updateSharedTextures({\n      centerline: {\n        width: centerline.length,\n        height: 1,\n        channels: 3,\n        filter: 'linear',\n        data: centerlineData\n      },\n      costTable: {\n        width: NUM_ACCELERATION_PROFILES * NUM_VELOCITY_RANGES * NUM_TIME_RANGES,\n        height: this.config.lattice.numLatitudes,\n        depth: this.config.lattice.numStations,\n        channels: 4,\n        textureType: '2DArray'\n      },\n      lattice: {\n        width: this.config.lattice.numLatitudes,\n        height: this.config.lattice.numStations,\n        channels: 4,\n        data: lattice\n      }\n    });\n\n    this.gpgpu._graphSearchCostTable = null;\n    this.gpgpu._dynamicObstacleGrid = null;\n\n    let start = performance.now();\n    const outputs = this.gpgpu.run();\n    const costTable = this.gpgpu._graphSearchCostTable;\n    const cubicPathParams = outputs[6];\n    const cubicPathFromVehicleParams = outputs[7];\n    const quinticPathFromVehicleParams = outputs[8];\n\n    let bestEntry = [Number.POSITIVE_INFINITY];\n    let bestEntryIndex;\n    const numEntries = costTable.length / 4;\n\n    for (let i = 0; i < numEntries; i++) {\n      const entryUnpacked = this._unpackCostTableIndex(i);\n      const entry = [\n        costTable[i * 4],\n        costTable[i * 4 + 1],\n        costTable[i * 4 + 2],\n        costTable[i * 4 + 3]\n      ];\n\n      if (entry[0] < 0) continue;\n\n      entry[0] += this._terminalCost(entryUnpacked, entry);\n\n      if (entry[0] < bestEntry[0]) {\n        bestEntryIndex = i;\n        bestEntry = entry;\n      }\n    }\n\n    const inverseVehicleXform = (new THREE.Matrix3()).getInverse(vehicleXform);\n    let bestTrajectory = null;\n    let fromVehicleSegment = null;\n    let fromVehicleParams = null;\n    let firstLatticePoint = -1;\n    let firstAcceleration = -1;\n    let secondLatticePoint = -1;\n    let secondAcceleration = -1;\n\n    if (isFinite(bestEntry[0])) {\n      [bestTrajectory, fromVehicleSegment, fromVehicleParams, firstLatticePoint, firstAcceleration, secondLatticePoint, secondAcceleration] = this._reconstructTrajectory(\n        bestEntryIndex,\n        costTable,\n        cubicPathParams,\n        cubicPathFromVehicleParams,\n        quinticPathFromVehicleParams,\n        vehiclePose,\n        lattice\n      );\n\n      fromVehicleSegment.forEach(p => {\n        p.pos = p.pos.applyMatrix3(inverseVehicleXform);\n        p.rot += vehiclePose.rot;\n      });\n\n      bestTrajectory.forEach(p => {\n        p.pos = p.pos.applyMatrix3(inverseVehicleXform);\n        p.rot += vehiclePose.rot;\n      });\n    }\n\n    this.previousFirstLatticePoint = firstLatticePoint;\n    this.previousFirstAcceleration = firstAcceleration;\n    this.previousSecondLatticePoint = secondLatticePoint;\n    this.previousSecondAcceleration = secondAcceleration;\n\n    return {\n      path: bestTrajectory,\n      fromVehicleSegment: fromVehicleSegment,\n      fromVehicleParams: fromVehicleParams,\n      latticeStartStation: this.previousStartStation,\n      dynamicObstacleGrid: { data: this.gpgpu._dynamicObstacleGrid, width: slWidth, height: slHeight }\n    };\n  }\n\n  _buildLattice(lanePath, startStation, vehicleRot, vehicleXform) {\n    const centerline = lanePath.sampleStations(startStation, this.config.lattice.numStations, this._latticeStationInterval());\n    const offset = Math.floor(this.config.lattice.numLatitudes / 2);\n    const lattice = new Float32Array(this.config.lattice.numStations * this.config.lattice.numLatitudes * 4);\n    let index = 0;\n\n    for (let s = 0; s < centerline.length; s++) {\n      const sample = centerline[s];\n\n      for (let l = 0; l < this.config.lattice.numLatitudes; l++) {\n        const latitude = (l - offset) / offset * this.config.roadWidth / 2;\n        const rot = sample.rot - vehicleRot;\n        const pos = THREE.Vector2.fromAngle(rot + Math.PI / 2).multiplyScalar(latitude).add(sample.pos.clone().applyMatrix3(vehicleXform));\n        const curv = sample.curv == 0 ? 0 : 1 / (1 / sample.curv - latitude);\n\n        lattice[index++] = pos.x;\n        lattice[index++] = pos.y;\n        lattice[index++] = rot;\n        lattice[index++] = curv;\n      }\n    }\n\n    return lattice;\n  }\n\n  _latticeStationInterval() {\n    return this.config.spatialHorizon / this.config.lattice.numStations;\n  }\n\n  _terminalCost([stationIndex, latitudeIndex, timeIndex, velocityIndex, accelerationIndex], [cost, finalVelocity, finalTime, incomingIndex]) {\n    // Only consider vertices that reach the end of the spatial or temporal horizon\n    if (stationIndex != this.config.lattice.numStations - 1 && finalVelocity > 0.05)\n      return Number.POSITIVE_INFINITY;\n\n    const station = (this.config.spatialHorizon / this.config.lattice.numStations) * (stationIndex + 1);\n\n    return station * -this.config.stationReachDiscount + finalTime * this.config.extraTimePenalty;\n  }\n\n  _unpackCostTableIndex(index) {\n    if (index < 0) return [-1, index + 2, null, null, null];\n\n    const numPerTime = NUM_ACCELERATION_PROFILES * NUM_VELOCITY_RANGES;\n    const numPerLatitude = numPerTime * NUM_TIME_RANGES;\n    const numPerStation = this.config.lattice.numLatitudes * numPerLatitude;\n\n    const stationIndex = Math.floor(index / numPerStation);\n    index -= stationIndex * numPerStation;\n\n    const latitudeIndex = Math.floor(index / numPerLatitude);\n    index -= latitudeIndex * numPerLatitude;\n\n    const timeIndex = Math.floor(index / numPerTime);\n    index -= timeIndex * numPerTime;\n\n    const velocityIndex = Math.floor(index / NUM_ACCELERATION_PROFILES);\n    const accelerationIndex = index % NUM_ACCELERATION_PROFILES;\n\n    return [stationIndex, latitudeIndex, timeIndex, velocityIndex, accelerationIndex];\n  }\n\n  _reconstructTrajectory(index, costTable, cubicPathParams, cubicPathFromVehicleParams, quinticPathFromVehicleParams, vehiclePose, lattice) {\n    let unpacked = this._unpackCostTableIndex(index);\n    unpacked.push(costTable[index * 4 + 1]);\n    const nodes = [unpacked];\n\n    let count = 0;\n    while (unpacked[0] >= 0 && count++ < 100) {\n      index = costTable[index * 4 + 3];\n      unpacked = this._unpackCostTableIndex(index);\n\n      const finalVelocity = unpacked[0] >= 0 ? costTable[index * 4 + 1] : vehiclePose.velocity;\n      unpacked.push(finalVelocity);\n\n      nodes.unshift(unpacked);\n    }\n    if (count >= 100) throw new Error('Infinite loop encountered while reconstructing trajectory.');\n\n    const points = [];\n    let fromVehicleSegment = [];\n    let fromVehicleParams = null;\n\n    for (let i = 0; i < nodes.length - 1; i++) {\n      const [prevStation, prevLatitude, _pt, _pv, _pa, prevVelocity] = nodes[i];\n      const [station, latitude, _t, _v, _a, velocity] = nodes[i + 1];\n\n      let length;\n      let pathBuilder;\n\n      if (prevStation < 0) {\n        const start = {\n          pos: new THREE.Vector2(0, 0),\n          rot: 0,\n          curv: vehiclePose.curv\n        };\n\n        const endIndex = (station * this.config.lattice.numLatitudes + latitude) * 4;\n        const end = {\n          pos: new THREE.Vector2(lattice[endIndex], lattice[endIndex + 1]),\n          rot: lattice[endIndex + 2],\n          curv: lattice[endIndex + 3]\n        };\n\n        if (prevLatitude == 0) { // Cubic path from vehicle to lattice node\n          length = cubicPathFromVehicleParams[endIndex + 2];\n\n          const params = {\n            p1: cubicPathFromVehicleParams[endIndex],\n            p2: cubicPathFromVehicleParams[endIndex + 1],\n            sG: length\n          };\n\n          pathBuilder = new CubicPath(start, end, params);\n\n          fromVehicleParams = { type: 'cubic', params: params };\n        } else { // Quintic path from vehicle to lattice node\n          length = quinticPathFromVehicleParams[endIndex + 2];\n\n          const params = {\n            p3: quinticPathFromVehicleParams[endIndex],\n            p4: quinticPathFromVehicleParams[endIndex + 1],\n            sG: length\n          };\n\n          pathBuilder = new QuinticPath(start, end, params);\n\n          fromVehicleParams = { type: 'quintic', params: params };\n        }\n      } else {\n        const startIndex = (prevStation * this.config.lattice.numLatitudes + prevLatitude) * 4;\n        const endIndex = (station * this.config.lattice.numLatitudes + latitude) * 4;\n\n        const start = {\n          pos: new THREE.Vector2(lattice[startIndex], lattice[startIndex + 1]),\n          rot: lattice[startIndex + 2],\n          curv: lattice[startIndex + 3]\n        };\n\n        const end = {\n          pos: new THREE.Vector2(lattice[endIndex], lattice[endIndex + 1]),\n          rot: lattice[endIndex + 2],\n          curv: lattice[endIndex + 3]\n        };\n\n        const slIndex = station * this.config.lattice.numLatitudes + latitude;\n        const connectivityIndex = (prevStation - station + this.config.lattice.stationConnectivity) * this.config.lattice.latitudeConnectivity + prevLatitude - latitude + Math.floor(this.config.lattice.latitudeConnectivity / 2);\n        const cubicPathIndex = (connectivityIndex * this.config.lattice.numStations * this.config.lattice.numLatitudes + slIndex) * 4;\n\n        length = cubicPathParams[cubicPathIndex + 2];\n\n        pathBuilder = new CubicPath(start, end, {\n          p1: cubicPathParams[cubicPathIndex],\n          p2: cubicPathParams[cubicPathIndex + 1],\n          sG: length\n        });\n      }\n\n      const path = pathBuilder.buildPath(Math.ceil(length / 0.25));\n\n      const prevVelocitySq = prevVelocity * prevVelocity;\n      const accel = (velocity * velocity - prevVelocitySq) / 2 / length;\n      const ds = length / (path.length - 1);\n      let s = 0;\n\n      for (let p = 0; p < path.length; p++) {\n        path[p].velocity = Math.sqrt(2 * accel * s + prevVelocitySq);\n        path[p].acceleration = accel;\n        s += ds;\n      }\n\n      if (prevStation < 0) {\n        fromVehicleSegment = path;\n      } else {\n        if (i > 0) path.shift();\n        points.push(...path);\n      }\n    }\n\n    let firstLatticePoint = null\n    let firstAcceleration = null;\n    let secondLatticePoint = null;\n    let secondAcceleration = null;\n\n    if (nodes.length >= 2) {\n      firstLatticePoint = nodes[1][0] * this.config.lattice.numLatitudes + nodes[1][1];\n      firstAcceleration = nodes[1][4];\n    }\n\n    if (nodes.length >= 3) {\n      secondLatticePoint = nodes[2][0] * this.config.lattice.numLatitudes + nodes[2][1];\n      secondAcceleration = nodes[2][4];\n    }\n\n    return [points, fromVehicleSegment, fromVehicleParams, firstLatticePoint, firstAcceleration, secondLatticePoint, secondAcceleration];\n  }\n}\n\nfunction vehicleTransform({ pos, rot }) {\n  const translate = new THREE.Matrix3();\n  translate.set(\n    1, 0, -pos.x,\n    0, 1, -pos.y,\n    0, 0, 1\n  );\n\n  const cosRot = Math.cos(rot);\n  const sinRot = Math.sin(rot);\n\n  const rotate = new THREE.Matrix3();\n  rotate.set(\n    cosRot, sinRot, 0,\n    -sinRot, cosRot, 0,\n    0, 0, 1\n  );\n\n  return rotate.multiply(translate);\n}\n\nfunction obstacleTransform(vehicleXform, xyCenterPoint, width, height) {\n  const translate = new THREE.Matrix3();\n  translate.set(\n    1, 0, -xyCenterPoint.x,\n    0, 1, -xyCenterPoint.y,\n    0, 0, 1\n  );\n\n  const scale = new THREE.Matrix3();\n  scale.set(\n    2 / width, 0, 0,\n    0, 2 / height, 0,\n    0, 0, 1\n  );\n\n  return scale.multiply(translate).multiply(vehicleXform);\n}\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nmodule.exports = function(src) {\n\tfunction log(error) {\n\t\t(typeof console !== \"undefined\")\n\t\t&& (console.error || console.log)(\"[Script Loader]\", error);\n\t}\n\n\t// Check for IE =< 8\n\tfunction isIE() {\n\t\treturn typeof attachEvent !== \"undefined\" && typeof addEventListener === \"undefined\";\n\t}\n\n\ttry {\n\t\tif (typeof execScript !== \"undefined\" && isIE()) {\n\t\t\texecScript(src);\n\t\t} else if (typeof eval !== \"undefined\") {\n\t\t\teval.call(null, src);\n\t\t} else {\n\t\t\tlog(\"EvalError: No eval function available\");\n\t\t}\n\t} catch (error) {\n\t\tlog(error);\n\t}\n}\n","module.exports = \"Math.clamp = (number, min, max) => Math.max(min, Math.min(number, max));\\n\\nMath.wrapAngle = (angle) => {\\n  angle = angle % (Math.PI * 2);\\n  if (angle <= -Math.PI) return angle + Math.PI * 2;\\n  else if (angle > Math.PI) return angle - Math.PI * 2;\\n  else return angle;\\n}\\n\\nTHREE.Vector2.fromAngle = (angle) => new THREE.Vector2(Math.cos(angle), Math.sin(angle));\\n\\nTHREE.Curve.prototype.getCurvatureAt = function(u) {\\n  let t2 = this.getUtoTmapping(u);\\n\\n  const delta = 0.0001;\\n  let t1 = t2 - delta;\\n  let t3 = t2 + delta;\\n\\n  if (t1 < 0) {\\n    t1 = 0;\\n    t2 = delta;\\n    t3 = 2 * delta;\\n  }\\n\\n  if (t3 > 1) {\\n    t3 = 1;\\n    t2 = 1 - delta;\\n    t1 = 1 - 2 * delta;\\n  }\\n\\n  const p1 = this.getPoint(t1);\\n  const p2 = this.getPoint(t2);\\n  const p3 = this.getPoint(t3);\\n\\n  return (Math.atan2(p3.y - p2.y, p3.x - p2.x) - Math.atan2(p2.y - p1.y, p2.x - p1.x)) / p2.distanceTo(p1);\\n};\\n\"","require(\"!!/Users/matt/code/self_driving_car/dash/node_modules/script-loader/addScript.js\")(require(\"!!/Users/matt/code/self_driving_car/dash/node_modules/raw-loader/index.js!/Users/matt/code/self_driving_car/dash/js/Utils.js\"))","module.exports = \"(function (global, factory) {\\n\\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\\n\\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\\n\\t(factory((global.THREE = {})));\\n}(this, (function (exports) { 'use strict';\\n\\n\\t// Polyfills\\n\\n\\tif ( Number.EPSILON === undefined ) {\\n\\n\\t\\tNumber.EPSILON = Math.pow( 2, - 52 );\\n\\n\\t}\\n\\n\\tif ( Number.isInteger === undefined ) {\\n\\n\\t\\t// Missing in IE\\n\\t\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\\n\\n\\t\\tNumber.isInteger = function ( value ) {\\n\\n\\t\\t\\treturn typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t//\\n\\n\\tif ( Math.sign === undefined ) {\\n\\n\\t\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\\n\\n\\t\\tMath.sign = function ( x ) {\\n\\n\\t\\t\\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\tif ( 'name' in Function.prototype === false ) {\\n\\n\\t\\t// Missing in IE\\n\\t\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\\n\\n\\t\\tObject.defineProperty( Function.prototype, 'name', {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this.toString().match( /^\\\\s*function\\\\s*([^\\\\(\\\\s]*)/ )[ 1 ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t} );\\n\\n\\t}\\n\\n\\tif ( Object.assign === undefined ) {\\n\\n\\t\\t// Missing in IE\\n\\t\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\\n\\n\\t\\t( function () {\\n\\n\\t\\t\\tObject.assign = function ( target ) {\\n\\n\\t\\t\\t\\tif ( target === undefined || target === null ) {\\n\\n\\t\\t\\t\\t\\tthrow new TypeError( 'Cannot convert undefined or null to object' );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar output = Object( target );\\n\\n\\t\\t\\t\\tfor ( var index = 1; index < arguments.length; index ++ ) {\\n\\n\\t\\t\\t\\t\\tvar source = arguments[ index ];\\n\\n\\t\\t\\t\\t\\tif ( source !== undefined && source !== null ) {\\n\\n\\t\\t\\t\\t\\t\\tfor ( var nextKey in source ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\toutput[ nextKey ] = source[ nextKey ];\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn output;\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )();\\n\\n\\t}\\n\\n\\t/**\\n\\t * https://github.com/mrdoob/eventdispatcher.js/\\n\\t */\\n\\n\\tfunction EventDispatcher() {}\\n\\n\\tObject.assign( EventDispatcher.prototype, {\\n\\n\\t\\taddEventListener: function ( type, listener ) {\\n\\n\\t\\t\\tif ( this._listeners === undefined ) this._listeners = {};\\n\\n\\t\\t\\tvar listeners = this._listeners;\\n\\n\\t\\t\\tif ( listeners[ type ] === undefined ) {\\n\\n\\t\\t\\t\\tlisteners[ type ] = [];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\\n\\n\\t\\t\\t\\tlisteners[ type ].push( listener );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\thasEventListener: function ( type, listener ) {\\n\\n\\t\\t\\tif ( this._listeners === undefined ) return false;\\n\\n\\t\\t\\tvar listeners = this._listeners;\\n\\n\\t\\t\\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\\n\\n\\t\\t},\\n\\n\\t\\tremoveEventListener: function ( type, listener ) {\\n\\n\\t\\t\\tif ( this._listeners === undefined ) return;\\n\\n\\t\\t\\tvar listeners = this._listeners;\\n\\t\\t\\tvar listenerArray = listeners[ type ];\\n\\n\\t\\t\\tif ( listenerArray !== undefined ) {\\n\\n\\t\\t\\t\\tvar index = listenerArray.indexOf( listener );\\n\\n\\t\\t\\t\\tif ( index !== - 1 ) {\\n\\n\\t\\t\\t\\t\\tlistenerArray.splice( index, 1 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tdispatchEvent: function ( event ) {\\n\\n\\t\\t\\tif ( this._listeners === undefined ) return;\\n\\n\\t\\t\\tvar listeners = this._listeners;\\n\\t\\t\\tvar listenerArray = listeners[ event.type ];\\n\\n\\t\\t\\tif ( listenerArray !== undefined ) {\\n\\n\\t\\t\\t\\tevent.target = this;\\n\\n\\t\\t\\t\\tvar array = listenerArray.slice( 0 );\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tarray[ i ].call( this, event );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tvar REVISION = '89';\\n\\tvar MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\\n\\tvar CullFaceNone = 0;\\n\\tvar CullFaceBack = 1;\\n\\tvar CullFaceFront = 2;\\n\\tvar CullFaceFrontBack = 3;\\n\\tvar FrontFaceDirectionCW = 0;\\n\\tvar FrontFaceDirectionCCW = 1;\\n\\tvar BasicShadowMap = 0;\\n\\tvar PCFShadowMap = 1;\\n\\tvar PCFSoftShadowMap = 2;\\n\\tvar FrontSide = 0;\\n\\tvar BackSide = 1;\\n\\tvar DoubleSide = 2;\\n\\tvar FlatShading = 1;\\n\\tvar SmoothShading = 2;\\n\\tvar NoColors = 0;\\n\\tvar FaceColors = 1;\\n\\tvar VertexColors = 2;\\n\\tvar NoBlending = 0;\\n\\tvar NormalBlending = 1;\\n\\tvar AdditiveBlending = 2;\\n\\tvar SubtractiveBlending = 3;\\n\\tvar MultiplyBlending = 4;\\n\\tvar CustomBlending = 5;\\n\\tvar AddEquation = 100;\\n\\tvar SubtractEquation = 101;\\n\\tvar ReverseSubtractEquation = 102;\\n\\tvar MinEquation = 103;\\n\\tvar MaxEquation = 104;\\n\\tvar ZeroFactor = 200;\\n\\tvar OneFactor = 201;\\n\\tvar SrcColorFactor = 202;\\n\\tvar OneMinusSrcColorFactor = 203;\\n\\tvar SrcAlphaFactor = 204;\\n\\tvar OneMinusSrcAlphaFactor = 205;\\n\\tvar DstAlphaFactor = 206;\\n\\tvar OneMinusDstAlphaFactor = 207;\\n\\tvar DstColorFactor = 208;\\n\\tvar OneMinusDstColorFactor = 209;\\n\\tvar SrcAlphaSaturateFactor = 210;\\n\\tvar NeverDepth = 0;\\n\\tvar AlwaysDepth = 1;\\n\\tvar LessDepth = 2;\\n\\tvar LessEqualDepth = 3;\\n\\tvar EqualDepth = 4;\\n\\tvar GreaterEqualDepth = 5;\\n\\tvar GreaterDepth = 6;\\n\\tvar NotEqualDepth = 7;\\n\\tvar MultiplyOperation = 0;\\n\\tvar MixOperation = 1;\\n\\tvar AddOperation = 2;\\n\\tvar NoToneMapping = 0;\\n\\tvar LinearToneMapping = 1;\\n\\tvar ReinhardToneMapping = 2;\\n\\tvar Uncharted2ToneMapping = 3;\\n\\tvar CineonToneMapping = 4;\\n\\tvar UVMapping = 300;\\n\\tvar CubeReflectionMapping = 301;\\n\\tvar CubeRefractionMapping = 302;\\n\\tvar EquirectangularReflectionMapping = 303;\\n\\tvar EquirectangularRefractionMapping = 304;\\n\\tvar SphericalReflectionMapping = 305;\\n\\tvar CubeUVReflectionMapping = 306;\\n\\tvar CubeUVRefractionMapping = 307;\\n\\tvar RepeatWrapping = 1000;\\n\\tvar ClampToEdgeWrapping = 1001;\\n\\tvar MirroredRepeatWrapping = 1002;\\n\\tvar NearestFilter = 1003;\\n\\tvar NearestMipMapNearestFilter = 1004;\\n\\tvar NearestMipMapLinearFilter = 1005;\\n\\tvar LinearFilter = 1006;\\n\\tvar LinearMipMapNearestFilter = 1007;\\n\\tvar LinearMipMapLinearFilter = 1008;\\n\\tvar UnsignedByteType = 1009;\\n\\tvar ByteType = 1010;\\n\\tvar ShortType = 1011;\\n\\tvar UnsignedShortType = 1012;\\n\\tvar IntType = 1013;\\n\\tvar UnsignedIntType = 1014;\\n\\tvar FloatType = 1015;\\n\\tvar HalfFloatType = 1016;\\n\\tvar UnsignedShort4444Type = 1017;\\n\\tvar UnsignedShort5551Type = 1018;\\n\\tvar UnsignedShort565Type = 1019;\\n\\tvar UnsignedInt248Type = 1020;\\n\\tvar AlphaFormat = 1021;\\n\\tvar RGBFormat = 1022;\\n\\tvar RGBAFormat = 1023;\\n\\tvar LuminanceFormat = 1024;\\n\\tvar LuminanceAlphaFormat = 1025;\\n\\tvar RGBEFormat = RGBAFormat;\\n\\tvar DepthFormat = 1026;\\n\\tvar DepthStencilFormat = 1027;\\n\\tvar RGB_S3TC_DXT1_Format = 2001;\\n\\tvar RGBA_S3TC_DXT1_Format = 2002;\\n\\tvar RGBA_S3TC_DXT3_Format = 2003;\\n\\tvar RGBA_S3TC_DXT5_Format = 2004;\\n\\tvar RGB_PVRTC_4BPPV1_Format = 2100;\\n\\tvar RGB_PVRTC_2BPPV1_Format = 2101;\\n\\tvar RGBA_PVRTC_4BPPV1_Format = 2102;\\n\\tvar RGBA_PVRTC_2BPPV1_Format = 2103;\\n\\tvar RGB_ETC1_Format = 2151;\\n\\tvar LoopOnce = 2200;\\n\\tvar LoopRepeat = 2201;\\n\\tvar LoopPingPong = 2202;\\n\\tvar InterpolateDiscrete = 2300;\\n\\tvar InterpolateLinear = 2301;\\n\\tvar InterpolateSmooth = 2302;\\n\\tvar ZeroCurvatureEnding = 2400;\\n\\tvar ZeroSlopeEnding = 2401;\\n\\tvar WrapAroundEnding = 2402;\\n\\tvar TrianglesDrawMode = 0;\\n\\tvar TriangleStripDrawMode = 1;\\n\\tvar TriangleFanDrawMode = 2;\\n\\tvar LinearEncoding = 3000;\\n\\tvar sRGBEncoding = 3001;\\n\\tvar GammaEncoding = 3007;\\n\\tvar RGBEEncoding = 3002;\\n\\tvar LogLuvEncoding = 3003;\\n\\tvar RGBM7Encoding = 3004;\\n\\tvar RGBM16Encoding = 3005;\\n\\tvar RGBDEncoding = 3006;\\n\\tvar BasicDepthPacking = 3200;\\n\\tvar RGBADepthPacking = 3201;\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tvar _Math = {\\n\\n\\t\\tDEG2RAD: Math.PI / 180,\\n\\t\\tRAD2DEG: 180 / Math.PI,\\n\\n\\t\\tgenerateUUID: ( function () {\\n\\n\\t\\t\\t// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\\n\\n\\t\\t\\tvar lut = [];\\n\\n\\t\\t\\tfor ( var i = 0; i < 256; i ++ ) {\\n\\n\\t\\t\\t\\tlut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 ).toUpperCase();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn function () {\\n\\n\\t\\t\\t\\tvar d0 = Math.random() * 0xffffffff | 0;\\n\\t\\t\\t\\tvar d1 = Math.random() * 0xffffffff | 0;\\n\\t\\t\\t\\tvar d2 = Math.random() * 0xffffffff | 0;\\n\\t\\t\\t\\tvar d3 = Math.random() * 0xffffffff | 0;\\n\\t\\t\\t\\treturn lut[ d0 & 0xff ] + lut[ d0 >> 8 & 0xff ] + lut[ d0 >> 16 & 0xff ] + lut[ d0 >> 24 & 0xff ] + '-' +\\n\\t\\t\\t\\t\\tlut[ d1 & 0xff ] + lut[ d1 >> 8 & 0xff ] + '-' + lut[ d1 >> 16 & 0x0f | 0x40 ] + lut[ d1 >> 24 & 0xff ] + '-' +\\n\\t\\t\\t\\t\\tlut[ d2 & 0x3f | 0x80 ] + lut[ d2 >> 8 & 0xff ] + '-' + lut[ d2 >> 16 & 0xff ] + lut[ d2 >> 24 & 0xff ] +\\n\\t\\t\\t\\t\\tlut[ d3 & 0xff ] + lut[ d3 >> 8 & 0xff ] + lut[ d3 >> 16 & 0xff ] + lut[ d3 >> 24 & 0xff ];\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )(),\\n\\n\\t\\tclamp: function ( value, min, max ) {\\n\\n\\t\\t\\treturn Math.max( min, Math.min( max, value ) );\\n\\n\\t\\t},\\n\\n\\t\\t// compute euclidian modulo of m % n\\n\\t\\t// https://en.wikipedia.org/wiki/Modulo_operation\\n\\n\\t\\teuclideanModulo: function ( n, m ) {\\n\\n\\t\\t\\treturn ( ( n % m ) + m ) % m;\\n\\n\\t\\t},\\n\\n\\t\\t// Linear mapping from range <a1, a2> to range <b1, b2>\\n\\n\\t\\tmapLinear: function ( x, a1, a2, b1, b2 ) {\\n\\n\\t\\t\\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\\n\\n\\t\\t},\\n\\n\\t\\t// https://en.wikipedia.org/wiki/Linear_interpolation\\n\\n\\t\\tlerp: function ( x, y, t ) {\\n\\n\\t\\t\\treturn ( 1 - t ) * x + t * y;\\n\\n\\t\\t},\\n\\n\\t\\t// http://en.wikipedia.org/wiki/Smoothstep\\n\\n\\t\\tsmoothstep: function ( x, min, max ) {\\n\\n\\t\\t\\tif ( x <= min ) return 0;\\n\\t\\t\\tif ( x >= max ) return 1;\\n\\n\\t\\t\\tx = ( x - min ) / ( max - min );\\n\\n\\t\\t\\treturn x * x * ( 3 - 2 * x );\\n\\n\\t\\t},\\n\\n\\t\\tsmootherstep: function ( x, min, max ) {\\n\\n\\t\\t\\tif ( x <= min ) return 0;\\n\\t\\t\\tif ( x >= max ) return 1;\\n\\n\\t\\t\\tx = ( x - min ) / ( max - min );\\n\\n\\t\\t\\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\\n\\n\\t\\t},\\n\\n\\t\\t// Random integer from <low, high> interval\\n\\n\\t\\trandInt: function ( low, high ) {\\n\\n\\t\\t\\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\\n\\n\\t\\t},\\n\\n\\t\\t// Random float from <low, high> interval\\n\\n\\t\\trandFloat: function ( low, high ) {\\n\\n\\t\\t\\treturn low + Math.random() * ( high - low );\\n\\n\\t\\t},\\n\\n\\t\\t// Random float from <-range/2, range/2> interval\\n\\n\\t\\trandFloatSpread: function ( range ) {\\n\\n\\t\\t\\treturn range * ( 0.5 - Math.random() );\\n\\n\\t\\t},\\n\\n\\t\\tdegToRad: function ( degrees ) {\\n\\n\\t\\t\\treturn degrees * _Math.DEG2RAD;\\n\\n\\t\\t},\\n\\n\\t\\tradToDeg: function ( radians ) {\\n\\n\\t\\t\\treturn radians * _Math.RAD2DEG;\\n\\n\\t\\t},\\n\\n\\t\\tisPowerOfTwo: function ( value ) {\\n\\n\\t\\t\\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\\n\\n\\t\\t},\\n\\n\\t\\tceilPowerOfTwo: function ( value ) {\\n\\n\\t\\t\\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\\n\\n\\t\\t},\\n\\n\\t\\tfloorPowerOfTwo: function ( value ) {\\n\\n\\t\\t\\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author philogb / http://blog.thejit.org/\\n\\t * @author egraether / http://egraether.com/\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t */\\n\\n\\tfunction Vector2( x, y ) {\\n\\n\\t\\tthis.x = x || 0;\\n\\t\\tthis.y = y || 0;\\n\\n\\t}\\n\\n\\tObject.defineProperties( Vector2.prototype, {\\n\\n\\t\\t\\\"width\\\": {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this.x;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis.x = value;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t\\\"height\\\": {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this.y;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis.y = value;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( Vector2.prototype, {\\n\\n\\t\\tisVector2: true,\\n\\n\\t\\tset: function ( x, y ) {\\n\\n\\t\\t\\tthis.x = x;\\n\\t\\t\\tthis.y = y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetScalar: function ( scalar ) {\\n\\n\\t\\t\\tthis.x = scalar;\\n\\t\\t\\tthis.y = scalar;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetX: function ( x ) {\\n\\n\\t\\t\\tthis.x = x;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetY: function ( y ) {\\n\\n\\t\\t\\tthis.y = y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetComponent: function ( index, value ) {\\n\\n\\t\\t\\tswitch ( index ) {\\n\\n\\t\\t\\t\\tcase 0: this.x = value; break;\\n\\t\\t\\t\\tcase 1: this.y = value; break;\\n\\t\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetComponent: function ( index ) {\\n\\n\\t\\t\\tswitch ( index ) {\\n\\n\\t\\t\\t\\tcase 0: return this.x;\\n\\t\\t\\t\\tcase 1: return this.y;\\n\\t\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.x, this.y );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( v ) {\\n\\n\\t\\t\\tthis.x = v.x;\\n\\t\\t\\tthis.y = v.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tadd: function ( v, w ) {\\n\\n\\t\\t\\tif ( w !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.addVectors( v, w );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x += v.x;\\n\\t\\t\\tthis.y += v.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddScalar: function ( s ) {\\n\\n\\t\\t\\tthis.x += s;\\n\\t\\t\\tthis.y += s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddVectors: function ( a, b ) {\\n\\n\\t\\t\\tthis.x = a.x + b.x;\\n\\t\\t\\tthis.y = a.y + b.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddScaledVector: function ( v, s ) {\\n\\n\\t\\t\\tthis.x += v.x * s;\\n\\t\\t\\tthis.y += v.y * s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsub: function ( v, w ) {\\n\\n\\t\\t\\tif ( w !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.subVectors( v, w );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x -= v.x;\\n\\t\\t\\tthis.y -= v.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsubScalar: function ( s ) {\\n\\n\\t\\t\\tthis.x -= s;\\n\\t\\t\\tthis.y -= s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsubVectors: function ( a, b ) {\\n\\n\\t\\t\\tthis.x = a.x - b.x;\\n\\t\\t\\tthis.y = a.y - b.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiply: function ( v ) {\\n\\n\\t\\t\\tthis.x *= v.x;\\n\\t\\t\\tthis.y *= v.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyScalar: function ( scalar ) {\\n\\n\\t\\t\\tthis.x *= scalar;\\n\\t\\t\\tthis.y *= scalar;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdivide: function ( v ) {\\n\\n\\t\\t\\tthis.x /= v.x;\\n\\t\\t\\tthis.y /= v.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdivideScalar: function ( scalar ) {\\n\\n\\t\\t\\treturn this.multiplyScalar( 1 / scalar );\\n\\n\\t\\t},\\n\\n\\t\\tapplyMatrix3: function ( m ) {\\n\\n\\t\\t\\tvar x = this.x, y = this.y;\\n\\t\\t\\tvar e = m.elements;\\n\\n\\t\\t\\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];\\n\\t\\t\\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmin: function ( v ) {\\n\\n\\t\\t\\tthis.x = Math.min( this.x, v.x );\\n\\t\\t\\tthis.y = Math.min( this.y, v.y );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmax: function ( v ) {\\n\\n\\t\\t\\tthis.x = Math.max( this.x, v.x );\\n\\t\\t\\tthis.y = Math.max( this.y, v.y );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclamp: function ( min, max ) {\\n\\n\\t\\t\\t// assumes min < max, componentwise\\n\\n\\t\\t\\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\\n\\t\\t\\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclampScalar: function () {\\n\\n\\t\\t\\tvar min = new Vector2();\\n\\t\\t\\tvar max = new Vector2();\\n\\n\\t\\t\\treturn function clampScalar( minVal, maxVal ) {\\n\\n\\t\\t\\t\\tmin.set( minVal, minVal );\\n\\t\\t\\t\\tmax.set( maxVal, maxVal );\\n\\n\\t\\t\\t\\treturn this.clamp( min, max );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tclampLength: function ( min, max ) {\\n\\n\\t\\t\\tvar length = this.length();\\n\\n\\t\\t\\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\\n\\n\\t\\t},\\n\\n\\t\\tfloor: function () {\\n\\n\\t\\t\\tthis.x = Math.floor( this.x );\\n\\t\\t\\tthis.y = Math.floor( this.y );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tceil: function () {\\n\\n\\t\\t\\tthis.x = Math.ceil( this.x );\\n\\t\\t\\tthis.y = Math.ceil( this.y );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tround: function () {\\n\\n\\t\\t\\tthis.x = Math.round( this.x );\\n\\t\\t\\tthis.y = Math.round( this.y );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\troundToZero: function () {\\n\\n\\t\\t\\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\\n\\t\\t\\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tnegate: function () {\\n\\n\\t\\t\\tthis.x = - this.x;\\n\\t\\t\\tthis.y = - this.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdot: function ( v ) {\\n\\n\\t\\t\\treturn this.x * v.x + this.y * v.y;\\n\\n\\t\\t},\\n\\n\\t\\tlengthSq: function () {\\n\\n\\t\\t\\treturn this.x * this.x + this.y * this.y;\\n\\n\\t\\t},\\n\\n\\t\\tlength: function () {\\n\\n\\t\\t\\treturn Math.sqrt( this.x * this.x + this.y * this.y );\\n\\n\\t\\t},\\n\\n\\t\\tmanhattanLength: function () {\\n\\n\\t\\t\\treturn Math.abs( this.x ) + Math.abs( this.y );\\n\\n\\t\\t},\\n\\n\\t\\tnormalize: function () {\\n\\n\\t\\t\\treturn this.divideScalar( this.length() || 1 );\\n\\n\\t\\t},\\n\\n\\t\\tangle: function () {\\n\\n\\t\\t\\t// computes the angle in radians with respect to the positive x-axis\\n\\n\\t\\t\\tvar angle = Math.atan2( this.y, this.x );\\n\\n\\t\\t\\tif ( angle < 0 ) angle += 2 * Math.PI;\\n\\n\\t\\t\\treturn angle;\\n\\n\\t\\t},\\n\\n\\t\\tdistanceTo: function ( v ) {\\n\\n\\t\\t\\treturn Math.sqrt( this.distanceToSquared( v ) );\\n\\n\\t\\t},\\n\\n\\t\\tdistanceToSquared: function ( v ) {\\n\\n\\t\\t\\tvar dx = this.x - v.x, dy = this.y - v.y;\\n\\t\\t\\treturn dx * dx + dy * dy;\\n\\n\\t\\t},\\n\\n\\t\\tmanhattanDistanceTo: function ( v ) {\\n\\n\\t\\t\\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\\n\\n\\t\\t},\\n\\n\\t\\tsetLength: function ( length ) {\\n\\n\\t\\t\\treturn this.normalize().multiplyScalar( length );\\n\\n\\t\\t},\\n\\n\\t\\tlerp: function ( v, alpha ) {\\n\\n\\t\\t\\tthis.x += ( v.x - this.x ) * alpha;\\n\\t\\t\\tthis.y += ( v.y - this.y ) * alpha;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tlerpVectors: function ( v1, v2, alpha ) {\\n\\n\\t\\t\\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( v ) {\\n\\n\\t\\t\\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\\n\\n\\t\\t},\\n\\n\\t\\tfromArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tthis.x = array[ offset ];\\n\\t\\t\\tthis.y = array[ offset + 1 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( array === undefined ) array = [];\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tarray[ offset ] = this.x;\\n\\t\\t\\tarray[ offset + 1 ] = this.y;\\n\\n\\t\\t\\treturn array;\\n\\n\\t\\t},\\n\\n\\t\\tfromBufferAttribute: function ( attribute, index, offset ) {\\n\\n\\t\\t\\tif ( offset !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x = attribute.getX( index );\\n\\t\\t\\tthis.y = attribute.getY( index );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\trotateAround: function ( center, angle ) {\\n\\n\\t\\t\\tvar c = Math.cos( angle ), s = Math.sin( angle );\\n\\n\\t\\t\\tvar x = this.x - center.x;\\n\\t\\t\\tvar y = this.y - center.y;\\n\\n\\t\\t\\tthis.x = x * c - y * s + center.x;\\n\\t\\t\\tthis.y = x * s + y * c + center.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author supereggbert / http://www.paulbrunt.co.uk/\\n\\t * @author philogb / http://blog.thejit.org/\\n\\t * @author jordi_ros / http://plattsoft.com\\n\\t * @author D1plo1d / http://github.com/D1plo1d\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author timknip / http://www.floorplanner.com/\\n\\t * @author bhouston / http://clara.io\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction Matrix4() {\\n\\n\\t\\tthis.elements = [\\n\\n\\t\\t\\t1, 0, 0, 0,\\n\\t\\t\\t0, 1, 0, 0,\\n\\t\\t\\t0, 0, 1, 0,\\n\\t\\t\\t0, 0, 0, 1\\n\\n\\t\\t];\\n\\n\\t\\tif ( arguments.length > 0 ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tObject.assign( Matrix4.prototype, {\\n\\n\\t\\tisMatrix4: true,\\n\\n\\t\\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\\n\\t\\t\\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\\n\\t\\t\\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\\n\\t\\t\\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tidentity: function () {\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\t1, 0, 0, 0,\\n\\t\\t\\t\\t0, 1, 0, 0,\\n\\t\\t\\t\\t0, 0, 1, 0,\\n\\t\\t\\t\\t0, 0, 0, 1\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new Matrix4().fromArray( this.elements );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( m ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\t\\t\\tvar me = m.elements;\\n\\n\\t\\t\\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];\\n\\t\\t\\tte[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];\\n\\t\\t\\tte[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];\\n\\t\\t\\tte[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyPosition: function ( m ) {\\n\\n\\t\\t\\tvar te = this.elements, me = m.elements;\\n\\n\\t\\t\\tte[ 12 ] = me[ 12 ];\\n\\t\\t\\tte[ 13 ] = me[ 13 ];\\n\\t\\t\\tte[ 14 ] = me[ 14 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\textractBasis: function ( xAxis, yAxis, zAxis ) {\\n\\n\\t\\t\\txAxis.setFromMatrixColumn( this, 0 );\\n\\t\\t\\tyAxis.setFromMatrixColumn( this, 1 );\\n\\t\\t\\tzAxis.setFromMatrixColumn( this, 2 );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\\n\\n\\t\\t\\tthis.set(\\n\\t\\t\\t\\txAxis.x, yAxis.x, zAxis.x, 0,\\n\\t\\t\\t\\txAxis.y, yAxis.y, zAxis.y, 0,\\n\\t\\t\\t\\txAxis.z, yAxis.z, zAxis.z, 0,\\n\\t\\t\\t\\t0, 0, 0, 1\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\textractRotation: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function extractRotation( m ) {\\n\\n\\t\\t\\t\\tvar te = this.elements;\\n\\t\\t\\t\\tvar me = m.elements;\\n\\n\\t\\t\\t\\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\\n\\t\\t\\t\\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\\n\\t\\t\\t\\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\\n\\n\\t\\t\\t\\tte[ 0 ] = me[ 0 ] * scaleX;\\n\\t\\t\\t\\tte[ 1 ] = me[ 1 ] * scaleX;\\n\\t\\t\\t\\tte[ 2 ] = me[ 2 ] * scaleX;\\n\\n\\t\\t\\t\\tte[ 4 ] = me[ 4 ] * scaleY;\\n\\t\\t\\t\\tte[ 5 ] = me[ 5 ] * scaleY;\\n\\t\\t\\t\\tte[ 6 ] = me[ 6 ] * scaleY;\\n\\n\\t\\t\\t\\tte[ 8 ] = me[ 8 ] * scaleZ;\\n\\t\\t\\t\\tte[ 9 ] = me[ 9 ] * scaleZ;\\n\\t\\t\\t\\tte[ 10 ] = me[ 10 ] * scaleZ;\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tmakeRotationFromEuler: function ( euler ) {\\n\\n\\t\\t\\tif ( ! ( euler && euler.isEuler ) ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tvar x = euler.x, y = euler.y, z = euler.z;\\n\\t\\t\\tvar a = Math.cos( x ), b = Math.sin( x );\\n\\t\\t\\tvar c = Math.cos( y ), d = Math.sin( y );\\n\\t\\t\\tvar e = Math.cos( z ), f = Math.sin( z );\\n\\n\\t\\t\\tif ( euler.order === 'XYZ' ) {\\n\\n\\t\\t\\t\\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\\n\\n\\t\\t\\t\\tte[ 0 ] = c * e;\\n\\t\\t\\t\\tte[ 4 ] = - c * f;\\n\\t\\t\\t\\tte[ 8 ] = d;\\n\\n\\t\\t\\t\\tte[ 1 ] = af + be * d;\\n\\t\\t\\t\\tte[ 5 ] = ae - bf * d;\\n\\t\\t\\t\\tte[ 9 ] = - b * c;\\n\\n\\t\\t\\t\\tte[ 2 ] = bf - ae * d;\\n\\t\\t\\t\\tte[ 6 ] = be + af * d;\\n\\t\\t\\t\\tte[ 10 ] = a * c;\\n\\n\\t\\t\\t} else if ( euler.order === 'YXZ' ) {\\n\\n\\t\\t\\t\\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\\n\\n\\t\\t\\t\\tte[ 0 ] = ce + df * b;\\n\\t\\t\\t\\tte[ 4 ] = de * b - cf;\\n\\t\\t\\t\\tte[ 8 ] = a * d;\\n\\n\\t\\t\\t\\tte[ 1 ] = a * f;\\n\\t\\t\\t\\tte[ 5 ] = a * e;\\n\\t\\t\\t\\tte[ 9 ] = - b;\\n\\n\\t\\t\\t\\tte[ 2 ] = cf * b - de;\\n\\t\\t\\t\\tte[ 6 ] = df + ce * b;\\n\\t\\t\\t\\tte[ 10 ] = a * c;\\n\\n\\t\\t\\t} else if ( euler.order === 'ZXY' ) {\\n\\n\\t\\t\\t\\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\\n\\n\\t\\t\\t\\tte[ 0 ] = ce - df * b;\\n\\t\\t\\t\\tte[ 4 ] = - a * f;\\n\\t\\t\\t\\tte[ 8 ] = de + cf * b;\\n\\n\\t\\t\\t\\tte[ 1 ] = cf + de * b;\\n\\t\\t\\t\\tte[ 5 ] = a * e;\\n\\t\\t\\t\\tte[ 9 ] = df - ce * b;\\n\\n\\t\\t\\t\\tte[ 2 ] = - a * d;\\n\\t\\t\\t\\tte[ 6 ] = b;\\n\\t\\t\\t\\tte[ 10 ] = a * c;\\n\\n\\t\\t\\t} else if ( euler.order === 'ZYX' ) {\\n\\n\\t\\t\\t\\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\\n\\n\\t\\t\\t\\tte[ 0 ] = c * e;\\n\\t\\t\\t\\tte[ 4 ] = be * d - af;\\n\\t\\t\\t\\tte[ 8 ] = ae * d + bf;\\n\\n\\t\\t\\t\\tte[ 1 ] = c * f;\\n\\t\\t\\t\\tte[ 5 ] = bf * d + ae;\\n\\t\\t\\t\\tte[ 9 ] = af * d - be;\\n\\n\\t\\t\\t\\tte[ 2 ] = - d;\\n\\t\\t\\t\\tte[ 6 ] = b * c;\\n\\t\\t\\t\\tte[ 10 ] = a * c;\\n\\n\\t\\t\\t} else if ( euler.order === 'YZX' ) {\\n\\n\\t\\t\\t\\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\\n\\n\\t\\t\\t\\tte[ 0 ] = c * e;\\n\\t\\t\\t\\tte[ 4 ] = bd - ac * f;\\n\\t\\t\\t\\tte[ 8 ] = bc * f + ad;\\n\\n\\t\\t\\t\\tte[ 1 ] = f;\\n\\t\\t\\t\\tte[ 5 ] = a * e;\\n\\t\\t\\t\\tte[ 9 ] = - b * e;\\n\\n\\t\\t\\t\\tte[ 2 ] = - d * e;\\n\\t\\t\\t\\tte[ 6 ] = ad * f + bc;\\n\\t\\t\\t\\tte[ 10 ] = ac - bd * f;\\n\\n\\t\\t\\t} else if ( euler.order === 'XZY' ) {\\n\\n\\t\\t\\t\\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\\n\\n\\t\\t\\t\\tte[ 0 ] = c * e;\\n\\t\\t\\t\\tte[ 4 ] = - f;\\n\\t\\t\\t\\tte[ 8 ] = d * e;\\n\\n\\t\\t\\t\\tte[ 1 ] = ac * f + bd;\\n\\t\\t\\t\\tte[ 5 ] = a * e;\\n\\t\\t\\t\\tte[ 9 ] = ad * f - bc;\\n\\n\\t\\t\\t\\tte[ 2 ] = bc * f - ad;\\n\\t\\t\\t\\tte[ 6 ] = b * e;\\n\\t\\t\\t\\tte[ 10 ] = bd * f + ac;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// last column\\n\\t\\t\\tte[ 3 ] = 0;\\n\\t\\t\\tte[ 7 ] = 0;\\n\\t\\t\\tte[ 11 ] = 0;\\n\\n\\t\\t\\t// bottom row\\n\\t\\t\\tte[ 12 ] = 0;\\n\\t\\t\\tte[ 13 ] = 0;\\n\\t\\t\\tte[ 14 ] = 0;\\n\\t\\t\\tte[ 15 ] = 1;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeRotationFromQuaternion: function ( q ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tvar x = q._x, y = q._y, z = q._z, w = q._w;\\n\\t\\t\\tvar x2 = x + x, y2 = y + y, z2 = z + z;\\n\\t\\t\\tvar xx = x * x2, xy = x * y2, xz = x * z2;\\n\\t\\t\\tvar yy = y * y2, yz = y * z2, zz = z * z2;\\n\\t\\t\\tvar wx = w * x2, wy = w * y2, wz = w * z2;\\n\\n\\t\\t\\tte[ 0 ] = 1 - ( yy + zz );\\n\\t\\t\\tte[ 4 ] = xy - wz;\\n\\t\\t\\tte[ 8 ] = xz + wy;\\n\\n\\t\\t\\tte[ 1 ] = xy + wz;\\n\\t\\t\\tte[ 5 ] = 1 - ( xx + zz );\\n\\t\\t\\tte[ 9 ] = yz - wx;\\n\\n\\t\\t\\tte[ 2 ] = xz - wy;\\n\\t\\t\\tte[ 6 ] = yz + wx;\\n\\t\\t\\tte[ 10 ] = 1 - ( xx + yy );\\n\\n\\t\\t\\t// last column\\n\\t\\t\\tte[ 3 ] = 0;\\n\\t\\t\\tte[ 7 ] = 0;\\n\\t\\t\\tte[ 11 ] = 0;\\n\\n\\t\\t\\t// bottom row\\n\\t\\t\\tte[ 12 ] = 0;\\n\\t\\t\\tte[ 13 ] = 0;\\n\\t\\t\\tte[ 14 ] = 0;\\n\\t\\t\\tte[ 15 ] = 1;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tlookAt: function () {\\n\\n\\t\\t\\tvar x = new Vector3();\\n\\t\\t\\tvar y = new Vector3();\\n\\t\\t\\tvar z = new Vector3();\\n\\n\\t\\t\\treturn function lookAt( eye, target, up ) {\\n\\n\\t\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\t\\tz.subVectors( eye, target );\\n\\n\\t\\t\\t\\tif ( z.lengthSq() === 0 ) {\\n\\n\\t\\t\\t\\t\\t// eye and target are in the same position\\n\\n\\t\\t\\t\\t\\tz.z = 1;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tz.normalize();\\n\\t\\t\\t\\tx.crossVectors( up, z );\\n\\n\\t\\t\\t\\tif ( x.lengthSq() === 0 ) {\\n\\n\\t\\t\\t\\t\\t// up and z are parallel\\n\\n\\t\\t\\t\\t\\tif ( Math.abs( up.z ) === 1 ) {\\n\\n\\t\\t\\t\\t\\t\\tz.x += 0.0001;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tz.z += 0.0001;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tz.normalize();\\n\\t\\t\\t\\t\\tx.crossVectors( up, z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tx.normalize();\\n\\t\\t\\t\\ty.crossVectors( z, x );\\n\\n\\t\\t\\t\\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\\n\\t\\t\\t\\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\\n\\t\\t\\t\\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tmultiply: function ( m, n ) {\\n\\n\\t\\t\\tif ( n !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.multiplyMatrices( m, n );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this.multiplyMatrices( this, m );\\n\\n\\t\\t},\\n\\n\\t\\tpremultiply: function ( m ) {\\n\\n\\t\\t\\treturn this.multiplyMatrices( m, this );\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyMatrices: function ( a, b ) {\\n\\n\\t\\t\\tvar ae = a.elements;\\n\\t\\t\\tvar be = b.elements;\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\\n\\t\\t\\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\\n\\t\\t\\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\\n\\t\\t\\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\\n\\n\\t\\t\\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\\n\\t\\t\\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\\n\\t\\t\\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\\n\\t\\t\\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\\n\\n\\t\\t\\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\\n\\t\\t\\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\\n\\t\\t\\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\\n\\t\\t\\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\\n\\n\\t\\t\\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\\n\\t\\t\\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\\n\\t\\t\\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\\n\\t\\t\\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\\n\\n\\t\\t\\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\\n\\t\\t\\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\\n\\t\\t\\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\\n\\t\\t\\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\\n\\n\\t\\t\\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\\n\\t\\t\\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\\n\\t\\t\\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\\n\\t\\t\\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyScalar: function ( s ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\\n\\t\\t\\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\\n\\t\\t\\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\\n\\t\\t\\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tapplyToBufferAttribute: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function applyToBufferAttribute( attribute ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tv1.x = attribute.getX( i );\\n\\t\\t\\t\\t\\tv1.y = attribute.getY( i );\\n\\t\\t\\t\\t\\tv1.z = attribute.getZ( i );\\n\\n\\t\\t\\t\\t\\tv1.applyMatrix4( this );\\n\\n\\t\\t\\t\\t\\tattribute.setXYZ( i, v1.x, v1.y, v1.z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn attribute;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tdeterminant: function () {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\\n\\t\\t\\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\\n\\t\\t\\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\\n\\t\\t\\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\\n\\n\\t\\t\\t//TODO: make this more efficient\\n\\t\\t\\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\\n\\n\\t\\t\\treturn (\\n\\t\\t\\t\\tn41 * (\\n\\t\\t\\t\\t\\t+ n14 * n23 * n32\\n\\t\\t\\t\\t\\t - n13 * n24 * n32\\n\\t\\t\\t\\t\\t - n14 * n22 * n33\\n\\t\\t\\t\\t\\t + n12 * n24 * n33\\n\\t\\t\\t\\t\\t + n13 * n22 * n34\\n\\t\\t\\t\\t\\t - n12 * n23 * n34\\n\\t\\t\\t\\t) +\\n\\t\\t\\t\\tn42 * (\\n\\t\\t\\t\\t\\t+ n11 * n23 * n34\\n\\t\\t\\t\\t\\t - n11 * n24 * n33\\n\\t\\t\\t\\t\\t + n14 * n21 * n33\\n\\t\\t\\t\\t\\t - n13 * n21 * n34\\n\\t\\t\\t\\t\\t + n13 * n24 * n31\\n\\t\\t\\t\\t\\t - n14 * n23 * n31\\n\\t\\t\\t\\t) +\\n\\t\\t\\t\\tn43 * (\\n\\t\\t\\t\\t\\t+ n11 * n24 * n32\\n\\t\\t\\t\\t\\t - n11 * n22 * n34\\n\\t\\t\\t\\t\\t - n14 * n21 * n32\\n\\t\\t\\t\\t\\t + n12 * n21 * n34\\n\\t\\t\\t\\t\\t + n14 * n22 * n31\\n\\t\\t\\t\\t\\t - n12 * n24 * n31\\n\\t\\t\\t\\t) +\\n\\t\\t\\t\\tn44 * (\\n\\t\\t\\t\\t\\t- n13 * n22 * n31\\n\\t\\t\\t\\t\\t - n11 * n23 * n32\\n\\t\\t\\t\\t\\t + n11 * n22 * n33\\n\\t\\t\\t\\t\\t + n13 * n21 * n32\\n\\t\\t\\t\\t\\t - n12 * n21 * n33\\n\\t\\t\\t\\t\\t + n12 * n23 * n31\\n\\t\\t\\t\\t)\\n\\n\\t\\t\\t);\\n\\n\\t\\t},\\n\\n\\t\\ttranspose: function () {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\t\\t\\tvar tmp;\\n\\n\\t\\t\\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\\n\\t\\t\\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\\n\\t\\t\\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\\n\\n\\t\\t\\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\\n\\t\\t\\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\\n\\t\\t\\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetPosition: function ( v ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tte[ 12 ] = v.x;\\n\\t\\t\\tte[ 13 ] = v.y;\\n\\t\\t\\tte[ 14 ] = v.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetInverse: function ( m, throwOnDegenerate ) {\\n\\n\\t\\t\\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\\n\\t\\t\\tvar te = this.elements,\\n\\t\\t\\t\\tme = m.elements,\\n\\n\\t\\t\\t\\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\\n\\t\\t\\t\\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\\n\\t\\t\\t\\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\\n\\t\\t\\t\\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\\n\\n\\t\\t\\t\\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\\n\\t\\t\\t\\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\\n\\t\\t\\t\\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\\n\\t\\t\\t\\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\\n\\n\\t\\t\\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\\n\\n\\t\\t\\tif ( det === 0 ) {\\n\\n\\t\\t\\t\\tvar msg = \\\"THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0\\\";\\n\\n\\t\\t\\t\\tif ( throwOnDegenerate === true ) {\\n\\n\\t\\t\\t\\t\\tthrow new Error( msg );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tconsole.warn( msg );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn this.identity();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar detInv = 1 / det;\\n\\n\\t\\t\\tte[ 0 ] = t11 * detInv;\\n\\t\\t\\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\\n\\t\\t\\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\\n\\t\\t\\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\\n\\n\\t\\t\\tte[ 4 ] = t12 * detInv;\\n\\t\\t\\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\\n\\t\\t\\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\\n\\t\\t\\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\\n\\n\\t\\t\\tte[ 8 ] = t13 * detInv;\\n\\t\\t\\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\\n\\t\\t\\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\\n\\t\\t\\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\\n\\n\\t\\t\\tte[ 12 ] = t14 * detInv;\\n\\t\\t\\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\\n\\t\\t\\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\\n\\t\\t\\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tscale: function ( v ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\t\\t\\tvar x = v.x, y = v.y, z = v.z;\\n\\n\\t\\t\\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\\n\\t\\t\\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\\n\\t\\t\\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\\n\\t\\t\\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetMaxScaleOnAxis: function () {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\\n\\t\\t\\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\\n\\t\\t\\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\\n\\n\\t\\t\\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\\n\\n\\t\\t},\\n\\n\\t\\tmakeTranslation: function ( x, y, z ) {\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\t1, 0, 0, x,\\n\\t\\t\\t\\t0, 1, 0, y,\\n\\t\\t\\t\\t0, 0, 1, z,\\n\\t\\t\\t\\t0, 0, 0, 1\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeRotationX: function ( theta ) {\\n\\n\\t\\t\\tvar c = Math.cos( theta ), s = Math.sin( theta );\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\t1, 0, 0, 0,\\n\\t\\t\\t\\t0, c, - s, 0,\\n\\t\\t\\t\\t0, s, c, 0,\\n\\t\\t\\t\\t0, 0, 0, 1\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeRotationY: function ( theta ) {\\n\\n\\t\\t\\tvar c = Math.cos( theta ), s = Math.sin( theta );\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\t c, 0, s, 0,\\n\\t\\t\\t\\t 0, 1, 0, 0,\\n\\t\\t\\t\\t- s, 0, c, 0,\\n\\t\\t\\t\\t 0, 0, 0, 1\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeRotationZ: function ( theta ) {\\n\\n\\t\\t\\tvar c = Math.cos( theta ), s = Math.sin( theta );\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\tc, - s, 0, 0,\\n\\t\\t\\t\\ts, c, 0, 0,\\n\\t\\t\\t\\t0, 0, 1, 0,\\n\\t\\t\\t\\t0, 0, 0, 1\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeRotationAxis: function ( axis, angle ) {\\n\\n\\t\\t\\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\\n\\n\\t\\t\\tvar c = Math.cos( angle );\\n\\t\\t\\tvar s = Math.sin( angle );\\n\\t\\t\\tvar t = 1 - c;\\n\\t\\t\\tvar x = axis.x, y = axis.y, z = axis.z;\\n\\t\\t\\tvar tx = t * x, ty = t * y;\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\\n\\t\\t\\t\\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\\n\\t\\t\\t\\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\\n\\t\\t\\t\\t0, 0, 0, 1\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\t return this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeScale: function ( x, y, z ) {\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\tx, 0, 0, 0,\\n\\t\\t\\t\\t0, y, 0, 0,\\n\\t\\t\\t\\t0, 0, z, 0,\\n\\t\\t\\t\\t0, 0, 0, 1\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeShear: function ( x, y, z ) {\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\t1, y, z, 0,\\n\\t\\t\\t\\tx, 1, z, 0,\\n\\t\\t\\t\\tx, y, 1, 0,\\n\\t\\t\\t\\t0, 0, 0, 1\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcompose: function ( position, quaternion, scale ) {\\n\\n\\t\\t\\tthis.makeRotationFromQuaternion( quaternion );\\n\\t\\t\\tthis.scale( scale );\\n\\t\\t\\tthis.setPosition( position );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdecompose: function () {\\n\\n\\t\\t\\tvar vector = new Vector3();\\n\\t\\t\\tvar matrix = new Matrix4();\\n\\n\\t\\t\\treturn function decompose( position, quaternion, scale ) {\\n\\n\\t\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\t\\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\\n\\t\\t\\t\\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\\n\\t\\t\\t\\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\\n\\n\\t\\t\\t\\t// if determine is negative, we need to invert one scale\\n\\t\\t\\t\\tvar det = this.determinant();\\n\\t\\t\\t\\tif ( det < 0 ) sx = - sx;\\n\\n\\t\\t\\t\\tposition.x = te[ 12 ];\\n\\t\\t\\t\\tposition.y = te[ 13 ];\\n\\t\\t\\t\\tposition.z = te[ 14 ];\\n\\n\\t\\t\\t\\t// scale the rotation part\\n\\t\\t\\t\\tmatrix.copy( this );\\n\\n\\t\\t\\t\\tvar invSX = 1 / sx;\\n\\t\\t\\t\\tvar invSY = 1 / sy;\\n\\t\\t\\t\\tvar invSZ = 1 / sz;\\n\\n\\t\\t\\t\\tmatrix.elements[ 0 ] *= invSX;\\n\\t\\t\\t\\tmatrix.elements[ 1 ] *= invSX;\\n\\t\\t\\t\\tmatrix.elements[ 2 ] *= invSX;\\n\\n\\t\\t\\t\\tmatrix.elements[ 4 ] *= invSY;\\n\\t\\t\\t\\tmatrix.elements[ 5 ] *= invSY;\\n\\t\\t\\t\\tmatrix.elements[ 6 ] *= invSY;\\n\\n\\t\\t\\t\\tmatrix.elements[ 8 ] *= invSZ;\\n\\t\\t\\t\\tmatrix.elements[ 9 ] *= invSZ;\\n\\t\\t\\t\\tmatrix.elements[ 10 ] *= invSZ;\\n\\n\\t\\t\\t\\tquaternion.setFromRotationMatrix( matrix );\\n\\n\\t\\t\\t\\tscale.x = sx;\\n\\t\\t\\t\\tscale.y = sy;\\n\\t\\t\\t\\tscale.z = sz;\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tmakePerspective: function ( left, right, top, bottom, near, far ) {\\n\\n\\t\\t\\tif ( far === undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar te = this.elements;\\n\\t\\t\\tvar x = 2 * near / ( right - left );\\n\\t\\t\\tvar y = 2 * near / ( top - bottom );\\n\\n\\t\\t\\tvar a = ( right + left ) / ( right - left );\\n\\t\\t\\tvar b = ( top + bottom ) / ( top - bottom );\\n\\t\\t\\tvar c = - ( far + near ) / ( far - near );\\n\\t\\t\\tvar d = - 2 * far * near / ( far - near );\\n\\n\\t\\t\\tte[ 0 ] = x;\\tte[ 4 ] = 0;\\tte[ 8 ] = a;\\tte[ 12 ] = 0;\\n\\t\\t\\tte[ 1 ] = 0;\\tte[ 5 ] = y;\\tte[ 9 ] = b;\\tte[ 13 ] = 0;\\n\\t\\t\\tte[ 2 ] = 0;\\tte[ 6 ] = 0;\\tte[ 10 ] = c;\\tte[ 14 ] = d;\\n\\t\\t\\tte[ 3 ] = 0;\\tte[ 7 ] = 0;\\tte[ 11 ] = - 1;\\tte[ 15 ] = 0;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\t\\t\\tvar w = 1.0 / ( right - left );\\n\\t\\t\\tvar h = 1.0 / ( top - bottom );\\n\\t\\t\\tvar p = 1.0 / ( far - near );\\n\\n\\t\\t\\tvar x = ( right + left ) * w;\\n\\t\\t\\tvar y = ( top + bottom ) * h;\\n\\t\\t\\tvar z = ( far + near ) * p;\\n\\n\\t\\t\\tte[ 0 ] = 2 * w;\\tte[ 4 ] = 0;\\tte[ 8 ] = 0;\\tte[ 12 ] = - x;\\n\\t\\t\\tte[ 1 ] = 0;\\tte[ 5 ] = 2 * h;\\tte[ 9 ] = 0;\\tte[ 13 ] = - y;\\n\\t\\t\\tte[ 2 ] = 0;\\tte[ 6 ] = 0;\\tte[ 10 ] = - 2 * p;\\tte[ 14 ] = - z;\\n\\t\\t\\tte[ 3 ] = 0;\\tte[ 7 ] = 0;\\tte[ 11 ] = 0;\\tte[ 15 ] = 1;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( matrix ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\t\\t\\tvar me = matrix.elements;\\n\\n\\t\\t\\tfor ( var i = 0; i < 16; i ++ ) {\\n\\n\\t\\t\\t\\tif ( te[ i ] !== me[ i ] ) return false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn true;\\n\\n\\t\\t},\\n\\n\\t\\tfromArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tfor ( var i = 0; i < 16; i ++ ) {\\n\\n\\t\\t\\t\\tthis.elements[ i ] = array[ i + offset ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( array === undefined ) array = [];\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tarray[ offset ] = te[ 0 ];\\n\\t\\t\\tarray[ offset + 1 ] = te[ 1 ];\\n\\t\\t\\tarray[ offset + 2 ] = te[ 2 ];\\n\\t\\t\\tarray[ offset + 3 ] = te[ 3 ];\\n\\n\\t\\t\\tarray[ offset + 4 ] = te[ 4 ];\\n\\t\\t\\tarray[ offset + 5 ] = te[ 5 ];\\n\\t\\t\\tarray[ offset + 6 ] = te[ 6 ];\\n\\t\\t\\tarray[ offset + 7 ] = te[ 7 ];\\n\\n\\t\\t\\tarray[ offset + 8 ] = te[ 8 ];\\n\\t\\t\\tarray[ offset + 9 ] = te[ 9 ];\\n\\t\\t\\tarray[ offset + 10 ] = te[ 10 ];\\n\\t\\t\\tarray[ offset + 11 ] = te[ 11 ];\\n\\n\\t\\t\\tarray[ offset + 12 ] = te[ 12 ];\\n\\t\\t\\tarray[ offset + 13 ] = te[ 13 ];\\n\\t\\t\\tarray[ offset + 14 ] = te[ 14 ];\\n\\t\\t\\tarray[ offset + 15 ] = te[ 15 ];\\n\\n\\t\\t\\treturn array;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t * @author bhouston / http://clara.io\\n\\t */\\n\\n\\tfunction Quaternion( x, y, z, w ) {\\n\\n\\t\\tthis._x = x || 0;\\n\\t\\tthis._y = y || 0;\\n\\t\\tthis._z = z || 0;\\n\\t\\tthis._w = ( w !== undefined ) ? w : 1;\\n\\n\\t}\\n\\n\\tObject.assign( Quaternion, {\\n\\n\\t\\tslerp: function ( qa, qb, qm, t ) {\\n\\n\\t\\t\\treturn qm.copy( qa ).slerp( qb, t );\\n\\n\\t\\t},\\n\\n\\t\\tslerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\\n\\n\\t\\t\\t// fuzz-free, array-based Quaternion SLERP operation\\n\\n\\t\\t\\tvar x0 = src0[ srcOffset0 + 0 ],\\n\\t\\t\\t\\ty0 = src0[ srcOffset0 + 1 ],\\n\\t\\t\\t\\tz0 = src0[ srcOffset0 + 2 ],\\n\\t\\t\\t\\tw0 = src0[ srcOffset0 + 3 ],\\n\\n\\t\\t\\t\\tx1 = src1[ srcOffset1 + 0 ],\\n\\t\\t\\t\\ty1 = src1[ srcOffset1 + 1 ],\\n\\t\\t\\t\\tz1 = src1[ srcOffset1 + 2 ],\\n\\t\\t\\t\\tw1 = src1[ srcOffset1 + 3 ];\\n\\n\\t\\t\\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\\n\\n\\t\\t\\t\\tvar s = 1 - t,\\n\\n\\t\\t\\t\\t\\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\\n\\n\\t\\t\\t\\t\\tdir = ( cos >= 0 ? 1 : - 1 ),\\n\\t\\t\\t\\t\\tsqrSin = 1 - cos * cos;\\n\\n\\t\\t\\t\\t// Skip the Slerp for tiny steps to avoid numeric problems:\\n\\t\\t\\t\\tif ( sqrSin > Number.EPSILON ) {\\n\\n\\t\\t\\t\\t\\tvar sin = Math.sqrt( sqrSin ),\\n\\t\\t\\t\\t\\t\\tlen = Math.atan2( sin, cos * dir );\\n\\n\\t\\t\\t\\t\\ts = Math.sin( s * len ) / sin;\\n\\t\\t\\t\\t\\tt = Math.sin( t * len ) / sin;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar tDir = t * dir;\\n\\n\\t\\t\\t\\tx0 = x0 * s + x1 * tDir;\\n\\t\\t\\t\\ty0 = y0 * s + y1 * tDir;\\n\\t\\t\\t\\tz0 = z0 * s + z1 * tDir;\\n\\t\\t\\t\\tw0 = w0 * s + w1 * tDir;\\n\\n\\t\\t\\t\\t// Normalize in case we just did a lerp:\\n\\t\\t\\t\\tif ( s === 1 - t ) {\\n\\n\\t\\t\\t\\t\\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\\n\\n\\t\\t\\t\\t\\tx0 *= f;\\n\\t\\t\\t\\t\\ty0 *= f;\\n\\t\\t\\t\\t\\tz0 *= f;\\n\\t\\t\\t\\t\\tw0 *= f;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tdst[ dstOffset ] = x0;\\n\\t\\t\\tdst[ dstOffset + 1 ] = y0;\\n\\t\\t\\tdst[ dstOffset + 2 ] = z0;\\n\\t\\t\\tdst[ dstOffset + 3 ] = w0;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperties( Quaternion.prototype, {\\n\\n\\t\\tx: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this._x;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis._x = value;\\n\\t\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\ty: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this._y;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis._y = value;\\n\\t\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tz: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this._z;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis._z = value;\\n\\t\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tw: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this._w;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis._w = value;\\n\\t\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( Quaternion.prototype, {\\n\\n\\t\\tset: function ( x, y, z, w ) {\\n\\n\\t\\t\\tthis._x = x;\\n\\t\\t\\tthis._y = y;\\n\\t\\t\\tthis._z = z;\\n\\t\\t\\tthis._w = w;\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this._x, this._y, this._z, this._w );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( quaternion ) {\\n\\n\\t\\t\\tthis._x = quaternion.x;\\n\\t\\t\\tthis._y = quaternion.y;\\n\\t\\t\\tthis._z = quaternion.z;\\n\\t\\t\\tthis._w = quaternion.w;\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromEuler: function ( euler, update ) {\\n\\n\\t\\t\\tif ( ! ( euler && euler.isEuler ) ) {\\n\\n\\t\\t\\t\\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar x = euler._x, y = euler._y, z = euler._z, order = euler.order;\\n\\n\\t\\t\\t// http://www.mathworks.com/matlabcentral/fileexchange/\\n\\t\\t\\t// \\t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\\n\\t\\t\\t//\\tcontent/SpinCalc.m\\n\\n\\t\\t\\tvar cos = Math.cos;\\n\\t\\t\\tvar sin = Math.sin;\\n\\n\\t\\t\\tvar c1 = cos( x / 2 );\\n\\t\\t\\tvar c2 = cos( y / 2 );\\n\\t\\t\\tvar c3 = cos( z / 2 );\\n\\n\\t\\t\\tvar s1 = sin( x / 2 );\\n\\t\\t\\tvar s2 = sin( y / 2 );\\n\\t\\t\\tvar s3 = sin( z / 2 );\\n\\n\\t\\t\\tif ( order === 'XYZ' ) {\\n\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\\n\\n\\t\\t\\t} else if ( order === 'YXZ' ) {\\n\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\\n\\n\\t\\t\\t} else if ( order === 'ZXY' ) {\\n\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\\n\\n\\t\\t\\t} else if ( order === 'ZYX' ) {\\n\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\\n\\n\\t\\t\\t} else if ( order === 'YZX' ) {\\n\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\\n\\n\\t\\t\\t} else if ( order === 'XZY' ) {\\n\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( update !== false ) this.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromAxisAngle: function ( axis, angle ) {\\n\\n\\t\\t\\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\\n\\n\\t\\t\\t// assumes axis is normalized\\n\\n\\t\\t\\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\\n\\n\\t\\t\\tthis._x = axis.x * s;\\n\\t\\t\\tthis._y = axis.y * s;\\n\\t\\t\\tthis._z = axis.z * s;\\n\\t\\t\\tthis._w = Math.cos( halfAngle );\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromRotationMatrix: function ( m ) {\\n\\n\\t\\t\\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\\n\\n\\t\\t\\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\\n\\n\\t\\t\\tvar te = m.elements,\\n\\n\\t\\t\\t\\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\\n\\t\\t\\t\\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\\n\\t\\t\\t\\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\\n\\n\\t\\t\\t\\ttrace = m11 + m22 + m33,\\n\\t\\t\\t\\ts;\\n\\n\\t\\t\\tif ( trace > 0 ) {\\n\\n\\t\\t\\t\\ts = 0.5 / Math.sqrt( trace + 1.0 );\\n\\n\\t\\t\\t\\tthis._w = 0.25 / s;\\n\\t\\t\\t\\tthis._x = ( m32 - m23 ) * s;\\n\\t\\t\\t\\tthis._y = ( m13 - m31 ) * s;\\n\\t\\t\\t\\tthis._z = ( m21 - m12 ) * s;\\n\\n\\t\\t\\t} else if ( m11 > m22 && m11 > m33 ) {\\n\\n\\t\\t\\t\\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\\n\\n\\t\\t\\t\\tthis._w = ( m32 - m23 ) / s;\\n\\t\\t\\t\\tthis._x = 0.25 * s;\\n\\t\\t\\t\\tthis._y = ( m12 + m21 ) / s;\\n\\t\\t\\t\\tthis._z = ( m13 + m31 ) / s;\\n\\n\\t\\t\\t} else if ( m22 > m33 ) {\\n\\n\\t\\t\\t\\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\\n\\n\\t\\t\\t\\tthis._w = ( m13 - m31 ) / s;\\n\\t\\t\\t\\tthis._x = ( m12 + m21 ) / s;\\n\\t\\t\\t\\tthis._y = 0.25 * s;\\n\\t\\t\\t\\tthis._z = ( m23 + m32 ) / s;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\\n\\n\\t\\t\\t\\tthis._w = ( m21 - m12 ) / s;\\n\\t\\t\\t\\tthis._x = ( m13 + m31 ) / s;\\n\\t\\t\\t\\tthis._y = ( m23 + m32 ) / s;\\n\\t\\t\\t\\tthis._z = 0.25 * s;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromUnitVectors: function () {\\n\\n\\t\\t\\t// assumes direction vectors vFrom and vTo are normalized\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\t\\t\\tvar r;\\n\\n\\t\\t\\tvar EPS = 0.000001;\\n\\n\\t\\t\\treturn function setFromUnitVectors( vFrom, vTo ) {\\n\\n\\t\\t\\t\\tif ( v1 === undefined ) v1 = new Vector3();\\n\\n\\t\\t\\t\\tr = vFrom.dot( vTo ) + 1;\\n\\n\\t\\t\\t\\tif ( r < EPS ) {\\n\\n\\t\\t\\t\\t\\tr = 0;\\n\\n\\t\\t\\t\\t\\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\\n\\n\\t\\t\\t\\t\\t\\tv1.set( - vFrom.y, vFrom.x, 0 );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tv1.set( 0, - vFrom.z, vFrom.y );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tv1.crossVectors( vFrom, vTo );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis._x = v1.x;\\n\\t\\t\\t\\tthis._y = v1.y;\\n\\t\\t\\t\\tthis._z = v1.z;\\n\\t\\t\\t\\tthis._w = r;\\n\\n\\t\\t\\t\\treturn this.normalize();\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tinverse: function () {\\n\\n\\t\\t\\treturn this.conjugate().normalize();\\n\\n\\t\\t},\\n\\n\\t\\tconjugate: function () {\\n\\n\\t\\t\\tthis._x *= - 1;\\n\\t\\t\\tthis._y *= - 1;\\n\\t\\t\\tthis._z *= - 1;\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdot: function ( v ) {\\n\\n\\t\\t\\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\\n\\n\\t\\t},\\n\\n\\t\\tlengthSq: function () {\\n\\n\\t\\t\\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\\n\\n\\t\\t},\\n\\n\\t\\tlength: function () {\\n\\n\\t\\t\\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\\n\\n\\t\\t},\\n\\n\\t\\tnormalize: function () {\\n\\n\\t\\t\\tvar l = this.length();\\n\\n\\t\\t\\tif ( l === 0 ) {\\n\\n\\t\\t\\t\\tthis._x = 0;\\n\\t\\t\\t\\tthis._y = 0;\\n\\t\\t\\t\\tthis._z = 0;\\n\\t\\t\\t\\tthis._w = 1;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tl = 1 / l;\\n\\n\\t\\t\\t\\tthis._x = this._x * l;\\n\\t\\t\\t\\tthis._y = this._y * l;\\n\\t\\t\\t\\tthis._z = this._z * l;\\n\\t\\t\\t\\tthis._w = this._w * l;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiply: function ( q, p ) {\\n\\n\\t\\t\\tif ( p !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.multiplyQuaternions( q, p );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this.multiplyQuaternions( this, q );\\n\\n\\t\\t},\\n\\n\\t\\tpremultiply: function ( q ) {\\n\\n\\t\\t\\treturn this.multiplyQuaternions( q, this );\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyQuaternions: function ( a, b ) {\\n\\n\\t\\t\\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\\n\\n\\t\\t\\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\\n\\t\\t\\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\\n\\n\\t\\t\\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\\n\\t\\t\\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\\n\\t\\t\\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\\n\\t\\t\\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tslerp: function ( qb, t ) {\\n\\n\\t\\t\\tif ( t === 0 ) return this;\\n\\t\\t\\tif ( t === 1 ) return this.copy( qb );\\n\\n\\t\\t\\tvar x = this._x, y = this._y, z = this._z, w = this._w;\\n\\n\\t\\t\\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\\n\\n\\t\\t\\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\\n\\n\\t\\t\\tif ( cosHalfTheta < 0 ) {\\n\\n\\t\\t\\t\\tthis._w = - qb._w;\\n\\t\\t\\t\\tthis._x = - qb._x;\\n\\t\\t\\t\\tthis._y = - qb._y;\\n\\t\\t\\t\\tthis._z = - qb._z;\\n\\n\\t\\t\\t\\tcosHalfTheta = - cosHalfTheta;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.copy( qb );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( cosHalfTheta >= 1.0 ) {\\n\\n\\t\\t\\t\\tthis._w = w;\\n\\t\\t\\t\\tthis._x = x;\\n\\t\\t\\t\\tthis._y = y;\\n\\t\\t\\t\\tthis._z = z;\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\\n\\n\\t\\t\\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\\n\\n\\t\\t\\t\\tthis._w = 0.5 * ( w + this._w );\\n\\t\\t\\t\\tthis._x = 0.5 * ( x + this._x );\\n\\t\\t\\t\\tthis._y = 0.5 * ( y + this._y );\\n\\t\\t\\t\\tthis._z = 0.5 * ( z + this._z );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\\n\\t\\t\\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\\n\\t\\t\\t\\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\\n\\n\\t\\t\\tthis._w = ( w * ratioA + this._w * ratioB );\\n\\t\\t\\tthis._x = ( x * ratioA + this._x * ratioB );\\n\\t\\t\\tthis._y = ( y * ratioA + this._y * ratioB );\\n\\t\\t\\tthis._z = ( z * ratioA + this._z * ratioB );\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( quaternion ) {\\n\\n\\t\\t\\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\\n\\n\\t\\t},\\n\\n\\t\\tfromArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tthis._x = array[ offset ];\\n\\t\\t\\tthis._y = array[ offset + 1 ];\\n\\t\\t\\tthis._z = array[ offset + 2 ];\\n\\t\\t\\tthis._w = array[ offset + 3 ];\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( array === undefined ) array = [];\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tarray[ offset ] = this._x;\\n\\t\\t\\tarray[ offset + 1 ] = this._y;\\n\\t\\t\\tarray[ offset + 2 ] = this._z;\\n\\t\\t\\tarray[ offset + 3 ] = this._w;\\n\\n\\t\\t\\treturn array;\\n\\n\\t\\t},\\n\\n\\t\\tonChange: function ( callback ) {\\n\\n\\t\\t\\tthis.onChangeCallback = callback;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tonChangeCallback: function () {}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author kile / http://kile.stravaganza.org/\\n\\t * @author philogb / http://blog.thejit.org/\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author egraether / http://egraether.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction Vector3( x, y, z ) {\\n\\n\\t\\tthis.x = x || 0;\\n\\t\\tthis.y = y || 0;\\n\\t\\tthis.z = z || 0;\\n\\n\\t}\\n\\n\\tObject.assign( Vector3.prototype, {\\n\\n\\t\\tisVector3: true,\\n\\n\\t\\tset: function ( x, y, z ) {\\n\\n\\t\\t\\tthis.x = x;\\n\\t\\t\\tthis.y = y;\\n\\t\\t\\tthis.z = z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetScalar: function ( scalar ) {\\n\\n\\t\\t\\tthis.x = scalar;\\n\\t\\t\\tthis.y = scalar;\\n\\t\\t\\tthis.z = scalar;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetX: function ( x ) {\\n\\n\\t\\t\\tthis.x = x;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetY: function ( y ) {\\n\\n\\t\\t\\tthis.y = y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetZ: function ( z ) {\\n\\n\\t\\t\\tthis.z = z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetComponent: function ( index, value ) {\\n\\n\\t\\t\\tswitch ( index ) {\\n\\n\\t\\t\\t\\tcase 0: this.x = value; break;\\n\\t\\t\\t\\tcase 1: this.y = value; break;\\n\\t\\t\\t\\tcase 2: this.z = value; break;\\n\\t\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetComponent: function ( index ) {\\n\\n\\t\\t\\tswitch ( index ) {\\n\\n\\t\\t\\t\\tcase 0: return this.x;\\n\\t\\t\\t\\tcase 1: return this.y;\\n\\t\\t\\t\\tcase 2: return this.z;\\n\\t\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.x, this.y, this.z );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( v ) {\\n\\n\\t\\t\\tthis.x = v.x;\\n\\t\\t\\tthis.y = v.y;\\n\\t\\t\\tthis.z = v.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tadd: function ( v, w ) {\\n\\n\\t\\t\\tif ( w !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.addVectors( v, w );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x += v.x;\\n\\t\\t\\tthis.y += v.y;\\n\\t\\t\\tthis.z += v.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddScalar: function ( s ) {\\n\\n\\t\\t\\tthis.x += s;\\n\\t\\t\\tthis.y += s;\\n\\t\\t\\tthis.z += s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddVectors: function ( a, b ) {\\n\\n\\t\\t\\tthis.x = a.x + b.x;\\n\\t\\t\\tthis.y = a.y + b.y;\\n\\t\\t\\tthis.z = a.z + b.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddScaledVector: function ( v, s ) {\\n\\n\\t\\t\\tthis.x += v.x * s;\\n\\t\\t\\tthis.y += v.y * s;\\n\\t\\t\\tthis.z += v.z * s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsub: function ( v, w ) {\\n\\n\\t\\t\\tif ( w !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.subVectors( v, w );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x -= v.x;\\n\\t\\t\\tthis.y -= v.y;\\n\\t\\t\\tthis.z -= v.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsubScalar: function ( s ) {\\n\\n\\t\\t\\tthis.x -= s;\\n\\t\\t\\tthis.y -= s;\\n\\t\\t\\tthis.z -= s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsubVectors: function ( a, b ) {\\n\\n\\t\\t\\tthis.x = a.x - b.x;\\n\\t\\t\\tthis.y = a.y - b.y;\\n\\t\\t\\tthis.z = a.z - b.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiply: function ( v, w ) {\\n\\n\\t\\t\\tif ( w !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.multiplyVectors( v, w );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x *= v.x;\\n\\t\\t\\tthis.y *= v.y;\\n\\t\\t\\tthis.z *= v.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyScalar: function ( scalar ) {\\n\\n\\t\\t\\tthis.x *= scalar;\\n\\t\\t\\tthis.y *= scalar;\\n\\t\\t\\tthis.z *= scalar;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyVectors: function ( a, b ) {\\n\\n\\t\\t\\tthis.x = a.x * b.x;\\n\\t\\t\\tthis.y = a.y * b.y;\\n\\t\\t\\tthis.z = a.z * b.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tapplyEuler: function () {\\n\\n\\t\\t\\tvar quaternion = new Quaternion();\\n\\n\\t\\t\\treturn function applyEuler( euler ) {\\n\\n\\t\\t\\t\\tif ( ! ( euler && euler.isEuler ) ) {\\n\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn this.applyQuaternion( quaternion.setFromEuler( euler ) );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tapplyAxisAngle: function () {\\n\\n\\t\\t\\tvar quaternion = new Quaternion();\\n\\n\\t\\t\\treturn function applyAxisAngle( axis, angle ) {\\n\\n\\t\\t\\t\\treturn this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tapplyMatrix3: function ( m ) {\\n\\n\\t\\t\\tvar x = this.x, y = this.y, z = this.z;\\n\\t\\t\\tvar e = m.elements;\\n\\n\\t\\t\\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\\n\\t\\t\\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\\n\\t\\t\\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tapplyMatrix4: function ( m ) {\\n\\n\\t\\t\\tvar x = this.x, y = this.y, z = this.z;\\n\\t\\t\\tvar e = m.elements;\\n\\n\\t\\t\\tvar w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );\\n\\n\\t\\t\\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;\\n\\t\\t\\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;\\n\\t\\t\\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tapplyQuaternion: function ( q ) {\\n\\n\\t\\t\\tvar x = this.x, y = this.y, z = this.z;\\n\\t\\t\\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\\n\\n\\t\\t\\t// calculate quat * vector\\n\\n\\t\\t\\tvar ix = qw * x + qy * z - qz * y;\\n\\t\\t\\tvar iy = qw * y + qz * x - qx * z;\\n\\t\\t\\tvar iz = qw * z + qx * y - qy * x;\\n\\t\\t\\tvar iw = - qx * x - qy * y - qz * z;\\n\\n\\t\\t\\t// calculate result * inverse quat\\n\\n\\t\\t\\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\\n\\t\\t\\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\\n\\t\\t\\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tproject: function () {\\n\\n\\t\\t\\tvar matrix = new Matrix4();\\n\\n\\t\\t\\treturn function project( camera ) {\\n\\n\\t\\t\\t\\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\\n\\t\\t\\t\\treturn this.applyMatrix4( matrix );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tunproject: function () {\\n\\n\\t\\t\\tvar matrix = new Matrix4();\\n\\n\\t\\t\\treturn function unproject( camera ) {\\n\\n\\t\\t\\t\\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\\n\\t\\t\\t\\treturn this.applyMatrix4( matrix );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttransformDirection: function ( m ) {\\n\\n\\t\\t\\t// input: THREE.Matrix4 affine matrix\\n\\t\\t\\t// vector interpreted as a direction\\n\\n\\t\\t\\tvar x = this.x, y = this.y, z = this.z;\\n\\t\\t\\tvar e = m.elements;\\n\\n\\t\\t\\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\\n\\t\\t\\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\\n\\t\\t\\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\\n\\n\\t\\t\\treturn this.normalize();\\n\\n\\t\\t},\\n\\n\\t\\tdivide: function ( v ) {\\n\\n\\t\\t\\tthis.x /= v.x;\\n\\t\\t\\tthis.y /= v.y;\\n\\t\\t\\tthis.z /= v.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdivideScalar: function ( scalar ) {\\n\\n\\t\\t\\treturn this.multiplyScalar( 1 / scalar );\\n\\n\\t\\t},\\n\\n\\t\\tmin: function ( v ) {\\n\\n\\t\\t\\tthis.x = Math.min( this.x, v.x );\\n\\t\\t\\tthis.y = Math.min( this.y, v.y );\\n\\t\\t\\tthis.z = Math.min( this.z, v.z );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmax: function ( v ) {\\n\\n\\t\\t\\tthis.x = Math.max( this.x, v.x );\\n\\t\\t\\tthis.y = Math.max( this.y, v.y );\\n\\t\\t\\tthis.z = Math.max( this.z, v.z );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclamp: function ( min, max ) {\\n\\n\\t\\t\\t// assumes min < max, componentwise\\n\\n\\t\\t\\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\\n\\t\\t\\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\\n\\t\\t\\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclampScalar: function () {\\n\\n\\t\\t\\tvar min = new Vector3();\\n\\t\\t\\tvar max = new Vector3();\\n\\n\\t\\t\\treturn function clampScalar( minVal, maxVal ) {\\n\\n\\t\\t\\t\\tmin.set( minVal, minVal, minVal );\\n\\t\\t\\t\\tmax.set( maxVal, maxVal, maxVal );\\n\\n\\t\\t\\t\\treturn this.clamp( min, max );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tclampLength: function ( min, max ) {\\n\\n\\t\\t\\tvar length = this.length();\\n\\n\\t\\t\\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\\n\\n\\t\\t},\\n\\n\\t\\tfloor: function () {\\n\\n\\t\\t\\tthis.x = Math.floor( this.x );\\n\\t\\t\\tthis.y = Math.floor( this.y );\\n\\t\\t\\tthis.z = Math.floor( this.z );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tceil: function () {\\n\\n\\t\\t\\tthis.x = Math.ceil( this.x );\\n\\t\\t\\tthis.y = Math.ceil( this.y );\\n\\t\\t\\tthis.z = Math.ceil( this.z );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tround: function () {\\n\\n\\t\\t\\tthis.x = Math.round( this.x );\\n\\t\\t\\tthis.y = Math.round( this.y );\\n\\t\\t\\tthis.z = Math.round( this.z );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\troundToZero: function () {\\n\\n\\t\\t\\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\\n\\t\\t\\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\\n\\t\\t\\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tnegate: function () {\\n\\n\\t\\t\\tthis.x = - this.x;\\n\\t\\t\\tthis.y = - this.y;\\n\\t\\t\\tthis.z = - this.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdot: function ( v ) {\\n\\n\\t\\t\\treturn this.x * v.x + this.y * v.y + this.z * v.z;\\n\\n\\t\\t},\\n\\n\\t\\t// TODO lengthSquared?\\n\\n\\t\\tlengthSq: function () {\\n\\n\\t\\t\\treturn this.x * this.x + this.y * this.y + this.z * this.z;\\n\\n\\t\\t},\\n\\n\\t\\tlength: function () {\\n\\n\\t\\t\\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\\n\\n\\t\\t},\\n\\n\\t\\tmanhattanLength: function () {\\n\\n\\t\\t\\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\\n\\n\\t\\t},\\n\\n\\t\\tnormalize: function () {\\n\\n\\t\\t\\treturn this.divideScalar( this.length() || 1 );\\n\\n\\t\\t},\\n\\n\\t\\tsetLength: function ( length ) {\\n\\n\\t\\t\\treturn this.normalize().multiplyScalar( length );\\n\\n\\t\\t},\\n\\n\\t\\tlerp: function ( v, alpha ) {\\n\\n\\t\\t\\tthis.x += ( v.x - this.x ) * alpha;\\n\\t\\t\\tthis.y += ( v.y - this.y ) * alpha;\\n\\t\\t\\tthis.z += ( v.z - this.z ) * alpha;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tlerpVectors: function ( v1, v2, alpha ) {\\n\\n\\t\\t\\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\\n\\n\\t\\t},\\n\\n\\t\\tcross: function ( v, w ) {\\n\\n\\t\\t\\tif ( w !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.crossVectors( v, w );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this.crossVectors( this, v );\\n\\n\\t\\t},\\n\\n\\t\\tcrossVectors: function ( a, b ) {\\n\\n\\t\\t\\tvar ax = a.x, ay = a.y, az = a.z;\\n\\t\\t\\tvar bx = b.x, by = b.y, bz = b.z;\\n\\n\\t\\t\\tthis.x = ay * bz - az * by;\\n\\t\\t\\tthis.y = az * bx - ax * bz;\\n\\t\\t\\tthis.z = ax * by - ay * bx;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tprojectOnVector: function ( vector ) {\\n\\n\\t\\t\\tvar scalar = vector.dot( this ) / vector.lengthSq();\\n\\n\\t\\t\\treturn this.copy( vector ).multiplyScalar( scalar );\\n\\n\\t\\t},\\n\\n\\t\\tprojectOnPlane: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function projectOnPlane( planeNormal ) {\\n\\n\\t\\t\\t\\tv1.copy( this ).projectOnVector( planeNormal );\\n\\n\\t\\t\\t\\treturn this.sub( v1 );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\treflect: function () {\\n\\n\\t\\t\\t// reflect incident vector off plane orthogonal to normal\\n\\t\\t\\t// normal is assumed to have unit length\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function reflect( normal ) {\\n\\n\\t\\t\\t\\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tangleTo: function ( v ) {\\n\\n\\t\\t\\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\\n\\n\\t\\t\\t// clamp, to handle numerical problems\\n\\n\\t\\t\\treturn Math.acos( _Math.clamp( theta, - 1, 1 ) );\\n\\n\\t\\t},\\n\\n\\t\\tdistanceTo: function ( v ) {\\n\\n\\t\\t\\treturn Math.sqrt( this.distanceToSquared( v ) );\\n\\n\\t\\t},\\n\\n\\t\\tdistanceToSquared: function ( v ) {\\n\\n\\t\\t\\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\\n\\n\\t\\t\\treturn dx * dx + dy * dy + dz * dz;\\n\\n\\t\\t},\\n\\n\\t\\tmanhattanDistanceTo: function ( v ) {\\n\\n\\t\\t\\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\\n\\n\\t\\t},\\n\\n\\t\\tsetFromSpherical: function ( s ) {\\n\\n\\t\\t\\tvar sinPhiRadius = Math.sin( s.phi ) * s.radius;\\n\\n\\t\\t\\tthis.x = sinPhiRadius * Math.sin( s.theta );\\n\\t\\t\\tthis.y = Math.cos( s.phi ) * s.radius;\\n\\t\\t\\tthis.z = sinPhiRadius * Math.cos( s.theta );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromCylindrical: function ( c ) {\\n\\n\\t\\t\\tthis.x = c.radius * Math.sin( c.theta );\\n\\t\\t\\tthis.y = c.y;\\n\\t\\t\\tthis.z = c.radius * Math.cos( c.theta );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromMatrixPosition: function ( m ) {\\n\\n\\t\\t\\tvar e = m.elements;\\n\\n\\t\\t\\tthis.x = e[ 12 ];\\n\\t\\t\\tthis.y = e[ 13 ];\\n\\t\\t\\tthis.z = e[ 14 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromMatrixScale: function ( m ) {\\n\\n\\t\\t\\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\\n\\t\\t\\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\\n\\t\\t\\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\\n\\n\\t\\t\\tthis.x = sx;\\n\\t\\t\\tthis.y = sy;\\n\\t\\t\\tthis.z = sz;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromMatrixColumn: function ( m, index ) {\\n\\n\\t\\t\\treturn this.fromArray( m.elements, index * 4 );\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( v ) {\\n\\n\\t\\t\\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\\n\\n\\t\\t},\\n\\n\\t\\tfromArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tthis.x = array[ offset ];\\n\\t\\t\\tthis.y = array[ offset + 1 ];\\n\\t\\t\\tthis.z = array[ offset + 2 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( array === undefined ) array = [];\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tarray[ offset ] = this.x;\\n\\t\\t\\tarray[ offset + 1 ] = this.y;\\n\\t\\t\\tarray[ offset + 2 ] = this.z;\\n\\n\\t\\t\\treturn array;\\n\\n\\t\\t},\\n\\n\\t\\tfromBufferAttribute: function ( attribute, index, offset ) {\\n\\n\\t\\t\\tif ( offset !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x = attribute.getX( index );\\n\\t\\t\\tthis.y = attribute.getY( index );\\n\\t\\t\\tthis.z = attribute.getZ( index );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t * @author bhouston / http://clara.io\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction Matrix3() {\\n\\n\\t\\tthis.elements = [\\n\\n\\t\\t\\t1, 0, 0,\\n\\t\\t\\t0, 1, 0,\\n\\t\\t\\t0, 0, 1\\n\\n\\t\\t];\\n\\n\\t\\tif ( arguments.length > 0 ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tObject.assign( Matrix3.prototype, {\\n\\n\\t\\tisMatrix3: true,\\n\\n\\t\\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\\n\\t\\t\\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\\n\\t\\t\\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tidentity: function () {\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\t1, 0, 0,\\n\\t\\t\\t\\t0, 1, 0,\\n\\t\\t\\t\\t0, 0, 1\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().fromArray( this.elements );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( m ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\t\\t\\tvar me = m.elements;\\n\\n\\t\\t\\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];\\n\\t\\t\\tte[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];\\n\\t\\t\\tte[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromMatrix4: function ( m ) {\\n\\n\\t\\t\\tvar me = m.elements;\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\tme[ 0 ], me[ 4 ], me[ 8 ],\\n\\t\\t\\t\\tme[ 1 ], me[ 5 ], me[ 9 ],\\n\\t\\t\\t\\tme[ 2 ], me[ 6 ], me[ 10 ]\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tapplyToBufferAttribute: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function applyToBufferAttribute( attribute ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tv1.x = attribute.getX( i );\\n\\t\\t\\t\\t\\tv1.y = attribute.getY( i );\\n\\t\\t\\t\\t\\tv1.z = attribute.getZ( i );\\n\\n\\t\\t\\t\\t\\tv1.applyMatrix3( this );\\n\\n\\t\\t\\t\\t\\tattribute.setXYZ( i, v1.x, v1.y, v1.z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn attribute;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tmultiply: function ( m ) {\\n\\n\\t\\t\\treturn this.multiplyMatrices( this, m );\\n\\n\\t\\t},\\n\\n\\t\\tpremultiply: function ( m ) {\\n\\n\\t\\t\\treturn this.multiplyMatrices( m, this );\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyMatrices: function ( a, b ) {\\n\\n\\t\\t\\tvar ae = a.elements;\\n\\t\\t\\tvar be = b.elements;\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tvar a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];\\n\\t\\t\\tvar a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];\\n\\t\\t\\tvar a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];\\n\\n\\t\\t\\tvar b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];\\n\\t\\t\\tvar b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];\\n\\t\\t\\tvar b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];\\n\\n\\t\\t\\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;\\n\\t\\t\\tte[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;\\n\\t\\t\\tte[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;\\n\\n\\t\\t\\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;\\n\\t\\t\\tte[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;\\n\\t\\t\\tte[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;\\n\\n\\t\\t\\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;\\n\\t\\t\\tte[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;\\n\\t\\t\\tte[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyScalar: function ( s ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\\n\\t\\t\\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\\n\\t\\t\\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdeterminant: function () {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\\n\\t\\t\\t\\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\\n\\t\\t\\t\\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\\n\\n\\t\\t\\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\\n\\n\\t\\t},\\n\\n\\t\\tgetInverse: function ( matrix, throwOnDegenerate ) {\\n\\n\\t\\t\\tif ( matrix && matrix.isMatrix4 ) {\\n\\n\\t\\t\\t\\tconsole.error( \\\"THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.\\\" );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar me = matrix.elements,\\n\\t\\t\\t\\tte = this.elements,\\n\\n\\t\\t\\t\\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\\n\\t\\t\\t\\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\\n\\t\\t\\t\\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\\n\\n\\t\\t\\t\\tt11 = n33 * n22 - n32 * n23,\\n\\t\\t\\t\\tt12 = n32 * n13 - n33 * n12,\\n\\t\\t\\t\\tt13 = n23 * n12 - n22 * n13,\\n\\n\\t\\t\\t\\tdet = n11 * t11 + n21 * t12 + n31 * t13;\\n\\n\\t\\t\\tif ( det === 0 ) {\\n\\n\\t\\t\\t\\tvar msg = \\\"THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0\\\";\\n\\n\\t\\t\\t\\tif ( throwOnDegenerate === true ) {\\n\\n\\t\\t\\t\\t\\tthrow new Error( msg );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tconsole.warn( msg );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn this.identity();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar detInv = 1 / det;\\n\\n\\t\\t\\tte[ 0 ] = t11 * detInv;\\n\\t\\t\\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\\n\\t\\t\\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\\n\\n\\t\\t\\tte[ 3 ] = t12 * detInv;\\n\\t\\t\\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\\n\\t\\t\\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\\n\\n\\t\\t\\tte[ 6 ] = t13 * detInv;\\n\\t\\t\\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\\n\\t\\t\\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttranspose: function () {\\n\\n\\t\\t\\tvar tmp, m = this.elements;\\n\\n\\t\\t\\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\\n\\t\\t\\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\\n\\t\\t\\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetNormalMatrix: function ( matrix4 ) {\\n\\n\\t\\t\\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\\n\\n\\t\\t},\\n\\n\\t\\ttransposeIntoArray: function ( r ) {\\n\\n\\t\\t\\tvar m = this.elements;\\n\\n\\t\\t\\tr[ 0 ] = m[ 0 ];\\n\\t\\t\\tr[ 1 ] = m[ 3 ];\\n\\t\\t\\tr[ 2 ] = m[ 6 ];\\n\\t\\t\\tr[ 3 ] = m[ 1 ];\\n\\t\\t\\tr[ 4 ] = m[ 4 ];\\n\\t\\t\\tr[ 5 ] = m[ 7 ];\\n\\t\\t\\tr[ 6 ] = m[ 2 ];\\n\\t\\t\\tr[ 7 ] = m[ 5 ];\\n\\t\\t\\tr[ 8 ] = m[ 8 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {\\n\\n\\t\\t\\tvar c = Math.cos( rotation );\\n\\t\\t\\tvar s = Math.sin( rotation );\\n\\n\\t\\t\\tthis.set(\\n\\t\\t\\t\\tsx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,\\n\\t\\t\\t\\t- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,\\n\\t\\t\\t\\t0, 0, 1\\n\\t\\t\\t);\\n\\n\\t\\t},\\n\\n\\t\\tscale: function ( sx, sy ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tte[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;\\n\\t\\t\\tte[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\trotate: function ( theta ) {\\n\\n\\t\\t\\tvar c = Math.cos( theta );\\n\\t\\t\\tvar s = Math.sin( theta );\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tvar a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];\\n\\t\\t\\tvar a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];\\n\\n\\t\\t\\tte[ 0 ] = c * a11 + s * a21;\\n\\t\\t\\tte[ 3 ] = c * a12 + s * a22;\\n\\t\\t\\tte[ 6 ] = c * a13 + s * a23;\\n\\n\\t\\t\\tte[ 1 ] = - s * a11 + c * a21;\\n\\t\\t\\tte[ 4 ] = - s * a12 + c * a22;\\n\\t\\t\\tte[ 7 ] = - s * a13 + c * a23;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttranslate: function ( tx, ty ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tte[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];\\n\\t\\t\\tte[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( matrix ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\t\\t\\tvar me = matrix.elements;\\n\\n\\t\\t\\tfor ( var i = 0; i < 9; i ++ ) {\\n\\n\\t\\t\\t\\tif ( te[ i ] !== me[ i ] ) return false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn true;\\n\\n\\t\\t},\\n\\n\\t\\tfromArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tfor ( var i = 0; i < 9; i ++ ) {\\n\\n\\t\\t\\t\\tthis.elements[ i ] = array[ i + offset ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( array === undefined ) array = [];\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tarray[ offset ] = te[ 0 ];\\n\\t\\t\\tarray[ offset + 1 ] = te[ 1 ];\\n\\t\\t\\tarray[ offset + 2 ] = te[ 2 ];\\n\\n\\t\\t\\tarray[ offset + 3 ] = te[ 3 ];\\n\\t\\t\\tarray[ offset + 4 ] = te[ 4 ];\\n\\t\\t\\tarray[ offset + 5 ] = te[ 5 ];\\n\\n\\t\\t\\tarray[ offset + 6 ] = te[ 6 ];\\n\\t\\t\\tarray[ offset + 7 ] = te[ 7 ];\\n\\t\\t\\tarray[ offset + 8 ] = te[ 8 ];\\n\\n\\t\\t\\treturn array;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author szimek / https://github.com/szimek/\\n\\t */\\n\\n\\tvar textureId = 0;\\n\\n\\tfunction Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\\n\\n\\t\\tObject.defineProperty( this, 'id', { value: textureId ++ } );\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\tthis.name = '';\\n\\n\\t\\tthis.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;\\n\\t\\tthis.mipmaps = [];\\n\\n\\t\\tthis.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;\\n\\n\\t\\tthis.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;\\n\\t\\tthis.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;\\n\\n\\t\\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\\n\\t\\tthis.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;\\n\\n\\t\\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\\n\\n\\t\\tthis.format = format !== undefined ? format : RGBAFormat;\\n\\t\\tthis.type = type !== undefined ? type : UnsignedByteType;\\n\\n\\t\\tthis.offset = new Vector2( 0, 0 );\\n\\t\\tthis.repeat = new Vector2( 1, 1 );\\n\\t\\tthis.center = new Vector2( 0, 0 );\\n\\t\\tthis.rotation = 0;\\n\\n\\t\\tthis.matrixAutoUpdate = true;\\n\\t\\tthis.matrix = new Matrix3();\\n\\n\\t\\tthis.generateMipmaps = true;\\n\\t\\tthis.premultiplyAlpha = false;\\n\\t\\tthis.flipY = true;\\n\\t\\tthis.unpackAlignment = 4;\\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\\n\\n\\t\\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\\n\\t\\t//\\n\\t\\t// Also changing the encoding after already used by a Material will not automatically make the Material\\n\\t\\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\\n\\t\\tthis.encoding = encoding !== undefined ? encoding : LinearEncoding;\\n\\n\\t\\tthis.version = 0;\\n\\t\\tthis.onUpdate = null;\\n\\n\\t}\\n\\n\\tTexture.DEFAULT_IMAGE = undefined;\\n\\tTexture.DEFAULT_MAPPING = UVMapping;\\n\\n\\tTexture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\n\\n\\t\\tconstructor: Texture,\\n\\n\\t\\tisTexture: true,\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tthis.name = source.name;\\n\\n\\t\\t\\tthis.image = source.image;\\n\\t\\t\\tthis.mipmaps = source.mipmaps.slice( 0 );\\n\\n\\t\\t\\tthis.mapping = source.mapping;\\n\\n\\t\\t\\tthis.wrapS = source.wrapS;\\n\\t\\t\\tthis.wrapT = source.wrapT;\\n\\n\\t\\t\\tthis.magFilter = source.magFilter;\\n\\t\\t\\tthis.minFilter = source.minFilter;\\n\\n\\t\\t\\tthis.anisotropy = source.anisotropy;\\n\\n\\t\\t\\tthis.format = source.format;\\n\\t\\t\\tthis.type = source.type;\\n\\n\\t\\t\\tthis.offset.copy( source.offset );\\n\\t\\t\\tthis.repeat.copy( source.repeat );\\n\\t\\t\\tthis.center.copy( source.center );\\n\\t\\t\\tthis.rotation = source.rotation;\\n\\n\\t\\t\\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\\n\\t\\t\\tthis.matrix.copy( source.matrix );\\n\\n\\t\\t\\tthis.generateMipmaps = source.generateMipmaps;\\n\\t\\t\\tthis.premultiplyAlpha = source.premultiplyAlpha;\\n\\t\\t\\tthis.flipY = source.flipY;\\n\\t\\t\\tthis.unpackAlignment = source.unpackAlignment;\\n\\t\\t\\tthis.encoding = source.encoding;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( meta ) {\\n\\n\\t\\t\\tvar isRootObject = ( meta === undefined || typeof meta === 'string' );\\n\\n\\t\\t\\tif ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {\\n\\n\\t\\t\\t\\treturn meta.textures[ this.uuid ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction getDataURL( image ) {\\n\\n\\t\\t\\t\\tvar canvas;\\n\\n\\t\\t\\t\\tif ( image instanceof HTMLCanvasElement ) {\\n\\n\\t\\t\\t\\t\\tcanvas = image;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tcanvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\\n\\t\\t\\t\\t\\tcanvas.width = image.width;\\n\\t\\t\\t\\t\\tcanvas.height = image.height;\\n\\n\\t\\t\\t\\t\\tvar context = canvas.getContext( '2d' );\\n\\n\\t\\t\\t\\t\\tif ( image instanceof ImageData ) {\\n\\n\\t\\t\\t\\t\\t\\tcontext.putImageData( image, 0, 0 );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tcontext.drawImage( image, 0, 0, image.width, image.height );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\\n\\n\\t\\t\\t\\t\\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\treturn canvas.toDataURL( 'image/png' );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar output = {\\n\\t\\t\\t\\tmetadata: {\\n\\t\\t\\t\\t\\tversion: 4.5,\\n\\t\\t\\t\\t\\ttype: 'Texture',\\n\\t\\t\\t\\t\\tgenerator: 'Texture.toJSON'\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tuuid: this.uuid,\\n\\t\\t\\t\\tname: this.name,\\n\\n\\t\\t\\t\\tmapping: this.mapping,\\n\\n\\t\\t\\t\\trepeat: [ this.repeat.x, this.repeat.y ],\\n\\t\\t\\t\\toffset: [ this.offset.x, this.offset.y ],\\n\\t\\t\\t\\tcenter: [ this.center.x, this.center.y ],\\n\\t\\t\\t\\trotation: this.rotation,\\n\\n\\t\\t\\t\\twrap: [ this.wrapS, this.wrapT ],\\n\\n\\t\\t\\t\\tminFilter: this.minFilter,\\n\\t\\t\\t\\tmagFilter: this.magFilter,\\n\\t\\t\\t\\tanisotropy: this.anisotropy,\\n\\n\\t\\t\\t\\tflipY: this.flipY\\n\\t\\t\\t};\\n\\n\\t\\t\\tif ( this.image !== undefined ) {\\n\\n\\t\\t\\t\\t// TODO: Move to THREE.Image\\n\\n\\t\\t\\t\\tvar image = this.image;\\n\\n\\t\\t\\t\\tif ( image.uuid === undefined ) {\\n\\n\\t\\t\\t\\t\\timage.uuid = _Math.generateUUID(); // UGH\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {\\n\\n\\t\\t\\t\\t\\tmeta.images[ image.uuid ] = {\\n\\t\\t\\t\\t\\t\\tuuid: image.uuid,\\n\\t\\t\\t\\t\\t\\turl: getDataURL( image )\\n\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\toutput.image = image.uuid;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( ! isRootObject ) {\\n\\n\\t\\t\\t\\tmeta.textures[ this.uuid ] = output;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn output;\\n\\n\\t\\t},\\n\\n\\t\\tdispose: function () {\\n\\n\\t\\t\\tthis.dispatchEvent( { type: 'dispose' } );\\n\\n\\t\\t},\\n\\n\\t\\ttransformUv: function ( uv ) {\\n\\n\\t\\t\\tif ( this.mapping !== UVMapping ) return;\\n\\n\\t\\t\\tuv.applyMatrix3( this.matrix );\\n\\n\\t\\t\\tif ( uv.x < 0 || uv.x > 1 ) {\\n\\n\\t\\t\\t\\tswitch ( this.wrapS ) {\\n\\n\\t\\t\\t\\t\\tcase RepeatWrapping:\\n\\n\\t\\t\\t\\t\\t\\tuv.x = uv.x - Math.floor( uv.x );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase ClampToEdgeWrapping:\\n\\n\\t\\t\\t\\t\\t\\tuv.x = uv.x < 0 ? 0 : 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase MirroredRepeatWrapping:\\n\\n\\t\\t\\t\\t\\t\\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tuv.x = Math.ceil( uv.x ) - uv.x;\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tuv.x = uv.x - Math.floor( uv.x );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( uv.y < 0 || uv.y > 1 ) {\\n\\n\\t\\t\\t\\tswitch ( this.wrapT ) {\\n\\n\\t\\t\\t\\t\\tcase RepeatWrapping:\\n\\n\\t\\t\\t\\t\\t\\tuv.y = uv.y - Math.floor( uv.y );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase ClampToEdgeWrapping:\\n\\n\\t\\t\\t\\t\\t\\tuv.y = uv.y < 0 ? 0 : 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase MirroredRepeatWrapping:\\n\\n\\t\\t\\t\\t\\t\\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tuv.y = Math.ceil( uv.y ) - uv.y;\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tuv.y = uv.y - Math.floor( uv.y );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.flipY ) {\\n\\n\\t\\t\\t\\tuv.y = 1 - uv.y;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperty( Texture.prototype, \\\"needsUpdate\\\", {\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tif ( value === true ) this.version ++;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author supereggbert / http://www.paulbrunt.co.uk/\\n\\t * @author philogb / http://blog.thejit.org/\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author egraether / http://egraether.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction Vector4( x, y, z, w ) {\\n\\n\\t\\tthis.x = x || 0;\\n\\t\\tthis.y = y || 0;\\n\\t\\tthis.z = z || 0;\\n\\t\\tthis.w = ( w !== undefined ) ? w : 1;\\n\\n\\t}\\n\\n\\tObject.assign( Vector4.prototype, {\\n\\n\\t\\tisVector4: true,\\n\\n\\t\\tset: function ( x, y, z, w ) {\\n\\n\\t\\t\\tthis.x = x;\\n\\t\\t\\tthis.y = y;\\n\\t\\t\\tthis.z = z;\\n\\t\\t\\tthis.w = w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetScalar: function ( scalar ) {\\n\\n\\t\\t\\tthis.x = scalar;\\n\\t\\t\\tthis.y = scalar;\\n\\t\\t\\tthis.z = scalar;\\n\\t\\t\\tthis.w = scalar;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetX: function ( x ) {\\n\\n\\t\\t\\tthis.x = x;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetY: function ( y ) {\\n\\n\\t\\t\\tthis.y = y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetZ: function ( z ) {\\n\\n\\t\\t\\tthis.z = z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetW: function ( w ) {\\n\\n\\t\\t\\tthis.w = w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetComponent: function ( index, value ) {\\n\\n\\t\\t\\tswitch ( index ) {\\n\\n\\t\\t\\t\\tcase 0: this.x = value; break;\\n\\t\\t\\t\\tcase 1: this.y = value; break;\\n\\t\\t\\t\\tcase 2: this.z = value; break;\\n\\t\\t\\t\\tcase 3: this.w = value; break;\\n\\t\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetComponent: function ( index ) {\\n\\n\\t\\t\\tswitch ( index ) {\\n\\n\\t\\t\\t\\tcase 0: return this.x;\\n\\t\\t\\t\\tcase 1: return this.y;\\n\\t\\t\\t\\tcase 2: return this.z;\\n\\t\\t\\t\\tcase 3: return this.w;\\n\\t\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.x, this.y, this.z, this.w );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( v ) {\\n\\n\\t\\t\\tthis.x = v.x;\\n\\t\\t\\tthis.y = v.y;\\n\\t\\t\\tthis.z = v.z;\\n\\t\\t\\tthis.w = ( v.w !== undefined ) ? v.w : 1;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tadd: function ( v, w ) {\\n\\n\\t\\t\\tif ( w !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.addVectors( v, w );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x += v.x;\\n\\t\\t\\tthis.y += v.y;\\n\\t\\t\\tthis.z += v.z;\\n\\t\\t\\tthis.w += v.w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddScalar: function ( s ) {\\n\\n\\t\\t\\tthis.x += s;\\n\\t\\t\\tthis.y += s;\\n\\t\\t\\tthis.z += s;\\n\\t\\t\\tthis.w += s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddVectors: function ( a, b ) {\\n\\n\\t\\t\\tthis.x = a.x + b.x;\\n\\t\\t\\tthis.y = a.y + b.y;\\n\\t\\t\\tthis.z = a.z + b.z;\\n\\t\\t\\tthis.w = a.w + b.w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddScaledVector: function ( v, s ) {\\n\\n\\t\\t\\tthis.x += v.x * s;\\n\\t\\t\\tthis.y += v.y * s;\\n\\t\\t\\tthis.z += v.z * s;\\n\\t\\t\\tthis.w += v.w * s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsub: function ( v, w ) {\\n\\n\\t\\t\\tif ( w !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.subVectors( v, w );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x -= v.x;\\n\\t\\t\\tthis.y -= v.y;\\n\\t\\t\\tthis.z -= v.z;\\n\\t\\t\\tthis.w -= v.w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsubScalar: function ( s ) {\\n\\n\\t\\t\\tthis.x -= s;\\n\\t\\t\\tthis.y -= s;\\n\\t\\t\\tthis.z -= s;\\n\\t\\t\\tthis.w -= s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsubVectors: function ( a, b ) {\\n\\n\\t\\t\\tthis.x = a.x - b.x;\\n\\t\\t\\tthis.y = a.y - b.y;\\n\\t\\t\\tthis.z = a.z - b.z;\\n\\t\\t\\tthis.w = a.w - b.w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyScalar: function ( scalar ) {\\n\\n\\t\\t\\tthis.x *= scalar;\\n\\t\\t\\tthis.y *= scalar;\\n\\t\\t\\tthis.z *= scalar;\\n\\t\\t\\tthis.w *= scalar;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tapplyMatrix4: function ( m ) {\\n\\n\\t\\t\\tvar x = this.x, y = this.y, z = this.z, w = this.w;\\n\\t\\t\\tvar e = m.elements;\\n\\n\\t\\t\\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\\n\\t\\t\\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\\n\\t\\t\\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\\n\\t\\t\\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdivideScalar: function ( scalar ) {\\n\\n\\t\\t\\treturn this.multiplyScalar( 1 / scalar );\\n\\n\\t\\t},\\n\\n\\t\\tsetAxisAngleFromQuaternion: function ( q ) {\\n\\n\\t\\t\\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\\n\\n\\t\\t\\t// q is assumed to be normalized\\n\\n\\t\\t\\tthis.w = 2 * Math.acos( q.w );\\n\\n\\t\\t\\tvar s = Math.sqrt( 1 - q.w * q.w );\\n\\n\\t\\t\\tif ( s < 0.0001 ) {\\n\\n\\t\\t\\t\\tthis.x = 1;\\n\\t\\t\\t\\tthis.y = 0;\\n\\t\\t\\t\\tthis.z = 0;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.x = q.x / s;\\n\\t\\t\\t\\tthis.y = q.y / s;\\n\\t\\t\\t\\tthis.z = q.z / s;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetAxisAngleFromRotationMatrix: function ( m ) {\\n\\n\\t\\t\\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\\n\\n\\t\\t\\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\\n\\n\\t\\t\\tvar angle, x, y, z,\\t\\t// variables for result\\n\\t\\t\\t\\tepsilon = 0.01,\\t\\t// margin to allow for rounding errors\\n\\t\\t\\t\\tepsilon2 = 0.1,\\t\\t// margin to distinguish between 0 and 180 degrees\\n\\n\\t\\t\\t\\tte = m.elements,\\n\\n\\t\\t\\t\\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\\n\\t\\t\\t\\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\\n\\t\\t\\t\\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\\n\\n\\t\\t\\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\\n\\t\\t\\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\\n\\t\\t\\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\\n\\n\\t\\t\\t\\t// singularity found\\n\\t\\t\\t\\t// first check for identity matrix which must have +1 for all terms\\n\\t\\t\\t\\t// in leading diagonal and zero in other terms\\n\\n\\t\\t\\t\\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\\n\\t\\t\\t\\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\\n\\t\\t\\t\\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\\n\\t\\t\\t\\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\\n\\n\\t\\t\\t\\t\\t// this singularity is identity matrix so angle = 0\\n\\n\\t\\t\\t\\t\\tthis.set( 1, 0, 0, 0 );\\n\\n\\t\\t\\t\\t\\treturn this; // zero angle, arbitrary axis\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// otherwise this singularity is angle = 180\\n\\n\\t\\t\\t\\tangle = Math.PI;\\n\\n\\t\\t\\t\\tvar xx = ( m11 + 1 ) / 2;\\n\\t\\t\\t\\tvar yy = ( m22 + 1 ) / 2;\\n\\t\\t\\t\\tvar zz = ( m33 + 1 ) / 2;\\n\\t\\t\\t\\tvar xy = ( m12 + m21 ) / 4;\\n\\t\\t\\t\\tvar xz = ( m13 + m31 ) / 4;\\n\\t\\t\\t\\tvar yz = ( m23 + m32 ) / 4;\\n\\n\\t\\t\\t\\tif ( ( xx > yy ) && ( xx > zz ) ) {\\n\\n\\t\\t\\t\\t\\t// m11 is the largest diagonal term\\n\\n\\t\\t\\t\\t\\tif ( xx < epsilon ) {\\n\\n\\t\\t\\t\\t\\t\\tx = 0;\\n\\t\\t\\t\\t\\t\\ty = 0.707106781;\\n\\t\\t\\t\\t\\t\\tz = 0.707106781;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tx = Math.sqrt( xx );\\n\\t\\t\\t\\t\\t\\ty = xy / x;\\n\\t\\t\\t\\t\\t\\tz = xz / x;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( yy > zz ) {\\n\\n\\t\\t\\t\\t\\t// m22 is the largest diagonal term\\n\\n\\t\\t\\t\\t\\tif ( yy < epsilon ) {\\n\\n\\t\\t\\t\\t\\t\\tx = 0.707106781;\\n\\t\\t\\t\\t\\t\\ty = 0;\\n\\t\\t\\t\\t\\t\\tz = 0.707106781;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\ty = Math.sqrt( yy );\\n\\t\\t\\t\\t\\t\\tx = xy / y;\\n\\t\\t\\t\\t\\t\\tz = yz / y;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// m33 is the largest diagonal term so base result on this\\n\\n\\t\\t\\t\\t\\tif ( zz < epsilon ) {\\n\\n\\t\\t\\t\\t\\t\\tx = 0.707106781;\\n\\t\\t\\t\\t\\t\\ty = 0.707106781;\\n\\t\\t\\t\\t\\t\\tz = 0;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tz = Math.sqrt( zz );\\n\\t\\t\\t\\t\\t\\tx = xz / z;\\n\\t\\t\\t\\t\\t\\ty = yz / z;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.set( x, y, z, angle );\\n\\n\\t\\t\\t\\treturn this; // return 180 deg rotation\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// as we have reached here there are no singularities so we can handle normally\\n\\n\\t\\t\\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\\n\\t\\t\\t                   ( m13 - m31 ) * ( m13 - m31 ) +\\n\\t\\t\\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\\n\\n\\t\\t\\tif ( Math.abs( s ) < 0.001 ) s = 1;\\n\\n\\t\\t\\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\\n\\t\\t\\t// caught by singularity test above, but I've left it in just in case\\n\\n\\t\\t\\tthis.x = ( m32 - m23 ) / s;\\n\\t\\t\\tthis.y = ( m13 - m31 ) / s;\\n\\t\\t\\tthis.z = ( m21 - m12 ) / s;\\n\\t\\t\\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmin: function ( v ) {\\n\\n\\t\\t\\tthis.x = Math.min( this.x, v.x );\\n\\t\\t\\tthis.y = Math.min( this.y, v.y );\\n\\t\\t\\tthis.z = Math.min( this.z, v.z );\\n\\t\\t\\tthis.w = Math.min( this.w, v.w );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmax: function ( v ) {\\n\\n\\t\\t\\tthis.x = Math.max( this.x, v.x );\\n\\t\\t\\tthis.y = Math.max( this.y, v.y );\\n\\t\\t\\tthis.z = Math.max( this.z, v.z );\\n\\t\\t\\tthis.w = Math.max( this.w, v.w );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclamp: function ( min, max ) {\\n\\n\\t\\t\\t// assumes min < max, componentwise\\n\\n\\t\\t\\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\\n\\t\\t\\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\\n\\t\\t\\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\\n\\t\\t\\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclampScalar: function () {\\n\\n\\t\\t\\tvar min, max;\\n\\n\\t\\t\\treturn function clampScalar( minVal, maxVal ) {\\n\\n\\t\\t\\t\\tif ( min === undefined ) {\\n\\n\\t\\t\\t\\t\\tmin = new Vector4();\\n\\t\\t\\t\\t\\tmax = new Vector4();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tmin.set( minVal, minVal, minVal, minVal );\\n\\t\\t\\t\\tmax.set( maxVal, maxVal, maxVal, maxVal );\\n\\n\\t\\t\\t\\treturn this.clamp( min, max );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tclampLength: function ( min, max ) {\\n\\n\\t\\t\\tvar length = this.length();\\n\\n\\t\\t\\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\\n\\n\\t\\t},\\n\\n\\t\\tfloor: function () {\\n\\n\\t\\t\\tthis.x = Math.floor( this.x );\\n\\t\\t\\tthis.y = Math.floor( this.y );\\n\\t\\t\\tthis.z = Math.floor( this.z );\\n\\t\\t\\tthis.w = Math.floor( this.w );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tceil: function () {\\n\\n\\t\\t\\tthis.x = Math.ceil( this.x );\\n\\t\\t\\tthis.y = Math.ceil( this.y );\\n\\t\\t\\tthis.z = Math.ceil( this.z );\\n\\t\\t\\tthis.w = Math.ceil( this.w );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tround: function () {\\n\\n\\t\\t\\tthis.x = Math.round( this.x );\\n\\t\\t\\tthis.y = Math.round( this.y );\\n\\t\\t\\tthis.z = Math.round( this.z );\\n\\t\\t\\tthis.w = Math.round( this.w );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\troundToZero: function () {\\n\\n\\t\\t\\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\\n\\t\\t\\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\\n\\t\\t\\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\\n\\t\\t\\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tnegate: function () {\\n\\n\\t\\t\\tthis.x = - this.x;\\n\\t\\t\\tthis.y = - this.y;\\n\\t\\t\\tthis.z = - this.z;\\n\\t\\t\\tthis.w = - this.w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdot: function ( v ) {\\n\\n\\t\\t\\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\\n\\n\\t\\t},\\n\\n\\t\\tlengthSq: function () {\\n\\n\\t\\t\\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\\n\\n\\t\\t},\\n\\n\\t\\tlength: function () {\\n\\n\\t\\t\\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\\n\\n\\t\\t},\\n\\n\\t\\tmanhattanLength: function () {\\n\\n\\t\\t\\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\\n\\n\\t\\t},\\n\\n\\t\\tnormalize: function () {\\n\\n\\t\\t\\treturn this.divideScalar( this.length() || 1 );\\n\\n\\t\\t},\\n\\n\\t\\tsetLength: function ( length ) {\\n\\n\\t\\t\\treturn this.normalize().multiplyScalar( length );\\n\\n\\t\\t},\\n\\n\\t\\tlerp: function ( v, alpha ) {\\n\\n\\t\\t\\tthis.x += ( v.x - this.x ) * alpha;\\n\\t\\t\\tthis.y += ( v.y - this.y ) * alpha;\\n\\t\\t\\tthis.z += ( v.z - this.z ) * alpha;\\n\\t\\t\\tthis.w += ( v.w - this.w ) * alpha;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tlerpVectors: function ( v1, v2, alpha ) {\\n\\n\\t\\t\\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( v ) {\\n\\n\\t\\t\\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\\n\\n\\t\\t},\\n\\n\\t\\tfromArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tthis.x = array[ offset ];\\n\\t\\t\\tthis.y = array[ offset + 1 ];\\n\\t\\t\\tthis.z = array[ offset + 2 ];\\n\\t\\t\\tthis.w = array[ offset + 3 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( array === undefined ) array = [];\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tarray[ offset ] = this.x;\\n\\t\\t\\tarray[ offset + 1 ] = this.y;\\n\\t\\t\\tarray[ offset + 2 ] = this.z;\\n\\t\\t\\tarray[ offset + 3 ] = this.w;\\n\\n\\t\\t\\treturn array;\\n\\n\\t\\t},\\n\\n\\t\\tfromBufferAttribute: function ( attribute, index, offset ) {\\n\\n\\t\\t\\tif ( offset !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x = attribute.getX( index );\\n\\t\\t\\tthis.y = attribute.getY( index );\\n\\t\\t\\tthis.z = attribute.getZ( index );\\n\\t\\t\\tthis.w = attribute.getW( index );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author szimek / https://github.com/szimek/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author Marius Kintel / https://github.com/kintel\\n\\t */\\n\\n\\t/*\\n\\t In options, we can specify:\\n\\t * Texture parameters for an auto-generated target texture\\n\\t * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\\n\\t*/\\n\\tfunction WebGLRenderTarget( width, height, options ) {\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\tthis.width = width;\\n\\t\\tthis.height = height;\\n\\n\\t\\tthis.scissor = new Vector4( 0, 0, width, height );\\n\\t\\tthis.scissorTest = false;\\n\\n\\t\\tthis.viewport = new Vector4( 0, 0, width, height );\\n\\n\\t\\toptions = options || {};\\n\\n\\t\\tif ( options.minFilter === undefined ) options.minFilter = LinearFilter;\\n\\n\\t\\tthis.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\\n\\n\\t\\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\\n\\t\\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\\n\\t\\tthis.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;\\n\\n\\t}\\n\\n\\tWebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\n\\n\\t\\tconstructor: WebGLRenderTarget,\\n\\n\\t\\tisWebGLRenderTarget: true,\\n\\n\\t\\tsetSize: function ( width, height ) {\\n\\n\\t\\t\\tif ( this.width !== width || this.height !== height ) {\\n\\n\\t\\t\\t\\tthis.width = width;\\n\\t\\t\\t\\tthis.height = height;\\n\\n\\t\\t\\t\\tthis.dispose();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.viewport.set( 0, 0, width, height );\\n\\t\\t\\tthis.scissor.set( 0, 0, width, height );\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tthis.width = source.width;\\n\\t\\t\\tthis.height = source.height;\\n\\n\\t\\t\\tthis.viewport.copy( source.viewport );\\n\\n\\t\\t\\tthis.texture = source.texture.clone();\\n\\n\\t\\t\\tthis.depthBuffer = source.depthBuffer;\\n\\t\\t\\tthis.stencilBuffer = source.stencilBuffer;\\n\\t\\t\\tthis.depthTexture = source.depthTexture;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdispose: function () {\\n\\n\\t\\t\\tthis.dispatchEvent( { type: 'dispose' } );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com\\n\\t */\\n\\n\\tfunction WebGLRenderTargetCube( width, height, options ) {\\n\\n\\t\\tWebGLRenderTarget.call( this, width, height, options );\\n\\n\\t\\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\\n\\t\\tthis.activeMipMapLevel = 0;\\n\\n\\t}\\n\\n\\tWebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );\\n\\tWebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;\\n\\n\\tWebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\\n\\n\\t\\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\\n\\n\\t\\tthis.image = { data: data, width: width, height: height };\\n\\n\\t\\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\\n\\t\\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\\n\\n\\t\\tthis.generateMipmaps = false;\\n\\t\\tthis.flipY = false;\\n\\t\\tthis.unpackAlignment = 1;\\n\\n\\t}\\n\\n\\tDataTexture.prototype = Object.create( Texture.prototype );\\n\\tDataTexture.prototype.constructor = DataTexture;\\n\\n\\tDataTexture.prototype.isDataTexture = true;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\\n\\n\\t\\timages = images !== undefined ? images : [];\\n\\t\\tmapping = mapping !== undefined ? mapping : CubeReflectionMapping;\\n\\n\\t\\tTexture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\\n\\n\\t\\tthis.flipY = false;\\n\\n\\t}\\n\\n\\tCubeTexture.prototype = Object.create( Texture.prototype );\\n\\tCubeTexture.prototype.constructor = CubeTexture;\\n\\n\\tCubeTexture.prototype.isCubeTexture = true;\\n\\n\\tObject.defineProperty( CubeTexture.prototype, 'images', {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\treturn this.image;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tthis.image = value;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author tschw\\n\\t *\\n\\t * Uniforms of a program.\\n\\t * Those form a tree structure with a special top-level container for the root,\\n\\t * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.\\n\\t *\\n\\t *\\n\\t * Properties of inner nodes including the top-level container:\\n\\t *\\n\\t * .seq - array of nested uniforms\\n\\t * .map - nested uniforms by name\\n\\t *\\n\\t *\\n\\t * Methods of all nodes except the top-level container:\\n\\t *\\n\\t * .setValue( gl, value, [renderer] )\\n\\t *\\n\\t * \\t\\tuploads a uniform value(s)\\n\\t *  \\tthe 'renderer' parameter is needed for sampler uniforms\\n\\t *\\n\\t *\\n\\t * Static methods of the top-level container (renderer factorizations):\\n\\t *\\n\\t * .upload( gl, seq, values, renderer )\\n\\t *\\n\\t * \\t\\tsets uniforms in 'seq' to 'values[id].value'\\n\\t *\\n\\t * .seqWithValue( seq, values ) : filteredSeq\\n\\t *\\n\\t * \\t\\tfilters 'seq' entries with corresponding entry in values\\n\\t *\\n\\t *\\n\\t * Methods of the top-level container (renderer factorizations):\\n\\t *\\n\\t * .setValue( gl, name, value )\\n\\t *\\n\\t * \\t\\tsets uniform with  name 'name' to 'value'\\n\\t *\\n\\t * .set( gl, obj, prop )\\n\\t *\\n\\t * \\t\\tsets uniform from object and property with same name than uniform\\n\\t *\\n\\t * .setOptional( gl, obj, prop )\\n\\t *\\n\\t * \\t\\tlike .set for an optional property of the object\\n\\t *\\n\\t */\\n\\n\\tvar emptyTexture = new Texture();\\n\\tvar emptyCubeTexture = new CubeTexture();\\n\\n\\t// --- Base for inner nodes (including the root) ---\\n\\n\\tfunction UniformContainer() {\\n\\n\\t\\tthis.seq = [];\\n\\t\\tthis.map = {};\\n\\n\\t}\\n\\n\\t// --- Utilities ---\\n\\n\\t// Array Caches (provide typed arrays for temporary by size)\\n\\n\\tvar arrayCacheF32 = [];\\n\\tvar arrayCacheI32 = [];\\n\\n\\t// Float32Array caches used for uploading Matrix uniforms\\n\\n\\tvar mat4array = new Float32Array( 16 );\\n\\tvar mat3array = new Float32Array( 9 );\\n\\n\\t// Flattening for arrays of vectors and matrices\\n\\n\\tfunction flatten( array, nBlocks, blockSize ) {\\n\\n\\t\\tvar firstElem = array[ 0 ];\\n\\n\\t\\tif ( firstElem <= 0 || firstElem > 0 ) return array;\\n\\t\\t// unoptimized: ! isNaN( firstElem )\\n\\t\\t// see http://jacksondunstan.com/articles/983\\n\\n\\t\\tvar n = nBlocks * blockSize,\\n\\t\\t\\tr = arrayCacheF32[ n ];\\n\\n\\t\\tif ( r === undefined ) {\\n\\n\\t\\t\\tr = new Float32Array( n );\\n\\t\\t\\tarrayCacheF32[ n ] = r;\\n\\n\\t\\t}\\n\\n\\t\\tif ( nBlocks !== 0 ) {\\n\\n\\t\\t\\tfirstElem.toArray( r, 0 );\\n\\n\\t\\t\\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\\n\\n\\t\\t\\t\\toffset += blockSize;\\n\\t\\t\\t\\tarray[ i ].toArray( r, offset );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn r;\\n\\n\\t}\\n\\n\\t// Texture unit allocation\\n\\n\\tfunction allocTexUnits( renderer, n ) {\\n\\n\\t\\tvar r = arrayCacheI32[ n ];\\n\\n\\t\\tif ( r === undefined ) {\\n\\n\\t\\t\\tr = new Int32Array( n );\\n\\t\\t\\tarrayCacheI32[ n ] = r;\\n\\n\\t\\t}\\n\\n\\t\\tfor ( var i = 0; i !== n; ++ i )\\n\\t\\t\\tr[ i ] = renderer.allocTextureUnit();\\n\\n\\t\\treturn r;\\n\\n\\t}\\n\\n\\t// --- Setters ---\\n\\n\\t// Note: Defining these methods externally, because they come in a bunch\\n\\t// and this way their names minify.\\n\\n\\t// Single scalar\\n\\n\\tfunction setValue1f( gl, v ) {\\n\\n\\t\\tgl.uniform1f( this.addr, v );\\n\\n\\t}\\n\\n\\tfunction setValue1i( gl, v ) {\\n\\n\\t\\tgl.uniform1i( this.addr, v );\\n\\n\\t}\\n\\n\\t// Single float vector (from flat array or THREE.VectorN)\\n\\n\\tfunction setValue2fv( gl, v ) {\\n\\n\\t\\tif ( v.x === undefined ) {\\n\\n\\t\\t\\tgl.uniform2fv( this.addr, v );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tgl.uniform2f( this.addr, v.x, v.y );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction setValue3fv( gl, v ) {\\n\\n\\t\\tif ( v.x !== undefined ) {\\n\\n\\t\\t\\tgl.uniform3f( this.addr, v.x, v.y, v.z );\\n\\n\\t\\t} else if ( v.r !== undefined ) {\\n\\n\\t\\t\\tgl.uniform3f( this.addr, v.r, v.g, v.b );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tgl.uniform3fv( this.addr, v );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction setValue4fv( gl, v ) {\\n\\n\\t\\tif ( v.x === undefined ) {\\n\\n\\t\\t\\tgl.uniform4fv( this.addr, v );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// Single matrix (from flat array or MatrixN)\\n\\n\\tfunction setValue2fm( gl, v ) {\\n\\n\\t\\tgl.uniformMatrix2fv( this.addr, false, v.elements || v );\\n\\n\\t}\\n\\n\\tfunction setValue3fm( gl, v ) {\\n\\n\\t\\tif ( v.elements === undefined ) {\\n\\n\\t\\t\\tgl.uniformMatrix3fv( this.addr, false, v );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tmat3array.set( v.elements );\\n\\t\\t\\tgl.uniformMatrix3fv( this.addr, false, mat3array );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction setValue4fm( gl, v ) {\\n\\n\\t\\tif ( v.elements === undefined ) {\\n\\n\\t\\t\\tgl.uniformMatrix4fv( this.addr, false, v );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tmat4array.set( v.elements );\\n\\t\\t\\tgl.uniformMatrix4fv( this.addr, false, mat4array );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// Single texture (2D / Cube)\\n\\n\\tfunction setValueT1( gl, v, renderer ) {\\n\\n\\t\\tvar unit = renderer.allocTextureUnit();\\n\\t\\tgl.uniform1i( this.addr, unit );\\n\\t\\trenderer.setTexture2D( v || emptyTexture, unit );\\n\\n\\t}\\n\\n\\tfunction setValueT6( gl, v, renderer ) {\\n\\n\\t\\tvar unit = renderer.allocTextureUnit();\\n\\t\\tgl.uniform1i( this.addr, unit );\\n\\t\\trenderer.setTextureCube( v || emptyCubeTexture, unit );\\n\\n\\t}\\n\\n\\t// Integer / Boolean vectors or arrays thereof (always flat arrays)\\n\\n\\tfunction setValue2iv( gl, v ) {\\n\\n\\t\\tgl.uniform2iv( this.addr, v );\\n\\n\\t}\\n\\n\\tfunction setValue3iv( gl, v ) {\\n\\n\\t\\tgl.uniform3iv( this.addr, v );\\n\\n\\t}\\n\\n\\tfunction setValue4iv( gl, v ) {\\n\\n\\t\\tgl.uniform4iv( this.addr, v );\\n\\n\\t}\\n\\n\\t// Helper to pick the right setter for the singular case\\n\\n\\tfunction getSingularSetter( type ) {\\n\\n\\t\\tswitch ( type ) {\\n\\n\\t\\t\\tcase 0x1406: return setValue1f; // FLOAT\\n\\t\\t\\tcase 0x8b50: return setValue2fv; // _VEC2\\n\\t\\t\\tcase 0x8b51: return setValue3fv; // _VEC3\\n\\t\\t\\tcase 0x8b52: return setValue4fv; // _VEC4\\n\\n\\t\\t\\tcase 0x8b5a: return setValue2fm; // _MAT2\\n\\t\\t\\tcase 0x8b5b: return setValue3fm; // _MAT3\\n\\t\\t\\tcase 0x8b5c: return setValue4fm; // _MAT4\\n\\n\\t\\t\\tcase 0x8b5e: case 0x8d66: return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES\\n\\t\\t\\tcase 0x8b60: return setValueT6; // SAMPLER_CUBE\\n\\n\\t\\t\\tcase 0x1404: case 0x8b56: return setValue1i; // INT, BOOL\\n\\t\\t\\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\\n\\t\\t\\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\\n\\t\\t\\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// Array of scalars\\n\\n\\tfunction setValue1fv( gl, v ) {\\n\\n\\t\\tgl.uniform1fv( this.addr, v );\\n\\n\\t}\\n\\tfunction setValue1iv( gl, v ) {\\n\\n\\t\\tgl.uniform1iv( this.addr, v );\\n\\n\\t}\\n\\n\\t// Array of vectors (flat or from THREE classes)\\n\\n\\tfunction setValueV2a( gl, v ) {\\n\\n\\t\\tgl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );\\n\\n\\t}\\n\\n\\tfunction setValueV3a( gl, v ) {\\n\\n\\t\\tgl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );\\n\\n\\t}\\n\\n\\tfunction setValueV4a( gl, v ) {\\n\\n\\t\\tgl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );\\n\\n\\t}\\n\\n\\t// Array of matrices (flat or from THREE clases)\\n\\n\\tfunction setValueM2a( gl, v ) {\\n\\n\\t\\tgl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );\\n\\n\\t}\\n\\n\\tfunction setValueM3a( gl, v ) {\\n\\n\\t\\tgl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );\\n\\n\\t}\\n\\n\\tfunction setValueM4a( gl, v ) {\\n\\n\\t\\tgl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );\\n\\n\\t}\\n\\n\\t// Array of textures (2D / Cube)\\n\\n\\tfunction setValueT1a( gl, v, renderer ) {\\n\\n\\t\\tvar n = v.length,\\n\\t\\t\\tunits = allocTexUnits( renderer, n );\\n\\n\\t\\tgl.uniform1iv( this.addr, units );\\n\\n\\t\\tfor ( var i = 0; i !== n; ++ i ) {\\n\\n\\t\\t\\trenderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction setValueT6a( gl, v, renderer ) {\\n\\n\\t\\tvar n = v.length,\\n\\t\\t\\tunits = allocTexUnits( renderer, n );\\n\\n\\t\\tgl.uniform1iv( this.addr, units );\\n\\n\\t\\tfor ( var i = 0; i !== n; ++ i ) {\\n\\n\\t\\t\\trenderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// Helper to pick the right setter for a pure (bottom-level) array\\n\\n\\tfunction getPureArraySetter( type ) {\\n\\n\\t\\tswitch ( type ) {\\n\\n\\t\\t\\tcase 0x1406: return setValue1fv; // FLOAT\\n\\t\\t\\tcase 0x8b50: return setValueV2a; // _VEC2\\n\\t\\t\\tcase 0x8b51: return setValueV3a; // _VEC3\\n\\t\\t\\tcase 0x8b52: return setValueV4a; // _VEC4\\n\\n\\t\\t\\tcase 0x8b5a: return setValueM2a; // _MAT2\\n\\t\\t\\tcase 0x8b5b: return setValueM3a; // _MAT3\\n\\t\\t\\tcase 0x8b5c: return setValueM4a; // _MAT4\\n\\n\\t\\t\\tcase 0x8b5e: return setValueT1a; // SAMPLER_2D\\n\\t\\t\\tcase 0x8b60: return setValueT6a; // SAMPLER_CUBE\\n\\n\\t\\t\\tcase 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL\\n\\t\\t\\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\\n\\t\\t\\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\\n\\t\\t\\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// --- Uniform Classes ---\\n\\n\\tfunction SingleUniform( id, activeInfo, addr ) {\\n\\n\\t\\tthis.id = id;\\n\\t\\tthis.addr = addr;\\n\\t\\tthis.setValue = getSingularSetter( activeInfo.type );\\n\\n\\t\\t// this.path = activeInfo.name; // DEBUG\\n\\n\\t}\\n\\n\\tfunction PureArrayUniform( id, activeInfo, addr ) {\\n\\n\\t\\tthis.id = id;\\n\\t\\tthis.addr = addr;\\n\\t\\tthis.size = activeInfo.size;\\n\\t\\tthis.setValue = getPureArraySetter( activeInfo.type );\\n\\n\\t\\t// this.path = activeInfo.name; // DEBUG\\n\\n\\t}\\n\\n\\tfunction StructuredUniform( id ) {\\n\\n\\t\\tthis.id = id;\\n\\n\\t\\tUniformContainer.call( this ); // mix-in\\n\\n\\t}\\n\\n\\tStructuredUniform.prototype.setValue = function ( gl, value ) {\\n\\n\\t\\t// Note: Don't need an extra 'renderer' parameter, since samplers\\n\\t\\t// are not allowed in structured uniforms.\\n\\n\\t\\tvar seq = this.seq;\\n\\n\\t\\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\\n\\n\\t\\t\\tvar u = seq[ i ];\\n\\t\\t\\tu.setValue( gl, value[ u.id ] );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t// --- Top-level ---\\n\\n\\t// Parser - builds up the property tree from the path strings\\n\\n\\tvar RePathPart = /([\\\\w\\\\d_]+)(\\\\])?(\\\\[|\\\\.)?/g;\\n\\n\\t// extracts\\n\\t// \\t- the identifier (member name or array index)\\n\\t//  - followed by an optional right bracket (found when array index)\\n\\t//  - followed by an optional left bracket or dot (type of subscript)\\n\\t//\\n\\t// Note: These portions can be read in a non-overlapping fashion and\\n\\t// allow straightforward parsing of the hierarchy that WebGL encodes\\n\\t// in the uniform names.\\n\\n\\tfunction addUniform( container, uniformObject ) {\\n\\n\\t\\tcontainer.seq.push( uniformObject );\\n\\t\\tcontainer.map[ uniformObject.id ] = uniformObject;\\n\\n\\t}\\n\\n\\tfunction parseUniform( activeInfo, addr, container ) {\\n\\n\\t\\tvar path = activeInfo.name,\\n\\t\\t\\tpathLength = path.length;\\n\\n\\t\\t// reset RegExp object, because of the early exit of a previous run\\n\\t\\tRePathPart.lastIndex = 0;\\n\\n\\t\\tfor ( ; ; ) {\\n\\n\\t\\t\\tvar match = RePathPart.exec( path ),\\n\\t\\t\\t\\tmatchEnd = RePathPart.lastIndex,\\n\\n\\t\\t\\t\\tid = match[ 1 ],\\n\\t\\t\\t\\tidIsIndex = match[ 2 ] === ']',\\n\\t\\t\\t\\tsubscript = match[ 3 ];\\n\\n\\t\\t\\tif ( idIsIndex ) id = id | 0; // convert to integer\\n\\n\\t\\t\\tif ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {\\n\\n\\t\\t\\t\\t// bare name or \\\"pure\\\" bottom-level array \\\"[0]\\\" suffix\\n\\n\\t\\t\\t\\taddUniform( container, subscript === undefined ?\\n\\t\\t\\t\\t\\tnew SingleUniform( id, activeInfo, addr ) :\\n\\t\\t\\t\\t\\tnew PureArrayUniform( id, activeInfo, addr ) );\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// step into inner node / create it in case it doesn't exist\\n\\n\\t\\t\\t\\tvar map = container.map, next = map[ id ];\\n\\n\\t\\t\\t\\tif ( next === undefined ) {\\n\\n\\t\\t\\t\\t\\tnext = new StructuredUniform( id );\\n\\t\\t\\t\\t\\taddUniform( container, next );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcontainer = next;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// Root Container\\n\\n\\tfunction WebGLUniforms( gl, program, renderer ) {\\n\\n\\t\\tUniformContainer.call( this );\\n\\n\\t\\tthis.renderer = renderer;\\n\\n\\t\\tvar n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\\n\\n\\t\\tfor ( var i = 0; i < n; ++ i ) {\\n\\n\\t\\t\\tvar info = gl.getActiveUniform( program, i ),\\n\\t\\t\\t\\tpath = info.name,\\n\\t\\t\\t\\taddr = gl.getUniformLocation( program, path );\\n\\n\\t\\t\\tparseUniform( info, addr, this );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tWebGLUniforms.prototype.setValue = function ( gl, name, value ) {\\n\\n\\t\\tvar u = this.map[ name ];\\n\\n\\t\\tif ( u !== undefined ) u.setValue( gl, value, this.renderer );\\n\\n\\t};\\n\\n\\tWebGLUniforms.prototype.setOptional = function ( gl, object, name ) {\\n\\n\\t\\tvar v = object[ name ];\\n\\n\\t\\tif ( v !== undefined ) this.setValue( gl, name, v );\\n\\n\\t};\\n\\n\\n\\t// Static interface\\n\\n\\tWebGLUniforms.upload = function ( gl, seq, values, renderer ) {\\n\\n\\t\\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\\n\\n\\t\\t\\tvar u = seq[ i ],\\n\\t\\t\\t\\tv = values[ u.id ];\\n\\n\\t\\t\\tif ( v.needsUpdate !== false ) {\\n\\n\\t\\t\\t\\t// note: always updating when .needsUpdate is undefined\\n\\t\\t\\t\\tu.setValue( gl, v.value, renderer );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tWebGLUniforms.seqWithValue = function ( seq, values ) {\\n\\n\\t\\tvar r = [];\\n\\n\\t\\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\\n\\n\\t\\t\\tvar u = seq[ i ];\\n\\t\\t\\tif ( u.id in values ) r.push( u );\\n\\n\\t\\t}\\n\\n\\t\\treturn r;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tvar ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\\n\\t\\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\\n\\t\\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\\n\\t\\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\\n\\t\\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\\n\\t\\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\\n\\t\\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\\n\\t\\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\\n\\t\\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\\n\\t\\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\\n\\t\\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\\n\\t\\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\\n\\t\\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\\n\\t\\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\\n\\t\\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\\n\\t\\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\\n\\t\\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\\n\\t\\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\\n\\t\\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\\n\\t\\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\\n\\t\\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\\n\\t\\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\\n\\t\\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\\n\\t\\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\\n\\n\\tfunction Color( r, g, b ) {\\n\\n\\t\\tif ( g === undefined && b === undefined ) {\\n\\n\\t\\t\\t// r is THREE.Color, hex or string\\n\\t\\t\\treturn this.set( r );\\n\\n\\t\\t}\\n\\n\\t\\treturn this.setRGB( r, g, b );\\n\\n\\t}\\n\\n\\tObject.assign( Color.prototype, {\\n\\n\\t\\tisColor: true,\\n\\n\\t\\tr: 1, g: 1, b: 1,\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tif ( value && value.isColor ) {\\n\\n\\t\\t\\t\\tthis.copy( value );\\n\\n\\t\\t\\t} else if ( typeof value === 'number' ) {\\n\\n\\t\\t\\t\\tthis.setHex( value );\\n\\n\\t\\t\\t} else if ( typeof value === 'string' ) {\\n\\n\\t\\t\\t\\tthis.setStyle( value );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetScalar: function ( scalar ) {\\n\\n\\t\\t\\tthis.r = scalar;\\n\\t\\t\\tthis.g = scalar;\\n\\t\\t\\tthis.b = scalar;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetHex: function ( hex ) {\\n\\n\\t\\t\\thex = Math.floor( hex );\\n\\n\\t\\t\\tthis.r = ( hex >> 16 & 255 ) / 255;\\n\\t\\t\\tthis.g = ( hex >> 8 & 255 ) / 255;\\n\\t\\t\\tthis.b = ( hex & 255 ) / 255;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetRGB: function ( r, g, b ) {\\n\\n\\t\\t\\tthis.r = r;\\n\\t\\t\\tthis.g = g;\\n\\t\\t\\tthis.b = b;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetHSL: function () {\\n\\n\\t\\t\\tfunction hue2rgb( p, q, t ) {\\n\\n\\t\\t\\t\\tif ( t < 0 ) t += 1;\\n\\t\\t\\t\\tif ( t > 1 ) t -= 1;\\n\\t\\t\\t\\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\\n\\t\\t\\t\\tif ( t < 1 / 2 ) return q;\\n\\t\\t\\t\\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\\n\\t\\t\\t\\treturn p;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn function setHSL( h, s, l ) {\\n\\n\\t\\t\\t\\t// h,s,l ranges are in 0.0 - 1.0\\n\\t\\t\\t\\th = _Math.euclideanModulo( h, 1 );\\n\\t\\t\\t\\ts = _Math.clamp( s, 0, 1 );\\n\\t\\t\\t\\tl = _Math.clamp( l, 0, 1 );\\n\\n\\t\\t\\t\\tif ( s === 0 ) {\\n\\n\\t\\t\\t\\t\\tthis.r = this.g = this.b = l;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\\n\\t\\t\\t\\t\\tvar q = ( 2 * l ) - p;\\n\\n\\t\\t\\t\\t\\tthis.r = hue2rgb( q, p, h + 1 / 3 );\\n\\t\\t\\t\\t\\tthis.g = hue2rgb( q, p, h );\\n\\t\\t\\t\\t\\tthis.b = hue2rgb( q, p, h - 1 / 3 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tsetStyle: function ( style ) {\\n\\n\\t\\t\\tfunction handleAlpha( string ) {\\n\\n\\t\\t\\t\\tif ( string === undefined ) return;\\n\\n\\t\\t\\t\\tif ( parseFloat( string ) < 1 ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\tvar m;\\n\\n\\t\\t\\tif ( m = /^((?:rgb|hsl)a?)\\\\(\\\\s*([^\\\\)]*)\\\\)/.exec( style ) ) {\\n\\n\\t\\t\\t\\t// rgb / hsl\\n\\n\\t\\t\\t\\tvar color;\\n\\t\\t\\t\\tvar name = m[ 1 ];\\n\\t\\t\\t\\tvar components = m[ 2 ];\\n\\n\\t\\t\\t\\tswitch ( name ) {\\n\\n\\t\\t\\t\\t\\tcase 'rgb':\\n\\t\\t\\t\\t\\tcase 'rgba':\\n\\n\\t\\t\\t\\t\\t\\tif ( color = /^(\\\\d+)\\\\s*,\\\\s*(\\\\d+)\\\\s*,\\\\s*(\\\\d+)\\\\s*(,\\\\s*([0-9]*\\\\.?[0-9]+)\\\\s*)?$/.exec( components ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// rgb(255,0,0) rgba(255,0,0,0.5)\\n\\t\\t\\t\\t\\t\\t\\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\\n\\t\\t\\t\\t\\t\\t\\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\\n\\t\\t\\t\\t\\t\\t\\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\\n\\n\\t\\t\\t\\t\\t\\t\\thandleAlpha( color[ 5 ] );\\n\\n\\t\\t\\t\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif ( color = /^(\\\\d+)\\\\%\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\s*(,\\\\s*([0-9]*\\\\.?[0-9]+)\\\\s*)?$/.exec( components ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\\n\\t\\t\\t\\t\\t\\t\\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\\n\\t\\t\\t\\t\\t\\t\\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\\n\\t\\t\\t\\t\\t\\t\\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\\n\\n\\t\\t\\t\\t\\t\\t\\thandleAlpha( color[ 5 ] );\\n\\n\\t\\t\\t\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'hsl':\\n\\t\\t\\t\\t\\tcase 'hsla':\\n\\n\\t\\t\\t\\t\\t\\tif ( color = /^([0-9]*\\\\.?[0-9]+)\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\s*(,\\\\s*([0-9]*\\\\.?[0-9]+)\\\\s*)?$/.exec( components ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\\n\\t\\t\\t\\t\\t\\t\\tvar h = parseFloat( color[ 1 ] ) / 360;\\n\\t\\t\\t\\t\\t\\t\\tvar s = parseInt( color[ 2 ], 10 ) / 100;\\n\\t\\t\\t\\t\\t\\t\\tvar l = parseInt( color[ 3 ], 10 ) / 100;\\n\\n\\t\\t\\t\\t\\t\\t\\thandleAlpha( color[ 5 ] );\\n\\n\\t\\t\\t\\t\\t\\t\\treturn this.setHSL( h, s, l );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( m = /^\\\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\\n\\n\\t\\t\\t\\t// hex color\\n\\n\\t\\t\\t\\tvar hex = m[ 1 ];\\n\\t\\t\\t\\tvar size = hex.length;\\n\\n\\t\\t\\t\\tif ( size === 3 ) {\\n\\n\\t\\t\\t\\t\\t// #ff0\\n\\t\\t\\t\\t\\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\\n\\t\\t\\t\\t\\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\\n\\t\\t\\t\\t\\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\\n\\n\\t\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t\\t} else if ( size === 6 ) {\\n\\n\\t\\t\\t\\t\\t// #ff0000\\n\\t\\t\\t\\t\\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\\n\\t\\t\\t\\t\\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\\n\\t\\t\\t\\t\\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\\n\\n\\t\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( style && style.length > 0 ) {\\n\\n\\t\\t\\t\\t// color keywords\\n\\t\\t\\t\\tvar hex = ColorKeywords[ style ];\\n\\n\\t\\t\\t\\tif ( hex !== undefined ) {\\n\\n\\t\\t\\t\\t\\t// red\\n\\t\\t\\t\\t\\tthis.setHex( hex );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// unknown color\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.Color: Unknown color ' + style );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.r, this.g, this.b );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( color ) {\\n\\n\\t\\t\\tthis.r = color.r;\\n\\t\\t\\tthis.g = color.g;\\n\\t\\t\\tthis.b = color.b;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyGammaToLinear: function ( color, gammaFactor ) {\\n\\n\\t\\t\\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\\n\\n\\t\\t\\tthis.r = Math.pow( color.r, gammaFactor );\\n\\t\\t\\tthis.g = Math.pow( color.g, gammaFactor );\\n\\t\\t\\tthis.b = Math.pow( color.b, gammaFactor );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyLinearToGamma: function ( color, gammaFactor ) {\\n\\n\\t\\t\\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\\n\\n\\t\\t\\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\\n\\n\\t\\t\\tthis.r = Math.pow( color.r, safeInverse );\\n\\t\\t\\tthis.g = Math.pow( color.g, safeInverse );\\n\\t\\t\\tthis.b = Math.pow( color.b, safeInverse );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tconvertGammaToLinear: function () {\\n\\n\\t\\t\\tvar r = this.r, g = this.g, b = this.b;\\n\\n\\t\\t\\tthis.r = r * r;\\n\\t\\t\\tthis.g = g * g;\\n\\t\\t\\tthis.b = b * b;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tconvertLinearToGamma: function () {\\n\\n\\t\\t\\tthis.r = Math.sqrt( this.r );\\n\\t\\t\\tthis.g = Math.sqrt( this.g );\\n\\t\\t\\tthis.b = Math.sqrt( this.b );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetHex: function () {\\n\\n\\t\\t\\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\\n\\n\\t\\t},\\n\\n\\t\\tgetHexString: function () {\\n\\n\\t\\t\\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\\n\\n\\t\\t},\\n\\n\\t\\tgetHSL: function ( optionalTarget ) {\\n\\n\\t\\t\\t// h,s,l ranges are in 0.0 - 1.0\\n\\n\\t\\t\\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\\n\\n\\t\\t\\tvar r = this.r, g = this.g, b = this.b;\\n\\n\\t\\t\\tvar max = Math.max( r, g, b );\\n\\t\\t\\tvar min = Math.min( r, g, b );\\n\\n\\t\\t\\tvar hue, saturation;\\n\\t\\t\\tvar lightness = ( min + max ) / 2.0;\\n\\n\\t\\t\\tif ( min === max ) {\\n\\n\\t\\t\\t\\thue = 0;\\n\\t\\t\\t\\tsaturation = 0;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tvar delta = max - min;\\n\\n\\t\\t\\t\\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\\n\\n\\t\\t\\t\\tswitch ( max ) {\\n\\n\\t\\t\\t\\t\\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\\n\\t\\t\\t\\t\\tcase g: hue = ( b - r ) / delta + 2; break;\\n\\t\\t\\t\\t\\tcase b: hue = ( r - g ) / delta + 4; break;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\thue /= 6;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\thsl.h = hue;\\n\\t\\t\\thsl.s = saturation;\\n\\t\\t\\thsl.l = lightness;\\n\\n\\t\\t\\treturn hsl;\\n\\n\\t\\t},\\n\\n\\t\\tgetStyle: function () {\\n\\n\\t\\t\\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\\n\\n\\t\\t},\\n\\n\\t\\toffsetHSL: function ( h, s, l ) {\\n\\n\\t\\t\\tvar hsl = this.getHSL();\\n\\n\\t\\t\\thsl.h += h; hsl.s += s; hsl.l += l;\\n\\n\\t\\t\\tthis.setHSL( hsl.h, hsl.s, hsl.l );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tadd: function ( color ) {\\n\\n\\t\\t\\tthis.r += color.r;\\n\\t\\t\\tthis.g += color.g;\\n\\t\\t\\tthis.b += color.b;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddColors: function ( color1, color2 ) {\\n\\n\\t\\t\\tthis.r = color1.r + color2.r;\\n\\t\\t\\tthis.g = color1.g + color2.g;\\n\\t\\t\\tthis.b = color1.b + color2.b;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddScalar: function ( s ) {\\n\\n\\t\\t\\tthis.r += s;\\n\\t\\t\\tthis.g += s;\\n\\t\\t\\tthis.b += s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsub: function ( color ) {\\n\\n\\t\\t\\tthis.r = Math.max( 0, this.r - color.r );\\n\\t\\t\\tthis.g = Math.max( 0, this.g - color.g );\\n\\t\\t\\tthis.b = Math.max( 0, this.b - color.b );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiply: function ( color ) {\\n\\n\\t\\t\\tthis.r *= color.r;\\n\\t\\t\\tthis.g *= color.g;\\n\\t\\t\\tthis.b *= color.b;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyScalar: function ( s ) {\\n\\n\\t\\t\\tthis.r *= s;\\n\\t\\t\\tthis.g *= s;\\n\\t\\t\\tthis.b *= s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tlerp: function ( color, alpha ) {\\n\\n\\t\\t\\tthis.r += ( color.r - this.r ) * alpha;\\n\\t\\t\\tthis.g += ( color.g - this.g ) * alpha;\\n\\t\\t\\tthis.b += ( color.b - this.b ) * alpha;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( c ) {\\n\\n\\t\\t\\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\\n\\n\\t\\t},\\n\\n\\t\\tfromArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tthis.r = array[ offset ];\\n\\t\\t\\tthis.g = array[ offset + 1 ];\\n\\t\\t\\tthis.b = array[ offset + 2 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( array === undefined ) array = [];\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tarray[ offset ] = this.r;\\n\\t\\t\\tarray[ offset + 1 ] = this.g;\\n\\t\\t\\tarray[ offset + 2 ] = this.b;\\n\\n\\t\\t\\treturn array;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function () {\\n\\n\\t\\t\\treturn this.getHex();\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * Uniforms library for shared webgl shaders\\n\\t */\\n\\n\\tvar UniformsLib = {\\n\\n\\t\\tcommon: {\\n\\n\\t\\t\\tdiffuse: { value: new Color( 0xeeeeee ) },\\n\\t\\t\\topacity: { value: 1.0 },\\n\\n\\t\\t\\tmap: { value: null },\\n\\t\\t\\tuvTransform: { value: new Matrix3() },\\n\\n\\t\\t\\talphaMap: { value: null },\\n\\n\\t\\t},\\n\\n\\t\\tspecularmap: {\\n\\n\\t\\t\\tspecularMap: { value: null },\\n\\n\\t\\t},\\n\\n\\t\\tenvmap: {\\n\\n\\t\\t\\tenvMap: { value: null },\\n\\t\\t\\tflipEnvMap: { value: - 1 },\\n\\t\\t\\treflectivity: { value: 1.0 },\\n\\t\\t\\trefractionRatio: { value: 0.98 }\\n\\n\\t\\t},\\n\\n\\t\\taomap: {\\n\\n\\t\\t\\taoMap: { value: null },\\n\\t\\t\\taoMapIntensity: { value: 1 }\\n\\n\\t\\t},\\n\\n\\t\\tlightmap: {\\n\\n\\t\\t\\tlightMap: { value: null },\\n\\t\\t\\tlightMapIntensity: { value: 1 }\\n\\n\\t\\t},\\n\\n\\t\\temissivemap: {\\n\\n\\t\\t\\temissiveMap: { value: null }\\n\\n\\t\\t},\\n\\n\\t\\tbumpmap: {\\n\\n\\t\\t\\tbumpMap: { value: null },\\n\\t\\t\\tbumpScale: { value: 1 }\\n\\n\\t\\t},\\n\\n\\t\\tnormalmap: {\\n\\n\\t\\t\\tnormalMap: { value: null },\\n\\t\\t\\tnormalScale: { value: new Vector2( 1, 1 ) }\\n\\n\\t\\t},\\n\\n\\t\\tdisplacementmap: {\\n\\n\\t\\t\\tdisplacementMap: { value: null },\\n\\t\\t\\tdisplacementScale: { value: 1 },\\n\\t\\t\\tdisplacementBias: { value: 0 }\\n\\n\\t\\t},\\n\\n\\t\\troughnessmap: {\\n\\n\\t\\t\\troughnessMap: { value: null }\\n\\n\\t\\t},\\n\\n\\t\\tmetalnessmap: {\\n\\n\\t\\t\\tmetalnessMap: { value: null }\\n\\n\\t\\t},\\n\\n\\t\\tgradientmap: {\\n\\n\\t\\t\\tgradientMap: { value: null }\\n\\n\\t\\t},\\n\\n\\t\\tfog: {\\n\\n\\t\\t\\tfogDensity: { value: 0.00025 },\\n\\t\\t\\tfogNear: { value: 1 },\\n\\t\\t\\tfogFar: { value: 2000 },\\n\\t\\t\\tfogColor: { value: new Color( 0xffffff ) }\\n\\n\\t\\t},\\n\\n\\t\\tlights: {\\n\\n\\t\\t\\tambientLightColor: { value: [] },\\n\\n\\t\\t\\tdirectionalLights: { value: [], properties: {\\n\\t\\t\\t\\tdirection: {},\\n\\t\\t\\t\\tcolor: {},\\n\\n\\t\\t\\t\\tshadow: {},\\n\\t\\t\\t\\tshadowBias: {},\\n\\t\\t\\t\\tshadowRadius: {},\\n\\t\\t\\t\\tshadowMapSize: {}\\n\\t\\t\\t} },\\n\\n\\t\\t\\tdirectionalShadowMap: { value: [] },\\n\\t\\t\\tdirectionalShadowMatrix: { value: [] },\\n\\n\\t\\t\\tspotLights: { value: [], properties: {\\n\\t\\t\\t\\tcolor: {},\\n\\t\\t\\t\\tposition: {},\\n\\t\\t\\t\\tdirection: {},\\n\\t\\t\\t\\tdistance: {},\\n\\t\\t\\t\\tconeCos: {},\\n\\t\\t\\t\\tpenumbraCos: {},\\n\\t\\t\\t\\tdecay: {},\\n\\n\\t\\t\\t\\tshadow: {},\\n\\t\\t\\t\\tshadowBias: {},\\n\\t\\t\\t\\tshadowRadius: {},\\n\\t\\t\\t\\tshadowMapSize: {}\\n\\t\\t\\t} },\\n\\n\\t\\t\\tspotShadowMap: { value: [] },\\n\\t\\t\\tspotShadowMatrix: { value: [] },\\n\\n\\t\\t\\tpointLights: { value: [], properties: {\\n\\t\\t\\t\\tcolor: {},\\n\\t\\t\\t\\tposition: {},\\n\\t\\t\\t\\tdecay: {},\\n\\t\\t\\t\\tdistance: {},\\n\\n\\t\\t\\t\\tshadow: {},\\n\\t\\t\\t\\tshadowBias: {},\\n\\t\\t\\t\\tshadowRadius: {},\\n\\t\\t\\t\\tshadowMapSize: {},\\n\\t\\t\\t\\tshadowCameraNear: {},\\n\\t\\t\\t\\tshadowCameraFar: {}\\n\\t\\t\\t} },\\n\\n\\t\\t\\tpointShadowMap: { value: [] },\\n\\t\\t\\tpointShadowMatrix: { value: [] },\\n\\n\\t\\t\\themisphereLights: { value: [], properties: {\\n\\t\\t\\t\\tdirection: {},\\n\\t\\t\\t\\tskyColor: {},\\n\\t\\t\\t\\tgroundColor: {}\\n\\t\\t\\t} },\\n\\n\\t\\t\\t// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src\\n\\t\\t\\trectAreaLights: { value: [], properties: {\\n\\t\\t\\t\\tcolor: {},\\n\\t\\t\\t\\tposition: {},\\n\\t\\t\\t\\twidth: {},\\n\\t\\t\\t\\theight: {}\\n\\t\\t\\t} }\\n\\n\\t\\t},\\n\\n\\t\\tpoints: {\\n\\n\\t\\t\\tdiffuse: { value: new Color( 0xeeeeee ) },\\n\\t\\t\\topacity: { value: 1.0 },\\n\\t\\t\\tsize: { value: 1.0 },\\n\\t\\t\\tscale: { value: 1.0 },\\n\\t\\t\\tmap: { value: null },\\n\\t\\t\\tuvTransform: { value: new Matrix3() }\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t * Uniform Utilities\\n\\t */\\n\\n\\tvar UniformsUtils = {\\n\\n\\t\\tmerge: function ( uniforms ) {\\n\\n\\t\\t\\tvar merged = {};\\n\\n\\t\\t\\tfor ( var u = 0; u < uniforms.length; u ++ ) {\\n\\n\\t\\t\\t\\tvar tmp = this.clone( uniforms[ u ] );\\n\\n\\t\\t\\t\\tfor ( var p in tmp ) {\\n\\n\\t\\t\\t\\t\\tmerged[ p ] = tmp[ p ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn merged;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function ( uniforms_src ) {\\n\\n\\t\\t\\tvar uniforms_dst = {};\\n\\n\\t\\t\\tfor ( var u in uniforms_src ) {\\n\\n\\t\\t\\t\\tuniforms_dst[ u ] = {};\\n\\n\\t\\t\\t\\tfor ( var p in uniforms_src[ u ] ) {\\n\\n\\t\\t\\t\\t\\tvar parameter_src = uniforms_src[ u ][ p ];\\n\\n\\t\\t\\t\\t\\tif ( parameter_src && ( parameter_src.isColor ||\\n\\t\\t\\t\\t\\t\\tparameter_src.isMatrix3 || parameter_src.isMatrix4 ||\\n\\t\\t\\t\\t\\t\\tparameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||\\n\\t\\t\\t\\t\\t\\tparameter_src.isTexture ) ) {\\n\\n\\t\\t\\t\\t\\t\\tuniforms_dst[ u ][ p ] = parameter_src.clone();\\n\\n\\t\\t\\t\\t\\t} else if ( Array.isArray( parameter_src ) ) {\\n\\n\\t\\t\\t\\t\\t\\tuniforms_dst[ u ][ p ] = parameter_src.slice();\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tuniforms_dst[ u ][ p ] = parameter_src;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn uniforms_dst;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tvar alphamap_fragment = \\\"#ifdef USE_ALPHAMAP\\\\n\\\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\\\n#endif\\\\n\\\";\\n\\n\\tvar alphamap_pars_fragment = \\\"#ifdef USE_ALPHAMAP\\\\n\\\\tuniform sampler2D alphaMap;\\\\n#endif\\\\n\\\";\\n\\n\\tvar alphatest_fragment = \\\"#ifdef ALPHATEST\\\\n\\\\tif ( diffuseColor.a < ALPHATEST ) discard;\\\\n#endif\\\\n\\\";\\n\\n\\tvar aomap_fragment = \\\"#ifdef USE_AOMAP\\\\n\\\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\\\n\\\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\\\n\\\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\\\n\\\\t\\\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\\\n\\\\t\\\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar aomap_pars_fragment = \\\"#ifdef USE_AOMAP\\\\n\\\\tuniform sampler2D aoMap;\\\\n\\\\tuniform float aoMapIntensity;\\\\n#endif\\\";\\n\\n\\tvar begin_vertex = \\\"\\\\nvec3 transformed = vec3( position );\\\\n\\\";\\n\\n\\tvar beginnormal_vertex = \\\"\\\\nvec3 objectNormal = vec3( normal );\\\\n\\\";\\n\\n\\tvar bsdfs = \\\"float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\\\n\\\\tif( decayExponent > 0.0 ) {\\\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\\\n\\\\t\\\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\\\n\\\\t\\\\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\\\n\\\\t\\\\treturn distanceFalloff * maxDistanceCutoffFactor;\\\\n#else\\\\n\\\\t\\\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\\\n#endif\\\\n\\\\t}\\\\n\\\\treturn 1.0;\\\\n}\\\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\\\n\\\\treturn RECIPROCAL_PI * diffuseColor;\\\\n}\\\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\\\n\\\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\\\n\\\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\\\n}\\\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\\\n\\\\tfloat a2 = pow2( alpha );\\\\n\\\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\\\n\\\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\\\n\\\\treturn 1.0 / ( gl * gv );\\\\n}\\\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\\\n\\\\tfloat a2 = pow2( alpha );\\\\n\\\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\\\n\\\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\\\n\\\\treturn 0.5 / max( gv + gl, EPSILON );\\\\n}\\\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\\\n\\\\tfloat a2 = pow2( alpha );\\\\n\\\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\\\n\\\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\\\n}\\\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\\\n\\\\tfloat alpha = pow2( roughness );\\\\n\\\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\\\n\\\\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\\\n\\\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\\\n\\\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\\\n\\\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\\\n\\\\tvec3 F = F_Schlick( specularColor, dotLH );\\\\n\\\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\\\n\\\\tfloat D = D_GGX( alpha, dotNH );\\\\n\\\\treturn F * ( G * D );\\\\n}\\\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\\\n\\\\tconst float LUT_SIZE  = 64.0;\\\\n\\\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\\\n\\\\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\\\\n\\\\tfloat theta = acos( dot( N, V ) );\\\\n\\\\tvec2 uv = vec2(\\\\n\\\\t\\\\tsqrt( saturate( roughness ) ),\\\\n\\\\t\\\\tsaturate( theta / ( 0.5 * PI ) ) );\\\\n\\\\tuv = uv * LUT_SCALE + LUT_BIAS;\\\\n\\\\treturn uv;\\\\n}\\\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\\\n\\\\tfloat l = length( f );\\\\n\\\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\\\n}\\\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\\\n\\\\tfloat x = dot( v1, v2 );\\\\n\\\\tfloat y = abs( x );\\\\n\\\\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\\\\n\\\\tfloat b = 3.45068 + (4.18814 + y) * y;\\\\n\\\\tfloat v = a / b;\\\\n\\\\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\\\\n\\\\treturn cross( v1, v2 ) * theta_sintheta;\\\\n}\\\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\\\n\\\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\\\n\\\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\\\n\\\\tvec3 lightNormal = cross( v1, v2 );\\\\n\\\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\\\n\\\\tvec3 T1, T2;\\\\n\\\\tT1 = normalize( V - N * dot( V, N ) );\\\\n\\\\tT2 = - cross( N, T1 );\\\\n\\\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\\\n\\\\tvec3 coords[ 4 ];\\\\n\\\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\\\n\\\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\\\n\\\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\\\n\\\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\\\n\\\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\\\n\\\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\\\n\\\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\\\n\\\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\\\n\\\\tvec3 vectorFormFactor = vec3( 0.0 );\\\\n\\\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\\\n\\\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\\\n\\\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\\\n\\\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\\\n\\\\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\\\\n\\\\treturn result;\\\\n}\\\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\\\n\\\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\\\n\\\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\\\n\\\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\\\n\\\\tvec4 r = roughness * c0 + c1;\\\\n\\\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\\\n\\\\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\\\n\\\\treturn specularColor * AB.x + AB.y;\\\\n}\\\\nfloat G_BlinnPhong_Implicit( ) {\\\\n\\\\treturn 0.25;\\\\n}\\\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\\\n\\\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\\\n}\\\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\\\n\\\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\\\n\\\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\\\n\\\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\\\n\\\\tvec3 F = F_Schlick( specularColor, dotLH );\\\\n\\\\tfloat G = G_BlinnPhong_Implicit( );\\\\n\\\\tfloat D = D_BlinnPhong( shininess, dotNH );\\\\n\\\\treturn F * ( G * D );\\\\n}\\\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\\\n\\\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\\\n}\\\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\\\n\\\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\\\n}\\\\n\\\";\\n\\n\\tvar bumpmap_pars_fragment = \\\"#ifdef USE_BUMPMAP\\\\n\\\\tuniform sampler2D bumpMap;\\\\n\\\\tuniform float bumpScale;\\\\n\\\\tvec2 dHdxy_fwd() {\\\\n\\\\t\\\\tvec2 dSTdx = dFdx( vUv );\\\\n\\\\t\\\\tvec2 dSTdy = dFdy( vUv );\\\\n\\\\t\\\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\\\n\\\\t\\\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\\\n\\\\t\\\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\\\n\\\\t\\\\treturn vec2( dBx, dBy );\\\\n\\\\t}\\\\n\\\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\\\n\\\\t\\\\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\\\\n\\\\t\\\\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\\\\n\\\\t\\\\tvec3 vN = surf_norm;\\\\n\\\\t\\\\tvec3 R1 = cross( vSigmaY, vN );\\\\n\\\\t\\\\tvec3 R2 = cross( vN, vSigmaX );\\\\n\\\\t\\\\tfloat fDet = dot( vSigmaX, R1 );\\\\n\\\\t\\\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\\\n\\\\t\\\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\\\n\\\\t}\\\\n#endif\\\\n\\\";\\n\\n\\tvar clipping_planes_fragment = \\\"#if NUM_CLIPPING_PLANES > 0\\\\n\\\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\\\\n\\\\t\\\\tvec4 plane = clippingPlanes[ i ];\\\\n\\\\t\\\\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\\\n\\\\t}\\\\n\\\\t\\\\t\\\\n\\\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\\\n\\\\t\\\\tbool clipped = true;\\\\n\\\\t\\\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\\\\n\\\\t\\\\t\\\\tvec4 plane = clippingPlanes[ i ];\\\\n\\\\t\\\\t\\\\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\tif ( clipped ) discard;\\\\n\\\\t\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar clipping_planes_pars_fragment = \\\"#if NUM_CLIPPING_PLANES > 0\\\\n\\\\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\\\n\\\\t\\\\tvarying vec3 vViewPosition;\\\\n\\\\t#endif\\\\n\\\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\\\n#endif\\\\n\\\";\\n\\n\\tvar clipping_planes_pars_vertex = \\\"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\\\n\\\\tvarying vec3 vViewPosition;\\\\n#endif\\\\n\\\";\\n\\n\\tvar clipping_planes_vertex = \\\"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\\\n\\\\tvViewPosition = - mvPosition.xyz;\\\\n#endif\\\\n\\\";\\n\\n\\tvar color_fragment = \\\"#ifdef USE_COLOR\\\\n\\\\tdiffuseColor.rgb *= vColor;\\\\n#endif\\\";\\n\\n\\tvar color_pars_fragment = \\\"#ifdef USE_COLOR\\\\n\\\\tvarying vec3 vColor;\\\\n#endif\\\\n\\\";\\n\\n\\tvar color_pars_vertex = \\\"#ifdef USE_COLOR\\\\n\\\\tvarying vec3 vColor;\\\\n#endif\\\";\\n\\n\\tvar color_vertex = \\\"#ifdef USE_COLOR\\\\n\\\\tvColor.xyz = color.xyz;\\\\n#endif\\\";\\n\\n\\tvar common = \\\"#define PI 3.14159265359\\\\n#define PI2 6.28318530718\\\\n#define PI_HALF 1.5707963267949\\\\n#define RECIPROCAL_PI 0.31830988618\\\\n#define RECIPROCAL_PI2 0.15915494\\\\n#define LOG2 1.442695\\\\n#define EPSILON 1e-6\\\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\\\nfloat pow2( const in float x ) { return x*x; }\\\\nfloat pow3( const in float x ) { return x*x*x; }\\\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\\\nhighp float rand( const in vec2 uv ) {\\\\n\\\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\\\n\\\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\\\n\\\\treturn fract(sin(sn) * c);\\\\n}\\\\nstruct IncidentLight {\\\\n\\\\tvec3 color;\\\\n\\\\tvec3 direction;\\\\n\\\\tbool visible;\\\\n};\\\\nstruct ReflectedLight {\\\\n\\\\tvec3 directDiffuse;\\\\n\\\\tvec3 directSpecular;\\\\n\\\\tvec3 indirectDiffuse;\\\\n\\\\tvec3 indirectSpecular;\\\\n};\\\\nstruct GeometricContext {\\\\n\\\\tvec3 position;\\\\n\\\\tvec3 normal;\\\\n\\\\tvec3 viewDir;\\\\n};\\\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\\\n\\\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\\\n}\\\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\\\n\\\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\\\n}\\\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\\\n\\\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\\\n\\\\treturn - distance * planeNormal + point;\\\\n}\\\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\\\n\\\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\\\n}\\\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\\\n\\\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\\\n}\\\\nmat3 transposeMat3( const in mat3 m ) {\\\\n\\\\tmat3 tmp;\\\\n\\\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\\\n\\\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\\\n\\\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\\\n\\\\treturn tmp;\\\\n}\\\\nfloat linearToRelativeLuminance( const in vec3 color ) {\\\\n\\\\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\\\\n\\\\treturn dot( weights, color.rgb );\\\\n}\\\\n\\\";\\n\\n\\tvar cube_uv_reflection_fragment = \\\"#ifdef ENVMAP_TYPE_CUBE_UV\\\\n#define cubeUV_textureSize (1024.0)\\\\nint getFaceFromDirection(vec3 direction) {\\\\n\\\\tvec3 absDirection = abs(direction);\\\\n\\\\tint face = -1;\\\\n\\\\tif( absDirection.x > absDirection.z ) {\\\\n\\\\t\\\\tif(absDirection.x > absDirection.y )\\\\n\\\\t\\\\t\\\\tface = direction.x > 0.0 ? 0 : 3;\\\\n\\\\t\\\\telse\\\\n\\\\t\\\\t\\\\tface = direction.y > 0.0 ? 1 : 4;\\\\n\\\\t}\\\\n\\\\telse {\\\\n\\\\t\\\\tif(absDirection.z > absDirection.y )\\\\n\\\\t\\\\t\\\\tface = direction.z > 0.0 ? 2 : 5;\\\\n\\\\t\\\\telse\\\\n\\\\t\\\\t\\\\tface = direction.y > 0.0 ? 1 : 4;\\\\n\\\\t}\\\\n\\\\treturn face;\\\\n}\\\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\\\n\\\\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\\\n\\\\tfloat dxRoughness = dFdx(roughness);\\\\n\\\\tfloat dyRoughness = dFdy(roughness);\\\\n\\\\tvec3 dx = dFdx( vec * scale * dxRoughness );\\\\n\\\\tvec3 dy = dFdy( vec * scale * dyRoughness );\\\\n\\\\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\\\n\\\\td = clamp(d, 1.0, cubeUV_rangeClamp);\\\\n\\\\tfloat mipLevel = 0.5 * log2(d);\\\\n\\\\treturn vec2(floor(mipLevel), fract(mipLevel));\\\\n}\\\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\\\n\\\\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\\\n\\\\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\\\n\\\\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\\\n\\\\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\\\n\\\\tfloat powScale = exp2_packed.x * exp2_packed.y;\\\\n\\\\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\\\n\\\\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\\\n\\\\tbool bRes = mipLevel == 0.0;\\\\n\\\\tscale =  bRes && (scale < a) ? a : scale;\\\\n\\\\tvec3 r;\\\\n\\\\tvec2 offset;\\\\n\\\\tint face = getFaceFromDirection(direction);\\\\n\\\\tfloat rcpPowScale = 1.0 / powScale;\\\\n\\\\tif( face == 0) {\\\\n\\\\t\\\\tr = vec3(direction.x, -direction.z, direction.y);\\\\n\\\\t\\\\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\\\n\\\\t\\\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\\\n\\\\t}\\\\n\\\\telse if( face == 1) {\\\\n\\\\t\\\\tr = vec3(direction.y, direction.x, direction.z);\\\\n\\\\t\\\\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\\\n\\\\t\\\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\\\n\\\\t}\\\\n\\\\telse if( face == 2) {\\\\n\\\\t\\\\tr = vec3(direction.z, direction.x, direction.y);\\\\n\\\\t\\\\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\\\n\\\\t\\\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\\\n\\\\t}\\\\n\\\\telse if( face == 3) {\\\\n\\\\t\\\\tr = vec3(direction.x, direction.z, direction.y);\\\\n\\\\t\\\\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\\\n\\\\t\\\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\\\n\\\\t}\\\\n\\\\telse if( face == 4) {\\\\n\\\\t\\\\tr = vec3(direction.y, direction.x, -direction.z);\\\\n\\\\t\\\\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\\\n\\\\t\\\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\\\n\\\\t}\\\\n\\\\telse {\\\\n\\\\t\\\\tr = vec3(direction.z, -direction.x, direction.y);\\\\n\\\\t\\\\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\\\n\\\\t\\\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\\\n\\\\t}\\\\n\\\\tr = normalize(r);\\\\n\\\\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\\\n\\\\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\\\n\\\\tvec2 base = offset + vec2( texelOffset );\\\\n\\\\treturn base + s * ( scale - 2.0 * texelOffset );\\\\n}\\\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\\\n\\\\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\\\n\\\\tfloat r1 = floor(roughnessVal);\\\\n\\\\tfloat r2 = r1 + 1.0;\\\\n\\\\tfloat t = fract(roughnessVal);\\\\n\\\\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\\\n\\\\tfloat s = mipInfo.y;\\\\n\\\\tfloat level0 = mipInfo.x;\\\\n\\\\tfloat level1 = level0 + 1.0;\\\\n\\\\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\\\n\\\\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\\\n\\\\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\\\n\\\\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\\\n\\\\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\\\n\\\\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\\\n\\\\tvec4 result = mix(color10, color20, t);\\\\n\\\\treturn vec4(result.rgb, 1.0);\\\\n}\\\\n#endif\\\\n\\\";\\n\\n\\tvar defaultnormal_vertex = \\\"vec3 transformedNormal = normalMatrix * objectNormal;\\\\n#ifdef FLIP_SIDED\\\\n\\\\ttransformedNormal = - transformedNormal;\\\\n#endif\\\\n\\\";\\n\\n\\tvar displacementmap_pars_vertex = \\\"#ifdef USE_DISPLACEMENTMAP\\\\n\\\\tuniform sampler2D displacementMap;\\\\n\\\\tuniform float displacementScale;\\\\n\\\\tuniform float displacementBias;\\\\n#endif\\\\n\\\";\\n\\n\\tvar displacementmap_vertex = \\\"#ifdef USE_DISPLACEMENTMAP\\\\n\\\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\\\n#endif\\\\n\\\";\\n\\n\\tvar emissivemap_fragment = \\\"#ifdef USE_EMISSIVEMAP\\\\n\\\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\\\n\\\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\\\n\\\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\\\n#endif\\\\n\\\";\\n\\n\\tvar emissivemap_pars_fragment = \\\"#ifdef USE_EMISSIVEMAP\\\\n\\\\tuniform sampler2D emissiveMap;\\\\n#endif\\\\n\\\";\\n\\n\\tvar encodings_fragment = \\\"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\\\n\\\";\\n\\n\\tvar encodings_pars_fragment = \\\"\\\\nvec4 LinearToLinear( in vec4 value ) {\\\\n\\\\treturn value;\\\\n}\\\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\\\n\\\\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\\\n}\\\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\\\n\\\\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\\\n}\\\\nvec4 sRGBToLinear( in vec4 value ) {\\\\n\\\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\\\n}\\\\nvec4 LinearTosRGB( in vec4 value ) {\\\\n\\\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\\\n}\\\\nvec4 RGBEToLinear( in vec4 value ) {\\\\n\\\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\\\n}\\\\nvec4 LinearToRGBE( in vec4 value ) {\\\\n\\\\tfloat maxComponent = max( max( value.r, value.g ), value.b );\\\\n\\\\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\\\n\\\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\\\n}\\\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\\\n\\\\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\\\\n}\\\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\\\n\\\\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\\\\n\\\\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\\\n\\\\tM            = ceil( M * 255.0 ) / 255.0;\\\\n\\\\treturn vec4( value.rgb / ( M * maxRange ), M );\\\\n}\\\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\\\n\\\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\\\n}\\\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\\\n\\\\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\\\\n\\\\tfloat D      = max( maxRange / maxRGB, 1.0 );\\\\n\\\\tD            = min( floor( D ) / 255.0, 1.0 );\\\\n\\\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\\\n}\\\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\\\nvec4 LinearToLogLuv( in vec4 value )  {\\\\n\\\\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\\\n\\\\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\\\n\\\\tvec4 vResult;\\\\n\\\\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\\\n\\\\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\\\n\\\\tvResult.w = fract(Le);\\\\n\\\\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\\\n\\\\treturn vResult;\\\\n}\\\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\\\nvec4 LogLuvToLinear( in vec4 value ) {\\\\n\\\\tfloat Le = value.z * 255.0 + value.w;\\\\n\\\\tvec3 Xp_Y_XYZp;\\\\n\\\\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\\\n\\\\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\\\n\\\\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\\\n\\\\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\\\n\\\\treturn vec4( max(vRGB, 0.0), 1.0 );\\\\n}\\\\n\\\";\\n\\n\\tvar envmap_fragment = \\\"#ifdef USE_ENVMAP\\\\n\\\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\\\n\\\\t\\\\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\\\n\\\\t\\\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\\\n\\\\t\\\\t#ifdef ENVMAP_MODE_REFLECTION\\\\n\\\\t\\\\t\\\\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\\\n\\\\t\\\\t#endif\\\\n\\\\t#else\\\\n\\\\t\\\\tvec3 reflectVec = vReflect;\\\\n\\\\t#endif\\\\n\\\\t#ifdef ENVMAP_TYPE_CUBE\\\\n\\\\t\\\\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\\\n\\\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\\\n\\\\t\\\\tvec2 sampleUV;\\\\n\\\\t\\\\treflectVec = normalize( reflectVec );\\\\n\\\\t\\\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\\\n\\\\t\\\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\\\n\\\\t\\\\tvec4 envColor = texture2D( envMap, sampleUV );\\\\n\\\\t#elif defined( ENVMAP_TYPE_SPHERE )\\\\n\\\\t\\\\treflectVec = normalize( reflectVec );\\\\n\\\\t\\\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\\\n\\\\t\\\\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\\\n\\\\t#else\\\\n\\\\t\\\\tvec4 envColor = vec4( 0.0 );\\\\n\\\\t#endif\\\\n\\\\tenvColor = envMapTexelToLinear( envColor );\\\\n\\\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\\\n\\\\t\\\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\\\n\\\\t#elif defined( ENVMAP_BLENDING_MIX )\\\\n\\\\t\\\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\\\n\\\\t#elif defined( ENVMAP_BLENDING_ADD )\\\\n\\\\t\\\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar envmap_pars_fragment = \\\"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\\\n\\\\tuniform float reflectivity;\\\\n\\\\tuniform float envMapIntensity;\\\\n#endif\\\\n#ifdef USE_ENVMAP\\\\n\\\\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\\\n\\\\t\\\\tvarying vec3 vWorldPosition;\\\\n\\\\t#endif\\\\n\\\\t#ifdef ENVMAP_TYPE_CUBE\\\\n\\\\t\\\\tuniform samplerCube envMap;\\\\n\\\\t#else\\\\n\\\\t\\\\tuniform sampler2D envMap;\\\\n\\\\t#endif\\\\n\\\\tuniform float flipEnvMap;\\\\n\\\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\\\n\\\\t\\\\tuniform float refractionRatio;\\\\n\\\\t#else\\\\n\\\\t\\\\tvarying vec3 vReflect;\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar envmap_pars_vertex = \\\"#ifdef USE_ENVMAP\\\\n\\\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\\\n\\\\t\\\\tvarying vec3 vWorldPosition;\\\\n\\\\t#else\\\\n\\\\t\\\\tvarying vec3 vReflect;\\\\n\\\\t\\\\tuniform float refractionRatio;\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar envmap_vertex = \\\"#ifdef USE_ENVMAP\\\\n\\\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\\\n\\\\t\\\\tvWorldPosition = worldPosition.xyz;\\\\n\\\\t#else\\\\n\\\\t\\\\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\\\n\\\\t\\\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\\\n\\\\t\\\\t#ifdef ENVMAP_MODE_REFLECTION\\\\n\\\\t\\\\t\\\\tvReflect = reflect( cameraToVertex, worldNormal );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\\\n\\\\t\\\\t#endif\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar fog_vertex = \\\"\\\\n#ifdef USE_FOG\\\\nfogDepth = -mvPosition.z;\\\\n#endif\\\";\\n\\n\\tvar fog_pars_vertex = \\\"#ifdef USE_FOG\\\\n  varying float fogDepth;\\\\n#endif\\\\n\\\";\\n\\n\\tvar fog_fragment = \\\"#ifdef USE_FOG\\\\n\\\\t#ifdef FOG_EXP2\\\\n\\\\t\\\\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\\\\n\\\\t#else\\\\n\\\\t\\\\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\\\\n\\\\t#endif\\\\n\\\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\\\n#endif\\\\n\\\";\\n\\n\\tvar fog_pars_fragment = \\\"#ifdef USE_FOG\\\\n\\\\tuniform vec3 fogColor;\\\\n\\\\tvarying float fogDepth;\\\\n\\\\t#ifdef FOG_EXP2\\\\n\\\\t\\\\tuniform float fogDensity;\\\\n\\\\t#else\\\\n\\\\t\\\\tuniform float fogNear;\\\\n\\\\t\\\\tuniform float fogFar;\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar gradientmap_pars_fragment = \\\"#ifdef TOON\\\\n\\\\tuniform sampler2D gradientMap;\\\\n\\\\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\\\n\\\\t\\\\tfloat dotNL = dot( normal, lightDirection );\\\\n\\\\t\\\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\\\n\\\\t\\\\t#ifdef USE_GRADIENTMAP\\\\n\\\\t\\\\t\\\\treturn texture2D( gradientMap, coord ).rgb;\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n#endif\\\\n\\\";\\n\\n\\tvar lightmap_fragment = \\\"#ifdef USE_LIGHTMAP\\\\n\\\\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\\\n#endif\\\\n\\\";\\n\\n\\tvar lightmap_pars_fragment = \\\"#ifdef USE_LIGHTMAP\\\\n\\\\tuniform sampler2D lightMap;\\\\n\\\\tuniform float lightMapIntensity;\\\\n#endif\\\";\\n\\n\\tvar lights_lambert_vertex = \\\"vec3 diffuse = vec3( 1.0 );\\\\nGeometricContext geometry;\\\\ngeometry.position = mvPosition.xyz;\\\\ngeometry.normal = normalize( transformedNormal );\\\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\\\nGeometricContext backGeometry;\\\\nbackGeometry.position = geometry.position;\\\\nbackGeometry.normal = -geometry.normal;\\\\nbackGeometry.viewDir = geometry.viewDir;\\\\nvLightFront = vec3( 0.0 );\\\\n#ifdef DOUBLE_SIDED\\\\n\\\\tvLightBack = vec3( 0.0 );\\\\n#endif\\\\nIncidentLight directLight;\\\\nfloat dotNL;\\\\nvec3 directLightColor_Diffuse;\\\\n#if NUM_POINT_LIGHTS > 0\\\\n\\\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\\\n\\\\t\\\\tdotNL = dot( geometry.normal, directLight.direction );\\\\n\\\\t\\\\tdirectLightColor_Diffuse = PI * directLight.color;\\\\n\\\\t\\\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\t\\\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n#endif\\\\n#if NUM_SPOT_LIGHTS > 0\\\\n\\\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\\\n\\\\t\\\\tdotNL = dot( geometry.normal, directLight.direction );\\\\n\\\\t\\\\tdirectLightColor_Diffuse = PI * directLight.color;\\\\n\\\\t\\\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\t\\\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n#endif\\\\n#if NUM_DIR_LIGHTS > 0\\\\n\\\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\\\n\\\\t\\\\tdotNL = dot( geometry.normal, directLight.direction );\\\\n\\\\t\\\\tdirectLightColor_Diffuse = PI * directLight.color;\\\\n\\\\t\\\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\t\\\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n#endif\\\\n#if NUM_HEMI_LIGHTS > 0\\\\n\\\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\\\n\\\\t\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\t\\\\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n#endif\\\\n\\\";\\n\\n\\tvar lights_pars = \\\"uniform vec3 ambientLightColor;\\\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\\\n\\\\tvec3 irradiance = ambientLightColor;\\\\n\\\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\\\n\\\\t\\\\tirradiance *= PI;\\\\n\\\\t#endif\\\\n\\\\treturn irradiance;\\\\n}\\\\n#if NUM_DIR_LIGHTS > 0\\\\n\\\\tstruct DirectionalLight {\\\\n\\\\t\\\\tvec3 direction;\\\\n\\\\t\\\\tvec3 color;\\\\n\\\\t\\\\tint shadow;\\\\n\\\\t\\\\tfloat shadowBias;\\\\n\\\\t\\\\tfloat shadowRadius;\\\\n\\\\t\\\\tvec2 shadowMapSize;\\\\n\\\\t};\\\\n\\\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\\\n\\\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\\\n\\\\t\\\\tdirectLight.color = directionalLight.color;\\\\n\\\\t\\\\tdirectLight.direction = directionalLight.direction;\\\\n\\\\t\\\\tdirectLight.visible = true;\\\\n\\\\t}\\\\n#endif\\\\n#if NUM_POINT_LIGHTS > 0\\\\n\\\\tstruct PointLight {\\\\n\\\\t\\\\tvec3 position;\\\\n\\\\t\\\\tvec3 color;\\\\n\\\\t\\\\tfloat distance;\\\\n\\\\t\\\\tfloat decay;\\\\n\\\\t\\\\tint shadow;\\\\n\\\\t\\\\tfloat shadowBias;\\\\n\\\\t\\\\tfloat shadowRadius;\\\\n\\\\t\\\\tvec2 shadowMapSize;\\\\n\\\\t\\\\tfloat shadowCameraNear;\\\\n\\\\t\\\\tfloat shadowCameraFar;\\\\n\\\\t};\\\\n\\\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\\\n\\\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\\\n\\\\t\\\\tvec3 lVector = pointLight.position - geometry.position;\\\\n\\\\t\\\\tdirectLight.direction = normalize( lVector );\\\\n\\\\t\\\\tfloat lightDistance = length( lVector );\\\\n\\\\t\\\\tdirectLight.color = pointLight.color;\\\\n\\\\t\\\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\\\n\\\\t\\\\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\\\\n\\\\t}\\\\n#endif\\\\n#if NUM_SPOT_LIGHTS > 0\\\\n\\\\tstruct SpotLight {\\\\n\\\\t\\\\tvec3 position;\\\\n\\\\t\\\\tvec3 direction;\\\\n\\\\t\\\\tvec3 color;\\\\n\\\\t\\\\tfloat distance;\\\\n\\\\t\\\\tfloat decay;\\\\n\\\\t\\\\tfloat coneCos;\\\\n\\\\t\\\\tfloat penumbraCos;\\\\n\\\\t\\\\tint shadow;\\\\n\\\\t\\\\tfloat shadowBias;\\\\n\\\\t\\\\tfloat shadowRadius;\\\\n\\\\t\\\\tvec2 shadowMapSize;\\\\n\\\\t};\\\\n\\\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\\\n\\\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\\\n\\\\t\\\\tvec3 lVector = spotLight.position - geometry.position;\\\\n\\\\t\\\\tdirectLight.direction = normalize( lVector );\\\\n\\\\t\\\\tfloat lightDistance = length( lVector );\\\\n\\\\t\\\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\\\n\\\\t\\\\tif ( angleCos > spotLight.coneCos ) {\\\\n\\\\t\\\\t\\\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\\\n\\\\t\\\\t\\\\tdirectLight.color = spotLight.color;\\\\n\\\\t\\\\t\\\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\\\n\\\\t\\\\t\\\\tdirectLight.visible = true;\\\\n\\\\t\\\\t} else {\\\\n\\\\t\\\\t\\\\tdirectLight.color = vec3( 0.0 );\\\\n\\\\t\\\\t\\\\tdirectLight.visible = false;\\\\n\\\\t\\\\t}\\\\n\\\\t}\\\\n#endif\\\\n#if NUM_RECT_AREA_LIGHTS > 0\\\\n\\\\tstruct RectAreaLight {\\\\n\\\\t\\\\tvec3 color;\\\\n\\\\t\\\\tvec3 position;\\\\n\\\\t\\\\tvec3 halfWidth;\\\\n\\\\t\\\\tvec3 halfHeight;\\\\n\\\\t};\\\\n\\\\tuniform sampler2D ltcMat;\\\\tuniform sampler2D ltcMag;\\\\n\\\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\\\n#endif\\\\n#if NUM_HEMI_LIGHTS > 0\\\\n\\\\tstruct HemisphereLight {\\\\n\\\\t\\\\tvec3 direction;\\\\n\\\\t\\\\tvec3 skyColor;\\\\n\\\\t\\\\tvec3 groundColor;\\\\n\\\\t};\\\\n\\\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\\\n\\\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\\\n\\\\t\\\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\\\n\\\\t\\\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\\\n\\\\t\\\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\\\n\\\\t\\\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\\\n\\\\t\\\\t\\\\tirradiance *= PI;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\treturn irradiance;\\\\n\\\\t}\\\\n#endif\\\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\\\n\\\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\\\n\\\\t\\\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\\\n\\\\t\\\\t#ifdef ENVMAP_TYPE_CUBE\\\\n\\\\t\\\\t\\\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\\\n\\\\t\\\\t\\\\t#ifdef TEXTURE_LOD_EXT\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\\\n\\\\t\\\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\\\n\\\\t\\\\t\\\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\\\n\\\\t\\\\t\\\\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\tvec4 envMapColor = vec4( 0.0 );\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\treturn PI * envMapColor.rgb * envMapIntensity;\\\\n\\\\t}\\\\n\\\\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\\\n\\\\t\\\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\\\n\\\\t\\\\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\\\n\\\\t\\\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\\\n\\\\t}\\\\n\\\\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\\\n\\\\t\\\\t#ifdef ENVMAP_MODE_REFLECTION\\\\n\\\\t\\\\t\\\\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\\\n\\\\t\\\\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\\\n\\\\t\\\\t#ifdef ENVMAP_TYPE_CUBE\\\\n\\\\t\\\\t\\\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\\\n\\\\t\\\\t\\\\t#ifdef TEXTURE_LOD_EXT\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\\\n\\\\t\\\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\\\n\\\\t\\\\t\\\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\\\n\\\\t\\\\t\\\\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\\\n\\\\t\\\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\\\n\\\\t\\\\t\\\\tvec2 sampleUV;\\\\n\\\\t\\\\t\\\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\\\n\\\\t\\\\t\\\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\\\n\\\\t\\\\t\\\\t#ifdef TEXTURE_LOD_EXT\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\\\n\\\\t\\\\t#elif defined( ENVMAP_TYPE_SPHERE )\\\\n\\\\t\\\\t\\\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\\\n\\\\t\\\\t\\\\t#ifdef TEXTURE_LOD_EXT\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\treturn envMapColor.rgb * envMapIntensity;\\\\n\\\\t}\\\\n#endif\\\\n\\\";\\n\\n\\tvar lights_phong_fragment = \\\"BlinnPhongMaterial material;\\\\nmaterial.diffuseColor = diffuseColor.rgb;\\\\nmaterial.specularColor = specular;\\\\nmaterial.specularShininess = shininess;\\\\nmaterial.specularStrength = specularStrength;\\\\n\\\";\\n\\n\\tvar lights_phong_pars_fragment = \\\"varying vec3 vViewPosition;\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\nstruct BlinnPhongMaterial {\\\\n\\\\tvec3\\\\tdiffuseColor;\\\\n\\\\tvec3\\\\tspecularColor;\\\\n\\\\tfloat\\\\tspecularShininess;\\\\n\\\\tfloat\\\\tspecularStrength;\\\\n};\\\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\t#ifdef TOON\\\\n\\\\t\\\\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\\\n\\\\t#else\\\\n\\\\t\\\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\\\n\\\\t\\\\tvec3 irradiance = dotNL * directLight.color;\\\\n\\\\t#endif\\\\n\\\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\\\n\\\\t\\\\tirradiance *= PI;\\\\n\\\\t#endif\\\\n\\\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\\\n\\\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\\\n}\\\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\\\n}\\\\n#define RE_Direct\\\\t\\\\t\\\\t\\\\tRE_Direct_BlinnPhong\\\\n#define RE_IndirectDiffuse\\\\t\\\\tRE_IndirectDiffuse_BlinnPhong\\\\n#define Material_LightProbeLOD( material )\\\\t(0)\\\\n\\\";\\n\\n\\tvar lights_physical_fragment = \\\"PhysicalMaterial material;\\\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\\\n#ifdef STANDARD\\\\n\\\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\\\n#else\\\\n\\\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\\\n\\\\tmaterial.clearCoat = saturate( clearCoat );\\\\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\\\n#endif\\\\n\\\";\\n\\n\\tvar lights_physical_pars_fragment = \\\"struct PhysicalMaterial {\\\\n\\\\tvec3\\\\tdiffuseColor;\\\\n\\\\tfloat\\\\tspecularRoughness;\\\\n\\\\tvec3\\\\tspecularColor;\\\\n\\\\t#ifndef STANDARD\\\\n\\\\t\\\\tfloat clearCoat;\\\\n\\\\t\\\\tfloat clearCoatRoughness;\\\\n\\\\t#endif\\\\n};\\\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\\\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\\\\n\\\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\\\n}\\\\n#if NUM_RECT_AREA_LIGHTS > 0\\\\n\\\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\t\\\\tvec3 normal = geometry.normal;\\\\n\\\\t\\\\tvec3 viewDir = geometry.viewDir;\\\\n\\\\t\\\\tvec3 position = geometry.position;\\\\n\\\\t\\\\tvec3 lightPos = rectAreaLight.position;\\\\n\\\\t\\\\tvec3 halfWidth = rectAreaLight.halfWidth;\\\\n\\\\t\\\\tvec3 halfHeight = rectAreaLight.halfHeight;\\\\n\\\\t\\\\tvec3 lightColor = rectAreaLight.color;\\\\n\\\\t\\\\tfloat roughness = material.specularRoughness;\\\\n\\\\t\\\\tvec3 rectCoords[ 4 ];\\\\n\\\\t\\\\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\\\\t\\\\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\\\\n\\\\t\\\\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\\\\n\\\\t\\\\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\\\\n\\\\t\\\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\\\n\\\\t\\\\tfloat norm = texture2D( ltcMag, uv ).a;\\\\n\\\\t\\\\tvec4 t = texture2D( ltcMat, uv );\\\\n\\\\t\\\\tmat3 mInv = mat3(\\\\n\\\\t\\\\t\\\\tvec3(   1,   0, t.y ),\\\\n\\\\t\\\\t\\\\tvec3(   0, t.z,   0 ),\\\\n\\\\t\\\\t\\\\tvec3( t.w,   0, t.x )\\\\n\\\\t\\\\t);\\\\n\\\\t\\\\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\\\n\\\\t\\\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\\\\n\\\\t}\\\\n#endif\\\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\\\n\\\\tvec3 irradiance = dotNL * directLight.color;\\\\n\\\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\\\n\\\\t\\\\tirradiance *= PI;\\\\n\\\\t#endif\\\\n\\\\t#ifndef STANDARD\\\\n\\\\t\\\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\\\n\\\\t#else\\\\n\\\\t\\\\tfloat clearCoatDHR = 0.0;\\\\n\\\\t#endif\\\\n\\\\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\\\n\\\\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\\\n\\\\t#ifndef STANDARD\\\\n\\\\t\\\\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\\\n\\\\t#endif\\\\n}\\\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\\\n}\\\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\t#ifndef STANDARD\\\\n\\\\t\\\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\\\n\\\\t\\\\tfloat dotNL = dotNV;\\\\n\\\\t\\\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\\\n\\\\t#else\\\\n\\\\t\\\\tfloat clearCoatDHR = 0.0;\\\\n\\\\t#endif\\\\n\\\\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\\\n\\\\t#ifndef STANDARD\\\\n\\\\t\\\\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\\\n\\\\t#endif\\\\n}\\\\n#define RE_Direct\\\\t\\\\t\\\\t\\\\tRE_Direct_Physical\\\\n#define RE_Direct_RectArea\\\\t\\\\tRE_Direct_RectArea_Physical\\\\n#define RE_IndirectDiffuse\\\\t\\\\tRE_IndirectDiffuse_Physical\\\\n#define RE_IndirectSpecular\\\\t\\\\tRE_IndirectSpecular_Physical\\\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\\\n\\\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\\\n}\\\\n\\\";\\n\\n\\tvar lights_template = \\\"\\\\nGeometricContext geometry;\\\\ngeometry.position = - vViewPosition;\\\\ngeometry.normal = normal;\\\\ngeometry.viewDir = normalize( vViewPosition );\\\\nIncidentLight directLight;\\\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\\\n\\\\tPointLight pointLight;\\\\n\\\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tpointLight = pointLights[ i ];\\\\n\\\\t\\\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\\\n\\\\t\\\\t#ifdef USE_SHADOWMAP\\\\n\\\\t\\\\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\tRE_Direct( directLight, geometry, material, reflectedLight );\\\\n\\\\t}\\\\n#endif\\\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\\\n\\\\tSpotLight spotLight;\\\\n\\\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tspotLight = spotLights[ i ];\\\\n\\\\t\\\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\\\n\\\\t\\\\t#ifdef USE_SHADOWMAP\\\\n\\\\t\\\\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\tRE_Direct( directLight, geometry, material, reflectedLight );\\\\n\\\\t}\\\\n#endif\\\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\\\n\\\\tDirectionalLight directionalLight;\\\\n\\\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tdirectionalLight = directionalLights[ i ];\\\\n\\\\t\\\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\\\n\\\\t\\\\t#ifdef USE_SHADOWMAP\\\\n\\\\t\\\\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\tRE_Direct( directLight, geometry, material, reflectedLight );\\\\n\\\\t}\\\\n#endif\\\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\\\n\\\\tRectAreaLight rectAreaLight;\\\\n\\\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\\\n\\\\t\\\\trectAreaLight = rectAreaLights[ i ];\\\\n\\\\t\\\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\\\n\\\\t}\\\\n#endif\\\\n#if defined( RE_IndirectDiffuse )\\\\n\\\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\\\n\\\\t#ifdef USE_LIGHTMAP\\\\n\\\\t\\\\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\\\n\\\\t\\\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\\\n\\\\t\\\\t\\\\tlightMapIrradiance *= PI;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\tirradiance += lightMapIrradiance;\\\\n\\\\t#endif\\\\n\\\\t#if ( NUM_HEMI_LIGHTS > 0 )\\\\n\\\\t\\\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\\\n\\\\t\\\\t\\\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\\\n\\\\t\\\\t}\\\\n\\\\t#endif\\\\n\\\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\\\n\\\\t\\\\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\\\n\\\\t#endif\\\\n\\\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\\\n#endif\\\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\\\n\\\\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\\\n\\\\t#ifndef STANDARD\\\\n\\\\t\\\\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\\\\n\\\\t#else\\\\n\\\\t\\\\tvec3 clearCoatRadiance = vec3( 0.0 );\\\\n\\\\t#endif\\\\n\\\\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\\\\n#endif\\\\n\\\";\\n\\n\\tvar logdepthbuf_fragment = \\\"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\\\n\\\\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\\\\n#endif\\\";\\n\\n\\tvar logdepthbuf_pars_fragment = \\\"#ifdef USE_LOGDEPTHBUF\\\\n\\\\tuniform float logDepthBufFC;\\\\n\\\\t#ifdef USE_LOGDEPTHBUF_EXT\\\\n\\\\t\\\\tvarying float vFragDepth;\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar logdepthbuf_pars_vertex = \\\"#ifdef USE_LOGDEPTHBUF\\\\n\\\\t#ifdef USE_LOGDEPTHBUF_EXT\\\\n\\\\t\\\\tvarying float vFragDepth;\\\\n\\\\t#endif\\\\n\\\\tuniform float logDepthBufFC;\\\\n#endif\\\";\\n\\n\\tvar logdepthbuf_vertex = \\\"#ifdef USE_LOGDEPTHBUF\\\\n\\\\t#ifdef USE_LOGDEPTHBUF_EXT\\\\n\\\\t\\\\tvFragDepth = 1.0 + gl_Position.w;\\\\n\\\\t#else\\\\n\\\\t\\\\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\\\\n\\\\t\\\\tgl_Position.z *= gl_Position.w;\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar map_fragment = \\\"#ifdef USE_MAP\\\\n\\\\tvec4 texelColor = texture2D( map, vUv );\\\\n\\\\ttexelColor = mapTexelToLinear( texelColor );\\\\n\\\\tdiffuseColor *= texelColor;\\\\n#endif\\\\n\\\";\\n\\n\\tvar map_pars_fragment = \\\"#ifdef USE_MAP\\\\n\\\\tuniform sampler2D map;\\\\n#endif\\\\n\\\";\\n\\n\\tvar map_particle_fragment = \\\"#ifdef USE_MAP\\\\n\\\\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\\\n\\\\tvec4 mapTexel = texture2D( map, uv );\\\\n\\\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\\\n#endif\\\\n\\\";\\n\\n\\tvar map_particle_pars_fragment = \\\"#ifdef USE_MAP\\\\n\\\\tuniform mat3 uvTransform;\\\\n\\\\tuniform sampler2D map;\\\\n#endif\\\\n\\\";\\n\\n\\tvar metalnessmap_fragment = \\\"float metalnessFactor = metalness;\\\\n#ifdef USE_METALNESSMAP\\\\n\\\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\\\n\\\\tmetalnessFactor *= texelMetalness.b;\\\\n#endif\\\\n\\\";\\n\\n\\tvar metalnessmap_pars_fragment = \\\"#ifdef USE_METALNESSMAP\\\\n\\\\tuniform sampler2D metalnessMap;\\\\n#endif\\\";\\n\\n\\tvar morphnormal_vertex = \\\"#ifdef USE_MORPHNORMALS\\\\n\\\\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\\\n\\\\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\\\n\\\\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\\\n\\\\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\\\n#endif\\\\n\\\";\\n\\n\\tvar morphtarget_pars_vertex = \\\"#ifdef USE_MORPHTARGETS\\\\n\\\\t#ifndef USE_MORPHNORMALS\\\\n\\\\tuniform float morphTargetInfluences[ 8 ];\\\\n\\\\t#else\\\\n\\\\tuniform float morphTargetInfluences[ 4 ];\\\\n\\\\t#endif\\\\n#endif\\\";\\n\\n\\tvar morphtarget_vertex = \\\"#ifdef USE_MORPHTARGETS\\\\n\\\\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\\\n\\\\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\\\n\\\\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\\\n\\\\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\\\n\\\\t#ifndef USE_MORPHNORMALS\\\\n\\\\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\\\n\\\\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\\\n\\\\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\\\n\\\\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar normal_fragment = \\\"#ifdef FLAT_SHADED\\\\n\\\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\\\n\\\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\\\n\\\\tvec3 normal = normalize( cross( fdx, fdy ) );\\\\n#else\\\\n\\\\tvec3 normal = normalize( vNormal );\\\\n\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\\\n\\\\t#endif\\\\n#endif\\\\n#ifdef USE_NORMALMAP\\\\n\\\\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\\\n#elif defined( USE_BUMPMAP )\\\\n\\\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\\\n#endif\\\\n\\\";\\n\\n\\tvar normalmap_pars_fragment = \\\"#ifdef USE_NORMALMAP\\\\n\\\\tuniform sampler2D normalMap;\\\\n\\\\tuniform vec2 normalScale;\\\\n\\\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\\\n\\\\t\\\\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\\\n\\\\t\\\\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\\\n\\\\t\\\\tvec2 st0 = dFdx( vUv.st );\\\\n\\\\t\\\\tvec2 st1 = dFdy( vUv.st );\\\\n\\\\t\\\\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\\\n\\\\t\\\\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\\\n\\\\t\\\\tvec3 N = normalize( surf_norm );\\\\n\\\\t\\\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\\\n\\\\t\\\\tmapN.xy = normalScale * mapN.xy;\\\\n\\\\t\\\\tmat3 tsn = mat3( S, T, N );\\\\n\\\\t\\\\treturn normalize( tsn * mapN );\\\\n\\\\t}\\\\n#endif\\\\n\\\";\\n\\n\\tvar packing = \\\"vec3 packNormalToRGB( const in vec3 normal ) {\\\\n\\\\treturn normalize( normal ) * 0.5 + 0.5;\\\\n}\\\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\\\n\\\\treturn 2.0 * rgb.xyz - 1.0;\\\\n}\\\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\\\nconst float ShiftRight8 = 1. / 256.;\\\\nvec4 packDepthToRGBA( const in float v ) {\\\\n\\\\tvec4 r = vec4( fract( v * PackFactors ), v );\\\\n\\\\tr.yzw -= r.xyz * ShiftRight8;\\\\treturn r * PackUpscale;\\\\n}\\\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\\\n\\\\treturn dot( v, UnpackFactors );\\\\n}\\\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\\\n\\\\treturn ( viewZ + near ) / ( near - far );\\\\n}\\\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\\\n\\\\treturn linearClipZ * ( near - far ) - near;\\\\n}\\\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\\\n\\\\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\\\n}\\\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\\\n\\\\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\\\n}\\\\n\\\";\\n\\n\\tvar premultiplied_alpha_fragment = \\\"#ifdef PREMULTIPLIED_ALPHA\\\\n\\\\tgl_FragColor.rgb *= gl_FragColor.a;\\\\n#endif\\\\n\\\";\\n\\n\\tvar project_vertex = \\\"vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\\\ngl_Position = projectionMatrix * mvPosition;\\\\n\\\";\\n\\n\\tvar dithering_fragment = \\\"#if defined( DITHERING )\\\\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\\\\n#endif\\\\n\\\";\\n\\n\\tvar dithering_pars_fragment = \\\"#if defined( DITHERING )\\\\n\\\\tvec3 dithering( vec3 color ) {\\\\n\\\\t\\\\tfloat grid_position = rand( gl_FragCoord.xy );\\\\n\\\\t\\\\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\\\n\\\\t\\\\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\\\n\\\\t\\\\treturn color + dither_shift_RGB;\\\\n\\\\t}\\\\n#endif\\\\n\\\";\\n\\n\\tvar roughnessmap_fragment = \\\"float roughnessFactor = roughness;\\\\n#ifdef USE_ROUGHNESSMAP\\\\n\\\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\\\n\\\\troughnessFactor *= texelRoughness.g;\\\\n#endif\\\\n\\\";\\n\\n\\tvar roughnessmap_pars_fragment = \\\"#ifdef USE_ROUGHNESSMAP\\\\n\\\\tuniform sampler2D roughnessMap;\\\\n#endif\\\";\\n\\n\\tvar shadowmap_pars_fragment = \\\"#ifdef USE_SHADOWMAP\\\\n\\\\t#if NUM_DIR_LIGHTS > 0\\\\n\\\\t\\\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\\\n\\\\t\\\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\\\n\\\\t#endif\\\\n\\\\t#if NUM_SPOT_LIGHTS > 0\\\\n\\\\t\\\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\\\n\\\\t\\\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\\\n\\\\t#endif\\\\n\\\\t#if NUM_POINT_LIGHTS > 0\\\\n\\\\t\\\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\\\n\\\\t\\\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\\\n\\\\t#endif\\\\n\\\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\\\n\\\\t\\\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\\\n\\\\t}\\\\n\\\\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\\\n\\\\t\\\\tconst vec2 offset = vec2( 0.0, 1.0 );\\\\n\\\\t\\\\tvec2 texelSize = vec2( 1.0 ) / size;\\\\n\\\\t\\\\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\\\n\\\\t\\\\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\\\n\\\\t\\\\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\\\n\\\\t\\\\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\\\n\\\\t\\\\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\\\n\\\\t\\\\tvec2 f = fract( uv * size + 0.5 );\\\\n\\\\t\\\\tfloat a = mix( lb, lt, f.y );\\\\n\\\\t\\\\tfloat b = mix( rb, rt, f.y );\\\\n\\\\t\\\\tfloat c = mix( a, b, f.x );\\\\n\\\\t\\\\treturn c;\\\\n\\\\t}\\\\n\\\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\\\n\\\\t\\\\tfloat shadow = 1.0;\\\\n\\\\t\\\\tshadowCoord.xyz /= shadowCoord.w;\\\\n\\\\t\\\\tshadowCoord.z += shadowBias;\\\\n\\\\t\\\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\\\n\\\\t\\\\tbool inFrustum = all( inFrustumVec );\\\\n\\\\t\\\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\\\n\\\\t\\\\tbool frustumTest = all( frustumTestVec );\\\\n\\\\t\\\\tif ( frustumTest ) {\\\\n\\\\t\\\\t#if defined( SHADOWMAP_TYPE_PCF )\\\\n\\\\t\\\\t\\\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\\\n\\\\t\\\\t\\\\tfloat dx0 = - texelSize.x * shadowRadius;\\\\n\\\\t\\\\t\\\\tfloat dy0 = - texelSize.y * shadowRadius;\\\\n\\\\t\\\\t\\\\tfloat dx1 = + texelSize.x * shadowRadius;\\\\n\\\\t\\\\t\\\\tfloat dy1 = + texelSize.y * shadowRadius;\\\\n\\\\t\\\\t\\\\tshadow = (\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\\\n\\\\t\\\\t\\\\t) * ( 1.0 / 9.0 );\\\\n\\\\t\\\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\\\n\\\\t\\\\t\\\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\\\n\\\\t\\\\t\\\\tfloat dx0 = - texelSize.x * shadowRadius;\\\\n\\\\t\\\\t\\\\tfloat dy0 = - texelSize.y * shadowRadius;\\\\n\\\\t\\\\t\\\\tfloat dx1 = + texelSize.x * shadowRadius;\\\\n\\\\t\\\\t\\\\tfloat dy1 = + texelSize.y * shadowRadius;\\\\n\\\\t\\\\t\\\\tshadow = (\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\\\n\\\\t\\\\t\\\\t) * ( 1.0 / 9.0 );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\treturn shadow;\\\\n\\\\t}\\\\n\\\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\\\n\\\\t\\\\tvec3 absV = abs( v );\\\\n\\\\t\\\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\\\n\\\\t\\\\tabsV *= scaleToCube;\\\\n\\\\t\\\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\\\n\\\\t\\\\tvec2 planar = v.xy;\\\\n\\\\t\\\\tfloat almostATexel = 1.5 * texelSizeY;\\\\n\\\\t\\\\tfloat almostOne = 1.0 - almostATexel;\\\\n\\\\t\\\\tif ( absV.z >= almostOne ) {\\\\n\\\\t\\\\t\\\\tif ( v.z > 0.0 )\\\\n\\\\t\\\\t\\\\t\\\\tplanar.x = 4.0 - v.x;\\\\n\\\\t\\\\t} else if ( absV.x >= almostOne ) {\\\\n\\\\t\\\\t\\\\tfloat signX = sign( v.x );\\\\n\\\\t\\\\t\\\\tplanar.x = v.z * signX + 2.0 * signX;\\\\n\\\\t\\\\t} else if ( absV.y >= almostOne ) {\\\\n\\\\t\\\\t\\\\tfloat signY = sign( v.y );\\\\n\\\\t\\\\t\\\\tplanar.x = v.x + 2.0 * signY + 2.0;\\\\n\\\\t\\\\t\\\\tplanar.y = v.z * signY - 2.0;\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\\\n\\\\t}\\\\n\\\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\\\n\\\\t\\\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\\\n\\\\t\\\\tvec3 lightToPosition = shadowCoord.xyz;\\\\n\\\\t\\\\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\\\t\\\\tdp += shadowBias;\\\\n\\\\t\\\\tvec3 bd3D = normalize( lightToPosition );\\\\n\\\\t\\\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\\\n\\\\t\\\\t\\\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\\\n\\\\t\\\\t\\\\treturn (\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\\\n\\\\t\\\\t\\\\t) * ( 1.0 / 9.0 );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n#endif\\\\n\\\";\\n\\n\\tvar shadowmap_pars_vertex = \\\"#ifdef USE_SHADOWMAP\\\\n\\\\t#if NUM_DIR_LIGHTS > 0\\\\n\\\\t\\\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\\\n\\\\t\\\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\\\n\\\\t#endif\\\\n\\\\t#if NUM_SPOT_LIGHTS > 0\\\\n\\\\t\\\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\\\n\\\\t\\\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\\\n\\\\t#endif\\\\n\\\\t#if NUM_POINT_LIGHTS > 0\\\\n\\\\t\\\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\\\n\\\\t\\\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar shadowmap_vertex = \\\"#ifdef USE_SHADOWMAP\\\\n\\\\t#if NUM_DIR_LIGHTS > 0\\\\n\\\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\\\n\\\\t}\\\\n\\\\t#endif\\\\n\\\\t#if NUM_SPOT_LIGHTS > 0\\\\n\\\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\\\n\\\\t}\\\\n\\\\t#endif\\\\n\\\\t#if NUM_POINT_LIGHTS > 0\\\\n\\\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\\\n\\\\t}\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar shadowmask_pars_fragment = \\\"float getShadowMask() {\\\\n\\\\tfloat shadow = 1.0;\\\\n\\\\t#ifdef USE_SHADOWMAP\\\\n\\\\t#if NUM_DIR_LIGHTS > 0\\\\n\\\\tDirectionalLight directionalLight;\\\\n\\\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tdirectionalLight = directionalLights[ i ];\\\\n\\\\t\\\\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\\\n\\\\t}\\\\n\\\\t#endif\\\\n\\\\t#if NUM_SPOT_LIGHTS > 0\\\\n\\\\tSpotLight spotLight;\\\\n\\\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tspotLight = spotLights[ i ];\\\\n\\\\t\\\\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\\\n\\\\t}\\\\n\\\\t#endif\\\\n\\\\t#if NUM_POINT_LIGHTS > 0\\\\n\\\\tPointLight pointLight;\\\\n\\\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tpointLight = pointLights[ i ];\\\\n\\\\t\\\\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\\\n\\\\t}\\\\n\\\\t#endif\\\\n\\\\t#endif\\\\n\\\\treturn shadow;\\\\n}\\\\n\\\";\\n\\n\\tvar skinbase_vertex = \\\"#ifdef USE_SKINNING\\\\n\\\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\\\n\\\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\\\n\\\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\\\n\\\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\\\n#endif\\\";\\n\\n\\tvar skinning_pars_vertex = \\\"#ifdef USE_SKINNING\\\\n\\\\tuniform mat4 bindMatrix;\\\\n\\\\tuniform mat4 bindMatrixInverse;\\\\n\\\\t#ifdef BONE_TEXTURE\\\\n\\\\t\\\\tuniform sampler2D boneTexture;\\\\n\\\\t\\\\tuniform int boneTextureSize;\\\\n\\\\t\\\\tmat4 getBoneMatrix( const in float i ) {\\\\n\\\\t\\\\t\\\\tfloat j = i * 4.0;\\\\n\\\\t\\\\t\\\\tfloat x = mod( j, float( boneTextureSize ) );\\\\n\\\\t\\\\t\\\\tfloat y = floor( j / float( boneTextureSize ) );\\\\n\\\\t\\\\t\\\\tfloat dx = 1.0 / float( boneTextureSize );\\\\n\\\\t\\\\t\\\\tfloat dy = 1.0 / float( boneTextureSize );\\\\n\\\\t\\\\t\\\\ty = dy * ( y + 0.5 );\\\\n\\\\t\\\\t\\\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\\\n\\\\t\\\\t\\\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\\\n\\\\t\\\\t\\\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\\\n\\\\t\\\\t\\\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\\\n\\\\t\\\\t\\\\tmat4 bone = mat4( v1, v2, v3, v4 );\\\\n\\\\t\\\\t\\\\treturn bone;\\\\n\\\\t\\\\t}\\\\n\\\\t#else\\\\n\\\\t\\\\tuniform mat4 boneMatrices[ MAX_BONES ];\\\\n\\\\t\\\\tmat4 getBoneMatrix( const in float i ) {\\\\n\\\\t\\\\t\\\\tmat4 bone = boneMatrices[ int(i) ];\\\\n\\\\t\\\\t\\\\treturn bone;\\\\n\\\\t\\\\t}\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar skinning_vertex = \\\"#ifdef USE_SKINNING\\\\n\\\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\\\n\\\\tvec4 skinned = vec4( 0.0 );\\\\n\\\\tskinned += boneMatX * skinVertex * skinWeight.x;\\\\n\\\\tskinned += boneMatY * skinVertex * skinWeight.y;\\\\n\\\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\\\n\\\\tskinned += boneMatW * skinVertex * skinWeight.w;\\\\n\\\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\\\n#endif\\\\n\\\";\\n\\n\\tvar skinnormal_vertex = \\\"#ifdef USE_SKINNING\\\\n\\\\tmat4 skinMatrix = mat4( 0.0 );\\\\n\\\\tskinMatrix += skinWeight.x * boneMatX;\\\\n\\\\tskinMatrix += skinWeight.y * boneMatY;\\\\n\\\\tskinMatrix += skinWeight.z * boneMatZ;\\\\n\\\\tskinMatrix += skinWeight.w * boneMatW;\\\\n\\\\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\\\n\\\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\\\n#endif\\\\n\\\";\\n\\n\\tvar specularmap_fragment = \\\"float specularStrength;\\\\n#ifdef USE_SPECULARMAP\\\\n\\\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\\\n\\\\tspecularStrength = texelSpecular.r;\\\\n#else\\\\n\\\\tspecularStrength = 1.0;\\\\n#endif\\\";\\n\\n\\tvar specularmap_pars_fragment = \\\"#ifdef USE_SPECULARMAP\\\\n\\\\tuniform sampler2D specularMap;\\\\n#endif\\\";\\n\\n\\tvar tonemapping_fragment = \\\"#if defined( TONE_MAPPING )\\\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\\\n#endif\\\\n\\\";\\n\\n\\tvar tonemapping_pars_fragment = \\\"#ifndef saturate\\\\n\\\\t#define saturate(a) clamp( a, 0.0, 1.0 )\\\\n#endif\\\\nuniform float toneMappingExposure;\\\\nuniform float toneMappingWhitePoint;\\\\nvec3 LinearToneMapping( vec3 color ) {\\\\n\\\\treturn toneMappingExposure * color;\\\\n}\\\\nvec3 ReinhardToneMapping( vec3 color ) {\\\\n\\\\tcolor *= toneMappingExposure;\\\\n\\\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\\\n}\\\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\\\n\\\\tcolor *= toneMappingExposure;\\\\n\\\\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\\\n}\\\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\\\n\\\\tcolor *= toneMappingExposure;\\\\n\\\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\\\n\\\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\\\n}\\\\n\\\";\\n\\n\\tvar uv_pars_fragment = \\\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\\\n\\\\tvarying vec2 vUv;\\\\n#endif\\\";\\n\\n\\tvar uv_pars_vertex = \\\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\\\n\\\\tvarying vec2 vUv;\\\\n\\\\tuniform mat3 uvTransform;\\\\n#endif\\\\n\\\";\\n\\n\\tvar uv_vertex = \\\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\\\n\\\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\\\n#endif\\\";\\n\\n\\tvar uv2_pars_fragment = \\\"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\\\n\\\\tvarying vec2 vUv2;\\\\n#endif\\\";\\n\\n\\tvar uv2_pars_vertex = \\\"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\\\n\\\\tattribute vec2 uv2;\\\\n\\\\tvarying vec2 vUv2;\\\\n#endif\\\";\\n\\n\\tvar uv2_vertex = \\\"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\\\n\\\\tvUv2 = uv2;\\\\n#endif\\\";\\n\\n\\tvar worldpos_vertex = \\\"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\\\\n\\\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\\\n#endif\\\\n\\\";\\n\\n\\tvar cube_frag = \\\"uniform samplerCube tCube;\\\\nuniform float tFlip;\\\\nuniform float opacity;\\\\nvarying vec3 vWorldPosition;\\\\nvoid main() {\\\\n\\\\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\\\n\\\\tgl_FragColor.a *= opacity;\\\\n}\\\\n\\\";\\n\\n\\tvar cube_vert = \\\"varying vec3 vWorldPosition;\\\\n#include <common>\\\\nvoid main() {\\\\n\\\\tvWorldPosition = transformDirection( position, modelMatrix );\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\tgl_Position.z = gl_Position.w;\\\\n}\\\\n\\\";\\n\\n\\tvar depth_frag = \\\"#if DEPTH_PACKING == 3200\\\\n\\\\tuniform float opacity;\\\\n#endif\\\\n#include <common>\\\\n#include <packing>\\\\n#include <uv_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( 1.0 );\\\\n\\\\t#if DEPTH_PACKING == 3200\\\\n\\\\t\\\\tdiffuseColor.a = opacity;\\\\n\\\\t#endif\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#if DEPTH_PACKING == 3200\\\\n\\\\t\\\\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\\\\n\\\\t#elif DEPTH_PACKING == 3201\\\\n\\\\t\\\\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\\\n\\\\t#endif\\\\n}\\\\n\\\";\\n\\n\\tvar depth_vert = \\\"#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <displacementmap_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#ifdef USE_DISPLACEMENTMAP\\\\n\\\\t\\\\t#include <beginnormal_vertex>\\\\n\\\\t\\\\t#include <morphnormal_vertex>\\\\n\\\\t\\\\t#include <skinnormal_vertex>\\\\n\\\\t#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <displacementmap_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n}\\\\n\\\";\\n\\n\\tvar distanceRGBA_frag = \\\"#define DISTANCE\\\\nuniform vec3 referencePosition;\\\\nuniform float nearDistance;\\\\nuniform float farDistance;\\\\nvarying vec3 vWorldPosition;\\\\n#include <common>\\\\n#include <packing>\\\\n#include <uv_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main () {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( 1.0 );\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\tfloat dist = length( vWorldPosition - referencePosition );\\\\n\\\\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\\\n\\\\tdist = saturate( dist );\\\\n\\\\tgl_FragColor = packDepthToRGBA( dist );\\\\n}\\\\n\\\";\\n\\n\\tvar distanceRGBA_vert = \\\"#define DISTANCE\\\\nvarying vec3 vWorldPosition;\\\\n#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <displacementmap_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#ifdef USE_DISPLACEMENTMAP\\\\n\\\\t\\\\t#include <beginnormal_vertex>\\\\n\\\\t\\\\t#include <morphnormal_vertex>\\\\n\\\\t\\\\t#include <skinnormal_vertex>\\\\n\\\\t#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <displacementmap_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\tvWorldPosition = worldPosition.xyz;\\\\n}\\\\n\\\";\\n\\n\\tvar equirect_frag = \\\"uniform sampler2D tEquirect;\\\\nvarying vec3 vWorldPosition;\\\\n#include <common>\\\\nvoid main() {\\\\n\\\\tvec3 direction = normalize( vWorldPosition );\\\\n\\\\tvec2 sampleUV;\\\\n\\\\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\\\n\\\\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\\\n\\\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\\\n}\\\\n\\\";\\n\\n\\tvar equirect_vert = \\\"varying vec3 vWorldPosition;\\\\n#include <common>\\\\nvoid main() {\\\\n\\\\tvWorldPosition = transformDirection( position, modelMatrix );\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <project_vertex>\\\\n}\\\\n\\\";\\n\\n\\tvar linedashed_frag = \\\"uniform vec3 diffuse;\\\\nuniform float opacity;\\\\nuniform float dashSize;\\\\nuniform float totalSize;\\\\nvarying float vLineDistance;\\\\n#include <common>\\\\n#include <color_pars_fragment>\\\\n#include <fog_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\\\n\\\\t\\\\tdiscard;\\\\n\\\\t}\\\\n\\\\tvec3 outgoingLight = vec3( 0.0 );\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\toutgoingLight = diffuseColor.rgb;\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n}\\\\n\\\";\\n\\n\\tvar linedashed_vert = \\\"uniform float scale;\\\\nattribute float lineDistance;\\\\nvarying float vLineDistance;\\\\n#include <common>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <color_vertex>\\\\n\\\\tvLineDistance = scale * lineDistance;\\\\n\\\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\\\n\\\\tgl_Position = projectionMatrix * mvPosition;\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\\n\\\";\\n\\n\\tvar meshbasic_frag = \\\"uniform vec3 diffuse;\\\\nuniform float opacity;\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\n#include <common>\\\\n#include <color_pars_fragment>\\\\n#include <uv_pars_fragment>\\\\n#include <uv2_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <aomap_pars_fragment>\\\\n#include <lightmap_pars_fragment>\\\\n#include <envmap_pars_fragment>\\\\n#include <fog_pars_fragment>\\\\n#include <specularmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\t#include <specularmap_fragment>\\\\n\\\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\\\n\\\\t#ifdef USE_LIGHTMAP\\\\n\\\\t\\\\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\\\n\\\\t#else\\\\n\\\\t\\\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\\\n\\\\t#endif\\\\n\\\\t#include <aomap_fragment>\\\\n\\\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\\\n\\\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\\\n\\\\t#include <envmap_fragment>\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n}\\\\n\\\";\\n\\n\\tvar meshbasic_vert = \\\"#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <uv2_pars_vertex>\\\\n#include <envmap_pars_vertex>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <uv2_vertex>\\\\n\\\\t#include <color_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#ifdef USE_ENVMAP\\\\n\\\\t#include <beginnormal_vertex>\\\\n\\\\t#include <morphnormal_vertex>\\\\n\\\\t#include <skinnormal_vertex>\\\\n\\\\t#include <defaultnormal_vertex>\\\\n\\\\t#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\t#include <envmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\\n\\\";\\n\\n\\tvar meshlambert_frag = \\\"uniform vec3 diffuse;\\\\nuniform vec3 emissive;\\\\nuniform float opacity;\\\\nvarying vec3 vLightFront;\\\\n#ifdef DOUBLE_SIDED\\\\n\\\\tvarying vec3 vLightBack;\\\\n#endif\\\\n#include <common>\\\\n#include <packing>\\\\n#include <dithering_pars_fragment>\\\\n#include <color_pars_fragment>\\\\n#include <uv_pars_fragment>\\\\n#include <uv2_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <aomap_pars_fragment>\\\\n#include <lightmap_pars_fragment>\\\\n#include <emissivemap_pars_fragment>\\\\n#include <envmap_pars_fragment>\\\\n#include <bsdfs>\\\\n#include <lights_pars>\\\\n#include <fog_pars_fragment>\\\\n#include <shadowmap_pars_fragment>\\\\n#include <shadowmask_pars_fragment>\\\\n#include <specularmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\\\n\\\\tvec3 totalEmissiveRadiance = emissive;\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\t#include <specularmap_fragment>\\\\n\\\\t#include <emissivemap_fragment>\\\\n\\\\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\\\n\\\\t#include <lightmap_fragment>\\\\n\\\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\\\n\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\\\n\\\\t#else\\\\n\\\\t\\\\treflectedLight.directDiffuse = vLightFront;\\\\n\\\\t#endif\\\\n\\\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\\\n\\\\t#include <aomap_fragment>\\\\n\\\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\\\n\\\\t#include <envmap_fragment>\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <dithering_fragment>\\\\n}\\\\n\\\";\\n\\n\\tvar meshlambert_vert = \\\"#define LAMBERT\\\\nvarying vec3 vLightFront;\\\\n#ifdef DOUBLE_SIDED\\\\n\\\\tvarying vec3 vLightBack;\\\\n#endif\\\\n#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <uv2_pars_vertex>\\\\n#include <envmap_pars_vertex>\\\\n#include <bsdfs>\\\\n#include <lights_pars>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <shadowmap_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <uv2_vertex>\\\\n\\\\t#include <color_vertex>\\\\n\\\\t#include <beginnormal_vertex>\\\\n\\\\t#include <morphnormal_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#include <skinnormal_vertex>\\\\n\\\\t#include <defaultnormal_vertex>\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <envmap_vertex>\\\\n\\\\t#include <lights_lambert_vertex>\\\\n\\\\t#include <shadowmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\\n\\\";\\n\\n\\tvar meshphong_frag = \\\"#define PHONG\\\\nuniform vec3 diffuse;\\\\nuniform vec3 emissive;\\\\nuniform vec3 specular;\\\\nuniform float shininess;\\\\nuniform float opacity;\\\\n#include <common>\\\\n#include <packing>\\\\n#include <dithering_pars_fragment>\\\\n#include <color_pars_fragment>\\\\n#include <uv_pars_fragment>\\\\n#include <uv2_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <aomap_pars_fragment>\\\\n#include <lightmap_pars_fragment>\\\\n#include <emissivemap_pars_fragment>\\\\n#include <envmap_pars_fragment>\\\\n#include <gradientmap_pars_fragment>\\\\n#include <fog_pars_fragment>\\\\n#include <bsdfs>\\\\n#include <lights_pars>\\\\n#include <lights_phong_pars_fragment>\\\\n#include <shadowmap_pars_fragment>\\\\n#include <bumpmap_pars_fragment>\\\\n#include <normalmap_pars_fragment>\\\\n#include <specularmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\\\n\\\\tvec3 totalEmissiveRadiance = emissive;\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\t#include <specularmap_fragment>\\\\n\\\\t#include <normal_fragment>\\\\n\\\\t#include <emissivemap_fragment>\\\\n\\\\t#include <lights_phong_fragment>\\\\n\\\\t#include <lights_template>\\\\n\\\\t#include <aomap_fragment>\\\\n\\\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\\\n\\\\t#include <envmap_fragment>\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <dithering_fragment>\\\\n}\\\\n\\\";\\n\\n\\tvar meshphong_vert = \\\"#define PHONG\\\\nvarying vec3 vViewPosition;\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\n#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <uv2_pars_vertex>\\\\n#include <displacementmap_pars_vertex>\\\\n#include <envmap_pars_vertex>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <shadowmap_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <uv2_vertex>\\\\n\\\\t#include <color_vertex>\\\\n\\\\t#include <beginnormal_vertex>\\\\n\\\\t#include <morphnormal_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#include <skinnormal_vertex>\\\\n\\\\t#include <defaultnormal_vertex>\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvNormal = normalize( transformedNormal );\\\\n#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <displacementmap_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\tvViewPosition = - mvPosition.xyz;\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <envmap_vertex>\\\\n\\\\t#include <shadowmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\\n\\\";\\n\\n\\tvar meshphysical_frag = \\\"#define PHYSICAL\\\\nuniform vec3 diffuse;\\\\nuniform vec3 emissive;\\\\nuniform float roughness;\\\\nuniform float metalness;\\\\nuniform float opacity;\\\\n#ifndef STANDARD\\\\n\\\\tuniform float clearCoat;\\\\n\\\\tuniform float clearCoatRoughness;\\\\n#endif\\\\nvarying vec3 vViewPosition;\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\n#include <common>\\\\n#include <packing>\\\\n#include <dithering_pars_fragment>\\\\n#include <color_pars_fragment>\\\\n#include <uv_pars_fragment>\\\\n#include <uv2_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <aomap_pars_fragment>\\\\n#include <lightmap_pars_fragment>\\\\n#include <emissivemap_pars_fragment>\\\\n#include <envmap_pars_fragment>\\\\n#include <fog_pars_fragment>\\\\n#include <bsdfs>\\\\n#include <cube_uv_reflection_fragment>\\\\n#include <lights_pars>\\\\n#include <lights_physical_pars_fragment>\\\\n#include <shadowmap_pars_fragment>\\\\n#include <bumpmap_pars_fragment>\\\\n#include <normalmap_pars_fragment>\\\\n#include <roughnessmap_pars_fragment>\\\\n#include <metalnessmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\\\n\\\\tvec3 totalEmissiveRadiance = emissive;\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\t#include <roughnessmap_fragment>\\\\n\\\\t#include <metalnessmap_fragment>\\\\n\\\\t#include <normal_fragment>\\\\n\\\\t#include <emissivemap_fragment>\\\\n\\\\t#include <lights_physical_fragment>\\\\n\\\\t#include <lights_template>\\\\n\\\\t#include <aomap_fragment>\\\\n\\\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <dithering_fragment>\\\\n}\\\\n\\\";\\n\\n\\tvar meshphysical_vert = \\\"#define PHYSICAL\\\\nvarying vec3 vViewPosition;\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\n#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <uv2_pars_vertex>\\\\n#include <displacementmap_pars_vertex>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <shadowmap_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <uv2_vertex>\\\\n\\\\t#include <color_vertex>\\\\n\\\\t#include <beginnormal_vertex>\\\\n\\\\t#include <morphnormal_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#include <skinnormal_vertex>\\\\n\\\\t#include <defaultnormal_vertex>\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvNormal = normalize( transformedNormal );\\\\n#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <displacementmap_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\tvViewPosition = - mvPosition.xyz;\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <shadowmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\\n\\\";\\n\\n\\tvar normal_frag = \\\"#define NORMAL\\\\nuniform float opacity;\\\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\\\n\\\\tvarying vec3 vViewPosition;\\\\n#endif\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\n#include <packing>\\\\n#include <uv_pars_fragment>\\\\n#include <bumpmap_pars_fragment>\\\\n#include <normalmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <normal_fragment>\\\\n\\\\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\\\n}\\\\n\\\";\\n\\n\\tvar normal_vert = \\\"#define NORMAL\\\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\\\n\\\\tvarying vec3 vViewPosition;\\\\n#endif\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\n#include <uv_pars_vertex>\\\\n#include <displacementmap_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <beginnormal_vertex>\\\\n\\\\t#include <morphnormal_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#include <skinnormal_vertex>\\\\n\\\\t#include <defaultnormal_vertex>\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvNormal = normalize( transformedNormal );\\\\n#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <displacementmap_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\\\n\\\\tvViewPosition = - mvPosition.xyz;\\\\n#endif\\\\n}\\\\n\\\";\\n\\n\\tvar points_frag = \\\"uniform vec3 diffuse;\\\\nuniform float opacity;\\\\n#include <common>\\\\n#include <packing>\\\\n#include <color_pars_fragment>\\\\n#include <map_particle_pars_fragment>\\\\n#include <fog_pars_fragment>\\\\n#include <shadowmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec3 outgoingLight = vec3( 0.0 );\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <map_particle_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\toutgoingLight = diffuseColor.rgb;\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n}\\\\n\\\";\\n\\n\\tvar points_vert = \\\"uniform float size;\\\\nuniform float scale;\\\\n#include <common>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <shadowmap_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <color_vertex>\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#ifdef USE_SIZEATTENUATION\\\\n\\\\t\\\\tgl_PointSize = size * ( scale / - mvPosition.z );\\\\n\\\\t#else\\\\n\\\\t\\\\tgl_PointSize = size;\\\\n\\\\t#endif\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <shadowmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\\n\\\";\\n\\n\\tvar shadow_frag = \\\"uniform vec3 color;\\\\nuniform float opacity;\\\\n#include <common>\\\\n#include <packing>\\\\n#include <fog_pars_fragment>\\\\n#include <bsdfs>\\\\n#include <lights_pars>\\\\n#include <shadowmap_pars_fragment>\\\\n#include <shadowmask_pars_fragment>\\\\nvoid main() {\\\\n\\\\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\\\n\\\\t#include <fog_fragment>\\\\n}\\\\n\\\";\\n\\n\\tvar shadow_vert = \\\"#include <fog_pars_vertex>\\\\n#include <shadowmap_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <shadowmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\\n\\\";\\n\\n\\tvar ShaderChunk = {\\n\\t\\talphamap_fragment: alphamap_fragment,\\n\\t\\talphamap_pars_fragment: alphamap_pars_fragment,\\n\\t\\talphatest_fragment: alphatest_fragment,\\n\\t\\taomap_fragment: aomap_fragment,\\n\\t\\taomap_pars_fragment: aomap_pars_fragment,\\n\\t\\tbegin_vertex: begin_vertex,\\n\\t\\tbeginnormal_vertex: beginnormal_vertex,\\n\\t\\tbsdfs: bsdfs,\\n\\t\\tbumpmap_pars_fragment: bumpmap_pars_fragment,\\n\\t\\tclipping_planes_fragment: clipping_planes_fragment,\\n\\t\\tclipping_planes_pars_fragment: clipping_planes_pars_fragment,\\n\\t\\tclipping_planes_pars_vertex: clipping_planes_pars_vertex,\\n\\t\\tclipping_planes_vertex: clipping_planes_vertex,\\n\\t\\tcolor_fragment: color_fragment,\\n\\t\\tcolor_pars_fragment: color_pars_fragment,\\n\\t\\tcolor_pars_vertex: color_pars_vertex,\\n\\t\\tcolor_vertex: color_vertex,\\n\\t\\tcommon: common,\\n\\t\\tcube_uv_reflection_fragment: cube_uv_reflection_fragment,\\n\\t\\tdefaultnormal_vertex: defaultnormal_vertex,\\n\\t\\tdisplacementmap_pars_vertex: displacementmap_pars_vertex,\\n\\t\\tdisplacementmap_vertex: displacementmap_vertex,\\n\\t\\temissivemap_fragment: emissivemap_fragment,\\n\\t\\temissivemap_pars_fragment: emissivemap_pars_fragment,\\n\\t\\tencodings_fragment: encodings_fragment,\\n\\t\\tencodings_pars_fragment: encodings_pars_fragment,\\n\\t\\tenvmap_fragment: envmap_fragment,\\n\\t\\tenvmap_pars_fragment: envmap_pars_fragment,\\n\\t\\tenvmap_pars_vertex: envmap_pars_vertex,\\n\\t\\tenvmap_vertex: envmap_vertex,\\n\\t\\tfog_vertex: fog_vertex,\\n\\t\\tfog_pars_vertex: fog_pars_vertex,\\n\\t\\tfog_fragment: fog_fragment,\\n\\t\\tfog_pars_fragment: fog_pars_fragment,\\n\\t\\tgradientmap_pars_fragment: gradientmap_pars_fragment,\\n\\t\\tlightmap_fragment: lightmap_fragment,\\n\\t\\tlightmap_pars_fragment: lightmap_pars_fragment,\\n\\t\\tlights_lambert_vertex: lights_lambert_vertex,\\n\\t\\tlights_pars: lights_pars,\\n\\t\\tlights_phong_fragment: lights_phong_fragment,\\n\\t\\tlights_phong_pars_fragment: lights_phong_pars_fragment,\\n\\t\\tlights_physical_fragment: lights_physical_fragment,\\n\\t\\tlights_physical_pars_fragment: lights_physical_pars_fragment,\\n\\t\\tlights_template: lights_template,\\n\\t\\tlogdepthbuf_fragment: logdepthbuf_fragment,\\n\\t\\tlogdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\\n\\t\\tlogdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\\n\\t\\tlogdepthbuf_vertex: logdepthbuf_vertex,\\n\\t\\tmap_fragment: map_fragment,\\n\\t\\tmap_pars_fragment: map_pars_fragment,\\n\\t\\tmap_particle_fragment: map_particle_fragment,\\n\\t\\tmap_particle_pars_fragment: map_particle_pars_fragment,\\n\\t\\tmetalnessmap_fragment: metalnessmap_fragment,\\n\\t\\tmetalnessmap_pars_fragment: metalnessmap_pars_fragment,\\n\\t\\tmorphnormal_vertex: morphnormal_vertex,\\n\\t\\tmorphtarget_pars_vertex: morphtarget_pars_vertex,\\n\\t\\tmorphtarget_vertex: morphtarget_vertex,\\n\\t\\tnormal_fragment: normal_fragment,\\n\\t\\tnormalmap_pars_fragment: normalmap_pars_fragment,\\n\\t\\tpacking: packing,\\n\\t\\tpremultiplied_alpha_fragment: premultiplied_alpha_fragment,\\n\\t\\tproject_vertex: project_vertex,\\n\\t\\tdithering_fragment: dithering_fragment,\\n\\t\\tdithering_pars_fragment: dithering_pars_fragment,\\n\\t\\troughnessmap_fragment: roughnessmap_fragment,\\n\\t\\troughnessmap_pars_fragment: roughnessmap_pars_fragment,\\n\\t\\tshadowmap_pars_fragment: shadowmap_pars_fragment,\\n\\t\\tshadowmap_pars_vertex: shadowmap_pars_vertex,\\n\\t\\tshadowmap_vertex: shadowmap_vertex,\\n\\t\\tshadowmask_pars_fragment: shadowmask_pars_fragment,\\n\\t\\tskinbase_vertex: skinbase_vertex,\\n\\t\\tskinning_pars_vertex: skinning_pars_vertex,\\n\\t\\tskinning_vertex: skinning_vertex,\\n\\t\\tskinnormal_vertex: skinnormal_vertex,\\n\\t\\tspecularmap_fragment: specularmap_fragment,\\n\\t\\tspecularmap_pars_fragment: specularmap_pars_fragment,\\n\\t\\ttonemapping_fragment: tonemapping_fragment,\\n\\t\\ttonemapping_pars_fragment: tonemapping_pars_fragment,\\n\\t\\tuv_pars_fragment: uv_pars_fragment,\\n\\t\\tuv_pars_vertex: uv_pars_vertex,\\n\\t\\tuv_vertex: uv_vertex,\\n\\t\\tuv2_pars_fragment: uv2_pars_fragment,\\n\\t\\tuv2_pars_vertex: uv2_pars_vertex,\\n\\t\\tuv2_vertex: uv2_vertex,\\n\\t\\tworldpos_vertex: worldpos_vertex,\\n\\n\\t\\tcube_frag: cube_frag,\\n\\t\\tcube_vert: cube_vert,\\n\\t\\tdepth_frag: depth_frag,\\n\\t\\tdepth_vert: depth_vert,\\n\\t\\tdistanceRGBA_frag: distanceRGBA_frag,\\n\\t\\tdistanceRGBA_vert: distanceRGBA_vert,\\n\\t\\tequirect_frag: equirect_frag,\\n\\t\\tequirect_vert: equirect_vert,\\n\\t\\tlinedashed_frag: linedashed_frag,\\n\\t\\tlinedashed_vert: linedashed_vert,\\n\\t\\tmeshbasic_frag: meshbasic_frag,\\n\\t\\tmeshbasic_vert: meshbasic_vert,\\n\\t\\tmeshlambert_frag: meshlambert_frag,\\n\\t\\tmeshlambert_vert: meshlambert_vert,\\n\\t\\tmeshphong_frag: meshphong_frag,\\n\\t\\tmeshphong_vert: meshphong_vert,\\n\\t\\tmeshphysical_frag: meshphysical_frag,\\n\\t\\tmeshphysical_vert: meshphysical_vert,\\n\\t\\tnormal_frag: normal_frag,\\n\\t\\tnormal_vert: normal_vert,\\n\\t\\tpoints_frag: points_frag,\\n\\t\\tpoints_vert: points_vert,\\n\\t\\tshadow_frag: shadow_frag,\\n\\t\\tshadow_vert: shadow_vert\\n\\t};\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t */\\n\\n\\tvar ShaderLib = {\\n\\n\\t\\tbasic: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.common,\\n\\t\\t\\t\\tUniformsLib.specularmap,\\n\\t\\t\\t\\tUniformsLib.envmap,\\n\\t\\t\\t\\tUniformsLib.aomap,\\n\\t\\t\\t\\tUniformsLib.lightmap,\\n\\t\\t\\t\\tUniformsLib.fog\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.meshbasic_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.meshbasic_frag\\n\\n\\t\\t},\\n\\n\\t\\tlambert: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.common,\\n\\t\\t\\t\\tUniformsLib.specularmap,\\n\\t\\t\\t\\tUniformsLib.envmap,\\n\\t\\t\\t\\tUniformsLib.aomap,\\n\\t\\t\\t\\tUniformsLib.lightmap,\\n\\t\\t\\t\\tUniformsLib.emissivemap,\\n\\t\\t\\t\\tUniformsLib.fog,\\n\\t\\t\\t\\tUniformsLib.lights,\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\temissive: { value: new Color( 0x000000 ) }\\n\\t\\t\\t\\t}\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.meshlambert_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.meshlambert_frag\\n\\n\\t\\t},\\n\\n\\t\\tphong: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.common,\\n\\t\\t\\t\\tUniformsLib.specularmap,\\n\\t\\t\\t\\tUniformsLib.envmap,\\n\\t\\t\\t\\tUniformsLib.aomap,\\n\\t\\t\\t\\tUniformsLib.lightmap,\\n\\t\\t\\t\\tUniformsLib.emissivemap,\\n\\t\\t\\t\\tUniformsLib.bumpmap,\\n\\t\\t\\t\\tUniformsLib.normalmap,\\n\\t\\t\\t\\tUniformsLib.displacementmap,\\n\\t\\t\\t\\tUniformsLib.gradientmap,\\n\\t\\t\\t\\tUniformsLib.fog,\\n\\t\\t\\t\\tUniformsLib.lights,\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\temissive: { value: new Color( 0x000000 ) },\\n\\t\\t\\t\\t\\tspecular: { value: new Color( 0x111111 ) },\\n\\t\\t\\t\\t\\tshininess: { value: 30 }\\n\\t\\t\\t\\t}\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.meshphong_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.meshphong_frag\\n\\n\\t\\t},\\n\\n\\t\\tstandard: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.common,\\n\\t\\t\\t\\tUniformsLib.envmap,\\n\\t\\t\\t\\tUniformsLib.aomap,\\n\\t\\t\\t\\tUniformsLib.lightmap,\\n\\t\\t\\t\\tUniformsLib.emissivemap,\\n\\t\\t\\t\\tUniformsLib.bumpmap,\\n\\t\\t\\t\\tUniformsLib.normalmap,\\n\\t\\t\\t\\tUniformsLib.displacementmap,\\n\\t\\t\\t\\tUniformsLib.roughnessmap,\\n\\t\\t\\t\\tUniformsLib.metalnessmap,\\n\\t\\t\\t\\tUniformsLib.fog,\\n\\t\\t\\t\\tUniformsLib.lights,\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\temissive: { value: new Color( 0x000000 ) },\\n\\t\\t\\t\\t\\troughness: { value: 0.5 },\\n\\t\\t\\t\\t\\tmetalness: { value: 0.5 },\\n\\t\\t\\t\\t\\tenvMapIntensity: { value: 1 } // temporary\\n\\t\\t\\t\\t}\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.meshphysical_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.meshphysical_frag\\n\\n\\t\\t},\\n\\n\\t\\tpoints: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.points,\\n\\t\\t\\t\\tUniformsLib.fog\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.points_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.points_frag\\n\\n\\t\\t},\\n\\n\\t\\tdashed: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.common,\\n\\t\\t\\t\\tUniformsLib.fog,\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tscale: { value: 1 },\\n\\t\\t\\t\\t\\tdashSize: { value: 1 },\\n\\t\\t\\t\\t\\ttotalSize: { value: 2 }\\n\\t\\t\\t\\t}\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.linedashed_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.linedashed_frag\\n\\n\\t\\t},\\n\\n\\t\\tdepth: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.common,\\n\\t\\t\\t\\tUniformsLib.displacementmap\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.depth_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.depth_frag\\n\\n\\t\\t},\\n\\n\\t\\tnormal: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.common,\\n\\t\\t\\t\\tUniformsLib.bumpmap,\\n\\t\\t\\t\\tUniformsLib.normalmap,\\n\\t\\t\\t\\tUniformsLib.displacementmap,\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\topacity: { value: 1.0 }\\n\\t\\t\\t\\t}\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.normal_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.normal_frag\\n\\n\\t\\t},\\n\\n\\t\\t/* -------------------------------------------------------------------------\\n\\t\\t//\\tCube map shader\\n\\t\\t ------------------------------------------------------------------------- */\\n\\n\\t\\tcube: {\\n\\n\\t\\t\\tuniforms: {\\n\\t\\t\\t\\ttCube: { value: null },\\n\\t\\t\\t\\ttFlip: { value: - 1 },\\n\\t\\t\\t\\topacity: { value: 1.0 }\\n\\t\\t\\t},\\n\\n\\t\\t\\tvertexShader: ShaderChunk.cube_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.cube_frag\\n\\n\\t\\t},\\n\\n\\t\\tequirect: {\\n\\n\\t\\t\\tuniforms: {\\n\\t\\t\\t\\ttEquirect: { value: null },\\n\\t\\t\\t},\\n\\n\\t\\t\\tvertexShader: ShaderChunk.equirect_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.equirect_frag\\n\\n\\t\\t},\\n\\n\\t\\tdistanceRGBA: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.common,\\n\\t\\t\\t\\tUniformsLib.displacementmap,\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treferencePosition: { value: new Vector3() },\\n\\t\\t\\t\\t\\tnearDistance: { value: 1 },\\n\\t\\t\\t\\t\\tfarDistance: { value: 1000 }\\n\\t\\t\\t\\t}\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.distanceRGBA_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.distanceRGBA_frag\\n\\n\\t\\t},\\n\\n\\t\\tshadow: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.lights,\\n\\t\\t\\t\\tUniformsLib.fog,\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcolor: { value: new Color( 0x00000 ) },\\n\\t\\t\\t\\t\\topacity: { value: 1.0 }\\n\\t\\t\\t\\t},\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.shadow_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.shadow_frag\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tShaderLib.physical = {\\n\\n\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\tShaderLib.standard.uniforms,\\n\\t\\t\\t{\\n\\t\\t\\t\\tclearCoat: { value: 0 },\\n\\t\\t\\t\\tclearCoatRoughness: { value: 0 }\\n\\t\\t\\t}\\n\\t\\t] ),\\n\\n\\t\\tvertexShader: ShaderChunk.meshphysical_vert,\\n\\t\\tfragmentShader: ShaderChunk.meshphysical_frag\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author bhouston / http://clara.io\\n\\t */\\n\\n\\tfunction Box2( min, max ) {\\n\\n\\t\\tthis.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );\\n\\t\\tthis.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );\\n\\n\\t}\\n\\n\\tObject.assign( Box2.prototype, {\\n\\n\\t\\tset: function ( min, max ) {\\n\\n\\t\\t\\tthis.min.copy( min );\\n\\t\\t\\tthis.max.copy( max );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromPoints: function ( points ) {\\n\\n\\t\\t\\tthis.makeEmpty();\\n\\n\\t\\t\\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.expandByPoint( points[ i ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromCenterAndSize: function () {\\n\\n\\t\\t\\tvar v1 = new Vector2();\\n\\n\\t\\t\\treturn function setFromCenterAndSize( center, size ) {\\n\\n\\t\\t\\t\\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\\n\\t\\t\\t\\tthis.min.copy( center ).sub( halfSize );\\n\\t\\t\\t\\tthis.max.copy( center ).add( halfSize );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( box ) {\\n\\n\\t\\t\\tthis.min.copy( box.min );\\n\\t\\t\\tthis.max.copy( box.max );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeEmpty: function () {\\n\\n\\t\\t\\tthis.min.x = this.min.y = + Infinity;\\n\\t\\t\\tthis.max.x = this.max.y = - Infinity;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tisEmpty: function () {\\n\\n\\t\\t\\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\\n\\n\\t\\t\\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\\n\\n\\t\\t},\\n\\n\\t\\tgetCenter: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector2();\\n\\t\\t\\treturn this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\\n\\n\\t\\t},\\n\\n\\t\\tgetSize: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector2();\\n\\t\\t\\treturn this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );\\n\\n\\t\\t},\\n\\n\\t\\texpandByPoint: function ( point ) {\\n\\n\\t\\t\\tthis.min.min( point );\\n\\t\\t\\tthis.max.max( point );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\texpandByVector: function ( vector ) {\\n\\n\\t\\t\\tthis.min.sub( vector );\\n\\t\\t\\tthis.max.add( vector );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\texpandByScalar: function ( scalar ) {\\n\\n\\t\\t\\tthis.min.addScalar( - scalar );\\n\\t\\t\\tthis.max.addScalar( scalar );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcontainsPoint: function ( point ) {\\n\\n\\t\\t\\treturn point.x < this.min.x || point.x > this.max.x ||\\n\\t\\t\\t\\tpoint.y < this.min.y || point.y > this.max.y ? false : true;\\n\\n\\t\\t},\\n\\n\\t\\tcontainsBox: function ( box ) {\\n\\n\\t\\t\\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\\n\\t\\t\\t\\tthis.min.y <= box.min.y && box.max.y <= this.max.y;\\n\\n\\t\\t},\\n\\n\\t\\tgetParameter: function ( point, optionalTarget ) {\\n\\n\\t\\t\\t// This can potentially have a divide by zero if the box\\n\\t\\t\\t// has a size dimension of 0.\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector2();\\n\\n\\t\\t\\treturn result.set(\\n\\t\\t\\t\\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\\n\\t\\t\\t\\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\\n\\t\\t\\t);\\n\\n\\t\\t},\\n\\n\\t\\tintersectsBox: function ( box ) {\\n\\n\\t\\t\\t// using 4 splitting planes to rule out intersections\\n\\n\\t\\t\\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\\n\\t\\t\\t\\tbox.max.y < this.min.y || box.min.y > this.max.y ? false : true;\\n\\n\\t\\t},\\n\\n\\t\\tclampPoint: function ( point, optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector2();\\n\\t\\t\\treturn result.copy( point ).clamp( this.min, this.max );\\n\\n\\t\\t},\\n\\n\\t\\tdistanceToPoint: function () {\\n\\n\\t\\t\\tvar v1 = new Vector2();\\n\\n\\t\\t\\treturn function distanceToPoint( point ) {\\n\\n\\t\\t\\t\\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\\n\\t\\t\\t\\treturn clampedPoint.sub( point ).length();\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tintersect: function ( box ) {\\n\\n\\t\\t\\tthis.min.max( box.min );\\n\\t\\t\\tthis.max.min( box.max );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tunion: function ( box ) {\\n\\n\\t\\t\\tthis.min.min( box.min );\\n\\t\\t\\tthis.max.max( box.max );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttranslate: function ( offset ) {\\n\\n\\t\\t\\tthis.min.add( offset );\\n\\t\\t\\tthis.max.add( offset );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( box ) {\\n\\n\\t\\t\\treturn box.min.equals( this.min ) && box.max.equals( this.max );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction WebGLFlareRenderer( renderer, gl, state, textures, capabilities ) {\\n\\n\\t\\tvar vertexBuffer, elementBuffer;\\n\\t\\tvar shader, program, attributes, uniforms;\\n\\n\\t\\tvar tempTexture, occlusionTexture;\\n\\n\\t\\tfunction init() {\\n\\n\\t\\t\\tvar vertices = new Float32Array( [\\n\\t\\t\\t\\t- 1, - 1, 0, 0,\\n\\t\\t\\t\\t  1, - 1, 1, 0,\\n\\t\\t\\t\\t  1, 1, 1, 1,\\n\\t\\t\\t\\t- 1, 1, 0, 1\\n\\t\\t\\t] );\\n\\n\\t\\t\\tvar faces = new Uint16Array( [\\n\\t\\t\\t\\t0, 1, 2,\\n\\t\\t\\t\\t0, 2, 3\\n\\t\\t\\t] );\\n\\n\\t\\t\\t// buffers\\n\\n\\t\\t\\tvertexBuffer = gl.createBuffer();\\n\\t\\t\\telementBuffer = gl.createBuffer();\\n\\n\\t\\t\\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\\n\\t\\t\\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\\n\\n\\t\\t\\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\\n\\t\\t\\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\\n\\n\\t\\t\\t// textures\\n\\n\\t\\t\\ttempTexture = gl.createTexture();\\n\\t\\t\\tocclusionTexture = gl.createTexture();\\n\\n\\t\\t\\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\\n\\t\\t\\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\\n\\n\\t\\t\\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\\n\\t\\t\\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\\n\\n\\t\\t\\tshader = {\\n\\n\\t\\t\\t\\tvertexShader: [\\n\\n\\t\\t\\t\\t\\t'uniform lowp int renderType;',\\n\\n\\t\\t\\t\\t\\t'uniform vec3 screenPosition;',\\n\\t\\t\\t\\t\\t'uniform vec2 scale;',\\n\\t\\t\\t\\t\\t'uniform float rotation;',\\n\\n\\t\\t\\t\\t\\t'uniform sampler2D occlusionMap;',\\n\\n\\t\\t\\t\\t\\t'attribute vec2 position;',\\n\\t\\t\\t\\t\\t'attribute vec2 uv;',\\n\\n\\t\\t\\t\\t\\t'varying vec2 vUV;',\\n\\t\\t\\t\\t\\t'varying float vVisibility;',\\n\\n\\t\\t\\t\\t\\t'void main() {',\\n\\n\\t\\t\\t\\t\\t'\\tvUV = uv;',\\n\\n\\t\\t\\t\\t\\t'\\tvec2 pos = position;',\\n\\n\\t\\t\\t\\t\\t'\\tif ( renderType == 2 ) {',\\n\\n\\t\\t\\t\\t\\t'\\t\\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );',\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );',\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );',\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );',\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );',\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );',\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );',\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );',\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );',\\n\\n\\t\\t\\t\\t\\t'\\t\\tvVisibility =        visibility.r / 9.0;',\\n\\t\\t\\t\\t\\t'\\t\\tvVisibility *= 1.0 - visibility.g / 9.0;',\\n\\t\\t\\t\\t\\t'\\t\\tvVisibility *=       visibility.b / 9.0;',\\n\\t\\t\\t\\t\\t'\\t\\tvVisibility *= 1.0 - visibility.a / 9.0;',\\n\\n\\t\\t\\t\\t\\t'\\t\\tpos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;',\\n\\t\\t\\t\\t\\t'\\t\\tpos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;',\\n\\n\\t\\t\\t\\t\\t'\\t}',\\n\\n\\t\\t\\t\\t\\t'\\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );',\\n\\n\\t\\t\\t\\t\\t'}'\\n\\n\\t\\t\\t\\t].join( '\\\\n' ),\\n\\n\\t\\t\\t\\tfragmentShader: [\\n\\n\\t\\t\\t\\t\\t'uniform lowp int renderType;',\\n\\n\\t\\t\\t\\t\\t'uniform sampler2D map;',\\n\\t\\t\\t\\t\\t'uniform float opacity;',\\n\\t\\t\\t\\t\\t'uniform vec3 color;',\\n\\n\\t\\t\\t\\t\\t'varying vec2 vUV;',\\n\\t\\t\\t\\t\\t'varying float vVisibility;',\\n\\n\\t\\t\\t\\t\\t'void main() {',\\n\\n\\t\\t\\t\\t\\t// pink square\\n\\n\\t\\t\\t\\t\\t'\\tif ( renderType == 0 ) {',\\n\\n\\t\\t\\t\\t\\t'\\t\\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );',\\n\\n\\t\\t\\t\\t\\t// restore\\n\\n\\t\\t\\t\\t\\t'\\t} else if ( renderType == 1 ) {',\\n\\n\\t\\t\\t\\t\\t'\\t\\tgl_FragColor = texture2D( map, vUV );',\\n\\n\\t\\t\\t\\t\\t// flare\\n\\n\\t\\t\\t\\t\\t'\\t} else {',\\n\\n\\t\\t\\t\\t\\t'\\t\\tvec4 texture = texture2D( map, vUV );',\\n\\t\\t\\t\\t\\t'\\t\\ttexture.a *= opacity * vVisibility;',\\n\\t\\t\\t\\t\\t'\\t\\tgl_FragColor = texture;',\\n\\t\\t\\t\\t\\t'\\t\\tgl_FragColor.rgb *= color;',\\n\\n\\t\\t\\t\\t\\t'\\t}',\\n\\n\\t\\t\\t\\t\\t'}'\\n\\n\\t\\t\\t\\t].join( '\\\\n' )\\n\\n\\t\\t\\t};\\n\\n\\t\\t\\tprogram = createProgram( shader );\\n\\n\\t\\t\\tattributes = {\\n\\t\\t\\t\\tvertex: gl.getAttribLocation( program, 'position' ),\\n\\t\\t\\t\\tuv: gl.getAttribLocation( program, 'uv' )\\n\\t\\t\\t};\\n\\n\\t\\t\\tuniforms = {\\n\\t\\t\\t\\trenderType: gl.getUniformLocation( program, 'renderType' ),\\n\\t\\t\\t\\tmap: gl.getUniformLocation( program, 'map' ),\\n\\t\\t\\t\\tocclusionMap: gl.getUniformLocation( program, 'occlusionMap' ),\\n\\t\\t\\t\\topacity: gl.getUniformLocation( program, 'opacity' ),\\n\\t\\t\\t\\tcolor: gl.getUniformLocation( program, 'color' ),\\n\\t\\t\\t\\tscale: gl.getUniformLocation( program, 'scale' ),\\n\\t\\t\\t\\trotation: gl.getUniformLocation( program, 'rotation' ),\\n\\t\\t\\t\\tscreenPosition: gl.getUniformLocation( program, 'screenPosition' )\\n\\t\\t\\t};\\n\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t * Render lens flares\\n\\t\\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\\n\\t\\t *         reads these back and calculates occlusion.\\n\\t\\t */\\n\\n\\t\\tthis.render = function ( flares, scene, camera, viewport ) {\\n\\n\\t\\t\\tif ( flares.length === 0 ) return;\\n\\n\\t\\t\\tvar tempPosition = new Vector3();\\n\\n\\t\\t\\tvar invAspect = viewport.w / viewport.z,\\n\\t\\t\\t\\thalfViewportWidth = viewport.z * 0.5,\\n\\t\\t\\t\\thalfViewportHeight = viewport.w * 0.5;\\n\\n\\t\\t\\tvar size = 16 / viewport.w,\\n\\t\\t\\t\\tscale = new Vector2( size * invAspect, size );\\n\\n\\t\\t\\tvar screenPosition = new Vector3( 1, 1, 0 ),\\n\\t\\t\\t\\tscreenPositionPixels = new Vector2( 1, 1 );\\n\\n\\t\\t\\tvar validArea = new Box2();\\n\\n\\t\\t\\tvalidArea.min.set( viewport.x, viewport.y );\\n\\t\\t\\tvalidArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );\\n\\n\\t\\t\\tif ( program === undefined ) {\\n\\n\\t\\t\\t\\tinit();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tstate.useProgram( program );\\n\\n\\t\\t\\tstate.initAttributes();\\n\\t\\t\\tstate.enableAttribute( attributes.vertex );\\n\\t\\t\\tstate.enableAttribute( attributes.uv );\\n\\t\\t\\tstate.disableUnusedAttributes();\\n\\n\\t\\t\\t// loop through all lens flares to update their occlusion and positions\\n\\t\\t\\t// setup gl and common used attribs/uniforms\\n\\n\\t\\t\\tgl.uniform1i( uniforms.occlusionMap, 0 );\\n\\t\\t\\tgl.uniform1i( uniforms.map, 1 );\\n\\n\\t\\t\\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\\n\\t\\t\\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\\n\\t\\t\\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\\n\\n\\t\\t\\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\\n\\n\\t\\t\\tstate.disable( gl.CULL_FACE );\\n\\t\\t\\tstate.buffers.depth.setMask( false );\\n\\n\\t\\t\\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tsize = 16 / viewport.w;\\n\\t\\t\\t\\tscale.set( size * invAspect, size );\\n\\n\\t\\t\\t\\t// calc object screen position\\n\\n\\t\\t\\t\\tvar flare = flares[ i ];\\n\\n\\t\\t\\t\\ttempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );\\n\\n\\t\\t\\t\\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\\n\\t\\t\\t\\ttempPosition.applyMatrix4( camera.projectionMatrix );\\n\\n\\t\\t\\t\\t// setup arrays for gl programs\\n\\n\\t\\t\\t\\tscreenPosition.copy( tempPosition );\\n\\n\\t\\t\\t\\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\\n\\n\\t\\t\\t\\tscreenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;\\n\\t\\t\\t\\tscreenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;\\n\\n\\t\\t\\t\\t// screen cull\\n\\n\\t\\t\\t\\tif ( validArea.containsPoint( screenPositionPixels ) === true ) {\\n\\n\\t\\t\\t\\t\\t// save current RGB to temp texture\\n\\n\\t\\t\\t\\t\\tstate.activeTexture( gl.TEXTURE0 );\\n\\t\\t\\t\\t\\tstate.bindTexture( gl.TEXTURE_2D, null );\\n\\t\\t\\t\\t\\tstate.activeTexture( gl.TEXTURE1 );\\n\\t\\t\\t\\t\\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\\n\\t\\t\\t\\t\\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\\n\\n\\n\\t\\t\\t\\t\\t// render pink quad\\n\\n\\t\\t\\t\\t\\tgl.uniform1i( uniforms.renderType, 0 );\\n\\t\\t\\t\\t\\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\\n\\t\\t\\t\\t\\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\\n\\n\\t\\t\\t\\t\\tstate.disable( gl.BLEND );\\n\\t\\t\\t\\t\\tstate.enable( gl.DEPTH_TEST );\\n\\n\\t\\t\\t\\t\\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\\n\\n\\n\\t\\t\\t\\t\\t// copy result to occlusionMap\\n\\n\\t\\t\\t\\t\\tstate.activeTexture( gl.TEXTURE0 );\\n\\t\\t\\t\\t\\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\\n\\t\\t\\t\\t\\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\\n\\n\\n\\t\\t\\t\\t\\t// restore graphics\\n\\n\\t\\t\\t\\t\\tgl.uniform1i( uniforms.renderType, 1 );\\n\\t\\t\\t\\t\\tstate.disable( gl.DEPTH_TEST );\\n\\n\\t\\t\\t\\t\\tstate.activeTexture( gl.TEXTURE1 );\\n\\t\\t\\t\\t\\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\\n\\t\\t\\t\\t\\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\\n\\n\\n\\t\\t\\t\\t\\t// update object positions\\n\\n\\t\\t\\t\\t\\tflare.positionScreen.copy( screenPosition );\\n\\n\\t\\t\\t\\t\\tif ( flare.customUpdateCallback ) {\\n\\n\\t\\t\\t\\t\\t\\tflare.customUpdateCallback( flare );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tflare.updateLensFlares();\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// render flares\\n\\n\\t\\t\\t\\t\\tgl.uniform1i( uniforms.renderType, 2 );\\n\\t\\t\\t\\t\\tstate.enable( gl.BLEND );\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar sprite = flare.lensFlares[ j ];\\n\\n\\t\\t\\t\\t\\t\\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tscreenPosition.x = sprite.x;\\n\\t\\t\\t\\t\\t\\t\\tscreenPosition.y = sprite.y;\\n\\t\\t\\t\\t\\t\\t\\tscreenPosition.z = sprite.z;\\n\\n\\t\\t\\t\\t\\t\\t\\tsize = sprite.size * sprite.scale / viewport.w;\\n\\n\\t\\t\\t\\t\\t\\t\\tscale.x = size * invAspect;\\n\\t\\t\\t\\t\\t\\t\\tscale.y = size;\\n\\n\\t\\t\\t\\t\\t\\t\\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\\n\\t\\t\\t\\t\\t\\t\\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\\n\\t\\t\\t\\t\\t\\t\\tgl.uniform1f( uniforms.rotation, sprite.rotation );\\n\\n\\t\\t\\t\\t\\t\\t\\tgl.uniform1f( uniforms.opacity, sprite.opacity );\\n\\t\\t\\t\\t\\t\\t\\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\\n\\n\\t\\t\\t\\t\\t\\t\\tstate.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\\n\\n\\t\\t\\t\\t\\t\\t\\ttextures.setTexture2D( sprite.texture, 1 );\\n\\n\\t\\t\\t\\t\\t\\t\\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// restore gl\\n\\n\\t\\t\\tstate.enable( gl.CULL_FACE );\\n\\t\\t\\tstate.enable( gl.DEPTH_TEST );\\n\\t\\t\\tstate.buffers.depth.setMask( true );\\n\\n\\t\\t\\tstate.reset();\\n\\n\\t\\t};\\n\\n\\t\\tfunction createProgram( shader ) {\\n\\n\\t\\t\\tvar program = gl.createProgram();\\n\\n\\t\\t\\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\\n\\t\\t\\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\\n\\n\\t\\t\\tvar prefix = 'precision ' + capabilities.precision + ' float;\\\\n';\\n\\n\\t\\t\\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\\n\\t\\t\\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\\n\\n\\t\\t\\tgl.compileShader( fragmentShader );\\n\\t\\t\\tgl.compileShader( vertexShader );\\n\\n\\t\\t\\tgl.attachShader( program, fragmentShader );\\n\\t\\t\\tgl.attachShader( program, vertexShader );\\n\\n\\t\\t\\tgl.linkProgram( program );\\n\\n\\t\\t\\treturn program;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\\n\\n\\t\\tTexture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\\n\\n\\t\\tthis.needsUpdate = true;\\n\\n\\t}\\n\\n\\tCanvasTexture.prototype = Object.create( Texture.prototype );\\n\\tCanvasTexture.prototype.constructor = CanvasTexture;\\n\\n\\t/**\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction WebGLSpriteRenderer( renderer, gl, state, textures, capabilities ) {\\n\\n\\t\\tvar vertexBuffer, elementBuffer;\\n\\t\\tvar program, attributes, uniforms;\\n\\n\\t\\tvar texture;\\n\\n\\t\\t// decompose matrixWorld\\n\\n\\t\\tvar spritePosition = new Vector3();\\n\\t\\tvar spriteRotation = new Quaternion();\\n\\t\\tvar spriteScale = new Vector3();\\n\\n\\t\\tfunction init() {\\n\\n\\t\\t\\tvar vertices = new Float32Array( [\\n\\t\\t\\t\\t- 0.5, - 0.5, 0, 0,\\n\\t\\t\\t\\t  0.5, - 0.5, 1, 0,\\n\\t\\t\\t\\t  0.5, 0.5, 1, 1,\\n\\t\\t\\t\\t- 0.5, 0.5, 0, 1\\n\\t\\t\\t] );\\n\\n\\t\\t\\tvar faces = new Uint16Array( [\\n\\t\\t\\t\\t0, 1, 2,\\n\\t\\t\\t\\t0, 2, 3\\n\\t\\t\\t] );\\n\\n\\t\\t\\tvertexBuffer = gl.createBuffer();\\n\\t\\t\\telementBuffer = gl.createBuffer();\\n\\n\\t\\t\\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\\n\\t\\t\\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\\n\\n\\t\\t\\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\\n\\t\\t\\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\\n\\n\\t\\t\\tprogram = createProgram();\\n\\n\\t\\t\\tattributes = {\\n\\t\\t\\t\\tposition: gl.getAttribLocation( program, 'position' ),\\n\\t\\t\\t\\tuv: gl.getAttribLocation( program, 'uv' )\\n\\t\\t\\t};\\n\\n\\t\\t\\tuniforms = {\\n\\t\\t\\t\\tuvOffset: gl.getUniformLocation( program, 'uvOffset' ),\\n\\t\\t\\t\\tuvScale: gl.getUniformLocation( program, 'uvScale' ),\\n\\n\\t\\t\\t\\trotation: gl.getUniformLocation( program, 'rotation' ),\\n\\t\\t\\t\\tscale: gl.getUniformLocation( program, 'scale' ),\\n\\n\\t\\t\\t\\tcolor: gl.getUniformLocation( program, 'color' ),\\n\\t\\t\\t\\tmap: gl.getUniformLocation( program, 'map' ),\\n\\t\\t\\t\\topacity: gl.getUniformLocation( program, 'opacity' ),\\n\\n\\t\\t\\t\\tmodelViewMatrix: gl.getUniformLocation( program, 'modelViewMatrix' ),\\n\\t\\t\\t\\tprojectionMatrix: gl.getUniformLocation( program, 'projectionMatrix' ),\\n\\n\\t\\t\\t\\tfogType: gl.getUniformLocation( program, 'fogType' ),\\n\\t\\t\\t\\tfogDensity: gl.getUniformLocation( program, 'fogDensity' ),\\n\\t\\t\\t\\tfogNear: gl.getUniformLocation( program, 'fogNear' ),\\n\\t\\t\\t\\tfogFar: gl.getUniformLocation( program, 'fogFar' ),\\n\\t\\t\\t\\tfogColor: gl.getUniformLocation( program, 'fogColor' ),\\n\\t\\t\\t\\tfogDepth: gl.getUniformLocation( program, 'fogDepth' ),\\n\\n\\t\\t\\t\\talphaTest: gl.getUniformLocation( program, 'alphaTest' )\\n\\t\\t\\t};\\n\\n\\t\\t\\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\\n\\t\\t\\tcanvas.width = 8;\\n\\t\\t\\tcanvas.height = 8;\\n\\n\\t\\t\\tvar context = canvas.getContext( '2d' );\\n\\t\\t\\tcontext.fillStyle = 'white';\\n\\t\\t\\tcontext.fillRect( 0, 0, 8, 8 );\\n\\n\\t\\t\\ttexture = new CanvasTexture( canvas );\\n\\n\\t\\t}\\n\\n\\t\\tthis.render = function ( sprites, scene, camera ) {\\n\\n\\t\\t\\tif ( sprites.length === 0 ) return;\\n\\n\\t\\t\\t// setup gl\\n\\n\\t\\t\\tif ( program === undefined ) {\\n\\n\\t\\t\\t\\tinit();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tstate.useProgram( program );\\n\\n\\t\\t\\tstate.initAttributes();\\n\\t\\t\\tstate.enableAttribute( attributes.position );\\n\\t\\t\\tstate.enableAttribute( attributes.uv );\\n\\t\\t\\tstate.disableUnusedAttributes();\\n\\n\\t\\t\\tstate.disable( gl.CULL_FACE );\\n\\t\\t\\tstate.enable( gl.BLEND );\\n\\n\\t\\t\\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\\n\\t\\t\\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\\n\\t\\t\\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\\n\\n\\t\\t\\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\\n\\n\\t\\t\\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\\n\\n\\t\\t\\tstate.activeTexture( gl.TEXTURE0 );\\n\\t\\t\\tgl.uniform1i( uniforms.map, 0 );\\n\\n\\t\\t\\tvar oldFogType = 0;\\n\\t\\t\\tvar sceneFogType = 0;\\n\\t\\t\\tvar fog = scene.fog;\\n\\n\\t\\t\\tif ( fog ) {\\n\\n\\t\\t\\t\\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\\n\\n\\t\\t\\t\\tif ( fog.isFog ) {\\n\\n\\t\\t\\t\\t\\tgl.uniform1f( uniforms.fogNear, fog.near );\\n\\t\\t\\t\\t\\tgl.uniform1f( uniforms.fogFar, fog.far );\\n\\n\\t\\t\\t\\t\\tgl.uniform1i( uniforms.fogType, 1 );\\n\\t\\t\\t\\t\\toldFogType = 1;\\n\\t\\t\\t\\t\\tsceneFogType = 1;\\n\\n\\t\\t\\t\\t} else if ( fog.isFogExp2 ) {\\n\\n\\t\\t\\t\\t\\tgl.uniform1f( uniforms.fogDensity, fog.density );\\n\\n\\t\\t\\t\\t\\tgl.uniform1i( uniforms.fogType, 2 );\\n\\t\\t\\t\\t\\toldFogType = 2;\\n\\t\\t\\t\\t\\tsceneFogType = 2;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tgl.uniform1i( uniforms.fogType, 0 );\\n\\t\\t\\t\\toldFogType = 0;\\n\\t\\t\\t\\tsceneFogType = 0;\\n\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\t// update positions and sort\\n\\n\\t\\t\\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar sprite = sprites[ i ];\\n\\n\\t\\t\\t\\tsprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\\n\\t\\t\\t\\tsprite.z = - sprite.modelViewMatrix.elements[ 14 ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tsprites.sort( painterSortStable );\\n\\n\\t\\t\\t// render all sprites\\n\\n\\t\\t\\tvar scale = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar sprite = sprites[ i ];\\n\\t\\t\\t\\tvar material = sprite.material;\\n\\n\\t\\t\\t\\tif ( material.visible === false ) continue;\\n\\n\\t\\t\\t\\tsprite.onBeforeRender( renderer, scene, camera, undefined, material, undefined );\\n\\n\\t\\t\\t\\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\\n\\t\\t\\t\\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\\n\\n\\t\\t\\t\\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\\n\\n\\t\\t\\t\\tscale[ 0 ] = spriteScale.x;\\n\\t\\t\\t\\tscale[ 1 ] = spriteScale.y;\\n\\n\\t\\t\\t\\tvar fogType = 0;\\n\\n\\t\\t\\t\\tif ( scene.fog && material.fog ) {\\n\\n\\t\\t\\t\\t\\tfogType = sceneFogType;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( oldFogType !== fogType ) {\\n\\n\\t\\t\\t\\t\\tgl.uniform1i( uniforms.fogType, fogType );\\n\\t\\t\\t\\t\\toldFogType = fogType;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( material.map !== null ) {\\n\\n\\t\\t\\t\\t\\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\\n\\t\\t\\t\\t\\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\\n\\t\\t\\t\\t\\tgl.uniform2f( uniforms.uvScale, 1, 1 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgl.uniform1f( uniforms.opacity, material.opacity );\\n\\t\\t\\t\\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\\n\\n\\t\\t\\t\\tgl.uniform1f( uniforms.rotation, material.rotation );\\n\\t\\t\\t\\tgl.uniform2fv( uniforms.scale, scale );\\n\\n\\t\\t\\t\\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\\n\\t\\t\\t\\tstate.buffers.depth.setTest( material.depthTest );\\n\\t\\t\\t\\tstate.buffers.depth.setMask( material.depthWrite );\\n\\t\\t\\t\\tstate.buffers.color.setMask( material.colorWrite );\\n\\n\\t\\t\\t\\ttextures.setTexture2D( material.map || texture, 0 );\\n\\n\\t\\t\\t\\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\\n\\n\\t\\t\\t\\tsprite.onAfterRender( renderer, scene, camera, undefined, material, undefined );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// restore gl\\n\\n\\t\\t\\tstate.enable( gl.CULL_FACE );\\n\\n\\t\\t\\tstate.reset();\\n\\n\\t\\t};\\n\\n\\t\\tfunction createProgram() {\\n\\n\\t\\t\\tvar program = gl.createProgram();\\n\\n\\t\\t\\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\\n\\t\\t\\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\\n\\n\\t\\t\\tgl.shaderSource( vertexShader, [\\n\\n\\t\\t\\t\\t'precision ' + capabilities.precision + ' float;',\\n\\n\\t\\t\\t\\t'#define SHADER_NAME ' + 'SpriteMaterial',\\n\\n\\t\\t\\t\\t'uniform mat4 modelViewMatrix;',\\n\\t\\t\\t\\t'uniform mat4 projectionMatrix;',\\n\\t\\t\\t\\t'uniform float rotation;',\\n\\t\\t\\t\\t'uniform vec2 scale;',\\n\\t\\t\\t\\t'uniform vec2 uvOffset;',\\n\\t\\t\\t\\t'uniform vec2 uvScale;',\\n\\n\\t\\t\\t\\t'attribute vec2 position;',\\n\\t\\t\\t\\t'attribute vec2 uv;',\\n\\n\\t\\t\\t\\t'varying vec2 vUV;',\\n\\t\\t\\t\\t'varying float fogDepth;',\\n\\n\\t\\t\\t\\t'void main() {',\\n\\n\\t\\t\\t\\t'\\tvUV = uvOffset + uv * uvScale;',\\n\\n\\t\\t\\t\\t'\\tvec2 alignedPosition = position * scale;',\\n\\n\\t\\t\\t\\t'\\tvec2 rotatedPosition;',\\n\\t\\t\\t\\t'\\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\\n\\t\\t\\t\\t'\\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\\n\\n\\t\\t\\t\\t'\\tvec4 mvPosition;',\\n\\n\\t\\t\\t\\t'\\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\\n\\t\\t\\t\\t'\\tmvPosition.xy += rotatedPosition;',\\n\\n\\t\\t\\t\\t'\\tgl_Position = projectionMatrix * mvPosition;',\\n\\n\\t\\t\\t\\t'\\tfogDepth = - mvPosition.z;',\\n\\n\\t\\t\\t\\t'}'\\n\\n\\t\\t\\t].join( '\\\\n' ) );\\n\\n\\t\\t\\tgl.shaderSource( fragmentShader, [\\n\\n\\t\\t\\t\\t'precision ' + capabilities.precision + ' float;',\\n\\n\\t\\t\\t\\t'#define SHADER_NAME ' + 'SpriteMaterial',\\n\\n\\t\\t\\t\\t'uniform vec3 color;',\\n\\t\\t\\t\\t'uniform sampler2D map;',\\n\\t\\t\\t\\t'uniform float opacity;',\\n\\n\\t\\t\\t\\t'uniform int fogType;',\\n\\t\\t\\t\\t'uniform vec3 fogColor;',\\n\\t\\t\\t\\t'uniform float fogDensity;',\\n\\t\\t\\t\\t'uniform float fogNear;',\\n\\t\\t\\t\\t'uniform float fogFar;',\\n\\t\\t\\t\\t'uniform float alphaTest;',\\n\\n\\t\\t\\t\\t'varying vec2 vUV;',\\n\\t\\t\\t\\t'varying float fogDepth;',\\n\\n\\t\\t\\t\\t'void main() {',\\n\\n\\t\\t\\t\\t'\\tvec4 texture = texture2D( map, vUV );',\\n\\n\\t\\t\\t\\t'\\tgl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\\n\\n\\t\\t\\t\\t'\\tif ( gl_FragColor.a < alphaTest ) discard;',\\n\\n\\t\\t\\t\\t'\\tif ( fogType > 0 ) {',\\n\\n\\t\\t\\t\\t'\\t\\tfloat fogFactor = 0.0;',\\n\\n\\t\\t\\t\\t'\\t\\tif ( fogType == 1 ) {',\\n\\n\\t\\t\\t\\t'\\t\\t\\tfogFactor = smoothstep( fogNear, fogFar, fogDepth );',\\n\\n\\t\\t\\t\\t'\\t\\t} else {',\\n\\n\\t\\t\\t\\t'\\t\\t\\tconst float LOG2 = 1.442695;',\\n\\t\\t\\t\\t'\\t\\t\\tfogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );',\\n\\t\\t\\t\\t'\\t\\t\\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\\n\\n\\t\\t\\t\\t'\\t\\t}',\\n\\n\\t\\t\\t\\t'\\t\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );',\\n\\n\\t\\t\\t\\t'\\t}',\\n\\n\\t\\t\\t\\t'}'\\n\\n\\t\\t\\t].join( '\\\\n' ) );\\n\\n\\t\\t\\tgl.compileShader( vertexShader );\\n\\t\\t\\tgl.compileShader( fragmentShader );\\n\\n\\t\\t\\tgl.attachShader( program, vertexShader );\\n\\t\\t\\tgl.attachShader( program, fragmentShader );\\n\\n\\t\\t\\tgl.linkProgram( program );\\n\\n\\t\\t\\treturn program;\\n\\n\\t\\t}\\n\\n\\t\\tfunction painterSortStable( a, b ) {\\n\\n\\t\\t\\tif ( a.renderOrder !== b.renderOrder ) {\\n\\n\\t\\t\\t\\treturn a.renderOrder - b.renderOrder;\\n\\n\\t\\t\\t} else if ( a.z !== b.z ) {\\n\\n\\t\\t\\t\\treturn b.z - a.z;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\treturn b.id - a.id;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tvar materialId = 0;\\n\\n\\tfunction Material() {\\n\\n\\t\\tObject.defineProperty( this, 'id', { value: materialId ++ } );\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\tthis.name = '';\\n\\t\\tthis.type = 'Material';\\n\\n\\t\\tthis.fog = true;\\n\\t\\tthis.lights = true;\\n\\n\\t\\tthis.blending = NormalBlending;\\n\\t\\tthis.side = FrontSide;\\n\\t\\tthis.flatShading = false;\\n\\t\\tthis.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors\\n\\n\\t\\tthis.opacity = 1;\\n\\t\\tthis.transparent = false;\\n\\n\\t\\tthis.blendSrc = SrcAlphaFactor;\\n\\t\\tthis.blendDst = OneMinusSrcAlphaFactor;\\n\\t\\tthis.blendEquation = AddEquation;\\n\\t\\tthis.blendSrcAlpha = null;\\n\\t\\tthis.blendDstAlpha = null;\\n\\t\\tthis.blendEquationAlpha = null;\\n\\n\\t\\tthis.depthFunc = LessEqualDepth;\\n\\t\\tthis.depthTest = true;\\n\\t\\tthis.depthWrite = true;\\n\\n\\t\\tthis.clippingPlanes = null;\\n\\t\\tthis.clipIntersection = false;\\n\\t\\tthis.clipShadows = false;\\n\\n\\t\\tthis.colorWrite = true;\\n\\n\\t\\tthis.precision = null; // override the renderer's default precision for this material\\n\\n\\t\\tthis.polygonOffset = false;\\n\\t\\tthis.polygonOffsetFactor = 0;\\n\\t\\tthis.polygonOffsetUnits = 0;\\n\\n\\t\\tthis.dithering = false;\\n\\n\\t\\tthis.alphaTest = 0;\\n\\t\\tthis.premultipliedAlpha = false;\\n\\n\\t\\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\\n\\n\\t\\tthis.visible = true;\\n\\n\\t\\tthis.userData = {};\\n\\n\\t\\tthis.needsUpdate = true;\\n\\n\\t}\\n\\n\\tMaterial.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\n\\n\\t\\tconstructor: Material,\\n\\n\\t\\tisMaterial: true,\\n\\n\\t\\tonBeforeCompile: function () {},\\n\\n\\t\\tsetValues: function ( values ) {\\n\\n\\t\\t\\tif ( values === undefined ) return;\\n\\n\\t\\t\\tfor ( var key in values ) {\\n\\n\\t\\t\\t\\tvar newValue = values[ key ];\\n\\n\\t\\t\\t\\tif ( newValue === undefined ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( \\\"THREE.Material: '\\\" + key + \\\"' parameter is undefined.\\\" );\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// for backward compatability if shading is set in the constructor\\n\\t\\t\\t\\tif ( key === 'shading' ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\\n\\t\\t\\t\\t\\tthis.flatShading = ( newValue === FlatShading ) ? true : false;\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar currentValue = this[ key ];\\n\\n\\t\\t\\t\\tif ( currentValue === undefined ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( \\\"THREE.\\\" + this.type + \\\": '\\\" + key + \\\"' is not a property of this material.\\\" );\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( currentValue && currentValue.isColor ) {\\n\\n\\t\\t\\t\\t\\tcurrentValue.set( newValue );\\n\\n\\t\\t\\t\\t} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {\\n\\n\\t\\t\\t\\t\\tcurrentValue.copy( newValue );\\n\\n\\t\\t\\t\\t} else if ( key === 'overdraw' ) {\\n\\n\\t\\t\\t\\t\\t// ensure overdraw is backwards-compatible with legacy boolean type\\n\\t\\t\\t\\t\\tthis[ key ] = Number( newValue );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthis[ key ] = newValue;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( meta ) {\\n\\n\\t\\t\\tvar isRoot = ( meta === undefined || typeof meta === 'string' );\\n\\n\\t\\t\\tif ( isRoot ) {\\n\\n\\t\\t\\t\\tmeta = {\\n\\t\\t\\t\\t\\ttextures: {},\\n\\t\\t\\t\\t\\timages: {}\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar data = {\\n\\t\\t\\t\\tmetadata: {\\n\\t\\t\\t\\t\\tversion: 4.5,\\n\\t\\t\\t\\t\\ttype: 'Material',\\n\\t\\t\\t\\t\\tgenerator: 'Material.toJSON'\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\t\\t// standard Material serialization\\n\\t\\t\\tdata.uuid = this.uuid;\\n\\t\\t\\tdata.type = this.type;\\n\\n\\t\\t\\tif ( this.name !== '' ) data.name = this.name;\\n\\n\\t\\t\\tif ( this.color && this.color.isColor ) data.color = this.color.getHex();\\n\\n\\t\\t\\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\\n\\t\\t\\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\\n\\n\\t\\t\\tif ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();\\n\\t\\t\\tif ( this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;\\n\\n\\t\\t\\tif ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();\\n\\t\\t\\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\\n\\t\\t\\tif ( this.clearCoat !== undefined ) data.clearCoat = this.clearCoat;\\n\\t\\t\\tif ( this.clearCoatRoughness !== undefined ) data.clearCoatRoughness = this.clearCoatRoughness;\\n\\n\\t\\t\\tif ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;\\n\\t\\t\\tif ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\\n\\t\\t\\tif ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\\n\\t\\t\\tif ( this.bumpMap && this.bumpMap.isTexture ) {\\n\\n\\t\\t\\t\\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\\n\\t\\t\\t\\tdata.bumpScale = this.bumpScale;\\n\\n\\t\\t\\t}\\n\\t\\t\\tif ( this.normalMap && this.normalMap.isTexture ) {\\n\\n\\t\\t\\t\\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\\n\\t\\t\\t\\tdata.normalScale = this.normalScale.toArray();\\n\\n\\t\\t\\t}\\n\\t\\t\\tif ( this.displacementMap && this.displacementMap.isTexture ) {\\n\\n\\t\\t\\t\\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\\n\\t\\t\\t\\tdata.displacementScale = this.displacementScale;\\n\\t\\t\\t\\tdata.displacementBias = this.displacementBias;\\n\\n\\t\\t\\t}\\n\\t\\t\\tif ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\\n\\t\\t\\tif ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\\n\\n\\t\\t\\tif ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\\n\\t\\t\\tif ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\\n\\n\\t\\t\\tif ( this.envMap && this.envMap.isTexture ) {\\n\\n\\t\\t\\t\\tdata.envMap = this.envMap.toJSON( meta ).uuid;\\n\\t\\t\\t\\tdata.reflectivity = this.reflectivity; // Scale behind envMap\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.gradientMap && this.gradientMap.isTexture ) {\\n\\n\\t\\t\\t\\tdata.gradientMap = this.gradientMap.toJSON( meta ).uuid;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.size !== undefined ) data.size = this.size;\\n\\t\\t\\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\\n\\n\\t\\t\\tif ( this.blending !== NormalBlending ) data.blending = this.blending;\\n\\t\\t\\tif ( this.flatShading === true ) data.flatShading = this.flatShading;\\n\\t\\t\\tif ( this.side !== FrontSide ) data.side = this.side;\\n\\t\\t\\tif ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;\\n\\n\\t\\t\\tif ( this.opacity < 1 ) data.opacity = this.opacity;\\n\\t\\t\\tif ( this.transparent === true ) data.transparent = this.transparent;\\n\\n\\t\\t\\tdata.depthFunc = this.depthFunc;\\n\\t\\t\\tdata.depthTest = this.depthTest;\\n\\t\\t\\tdata.depthWrite = this.depthWrite;\\n\\n\\t\\t\\t// rotation (SpriteMaterial)\\n\\t\\t\\tif ( this.rotation !== 0 ) data.rotation = this.rotation;\\n\\n\\t\\t\\tif ( this.linewidth !== 1 ) data.linewidth = this.linewidth;\\n\\t\\t\\tif ( this.dashSize !== undefined ) data.dashSize = this.dashSize;\\n\\t\\t\\tif ( this.gapSize !== undefined ) data.gapSize = this.gapSize;\\n\\t\\t\\tif ( this.scale !== undefined ) data.scale = this.scale;\\n\\n\\t\\t\\tif ( this.dithering === true ) data.dithering = true;\\n\\n\\t\\t\\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\\n\\t\\t\\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\\n\\n\\t\\t\\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\\n\\t\\t\\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\\n\\t\\t\\tif ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;\\n\\t\\t\\tif ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;\\n\\n\\t\\t\\tif ( this.morphTargets === true ) data.morphTargets = true;\\n\\t\\t\\tif ( this.skinning === true ) data.skinning = true;\\n\\n\\t\\t\\tif ( this.visible === false ) data.visible = false;\\n\\t\\t\\tif ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;\\n\\n\\t\\t\\t// TODO: Copied from Object3D.toJSON\\n\\n\\t\\t\\tfunction extractFromCache( cache ) {\\n\\n\\t\\t\\t\\tvar values = [];\\n\\n\\t\\t\\t\\tfor ( var key in cache ) {\\n\\n\\t\\t\\t\\t\\tvar data = cache[ key ];\\n\\t\\t\\t\\t\\tdelete data.metadata;\\n\\t\\t\\t\\t\\tvalues.push( data );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn values;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( isRoot ) {\\n\\n\\t\\t\\t\\tvar textures = extractFromCache( meta.textures );\\n\\t\\t\\t\\tvar images = extractFromCache( meta.images );\\n\\n\\t\\t\\t\\tif ( textures.length > 0 ) data.textures = textures;\\n\\t\\t\\t\\tif ( images.length > 0 ) data.images = images;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tthis.name = source.name;\\n\\n\\t\\t\\tthis.fog = source.fog;\\n\\t\\t\\tthis.lights = source.lights;\\n\\n\\t\\t\\tthis.blending = source.blending;\\n\\t\\t\\tthis.side = source.side;\\n\\t\\t\\tthis.flatShading = source.flatShading;\\n\\t\\t\\tthis.vertexColors = source.vertexColors;\\n\\n\\t\\t\\tthis.opacity = source.opacity;\\n\\t\\t\\tthis.transparent = source.transparent;\\n\\n\\t\\t\\tthis.blendSrc = source.blendSrc;\\n\\t\\t\\tthis.blendDst = source.blendDst;\\n\\t\\t\\tthis.blendEquation = source.blendEquation;\\n\\t\\t\\tthis.blendSrcAlpha = source.blendSrcAlpha;\\n\\t\\t\\tthis.blendDstAlpha = source.blendDstAlpha;\\n\\t\\t\\tthis.blendEquationAlpha = source.blendEquationAlpha;\\n\\n\\t\\t\\tthis.depthFunc = source.depthFunc;\\n\\t\\t\\tthis.depthTest = source.depthTest;\\n\\t\\t\\tthis.depthWrite = source.depthWrite;\\n\\n\\t\\t\\tthis.colorWrite = source.colorWrite;\\n\\n\\t\\t\\tthis.precision = source.precision;\\n\\n\\t\\t\\tthis.polygonOffset = source.polygonOffset;\\n\\t\\t\\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\\n\\t\\t\\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\\n\\n\\t\\t\\tthis.dithering = source.dithering;\\n\\n\\t\\t\\tthis.alphaTest = source.alphaTest;\\n\\t\\t\\tthis.premultipliedAlpha = source.premultipliedAlpha;\\n\\n\\t\\t\\tthis.overdraw = source.overdraw;\\n\\n\\t\\t\\tthis.visible = source.visible;\\n\\t\\t\\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\\n\\n\\t\\t\\tthis.clipShadows = source.clipShadows;\\n\\t\\t\\tthis.clipIntersection = source.clipIntersection;\\n\\n\\t\\t\\tvar srcPlanes = source.clippingPlanes,\\n\\t\\t\\t\\tdstPlanes = null;\\n\\n\\t\\t\\tif ( srcPlanes !== null ) {\\n\\n\\t\\t\\t\\tvar n = srcPlanes.length;\\n\\t\\t\\t\\tdstPlanes = new Array( n );\\n\\n\\t\\t\\t\\tfor ( var i = 0; i !== n; ++ i )\\n\\t\\t\\t\\t\\tdstPlanes[ i ] = srcPlanes[ i ].clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.clippingPlanes = dstPlanes;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdispose: function () {\\n\\n\\t\\t\\tthis.dispatchEvent( { type: 'dispose' } );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author bhouston / https://clara.io\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t *\\n\\t * parameters = {\\n\\t *\\n\\t *  opacity: <float>,\\n\\t *\\n\\t *  map: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  alphaMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  displacementMap: new THREE.Texture( <Image> ),\\n\\t *  displacementScale: <float>,\\n\\t *  displacementBias: <float>,\\n\\t *\\n\\t *  wireframe: <boolean>,\\n\\t *  wireframeLinewidth: <float>\\n\\t * }\\n\\t */\\n\\n\\tfunction MeshDepthMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'MeshDepthMaterial';\\n\\n\\t\\tthis.depthPacking = BasicDepthPacking;\\n\\n\\t\\tthis.skinning = false;\\n\\t\\tthis.morphTargets = false;\\n\\n\\t\\tthis.map = null;\\n\\n\\t\\tthis.alphaMap = null;\\n\\n\\t\\tthis.displacementMap = null;\\n\\t\\tthis.displacementScale = 1;\\n\\t\\tthis.displacementBias = 0;\\n\\n\\t\\tthis.wireframe = false;\\n\\t\\tthis.wireframeLinewidth = 1;\\n\\n\\t\\tthis.fog = false;\\n\\t\\tthis.lights = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tMeshDepthMaterial.prototype = Object.create( Material.prototype );\\n\\tMeshDepthMaterial.prototype.constructor = MeshDepthMaterial;\\n\\n\\tMeshDepthMaterial.prototype.isMeshDepthMaterial = true;\\n\\n\\tMeshDepthMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.depthPacking = source.depthPacking;\\n\\n\\t\\tthis.skinning = source.skinning;\\n\\t\\tthis.morphTargets = source.morphTargets;\\n\\n\\t\\tthis.map = source.map;\\n\\n\\t\\tthis.alphaMap = source.alphaMap;\\n\\n\\t\\tthis.displacementMap = source.displacementMap;\\n\\t\\tthis.displacementScale = source.displacementScale;\\n\\t\\tthis.displacementBias = source.displacementBias;\\n\\n\\t\\tthis.wireframe = source.wireframe;\\n\\t\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t *\\n\\t * parameters = {\\n\\t *\\n\\t *  referencePosition: <float>,\\n\\t *  nearDistance: <float>,\\n\\t *  farDistance: <float>,\\n\\t *\\n\\t *  skinning: <bool>,\\n\\t *  morphTargets: <bool>,\\n\\t *\\n\\t *  map: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  alphaMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  displacementMap: new THREE.Texture( <Image> ),\\n\\t *  displacementScale: <float>,\\n\\t *  displacementBias: <float>\\n\\t *\\n\\t * }\\n\\t */\\n\\n\\tfunction MeshDistanceMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'MeshDistanceMaterial';\\n\\n\\t\\tthis.referencePosition = new Vector3();\\n\\t\\tthis.nearDistance = 1;\\n\\t\\tthis.farDistance = 1000;\\n\\n\\t\\tthis.skinning = false;\\n\\t\\tthis.morphTargets = false;\\n\\n\\t\\tthis.map = null;\\n\\n\\t\\tthis.alphaMap = null;\\n\\n\\t\\tthis.displacementMap = null;\\n\\t\\tthis.displacementScale = 1;\\n\\t\\tthis.displacementBias = 0;\\n\\n\\t\\tthis.fog = false;\\n\\t\\tthis.lights = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tMeshDistanceMaterial.prototype = Object.create( Material.prototype );\\n\\tMeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;\\n\\n\\tMeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;\\n\\n\\tMeshDistanceMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.referencePosition.copy( source.referencePosition );\\n\\t\\tthis.nearDistance = source.nearDistance;\\n\\t\\tthis.farDistance = source.farDistance;\\n\\n\\t\\tthis.skinning = source.skinning;\\n\\t\\tthis.morphTargets = source.morphTargets;\\n\\n\\t\\tthis.map = source.map;\\n\\n\\t\\tthis.alphaMap = source.alphaMap;\\n\\n\\t\\tthis.displacementMap = source.displacementMap;\\n\\t\\tthis.displacementScale = source.displacementScale;\\n\\t\\tthis.displacementBias = source.displacementBias;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author bhouston / http://clara.io\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction Box3( min, max ) {\\n\\n\\t\\tthis.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );\\n\\t\\tthis.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );\\n\\n\\t}\\n\\n\\tObject.assign( Box3.prototype, {\\n\\n\\t\\tisBox3: true,\\n\\n\\t\\tset: function ( min, max ) {\\n\\n\\t\\t\\tthis.min.copy( min );\\n\\t\\t\\tthis.max.copy( max );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromArray: function ( array ) {\\n\\n\\t\\t\\tvar minX = + Infinity;\\n\\t\\t\\tvar minY = + Infinity;\\n\\t\\t\\tvar minZ = + Infinity;\\n\\n\\t\\t\\tvar maxX = - Infinity;\\n\\t\\t\\tvar maxY = - Infinity;\\n\\t\\t\\tvar maxZ = - Infinity;\\n\\n\\t\\t\\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\\n\\n\\t\\t\\t\\tvar x = array[ i ];\\n\\t\\t\\t\\tvar y = array[ i + 1 ];\\n\\t\\t\\t\\tvar z = array[ i + 2 ];\\n\\n\\t\\t\\t\\tif ( x < minX ) minX = x;\\n\\t\\t\\t\\tif ( y < minY ) minY = y;\\n\\t\\t\\t\\tif ( z < minZ ) minZ = z;\\n\\n\\t\\t\\t\\tif ( x > maxX ) maxX = x;\\n\\t\\t\\t\\tif ( y > maxY ) maxY = y;\\n\\t\\t\\t\\tif ( z > maxZ ) maxZ = z;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.min.set( minX, minY, minZ );\\n\\t\\t\\tthis.max.set( maxX, maxY, maxZ );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromBufferAttribute: function ( attribute ) {\\n\\n\\t\\t\\tvar minX = + Infinity;\\n\\t\\t\\tvar minY = + Infinity;\\n\\t\\t\\tvar minZ = + Infinity;\\n\\n\\t\\t\\tvar maxX = - Infinity;\\n\\t\\t\\tvar maxY = - Infinity;\\n\\t\\t\\tvar maxZ = - Infinity;\\n\\n\\t\\t\\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar x = attribute.getX( i );\\n\\t\\t\\t\\tvar y = attribute.getY( i );\\n\\t\\t\\t\\tvar z = attribute.getZ( i );\\n\\n\\t\\t\\t\\tif ( x < minX ) minX = x;\\n\\t\\t\\t\\tif ( y < minY ) minY = y;\\n\\t\\t\\t\\tif ( z < minZ ) minZ = z;\\n\\n\\t\\t\\t\\tif ( x > maxX ) maxX = x;\\n\\t\\t\\t\\tif ( y > maxY ) maxY = y;\\n\\t\\t\\t\\tif ( z > maxZ ) maxZ = z;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.min.set( minX, minY, minZ );\\n\\t\\t\\tthis.max.set( maxX, maxY, maxZ );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromPoints: function ( points ) {\\n\\n\\t\\t\\tthis.makeEmpty();\\n\\n\\t\\t\\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.expandByPoint( points[ i ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromCenterAndSize: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function setFromCenterAndSize( center, size ) {\\n\\n\\t\\t\\t\\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\\n\\n\\t\\t\\t\\tthis.min.copy( center ).sub( halfSize );\\n\\t\\t\\t\\tthis.max.copy( center ).add( halfSize );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tsetFromObject: function ( object ) {\\n\\n\\t\\t\\tthis.makeEmpty();\\n\\n\\t\\t\\treturn this.expandByObject( object );\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( box ) {\\n\\n\\t\\t\\tthis.min.copy( box.min );\\n\\t\\t\\tthis.max.copy( box.max );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeEmpty: function () {\\n\\n\\t\\t\\tthis.min.x = this.min.y = this.min.z = + Infinity;\\n\\t\\t\\tthis.max.x = this.max.y = this.max.z = - Infinity;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tisEmpty: function () {\\n\\n\\t\\t\\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\\n\\n\\t\\t\\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\\n\\n\\t\\t},\\n\\n\\t\\tgetCenter: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\t\\t\\treturn this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\\n\\n\\t\\t},\\n\\n\\t\\tgetSize: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\t\\t\\treturn this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );\\n\\n\\t\\t},\\n\\n\\t\\texpandByPoint: function ( point ) {\\n\\n\\t\\t\\tthis.min.min( point );\\n\\t\\t\\tthis.max.max( point );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\texpandByVector: function ( vector ) {\\n\\n\\t\\t\\tthis.min.sub( vector );\\n\\t\\t\\tthis.max.add( vector );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\texpandByScalar: function ( scalar ) {\\n\\n\\t\\t\\tthis.min.addScalar( - scalar );\\n\\t\\t\\tthis.max.addScalar( scalar );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\texpandByObject: function () {\\n\\n\\t\\t\\t// Computes the world-axis-aligned bounding box of an object (including its children),\\n\\t\\t\\t// accounting for both the object's, and children's, world transforms\\n\\n\\t\\t\\tvar scope, i, l;\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\tfunction traverse( node ) {\\n\\n\\t\\t\\t\\tvar geometry = node.geometry;\\n\\n\\t\\t\\t\\tif ( geometry !== undefined ) {\\n\\n\\t\\t\\t\\t\\tif ( geometry.isGeometry ) {\\n\\n\\t\\t\\t\\t\\t\\tvar vertices = geometry.vertices;\\n\\n\\t\\t\\t\\t\\t\\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tv1.copy( vertices[ i ] );\\n\\t\\t\\t\\t\\t\\t\\tv1.applyMatrix4( node.matrixWorld );\\n\\n\\t\\t\\t\\t\\t\\t\\tscope.expandByPoint( v1 );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else if ( geometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\t\\t\\tvar attribute = geometry.attributes.position;\\n\\n\\t\\t\\t\\t\\t\\tif ( attribute !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( i = 0, l = attribute.count; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tv1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tscope.expandByPoint( v1 );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn function expandByObject( object ) {\\n\\n\\t\\t\\t\\tscope = this;\\n\\n\\t\\t\\t\\tobject.updateMatrixWorld( true );\\n\\n\\t\\t\\t\\tobject.traverse( traverse );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tcontainsPoint: function ( point ) {\\n\\n\\t\\t\\treturn point.x < this.min.x || point.x > this.max.x ||\\n\\t\\t\\t\\tpoint.y < this.min.y || point.y > this.max.y ||\\n\\t\\t\\t\\tpoint.z < this.min.z || point.z > this.max.z ? false : true;\\n\\n\\t\\t},\\n\\n\\t\\tcontainsBox: function ( box ) {\\n\\n\\t\\t\\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\\n\\t\\t\\t\\tthis.min.y <= box.min.y && box.max.y <= this.max.y &&\\n\\t\\t\\t\\tthis.min.z <= box.min.z && box.max.z <= this.max.z;\\n\\n\\t\\t},\\n\\n\\t\\tgetParameter: function ( point, optionalTarget ) {\\n\\n\\t\\t\\t// This can potentially have a divide by zero if the box\\n\\t\\t\\t// has a size dimension of 0.\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\treturn result.set(\\n\\t\\t\\t\\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\\n\\t\\t\\t\\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\\n\\t\\t\\t\\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\\n\\t\\t\\t);\\n\\n\\t\\t},\\n\\n\\t\\tintersectsBox: function ( box ) {\\n\\n\\t\\t\\t// using 6 splitting planes to rule out intersections.\\n\\t\\t\\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\\n\\t\\t\\t\\tbox.max.y < this.min.y || box.min.y > this.max.y ||\\n\\t\\t\\t\\tbox.max.z < this.min.z || box.min.z > this.max.z ? false : true;\\n\\n\\t\\t},\\n\\n\\t\\tintersectsSphere: ( function () {\\n\\n\\t\\t\\tvar closestPoint = new Vector3();\\n\\n\\t\\t\\treturn function intersectsSphere( sphere ) {\\n\\n\\t\\t\\t\\t// Find the point on the AABB closest to the sphere center.\\n\\t\\t\\t\\tthis.clampPoint( sphere.center, closestPoint );\\n\\n\\t\\t\\t\\t// If that point is inside the sphere, the AABB and sphere intersect.\\n\\t\\t\\t\\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )(),\\n\\n\\t\\tintersectsPlane: function ( plane ) {\\n\\n\\t\\t\\t// We compute the minimum and maximum dot product values. If those values\\n\\t\\t\\t// are on the same side (back or front) of the plane, then there is no intersection.\\n\\n\\t\\t\\tvar min, max;\\n\\n\\t\\t\\tif ( plane.normal.x > 0 ) {\\n\\n\\t\\t\\t\\tmin = plane.normal.x * this.min.x;\\n\\t\\t\\t\\tmax = plane.normal.x * this.max.x;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tmin = plane.normal.x * this.max.x;\\n\\t\\t\\t\\tmax = plane.normal.x * this.min.x;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( plane.normal.y > 0 ) {\\n\\n\\t\\t\\t\\tmin += plane.normal.y * this.min.y;\\n\\t\\t\\t\\tmax += plane.normal.y * this.max.y;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tmin += plane.normal.y * this.max.y;\\n\\t\\t\\t\\tmax += plane.normal.y * this.min.y;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( plane.normal.z > 0 ) {\\n\\n\\t\\t\\t\\tmin += plane.normal.z * this.min.z;\\n\\t\\t\\t\\tmax += plane.normal.z * this.max.z;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tmin += plane.normal.z * this.max.z;\\n\\t\\t\\t\\tmax += plane.normal.z * this.min.z;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ( min <= plane.constant && max >= plane.constant );\\n\\n\\t\\t},\\n\\n\\t\\tclampPoint: function ( point, optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\t\\t\\treturn result.copy( point ).clamp( this.min, this.max );\\n\\n\\t\\t},\\n\\n\\t\\tdistanceToPoint: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function distanceToPoint( point ) {\\n\\n\\t\\t\\t\\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\\n\\t\\t\\t\\treturn clampedPoint.sub( point ).length();\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tgetBoundingSphere: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function getBoundingSphere( optionalTarget ) {\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Sphere();\\n\\n\\t\\t\\t\\tthis.getCenter( result.center );\\n\\n\\t\\t\\t\\tresult.radius = this.getSize( v1 ).length() * 0.5;\\n\\n\\t\\t\\t\\treturn result;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tintersect: function ( box ) {\\n\\n\\t\\t\\tthis.min.max( box.min );\\n\\t\\t\\tthis.max.min( box.max );\\n\\n\\t\\t\\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\\n\\t\\t\\tif ( this.isEmpty() ) this.makeEmpty();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tunion: function ( box ) {\\n\\n\\t\\t\\tthis.min.min( box.min );\\n\\t\\t\\tthis.max.max( box.max );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tapplyMatrix4: function () {\\n\\n\\t\\t\\tvar points = [\\n\\t\\t\\t\\tnew Vector3(),\\n\\t\\t\\t\\tnew Vector3(),\\n\\t\\t\\t\\tnew Vector3(),\\n\\t\\t\\t\\tnew Vector3(),\\n\\t\\t\\t\\tnew Vector3(),\\n\\t\\t\\t\\tnew Vector3(),\\n\\t\\t\\t\\tnew Vector3(),\\n\\t\\t\\t\\tnew Vector3()\\n\\t\\t\\t];\\n\\n\\t\\t\\treturn function applyMatrix4( matrix ) {\\n\\n\\t\\t\\t\\t// transform of empty box is an empty box.\\n\\t\\t\\t\\tif ( this.isEmpty() ) return this;\\n\\n\\t\\t\\t\\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\\n\\t\\t\\t\\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\\n\\t\\t\\t\\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\\n\\t\\t\\t\\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\\n\\t\\t\\t\\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\\n\\t\\t\\t\\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\\n\\t\\t\\t\\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\\n\\t\\t\\t\\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\\n\\t\\t\\t\\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );\\t// 111\\n\\n\\t\\t\\t\\tthis.setFromPoints( points );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttranslate: function ( offset ) {\\n\\n\\t\\t\\tthis.min.add( offset );\\n\\t\\t\\tthis.max.add( offset );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( box ) {\\n\\n\\t\\t\\treturn box.min.equals( this.min ) && box.max.equals( this.max );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author bhouston / http://clara.io\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction Sphere( center, radius ) {\\n\\n\\t\\tthis.center = ( center !== undefined ) ? center : new Vector3();\\n\\t\\tthis.radius = ( radius !== undefined ) ? radius : 0;\\n\\n\\t}\\n\\n\\tObject.assign( Sphere.prototype, {\\n\\n\\t\\tset: function ( center, radius ) {\\n\\n\\t\\t\\tthis.center.copy( center );\\n\\t\\t\\tthis.radius = radius;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromPoints: function () {\\n\\n\\t\\t\\tvar box = new Box3();\\n\\n\\t\\t\\treturn function setFromPoints( points, optionalCenter ) {\\n\\n\\t\\t\\t\\tvar center = this.center;\\n\\n\\t\\t\\t\\tif ( optionalCenter !== undefined ) {\\n\\n\\t\\t\\t\\t\\tcenter.copy( optionalCenter );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tbox.setFromPoints( points ).getCenter( center );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar maxRadiusSq = 0;\\n\\n\\t\\t\\t\\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.radius = Math.sqrt( maxRadiusSq );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( sphere ) {\\n\\n\\t\\t\\tthis.center.copy( sphere.center );\\n\\t\\t\\tthis.radius = sphere.radius;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tempty: function () {\\n\\n\\t\\t\\treturn ( this.radius <= 0 );\\n\\n\\t\\t},\\n\\n\\t\\tcontainsPoint: function ( point ) {\\n\\n\\t\\t\\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\\n\\n\\t\\t},\\n\\n\\t\\tdistanceToPoint: function ( point ) {\\n\\n\\t\\t\\treturn ( point.distanceTo( this.center ) - this.radius );\\n\\n\\t\\t},\\n\\n\\t\\tintersectsSphere: function ( sphere ) {\\n\\n\\t\\t\\tvar radiusSum = this.radius + sphere.radius;\\n\\n\\t\\t\\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\\n\\n\\t\\t},\\n\\n\\t\\tintersectsBox: function ( box ) {\\n\\n\\t\\t\\treturn box.intersectsSphere( this );\\n\\n\\t\\t},\\n\\n\\t\\tintersectsPlane: function ( plane ) {\\n\\n\\t\\t\\treturn Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;\\n\\n\\t\\t},\\n\\n\\t\\tclampPoint: function ( point, optionalTarget ) {\\n\\n\\t\\t\\tvar deltaLengthSq = this.center.distanceToSquared( point );\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\tresult.copy( point );\\n\\n\\t\\t\\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\\n\\n\\t\\t\\t\\tresult.sub( this.center ).normalize();\\n\\t\\t\\t\\tresult.multiplyScalar( this.radius ).add( this.center );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\n\\t\\t},\\n\\n\\t\\tgetBoundingBox: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar box = optionalTarget || new Box3();\\n\\n\\t\\t\\tbox.set( this.center, this.center );\\n\\t\\t\\tbox.expandByScalar( this.radius );\\n\\n\\t\\t\\treturn box;\\n\\n\\t\\t},\\n\\n\\t\\tapplyMatrix4: function ( matrix ) {\\n\\n\\t\\t\\tthis.center.applyMatrix4( matrix );\\n\\t\\t\\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttranslate: function ( offset ) {\\n\\n\\t\\t\\tthis.center.add( offset );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( sphere ) {\\n\\n\\t\\t\\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author bhouston / http://clara.io\\n\\t */\\n\\n\\tfunction Plane( normal, constant ) {\\n\\n\\t\\t// normal is assumed to be normalized\\n\\n\\t\\tthis.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );\\n\\t\\tthis.constant = ( constant !== undefined ) ? constant : 0;\\n\\n\\t}\\n\\n\\tObject.assign( Plane.prototype, {\\n\\n\\t\\tset: function ( normal, constant ) {\\n\\n\\t\\t\\tthis.normal.copy( normal );\\n\\t\\t\\tthis.constant = constant;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetComponents: function ( x, y, z, w ) {\\n\\n\\t\\t\\tthis.normal.set( x, y, z );\\n\\t\\t\\tthis.constant = w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\\n\\n\\t\\t\\tthis.normal.copy( normal );\\n\\t\\t\\tthis.constant = - point.dot( this.normal );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromCoplanarPoints: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\t\\t\\tvar v2 = new Vector3();\\n\\n\\t\\t\\treturn function setFromCoplanarPoints( a, b, c ) {\\n\\n\\t\\t\\t\\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\\n\\n\\t\\t\\t\\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\\n\\n\\t\\t\\t\\tthis.setFromNormalAndCoplanarPoint( normal, a );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( plane ) {\\n\\n\\t\\t\\tthis.normal.copy( plane.normal );\\n\\t\\t\\tthis.constant = plane.constant;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tnormalize: function () {\\n\\n\\t\\t\\t// Note: will lead to a divide by zero if the plane is invalid.\\n\\n\\t\\t\\tvar inverseNormalLength = 1.0 / this.normal.length();\\n\\t\\t\\tthis.normal.multiplyScalar( inverseNormalLength );\\n\\t\\t\\tthis.constant *= inverseNormalLength;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tnegate: function () {\\n\\n\\t\\t\\tthis.constant *= - 1;\\n\\t\\t\\tthis.normal.negate();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdistanceToPoint: function ( point ) {\\n\\n\\t\\t\\treturn this.normal.dot( point ) + this.constant;\\n\\n\\t\\t},\\n\\n\\t\\tdistanceToSphere: function ( sphere ) {\\n\\n\\t\\t\\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\\n\\n\\t\\t},\\n\\n\\t\\tprojectPoint: function ( point, optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\treturn result.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );\\n\\n\\t\\t},\\n\\n\\t\\tintersectLine: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function intersectLine( line, optionalTarget ) {\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\t\\tvar direction = line.delta( v1 );\\n\\n\\t\\t\\t\\tvar denominator = this.normal.dot( direction );\\n\\n\\t\\t\\t\\tif ( denominator === 0 ) {\\n\\n\\t\\t\\t\\t\\t// line is coplanar, return origin\\n\\t\\t\\t\\t\\tif ( this.distanceToPoint( line.start ) === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\treturn result.copy( line.start );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Unsure if this is the correct method to handle this case.\\n\\t\\t\\t\\t\\treturn undefined;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\\n\\n\\t\\t\\t\\tif ( t < 0 || t > 1 ) {\\n\\n\\t\\t\\t\\t\\treturn undefined;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tintersectsLine: function ( line ) {\\n\\n\\t\\t\\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\\n\\n\\t\\t\\tvar startSign = this.distanceToPoint( line.start );\\n\\t\\t\\tvar endSign = this.distanceToPoint( line.end );\\n\\n\\t\\t\\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\\n\\n\\t\\t},\\n\\n\\t\\tintersectsBox: function ( box ) {\\n\\n\\t\\t\\treturn box.intersectsPlane( this );\\n\\n\\t\\t},\\n\\n\\t\\tintersectsSphere: function ( sphere ) {\\n\\n\\t\\t\\treturn sphere.intersectsPlane( this );\\n\\n\\t\\t},\\n\\n\\t\\tcoplanarPoint: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\\n\\n\\t\\t},\\n\\n\\t\\tapplyMatrix4: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\t\\t\\tvar m1 = new Matrix3();\\n\\n\\t\\t\\treturn function applyMatrix4( matrix, optionalNormalMatrix ) {\\n\\n\\t\\t\\t\\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\\n\\n\\t\\t\\t\\tvar referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\\n\\n\\t\\t\\t\\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\\n\\n\\t\\t\\t\\tthis.constant = - referencePoint.dot( normal );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttranslate: function ( offset ) {\\n\\n\\t\\t\\tthis.constant -= offset.dot( this.normal );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( plane ) {\\n\\n\\t\\t\\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author bhouston / http://clara.io\\n\\t */\\n\\n\\tfunction Frustum( p0, p1, p2, p3, p4, p5 ) {\\n\\n\\t\\tthis.planes = [\\n\\n\\t\\t\\t( p0 !== undefined ) ? p0 : new Plane(),\\n\\t\\t\\t( p1 !== undefined ) ? p1 : new Plane(),\\n\\t\\t\\t( p2 !== undefined ) ? p2 : new Plane(),\\n\\t\\t\\t( p3 !== undefined ) ? p3 : new Plane(),\\n\\t\\t\\t( p4 !== undefined ) ? p4 : new Plane(),\\n\\t\\t\\t( p5 !== undefined ) ? p5 : new Plane()\\n\\n\\t\\t];\\n\\n\\t}\\n\\n\\tObject.assign( Frustum.prototype, {\\n\\n\\t\\tset: function ( p0, p1, p2, p3, p4, p5 ) {\\n\\n\\t\\t\\tvar planes = this.planes;\\n\\n\\t\\t\\tplanes[ 0 ].copy( p0 );\\n\\t\\t\\tplanes[ 1 ].copy( p1 );\\n\\t\\t\\tplanes[ 2 ].copy( p2 );\\n\\t\\t\\tplanes[ 3 ].copy( p3 );\\n\\t\\t\\tplanes[ 4 ].copy( p4 );\\n\\t\\t\\tplanes[ 5 ].copy( p5 );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( frustum ) {\\n\\n\\t\\t\\tvar planes = this.planes;\\n\\n\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\tplanes[ i ].copy( frustum.planes[ i ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromMatrix: function ( m ) {\\n\\n\\t\\t\\tvar planes = this.planes;\\n\\t\\t\\tvar me = m.elements;\\n\\t\\t\\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\\n\\t\\t\\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\\n\\t\\t\\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\\n\\t\\t\\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\\n\\n\\t\\t\\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\\n\\t\\t\\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\\n\\t\\t\\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\\n\\t\\t\\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\\n\\t\\t\\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\\n\\t\\t\\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tintersectsObject: function () {\\n\\n\\t\\t\\tvar sphere = new Sphere();\\n\\n\\t\\t\\treturn function intersectsObject( object ) {\\n\\n\\t\\t\\t\\tvar geometry = object.geometry;\\n\\n\\t\\t\\t\\tif ( geometry.boundingSphere === null )\\n\\t\\t\\t\\t\\tgeometry.computeBoundingSphere();\\n\\n\\t\\t\\t\\tsphere.copy( geometry.boundingSphere )\\n\\t\\t\\t\\t\\t.applyMatrix4( object.matrixWorld );\\n\\n\\t\\t\\t\\treturn this.intersectsSphere( sphere );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tintersectsSprite: function () {\\n\\n\\t\\t\\tvar sphere = new Sphere();\\n\\n\\t\\t\\treturn function intersectsSprite( sprite ) {\\n\\n\\t\\t\\t\\tsphere.center.set( 0, 0, 0 );\\n\\t\\t\\t\\tsphere.radius = 0.7071067811865476;\\n\\t\\t\\t\\tsphere.applyMatrix4( sprite.matrixWorld );\\n\\n\\t\\t\\t\\treturn this.intersectsSphere( sphere );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tintersectsSphere: function ( sphere ) {\\n\\n\\t\\t\\tvar planes = this.planes;\\n\\t\\t\\tvar center = sphere.center;\\n\\t\\t\\tvar negRadius = - sphere.radius;\\n\\n\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\tvar distance = planes[ i ].distanceToPoint( center );\\n\\n\\t\\t\\t\\tif ( distance < negRadius ) {\\n\\n\\t\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn true;\\n\\n\\t\\t},\\n\\n\\t\\tintersectsBox: function () {\\n\\n\\t\\t\\tvar p1 = new Vector3(),\\n\\t\\t\\t\\tp2 = new Vector3();\\n\\n\\t\\t\\treturn function intersectsBox( box ) {\\n\\n\\t\\t\\t\\tvar planes = this.planes;\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar plane = planes[ i ];\\n\\n\\t\\t\\t\\t\\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\\n\\t\\t\\t\\t\\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\\n\\t\\t\\t\\t\\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\\n\\t\\t\\t\\t\\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\\n\\t\\t\\t\\t\\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\\n\\t\\t\\t\\t\\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\\n\\n\\t\\t\\t\\t\\tvar d1 = plane.distanceToPoint( p1 );\\n\\t\\t\\t\\t\\tvar d2 = plane.distanceToPoint( p2 );\\n\\n\\t\\t\\t\\t\\t// if both outside plane, no intersection\\n\\n\\t\\t\\t\\t\\tif ( d1 < 0 && d2 < 0 ) {\\n\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tcontainsPoint: function ( point ) {\\n\\n\\t\\t\\tvar planes = this.planes;\\n\\n\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\\n\\n\\t\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn true;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLShadowMap( _renderer, _objects, maxTextureSize ) {\\n\\n\\t\\tvar _frustum = new Frustum(),\\n\\t\\t\\t_projScreenMatrix = new Matrix4(),\\n\\n\\t\\t\\t_shadowMapSize = new Vector2(),\\n\\t\\t\\t_maxShadowMapSize = new Vector2( maxTextureSize, maxTextureSize ),\\n\\n\\t\\t\\t_lookTarget = new Vector3(),\\n\\t\\t\\t_lightPositionWorld = new Vector3(),\\n\\n\\t\\t\\t_MorphingFlag = 1,\\n\\t\\t\\t_SkinningFlag = 2,\\n\\n\\t\\t\\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\\n\\n\\t\\t\\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\\n\\t\\t\\t_distanceMaterials = new Array( _NumberOfMaterialVariants ),\\n\\n\\t\\t\\t_materialCache = {};\\n\\n\\t\\tvar cubeDirections = [\\n\\t\\t\\tnew Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),\\n\\t\\t\\tnew Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )\\n\\t\\t];\\n\\n\\t\\tvar cubeUps = [\\n\\t\\t\\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),\\n\\t\\t\\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),\\tnew Vector3( 0, 0, - 1 )\\n\\t\\t];\\n\\n\\t\\tvar cube2DViewPorts = [\\n\\t\\t\\tnew Vector4(), new Vector4(), new Vector4(),\\n\\t\\t\\tnew Vector4(), new Vector4(), new Vector4()\\n\\t\\t];\\n\\n\\t\\t// init\\n\\n\\t\\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\\n\\n\\t\\t\\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\\n\\t\\t\\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\\n\\n\\t\\t\\tvar depthMaterial = new MeshDepthMaterial( {\\n\\n\\t\\t\\t\\tdepthPacking: RGBADepthPacking,\\n\\n\\t\\t\\t\\tmorphTargets: useMorphing,\\n\\t\\t\\t\\tskinning: useSkinning\\n\\n\\t\\t\\t} );\\n\\n\\t\\t\\t_depthMaterials[ i ] = depthMaterial;\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar distanceMaterial = new MeshDistanceMaterial( {\\n\\n\\t\\t\\t\\tmorphTargets: useMorphing,\\n\\t\\t\\t\\tskinning: useSkinning\\n\\n\\t\\t\\t} );\\n\\n\\t\\t\\t_distanceMaterials[ i ] = distanceMaterial;\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\tthis.enabled = false;\\n\\n\\t\\tthis.autoUpdate = true;\\n\\t\\tthis.needsUpdate = false;\\n\\n\\t\\tthis.type = PCFShadowMap;\\n\\n\\t\\tthis.renderReverseSided = true;\\n\\t\\tthis.renderSingleSided = true;\\n\\n\\t\\tthis.render = function ( lights, scene, camera ) {\\n\\n\\t\\t\\tif ( scope.enabled === false ) return;\\n\\t\\t\\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\\n\\n\\t\\t\\tif ( lights.length === 0 ) return;\\n\\n\\t\\t\\t// TODO Clean up (needed in case of contextlost)\\n\\t\\t\\tvar _gl = _renderer.context;\\n\\t\\t\\tvar _state = _renderer.state;\\n\\n\\t\\t\\t// Set GL state for depth map.\\n\\t\\t\\t_state.disable( _gl.BLEND );\\n\\t\\t\\t_state.buffers.color.setClear( 1, 1, 1, 1 );\\n\\t\\t\\t_state.buffers.depth.setTest( true );\\n\\t\\t\\t_state.setScissorTest( false );\\n\\n\\t\\t\\t// render depth map\\n\\n\\t\\t\\tvar faceCount;\\n\\n\\t\\t\\tfor ( var i = 0, il = lights.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar light = lights[ i ];\\n\\t\\t\\t\\tvar shadow = light.shadow;\\n\\t\\t\\t\\tvar isPointLight = light && light.isPointLight;\\n\\n\\t\\t\\t\\tif ( shadow === undefined ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar shadowCamera = shadow.camera;\\n\\n\\t\\t\\t\\t_shadowMapSize.copy( shadow.mapSize );\\n\\t\\t\\t\\t_shadowMapSize.min( _maxShadowMapSize );\\n\\n\\t\\t\\t\\tif ( isPointLight ) {\\n\\n\\t\\t\\t\\t\\tvar vpWidth = _shadowMapSize.x;\\n\\t\\t\\t\\t\\tvar vpHeight = _shadowMapSize.y;\\n\\n\\t\\t\\t\\t\\t// These viewports map a cube-map onto a 2D texture with the\\n\\t\\t\\t\\t\\t// following orientation:\\n\\t\\t\\t\\t\\t//\\n\\t\\t\\t\\t\\t//  xzXZ\\n\\t\\t\\t\\t\\t//   y Y\\n\\t\\t\\t\\t\\t//\\n\\t\\t\\t\\t\\t// X - Positive x direction\\n\\t\\t\\t\\t\\t// x - Negative x direction\\n\\t\\t\\t\\t\\t// Y - Positive y direction\\n\\t\\t\\t\\t\\t// y - Negative y direction\\n\\t\\t\\t\\t\\t// Z - Positive z direction\\n\\t\\t\\t\\t\\t// z - Negative z direction\\n\\n\\t\\t\\t\\t\\t// positive X\\n\\t\\t\\t\\t\\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\\n\\t\\t\\t\\t\\t// negative X\\n\\t\\t\\t\\t\\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\\n\\t\\t\\t\\t\\t// positive Z\\n\\t\\t\\t\\t\\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\\n\\t\\t\\t\\t\\t// negative Z\\n\\t\\t\\t\\t\\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\\n\\t\\t\\t\\t\\t// positive Y\\n\\t\\t\\t\\t\\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\\n\\t\\t\\t\\t\\t// negative Y\\n\\t\\t\\t\\t\\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\\n\\n\\t\\t\\t\\t\\t_shadowMapSize.x *= 4.0;\\n\\t\\t\\t\\t\\t_shadowMapSize.y *= 2.0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( shadow.map === null ) {\\n\\n\\t\\t\\t\\t\\tvar pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };\\n\\n\\t\\t\\t\\t\\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\\n\\t\\t\\t\\t\\tshadow.map.texture.name = light.name + \\\".shadowMap\\\";\\n\\n\\t\\t\\t\\t\\tshadowCamera.updateProjectionMatrix();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( shadow.isSpotLightShadow ) {\\n\\n\\t\\t\\t\\t\\tshadow.update( light );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar shadowMap = shadow.map;\\n\\t\\t\\t\\tvar shadowMatrix = shadow.matrix;\\n\\n\\t\\t\\t\\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\\n\\t\\t\\t\\tshadowCamera.position.copy( _lightPositionWorld );\\n\\n\\t\\t\\t\\tif ( isPointLight ) {\\n\\n\\t\\t\\t\\t\\tfaceCount = 6;\\n\\n\\t\\t\\t\\t\\t// for point lights we set the shadow matrix to be a translation-only matrix\\n\\t\\t\\t\\t\\t// equal to inverse of the light's position\\n\\n\\t\\t\\t\\t\\tshadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tfaceCount = 1;\\n\\n\\t\\t\\t\\t\\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\\n\\t\\t\\t\\t\\tshadowCamera.lookAt( _lookTarget );\\n\\t\\t\\t\\t\\tshadowCamera.updateMatrixWorld();\\n\\n\\t\\t\\t\\t\\t// compute shadow matrix\\n\\n\\t\\t\\t\\t\\tshadowMatrix.set(\\n\\t\\t\\t\\t\\t\\t0.5, 0.0, 0.0, 0.5,\\n\\t\\t\\t\\t\\t\\t0.0, 0.5, 0.0, 0.5,\\n\\t\\t\\t\\t\\t\\t0.0, 0.0, 0.5, 0.5,\\n\\t\\t\\t\\t\\t\\t0.0, 0.0, 0.0, 1.0\\n\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\\n\\t\\t\\t\\t\\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t_renderer.setRenderTarget( shadowMap );\\n\\t\\t\\t\\t_renderer.clear();\\n\\n\\t\\t\\t\\t// render shadow map for each cube face (if omni-directional) or\\n\\t\\t\\t\\t// run a single pass if not\\n\\n\\t\\t\\t\\tfor ( var face = 0; face < faceCount; face ++ ) {\\n\\n\\t\\t\\t\\t\\tif ( isPointLight ) {\\n\\n\\t\\t\\t\\t\\t\\t_lookTarget.copy( shadowCamera.position );\\n\\t\\t\\t\\t\\t\\t_lookTarget.add( cubeDirections[ face ] );\\n\\t\\t\\t\\t\\t\\tshadowCamera.up.copy( cubeUps[ face ] );\\n\\t\\t\\t\\t\\t\\tshadowCamera.lookAt( _lookTarget );\\n\\t\\t\\t\\t\\t\\tshadowCamera.updateMatrixWorld();\\n\\n\\t\\t\\t\\t\\t\\tvar vpDimensions = cube2DViewPorts[ face ];\\n\\t\\t\\t\\t\\t\\t_state.viewport( vpDimensions );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// update camera matrices and frustum\\n\\n\\t\\t\\t\\t\\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\\n\\t\\t\\t\\t\\t_frustum.setFromMatrix( _projScreenMatrix );\\n\\n\\t\\t\\t\\t\\t// set object matrices & frustum culling\\n\\n\\t\\t\\t\\t\\trenderObject( scene, camera, shadowCamera, isPointLight );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tscope.needsUpdate = false;\\n\\n\\t\\t};\\n\\n\\t\\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar ) {\\n\\n\\t\\t\\tvar geometry = object.geometry;\\n\\n\\t\\t\\tvar result = null;\\n\\n\\t\\t\\tvar materialVariants = _depthMaterials;\\n\\t\\t\\tvar customMaterial = object.customDepthMaterial;\\n\\n\\t\\t\\tif ( isPointLight ) {\\n\\n\\t\\t\\t\\tmaterialVariants = _distanceMaterials;\\n\\t\\t\\t\\tcustomMaterial = object.customDistanceMaterial;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( ! customMaterial ) {\\n\\n\\t\\t\\t\\tvar useMorphing = false;\\n\\n\\t\\t\\t\\tif ( material.morphTargets ) {\\n\\n\\t\\t\\t\\t\\tif ( geometry && geometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\t\\t\\tuseMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\\n\\n\\t\\t\\t\\t\\t} else if ( geometry && geometry.isGeometry ) {\\n\\n\\t\\t\\t\\t\\t\\tuseMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( object.isSkinnedMesh && material.skinning === false ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar useSkinning = object.isSkinnedMesh && material.skinning;\\n\\n\\t\\t\\t\\tvar variantIndex = 0;\\n\\n\\t\\t\\t\\tif ( useMorphing ) variantIndex |= _MorphingFlag;\\n\\t\\t\\t\\tif ( useSkinning ) variantIndex |= _SkinningFlag;\\n\\n\\t\\t\\t\\tresult = materialVariants[ variantIndex ];\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tresult = customMaterial;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( _renderer.localClippingEnabled &&\\n\\t\\t\\t\\t\\tmaterial.clipShadows === true &&\\n\\t\\t\\t\\t\\tmaterial.clippingPlanes.length !== 0 ) {\\n\\n\\t\\t\\t\\t// in this case we need a unique material instance reflecting the\\n\\t\\t\\t\\t// appropriate state\\n\\n\\t\\t\\t\\tvar keyA = result.uuid, keyB = material.uuid;\\n\\n\\t\\t\\t\\tvar materialsForVariant = _materialCache[ keyA ];\\n\\n\\t\\t\\t\\tif ( materialsForVariant === undefined ) {\\n\\n\\t\\t\\t\\t\\tmaterialsForVariant = {};\\n\\t\\t\\t\\t\\t_materialCache[ keyA ] = materialsForVariant;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar cachedMaterial = materialsForVariant[ keyB ];\\n\\n\\t\\t\\t\\tif ( cachedMaterial === undefined ) {\\n\\n\\t\\t\\t\\t\\tcachedMaterial = result.clone();\\n\\t\\t\\t\\t\\tmaterialsForVariant[ keyB ] = cachedMaterial;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tresult = cachedMaterial;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tresult.visible = material.visible;\\n\\t\\t\\tresult.wireframe = material.wireframe;\\n\\n\\t\\t\\tvar side = material.side;\\n\\n\\t\\t\\tif ( scope.renderSingleSided && side == DoubleSide ) {\\n\\n\\t\\t\\t\\tside = FrontSide;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( scope.renderReverseSided ) {\\n\\n\\t\\t\\t\\tif ( side === FrontSide ) side = BackSide;\\n\\t\\t\\t\\telse if ( side === BackSide ) side = FrontSide;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tresult.side = side;\\n\\n\\t\\t\\tresult.clipShadows = material.clipShadows;\\n\\t\\t\\tresult.clippingPlanes = material.clippingPlanes;\\n\\t\\t\\tresult.clipIntersection = material.clipIntersection;\\n\\n\\t\\t\\tresult.wireframeLinewidth = material.wireframeLinewidth;\\n\\t\\t\\tresult.linewidth = material.linewidth;\\n\\n\\t\\t\\tif ( isPointLight && result.isMeshDistanceMaterial ) {\\n\\n\\t\\t\\t\\tresult.referencePosition.copy( lightPositionWorld );\\n\\t\\t\\t\\tresult.nearDistance = shadowCameraNear;\\n\\t\\t\\t\\tresult.farDistance = shadowCameraFar;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\n\\t\\t}\\n\\n\\t\\tfunction renderObject( object, camera, shadowCamera, isPointLight ) {\\n\\n\\t\\t\\tif ( object.visible === false ) return;\\n\\n\\t\\t\\tvar visible = object.layers.test( camera.layers );\\n\\n\\t\\t\\tif ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {\\n\\n\\t\\t\\t\\tif ( object.castShadow && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {\\n\\n\\t\\t\\t\\t\\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\\n\\n\\t\\t\\t\\t\\tvar geometry = _objects.update( object );\\n\\t\\t\\t\\t\\tvar material = object.material;\\n\\n\\t\\t\\t\\t\\tif ( Array.isArray( material ) ) {\\n\\n\\t\\t\\t\\t\\t\\tvar groups = geometry.groups;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar group = groups[ k ];\\n\\t\\t\\t\\t\\t\\t\\tvar groupMaterial = material[ group.materialIndex ];\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( groupMaterial && groupMaterial.visible ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );\\n\\t\\t\\t\\t\\t\\t\\t\\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else if ( material.visible ) {\\n\\n\\t\\t\\t\\t\\t\\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );\\n\\t\\t\\t\\t\\t\\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar children = object.children;\\n\\n\\t\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\trenderObject( children[ i ], camera, shadowCamera, isPointLight );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLAttributes( gl ) {\\n\\n\\t\\tvar buffers = {};\\n\\n\\t\\tfunction createBuffer( attribute, bufferType ) {\\n\\n\\t\\t\\tvar array = attribute.array;\\n\\t\\t\\tvar usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\\n\\n\\t\\t\\tvar buffer = gl.createBuffer();\\n\\n\\t\\t\\tgl.bindBuffer( bufferType, buffer );\\n\\t\\t\\tgl.bufferData( bufferType, array, usage );\\n\\n\\t\\t\\tattribute.onUploadCallback();\\n\\n\\t\\t\\tvar type = gl.FLOAT;\\n\\n\\t\\t\\tif ( array instanceof Float32Array ) {\\n\\n\\t\\t\\t\\ttype = gl.FLOAT;\\n\\n\\t\\t\\t} else if ( array instanceof Float64Array ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );\\n\\n\\t\\t\\t} else if ( array instanceof Uint16Array ) {\\n\\n\\t\\t\\t\\ttype = gl.UNSIGNED_SHORT;\\n\\n\\t\\t\\t} else if ( array instanceof Int16Array ) {\\n\\n\\t\\t\\t\\ttype = gl.SHORT;\\n\\n\\t\\t\\t} else if ( array instanceof Uint32Array ) {\\n\\n\\t\\t\\t\\ttype = gl.UNSIGNED_INT;\\n\\n\\t\\t\\t} else if ( array instanceof Int32Array ) {\\n\\n\\t\\t\\t\\ttype = gl.INT;\\n\\n\\t\\t\\t} else if ( array instanceof Int8Array ) {\\n\\n\\t\\t\\t\\ttype = gl.BYTE;\\n\\n\\t\\t\\t} else if ( array instanceof Uint8Array ) {\\n\\n\\t\\t\\t\\ttype = gl.UNSIGNED_BYTE;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tbuffer: buffer,\\n\\t\\t\\t\\ttype: type,\\n\\t\\t\\t\\tbytesPerElement: array.BYTES_PER_ELEMENT,\\n\\t\\t\\t\\tversion: attribute.version\\n\\t\\t\\t};\\n\\n\\t\\t}\\n\\n\\t\\tfunction updateBuffer( buffer, attribute, bufferType ) {\\n\\n\\t\\t\\tvar array = attribute.array;\\n\\t\\t\\tvar updateRange = attribute.updateRange;\\n\\n\\t\\t\\tgl.bindBuffer( bufferType, buffer );\\n\\n\\t\\t\\tif ( attribute.dynamic === false ) {\\n\\n\\t\\t\\t\\tgl.bufferData( bufferType, array, gl.STATIC_DRAW );\\n\\n\\t\\t\\t} else if ( updateRange.count === - 1 ) {\\n\\n\\t\\t\\t\\t// Not using update ranges\\n\\n\\t\\t\\t\\tgl.bufferSubData( bufferType, 0, array );\\n\\n\\t\\t\\t} else if ( updateRange.count === 0 ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tgl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,\\n\\t\\t\\t\\t\\tarray.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );\\n\\n\\t\\t\\t\\tupdateRange.count = - 1; // reset range\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tfunction get( attribute ) {\\n\\n\\t\\t\\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\\n\\n\\t\\t\\treturn buffers[ attribute.uuid ];\\n\\n\\t\\t}\\n\\n\\t\\tfunction remove( attribute ) {\\n\\n\\t\\t\\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\\n\\n\\t\\t\\tvar data = buffers[ attribute.uuid ];\\n\\n\\t\\t\\tif ( data ) {\\n\\n\\t\\t\\t\\tgl.deleteBuffer( data.buffer );\\n\\n\\t\\t\\t\\tdelete buffers[ attribute.uuid ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction update( attribute, bufferType ) {\\n\\n\\t\\t\\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\\n\\n\\t\\t\\tvar data = buffers[ attribute.uuid ];\\n\\n\\t\\t\\tif ( data === undefined ) {\\n\\n\\t\\t\\t\\tbuffers[ attribute.uuid ] = createBuffer( attribute, bufferType );\\n\\n\\t\\t\\t} else if ( data.version < attribute.version ) {\\n\\n\\t\\t\\t\\tupdateBuffer( data.buffer, attribute, bufferType );\\n\\n\\t\\t\\t\\tdata.version = attribute.version;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tget: get,\\n\\t\\t\\tremove: remove,\\n\\t\\t\\tupdate: update\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t * @author bhouston / http://clara.io\\n\\t */\\n\\n\\tfunction Euler( x, y, z, order ) {\\n\\n\\t\\tthis._x = x || 0;\\n\\t\\tthis._y = y || 0;\\n\\t\\tthis._z = z || 0;\\n\\t\\tthis._order = order || Euler.DefaultOrder;\\n\\n\\t}\\n\\n\\tEuler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\\n\\n\\tEuler.DefaultOrder = 'XYZ';\\n\\n\\tObject.defineProperties( Euler.prototype, {\\n\\n\\t\\tx: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this._x;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis._x = value;\\n\\t\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\ty: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this._y;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis._y = value;\\n\\t\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tz: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this._z;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis._z = value;\\n\\t\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\torder: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this._order;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis._order = value;\\n\\t\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( Euler.prototype, {\\n\\n\\t\\tisEuler: true,\\n\\n\\t\\tset: function ( x, y, z, order ) {\\n\\n\\t\\t\\tthis._x = x;\\n\\t\\t\\tthis._y = y;\\n\\t\\t\\tthis._z = z;\\n\\t\\t\\tthis._order = order || this._order;\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this._x, this._y, this._z, this._order );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( euler ) {\\n\\n\\t\\t\\tthis._x = euler._x;\\n\\t\\t\\tthis._y = euler._y;\\n\\t\\t\\tthis._z = euler._z;\\n\\t\\t\\tthis._order = euler._order;\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromRotationMatrix: function ( m, order, update ) {\\n\\n\\t\\t\\tvar clamp = _Math.clamp;\\n\\n\\t\\t\\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\\n\\n\\t\\t\\tvar te = m.elements;\\n\\t\\t\\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\\n\\t\\t\\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\\n\\t\\t\\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\\n\\n\\t\\t\\torder = order || this._order;\\n\\n\\t\\t\\tif ( order === 'XYZ' ) {\\n\\n\\t\\t\\t\\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\\n\\n\\t\\t\\t\\tif ( Math.abs( m13 ) < 0.99999 ) {\\n\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( - m23, m33 );\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( - m12, m11 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( m32, m22 );\\n\\t\\t\\t\\t\\tthis._z = 0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( order === 'YXZ' ) {\\n\\n\\t\\t\\t\\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\\n\\n\\t\\t\\t\\tif ( Math.abs( m23 ) < 0.99999 ) {\\n\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( m13, m33 );\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( m21, m22 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( - m31, m11 );\\n\\t\\t\\t\\t\\tthis._z = 0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( order === 'ZXY' ) {\\n\\n\\t\\t\\t\\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\\n\\n\\t\\t\\t\\tif ( Math.abs( m32 ) < 0.99999 ) {\\n\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( - m31, m33 );\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( - m12, m22 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthis._y = 0;\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( m21, m11 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( order === 'ZYX' ) {\\n\\n\\t\\t\\t\\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\\n\\n\\t\\t\\t\\tif ( Math.abs( m31 ) < 0.99999 ) {\\n\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( m32, m33 );\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( m21, m11 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthis._x = 0;\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( - m12, m22 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( order === 'YZX' ) {\\n\\n\\t\\t\\t\\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\\n\\n\\t\\t\\t\\tif ( Math.abs( m21 ) < 0.99999 ) {\\n\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( - m23, m22 );\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( - m31, m11 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthis._x = 0;\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( m13, m33 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( order === 'XZY' ) {\\n\\n\\t\\t\\t\\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\\n\\n\\t\\t\\t\\tif ( Math.abs( m12 ) < 0.99999 ) {\\n\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( m32, m22 );\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( m13, m11 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( - m23, m33 );\\n\\t\\t\\t\\t\\tthis._y = 0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._order = order;\\n\\n\\t\\t\\tif ( update !== false ) this.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromQuaternion: function () {\\n\\n\\t\\t\\tvar matrix = new Matrix4();\\n\\n\\t\\t\\treturn function setFromQuaternion( q, order, update ) {\\n\\n\\t\\t\\t\\tmatrix.makeRotationFromQuaternion( q );\\n\\n\\t\\t\\t\\treturn this.setFromRotationMatrix( matrix, order, update );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tsetFromVector3: function ( v, order ) {\\n\\n\\t\\t\\treturn this.set( v.x, v.y, v.z, order || this._order );\\n\\n\\t\\t},\\n\\n\\t\\treorder: function () {\\n\\n\\t\\t\\t// WARNING: this discards revolution information -bhouston\\n\\n\\t\\t\\tvar q = new Quaternion();\\n\\n\\t\\t\\treturn function reorder( newOrder ) {\\n\\n\\t\\t\\t\\tq.setFromEuler( this );\\n\\n\\t\\t\\t\\treturn this.setFromQuaternion( q, newOrder );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tequals: function ( euler ) {\\n\\n\\t\\t\\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\\n\\n\\t\\t},\\n\\n\\t\\tfromArray: function ( array ) {\\n\\n\\t\\t\\tthis._x = array[ 0 ];\\n\\t\\t\\tthis._y = array[ 1 ];\\n\\t\\t\\tthis._z = array[ 2 ];\\n\\t\\t\\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( array === undefined ) array = [];\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tarray[ offset ] = this._x;\\n\\t\\t\\tarray[ offset + 1 ] = this._y;\\n\\t\\t\\tarray[ offset + 2 ] = this._z;\\n\\t\\t\\tarray[ offset + 3 ] = this._order;\\n\\n\\t\\t\\treturn array;\\n\\n\\t\\t},\\n\\n\\t\\ttoVector3: function ( optionalResult ) {\\n\\n\\t\\t\\tif ( optionalResult ) {\\n\\n\\t\\t\\t\\treturn optionalResult.set( this._x, this._y, this._z );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\treturn new Vector3( this._x, this._y, this._z );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tonChange: function ( callback ) {\\n\\n\\t\\t\\tthis.onChangeCallback = callback;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tonChangeCallback: function () {}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction Layers() {\\n\\n\\t\\tthis.mask = 1 | 0;\\n\\n\\t}\\n\\n\\tObject.assign( Layers.prototype, {\\n\\n\\t\\tset: function ( channel ) {\\n\\n\\t\\t\\tthis.mask = 1 << channel | 0;\\n\\n\\t\\t},\\n\\n\\t\\tenable: function ( channel ) {\\n\\n\\t\\t\\tthis.mask |= 1 << channel | 0;\\n\\n\\t\\t},\\n\\n\\t\\ttoggle: function ( channel ) {\\n\\n\\t\\t\\tthis.mask ^= 1 << channel | 0;\\n\\n\\t\\t},\\n\\n\\t\\tdisable: function ( channel ) {\\n\\n\\t\\t\\tthis.mask &= ~ ( 1 << channel | 0 );\\n\\n\\t\\t},\\n\\n\\t\\ttest: function ( layers ) {\\n\\n\\t\\t\\treturn ( this.mask & layers.mask ) !== 0;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t * @author elephantatwork / www.elephantatwork.ch\\n\\t */\\n\\n\\tvar object3DId = 0;\\n\\n\\tfunction Object3D() {\\n\\n\\t\\tObject.defineProperty( this, 'id', { value: object3DId ++ } );\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\tthis.name = '';\\n\\t\\tthis.type = 'Object3D';\\n\\n\\t\\tthis.parent = null;\\n\\t\\tthis.children = [];\\n\\n\\t\\tthis.up = Object3D.DefaultUp.clone();\\n\\n\\t\\tvar position = new Vector3();\\n\\t\\tvar rotation = new Euler();\\n\\t\\tvar quaternion = new Quaternion();\\n\\t\\tvar scale = new Vector3( 1, 1, 1 );\\n\\n\\t\\tfunction onRotationChange() {\\n\\n\\t\\t\\tquaternion.setFromEuler( rotation, false );\\n\\n\\t\\t}\\n\\n\\t\\tfunction onQuaternionChange() {\\n\\n\\t\\t\\trotation.setFromQuaternion( quaternion, undefined, false );\\n\\n\\t\\t}\\n\\n\\t\\trotation.onChange( onRotationChange );\\n\\t\\tquaternion.onChange( onQuaternionChange );\\n\\n\\t\\tObject.defineProperties( this, {\\n\\t\\t\\tposition: {\\n\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t\\tvalue: position\\n\\t\\t\\t},\\n\\t\\t\\trotation: {\\n\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t\\tvalue: rotation\\n\\t\\t\\t},\\n\\t\\t\\tquaternion: {\\n\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t\\tvalue: quaternion\\n\\t\\t\\t},\\n\\t\\t\\tscale: {\\n\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t\\tvalue: scale\\n\\t\\t\\t},\\n\\t\\t\\tmodelViewMatrix: {\\n\\t\\t\\t\\tvalue: new Matrix4()\\n\\t\\t\\t},\\n\\t\\t\\tnormalMatrix: {\\n\\t\\t\\t\\tvalue: new Matrix3()\\n\\t\\t\\t}\\n\\t\\t} );\\n\\n\\t\\tthis.matrix = new Matrix4();\\n\\t\\tthis.matrixWorld = new Matrix4();\\n\\n\\t\\tthis.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\\n\\t\\tthis.matrixWorldNeedsUpdate = false;\\n\\n\\t\\tthis.layers = new Layers();\\n\\t\\tthis.visible = true;\\n\\n\\t\\tthis.castShadow = false;\\n\\t\\tthis.receiveShadow = false;\\n\\n\\t\\tthis.frustumCulled = true;\\n\\t\\tthis.renderOrder = 0;\\n\\n\\t\\tthis.userData = {};\\n\\n\\t}\\n\\n\\tObject3D.DefaultUp = new Vector3( 0, 1, 0 );\\n\\tObject3D.DefaultMatrixAutoUpdate = true;\\n\\n\\tObject3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\n\\n\\t\\tconstructor: Object3D,\\n\\n\\t\\tisObject3D: true,\\n\\n\\t\\tonBeforeRender: function () {},\\n\\t\\tonAfterRender: function () {},\\n\\n\\t\\tapplyMatrix: function ( matrix ) {\\n\\n\\t\\t\\tthis.matrix.multiplyMatrices( matrix, this.matrix );\\n\\n\\t\\t\\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\\n\\n\\t\\t},\\n\\n\\t\\tapplyQuaternion: function ( q ) {\\n\\n\\t\\t\\tthis.quaternion.premultiply( q );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetRotationFromAxisAngle: function ( axis, angle ) {\\n\\n\\t\\t\\t// assumes axis is normalized\\n\\n\\t\\t\\tthis.quaternion.setFromAxisAngle( axis, angle );\\n\\n\\t\\t},\\n\\n\\t\\tsetRotationFromEuler: function ( euler ) {\\n\\n\\t\\t\\tthis.quaternion.setFromEuler( euler, true );\\n\\n\\t\\t},\\n\\n\\t\\tsetRotationFromMatrix: function ( m ) {\\n\\n\\t\\t\\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\\n\\n\\t\\t\\tthis.quaternion.setFromRotationMatrix( m );\\n\\n\\t\\t},\\n\\n\\t\\tsetRotationFromQuaternion: function ( q ) {\\n\\n\\t\\t\\t// assumes q is normalized\\n\\n\\t\\t\\tthis.quaternion.copy( q );\\n\\n\\t\\t},\\n\\n\\t\\trotateOnAxis: function () {\\n\\n\\t\\t\\t// rotate object on axis in object space\\n\\t\\t\\t// axis is assumed to be normalized\\n\\n\\t\\t\\tvar q1 = new Quaternion();\\n\\n\\t\\t\\treturn function rotateOnAxis( axis, angle ) {\\n\\n\\t\\t\\t\\tq1.setFromAxisAngle( axis, angle );\\n\\n\\t\\t\\t\\tthis.quaternion.multiply( q1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\trotateOnWorldAxis: function () {\\n\\n\\t\\t\\t// rotate object on axis in world space\\n\\t\\t\\t// axis is assumed to be normalized\\n\\t\\t\\t// method assumes no rotated parent\\n\\n\\t\\t\\tvar q1 = new Quaternion();\\n\\n\\t\\t\\treturn function rotateOnWorldAxis( axis, angle ) {\\n\\n\\t\\t\\t\\tq1.setFromAxisAngle( axis, angle );\\n\\n\\t\\t\\t\\tthis.quaternion.premultiply( q1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\trotateX: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3( 1, 0, 0 );\\n\\n\\t\\t\\treturn function rotateX( angle ) {\\n\\n\\t\\t\\t\\treturn this.rotateOnAxis( v1, angle );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\trotateY: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3( 0, 1, 0 );\\n\\n\\t\\t\\treturn function rotateY( angle ) {\\n\\n\\t\\t\\t\\treturn this.rotateOnAxis( v1, angle );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\trotateZ: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3( 0, 0, 1 );\\n\\n\\t\\t\\treturn function rotateZ( angle ) {\\n\\n\\t\\t\\t\\treturn this.rotateOnAxis( v1, angle );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttranslateOnAxis: function () {\\n\\n\\t\\t\\t// translate object by distance along axis in object space\\n\\t\\t\\t// axis is assumed to be normalized\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function translateOnAxis( axis, distance ) {\\n\\n\\t\\t\\t\\tv1.copy( axis ).applyQuaternion( this.quaternion );\\n\\n\\t\\t\\t\\tthis.position.add( v1.multiplyScalar( distance ) );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttranslateX: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3( 1, 0, 0 );\\n\\n\\t\\t\\treturn function translateX( distance ) {\\n\\n\\t\\t\\t\\treturn this.translateOnAxis( v1, distance );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttranslateY: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3( 0, 1, 0 );\\n\\n\\t\\t\\treturn function translateY( distance ) {\\n\\n\\t\\t\\t\\treturn this.translateOnAxis( v1, distance );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttranslateZ: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3( 0, 0, 1 );\\n\\n\\t\\t\\treturn function translateZ( distance ) {\\n\\n\\t\\t\\t\\treturn this.translateOnAxis( v1, distance );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tlocalToWorld: function ( vector ) {\\n\\n\\t\\t\\treturn vector.applyMatrix4( this.matrixWorld );\\n\\n\\t\\t},\\n\\n\\t\\tworldToLocal: function () {\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function worldToLocal( vector ) {\\n\\n\\t\\t\\t\\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tlookAt: function () {\\n\\n\\t\\t\\t// This method does not support objects with rotated and/or translated parent(s)\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\t\\t\\tvar vector = new Vector3();\\n\\n\\t\\t\\treturn function lookAt( x, y, z ) {\\n\\n\\t\\t\\t\\tif ( x.isVector3 ) {\\n\\n\\t\\t\\t\\t\\tvector.copy( x );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tvector.set( x, y, z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( this.isCamera ) {\\n\\n\\t\\t\\t\\t\\tm1.lookAt( this.position, vector, this.up );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tm1.lookAt( vector, this.position, this.up );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.quaternion.setFromRotationMatrix( m1 );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tadd: function ( object ) {\\n\\n\\t\\t\\tif ( arguments.length > 1 ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < arguments.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tthis.add( arguments[ i ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( object === this ) {\\n\\n\\t\\t\\t\\tconsole.error( \\\"THREE.Object3D.add: object can't be added as a child of itself.\\\", object );\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( ( object && object.isObject3D ) ) {\\n\\n\\t\\t\\t\\tif ( object.parent !== null ) {\\n\\n\\t\\t\\t\\t\\tobject.parent.remove( object );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tobject.parent = this;\\n\\t\\t\\t\\tobject.dispatchEvent( { type: 'added' } );\\n\\n\\t\\t\\t\\tthis.children.push( object );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tconsole.error( \\\"THREE.Object3D.add: object not an instance of THREE.Object3D.\\\", object );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tremove: function ( object ) {\\n\\n\\t\\t\\tif ( arguments.length > 1 ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < arguments.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tthis.remove( arguments[ i ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar index = this.children.indexOf( object );\\n\\n\\t\\t\\tif ( index !== - 1 ) {\\n\\n\\t\\t\\t\\tobject.parent = null;\\n\\n\\t\\t\\t\\tobject.dispatchEvent( { type: 'removed' } );\\n\\n\\t\\t\\t\\tthis.children.splice( index, 1 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetObjectById: function ( id ) {\\n\\n\\t\\t\\treturn this.getObjectByProperty( 'id', id );\\n\\n\\t\\t},\\n\\n\\t\\tgetObjectByName: function ( name ) {\\n\\n\\t\\t\\treturn this.getObjectByProperty( 'name', name );\\n\\n\\t\\t},\\n\\n\\t\\tgetObjectByProperty: function ( name, value ) {\\n\\n\\t\\t\\tif ( this[ name ] === value ) return this;\\n\\n\\t\\t\\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar child = this.children[ i ];\\n\\t\\t\\t\\tvar object = child.getObjectByProperty( name, value );\\n\\n\\t\\t\\t\\tif ( object !== undefined ) {\\n\\n\\t\\t\\t\\t\\treturn object;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn undefined;\\n\\n\\t\\t},\\n\\n\\t\\tgetWorldPosition: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\tthis.updateMatrixWorld( true );\\n\\n\\t\\t\\treturn result.setFromMatrixPosition( this.matrixWorld );\\n\\n\\t\\t},\\n\\n\\t\\tgetWorldQuaternion: function () {\\n\\n\\t\\t\\tvar position = new Vector3();\\n\\t\\t\\tvar scale = new Vector3();\\n\\n\\t\\t\\treturn function getWorldQuaternion( optionalTarget ) {\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Quaternion();\\n\\n\\t\\t\\t\\tthis.updateMatrixWorld( true );\\n\\n\\t\\t\\t\\tthis.matrixWorld.decompose( position, result, scale );\\n\\n\\t\\t\\t\\treturn result;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tgetWorldRotation: function () {\\n\\n\\t\\t\\tvar quaternion = new Quaternion();\\n\\n\\t\\t\\treturn function getWorldRotation( optionalTarget ) {\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Euler();\\n\\n\\t\\t\\t\\tthis.getWorldQuaternion( quaternion );\\n\\n\\t\\t\\t\\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tgetWorldScale: function () {\\n\\n\\t\\t\\tvar position = new Vector3();\\n\\t\\t\\tvar quaternion = new Quaternion();\\n\\n\\t\\t\\treturn function getWorldScale( optionalTarget ) {\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\t\\tthis.updateMatrixWorld( true );\\n\\n\\t\\t\\t\\tthis.matrixWorld.decompose( position, quaternion, result );\\n\\n\\t\\t\\t\\treturn result;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tgetWorldDirection: function () {\\n\\n\\t\\t\\tvar quaternion = new Quaternion();\\n\\n\\t\\t\\treturn function getWorldDirection( optionalTarget ) {\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\t\\tthis.getWorldQuaternion( quaternion );\\n\\n\\t\\t\\t\\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\traycast: function () {},\\n\\n\\t\\ttraverse: function ( callback ) {\\n\\n\\t\\t\\tcallback( this );\\n\\n\\t\\t\\tvar children = this.children;\\n\\n\\t\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tchildren[ i ].traverse( callback );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\ttraverseVisible: function ( callback ) {\\n\\n\\t\\t\\tif ( this.visible === false ) return;\\n\\n\\t\\t\\tcallback( this );\\n\\n\\t\\t\\tvar children = this.children;\\n\\n\\t\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tchildren[ i ].traverseVisible( callback );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\ttraverseAncestors: function ( callback ) {\\n\\n\\t\\t\\tvar parent = this.parent;\\n\\n\\t\\t\\tif ( parent !== null ) {\\n\\n\\t\\t\\t\\tcallback( parent );\\n\\n\\t\\t\\t\\tparent.traverseAncestors( callback );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tupdateMatrix: function () {\\n\\n\\t\\t\\tthis.matrix.compose( this.position, this.quaternion, this.scale );\\n\\n\\t\\t\\tthis.matrixWorldNeedsUpdate = true;\\n\\n\\t\\t},\\n\\n\\t\\tupdateMatrixWorld: function ( force ) {\\n\\n\\t\\t\\tif ( this.matrixAutoUpdate ) this.updateMatrix();\\n\\n\\t\\t\\tif ( this.matrixWorldNeedsUpdate || force ) {\\n\\n\\t\\t\\t\\tif ( this.parent === null ) {\\n\\n\\t\\t\\t\\t\\tthis.matrixWorld.copy( this.matrix );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.matrixWorldNeedsUpdate = false;\\n\\n\\t\\t\\t\\tforce = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// update children\\n\\n\\t\\t\\tvar children = this.children;\\n\\n\\t\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tchildren[ i ].updateMatrixWorld( force );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( meta ) {\\n\\n\\t\\t\\t// meta is a string when called from JSON.stringify\\n\\t\\t\\tvar isRootObject = ( meta === undefined || typeof meta === 'string' );\\n\\n\\t\\t\\tvar output = {};\\n\\n\\t\\t\\t// meta is a hash used to collect geometries, materials.\\n\\t\\t\\t// not providing it implies that this is the root object\\n\\t\\t\\t// being serialized.\\n\\t\\t\\tif ( isRootObject ) {\\n\\n\\t\\t\\t\\t// initialize meta obj\\n\\t\\t\\t\\tmeta = {\\n\\t\\t\\t\\t\\tgeometries: {},\\n\\t\\t\\t\\t\\tmaterials: {},\\n\\t\\t\\t\\t\\ttextures: {},\\n\\t\\t\\t\\t\\timages: {},\\n\\t\\t\\t\\t\\tshapes: {}\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\toutput.metadata = {\\n\\t\\t\\t\\t\\tversion: 4.5,\\n\\t\\t\\t\\t\\ttype: 'Object',\\n\\t\\t\\t\\t\\tgenerator: 'Object3D.toJSON'\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// standard Object3D serialization\\n\\n\\t\\t\\tvar object = {};\\n\\n\\t\\t\\tobject.uuid = this.uuid;\\n\\t\\t\\tobject.type = this.type;\\n\\n\\t\\t\\tif ( this.name !== '' ) object.name = this.name;\\n\\t\\t\\tif ( this.castShadow === true ) object.castShadow = true;\\n\\t\\t\\tif ( this.receiveShadow === true ) object.receiveShadow = true;\\n\\t\\t\\tif ( this.visible === false ) object.visible = false;\\n\\t\\t\\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\\n\\n\\t\\t\\tobject.matrix = this.matrix.toArray();\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tfunction serialize( library, element ) {\\n\\n\\t\\t\\t\\tif ( library[ element.uuid ] === undefined ) {\\n\\n\\t\\t\\t\\t\\tlibrary[ element.uuid ] = element.toJSON( meta );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn element.uuid;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.geometry !== undefined ) {\\n\\n\\t\\t\\t\\tobject.geometry = serialize( meta.geometries, this.geometry );\\n\\n\\t\\t\\t\\tvar parameters = this.geometry.parameters;\\n\\n\\t\\t\\t\\tif ( parameters !== undefined && parameters.shapes !== undefined ) {\\n\\n\\t\\t\\t\\t\\tvar shapes = parameters.shapes;\\n\\n\\t\\t\\t\\t\\tif ( Array.isArray( shapes ) ) {\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar shape = shapes[ i ];\\n\\n\\t\\t\\t\\t\\t\\t\\tserialize( meta.shapes, shape );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tserialize( meta.shapes, shapes );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.material !== undefined ) {\\n\\n\\t\\t\\t\\tif ( Array.isArray( this.material ) ) {\\n\\n\\t\\t\\t\\t\\tvar uuids = [];\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = this.material.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tuuids.push( serialize( meta.materials, this.material[ i ] ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tobject.material = uuids;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tobject.material = serialize( meta.materials, this.material );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tif ( this.children.length > 0 ) {\\n\\n\\t\\t\\t\\tobject.children = [];\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < this.children.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tobject.children.push( this.children[ i ].toJSON( meta ).object );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( isRootObject ) {\\n\\n\\t\\t\\t\\tvar geometries = extractFromCache( meta.geometries );\\n\\t\\t\\t\\tvar materials = extractFromCache( meta.materials );\\n\\t\\t\\t\\tvar textures = extractFromCache( meta.textures );\\n\\t\\t\\t\\tvar images = extractFromCache( meta.images );\\n\\t\\t\\t\\tvar shapes = extractFromCache( meta.shapes );\\n\\n\\t\\t\\t\\tif ( geometries.length > 0 ) output.geometries = geometries;\\n\\t\\t\\t\\tif ( materials.length > 0 ) output.materials = materials;\\n\\t\\t\\t\\tif ( textures.length > 0 ) output.textures = textures;\\n\\t\\t\\t\\tif ( images.length > 0 ) output.images = images;\\n\\t\\t\\t\\tif ( shapes.length > 0 ) output.shapes = shapes;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\toutput.object = object;\\n\\n\\t\\t\\treturn output;\\n\\n\\t\\t\\t// extract data from the cache hash\\n\\t\\t\\t// remove metadata on each item\\n\\t\\t\\t// and return as array\\n\\t\\t\\tfunction extractFromCache( cache ) {\\n\\n\\t\\t\\t\\tvar values = [];\\n\\t\\t\\t\\tfor ( var key in cache ) {\\n\\n\\t\\t\\t\\t\\tvar data = cache[ key ];\\n\\t\\t\\t\\t\\tdelete data.metadata;\\n\\t\\t\\t\\t\\tvalues.push( data );\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn values;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tclone: function ( recursive ) {\\n\\n\\t\\t\\treturn new this.constructor().copy( this, recursive );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source, recursive ) {\\n\\n\\t\\t\\tif ( recursive === undefined ) recursive = true;\\n\\n\\t\\t\\tthis.name = source.name;\\n\\n\\t\\t\\tthis.up.copy( source.up );\\n\\n\\t\\t\\tthis.position.copy( source.position );\\n\\t\\t\\tthis.quaternion.copy( source.quaternion );\\n\\t\\t\\tthis.scale.copy( source.scale );\\n\\n\\t\\t\\tthis.matrix.copy( source.matrix );\\n\\t\\t\\tthis.matrixWorld.copy( source.matrixWorld );\\n\\n\\t\\t\\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\\n\\t\\t\\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\\n\\n\\t\\t\\tthis.layers.mask = source.layers.mask;\\n\\t\\t\\tthis.visible = source.visible;\\n\\n\\t\\t\\tthis.castShadow = source.castShadow;\\n\\t\\t\\tthis.receiveShadow = source.receiveShadow;\\n\\n\\t\\t\\tthis.frustumCulled = source.frustumCulled;\\n\\t\\t\\tthis.renderOrder = source.renderOrder;\\n\\n\\t\\t\\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\\n\\n\\t\\t\\tif ( recursive === true ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < source.children.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar child = source.children[ i ];\\n\\t\\t\\t\\t\\tthis.add( child.clone() );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t*/\\n\\n\\tfunction Camera() {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Camera';\\n\\n\\t\\tthis.matrixWorldInverse = new Matrix4();\\n\\t\\tthis.projectionMatrix = new Matrix4();\\n\\n\\t}\\n\\n\\tCamera.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Camera,\\n\\n\\t\\tisCamera: true,\\n\\n\\t\\tcopy: function ( source, recursive ) {\\n\\n\\t\\t\\tObject3D.prototype.copy.call( this, source, recursive );\\n\\n\\t\\t\\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\\n\\t\\t\\tthis.projectionMatrix.copy( source.projectionMatrix );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetWorldDirection: function () {\\n\\n\\t\\t\\tvar quaternion = new Quaternion();\\n\\n\\t\\t\\treturn function getWorldDirection( optionalTarget ) {\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\t\\tthis.getWorldQuaternion( quaternion );\\n\\n\\t\\t\\t\\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tupdateMatrixWorld: function ( force ) {\\n\\n\\t\\t\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\n\\n\\t\\t\\tthis.matrixWorldInverse.getInverse( this.matrixWorld );\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author arose / http://github.com/arose\\n\\t */\\n\\n\\tfunction OrthographicCamera( left, right, top, bottom, near, far ) {\\n\\n\\t\\tCamera.call( this );\\n\\n\\t\\tthis.type = 'OrthographicCamera';\\n\\n\\t\\tthis.zoom = 1;\\n\\t\\tthis.view = null;\\n\\n\\t\\tthis.left = left;\\n\\t\\tthis.right = right;\\n\\t\\tthis.top = top;\\n\\t\\tthis.bottom = bottom;\\n\\n\\t\\tthis.near = ( near !== undefined ) ? near : 0.1;\\n\\t\\tthis.far = ( far !== undefined ) ? far : 2000;\\n\\n\\t\\tthis.updateProjectionMatrix();\\n\\n\\t}\\n\\n\\tOrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\\n\\n\\t\\tconstructor: OrthographicCamera,\\n\\n\\t\\tisOrthographicCamera: true,\\n\\n\\t\\tcopy: function ( source, recursive ) {\\n\\n\\t\\t\\tCamera.prototype.copy.call( this, source, recursive );\\n\\n\\t\\t\\tthis.left = source.left;\\n\\t\\t\\tthis.right = source.right;\\n\\t\\t\\tthis.top = source.top;\\n\\t\\t\\tthis.bottom = source.bottom;\\n\\t\\t\\tthis.near = source.near;\\n\\t\\t\\tthis.far = source.far;\\n\\n\\t\\t\\tthis.zoom = source.zoom;\\n\\t\\t\\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\\n\\n\\t\\t\\tif ( this.view === null ) {\\n\\n\\t\\t\\t\\tthis.view = {\\n\\t\\t\\t\\t\\tenabled: true,\\n\\t\\t\\t\\t\\tfullWidth: 1,\\n\\t\\t\\t\\t\\tfullHeight: 1,\\n\\t\\t\\t\\t\\toffsetX: 0,\\n\\t\\t\\t\\t\\toffsetY: 0,\\n\\t\\t\\t\\t\\twidth: 1,\\n\\t\\t\\t\\t\\theight: 1\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.view.enabled = true;\\n\\t\\t\\tthis.view.fullWidth = fullWidth;\\n\\t\\t\\tthis.view.fullHeight = fullHeight;\\n\\t\\t\\tthis.view.offsetX = x;\\n\\t\\t\\tthis.view.offsetY = y;\\n\\t\\t\\tthis.view.width = width;\\n\\t\\t\\tthis.view.height = height;\\n\\n\\t\\t\\tthis.updateProjectionMatrix();\\n\\n\\t\\t},\\n\\n\\t\\tclearViewOffset: function () {\\n\\n\\t\\t\\tif ( this.view !== null ) {\\n\\n\\t\\t\\t\\tthis.view.enabled = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.updateProjectionMatrix();\\n\\n\\t\\t},\\n\\n\\t\\tupdateProjectionMatrix: function () {\\n\\n\\t\\t\\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\\n\\t\\t\\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\\n\\t\\t\\tvar cx = ( this.right + this.left ) / 2;\\n\\t\\t\\tvar cy = ( this.top + this.bottom ) / 2;\\n\\n\\t\\t\\tvar left = cx - dx;\\n\\t\\t\\tvar right = cx + dx;\\n\\t\\t\\tvar top = cy + dy;\\n\\t\\t\\tvar bottom = cy - dy;\\n\\n\\t\\t\\tif ( this.view !== null && this.view.enabled ) {\\n\\n\\t\\t\\t\\tvar zoomW = this.zoom / ( this.view.width / this.view.fullWidth );\\n\\t\\t\\t\\tvar zoomH = this.zoom / ( this.view.height / this.view.fullHeight );\\n\\t\\t\\t\\tvar scaleW = ( this.right - this.left ) / this.view.width;\\n\\t\\t\\t\\tvar scaleH = ( this.top - this.bottom ) / this.view.height;\\n\\n\\t\\t\\t\\tleft += scaleW * ( this.view.offsetX / zoomW );\\n\\t\\t\\t\\tright = left + scaleW * ( this.view.width / zoomW );\\n\\t\\t\\t\\ttop -= scaleH * ( this.view.offsetY / zoomH );\\n\\t\\t\\t\\tbottom = top - scaleH * ( this.view.height / zoomH );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( meta ) {\\n\\n\\t\\t\\tvar data = Object3D.prototype.toJSON.call( this, meta );\\n\\n\\t\\t\\tdata.object.zoom = this.zoom;\\n\\t\\t\\tdata.object.left = this.left;\\n\\t\\t\\tdata.object.right = this.right;\\n\\t\\t\\tdata.object.top = this.top;\\n\\t\\t\\tdata.object.bottom = this.bottom;\\n\\t\\t\\tdata.object.near = this.near;\\n\\t\\t\\tdata.object.far = this.far;\\n\\n\\t\\t\\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction Face3( a, b, c, normal, color, materialIndex ) {\\n\\n\\t\\tthis.a = a;\\n\\t\\tthis.b = b;\\n\\t\\tthis.c = c;\\n\\n\\t\\tthis.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();\\n\\t\\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\\n\\n\\t\\tthis.color = ( color && color.isColor ) ? color : new Color();\\n\\t\\tthis.vertexColors = Array.isArray( color ) ? color : [];\\n\\n\\t\\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\\n\\n\\t}\\n\\n\\tObject.assign( Face3.prototype, {\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tthis.a = source.a;\\n\\t\\t\\tthis.b = source.b;\\n\\t\\t\\tthis.c = source.c;\\n\\n\\t\\t\\tthis.normal.copy( source.normal );\\n\\t\\t\\tthis.color.copy( source.color );\\n\\n\\t\\t\\tthis.materialIndex = source.materialIndex;\\n\\n\\t\\t\\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author kile / http://kile.stravaganza.org/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t * @author bhouston / http://clara.io\\n\\t */\\n\\n\\tvar geometryId = 0; // Geometry uses even numbers as Id\\n\\n\\tfunction Geometry() {\\n\\n\\t\\tObject.defineProperty( this, 'id', { value: geometryId += 2 } );\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\tthis.name = '';\\n\\t\\tthis.type = 'Geometry';\\n\\n\\t\\tthis.vertices = [];\\n\\t\\tthis.colors = [];\\n\\t\\tthis.faces = [];\\n\\t\\tthis.faceVertexUvs = [[]];\\n\\n\\t\\tthis.morphTargets = [];\\n\\t\\tthis.morphNormals = [];\\n\\n\\t\\tthis.skinWeights = [];\\n\\t\\tthis.skinIndices = [];\\n\\n\\t\\tthis.lineDistances = [];\\n\\n\\t\\tthis.boundingBox = null;\\n\\t\\tthis.boundingSphere = null;\\n\\n\\t\\t// update flags\\n\\n\\t\\tthis.elementsNeedUpdate = false;\\n\\t\\tthis.verticesNeedUpdate = false;\\n\\t\\tthis.uvsNeedUpdate = false;\\n\\t\\tthis.normalsNeedUpdate = false;\\n\\t\\tthis.colorsNeedUpdate = false;\\n\\t\\tthis.lineDistancesNeedUpdate = false;\\n\\t\\tthis.groupsNeedUpdate = false;\\n\\n\\t}\\n\\n\\tGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\n\\n\\t\\tconstructor: Geometry,\\n\\n\\t\\tisGeometry: true,\\n\\n\\t\\tapplyMatrix: function ( matrix ) {\\n\\n\\t\\t\\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\\n\\n\\t\\t\\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar vertex = this.vertices[ i ];\\n\\t\\t\\t\\tvertex.applyMatrix4( matrix );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar face = this.faces[ i ];\\n\\t\\t\\t\\tface.normal.applyMatrix3( normalMatrix ).normalize();\\n\\n\\t\\t\\t\\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.boundingBox !== null ) {\\n\\n\\t\\t\\t\\tthis.computeBoundingBox();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.boundingSphere !== null ) {\\n\\n\\t\\t\\t\\tthis.computeBoundingSphere();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.verticesNeedUpdate = true;\\n\\t\\t\\tthis.normalsNeedUpdate = true;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\trotateX: function () {\\n\\n\\t\\t\\t// rotate geometry around world x-axis\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function rotateX( angle ) {\\n\\n\\t\\t\\t\\tm1.makeRotationX( angle );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\trotateY: function () {\\n\\n\\t\\t\\t// rotate geometry around world y-axis\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function rotateY( angle ) {\\n\\n\\t\\t\\t\\tm1.makeRotationY( angle );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\trotateZ: function () {\\n\\n\\t\\t\\t// rotate geometry around world z-axis\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function rotateZ( angle ) {\\n\\n\\t\\t\\t\\tm1.makeRotationZ( angle );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttranslate: function () {\\n\\n\\t\\t\\t// translate geometry\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function translate( x, y, z ) {\\n\\n\\t\\t\\t\\tm1.makeTranslation( x, y, z );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tscale: function () {\\n\\n\\t\\t\\t// scale geometry\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function scale( x, y, z ) {\\n\\n\\t\\t\\t\\tm1.makeScale( x, y, z );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tlookAt: function () {\\n\\n\\t\\t\\tvar obj = new Object3D();\\n\\n\\t\\t\\treturn function lookAt( vector ) {\\n\\n\\t\\t\\t\\tobj.lookAt( vector );\\n\\n\\t\\t\\t\\tobj.updateMatrix();\\n\\n\\t\\t\\t\\tthis.applyMatrix( obj.matrix );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tfromBufferGeometry: function ( geometry ) {\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\\n\\t\\t\\tvar attributes = geometry.attributes;\\n\\n\\t\\t\\tvar positions = attributes.position.array;\\n\\t\\t\\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\\n\\t\\t\\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\\n\\t\\t\\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\\n\\t\\t\\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\\n\\n\\t\\t\\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\\n\\n\\t\\t\\tvar tempNormals = [];\\n\\t\\t\\tvar tempUVs = [];\\n\\t\\t\\tvar tempUVs2 = [];\\n\\n\\t\\t\\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\\n\\n\\t\\t\\t\\tscope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\\n\\n\\t\\t\\t\\tif ( normals !== undefined ) {\\n\\n\\t\\t\\t\\t\\ttempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( colors !== undefined ) {\\n\\n\\t\\t\\t\\t\\tscope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( uvs !== undefined ) {\\n\\n\\t\\t\\t\\t\\ttempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( uvs2 !== undefined ) {\\n\\n\\t\\t\\t\\t\\ttempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction addFace( a, b, c, materialIndex ) {\\n\\n\\t\\t\\t\\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\\n\\t\\t\\t\\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\\n\\n\\t\\t\\t\\tvar face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\\n\\n\\t\\t\\t\\tscope.faces.push( face );\\n\\n\\t\\t\\t\\tif ( uvs !== undefined ) {\\n\\n\\t\\t\\t\\t\\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( uvs2 !== undefined ) {\\n\\n\\t\\t\\t\\t\\tscope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar groups = geometry.groups;\\n\\n\\t\\t\\tif ( groups.length > 0 ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < groups.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar group = groups[ i ];\\n\\n\\t\\t\\t\\t\\tvar start = group.start;\\n\\t\\t\\t\\t\\tvar count = group.count;\\n\\n\\t\\t\\t\\t\\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( indices !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\taddFace( j, j + 1, j + 2, group.materialIndex );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tif ( indices !== undefined ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < indices.length; i += 3 ) {\\n\\n\\t\\t\\t\\t\\t\\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\\n\\n\\t\\t\\t\\t\\t\\taddFace( i, i + 1, i + 2 );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.computeFaceNormals();\\n\\n\\t\\t\\tif ( geometry.boundingBox !== null ) {\\n\\n\\t\\t\\t\\tthis.boundingBox = geometry.boundingBox.clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.boundingSphere !== null ) {\\n\\n\\t\\t\\t\\tthis.boundingSphere = geometry.boundingSphere.clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcenter: function () {\\n\\n\\t\\t\\tthis.computeBoundingBox();\\n\\n\\t\\t\\tvar offset = this.boundingBox.getCenter().negate();\\n\\n\\t\\t\\tthis.translate( offset.x, offset.y, offset.z );\\n\\n\\t\\t\\treturn offset;\\n\\n\\t\\t},\\n\\n\\t\\tnormalize: function () {\\n\\n\\t\\t\\tthis.computeBoundingSphere();\\n\\n\\t\\t\\tvar center = this.boundingSphere.center;\\n\\t\\t\\tvar radius = this.boundingSphere.radius;\\n\\n\\t\\t\\tvar s = radius === 0 ? 1 : 1.0 / radius;\\n\\n\\t\\t\\tvar matrix = new Matrix4();\\n\\t\\t\\tmatrix.set(\\n\\t\\t\\t\\ts, 0, 0, - s * center.x,\\n\\t\\t\\t\\t0, s, 0, - s * center.y,\\n\\t\\t\\t\\t0, 0, s, - s * center.z,\\n\\t\\t\\t\\t0, 0, 0, 1\\n\\t\\t\\t);\\n\\n\\t\\t\\tthis.applyMatrix( matrix );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcomputeFaceNormals: function () {\\n\\n\\t\\t\\tvar cb = new Vector3(), ab = new Vector3();\\n\\n\\t\\t\\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\tvar face = this.faces[ f ];\\n\\n\\t\\t\\t\\tvar vA = this.vertices[ face.a ];\\n\\t\\t\\t\\tvar vB = this.vertices[ face.b ];\\n\\t\\t\\t\\tvar vC = this.vertices[ face.c ];\\n\\n\\t\\t\\t\\tcb.subVectors( vC, vB );\\n\\t\\t\\t\\tab.subVectors( vA, vB );\\n\\t\\t\\t\\tcb.cross( ab );\\n\\n\\t\\t\\t\\tcb.normalize();\\n\\n\\t\\t\\t\\tface.normal.copy( cb );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tcomputeVertexNormals: function ( areaWeighted ) {\\n\\n\\t\\t\\tif ( areaWeighted === undefined ) areaWeighted = true;\\n\\n\\t\\t\\tvar v, vl, f, fl, face, vertices;\\n\\n\\t\\t\\tvertices = new Array( this.vertices.length );\\n\\n\\t\\t\\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\\n\\n\\t\\t\\t\\tvertices[ v ] = new Vector3();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( areaWeighted ) {\\n\\n\\t\\t\\t\\t// vertex normals weighted by triangle areas\\n\\t\\t\\t\\t// http://www.iquilezles.org/www/articles/normals/normals.htm\\n\\n\\t\\t\\t\\tvar vA, vB, vC;\\n\\t\\t\\t\\tvar cb = new Vector3(), ab = new Vector3();\\n\\n\\t\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\t\\tface = this.faces[ f ];\\n\\n\\t\\t\\t\\t\\tvA = this.vertices[ face.a ];\\n\\t\\t\\t\\t\\tvB = this.vertices[ face.b ];\\n\\t\\t\\t\\t\\tvC = this.vertices[ face.c ];\\n\\n\\t\\t\\t\\t\\tcb.subVectors( vC, vB );\\n\\t\\t\\t\\t\\tab.subVectors( vA, vB );\\n\\t\\t\\t\\t\\tcb.cross( ab );\\n\\n\\t\\t\\t\\t\\tvertices[ face.a ].add( cb );\\n\\t\\t\\t\\t\\tvertices[ face.b ].add( cb );\\n\\t\\t\\t\\t\\tvertices[ face.c ].add( cb );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.computeFaceNormals();\\n\\n\\t\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\t\\tface = this.faces[ f ];\\n\\n\\t\\t\\t\\t\\tvertices[ face.a ].add( face.normal );\\n\\t\\t\\t\\t\\tvertices[ face.b ].add( face.normal );\\n\\t\\t\\t\\t\\tvertices[ face.c ].add( face.normal );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\\n\\n\\t\\t\\t\\tvertices[ v ].normalize();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\tface = this.faces[ f ];\\n\\n\\t\\t\\t\\tvar vertexNormals = face.vertexNormals;\\n\\n\\t\\t\\t\\tif ( vertexNormals.length === 3 ) {\\n\\n\\t\\t\\t\\t\\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\\n\\t\\t\\t\\t\\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\\n\\t\\t\\t\\t\\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\\n\\t\\t\\t\\t\\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\\n\\t\\t\\t\\t\\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.faces.length > 0 ) {\\n\\n\\t\\t\\t\\tthis.normalsNeedUpdate = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tcomputeFlatVertexNormals: function () {\\n\\n\\t\\t\\tvar f, fl, face;\\n\\n\\t\\t\\tthis.computeFaceNormals();\\n\\n\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\tface = this.faces[ f ];\\n\\n\\t\\t\\t\\tvar vertexNormals = face.vertexNormals;\\n\\n\\t\\t\\t\\tif ( vertexNormals.length === 3 ) {\\n\\n\\t\\t\\t\\t\\tvertexNormals[ 0 ].copy( face.normal );\\n\\t\\t\\t\\t\\tvertexNormals[ 1 ].copy( face.normal );\\n\\t\\t\\t\\t\\tvertexNormals[ 2 ].copy( face.normal );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tvertexNormals[ 0 ] = face.normal.clone();\\n\\t\\t\\t\\t\\tvertexNormals[ 1 ] = face.normal.clone();\\n\\t\\t\\t\\t\\tvertexNormals[ 2 ] = face.normal.clone();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.faces.length > 0 ) {\\n\\n\\t\\t\\t\\tthis.normalsNeedUpdate = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tcomputeMorphNormals: function () {\\n\\n\\t\\t\\tvar i, il, f, fl, face;\\n\\n\\t\\t\\t// save original normals\\n\\t\\t\\t// - create temp variables on first access\\n\\t\\t\\t//   otherwise just copy (for faster repeated calls)\\n\\n\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\tface = this.faces[ f ];\\n\\n\\t\\t\\t\\tif ( ! face.__originalFaceNormal ) {\\n\\n\\t\\t\\t\\t\\tface.__originalFaceNormal = face.normal.clone();\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tface.__originalFaceNormal.copy( face.normal );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\\n\\n\\t\\t\\t\\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\tif ( ! face.__originalVertexNormals[ i ] ) {\\n\\n\\t\\t\\t\\t\\t\\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// use temp geometry to compute face and vertex normals for each morph\\n\\n\\t\\t\\tvar tmpGeo = new Geometry();\\n\\t\\t\\ttmpGeo.faces = this.faces;\\n\\n\\t\\t\\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t// create on first access\\n\\n\\t\\t\\t\\tif ( ! this.morphNormals[ i ] ) {\\n\\n\\t\\t\\t\\t\\tthis.morphNormals[ i ] = {};\\n\\t\\t\\t\\t\\tthis.morphNormals[ i ].faceNormals = [];\\n\\t\\t\\t\\t\\tthis.morphNormals[ i ].vertexNormals = [];\\n\\n\\t\\t\\t\\t\\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\\n\\t\\t\\t\\t\\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\\n\\n\\t\\t\\t\\t\\tvar faceNormal, vertexNormals;\\n\\n\\t\\t\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tfaceNormal = new Vector3();\\n\\t\\t\\t\\t\\t\\tvertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\\n\\n\\t\\t\\t\\t\\t\\tdstNormalsFace.push( faceNormal );\\n\\t\\t\\t\\t\\t\\tdstNormalsVertex.push( vertexNormals );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar morphNormals = this.morphNormals[ i ];\\n\\n\\t\\t\\t\\t// set vertices to morph target\\n\\n\\t\\t\\t\\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\\n\\n\\t\\t\\t\\t// compute morph normals\\n\\n\\t\\t\\t\\ttmpGeo.computeFaceNormals();\\n\\t\\t\\t\\ttmpGeo.computeVertexNormals();\\n\\n\\t\\t\\t\\t// store morph normals\\n\\n\\t\\t\\t\\tvar faceNormal, vertexNormals;\\n\\n\\t\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\t\\tface = this.faces[ f ];\\n\\n\\t\\t\\t\\t\\tfaceNormal = morphNormals.faceNormals[ f ];\\n\\t\\t\\t\\t\\tvertexNormals = morphNormals.vertexNormals[ f ];\\n\\n\\t\\t\\t\\t\\tfaceNormal.copy( face.normal );\\n\\n\\t\\t\\t\\t\\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\\n\\t\\t\\t\\t\\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\\n\\t\\t\\t\\t\\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// restore original normals\\n\\n\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\tface = this.faces[ f ];\\n\\n\\t\\t\\t\\tface.normal = face.__originalFaceNormal;\\n\\t\\t\\t\\tface.vertexNormals = face.__originalVertexNormals;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tcomputeLineDistances: function () {\\n\\n\\t\\t\\tvar d = 0;\\n\\t\\t\\tvar vertices = this.vertices;\\n\\n\\t\\t\\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tif ( i > 0 ) {\\n\\n\\t\\t\\t\\t\\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.lineDistances[ i ] = d;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tcomputeBoundingBox: function () {\\n\\n\\t\\t\\tif ( this.boundingBox === null ) {\\n\\n\\t\\t\\t\\tthis.boundingBox = new Box3();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.boundingBox.setFromPoints( this.vertices );\\n\\n\\t\\t},\\n\\n\\t\\tcomputeBoundingSphere: function () {\\n\\n\\t\\t\\tif ( this.boundingSphere === null ) {\\n\\n\\t\\t\\t\\tthis.boundingSphere = new Sphere();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.boundingSphere.setFromPoints( this.vertices );\\n\\n\\t\\t},\\n\\n\\t\\tmerge: function ( geometry, matrix, materialIndexOffset ) {\\n\\n\\t\\t\\tif ( ! ( geometry && geometry.isGeometry ) ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar normalMatrix,\\n\\t\\t\\t\\tvertexOffset = this.vertices.length,\\n\\t\\t\\t\\tvertices1 = this.vertices,\\n\\t\\t\\t\\tvertices2 = geometry.vertices,\\n\\t\\t\\t\\tfaces1 = this.faces,\\n\\t\\t\\t\\tfaces2 = geometry.faces,\\n\\t\\t\\t\\tuvs1 = this.faceVertexUvs[ 0 ],\\n\\t\\t\\t\\tuvs2 = geometry.faceVertexUvs[ 0 ],\\n\\t\\t\\t\\tcolors1 = this.colors,\\n\\t\\t\\t\\tcolors2 = geometry.colors;\\n\\n\\t\\t\\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\\n\\n\\t\\t\\tif ( matrix !== undefined ) {\\n\\n\\t\\t\\t\\tnormalMatrix = new Matrix3().getNormalMatrix( matrix );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// vertices\\n\\n\\t\\t\\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar vertex = vertices2[ i ];\\n\\n\\t\\t\\t\\tvar vertexCopy = vertex.clone();\\n\\n\\t\\t\\t\\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\\n\\n\\t\\t\\t\\tvertices1.push( vertexCopy );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// colors\\n\\n\\t\\t\\tfor ( var i = 0, il = colors2.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tcolors1.push( colors2[ i ].clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// faces\\n\\n\\t\\t\\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar face = faces2[ i ], faceCopy, normal, color,\\n\\t\\t\\t\\t\\tfaceVertexNormals = face.vertexNormals,\\n\\t\\t\\t\\t\\tfaceVertexColors = face.vertexColors;\\n\\n\\t\\t\\t\\tfaceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\\n\\t\\t\\t\\tfaceCopy.normal.copy( face.normal );\\n\\n\\t\\t\\t\\tif ( normalMatrix !== undefined ) {\\n\\n\\t\\t\\t\\t\\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\tnormal = faceVertexNormals[ j ].clone();\\n\\n\\t\\t\\t\\t\\tif ( normalMatrix !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tnormal.applyMatrix3( normalMatrix ).normalize();\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfaceCopy.vertexNormals.push( normal );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfaceCopy.color.copy( face.color );\\n\\n\\t\\t\\t\\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\tcolor = faceVertexColors[ j ];\\n\\t\\t\\t\\t\\tfaceCopy.vertexColors.push( color.clone() );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\\n\\n\\t\\t\\t\\tfaces1.push( faceCopy );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// uvs\\n\\n\\t\\t\\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar uv = uvs2[ i ], uvCopy = [];\\n\\n\\t\\t\\t\\tif ( uv === undefined ) {\\n\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\tuvCopy.push( uv[ j ].clone() );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tuvs1.push( uvCopy );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tmergeMesh: function ( mesh ) {\\n\\n\\t\\t\\tif ( ! ( mesh && mesh.isMesh ) ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tmesh.matrixAutoUpdate && mesh.updateMatrix();\\n\\n\\t\\t\\tthis.merge( mesh.geometry, mesh.matrix );\\n\\n\\t\\t},\\n\\n\\t\\t/*\\n\\t\\t * Checks for duplicate vertices with hashmap.\\n\\t\\t * Duplicated vertices are removed\\n\\t\\t * and faces' vertices are updated.\\n\\t\\t */\\n\\n\\t\\tmergeVertices: function () {\\n\\n\\t\\t\\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\\n\\t\\t\\tvar unique = [], changes = [];\\n\\n\\t\\t\\tvar v, key;\\n\\t\\t\\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\\n\\t\\t\\tvar precision = Math.pow( 10, precisionPoints );\\n\\t\\t\\tvar i, il, face;\\n\\t\\t\\tvar indices, j, jl;\\n\\n\\t\\t\\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tv = this.vertices[ i ];\\n\\t\\t\\t\\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\\n\\n\\t\\t\\t\\tif ( verticesMap[ key ] === undefined ) {\\n\\n\\t\\t\\t\\t\\tverticesMap[ key ] = i;\\n\\t\\t\\t\\t\\tunique.push( this.vertices[ i ] );\\n\\t\\t\\t\\t\\tchanges[ i ] = unique.length - 1;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\\n\\t\\t\\t\\t\\tchanges[ i ] = changes[ verticesMap[ key ] ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\t// if faces are completely degenerate after merging vertices, we\\n\\t\\t\\t// have to remove them from the geometry.\\n\\t\\t\\tvar faceIndicesToRemove = [];\\n\\n\\t\\t\\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tface = this.faces[ i ];\\n\\n\\t\\t\\t\\tface.a = changes[ face.a ];\\n\\t\\t\\t\\tface.b = changes[ face.b ];\\n\\t\\t\\t\\tface.c = changes[ face.c ];\\n\\n\\t\\t\\t\\tindices = [ face.a, face.b, face.c ];\\n\\n\\t\\t\\t\\t// if any duplicate vertices are found in a Face3\\n\\t\\t\\t\\t// we have to remove the face as nothing can be saved\\n\\t\\t\\t\\tfor ( var n = 0; n < 3; n ++ ) {\\n\\n\\t\\t\\t\\t\\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\\n\\n\\t\\t\\t\\t\\t\\tfaceIndicesToRemove.push( i );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\\n\\n\\t\\t\\t\\tvar idx = faceIndicesToRemove[ i ];\\n\\n\\t\\t\\t\\tthis.faces.splice( idx, 1 );\\n\\n\\t\\t\\t\\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\tthis.faceVertexUvs[ j ].splice( idx, 1 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Use unique set of vertices\\n\\n\\t\\t\\tvar diff = this.vertices.length - unique.length;\\n\\t\\t\\tthis.vertices = unique;\\n\\t\\t\\treturn diff;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromPoints: function ( points ) {\\n\\n\\t\\t\\tthis.vertices = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar point = points[ i ];\\n\\t\\t\\t\\tthis.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsortFacesByMaterialIndex: function () {\\n\\n\\t\\t\\tvar faces = this.faces;\\n\\t\\t\\tvar length = faces.length;\\n\\n\\t\\t\\t// tag faces\\n\\n\\t\\t\\tfor ( var i = 0; i < length; i ++ ) {\\n\\n\\t\\t\\t\\tfaces[ i ]._id = i;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// sort faces\\n\\n\\t\\t\\tfunction materialIndexSort( a, b ) {\\n\\n\\t\\t\\t\\treturn a.materialIndex - b.materialIndex;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfaces.sort( materialIndexSort );\\n\\n\\t\\t\\t// sort uvs\\n\\n\\t\\t\\tvar uvs1 = this.faceVertexUvs[ 0 ];\\n\\t\\t\\tvar uvs2 = this.faceVertexUvs[ 1 ];\\n\\n\\t\\t\\tvar newUvs1, newUvs2;\\n\\n\\t\\t\\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\\n\\t\\t\\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\\n\\n\\t\\t\\tfor ( var i = 0; i < length; i ++ ) {\\n\\n\\t\\t\\t\\tvar id = faces[ i ]._id;\\n\\n\\t\\t\\t\\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\\n\\t\\t\\t\\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\\n\\t\\t\\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function () {\\n\\n\\t\\t\\tvar data = {\\n\\t\\t\\t\\tmetadata: {\\n\\t\\t\\t\\t\\tversion: 4.5,\\n\\t\\t\\t\\t\\ttype: 'Geometry',\\n\\t\\t\\t\\t\\tgenerator: 'Geometry.toJSON'\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\t\\t// standard Geometry serialization\\n\\n\\t\\t\\tdata.uuid = this.uuid;\\n\\t\\t\\tdata.type = this.type;\\n\\t\\t\\tif ( this.name !== '' ) data.name = this.name;\\n\\n\\t\\t\\tif ( this.parameters !== undefined ) {\\n\\n\\t\\t\\t\\tvar parameters = this.parameters;\\n\\n\\t\\t\\t\\tfor ( var key in parameters ) {\\n\\n\\t\\t\\t\\t\\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn data;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar vertices = [];\\n\\n\\t\\t\\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\\n\\n\\t\\t\\t\\tvar vertex = this.vertices[ i ];\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar faces = [];\\n\\t\\t\\tvar normals = [];\\n\\t\\t\\tvar normalsHash = {};\\n\\t\\t\\tvar colors = [];\\n\\t\\t\\tvar colorsHash = {};\\n\\t\\t\\tvar uvs = [];\\n\\t\\t\\tvar uvsHash = {};\\n\\n\\t\\t\\tfor ( var i = 0; i < this.faces.length; i ++ ) {\\n\\n\\t\\t\\t\\tvar face = this.faces[ i ];\\n\\n\\t\\t\\t\\tvar hasMaterial = true;\\n\\t\\t\\t\\tvar hasFaceUv = false; // deprecated\\n\\t\\t\\t\\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\\n\\t\\t\\t\\tvar hasFaceNormal = face.normal.length() > 0;\\n\\t\\t\\t\\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\\n\\t\\t\\t\\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\\n\\t\\t\\t\\tvar hasFaceVertexColor = face.vertexColors.length > 0;\\n\\n\\t\\t\\t\\tvar faceType = 0;\\n\\n\\t\\t\\t\\tfaceType = setBit( faceType, 0, 0 ); // isQuad\\n\\t\\t\\t\\tfaceType = setBit( faceType, 1, hasMaterial );\\n\\t\\t\\t\\tfaceType = setBit( faceType, 2, hasFaceUv );\\n\\t\\t\\t\\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\\n\\t\\t\\t\\tfaceType = setBit( faceType, 4, hasFaceNormal );\\n\\t\\t\\t\\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\\n\\t\\t\\t\\tfaceType = setBit( faceType, 6, hasFaceColor );\\n\\t\\t\\t\\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\\n\\n\\t\\t\\t\\tfaces.push( faceType );\\n\\t\\t\\t\\tfaces.push( face.a, face.b, face.c );\\n\\t\\t\\t\\tfaces.push( face.materialIndex );\\n\\n\\t\\t\\t\\tif ( hasFaceVertexUv ) {\\n\\n\\t\\t\\t\\t\\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\\n\\n\\t\\t\\t\\t\\tfaces.push(\\n\\t\\t\\t\\t\\t\\tgetUvIndex( faceVertexUvs[ 0 ] ),\\n\\t\\t\\t\\t\\t\\tgetUvIndex( faceVertexUvs[ 1 ] ),\\n\\t\\t\\t\\t\\t\\tgetUvIndex( faceVertexUvs[ 2 ] )\\n\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( hasFaceNormal ) {\\n\\n\\t\\t\\t\\t\\tfaces.push( getNormalIndex( face.normal ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( hasFaceVertexNormal ) {\\n\\n\\t\\t\\t\\t\\tvar vertexNormals = face.vertexNormals;\\n\\n\\t\\t\\t\\t\\tfaces.push(\\n\\t\\t\\t\\t\\t\\tgetNormalIndex( vertexNormals[ 0 ] ),\\n\\t\\t\\t\\t\\t\\tgetNormalIndex( vertexNormals[ 1 ] ),\\n\\t\\t\\t\\t\\t\\tgetNormalIndex( vertexNormals[ 2 ] )\\n\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( hasFaceColor ) {\\n\\n\\t\\t\\t\\t\\tfaces.push( getColorIndex( face.color ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( hasFaceVertexColor ) {\\n\\n\\t\\t\\t\\t\\tvar vertexColors = face.vertexColors;\\n\\n\\t\\t\\t\\t\\tfaces.push(\\n\\t\\t\\t\\t\\t\\tgetColorIndex( vertexColors[ 0 ] ),\\n\\t\\t\\t\\t\\t\\tgetColorIndex( vertexColors[ 1 ] ),\\n\\t\\t\\t\\t\\t\\tgetColorIndex( vertexColors[ 2 ] )\\n\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction setBit( value, position, enabled ) {\\n\\n\\t\\t\\t\\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction getNormalIndex( normal ) {\\n\\n\\t\\t\\t\\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\\n\\n\\t\\t\\t\\tif ( normalsHash[ hash ] !== undefined ) {\\n\\n\\t\\t\\t\\t\\treturn normalsHash[ hash ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tnormalsHash[ hash ] = normals.length / 3;\\n\\t\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\n\\n\\t\\t\\t\\treturn normalsHash[ hash ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction getColorIndex( color ) {\\n\\n\\t\\t\\t\\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\\n\\n\\t\\t\\t\\tif ( colorsHash[ hash ] !== undefined ) {\\n\\n\\t\\t\\t\\t\\treturn colorsHash[ hash ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcolorsHash[ hash ] = colors.length;\\n\\t\\t\\t\\tcolors.push( color.getHex() );\\n\\n\\t\\t\\t\\treturn colorsHash[ hash ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction getUvIndex( uv ) {\\n\\n\\t\\t\\t\\tvar hash = uv.x.toString() + uv.y.toString();\\n\\n\\t\\t\\t\\tif ( uvsHash[ hash ] !== undefined ) {\\n\\n\\t\\t\\t\\t\\treturn uvsHash[ hash ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tuvsHash[ hash ] = uvs.length / 2;\\n\\t\\t\\t\\tuvs.push( uv.x, uv.y );\\n\\n\\t\\t\\t\\treturn uvsHash[ hash ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tdata.data = {};\\n\\n\\t\\t\\tdata.data.vertices = vertices;\\n\\t\\t\\tdata.data.normals = normals;\\n\\t\\t\\tif ( colors.length > 0 ) data.data.colors = colors;\\n\\t\\t\\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\\n\\t\\t\\tdata.data.faces = faces;\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\t/*\\n\\t\\t\\t // Handle primitives\\n\\n\\t\\t\\t var parameters = this.parameters;\\n\\n\\t\\t\\t if ( parameters !== undefined ) {\\n\\n\\t\\t\\t var values = [];\\n\\n\\t\\t\\t for ( var key in parameters ) {\\n\\n\\t\\t\\t values.push( parameters[ key ] );\\n\\n\\t\\t\\t }\\n\\n\\t\\t\\t var geometry = Object.create( this.constructor.prototype );\\n\\t\\t\\t this.constructor.apply( geometry, values );\\n\\t\\t\\t return geometry;\\n\\n\\t\\t\\t }\\n\\n\\t\\t\\t return new this.constructor().copy( this );\\n\\t\\t\\t */\\n\\n\\t\\t\\treturn new Geometry().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tvar i, il, j, jl, k, kl;\\n\\n\\t\\t\\t// reset\\n\\n\\t\\t\\tthis.vertices = [];\\n\\t\\t\\tthis.colors = [];\\n\\t\\t\\tthis.faces = [];\\n\\t\\t\\tthis.faceVertexUvs = [[]];\\n\\t\\t\\tthis.morphTargets = [];\\n\\t\\t\\tthis.morphNormals = [];\\n\\t\\t\\tthis.skinWeights = [];\\n\\t\\t\\tthis.skinIndices = [];\\n\\t\\t\\tthis.lineDistances = [];\\n\\t\\t\\tthis.boundingBox = null;\\n\\t\\t\\tthis.boundingSphere = null;\\n\\n\\t\\t\\t// name\\n\\n\\t\\t\\tthis.name = source.name;\\n\\n\\t\\t\\t// vertices\\n\\n\\t\\t\\tvar vertices = source.vertices;\\n\\n\\t\\t\\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.vertices.push( vertices[ i ].clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// colors\\n\\n\\t\\t\\tvar colors = source.colors;\\n\\n\\t\\t\\tfor ( i = 0, il = colors.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.colors.push( colors[ i ].clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// faces\\n\\n\\t\\t\\tvar faces = source.faces;\\n\\n\\t\\t\\tfor ( i = 0, il = faces.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.faces.push( faces[ i ].clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// face vertex uvs\\n\\n\\t\\t\\tfor ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar faceVertexUvs = source.faceVertexUvs[ i ];\\n\\n\\t\\t\\t\\tif ( this.faceVertexUvs[ i ] === undefined ) {\\n\\n\\t\\t\\t\\t\\tthis.faceVertexUvs[ i ] = [];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\\n\\n\\t\\t\\t\\t\\tfor ( k = 0, kl = uvs.length; k < kl; k ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar uv = uvs[ k ];\\n\\n\\t\\t\\t\\t\\t\\tuvsCopy.push( uv.clone() );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tthis.faceVertexUvs[ i ].push( uvsCopy );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// morph targets\\n\\n\\t\\t\\tvar morphTargets = source.morphTargets;\\n\\n\\t\\t\\tfor ( i = 0, il = morphTargets.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar morphTarget = {};\\n\\t\\t\\t\\tmorphTarget.name = morphTargets[ i ].name;\\n\\n\\t\\t\\t\\t// vertices\\n\\n\\t\\t\\t\\tif ( morphTargets[ i ].vertices !== undefined ) {\\n\\n\\t\\t\\t\\t\\tmorphTarget.vertices = [];\\n\\n\\t\\t\\t\\t\\tfor ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tmorphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// normals\\n\\n\\t\\t\\t\\tif ( morphTargets[ i ].normals !== undefined ) {\\n\\n\\t\\t\\t\\t\\tmorphTarget.normals = [];\\n\\n\\t\\t\\t\\t\\tfor ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tmorphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.morphTargets.push( morphTarget );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// morph normals\\n\\n\\t\\t\\tvar morphNormals = source.morphNormals;\\n\\n\\t\\t\\tfor ( i = 0, il = morphNormals.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar morphNormal = {};\\n\\n\\t\\t\\t\\t// vertex normals\\n\\n\\t\\t\\t\\tif ( morphNormals[ i ].vertexNormals !== undefined ) {\\n\\n\\t\\t\\t\\t\\tmorphNormal.vertexNormals = [];\\n\\n\\t\\t\\t\\t\\tfor ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];\\n\\t\\t\\t\\t\\t\\tvar destVertexNormal = {};\\n\\n\\t\\t\\t\\t\\t\\tdestVertexNormal.a = srcVertexNormal.a.clone();\\n\\t\\t\\t\\t\\t\\tdestVertexNormal.b = srcVertexNormal.b.clone();\\n\\t\\t\\t\\t\\t\\tdestVertexNormal.c = srcVertexNormal.c.clone();\\n\\n\\t\\t\\t\\t\\t\\tmorphNormal.vertexNormals.push( destVertexNormal );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// face normals\\n\\n\\t\\t\\t\\tif ( morphNormals[ i ].faceNormals !== undefined ) {\\n\\n\\t\\t\\t\\t\\tmorphNormal.faceNormals = [];\\n\\n\\t\\t\\t\\t\\tfor ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tmorphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.morphNormals.push( morphNormal );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// skin weights\\n\\n\\t\\t\\tvar skinWeights = source.skinWeights;\\n\\n\\t\\t\\tfor ( i = 0, il = skinWeights.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.skinWeights.push( skinWeights[ i ].clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// skin indices\\n\\n\\t\\t\\tvar skinIndices = source.skinIndices;\\n\\n\\t\\t\\tfor ( i = 0, il = skinIndices.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.skinIndices.push( skinIndices[ i ].clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// line distances\\n\\n\\t\\t\\tvar lineDistances = source.lineDistances;\\n\\n\\t\\t\\tfor ( i = 0, il = lineDistances.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.lineDistances.push( lineDistances[ i ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// bounding box\\n\\n\\t\\t\\tvar boundingBox = source.boundingBox;\\n\\n\\t\\t\\tif ( boundingBox !== null ) {\\n\\n\\t\\t\\t\\tthis.boundingBox = boundingBox.clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// bounding sphere\\n\\n\\t\\t\\tvar boundingSphere = source.boundingSphere;\\n\\n\\t\\t\\tif ( boundingSphere !== null ) {\\n\\n\\t\\t\\t\\tthis.boundingSphere = boundingSphere.clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// update flags\\n\\n\\t\\t\\tthis.elementsNeedUpdate = source.elementsNeedUpdate;\\n\\t\\t\\tthis.verticesNeedUpdate = source.verticesNeedUpdate;\\n\\t\\t\\tthis.uvsNeedUpdate = source.uvsNeedUpdate;\\n\\t\\t\\tthis.normalsNeedUpdate = source.normalsNeedUpdate;\\n\\t\\t\\tthis.colorsNeedUpdate = source.colorsNeedUpdate;\\n\\t\\t\\tthis.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\\n\\t\\t\\tthis.groupsNeedUpdate = source.groupsNeedUpdate;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdispose: function () {\\n\\n\\t\\t\\tthis.dispatchEvent( { type: 'dispose' } );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction BufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tif ( Array.isArray( array ) ) {\\n\\n\\t\\t\\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\\n\\n\\t\\t}\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\t\\tthis.name = '';\\n\\n\\t\\tthis.array = array;\\n\\t\\tthis.itemSize = itemSize;\\n\\t\\tthis.count = array !== undefined ? array.length / itemSize : 0;\\n\\t\\tthis.normalized = normalized === true;\\n\\n\\t\\tthis.dynamic = false;\\n\\t\\tthis.updateRange = { offset: 0, count: - 1 };\\n\\n\\t\\tthis.onUploadCallback = function () {};\\n\\n\\t\\tthis.version = 0;\\n\\n\\t}\\n\\n\\tObject.defineProperty( BufferAttribute.prototype, 'needsUpdate', {\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tif ( value === true ) this.version ++;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( BufferAttribute.prototype, {\\n\\n\\t\\tisBufferAttribute: true,\\n\\n\\t\\tsetArray: function ( array ) {\\n\\n\\t\\t\\tif ( Array.isArray( array ) ) {\\n\\n\\t\\t\\t\\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.count = array !== undefined ? array.length / this.itemSize : 0;\\n\\t\\t\\tthis.array = array;\\n\\n\\t\\t},\\n\\n\\t\\tsetDynamic: function ( value ) {\\n\\n\\t\\t\\tthis.dynamic = value;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tthis.array = new source.array.constructor( source.array );\\n\\t\\t\\tthis.itemSize = source.itemSize;\\n\\t\\t\\tthis.count = source.count;\\n\\t\\t\\tthis.normalized = source.normalized;\\n\\n\\t\\t\\tthis.dynamic = source.dynamic;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyAt: function ( index1, attribute, index2 ) {\\n\\n\\t\\t\\tindex1 *= this.itemSize;\\n\\t\\t\\tindex2 *= attribute.itemSize;\\n\\n\\t\\t\\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyArray: function ( array ) {\\n\\n\\t\\t\\tthis.array.set( array );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyColorsArray: function ( colors ) {\\n\\n\\t\\t\\tvar array = this.array, offset = 0;\\n\\n\\t\\t\\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar color = colors[ i ];\\n\\n\\t\\t\\t\\tif ( color === undefined ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\\n\\t\\t\\t\\t\\tcolor = new Color();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tarray[ offset ++ ] = color.r;\\n\\t\\t\\t\\tarray[ offset ++ ] = color.g;\\n\\t\\t\\t\\tarray[ offset ++ ] = color.b;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyIndicesArray: function ( indices ) {\\n\\n\\t\\t\\tvar array = this.array, offset = 0;\\n\\n\\t\\t\\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar index = indices[ i ];\\n\\n\\t\\t\\t\\tarray[ offset ++ ] = index.a;\\n\\t\\t\\t\\tarray[ offset ++ ] = index.b;\\n\\t\\t\\t\\tarray[ offset ++ ] = index.c;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyVector2sArray: function ( vectors ) {\\n\\n\\t\\t\\tvar array = this.array, offset = 0;\\n\\n\\t\\t\\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar vector = vectors[ i ];\\n\\n\\t\\t\\t\\tif ( vector === undefined ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\\n\\t\\t\\t\\t\\tvector = new Vector2();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.x;\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.y;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyVector3sArray: function ( vectors ) {\\n\\n\\t\\t\\tvar array = this.array, offset = 0;\\n\\n\\t\\t\\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar vector = vectors[ i ];\\n\\n\\t\\t\\t\\tif ( vector === undefined ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\\n\\t\\t\\t\\t\\tvector = new Vector3();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.x;\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.y;\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.z;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyVector4sArray: function ( vectors ) {\\n\\n\\t\\t\\tvar array = this.array, offset = 0;\\n\\n\\t\\t\\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar vector = vectors[ i ];\\n\\n\\t\\t\\t\\tif ( vector === undefined ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\\n\\t\\t\\t\\t\\tvector = new Vector4();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.x;\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.y;\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.z;\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.w;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value, offset ) {\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tthis.array.set( value, offset );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetX: function ( index ) {\\n\\n\\t\\t\\treturn this.array[ index * this.itemSize ];\\n\\n\\t\\t},\\n\\n\\t\\tsetX: function ( index, x ) {\\n\\n\\t\\t\\tthis.array[ index * this.itemSize ] = x;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetY: function ( index ) {\\n\\n\\t\\t\\treturn this.array[ index * this.itemSize + 1 ];\\n\\n\\t\\t},\\n\\n\\t\\tsetY: function ( index, y ) {\\n\\n\\t\\t\\tthis.array[ index * this.itemSize + 1 ] = y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetZ: function ( index ) {\\n\\n\\t\\t\\treturn this.array[ index * this.itemSize + 2 ];\\n\\n\\t\\t},\\n\\n\\t\\tsetZ: function ( index, z ) {\\n\\n\\t\\t\\tthis.array[ index * this.itemSize + 2 ] = z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetW: function ( index ) {\\n\\n\\t\\t\\treturn this.array[ index * this.itemSize + 3 ];\\n\\n\\t\\t},\\n\\n\\t\\tsetW: function ( index, w ) {\\n\\n\\t\\t\\tthis.array[ index * this.itemSize + 3 ] = w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetXY: function ( index, x, y ) {\\n\\n\\t\\t\\tindex *= this.itemSize;\\n\\n\\t\\t\\tthis.array[ index + 0 ] = x;\\n\\t\\t\\tthis.array[ index + 1 ] = y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetXYZ: function ( index, x, y, z ) {\\n\\n\\t\\t\\tindex *= this.itemSize;\\n\\n\\t\\t\\tthis.array[ index + 0 ] = x;\\n\\t\\t\\tthis.array[ index + 1 ] = y;\\n\\t\\t\\tthis.array[ index + 2 ] = z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetXYZW: function ( index, x, y, z, w ) {\\n\\n\\t\\t\\tindex *= this.itemSize;\\n\\n\\t\\t\\tthis.array[ index + 0 ] = x;\\n\\t\\t\\tthis.array[ index + 1 ] = y;\\n\\t\\t\\tthis.array[ index + 2 ] = z;\\n\\t\\t\\tthis.array[ index + 3 ] = w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tonUpload: function ( callback ) {\\n\\n\\t\\t\\tthis.onUploadCallback = callback;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.array, this.itemSize ).copy( this );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tfunction Int8BufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tBufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );\\n\\n\\t}\\n\\n\\tInt8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\n\\tInt8BufferAttribute.prototype.constructor = Int8BufferAttribute;\\n\\n\\n\\tfunction Uint8BufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tBufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );\\n\\n\\t}\\n\\n\\tUint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\n\\tUint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;\\n\\n\\n\\tfunction Uint8ClampedBufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tBufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );\\n\\n\\t}\\n\\n\\tUint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\n\\tUint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;\\n\\n\\n\\tfunction Int16BufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tBufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );\\n\\n\\t}\\n\\n\\tInt16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\n\\tInt16BufferAttribute.prototype.constructor = Int16BufferAttribute;\\n\\n\\n\\tfunction Uint16BufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tBufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );\\n\\n\\t}\\n\\n\\tUint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\n\\tUint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;\\n\\n\\n\\tfunction Int32BufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tBufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );\\n\\n\\t}\\n\\n\\tInt32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\n\\tInt32BufferAttribute.prototype.constructor = Int32BufferAttribute;\\n\\n\\n\\tfunction Uint32BufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tBufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );\\n\\n\\t}\\n\\n\\tUint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\n\\tUint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;\\n\\n\\n\\tfunction Float32BufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tBufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );\\n\\n\\t}\\n\\n\\tFloat32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\n\\tFloat32BufferAttribute.prototype.constructor = Float32BufferAttribute;\\n\\n\\n\\tfunction Float64BufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tBufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );\\n\\n\\t}\\n\\n\\tFloat64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\n\\tFloat64BufferAttribute.prototype.constructor = Float64BufferAttribute;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction DirectGeometry() {\\n\\n\\t\\tthis.indices = [];\\n\\t\\tthis.vertices = [];\\n\\t\\tthis.normals = [];\\n\\t\\tthis.colors = [];\\n\\t\\tthis.uvs = [];\\n\\t\\tthis.uvs2 = [];\\n\\n\\t\\tthis.groups = [];\\n\\n\\t\\tthis.morphTargets = {};\\n\\n\\t\\tthis.skinWeights = [];\\n\\t\\tthis.skinIndices = [];\\n\\n\\t\\t// this.lineDistances = [];\\n\\n\\t\\tthis.boundingBox = null;\\n\\t\\tthis.boundingSphere = null;\\n\\n\\t\\t// update flags\\n\\n\\t\\tthis.verticesNeedUpdate = false;\\n\\t\\tthis.normalsNeedUpdate = false;\\n\\t\\tthis.colorsNeedUpdate = false;\\n\\t\\tthis.uvsNeedUpdate = false;\\n\\t\\tthis.groupsNeedUpdate = false;\\n\\n\\t}\\n\\n\\tObject.assign( DirectGeometry.prototype, {\\n\\n\\t\\tcomputeGroups: function ( geometry ) {\\n\\n\\t\\t\\tvar group;\\n\\t\\t\\tvar groups = [];\\n\\t\\t\\tvar materialIndex = undefined;\\n\\n\\t\\t\\tvar faces = geometry.faces;\\n\\n\\t\\t\\tfor ( var i = 0; i < faces.length; i ++ ) {\\n\\n\\t\\t\\t\\tvar face = faces[ i ];\\n\\n\\t\\t\\t\\t// materials\\n\\n\\t\\t\\t\\tif ( face.materialIndex !== materialIndex ) {\\n\\n\\t\\t\\t\\t\\tmaterialIndex = face.materialIndex;\\n\\n\\t\\t\\t\\t\\tif ( group !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tgroup.count = ( i * 3 ) - group.start;\\n\\t\\t\\t\\t\\t\\tgroups.push( group );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tgroup = {\\n\\t\\t\\t\\t\\t\\tstart: i * 3,\\n\\t\\t\\t\\t\\t\\tmaterialIndex: materialIndex\\n\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( group !== undefined ) {\\n\\n\\t\\t\\t\\tgroup.count = ( i * 3 ) - group.start;\\n\\t\\t\\t\\tgroups.push( group );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.groups = groups;\\n\\n\\t\\t},\\n\\n\\t\\tfromGeometry: function ( geometry ) {\\n\\n\\t\\t\\tvar faces = geometry.faces;\\n\\t\\t\\tvar vertices = geometry.vertices;\\n\\t\\t\\tvar faceVertexUvs = geometry.faceVertexUvs;\\n\\n\\t\\t\\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\\n\\t\\t\\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\\n\\n\\t\\t\\t// morphs\\n\\n\\t\\t\\tvar morphTargets = geometry.morphTargets;\\n\\t\\t\\tvar morphTargetsLength = morphTargets.length;\\n\\n\\t\\t\\tvar morphTargetsPosition;\\n\\n\\t\\t\\tif ( morphTargetsLength > 0 ) {\\n\\n\\t\\t\\t\\tmorphTargetsPosition = [];\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\\n\\n\\t\\t\\t\\t\\tmorphTargetsPosition[ i ] = [];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.morphTargets.position = morphTargetsPosition;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar morphNormals = geometry.morphNormals;\\n\\t\\t\\tvar morphNormalsLength = morphNormals.length;\\n\\n\\t\\t\\tvar morphTargetsNormal;\\n\\n\\t\\t\\tif ( morphNormalsLength > 0 ) {\\n\\n\\t\\t\\t\\tmorphTargetsNormal = [];\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\\n\\n\\t\\t\\t\\t\\tmorphTargetsNormal[ i ] = [];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.morphTargets.normal = morphTargetsNormal;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// skins\\n\\n\\t\\t\\tvar skinIndices = geometry.skinIndices;\\n\\t\\t\\tvar skinWeights = geometry.skinWeights;\\n\\n\\t\\t\\tvar hasSkinIndices = skinIndices.length === vertices.length;\\n\\t\\t\\tvar hasSkinWeights = skinWeights.length === vertices.length;\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tfor ( var i = 0; i < faces.length; i ++ ) {\\n\\n\\t\\t\\t\\tvar face = faces[ i ];\\n\\n\\t\\t\\t\\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\\n\\n\\t\\t\\t\\tvar vertexNormals = face.vertexNormals;\\n\\n\\t\\t\\t\\tif ( vertexNormals.length === 3 ) {\\n\\n\\t\\t\\t\\t\\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tvar normal = face.normal;\\n\\n\\t\\t\\t\\t\\tthis.normals.push( normal, normal, normal );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar vertexColors = face.vertexColors;\\n\\n\\t\\t\\t\\tif ( vertexColors.length === 3 ) {\\n\\n\\t\\t\\t\\t\\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tvar color = face.color;\\n\\n\\t\\t\\t\\t\\tthis.colors.push( color, color, color );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( hasFaceVertexUv === true ) {\\n\\n\\t\\t\\t\\t\\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\\n\\n\\t\\t\\t\\t\\tif ( vertexUvs !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\\n\\n\\t\\t\\t\\t\\t\\tthis.uvs.push( new Vector2(), new Vector2(), new Vector2() );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( hasFaceVertexUv2 === true ) {\\n\\n\\t\\t\\t\\t\\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\\n\\n\\t\\t\\t\\t\\tif ( vertexUvs !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\\n\\n\\t\\t\\t\\t\\t\\tthis.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// morphs\\n\\n\\t\\t\\t\\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\\n\\n\\t\\t\\t\\t\\tvar morphTarget = morphTargets[ j ].vertices;\\n\\n\\t\\t\\t\\t\\tmorphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\\n\\n\\t\\t\\t\\t\\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\\n\\n\\t\\t\\t\\t\\tmorphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// skins\\n\\n\\t\\t\\t\\tif ( hasSkinIndices ) {\\n\\n\\t\\t\\t\\t\\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( hasSkinWeights ) {\\n\\n\\t\\t\\t\\t\\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.computeGroups( geometry );\\n\\n\\t\\t\\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\\n\\t\\t\\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\\n\\t\\t\\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\\n\\t\\t\\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\\n\\t\\t\\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction arrayMax( array ) {\\n\\n\\t\\tif ( array.length === 0 ) return - Infinity;\\n\\n\\t\\tvar max = array[ 0 ];\\n\\n\\t\\tfor ( var i = 1, l = array.length; i < l; ++ i ) {\\n\\n\\t\\t\\tif ( array[ i ] > max ) max = array[ i ];\\n\\n\\t\\t}\\n\\n\\t\\treturn max;\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tvar bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id\\n\\n\\tfunction BufferGeometry() {\\n\\n\\t\\tObject.defineProperty( this, 'id', { value: bufferGeometryId += 2 } );\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\tthis.name = '';\\n\\t\\tthis.type = 'BufferGeometry';\\n\\n\\t\\tthis.index = null;\\n\\t\\tthis.attributes = {};\\n\\n\\t\\tthis.morphAttributes = {};\\n\\n\\t\\tthis.groups = [];\\n\\n\\t\\tthis.boundingBox = null;\\n\\t\\tthis.boundingSphere = null;\\n\\n\\t\\tthis.drawRange = { start: 0, count: Infinity };\\n\\n\\t}\\n\\n\\tBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\n\\n\\t\\tconstructor: BufferGeometry,\\n\\n\\t\\tisBufferGeometry: true,\\n\\n\\t\\tgetIndex: function () {\\n\\n\\t\\t\\treturn this.index;\\n\\n\\t\\t},\\n\\n\\t\\tsetIndex: function ( index ) {\\n\\n\\t\\t\\tif ( Array.isArray( index ) ) {\\n\\n\\t\\t\\t\\tthis.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.index = index;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\taddAttribute: function ( name, attribute ) {\\n\\n\\t\\t\\tif ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\\n\\n\\t\\t\\t\\tthis.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\\n\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( name === 'index' ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\\n\\t\\t\\t\\tthis.setIndex( attribute );\\n\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.attributes[ name ] = attribute;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetAttribute: function ( name ) {\\n\\n\\t\\t\\treturn this.attributes[ name ];\\n\\n\\t\\t},\\n\\n\\t\\tremoveAttribute: function ( name ) {\\n\\n\\t\\t\\tdelete this.attributes[ name ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddGroup: function ( start, count, materialIndex ) {\\n\\n\\t\\t\\tthis.groups.push( {\\n\\n\\t\\t\\t\\tstart: start,\\n\\t\\t\\t\\tcount: count,\\n\\t\\t\\t\\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\\n\\n\\t\\t\\t} );\\n\\n\\t\\t},\\n\\n\\t\\tclearGroups: function () {\\n\\n\\t\\t\\tthis.groups = [];\\n\\n\\t\\t},\\n\\n\\t\\tsetDrawRange: function ( start, count ) {\\n\\n\\t\\t\\tthis.drawRange.start = start;\\n\\t\\t\\tthis.drawRange.count = count;\\n\\n\\t\\t},\\n\\n\\t\\tapplyMatrix: function ( matrix ) {\\n\\n\\t\\t\\tvar position = this.attributes.position;\\n\\n\\t\\t\\tif ( position !== undefined ) {\\n\\n\\t\\t\\t\\tmatrix.applyToBufferAttribute( position );\\n\\t\\t\\t\\tposition.needsUpdate = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar normal = this.attributes.normal;\\n\\n\\t\\t\\tif ( normal !== undefined ) {\\n\\n\\t\\t\\t\\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\\n\\n\\t\\t\\t\\tnormalMatrix.applyToBufferAttribute( normal );\\n\\t\\t\\t\\tnormal.needsUpdate = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.boundingBox !== null ) {\\n\\n\\t\\t\\t\\tthis.computeBoundingBox();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.boundingSphere !== null ) {\\n\\n\\t\\t\\t\\tthis.computeBoundingSphere();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\trotateX: function () {\\n\\n\\t\\t\\t// rotate geometry around world x-axis\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function rotateX( angle ) {\\n\\n\\t\\t\\t\\tm1.makeRotationX( angle );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\trotateY: function () {\\n\\n\\t\\t\\t// rotate geometry around world y-axis\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function rotateY( angle ) {\\n\\n\\t\\t\\t\\tm1.makeRotationY( angle );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\trotateZ: function () {\\n\\n\\t\\t\\t// rotate geometry around world z-axis\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function rotateZ( angle ) {\\n\\n\\t\\t\\t\\tm1.makeRotationZ( angle );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttranslate: function () {\\n\\n\\t\\t\\t// translate geometry\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function translate( x, y, z ) {\\n\\n\\t\\t\\t\\tm1.makeTranslation( x, y, z );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tscale: function () {\\n\\n\\t\\t\\t// scale geometry\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function scale( x, y, z ) {\\n\\n\\t\\t\\t\\tm1.makeScale( x, y, z );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tlookAt: function () {\\n\\n\\t\\t\\tvar obj = new Object3D();\\n\\n\\t\\t\\treturn function lookAt( vector ) {\\n\\n\\t\\t\\t\\tobj.lookAt( vector );\\n\\n\\t\\t\\t\\tobj.updateMatrix();\\n\\n\\t\\t\\t\\tthis.applyMatrix( obj.matrix );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tcenter: function () {\\n\\n\\t\\t\\tthis.computeBoundingBox();\\n\\n\\t\\t\\tvar offset = this.boundingBox.getCenter().negate();\\n\\n\\t\\t\\tthis.translate( offset.x, offset.y, offset.z );\\n\\n\\t\\t\\treturn offset;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromObject: function ( object ) {\\n\\n\\t\\t\\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\\n\\n\\t\\t\\tvar geometry = object.geometry;\\n\\n\\t\\t\\tif ( object.isPoints || object.isLine ) {\\n\\n\\t\\t\\t\\tvar positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );\\n\\t\\t\\t\\tvar colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );\\n\\n\\t\\t\\t\\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\\n\\t\\t\\t\\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\\n\\n\\t\\t\\t\\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\\n\\n\\t\\t\\t\\t\\tvar lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );\\n\\n\\t\\t\\t\\t\\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( geometry.boundingSphere !== null ) {\\n\\n\\t\\t\\t\\t\\tthis.boundingSphere = geometry.boundingSphere.clone();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( geometry.boundingBox !== null ) {\\n\\n\\t\\t\\t\\t\\tthis.boundingBox = geometry.boundingBox.clone();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( object.isMesh ) {\\n\\n\\t\\t\\t\\tif ( geometry && geometry.isGeometry ) {\\n\\n\\t\\t\\t\\t\\tthis.fromGeometry( geometry );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromPoints: function ( points ) {\\n\\n\\t\\t\\tvar position = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar point = points[ i ];\\n\\t\\t\\t\\tposition.push( point.x, point.y, point.z || 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tupdateFromObject: function ( object ) {\\n\\n\\t\\t\\tvar geometry = object.geometry;\\n\\n\\t\\t\\tif ( object.isMesh ) {\\n\\n\\t\\t\\t\\tvar direct = geometry.__directGeometry;\\n\\n\\t\\t\\t\\tif ( geometry.elementsNeedUpdate === true ) {\\n\\n\\t\\t\\t\\t\\tdirect = undefined;\\n\\t\\t\\t\\t\\tgeometry.elementsNeedUpdate = false;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( direct === undefined ) {\\n\\n\\t\\t\\t\\t\\treturn this.fromGeometry( geometry );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\\n\\t\\t\\t\\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\\n\\t\\t\\t\\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\\n\\t\\t\\t\\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\\n\\t\\t\\t\\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\\n\\n\\t\\t\\t\\tgeometry.verticesNeedUpdate = false;\\n\\t\\t\\t\\tgeometry.normalsNeedUpdate = false;\\n\\t\\t\\t\\tgeometry.colorsNeedUpdate = false;\\n\\t\\t\\t\\tgeometry.uvsNeedUpdate = false;\\n\\t\\t\\t\\tgeometry.groupsNeedUpdate = false;\\n\\n\\t\\t\\t\\tgeometry = direct;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar attribute;\\n\\n\\t\\t\\tif ( geometry.verticesNeedUpdate === true ) {\\n\\n\\t\\t\\t\\tattribute = this.attributes.position;\\n\\n\\t\\t\\t\\tif ( attribute !== undefined ) {\\n\\n\\t\\t\\t\\t\\tattribute.copyVector3sArray( geometry.vertices );\\n\\t\\t\\t\\t\\tattribute.needsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgeometry.verticesNeedUpdate = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.normalsNeedUpdate === true ) {\\n\\n\\t\\t\\t\\tattribute = this.attributes.normal;\\n\\n\\t\\t\\t\\tif ( attribute !== undefined ) {\\n\\n\\t\\t\\t\\t\\tattribute.copyVector3sArray( geometry.normals );\\n\\t\\t\\t\\t\\tattribute.needsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgeometry.normalsNeedUpdate = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.colorsNeedUpdate === true ) {\\n\\n\\t\\t\\t\\tattribute = this.attributes.color;\\n\\n\\t\\t\\t\\tif ( attribute !== undefined ) {\\n\\n\\t\\t\\t\\t\\tattribute.copyColorsArray( geometry.colors );\\n\\t\\t\\t\\t\\tattribute.needsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgeometry.colorsNeedUpdate = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.uvsNeedUpdate ) {\\n\\n\\t\\t\\t\\tattribute = this.attributes.uv;\\n\\n\\t\\t\\t\\tif ( attribute !== undefined ) {\\n\\n\\t\\t\\t\\t\\tattribute.copyVector2sArray( geometry.uvs );\\n\\t\\t\\t\\t\\tattribute.needsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgeometry.uvsNeedUpdate = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.lineDistancesNeedUpdate ) {\\n\\n\\t\\t\\t\\tattribute = this.attributes.lineDistance;\\n\\n\\t\\t\\t\\tif ( attribute !== undefined ) {\\n\\n\\t\\t\\t\\t\\tattribute.copyArray( geometry.lineDistances );\\n\\t\\t\\t\\t\\tattribute.needsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgeometry.lineDistancesNeedUpdate = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.groupsNeedUpdate ) {\\n\\n\\t\\t\\t\\tgeometry.computeGroups( object.geometry );\\n\\t\\t\\t\\tthis.groups = geometry.groups;\\n\\n\\t\\t\\t\\tgeometry.groupsNeedUpdate = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tfromGeometry: function ( geometry ) {\\n\\n\\t\\t\\tgeometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );\\n\\n\\t\\t\\treturn this.fromDirectGeometry( geometry.__directGeometry );\\n\\n\\t\\t},\\n\\n\\t\\tfromDirectGeometry: function ( geometry ) {\\n\\n\\t\\t\\tvar positions = new Float32Array( geometry.vertices.length * 3 );\\n\\t\\t\\tthis.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\\n\\n\\t\\t\\tif ( geometry.normals.length > 0 ) {\\n\\n\\t\\t\\t\\tvar normals = new Float32Array( geometry.normals.length * 3 );\\n\\t\\t\\t\\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.colors.length > 0 ) {\\n\\n\\t\\t\\t\\tvar colors = new Float32Array( geometry.colors.length * 3 );\\n\\t\\t\\t\\tthis.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.uvs.length > 0 ) {\\n\\n\\t\\t\\t\\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\\n\\t\\t\\t\\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.uvs2.length > 0 ) {\\n\\n\\t\\t\\t\\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\\n\\t\\t\\t\\tthis.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.indices.length > 0 ) {\\n\\n\\t\\t\\t\\tvar TypeArray = arrayMax( geometry.indices ) > 65535 ? Uint32Array : Uint16Array;\\n\\t\\t\\t\\tvar indices = new TypeArray( geometry.indices.length * 3 );\\n\\t\\t\\t\\tthis.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// groups\\n\\n\\t\\t\\tthis.groups = geometry.groups;\\n\\n\\t\\t\\t// morphs\\n\\n\\t\\t\\tfor ( var name in geometry.morphTargets ) {\\n\\n\\t\\t\\t\\tvar array = [];\\n\\t\\t\\t\\tvar morphTargets = geometry.morphTargets[ name ];\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar morphTarget = morphTargets[ i ];\\n\\n\\t\\t\\t\\t\\tvar attribute = new Float32BufferAttribute( morphTarget.length * 3, 3 );\\n\\n\\t\\t\\t\\t\\tarray.push( attribute.copyVector3sArray( morphTarget ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.morphAttributes[ name ] = array;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// skinning\\n\\n\\t\\t\\tif ( geometry.skinIndices.length > 0 ) {\\n\\n\\t\\t\\t\\tvar skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );\\n\\t\\t\\t\\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.skinWeights.length > 0 ) {\\n\\n\\t\\t\\t\\tvar skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );\\n\\t\\t\\t\\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tif ( geometry.boundingSphere !== null ) {\\n\\n\\t\\t\\t\\tthis.boundingSphere = geometry.boundingSphere.clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.boundingBox !== null ) {\\n\\n\\t\\t\\t\\tthis.boundingBox = geometry.boundingBox.clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcomputeBoundingBox: function () {\\n\\n\\t\\t\\tif ( this.boundingBox === null ) {\\n\\n\\t\\t\\t\\tthis.boundingBox = new Box3();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar position = this.attributes.position;\\n\\n\\t\\t\\tif ( position !== undefined ) {\\n\\n\\t\\t\\t\\tthis.boundingBox.setFromBufferAttribute( position );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.boundingBox.makeEmpty();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \\\"position\\\" attribute is likely to have NaN values.', this );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tcomputeBoundingSphere: function () {\\n\\n\\t\\t\\tvar box = new Box3();\\n\\t\\t\\tvar vector = new Vector3();\\n\\n\\t\\t\\treturn function computeBoundingSphere() {\\n\\n\\t\\t\\t\\tif ( this.boundingSphere === null ) {\\n\\n\\t\\t\\t\\t\\tthis.boundingSphere = new Sphere();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar position = this.attributes.position;\\n\\n\\t\\t\\t\\tif ( position ) {\\n\\n\\t\\t\\t\\t\\tvar center = this.boundingSphere.center;\\n\\n\\t\\t\\t\\t\\tbox.setFromBufferAttribute( position );\\n\\t\\t\\t\\t\\tbox.getCenter( center );\\n\\n\\t\\t\\t\\t\\t// hoping to find a boundingSphere with a radius smaller than the\\n\\t\\t\\t\\t\\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\\n\\n\\t\\t\\t\\t\\tvar maxRadiusSq = 0;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = position.count; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvector.x = position.getX( i );\\n\\t\\t\\t\\t\\t\\tvector.y = position.getY( i );\\n\\t\\t\\t\\t\\t\\tvector.z = position.getZ( i );\\n\\t\\t\\t\\t\\t\\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\\n\\n\\t\\t\\t\\t\\tif ( isNaN( this.boundingSphere.radius ) ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \\\"position\\\" attribute is likely to have NaN values.', this );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tcomputeFaceNormals: function () {\\n\\n\\t\\t\\t// backwards compatibility\\n\\n\\t\\t},\\n\\n\\t\\tcomputeVertexNormals: function () {\\n\\n\\t\\t\\tvar index = this.index;\\n\\t\\t\\tvar attributes = this.attributes;\\n\\t\\t\\tvar groups = this.groups;\\n\\n\\t\\t\\tif ( attributes.position ) {\\n\\n\\t\\t\\t\\tvar positions = attributes.position.array;\\n\\n\\t\\t\\t\\tif ( attributes.normal === undefined ) {\\n\\n\\t\\t\\t\\t\\tthis.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// reset existing normals to zero\\n\\n\\t\\t\\t\\t\\tvar array = attributes.normal.array;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tarray[ i ] = 0;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar normals = attributes.normal.array;\\n\\n\\t\\t\\t\\tvar vA, vB, vC;\\n\\t\\t\\t\\tvar pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\\n\\t\\t\\t\\tvar cb = new Vector3(), ab = new Vector3();\\n\\n\\t\\t\\t\\t// indexed elements\\n\\n\\t\\t\\t\\tif ( index ) {\\n\\n\\t\\t\\t\\t\\tvar indices = index.array;\\n\\n\\t\\t\\t\\t\\tif ( groups.length === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.addGroup( 0, indices.length );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0, jl = groups.length; j < jl; ++ j ) {\\n\\n\\t\\t\\t\\t\\t\\tvar group = groups[ j ];\\n\\n\\t\\t\\t\\t\\t\\tvar start = group.start;\\n\\t\\t\\t\\t\\t\\tvar count = group.count;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvA = indices[ i + 0 ] * 3;\\n\\t\\t\\t\\t\\t\\t\\tvB = indices[ i + 1 ] * 3;\\n\\t\\t\\t\\t\\t\\t\\tvC = indices[ i + 2 ] * 3;\\n\\n\\t\\t\\t\\t\\t\\t\\tpA.fromArray( positions, vA );\\n\\t\\t\\t\\t\\t\\t\\tpB.fromArray( positions, vB );\\n\\t\\t\\t\\t\\t\\t\\tpC.fromArray( positions, vC );\\n\\n\\t\\t\\t\\t\\t\\t\\tcb.subVectors( pC, pB );\\n\\t\\t\\t\\t\\t\\t\\tab.subVectors( pA, pB );\\n\\t\\t\\t\\t\\t\\t\\tcb.cross( ab );\\n\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vA ] += cb.x;\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vA + 1 ] += cb.y;\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vA + 2 ] += cb.z;\\n\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vB ] += cb.x;\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vB + 1 ] += cb.y;\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vB + 2 ] += cb.z;\\n\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vC ] += cb.x;\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vC + 1 ] += cb.y;\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vC + 2 ] += cb.z;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// non-indexed elements (unconnected triangle soup)\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\\n\\n\\t\\t\\t\\t\\t\\tpA.fromArray( positions, i );\\n\\t\\t\\t\\t\\t\\tpB.fromArray( positions, i + 3 );\\n\\t\\t\\t\\t\\t\\tpC.fromArray( positions, i + 6 );\\n\\n\\t\\t\\t\\t\\t\\tcb.subVectors( pC, pB );\\n\\t\\t\\t\\t\\t\\tab.subVectors( pA, pB );\\n\\t\\t\\t\\t\\t\\tcb.cross( ab );\\n\\n\\t\\t\\t\\t\\t\\tnormals[ i ] = cb.x;\\n\\t\\t\\t\\t\\t\\tnormals[ i + 1 ] = cb.y;\\n\\t\\t\\t\\t\\t\\tnormals[ i + 2 ] = cb.z;\\n\\n\\t\\t\\t\\t\\t\\tnormals[ i + 3 ] = cb.x;\\n\\t\\t\\t\\t\\t\\tnormals[ i + 4 ] = cb.y;\\n\\t\\t\\t\\t\\t\\tnormals[ i + 5 ] = cb.z;\\n\\n\\t\\t\\t\\t\\t\\tnormals[ i + 6 ] = cb.x;\\n\\t\\t\\t\\t\\t\\tnormals[ i + 7 ] = cb.y;\\n\\t\\t\\t\\t\\t\\tnormals[ i + 8 ] = cb.z;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.normalizeNormals();\\n\\n\\t\\t\\t\\tattributes.normal.needsUpdate = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tmerge: function ( geometry, offset ) {\\n\\n\\t\\t\\tif ( ! ( geometry && geometry.isBufferGeometry ) ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tvar attributes = this.attributes;\\n\\n\\t\\t\\tfor ( var key in attributes ) {\\n\\n\\t\\t\\t\\tif ( geometry.attributes[ key ] === undefined ) continue;\\n\\n\\t\\t\\t\\tvar attribute1 = attributes[ key ];\\n\\t\\t\\t\\tvar attributeArray1 = attribute1.array;\\n\\n\\t\\t\\t\\tvar attribute2 = geometry.attributes[ key ];\\n\\t\\t\\t\\tvar attributeArray2 = attribute2.array;\\n\\n\\t\\t\\t\\tvar attributeSize = attribute2.itemSize;\\n\\n\\t\\t\\t\\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\\n\\n\\t\\t\\t\\t\\tattributeArray1[ j ] = attributeArray2[ i ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tnormalizeNormals: function () {\\n\\n\\t\\t\\tvar vector = new Vector3();\\n\\n\\t\\t\\treturn function normalizeNormals() {\\n\\n\\t\\t\\t\\tvar normals = this.attributes.normal;\\n\\n\\t\\t\\t\\tfor ( var i = 0, il = normals.count; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvector.x = normals.getX( i );\\n\\t\\t\\t\\t\\tvector.y = normals.getY( i );\\n\\t\\t\\t\\t\\tvector.z = normals.getZ( i );\\n\\n\\t\\t\\t\\t\\tvector.normalize();\\n\\n\\t\\t\\t\\t\\tnormals.setXYZ( i, vector.x, vector.y, vector.z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttoNonIndexed: function () {\\n\\n\\t\\t\\tif ( this.index === null ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar geometry2 = new BufferGeometry();\\n\\n\\t\\t\\tvar indices = this.index.array;\\n\\t\\t\\tvar attributes = this.attributes;\\n\\n\\t\\t\\tfor ( var name in attributes ) {\\n\\n\\t\\t\\t\\tvar attribute = attributes[ name ];\\n\\n\\t\\t\\t\\tvar array = attribute.array;\\n\\t\\t\\t\\tvar itemSize = attribute.itemSize;\\n\\n\\t\\t\\t\\tvar array2 = new array.constructor( indices.length * itemSize );\\n\\n\\t\\t\\t\\tvar index = 0, index2 = 0;\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tindex = indices[ i ] * itemSize;\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0; j < itemSize; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tarray2[ index2 ++ ] = array[ index ++ ];\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgeometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn geometry2;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function () {\\n\\n\\t\\t\\tvar data = {\\n\\t\\t\\t\\tmetadata: {\\n\\t\\t\\t\\t\\tversion: 4.5,\\n\\t\\t\\t\\t\\ttype: 'BufferGeometry',\\n\\t\\t\\t\\t\\tgenerator: 'BufferGeometry.toJSON'\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\t\\t// standard BufferGeometry serialization\\n\\n\\t\\t\\tdata.uuid = this.uuid;\\n\\t\\t\\tdata.type = this.type;\\n\\t\\t\\tif ( this.name !== '' ) data.name = this.name;\\n\\n\\t\\t\\tif ( this.parameters !== undefined ) {\\n\\n\\t\\t\\t\\tvar parameters = this.parameters;\\n\\n\\t\\t\\t\\tfor ( var key in parameters ) {\\n\\n\\t\\t\\t\\t\\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn data;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tdata.data = { attributes: {} };\\n\\n\\t\\t\\tvar index = this.index;\\n\\n\\t\\t\\tif ( index !== null ) {\\n\\n\\t\\t\\t\\tvar array = Array.prototype.slice.call( index.array );\\n\\n\\t\\t\\t\\tdata.data.index = {\\n\\t\\t\\t\\t\\ttype: index.array.constructor.name,\\n\\t\\t\\t\\t\\tarray: array\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar attributes = this.attributes;\\n\\n\\t\\t\\tfor ( var key in attributes ) {\\n\\n\\t\\t\\t\\tvar attribute = attributes[ key ];\\n\\n\\t\\t\\t\\tvar array = Array.prototype.slice.call( attribute.array );\\n\\n\\t\\t\\t\\tdata.data.attributes[ key ] = {\\n\\t\\t\\t\\t\\titemSize: attribute.itemSize,\\n\\t\\t\\t\\t\\ttype: attribute.array.constructor.name,\\n\\t\\t\\t\\t\\tarray: array,\\n\\t\\t\\t\\t\\tnormalized: attribute.normalized\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar groups = this.groups;\\n\\n\\t\\t\\tif ( groups.length > 0 ) {\\n\\n\\t\\t\\t\\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar boundingSphere = this.boundingSphere;\\n\\n\\t\\t\\tif ( boundingSphere !== null ) {\\n\\n\\t\\t\\t\\tdata.data.boundingSphere = {\\n\\t\\t\\t\\t\\tcenter: boundingSphere.center.toArray(),\\n\\t\\t\\t\\t\\tradius: boundingSphere.radius\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\t/*\\n\\t\\t\\t // Handle primitives\\n\\n\\t\\t\\t var parameters = this.parameters;\\n\\n\\t\\t\\t if ( parameters !== undefined ) {\\n\\n\\t\\t\\t var values = [];\\n\\n\\t\\t\\t for ( var key in parameters ) {\\n\\n\\t\\t\\t values.push( parameters[ key ] );\\n\\n\\t\\t\\t }\\n\\n\\t\\t\\t var geometry = Object.create( this.constructor.prototype );\\n\\t\\t\\t this.constructor.apply( geometry, values );\\n\\t\\t\\t return geometry;\\n\\n\\t\\t\\t }\\n\\n\\t\\t\\t return new this.constructor().copy( this );\\n\\t\\t\\t */\\n\\n\\t\\t\\treturn new BufferGeometry().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tvar name, i, l;\\n\\n\\t\\t\\t// reset\\n\\n\\t\\t\\tthis.index = null;\\n\\t\\t\\tthis.attributes = {};\\n\\t\\t\\tthis.morphAttributes = {};\\n\\t\\t\\tthis.groups = [];\\n\\t\\t\\tthis.boundingBox = null;\\n\\t\\t\\tthis.boundingSphere = null;\\n\\n\\t\\t\\t// name\\n\\n\\t\\t\\tthis.name = source.name;\\n\\n\\t\\t\\t// index\\n\\n\\t\\t\\tvar index = source.index;\\n\\n\\t\\t\\tif ( index !== null ) {\\n\\n\\t\\t\\t\\tthis.setIndex( index.clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// attributes\\n\\n\\t\\t\\tvar attributes = source.attributes;\\n\\n\\t\\t\\tfor ( name in attributes ) {\\n\\n\\t\\t\\t\\tvar attribute = attributes[ name ];\\n\\t\\t\\t\\tthis.addAttribute( name, attribute.clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// morph attributes\\n\\n\\t\\t\\tvar morphAttributes = source.morphAttributes;\\n\\n\\t\\t\\tfor ( name in morphAttributes ) {\\n\\n\\t\\t\\t\\tvar array = [];\\n\\t\\t\\t\\tvar morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\\n\\n\\t\\t\\t\\tfor ( i = 0, l = morphAttribute.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tarray.push( morphAttribute[ i ].clone() );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.morphAttributes[ name ] = array;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// groups\\n\\n\\t\\t\\tvar groups = source.groups;\\n\\n\\t\\t\\tfor ( i = 0, l = groups.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar group = groups[ i ];\\n\\t\\t\\t\\tthis.addGroup( group.start, group.count, group.materialIndex );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// bounding box\\n\\n\\t\\t\\tvar boundingBox = source.boundingBox;\\n\\n\\t\\t\\tif ( boundingBox !== null ) {\\n\\n\\t\\t\\t\\tthis.boundingBox = boundingBox.clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// bounding sphere\\n\\n\\t\\t\\tvar boundingSphere = source.boundingSphere;\\n\\n\\t\\t\\tif ( boundingSphere !== null ) {\\n\\n\\t\\t\\t\\tthis.boundingSphere = boundingSphere.clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// draw range\\n\\n\\t\\t\\tthis.drawRange.start = source.drawRange.start;\\n\\t\\t\\tthis.drawRange.count = source.drawRange.count;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdispose: function () {\\n\\n\\t\\t\\tthis.dispatchEvent( { type: 'dispose' } );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// BoxGeometry\\n\\n\\tfunction BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'BoxGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\twidth: width,\\n\\t\\t\\theight: height,\\n\\t\\t\\tdepth: depth,\\n\\t\\t\\twidthSegments: widthSegments,\\n\\t\\t\\theightSegments: heightSegments,\\n\\t\\t\\tdepthSegments: depthSegments\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tBoxGeometry.prototype = Object.create( Geometry.prototype );\\n\\tBoxGeometry.prototype.constructor = BoxGeometry;\\n\\n\\t// BoxBufferGeometry\\n\\n\\tfunction BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'BoxBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\twidth: width,\\n\\t\\t\\theight: height,\\n\\t\\t\\tdepth: depth,\\n\\t\\t\\twidthSegments: widthSegments,\\n\\t\\t\\theightSegments: heightSegments,\\n\\t\\t\\tdepthSegments: depthSegments\\n\\t\\t};\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\twidth = width || 1;\\n\\t\\theight = height || 1;\\n\\t\\tdepth = depth || 1;\\n\\n\\t\\t// segments\\n\\n\\t\\twidthSegments = Math.floor( widthSegments ) || 1;\\n\\t\\theightSegments = Math.floor( heightSegments ) || 1;\\n\\t\\tdepthSegments = Math.floor( depthSegments ) || 1;\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar numberOfVertices = 0;\\n\\t\\tvar groupStart = 0;\\n\\n\\t\\t// build each side of the box geometry\\n\\n\\t\\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px\\n\\t\\tbuildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx\\n\\t\\tbuildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py\\n\\t\\tbuildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny\\n\\t\\tbuildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz\\n\\t\\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t\\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\\n\\n\\t\\t\\tvar segmentWidth = width / gridX;\\n\\t\\t\\tvar segmentHeight = height / gridY;\\n\\n\\t\\t\\tvar widthHalf = width / 2;\\n\\t\\t\\tvar heightHalf = height / 2;\\n\\t\\t\\tvar depthHalf = depth / 2;\\n\\n\\t\\t\\tvar gridX1 = gridX + 1;\\n\\t\\t\\tvar gridY1 = gridY + 1;\\n\\n\\t\\t\\tvar vertexCounter = 0;\\n\\t\\t\\tvar groupCount = 0;\\n\\n\\t\\t\\tvar ix, iy;\\n\\n\\t\\t\\tvar vector = new Vector3();\\n\\n\\t\\t\\t// generate vertices, normals and uvs\\n\\n\\t\\t\\tfor ( iy = 0; iy < gridY1; iy ++ ) {\\n\\n\\t\\t\\t\\tvar y = iy * segmentHeight - heightHalf;\\n\\n\\t\\t\\t\\tfor ( ix = 0; ix < gridX1; ix ++ ) {\\n\\n\\t\\t\\t\\t\\tvar x = ix * segmentWidth - widthHalf;\\n\\n\\t\\t\\t\\t\\t// set values to correct vector component\\n\\n\\t\\t\\t\\t\\tvector[ u ] = x * udir;\\n\\t\\t\\t\\t\\tvector[ v ] = y * vdir;\\n\\t\\t\\t\\t\\tvector[ w ] = depthHalf;\\n\\n\\t\\t\\t\\t\\t// now apply vector to vertex buffer\\n\\n\\t\\t\\t\\t\\tvertices.push( vector.x, vector.y, vector.z );\\n\\n\\t\\t\\t\\t\\t// set values to correct vector component\\n\\n\\t\\t\\t\\t\\tvector[ u ] = 0;\\n\\t\\t\\t\\t\\tvector[ v ] = 0;\\n\\t\\t\\t\\t\\tvector[ w ] = depth > 0 ? 1 : - 1;\\n\\n\\t\\t\\t\\t\\t// now apply vector to normal buffer\\n\\n\\t\\t\\t\\t\\tnormals.push( vector.x, vector.y, vector.z );\\n\\n\\t\\t\\t\\t\\t// uvs\\n\\n\\t\\t\\t\\t\\tuvs.push( ix / gridX );\\n\\t\\t\\t\\t\\tuvs.push( 1 - ( iy / gridY ) );\\n\\n\\t\\t\\t\\t\\t// counters\\n\\n\\t\\t\\t\\t\\tvertexCounter += 1;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// indices\\n\\n\\t\\t\\t// 1. you need three indices to draw a single face\\n\\t\\t\\t// 2. a single segment consists of two faces\\n\\t\\t\\t// 3. so we need to generate six (2*3) indices per segment\\n\\n\\t\\t\\tfor ( iy = 0; iy < gridY; iy ++ ) {\\n\\n\\t\\t\\t\\tfor ( ix = 0; ix < gridX; ix ++ ) {\\n\\n\\t\\t\\t\\t\\tvar a = numberOfVertices + ix + gridX1 * iy;\\n\\t\\t\\t\\t\\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\\n\\t\\t\\t\\t\\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\\n\\t\\t\\t\\t\\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\\n\\n\\t\\t\\t\\t\\t// faces\\n\\n\\t\\t\\t\\t\\tindices.push( a, b, d );\\n\\t\\t\\t\\t\\tindices.push( b, c, d );\\n\\n\\t\\t\\t\\t\\t// increase counter\\n\\n\\t\\t\\t\\t\\tgroupCount += 6;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// add a group to the geometry. this will ensure multi material support\\n\\n\\t\\t\\tscope.addGroup( groupStart, groupCount, materialIndex );\\n\\n\\t\\t\\t// calculate new start value for groups\\n\\n\\t\\t\\tgroupStart += groupCount;\\n\\n\\t\\t\\t// update total number of vertices\\n\\n\\t\\t\\tnumberOfVertices += vertexCounter;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tBoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tBoxBufferGeometry.prototype.constructor = BoxBufferGeometry;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// PlaneGeometry\\n\\n\\tfunction PlaneGeometry( width, height, widthSegments, heightSegments ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'PlaneGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\twidth: width,\\n\\t\\t\\theight: height,\\n\\t\\t\\twidthSegments: widthSegments,\\n\\t\\t\\theightSegments: heightSegments\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tPlaneGeometry.prototype = Object.create( Geometry.prototype );\\n\\tPlaneGeometry.prototype.constructor = PlaneGeometry;\\n\\n\\t// PlaneBufferGeometry\\n\\n\\tfunction PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'PlaneBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\twidth: width,\\n\\t\\t\\theight: height,\\n\\t\\t\\twidthSegments: widthSegments,\\n\\t\\t\\theightSegments: heightSegments\\n\\t\\t};\\n\\n\\t\\twidth = width || 1;\\n\\t\\theight = height || 1;\\n\\n\\t\\tvar width_half = width / 2;\\n\\t\\tvar height_half = height / 2;\\n\\n\\t\\tvar gridX = Math.floor( widthSegments ) || 1;\\n\\t\\tvar gridY = Math.floor( heightSegments ) || 1;\\n\\n\\t\\tvar gridX1 = gridX + 1;\\n\\t\\tvar gridY1 = gridY + 1;\\n\\n\\t\\tvar segment_width = width / gridX;\\n\\t\\tvar segment_height = height / gridY;\\n\\n\\t\\tvar ix, iy;\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// generate vertices, normals and uvs\\n\\n\\t\\tfor ( iy = 0; iy < gridY1; iy ++ ) {\\n\\n\\t\\t\\tvar y = iy * segment_height - height_half;\\n\\n\\t\\t\\tfor ( ix = 0; ix < gridX1; ix ++ ) {\\n\\n\\t\\t\\t\\tvar x = ix * segment_width - width_half;\\n\\n\\t\\t\\t\\tvertices.push( x, - y, 0 );\\n\\n\\t\\t\\t\\tnormals.push( 0, 0, 1 );\\n\\n\\t\\t\\t\\tuvs.push( ix / gridX );\\n\\t\\t\\t\\tuvs.push( 1 - ( iy / gridY ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// indices\\n\\n\\t\\tfor ( iy = 0; iy < gridY; iy ++ ) {\\n\\n\\t\\t\\tfor ( ix = 0; ix < gridX; ix ++ ) {\\n\\n\\t\\t\\t\\tvar a = ix + gridX1 * iy;\\n\\t\\t\\t\\tvar b = ix + gridX1 * ( iy + 1 );\\n\\t\\t\\t\\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\\n\\t\\t\\t\\tvar d = ( ix + 1 ) + gridX1 * iy;\\n\\n\\t\\t\\t\\t// faces\\n\\n\\t\\t\\t\\tindices.push( a, b, d );\\n\\t\\t\\t\\tindices.push( b, c, d );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t}\\n\\n\\tPlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tPlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t *\\n\\t * parameters = {\\n\\t *  color: <hex>,\\n\\t *  opacity: <float>,\\n\\t *  map: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  lightMap: new THREE.Texture( <Image> ),\\n\\t *  lightMapIntensity: <float>\\n\\t *\\n\\t *  aoMap: new THREE.Texture( <Image> ),\\n\\t *  aoMapIntensity: <float>\\n\\t *\\n\\t *  specularMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  alphaMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\\n\\t *  combine: THREE.Multiply,\\n\\t *  reflectivity: <float>,\\n\\t *  refractionRatio: <float>,\\n\\t *\\n\\t *  depthTest: <bool>,\\n\\t *  depthWrite: <bool>,\\n\\t *\\n\\t *  wireframe: <boolean>,\\n\\t *  wireframeLinewidth: <float>,\\n\\t *\\n\\t *  skinning: <bool>,\\n\\t *  morphTargets: <bool>\\n\\t * }\\n\\t */\\n\\n\\tfunction MeshBasicMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'MeshBasicMaterial';\\n\\n\\t\\tthis.color = new Color( 0xffffff ); // emissive\\n\\n\\t\\tthis.map = null;\\n\\n\\t\\tthis.lightMap = null;\\n\\t\\tthis.lightMapIntensity = 1.0;\\n\\n\\t\\tthis.aoMap = null;\\n\\t\\tthis.aoMapIntensity = 1.0;\\n\\n\\t\\tthis.specularMap = null;\\n\\n\\t\\tthis.alphaMap = null;\\n\\n\\t\\tthis.envMap = null;\\n\\t\\tthis.combine = MultiplyOperation;\\n\\t\\tthis.reflectivity = 1;\\n\\t\\tthis.refractionRatio = 0.98;\\n\\n\\t\\tthis.wireframe = false;\\n\\t\\tthis.wireframeLinewidth = 1;\\n\\t\\tthis.wireframeLinecap = 'round';\\n\\t\\tthis.wireframeLinejoin = 'round';\\n\\n\\t\\tthis.skinning = false;\\n\\t\\tthis.morphTargets = false;\\n\\n\\t\\tthis.lights = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tMeshBasicMaterial.prototype = Object.create( Material.prototype );\\n\\tMeshBasicMaterial.prototype.constructor = MeshBasicMaterial;\\n\\n\\tMeshBasicMaterial.prototype.isMeshBasicMaterial = true;\\n\\n\\tMeshBasicMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.color.copy( source.color );\\n\\n\\t\\tthis.map = source.map;\\n\\n\\t\\tthis.lightMap = source.lightMap;\\n\\t\\tthis.lightMapIntensity = source.lightMapIntensity;\\n\\n\\t\\tthis.aoMap = source.aoMap;\\n\\t\\tthis.aoMapIntensity = source.aoMapIntensity;\\n\\n\\t\\tthis.specularMap = source.specularMap;\\n\\n\\t\\tthis.alphaMap = source.alphaMap;\\n\\n\\t\\tthis.envMap = source.envMap;\\n\\t\\tthis.combine = source.combine;\\n\\t\\tthis.reflectivity = source.reflectivity;\\n\\t\\tthis.refractionRatio = source.refractionRatio;\\n\\n\\t\\tthis.wireframe = source.wireframe;\\n\\t\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\n\\t\\tthis.wireframeLinecap = source.wireframeLinecap;\\n\\t\\tthis.wireframeLinejoin = source.wireframeLinejoin;\\n\\n\\t\\tthis.skinning = source.skinning;\\n\\t\\tthis.morphTargets = source.morphTargets;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t *\\n\\t * parameters = {\\n\\t *  defines: { \\\"label\\\" : \\\"value\\\" },\\n\\t *  uniforms: { \\\"parameter1\\\": { value: 1.0 }, \\\"parameter2\\\": { value2: 2 } },\\n\\t *\\n\\t *  fragmentShader: <string>,\\n\\t *  vertexShader: <string>,\\n\\t *\\n\\t *  wireframe: <boolean>,\\n\\t *  wireframeLinewidth: <float>,\\n\\t *\\n\\t *  lights: <bool>,\\n\\t *\\n\\t *  skinning: <bool>,\\n\\t *  morphTargets: <bool>,\\n\\t *  morphNormals: <bool>\\n\\t * }\\n\\t */\\n\\n\\tfunction ShaderMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'ShaderMaterial';\\n\\n\\t\\tthis.defines = {};\\n\\t\\tthis.uniforms = {};\\n\\n\\t\\tthis.vertexShader = 'void main() {\\\\n\\\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\\n}';\\n\\t\\tthis.fragmentShader = 'void main() {\\\\n\\\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\\\n}';\\n\\n\\t\\tthis.linewidth = 1;\\n\\n\\t\\tthis.wireframe = false;\\n\\t\\tthis.wireframeLinewidth = 1;\\n\\n\\t\\tthis.fog = false; // set to use scene fog\\n\\t\\tthis.lights = false; // set to use scene lights\\n\\t\\tthis.clipping = false; // set to use user-defined clipping planes\\n\\n\\t\\tthis.skinning = false; // set to use skinning attribute streams\\n\\t\\tthis.morphTargets = false; // set to use morph targets\\n\\t\\tthis.morphNormals = false; // set to use morph normals\\n\\n\\t\\tthis.extensions = {\\n\\t\\t\\tderivatives: false, // set to use derivatives\\n\\t\\t\\tfragDepth: false, // set to use fragment depth values\\n\\t\\t\\tdrawBuffers: false, // set to use draw buffers\\n\\t\\t\\tshaderTextureLOD: false // set to use shader texture LOD\\n\\t\\t};\\n\\n\\t\\t// When rendered geometry doesn't include these attributes but the material does,\\n\\t\\t// use these default values in WebGL. This avoids errors when buffer data is missing.\\n\\t\\tthis.defaultAttributeValues = {\\n\\t\\t\\t'color': [ 1, 1, 1 ],\\n\\t\\t\\t'uv': [ 0, 0 ],\\n\\t\\t\\t'uv2': [ 0, 0 ]\\n\\t\\t};\\n\\n\\t\\tthis.index0AttributeName = undefined;\\n\\n\\t\\tif ( parameters !== undefined ) {\\n\\n\\t\\t\\tif ( parameters.attributes !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.setValues( parameters );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tShaderMaterial.prototype = Object.create( Material.prototype );\\n\\tShaderMaterial.prototype.constructor = ShaderMaterial;\\n\\n\\tShaderMaterial.prototype.isShaderMaterial = true;\\n\\n\\tShaderMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.fragmentShader = source.fragmentShader;\\n\\t\\tthis.vertexShader = source.vertexShader;\\n\\n\\t\\tthis.uniforms = UniformsUtils.clone( source.uniforms );\\n\\n\\t\\tthis.defines = source.defines;\\n\\n\\t\\tthis.wireframe = source.wireframe;\\n\\t\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\n\\n\\t\\tthis.lights = source.lights;\\n\\t\\tthis.clipping = source.clipping;\\n\\n\\t\\tthis.skinning = source.skinning;\\n\\n\\t\\tthis.morphTargets = source.morphTargets;\\n\\t\\tthis.morphNormals = source.morphNormals;\\n\\n\\t\\tthis.extensions = source.extensions;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tShaderMaterial.prototype.toJSON = function ( meta ) {\\n\\n\\t\\tvar data = Material.prototype.toJSON.call( this, meta );\\n\\n\\t\\tdata.uniforms = this.uniforms;\\n\\t\\tdata.vertexShader = this.vertexShader;\\n\\t\\tdata.fragmentShader = this.fragmentShader;\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author bhouston / http://clara.io\\n\\t */\\n\\n\\tfunction Ray( origin, direction ) {\\n\\n\\t\\tthis.origin = ( origin !== undefined ) ? origin : new Vector3();\\n\\t\\tthis.direction = ( direction !== undefined ) ? direction : new Vector3();\\n\\n\\t}\\n\\n\\tObject.assign( Ray.prototype, {\\n\\n\\t\\tset: function ( origin, direction ) {\\n\\n\\t\\t\\tthis.origin.copy( origin );\\n\\t\\t\\tthis.direction.copy( direction );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( ray ) {\\n\\n\\t\\t\\tthis.origin.copy( ray.origin );\\n\\t\\t\\tthis.direction.copy( ray.direction );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tat: function ( t, optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\\n\\n\\t\\t},\\n\\n\\t\\tlookAt: function ( v ) {\\n\\n\\t\\t\\tthis.direction.copy( v ).sub( this.origin ).normalize();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\trecast: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function recast( t ) {\\n\\n\\t\\t\\t\\tthis.origin.copy( this.at( t, v1 ) );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tclosestPointToPoint: function ( point, optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\t\\t\\tresult.subVectors( point, this.origin );\\n\\t\\t\\tvar directionDistance = result.dot( this.direction );\\n\\n\\t\\t\\tif ( directionDistance < 0 ) {\\n\\n\\t\\t\\t\\treturn result.copy( this.origin );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\\n\\n\\t\\t},\\n\\n\\t\\tdistanceToPoint: function ( point ) {\\n\\n\\t\\t\\treturn Math.sqrt( this.distanceSqToPoint( point ) );\\n\\n\\t\\t},\\n\\n\\t\\tdistanceSqToPoint: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function distanceSqToPoint( point ) {\\n\\n\\t\\t\\t\\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\\n\\n\\t\\t\\t\\t// point behind the ray\\n\\n\\t\\t\\t\\tif ( directionDistance < 0 ) {\\n\\n\\t\\t\\t\\t\\treturn this.origin.distanceToSquared( point );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\\n\\n\\t\\t\\t\\treturn v1.distanceToSquared( point );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tdistanceSqToSegment: function () {\\n\\n\\t\\t\\tvar segCenter = new Vector3();\\n\\t\\t\\tvar segDir = new Vector3();\\n\\t\\t\\tvar diff = new Vector3();\\n\\n\\t\\t\\treturn function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\\n\\n\\t\\t\\t\\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\\n\\t\\t\\t\\t// It returns the min distance between the ray and the segment\\n\\t\\t\\t\\t// defined by v0 and v1\\n\\t\\t\\t\\t// It can also set two optional targets :\\n\\t\\t\\t\\t// - The closest point on the ray\\n\\t\\t\\t\\t// - The closest point on the segment\\n\\n\\t\\t\\t\\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\\n\\t\\t\\t\\tsegDir.copy( v1 ).sub( v0 ).normalize();\\n\\t\\t\\t\\tdiff.copy( this.origin ).sub( segCenter );\\n\\n\\t\\t\\t\\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\\n\\t\\t\\t\\tvar a01 = - this.direction.dot( segDir );\\n\\t\\t\\t\\tvar b0 = diff.dot( this.direction );\\n\\t\\t\\t\\tvar b1 = - diff.dot( segDir );\\n\\t\\t\\t\\tvar c = diff.lengthSq();\\n\\t\\t\\t\\tvar det = Math.abs( 1 - a01 * a01 );\\n\\t\\t\\t\\tvar s0, s1, sqrDist, extDet;\\n\\n\\t\\t\\t\\tif ( det > 0 ) {\\n\\n\\t\\t\\t\\t\\t// The ray and segment are not parallel.\\n\\n\\t\\t\\t\\t\\ts0 = a01 * b1 - b0;\\n\\t\\t\\t\\t\\ts1 = a01 * b0 - b1;\\n\\t\\t\\t\\t\\textDet = segExtent * det;\\n\\n\\t\\t\\t\\t\\tif ( s0 >= 0 ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( s1 >= - extDet ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( s1 <= extDet ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// region 0\\n\\t\\t\\t\\t\\t\\t\\t\\t// Minimum at interior points of ray and segment.\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar invDet = 1 / det;\\n\\t\\t\\t\\t\\t\\t\\t\\ts0 *= invDet;\\n\\t\\t\\t\\t\\t\\t\\t\\ts1 *= invDet;\\n\\t\\t\\t\\t\\t\\t\\t\\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// region 1\\n\\n\\t\\t\\t\\t\\t\\t\\t\\ts1 = segExtent;\\n\\t\\t\\t\\t\\t\\t\\t\\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\\n\\t\\t\\t\\t\\t\\t\\t\\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t// region 5\\n\\n\\t\\t\\t\\t\\t\\t\\ts1 = - segExtent;\\n\\t\\t\\t\\t\\t\\t\\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\\n\\t\\t\\t\\t\\t\\t\\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tif ( s1 <= - extDet ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// region 4\\n\\n\\t\\t\\t\\t\\t\\t\\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\\n\\t\\t\\t\\t\\t\\t\\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\\n\\t\\t\\t\\t\\t\\t\\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\\n\\n\\t\\t\\t\\t\\t\\t} else if ( s1 <= extDet ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// region 3\\n\\n\\t\\t\\t\\t\\t\\t\\ts0 = 0;\\n\\t\\t\\t\\t\\t\\t\\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\\n\\t\\t\\t\\t\\t\\t\\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t// region 2\\n\\n\\t\\t\\t\\t\\t\\t\\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\\n\\t\\t\\t\\t\\t\\t\\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\\n\\t\\t\\t\\t\\t\\t\\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// Ray and segment are parallel.\\n\\n\\t\\t\\t\\t\\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\\n\\t\\t\\t\\t\\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\\n\\t\\t\\t\\t\\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( optionalPointOnRay ) {\\n\\n\\t\\t\\t\\t\\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( optionalPointOnSegment ) {\\n\\n\\t\\t\\t\\t\\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn sqrDist;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tintersectSphere: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function intersectSphere( sphere, optionalTarget ) {\\n\\n\\t\\t\\t\\tv1.subVectors( sphere.center, this.origin );\\n\\t\\t\\t\\tvar tca = v1.dot( this.direction );\\n\\t\\t\\t\\tvar d2 = v1.dot( v1 ) - tca * tca;\\n\\t\\t\\t\\tvar radius2 = sphere.radius * sphere.radius;\\n\\n\\t\\t\\t\\tif ( d2 > radius2 ) return null;\\n\\n\\t\\t\\t\\tvar thc = Math.sqrt( radius2 - d2 );\\n\\n\\t\\t\\t\\t// t0 = first intersect point - entrance on front of sphere\\n\\t\\t\\t\\tvar t0 = tca - thc;\\n\\n\\t\\t\\t\\t// t1 = second intersect point - exit point on back of sphere\\n\\t\\t\\t\\tvar t1 = tca + thc;\\n\\n\\t\\t\\t\\t// test to see if both t0 and t1 are behind the ray - if so, return null\\n\\t\\t\\t\\tif ( t0 < 0 && t1 < 0 ) return null;\\n\\n\\t\\t\\t\\t// test to see if t0 is behind the ray:\\n\\t\\t\\t\\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\\n\\t\\t\\t\\t// in order to always return an intersect point that is in front of the ray.\\n\\t\\t\\t\\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\\n\\n\\t\\t\\t\\t// else t0 is in front of the ray, so return the first collision point scaled by t0\\n\\t\\t\\t\\treturn this.at( t0, optionalTarget );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tintersectsSphere: function ( sphere ) {\\n\\n\\t\\t\\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\\n\\n\\t\\t},\\n\\n\\t\\tdistanceToPlane: function ( plane ) {\\n\\n\\t\\t\\tvar denominator = plane.normal.dot( this.direction );\\n\\n\\t\\t\\tif ( denominator === 0 ) {\\n\\n\\t\\t\\t\\t// line is coplanar, return origin\\n\\t\\t\\t\\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\\n\\n\\t\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Null is preferable to undefined since undefined means.... it is undefined\\n\\n\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\\n\\n\\t\\t\\t// Return if the ray never intersects the plane\\n\\n\\t\\t\\treturn t >= 0 ? t : null;\\n\\n\\t\\t},\\n\\n\\t\\tintersectPlane: function ( plane, optionalTarget ) {\\n\\n\\t\\t\\tvar t = this.distanceToPlane( plane );\\n\\n\\t\\t\\tif ( t === null ) {\\n\\n\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this.at( t, optionalTarget );\\n\\n\\t\\t},\\n\\n\\t\\tintersectsPlane: function ( plane ) {\\n\\n\\t\\t\\t// check if the ray lies on the plane first\\n\\n\\t\\t\\tvar distToPoint = plane.distanceToPoint( this.origin );\\n\\n\\t\\t\\tif ( distToPoint === 0 ) {\\n\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar denominator = plane.normal.dot( this.direction );\\n\\n\\t\\t\\tif ( denominator * distToPoint < 0 ) {\\n\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// ray origin is behind the plane (and is pointing behind it)\\n\\n\\t\\t\\treturn false;\\n\\n\\t\\t},\\n\\n\\t\\tintersectBox: function ( box, optionalTarget ) {\\n\\n\\t\\t\\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\\n\\n\\t\\t\\tvar invdirx = 1 / this.direction.x,\\n\\t\\t\\t\\tinvdiry = 1 / this.direction.y,\\n\\t\\t\\t\\tinvdirz = 1 / this.direction.z;\\n\\n\\t\\t\\tvar origin = this.origin;\\n\\n\\t\\t\\tif ( invdirx >= 0 ) {\\n\\n\\t\\t\\t\\ttmin = ( box.min.x - origin.x ) * invdirx;\\n\\t\\t\\t\\ttmax = ( box.max.x - origin.x ) * invdirx;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\ttmin = ( box.max.x - origin.x ) * invdirx;\\n\\t\\t\\t\\ttmax = ( box.min.x - origin.x ) * invdirx;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( invdiry >= 0 ) {\\n\\n\\t\\t\\t\\ttymin = ( box.min.y - origin.y ) * invdiry;\\n\\t\\t\\t\\ttymax = ( box.max.y - origin.y ) * invdiry;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\ttymin = ( box.max.y - origin.y ) * invdiry;\\n\\t\\t\\t\\ttymax = ( box.min.y - origin.y ) * invdiry;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\\n\\n\\t\\t\\t// These lines also handle the case where tmin or tmax is NaN\\n\\t\\t\\t// (result of 0 * Infinity). x !== x returns true if x is NaN\\n\\n\\t\\t\\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\\n\\n\\t\\t\\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\\n\\n\\t\\t\\tif ( invdirz >= 0 ) {\\n\\n\\t\\t\\t\\ttzmin = ( box.min.z - origin.z ) * invdirz;\\n\\t\\t\\t\\ttzmax = ( box.max.z - origin.z ) * invdirz;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\ttzmin = ( box.max.z - origin.z ) * invdirz;\\n\\t\\t\\t\\ttzmax = ( box.min.z - origin.z ) * invdirz;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\\n\\n\\t\\t\\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\\n\\n\\t\\t\\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\\n\\n\\t\\t\\t//return point closest to the ray (positive side)\\n\\n\\t\\t\\tif ( tmax < 0 ) return null;\\n\\n\\t\\t\\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\\n\\n\\t\\t},\\n\\n\\t\\tintersectsBox: ( function () {\\n\\n\\t\\t\\tvar v = new Vector3();\\n\\n\\t\\t\\treturn function intersectsBox( box ) {\\n\\n\\t\\t\\t\\treturn this.intersectBox( box, v ) !== null;\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )(),\\n\\n\\t\\tintersectTriangle: function () {\\n\\n\\t\\t\\t// Compute the offset origin, edges, and normal.\\n\\t\\t\\tvar diff = new Vector3();\\n\\t\\t\\tvar edge1 = new Vector3();\\n\\t\\t\\tvar edge2 = new Vector3();\\n\\t\\t\\tvar normal = new Vector3();\\n\\n\\t\\t\\treturn function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {\\n\\n\\t\\t\\t\\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\\n\\n\\t\\t\\t\\tedge1.subVectors( b, a );\\n\\t\\t\\t\\tedge2.subVectors( c, a );\\n\\t\\t\\t\\tnormal.crossVectors( edge1, edge2 );\\n\\n\\t\\t\\t\\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\\n\\t\\t\\t\\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\\n\\t\\t\\t\\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\\n\\t\\t\\t\\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\\n\\t\\t\\t\\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\\n\\t\\t\\t\\tvar DdN = this.direction.dot( normal );\\n\\t\\t\\t\\tvar sign;\\n\\n\\t\\t\\t\\tif ( DdN > 0 ) {\\n\\n\\t\\t\\t\\t\\tif ( backfaceCulling ) return null;\\n\\t\\t\\t\\t\\tsign = 1;\\n\\n\\t\\t\\t\\t} else if ( DdN < 0 ) {\\n\\n\\t\\t\\t\\t\\tsign = - 1;\\n\\t\\t\\t\\t\\tDdN = - DdN;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdiff.subVectors( this.origin, a );\\n\\t\\t\\t\\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\\n\\n\\t\\t\\t\\t// b1 < 0, no intersection\\n\\t\\t\\t\\tif ( DdQxE2 < 0 ) {\\n\\n\\t\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\\n\\n\\t\\t\\t\\t// b2 < 0, no intersection\\n\\t\\t\\t\\tif ( DdE1xQ < 0 ) {\\n\\n\\t\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// b1+b2 > 1, no intersection\\n\\t\\t\\t\\tif ( DdQxE2 + DdE1xQ > DdN ) {\\n\\n\\t\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Line intersects triangle, check if ray does.\\n\\t\\t\\t\\tvar QdN = - sign * diff.dot( normal );\\n\\n\\t\\t\\t\\t// t < 0, no intersection\\n\\t\\t\\t\\tif ( QdN < 0 ) {\\n\\n\\t\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Ray intersects triangle.\\n\\t\\t\\t\\treturn this.at( QdN / DdN, optionalTarget );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tapplyMatrix4: function ( matrix4 ) {\\n\\n\\t\\t\\tthis.origin.applyMatrix4( matrix4 );\\n\\t\\t\\tthis.direction.transformDirection( matrix4 );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( ray ) {\\n\\n\\t\\t\\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author bhouston / http://clara.io\\n\\t */\\n\\n\\tfunction Line3( start, end ) {\\n\\n\\t\\tthis.start = ( start !== undefined ) ? start : new Vector3();\\n\\t\\tthis.end = ( end !== undefined ) ? end : new Vector3();\\n\\n\\t}\\n\\n\\tObject.assign( Line3.prototype, {\\n\\n\\t\\tset: function ( start, end ) {\\n\\n\\t\\t\\tthis.start.copy( start );\\n\\t\\t\\tthis.end.copy( end );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( line ) {\\n\\n\\t\\t\\tthis.start.copy( line.start );\\n\\t\\t\\tthis.end.copy( line.end );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetCenter: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\t\\t\\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\\n\\n\\t\\t},\\n\\n\\t\\tdelta: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\t\\t\\treturn result.subVectors( this.end, this.start );\\n\\n\\t\\t},\\n\\n\\t\\tdistanceSq: function () {\\n\\n\\t\\t\\treturn this.start.distanceToSquared( this.end );\\n\\n\\t\\t},\\n\\n\\t\\tdistance: function () {\\n\\n\\t\\t\\treturn this.start.distanceTo( this.end );\\n\\n\\t\\t},\\n\\n\\t\\tat: function ( t, optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\\n\\n\\t\\t},\\n\\n\\t\\tclosestPointToPointParameter: function () {\\n\\n\\t\\t\\tvar startP = new Vector3();\\n\\t\\t\\tvar startEnd = new Vector3();\\n\\n\\t\\t\\treturn function closestPointToPointParameter( point, clampToLine ) {\\n\\n\\t\\t\\t\\tstartP.subVectors( point, this.start );\\n\\t\\t\\t\\tstartEnd.subVectors( this.end, this.start );\\n\\n\\t\\t\\t\\tvar startEnd2 = startEnd.dot( startEnd );\\n\\t\\t\\t\\tvar startEnd_startP = startEnd.dot( startP );\\n\\n\\t\\t\\t\\tvar t = startEnd_startP / startEnd2;\\n\\n\\t\\t\\t\\tif ( clampToLine ) {\\n\\n\\t\\t\\t\\t\\tt = _Math.clamp( t, 0, 1 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn t;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\\n\\n\\t\\t\\tvar t = this.closestPointToPointParameter( point, clampToLine );\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\\n\\n\\t\\t},\\n\\n\\t\\tapplyMatrix4: function ( matrix ) {\\n\\n\\t\\t\\tthis.start.applyMatrix4( matrix );\\n\\t\\t\\tthis.end.applyMatrix4( matrix );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( line ) {\\n\\n\\t\\t\\treturn line.start.equals( this.start ) && line.end.equals( this.end );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author bhouston / http://clara.io\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction Triangle( a, b, c ) {\\n\\n\\t\\tthis.a = ( a !== undefined ) ? a : new Vector3();\\n\\t\\tthis.b = ( b !== undefined ) ? b : new Vector3();\\n\\t\\tthis.c = ( c !== undefined ) ? c : new Vector3();\\n\\n\\t}\\n\\n\\tObject.assign( Triangle, {\\n\\n\\t\\tnormal: function () {\\n\\n\\t\\t\\tvar v0 = new Vector3();\\n\\n\\t\\t\\treturn function normal( a, b, c, optionalTarget ) {\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\t\\tresult.subVectors( c, b );\\n\\t\\t\\t\\tv0.subVectors( a, b );\\n\\t\\t\\t\\tresult.cross( v0 );\\n\\n\\t\\t\\t\\tvar resultLengthSq = result.lengthSq();\\n\\t\\t\\t\\tif ( resultLengthSq > 0 ) {\\n\\n\\t\\t\\t\\t\\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn result.set( 0, 0, 0 );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\t// static/instance method to calculate barycentric coordinates\\n\\t\\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\\n\\t\\tbarycoordFromPoint: function () {\\n\\n\\t\\t\\tvar v0 = new Vector3();\\n\\t\\t\\tvar v1 = new Vector3();\\n\\t\\t\\tvar v2 = new Vector3();\\n\\n\\t\\t\\treturn function barycoordFromPoint( point, a, b, c, optionalTarget ) {\\n\\n\\t\\t\\t\\tv0.subVectors( c, a );\\n\\t\\t\\t\\tv1.subVectors( b, a );\\n\\t\\t\\t\\tv2.subVectors( point, a );\\n\\n\\t\\t\\t\\tvar dot00 = v0.dot( v0 );\\n\\t\\t\\t\\tvar dot01 = v0.dot( v1 );\\n\\t\\t\\t\\tvar dot02 = v0.dot( v2 );\\n\\t\\t\\t\\tvar dot11 = v1.dot( v1 );\\n\\t\\t\\t\\tvar dot12 = v1.dot( v2 );\\n\\n\\t\\t\\t\\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\t\\t// collinear or singular triangle\\n\\t\\t\\t\\tif ( denom === 0 ) {\\n\\n\\t\\t\\t\\t\\t// arbitrary location outside of triangle?\\n\\t\\t\\t\\t\\t// not sure if this is the best idea, maybe should be returning undefined\\n\\t\\t\\t\\t\\treturn result.set( - 2, - 1, - 1 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar invDenom = 1 / denom;\\n\\t\\t\\t\\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\\n\\t\\t\\t\\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\\n\\n\\t\\t\\t\\t// barycentric coordinates must always sum to 1\\n\\t\\t\\t\\treturn result.set( 1 - u - v, v, u );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tcontainsPoint: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function containsPoint( point, a, b, c ) {\\n\\n\\t\\t\\t\\tvar result = Triangle.barycoordFromPoint( point, a, b, c, v1 );\\n\\n\\t\\t\\t\\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}()\\n\\n\\t} );\\n\\n\\tObject.assign( Triangle.prototype, {\\n\\n\\t\\tset: function ( a, b, c ) {\\n\\n\\t\\t\\tthis.a.copy( a );\\n\\t\\t\\tthis.b.copy( b );\\n\\t\\t\\tthis.c.copy( c );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\\n\\n\\t\\t\\tthis.a.copy( points[ i0 ] );\\n\\t\\t\\tthis.b.copy( points[ i1 ] );\\n\\t\\t\\tthis.c.copy( points[ i2 ] );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( triangle ) {\\n\\n\\t\\t\\tthis.a.copy( triangle.a );\\n\\t\\t\\tthis.b.copy( triangle.b );\\n\\t\\t\\tthis.c.copy( triangle.c );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tarea: function () {\\n\\n\\t\\t\\tvar v0 = new Vector3();\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function area() {\\n\\n\\t\\t\\t\\tv0.subVectors( this.c, this.b );\\n\\t\\t\\t\\tv1.subVectors( this.a, this.b );\\n\\n\\t\\t\\t\\treturn v0.cross( v1 ).length() * 0.5;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tmidpoint: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\t\\t\\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\\n\\n\\t\\t},\\n\\n\\t\\tnormal: function ( optionalTarget ) {\\n\\n\\t\\t\\treturn Triangle.normal( this.a, this.b, this.c, optionalTarget );\\n\\n\\t\\t},\\n\\n\\t\\tplane: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Plane();\\n\\n\\t\\t\\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\\n\\n\\t\\t},\\n\\n\\t\\tbarycoordFromPoint: function ( point, optionalTarget ) {\\n\\n\\t\\t\\treturn Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\\n\\n\\t\\t},\\n\\n\\t\\tcontainsPoint: function ( point ) {\\n\\n\\t\\t\\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\\n\\n\\t\\t},\\n\\n\\t\\tclosestPointToPoint: function () {\\n\\n\\t\\t\\tvar plane = new Plane();\\n\\t\\t\\tvar edgeList = [ new Line3(), new Line3(), new Line3() ];\\n\\t\\t\\tvar projectedPoint = new Vector3();\\n\\t\\t\\tvar closestPoint = new Vector3();\\n\\n\\t\\t\\treturn function closestPointToPoint( point, optionalTarget ) {\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\t\\t\\t\\tvar minDistance = Infinity;\\n\\n\\t\\t\\t\\t// project the point onto the plane of the triangle\\n\\n\\t\\t\\t\\tplane.setFromCoplanarPoints( this.a, this.b, this.c );\\n\\t\\t\\t\\tplane.projectPoint( point, projectedPoint );\\n\\n\\t\\t\\t\\t// check if the projection lies within the triangle\\n\\n\\t\\t\\t\\tif ( this.containsPoint( projectedPoint ) === true ) {\\n\\n\\t\\t\\t\\t\\t// if so, this is the closest point\\n\\n\\t\\t\\t\\t\\tresult.copy( projectedPoint );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices\\n\\n\\t\\t\\t\\t\\tedgeList[ 0 ].set( this.a, this.b );\\n\\t\\t\\t\\t\\tedgeList[ 1 ].set( this.b, this.c );\\n\\t\\t\\t\\t\\tedgeList[ 2 ].set( this.c, this.a );\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < edgeList.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tedgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );\\n\\n\\t\\t\\t\\t\\t\\tvar distance = projectedPoint.distanceToSquared( closestPoint );\\n\\n\\t\\t\\t\\t\\t\\tif ( distance < minDistance ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tminDistance = distance;\\n\\n\\t\\t\\t\\t\\t\\t\\tresult.copy( closestPoint );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn result;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tequals: function ( triangle ) {\\n\\n\\t\\t\\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author jonobr1 / http://jonobr1.com/\\n\\t */\\n\\n\\tfunction Mesh( geometry, material ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Mesh';\\n\\n\\t\\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\\n\\t\\tthis.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );\\n\\n\\t\\tthis.drawMode = TrianglesDrawMode;\\n\\n\\t\\tthis.updateMorphTargets();\\n\\n\\t}\\n\\n\\tMesh.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Mesh,\\n\\n\\t\\tisMesh: true,\\n\\n\\t\\tsetDrawMode: function ( value ) {\\n\\n\\t\\t\\tthis.drawMode = value;\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tObject3D.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.drawMode = source.drawMode;\\n\\n\\t\\t\\tif ( source.morphTargetInfluences !== undefined ) {\\n\\n\\t\\t\\t\\tthis.morphTargetInfluences = source.morphTargetInfluences.slice();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( source.morphTargetDictionary !== undefined ) {\\n\\n\\t\\t\\t\\tthis.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tupdateMorphTargets: function () {\\n\\n\\t\\t\\tvar geometry = this.geometry;\\n\\t\\t\\tvar m, ml, name;\\n\\n\\t\\t\\tif ( geometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\tvar morphAttributes = geometry.morphAttributes;\\n\\t\\t\\t\\tvar keys = Object.keys( morphAttributes );\\n\\n\\t\\t\\t\\tif ( keys.length > 0 ) {\\n\\n\\t\\t\\t\\t\\tvar morphAttribute = morphAttributes[ keys[ 0 ] ];\\n\\n\\t\\t\\t\\t\\tif ( morphAttribute !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.morphTargetInfluences = [];\\n\\t\\t\\t\\t\\t\\tthis.morphTargetDictionary = {};\\n\\n\\t\\t\\t\\t\\t\\tfor ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tname = morphAttribute[ m ].name || String( m );\\n\\n\\t\\t\\t\\t\\t\\t\\tthis.morphTargetInfluences.push( 0 );\\n\\t\\t\\t\\t\\t\\t\\tthis.morphTargetDictionary[ name ] = m;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tvar morphTargets = geometry.morphTargets;\\n\\n\\t\\t\\t\\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\\n\\n\\t\\t\\t\\t\\tthis.morphTargetInfluences = [];\\n\\t\\t\\t\\t\\tthis.morphTargetDictionary = {};\\n\\n\\t\\t\\t\\t\\tfor ( m = 0, ml = morphTargets.length; m < ml; m ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tname = morphTargets[ m ].name || String( m );\\n\\n\\t\\t\\t\\t\\t\\tthis.morphTargetInfluences.push( 0 );\\n\\t\\t\\t\\t\\t\\tthis.morphTargetDictionary[ name ] = m;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\traycast: ( function () {\\n\\n\\t\\t\\tvar inverseMatrix = new Matrix4();\\n\\t\\t\\tvar ray = new Ray();\\n\\t\\t\\tvar sphere = new Sphere();\\n\\n\\t\\t\\tvar vA = new Vector3();\\n\\t\\t\\tvar vB = new Vector3();\\n\\t\\t\\tvar vC = new Vector3();\\n\\n\\t\\t\\tvar tempA = new Vector3();\\n\\t\\t\\tvar tempB = new Vector3();\\n\\t\\t\\tvar tempC = new Vector3();\\n\\n\\t\\t\\tvar uvA = new Vector2();\\n\\t\\t\\tvar uvB = new Vector2();\\n\\t\\t\\tvar uvC = new Vector2();\\n\\n\\t\\t\\tvar barycoord = new Vector3();\\n\\n\\t\\t\\tvar intersectionPoint = new Vector3();\\n\\t\\t\\tvar intersectionPointWorld = new Vector3();\\n\\n\\t\\t\\tfunction uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\\n\\n\\t\\t\\t\\tTriangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\\n\\n\\t\\t\\t\\tuv1.multiplyScalar( barycoord.x );\\n\\t\\t\\t\\tuv2.multiplyScalar( barycoord.y );\\n\\t\\t\\t\\tuv3.multiplyScalar( barycoord.z );\\n\\n\\t\\t\\t\\tuv1.add( uv2 ).add( uv3 );\\n\\n\\t\\t\\t\\treturn uv1.clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {\\n\\n\\t\\t\\t\\tvar intersect;\\n\\n\\t\\t\\t\\tif ( material.side === BackSide ) {\\n\\n\\t\\t\\t\\t\\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( intersect === null ) return null;\\n\\n\\t\\t\\t\\tintersectionPointWorld.copy( point );\\n\\t\\t\\t\\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\\n\\n\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\\n\\n\\t\\t\\t\\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\\n\\n\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\tdistance: distance,\\n\\t\\t\\t\\t\\tpoint: intersectionPointWorld.clone(),\\n\\t\\t\\t\\t\\tobject: object\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction checkBufferGeometryIntersection( object, raycaster, ray, position, uv, a, b, c ) {\\n\\n\\t\\t\\t\\tvA.fromBufferAttribute( position, a );\\n\\t\\t\\t\\tvB.fromBufferAttribute( position, b );\\n\\t\\t\\t\\tvC.fromBufferAttribute( position, c );\\n\\n\\t\\t\\t\\tvar intersection = checkIntersection( object, object.material, raycaster, ray, vA, vB, vC, intersectionPoint );\\n\\n\\t\\t\\t\\tif ( intersection ) {\\n\\n\\t\\t\\t\\t\\tif ( uv ) {\\n\\n\\t\\t\\t\\t\\t\\tuvA.fromBufferAttribute( uv, a );\\n\\t\\t\\t\\t\\t\\tuvB.fromBufferAttribute( uv, b );\\n\\t\\t\\t\\t\\t\\tuvC.fromBufferAttribute( uv, c );\\n\\n\\t\\t\\t\\t\\t\\tintersection.uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tintersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );\\n\\t\\t\\t\\t\\tintersection.faceIndex = a;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn intersection;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn function raycast( raycaster, intersects ) {\\n\\n\\t\\t\\t\\tvar geometry = this.geometry;\\n\\t\\t\\t\\tvar material = this.material;\\n\\t\\t\\t\\tvar matrixWorld = this.matrixWorld;\\n\\n\\t\\t\\t\\tif ( material === undefined ) return;\\n\\n\\t\\t\\t\\t// Checking boundingSphere distance to ray\\n\\n\\t\\t\\t\\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\\n\\n\\t\\t\\t\\tsphere.copy( geometry.boundingSphere );\\n\\t\\t\\t\\tsphere.applyMatrix4( matrixWorld );\\n\\n\\t\\t\\t\\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\\n\\n\\t\\t\\t\\t//\\n\\n\\t\\t\\t\\tinverseMatrix.getInverse( matrixWorld );\\n\\t\\t\\t\\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\\n\\n\\t\\t\\t\\t// Check boundingBox before continuing\\n\\n\\t\\t\\t\\tif ( geometry.boundingBox !== null ) {\\n\\n\\t\\t\\t\\t\\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar intersection;\\n\\n\\t\\t\\t\\tif ( geometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\t\\tvar a, b, c;\\n\\t\\t\\t\\t\\tvar index = geometry.index;\\n\\t\\t\\t\\t\\tvar position = geometry.attributes.position;\\n\\t\\t\\t\\t\\tvar uv = geometry.attributes.uv;\\n\\t\\t\\t\\t\\tvar i, l;\\n\\n\\t\\t\\t\\t\\tif ( index !== null ) {\\n\\n\\t\\t\\t\\t\\t\\t// indexed buffer geometry\\n\\n\\t\\t\\t\\t\\t\\tfor ( i = 0, l = index.count; i < l; i += 3 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\ta = index.getX( i );\\n\\t\\t\\t\\t\\t\\t\\tb = index.getX( i + 1 );\\n\\t\\t\\t\\t\\t\\t\\tc = index.getX( i + 2 );\\n\\n\\t\\t\\t\\t\\t\\t\\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( intersection ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\\n\\t\\t\\t\\t\\t\\t\\t\\tintersects.push( intersection );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else if ( position !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t// non-indexed buffer geometry\\n\\n\\t\\t\\t\\t\\t\\tfor ( i = 0, l = position.count; i < l; i += 3 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\ta = i;\\n\\t\\t\\t\\t\\t\\t\\tb = i + 1;\\n\\t\\t\\t\\t\\t\\t\\tc = i + 2;\\n\\n\\t\\t\\t\\t\\t\\t\\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( intersection ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tintersection.index = a; // triangle number in positions buffer semantics\\n\\t\\t\\t\\t\\t\\t\\t\\tintersects.push( intersection );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( geometry.isGeometry ) {\\n\\n\\t\\t\\t\\t\\tvar fvA, fvB, fvC;\\n\\t\\t\\t\\t\\tvar isMultiMaterial = Array.isArray( material );\\n\\n\\t\\t\\t\\t\\tvar vertices = geometry.vertices;\\n\\t\\t\\t\\t\\tvar faces = geometry.faces;\\n\\t\\t\\t\\t\\tvar uvs;\\n\\n\\t\\t\\t\\t\\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\\n\\t\\t\\t\\t\\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\\n\\n\\t\\t\\t\\t\\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar face = faces[ f ];\\n\\t\\t\\t\\t\\t\\tvar faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;\\n\\n\\t\\t\\t\\t\\t\\tif ( faceMaterial === undefined ) continue;\\n\\n\\t\\t\\t\\t\\t\\tfvA = vertices[ face.a ];\\n\\t\\t\\t\\t\\t\\tfvB = vertices[ face.b ];\\n\\t\\t\\t\\t\\t\\tfvC = vertices[ face.c ];\\n\\n\\t\\t\\t\\t\\t\\tif ( faceMaterial.morphTargets === true ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar morphTargets = geometry.morphTargets;\\n\\t\\t\\t\\t\\t\\t\\tvar morphInfluences = this.morphTargetInfluences;\\n\\n\\t\\t\\t\\t\\t\\t\\tvA.set( 0, 0, 0 );\\n\\t\\t\\t\\t\\t\\t\\tvB.set( 0, 0, 0 );\\n\\t\\t\\t\\t\\t\\t\\tvC.set( 0, 0, 0 );\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar influence = morphInfluences[ t ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( influence === 0 ) continue;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar targets = morphTargets[ t ].vertices;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\\n\\t\\t\\t\\t\\t\\t\\t\\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\\n\\t\\t\\t\\t\\t\\t\\t\\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tvA.add( fvA );\\n\\t\\t\\t\\t\\t\\t\\tvB.add( fvB );\\n\\t\\t\\t\\t\\t\\t\\tvC.add( fvC );\\n\\n\\t\\t\\t\\t\\t\\t\\tfvA = vA;\\n\\t\\t\\t\\t\\t\\t\\tfvB = vB;\\n\\t\\t\\t\\t\\t\\t\\tfvC = vC;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tintersection = checkIntersection( this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\\n\\n\\t\\t\\t\\t\\t\\tif ( intersection ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( uvs && uvs[ f ] ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar uvs_f = uvs[ f ];\\n\\t\\t\\t\\t\\t\\t\\t\\tuvA.copy( uvs_f[ 0 ] );\\n\\t\\t\\t\\t\\t\\t\\t\\tuvB.copy( uvs_f[ 1 ] );\\n\\t\\t\\t\\t\\t\\t\\t\\tuvC.copy( uvs_f[ 2 ] );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tintersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tintersection.face = face;\\n\\t\\t\\t\\t\\t\\t\\tintersection.faceIndex = f;\\n\\t\\t\\t\\t\\t\\t\\tintersects.push( intersection );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}() ),\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.geometry, this.material ).copy( this );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLBackground( renderer, state, geometries, premultipliedAlpha ) {\\n\\n\\t\\tvar clearColor = new Color( 0x000000 );\\n\\t\\tvar clearAlpha = 0;\\n\\n\\t\\tvar planeCamera, planeMesh;\\n\\t\\tvar boxMesh;\\n\\n\\t\\tfunction render( renderList, scene, camera, forceClear ) {\\n\\n\\t\\t\\tvar background = scene.background;\\n\\n\\t\\t\\tif ( background === null ) {\\n\\n\\t\\t\\t\\tsetClear( clearColor, clearAlpha );\\n\\n\\t\\t\\t} else if ( background && background.isColor ) {\\n\\n\\t\\t\\t\\tsetClear( background, 1 );\\n\\t\\t\\t\\tforceClear = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( renderer.autoClear || forceClear ) {\\n\\n\\t\\t\\t\\trenderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( background && background.isCubeTexture ) {\\n\\n\\t\\t\\t\\tif ( boxMesh === undefined ) {\\n\\n\\t\\t\\t\\t\\tboxMesh = new Mesh(\\n\\t\\t\\t\\t\\t\\tnew BoxBufferGeometry( 1, 1, 1 ),\\n\\t\\t\\t\\t\\t\\tnew ShaderMaterial( {\\n\\t\\t\\t\\t\\t\\t\\tuniforms: ShaderLib.cube.uniforms,\\n\\t\\t\\t\\t\\t\\t\\tvertexShader: ShaderLib.cube.vertexShader,\\n\\t\\t\\t\\t\\t\\t\\tfragmentShader: ShaderLib.cube.fragmentShader,\\n\\t\\t\\t\\t\\t\\t\\tside: BackSide,\\n\\t\\t\\t\\t\\t\\t\\tdepthTest: true,\\n\\t\\t\\t\\t\\t\\t\\tdepthWrite: false,\\n\\t\\t\\t\\t\\t\\t\\tfog: false\\n\\t\\t\\t\\t\\t\\t} )\\n\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\tboxMesh.geometry.removeAttribute( 'normal' );\\n\\t\\t\\t\\t\\tboxMesh.geometry.removeAttribute( 'uv' );\\n\\n\\t\\t\\t\\t\\tboxMesh.onBeforeRender = function ( renderer, scene, camera ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.matrixWorld.copyPosition( camera.matrixWorld );\\n\\n\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\tgeometries.update( boxMesh.geometry );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tboxMesh.material.uniforms.tCube.value = background;\\n\\n\\t\\t\\t\\trenderList.push( boxMesh, boxMesh.geometry, boxMesh.material, 0, null );\\n\\n\\t\\t\\t} else if ( background && background.isTexture ) {\\n\\n\\t\\t\\t\\tif ( planeCamera === undefined ) {\\n\\n\\t\\t\\t\\t\\tplaneCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\\n\\n\\t\\t\\t\\t\\tplaneMesh = new Mesh(\\n\\t\\t\\t\\t\\t\\tnew PlaneBufferGeometry( 2, 2 ),\\n\\t\\t\\t\\t\\t\\tnew MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )\\n\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\tgeometries.update( planeMesh.geometry );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tplaneMesh.material.map = background;\\n\\n\\t\\t\\t\\t// TODO Push this to renderList\\n\\n\\t\\t\\t\\trenderer.renderBufferDirect( planeCamera, null, planeMesh.geometry, planeMesh.material, planeMesh, null );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction setClear( color, alpha ) {\\n\\n\\t\\t\\tstate.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tgetClearColor: function () {\\n\\n\\t\\t\\t\\treturn clearColor;\\n\\n\\t\\t\\t},\\n\\t\\t\\tsetClearColor: function ( color, alpha ) {\\n\\n\\t\\t\\t\\tclearColor.set( color );\\n\\t\\t\\t\\tclearAlpha = alpha !== undefined ? alpha : 1;\\n\\t\\t\\t\\tsetClear( clearColor, clearAlpha );\\n\\n\\t\\t\\t},\\n\\t\\t\\tgetClearAlpha: function () {\\n\\n\\t\\t\\t\\treturn clearAlpha;\\n\\n\\t\\t\\t},\\n\\t\\t\\tsetClearAlpha: function ( alpha ) {\\n\\n\\t\\t\\t\\tclearAlpha = alpha;\\n\\t\\t\\t\\tsetClear( clearColor, clearAlpha );\\n\\n\\t\\t\\t},\\n\\t\\t\\trender: render\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction painterSortStable( a, b ) {\\n\\n\\t\\tif ( a.renderOrder !== b.renderOrder ) {\\n\\n\\t\\t\\treturn a.renderOrder - b.renderOrder;\\n\\n\\t\\t} else if ( a.program && b.program && a.program !== b.program ) {\\n\\n\\t\\t\\treturn a.program.id - b.program.id;\\n\\n\\t\\t} else if ( a.material.id !== b.material.id ) {\\n\\n\\t\\t\\treturn a.material.id - b.material.id;\\n\\n\\t\\t} else if ( a.z !== b.z ) {\\n\\n\\t\\t\\treturn a.z - b.z;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\treturn a.id - b.id;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction reversePainterSortStable( a, b ) {\\n\\n\\t\\tif ( a.renderOrder !== b.renderOrder ) {\\n\\n\\t\\t\\treturn a.renderOrder - b.renderOrder;\\n\\n\\t\\t} if ( a.z !== b.z ) {\\n\\n\\t\\t\\treturn b.z - a.z;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\treturn a.id - b.id;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction WebGLRenderList() {\\n\\n\\t\\tvar renderItems = [];\\n\\t\\tvar renderItemsIndex = 0;\\n\\n\\t\\tvar opaque = [];\\n\\t\\tvar transparent = [];\\n\\n\\t\\tfunction init() {\\n\\n\\t\\t\\trenderItemsIndex = 0;\\n\\n\\t\\t\\topaque.length = 0;\\n\\t\\t\\ttransparent.length = 0;\\n\\n\\t\\t}\\n\\n\\t\\tfunction push( object, geometry, material, z, group ) {\\n\\n\\t\\t\\tvar renderItem = renderItems[ renderItemsIndex ];\\n\\n\\t\\t\\tif ( renderItem === undefined ) {\\n\\n\\t\\t\\t\\trenderItem = {\\n\\t\\t\\t\\t\\tid: object.id,\\n\\t\\t\\t\\t\\tobject: object,\\n\\t\\t\\t\\t\\tgeometry: geometry,\\n\\t\\t\\t\\t\\tmaterial: material,\\n\\t\\t\\t\\t\\tprogram: material.program,\\n\\t\\t\\t\\t\\trenderOrder: object.renderOrder,\\n\\t\\t\\t\\t\\tz: z,\\n\\t\\t\\t\\t\\tgroup: group\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\trenderItems[ renderItemsIndex ] = renderItem;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\trenderItem.id = object.id;\\n\\t\\t\\t\\trenderItem.object = object;\\n\\t\\t\\t\\trenderItem.geometry = geometry;\\n\\t\\t\\t\\trenderItem.material = material;\\n\\t\\t\\t\\trenderItem.program = material.program;\\n\\t\\t\\t\\trenderItem.renderOrder = object.renderOrder;\\n\\t\\t\\t\\trenderItem.z = z;\\n\\t\\t\\t\\trenderItem.group = group;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t( material.transparent === true ? transparent : opaque ).push( renderItem );\\n\\n\\t\\t\\trenderItemsIndex ++;\\n\\n\\t\\t}\\n\\n\\t\\tfunction sort() {\\n\\n\\t\\t\\tif ( opaque.length > 1 ) opaque.sort( painterSortStable );\\n\\t\\t\\tif ( transparent.length > 1 ) transparent.sort( reversePainterSortStable );\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\topaque: opaque,\\n\\t\\t\\ttransparent: transparent,\\n\\n\\t\\t\\tinit: init,\\n\\t\\t\\tpush: push,\\n\\n\\t\\t\\tsort: sort\\n\\t\\t};\\n\\n\\t}\\n\\n\\tfunction WebGLRenderLists() {\\n\\n\\t\\tvar lists = {};\\n\\n\\t\\tfunction get( scene, camera ) {\\n\\n\\t\\t\\tvar hash = scene.id + ',' + camera.id;\\n\\t\\t\\tvar list = lists[ hash ];\\n\\n\\t\\t\\tif ( list === undefined ) {\\n\\n\\t\\t\\t\\t// console.log( 'THREE.WebGLRenderLists:', hash );\\n\\n\\t\\t\\t\\tlist = new WebGLRenderList();\\n\\t\\t\\t\\tlists[ hash ] = list;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn list;\\n\\n\\t\\t}\\n\\n\\t\\tfunction dispose() {\\n\\n\\t\\t\\tlists = {};\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\tget: get,\\n\\t\\t\\tdispose: dispose\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction absNumericalSort( a, b ) {\\n\\n\\t\\treturn Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );\\n\\n\\t}\\n\\n\\tfunction WebGLMorphtargets( gl ) {\\n\\n\\t\\tvar influencesList = {};\\n\\t\\tvar morphInfluences = new Float32Array( 8 );\\n\\n\\t\\tfunction update( object, geometry, material, program ) {\\n\\n\\t\\t\\tvar objectInfluences = object.morphTargetInfluences;\\n\\n\\t\\t\\tvar length = objectInfluences.length;\\n\\n\\t\\t\\tvar influences = influencesList[ geometry.id ];\\n\\n\\t\\t\\tif ( influences === undefined ) {\\n\\n\\t\\t\\t\\t// initialise list\\n\\n\\t\\t\\t\\tinfluences = [];\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tinfluences[ i ] = [ i, 0 ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tinfluencesList[ geometry.id ] = influences;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar morphTargets = material.morphTargets && geometry.morphAttributes.position;\\n\\t\\t\\tvar morphNormals = material.morphNormals && geometry.morphAttributes.normal;\\n\\n\\t\\t\\t// Remove current morphAttributes\\n\\n\\t\\t\\tfor ( var i = 0; i < length; i ++ ) {\\n\\n\\t\\t\\t\\tvar influence = influences[ i ];\\n\\n\\t\\t\\t\\tif ( influence[ 1 ] !== 0 ) {\\n\\n\\t\\t\\t\\t\\tif ( morphTargets ) geometry.removeAttribute( 'morphTarget' + i );\\n\\t\\t\\t\\t\\tif ( morphNormals ) geometry.removeAttribute( 'morphNormal' + i );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Collect influences\\n\\n\\t\\t\\tfor ( var i = 0; i < length; i ++ ) {\\n\\n\\t\\t\\t\\tvar influence = influences[ i ];\\n\\n\\t\\t\\t\\tinfluence[ 0 ] = i;\\n\\t\\t\\t\\tinfluence[ 1 ] = objectInfluences[ i ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tinfluences.sort( absNumericalSort );\\n\\n\\t\\t\\t// Add morphAttributes\\n\\n\\t\\t\\tfor ( var i = 0; i < 8; i ++ ) {\\n\\n\\t\\t\\t\\tvar influence = influences[ i ];\\n\\n\\t\\t\\t\\tif ( influence ) {\\n\\n\\t\\t\\t\\t\\tvar index = influence[ 0 ];\\n\\t\\t\\t\\t\\tvar value = influence[ 1 ];\\n\\n\\t\\t\\t\\t\\tif ( value ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( morphTargets ) geometry.addAttribute( 'morphTarget' + i, morphTargets[ index ] );\\n\\t\\t\\t\\t\\t\\tif ( morphNormals ) geometry.addAttribute( 'morphNormal' + i, morphNormals[ index ] );\\n\\n\\t\\t\\t\\t\\t\\tmorphInfluences[ i ] = value;\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tmorphInfluences[ i ] = 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tprogram.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tupdate: update\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {\\n\\n\\t\\tvar mode;\\n\\n\\t\\tfunction setMode( value ) {\\n\\n\\t\\t\\tmode = value;\\n\\n\\t\\t}\\n\\n\\t\\tvar type, bytesPerElement;\\n\\n\\t\\tfunction setIndex( value ) {\\n\\n\\t\\t\\ttype = value.type;\\n\\t\\t\\tbytesPerElement = value.bytesPerElement;\\n\\n\\t\\t}\\n\\n\\t\\tfunction render( start, count ) {\\n\\n\\t\\t\\tgl.drawElements( mode, count, type, start * bytesPerElement );\\n\\n\\t\\t\\tinfoRender.calls ++;\\n\\t\\t\\tinfoRender.vertices += count;\\n\\n\\t\\t\\tif ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\\n\\t\\t\\telse if ( mode === gl.POINTS ) infoRender.points += count;\\n\\n\\t\\t}\\n\\n\\t\\tfunction renderInstances( geometry, start, count ) {\\n\\n\\t\\t\\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\\n\\n\\t\\t\\tif ( extension === null ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\textension.drawElementsInstancedANGLE( mode, count, type, start * bytesPerElement, geometry.maxInstancedCount );\\n\\n\\t\\t\\tinfoRender.calls ++;\\n\\t\\t\\tinfoRender.vertices += count * geometry.maxInstancedCount;\\n\\n\\t\\t\\tif ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\\n\\t\\t\\telse if ( mode === gl.POINTS ) infoRender.points += geometry.maxInstancedCount * count;\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tthis.setMode = setMode;\\n\\t\\tthis.setIndex = setIndex;\\n\\t\\tthis.render = render;\\n\\t\\tthis.renderInstances = renderInstances;\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLBufferRenderer( gl, extensions, infoRender ) {\\n\\n\\t\\tvar mode;\\n\\n\\t\\tfunction setMode( value ) {\\n\\n\\t\\t\\tmode = value;\\n\\n\\t\\t}\\n\\n\\t\\tfunction render( start, count ) {\\n\\n\\t\\t\\tgl.drawArrays( mode, start, count );\\n\\n\\t\\t\\tinfoRender.calls ++;\\n\\t\\t\\tinfoRender.vertices += count;\\n\\n\\t\\t\\tif ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\\n\\t\\t\\telse if ( mode === gl.POINTS ) infoRender.points += count;\\n\\n\\t\\t}\\n\\n\\t\\tfunction renderInstances( geometry, start, count ) {\\n\\n\\t\\t\\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\\n\\n\\t\\t\\tif ( extension === null ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar position = geometry.attributes.position;\\n\\n\\t\\t\\tif ( position.isInterleavedBufferAttribute ) {\\n\\n\\t\\t\\t\\tcount = position.data.count;\\n\\n\\t\\t\\t\\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\textension.drawArraysInstancedANGLE( mode, start, count, geometry.maxInstancedCount );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tinfoRender.calls ++;\\n\\t\\t\\tinfoRender.vertices += count * geometry.maxInstancedCount;\\n\\n\\t\\t\\tif ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\\n\\t\\t\\telse if ( mode === gl.POINTS ) infoRender.points += geometry.maxInstancedCount * count;\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tthis.setMode = setMode;\\n\\t\\tthis.render = render;\\n\\t\\tthis.renderInstances = renderInstances;\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLGeometries( gl, attributes, infoMemory ) {\\n\\n\\t\\tvar geometries = {};\\n\\t\\tvar wireframeAttributes = {};\\n\\n\\t\\tfunction onGeometryDispose( event ) {\\n\\n\\t\\t\\tvar geometry = event.target;\\n\\t\\t\\tvar buffergeometry = geometries[ geometry.id ];\\n\\n\\t\\t\\tif ( buffergeometry.index !== null ) {\\n\\n\\t\\t\\t\\tattributes.remove( buffergeometry.index );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var name in buffergeometry.attributes ) {\\n\\n\\t\\t\\t\\tattributes.remove( buffergeometry.attributes[ name ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\\n\\n\\t\\t\\tdelete geometries[ geometry.id ];\\n\\n\\t\\t\\t// TODO Remove duplicate code\\n\\n\\t\\t\\tvar attribute = wireframeAttributes[ geometry.id ];\\n\\n\\t\\t\\tif ( attribute ) {\\n\\n\\t\\t\\t\\tattributes.remove( attribute );\\n\\t\\t\\t\\tdelete wireframeAttributes[ geometry.id ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tattribute = wireframeAttributes[ buffergeometry.id ];\\n\\n\\t\\t\\tif ( attribute ) {\\n\\n\\t\\t\\t\\tattributes.remove( attribute );\\n\\t\\t\\t\\tdelete wireframeAttributes[ buffergeometry.id ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tinfoMemory.geometries --;\\n\\n\\t\\t}\\n\\n\\t\\tfunction get( object, geometry ) {\\n\\n\\t\\t\\tvar buffergeometry = geometries[ geometry.id ];\\n\\n\\t\\t\\tif ( buffergeometry ) return buffergeometry;\\n\\n\\t\\t\\tgeometry.addEventListener( 'dispose', onGeometryDispose );\\n\\n\\t\\t\\tif ( geometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\tbuffergeometry = geometry;\\n\\n\\t\\t\\t} else if ( geometry.isGeometry ) {\\n\\n\\t\\t\\t\\tif ( geometry._bufferGeometry === undefined ) {\\n\\n\\t\\t\\t\\t\\tgeometry._bufferGeometry = new BufferGeometry().setFromObject( object );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbuffergeometry = geometry._bufferGeometry;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tgeometries[ geometry.id ] = buffergeometry;\\n\\n\\t\\t\\tinfoMemory.geometries ++;\\n\\n\\t\\t\\treturn buffergeometry;\\n\\n\\t\\t}\\n\\n\\t\\tfunction update( geometry ) {\\n\\n\\t\\t\\tvar index = geometry.index;\\n\\t\\t\\tvar geometryAttributes = geometry.attributes;\\n\\n\\t\\t\\tif ( index !== null ) {\\n\\n\\t\\t\\t\\tattributes.update( index, gl.ELEMENT_ARRAY_BUFFER );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var name in geometryAttributes ) {\\n\\n\\t\\t\\t\\tattributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// morph targets\\n\\n\\t\\t\\tvar morphAttributes = geometry.morphAttributes;\\n\\n\\t\\t\\tfor ( var name in morphAttributes ) {\\n\\n\\t\\t\\t\\tvar array = morphAttributes[ name ];\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tattributes.update( array[ i ], gl.ARRAY_BUFFER );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction getWireframeAttribute( geometry ) {\\n\\n\\t\\t\\tvar attribute = wireframeAttributes[ geometry.id ];\\n\\n\\t\\t\\tif ( attribute ) return attribute;\\n\\n\\t\\t\\tvar indices = [];\\n\\n\\t\\t\\tvar geometryIndex = geometry.index;\\n\\t\\t\\tvar geometryAttributes = geometry.attributes;\\n\\n\\t\\t\\t// console.time( 'wireframe' );\\n\\n\\t\\t\\tif ( geometryIndex !== null ) {\\n\\n\\t\\t\\t\\tvar array = geometryIndex.array;\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\\n\\n\\t\\t\\t\\t\\tvar a = array[ i + 0 ];\\n\\t\\t\\t\\t\\tvar b = array[ i + 1 ];\\n\\t\\t\\t\\t\\tvar c = array[ i + 2 ];\\n\\n\\t\\t\\t\\t\\tindices.push( a, b, b, c, c, a );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tvar array = geometryAttributes.position.array;\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\\n\\n\\t\\t\\t\\t\\tvar a = i + 0;\\n\\t\\t\\t\\t\\tvar b = i + 1;\\n\\t\\t\\t\\t\\tvar c = i + 2;\\n\\n\\t\\t\\t\\t\\tindices.push( a, b, b, c, c, a );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// console.timeEnd( 'wireframe' );\\n\\n\\t\\t\\tattribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );\\n\\n\\t\\t\\tattributes.update( attribute, gl.ELEMENT_ARRAY_BUFFER );\\n\\n\\t\\t\\twireframeAttributes[ geometry.id ] = attribute;\\n\\n\\t\\t\\treturn attribute;\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tget: get,\\n\\t\\t\\tupdate: update,\\n\\n\\t\\t\\tgetWireframeAttribute: getWireframeAttribute\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction UniformsCache() {\\n\\n\\t\\tvar lights = {};\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tget: function ( light ) {\\n\\n\\t\\t\\t\\tif ( lights[ light.id ] !== undefined ) {\\n\\n\\t\\t\\t\\t\\treturn lights[ light.id ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar uniforms;\\n\\n\\t\\t\\t\\tswitch ( light.type ) {\\n\\n\\t\\t\\t\\t\\tcase 'DirectionalLight':\\n\\t\\t\\t\\t\\t\\tuniforms = {\\n\\t\\t\\t\\t\\t\\t\\tdirection: new Vector3(),\\n\\t\\t\\t\\t\\t\\t\\tcolor: new Color(),\\n\\n\\t\\t\\t\\t\\t\\t\\tshadow: false,\\n\\t\\t\\t\\t\\t\\t\\tshadowBias: 0,\\n\\t\\t\\t\\t\\t\\t\\tshadowRadius: 1,\\n\\t\\t\\t\\t\\t\\t\\tshadowMapSize: new Vector2()\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'SpotLight':\\n\\t\\t\\t\\t\\t\\tuniforms = {\\n\\t\\t\\t\\t\\t\\t\\tposition: new Vector3(),\\n\\t\\t\\t\\t\\t\\t\\tdirection: new Vector3(),\\n\\t\\t\\t\\t\\t\\t\\tcolor: new Color(),\\n\\t\\t\\t\\t\\t\\t\\tdistance: 0,\\n\\t\\t\\t\\t\\t\\t\\tconeCos: 0,\\n\\t\\t\\t\\t\\t\\t\\tpenumbraCos: 0,\\n\\t\\t\\t\\t\\t\\t\\tdecay: 0,\\n\\n\\t\\t\\t\\t\\t\\t\\tshadow: false,\\n\\t\\t\\t\\t\\t\\t\\tshadowBias: 0,\\n\\t\\t\\t\\t\\t\\t\\tshadowRadius: 1,\\n\\t\\t\\t\\t\\t\\t\\tshadowMapSize: new Vector2()\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'PointLight':\\n\\t\\t\\t\\t\\t\\tuniforms = {\\n\\t\\t\\t\\t\\t\\t\\tposition: new Vector3(),\\n\\t\\t\\t\\t\\t\\t\\tcolor: new Color(),\\n\\t\\t\\t\\t\\t\\t\\tdistance: 0,\\n\\t\\t\\t\\t\\t\\t\\tdecay: 0,\\n\\n\\t\\t\\t\\t\\t\\t\\tshadow: false,\\n\\t\\t\\t\\t\\t\\t\\tshadowBias: 0,\\n\\t\\t\\t\\t\\t\\t\\tshadowRadius: 1,\\n\\t\\t\\t\\t\\t\\t\\tshadowMapSize: new Vector2(),\\n\\t\\t\\t\\t\\t\\t\\tshadowCameraNear: 1,\\n\\t\\t\\t\\t\\t\\t\\tshadowCameraFar: 1000\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'HemisphereLight':\\n\\t\\t\\t\\t\\t\\tuniforms = {\\n\\t\\t\\t\\t\\t\\t\\tdirection: new Vector3(),\\n\\t\\t\\t\\t\\t\\t\\tskyColor: new Color(),\\n\\t\\t\\t\\t\\t\\t\\tgroundColor: new Color()\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'RectAreaLight':\\n\\t\\t\\t\\t\\t\\tuniforms = {\\n\\t\\t\\t\\t\\t\\t\\tcolor: new Color(),\\n\\t\\t\\t\\t\\t\\t\\tposition: new Vector3(),\\n\\t\\t\\t\\t\\t\\t\\thalfWidth: new Vector3(),\\n\\t\\t\\t\\t\\t\\t\\thalfHeight: new Vector3()\\n\\t\\t\\t\\t\\t\\t\\t// TODO (abelnation): set RectAreaLight shadow uniforms\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tlights[ light.id ] = uniforms;\\n\\n\\t\\t\\t\\treturn uniforms;\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\tfunction WebGLLights() {\\n\\n\\t\\tvar cache = new UniformsCache();\\n\\n\\t\\tvar state = {\\n\\n\\t\\t\\thash: '',\\n\\n\\t\\t\\tambient: [ 0, 0, 0 ],\\n\\t\\t\\tdirectional: [],\\n\\t\\t\\tdirectionalShadowMap: [],\\n\\t\\t\\tdirectionalShadowMatrix: [],\\n\\t\\t\\tspot: [],\\n\\t\\t\\tspotShadowMap: [],\\n\\t\\t\\tspotShadowMatrix: [],\\n\\t\\t\\trectArea: [],\\n\\t\\t\\tpoint: [],\\n\\t\\t\\tpointShadowMap: [],\\n\\t\\t\\tpointShadowMatrix: [],\\n\\t\\t\\themi: []\\n\\n\\t\\t};\\n\\n\\t\\tvar vector3 = new Vector3();\\n\\t\\tvar matrix4 = new Matrix4();\\n\\t\\tvar matrix42 = new Matrix4();\\n\\n\\t\\tfunction setup( lights, shadows, camera ) {\\n\\n\\t\\t\\tvar r = 0, g = 0, b = 0;\\n\\n\\t\\t\\tvar directionalLength = 0;\\n\\t\\t\\tvar pointLength = 0;\\n\\t\\t\\tvar spotLength = 0;\\n\\t\\t\\tvar rectAreaLength = 0;\\n\\t\\t\\tvar hemiLength = 0;\\n\\n\\t\\t\\tvar viewMatrix = camera.matrixWorldInverse;\\n\\n\\t\\t\\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar light = lights[ i ];\\n\\n\\t\\t\\t\\tvar color = light.color;\\n\\t\\t\\t\\tvar intensity = light.intensity;\\n\\t\\t\\t\\tvar distance = light.distance;\\n\\n\\t\\t\\t\\tvar shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\\n\\n\\t\\t\\t\\tif ( light.isAmbientLight ) {\\n\\n\\t\\t\\t\\t\\tr += color.r * intensity;\\n\\t\\t\\t\\t\\tg += color.g * intensity;\\n\\t\\t\\t\\t\\tb += color.b * intensity;\\n\\n\\t\\t\\t\\t} else if ( light.isDirectionalLight ) {\\n\\n\\t\\t\\t\\t\\tvar uniforms = cache.get( light );\\n\\n\\t\\t\\t\\t\\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\\n\\t\\t\\t\\t\\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\\n\\t\\t\\t\\t\\tvector3.setFromMatrixPosition( light.target.matrixWorld );\\n\\t\\t\\t\\t\\tuniforms.direction.sub( vector3 );\\n\\t\\t\\t\\t\\tuniforms.direction.transformDirection( viewMatrix );\\n\\n\\t\\t\\t\\t\\tuniforms.shadow = light.castShadow;\\n\\n\\t\\t\\t\\t\\tif ( light.castShadow ) {\\n\\n\\t\\t\\t\\t\\t\\tvar shadow = light.shadow;\\n\\n\\t\\t\\t\\t\\t\\tuniforms.shadowBias = shadow.bias;\\n\\t\\t\\t\\t\\t\\tuniforms.shadowRadius = shadow.radius;\\n\\t\\t\\t\\t\\t\\tuniforms.shadowMapSize = shadow.mapSize;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tstate.directionalShadowMap[ directionalLength ] = shadowMap;\\n\\t\\t\\t\\t\\tstate.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\\n\\t\\t\\t\\t\\tstate.directional[ directionalLength ] = uniforms;\\n\\n\\t\\t\\t\\t\\tdirectionalLength ++;\\n\\n\\t\\t\\t\\t} else if ( light.isSpotLight ) {\\n\\n\\t\\t\\t\\t\\tvar uniforms = cache.get( light );\\n\\n\\t\\t\\t\\t\\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\\n\\t\\t\\t\\t\\tuniforms.position.applyMatrix4( viewMatrix );\\n\\n\\t\\t\\t\\t\\tuniforms.color.copy( color ).multiplyScalar( intensity );\\n\\t\\t\\t\\t\\tuniforms.distance = distance;\\n\\n\\t\\t\\t\\t\\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\\n\\t\\t\\t\\t\\tvector3.setFromMatrixPosition( light.target.matrixWorld );\\n\\t\\t\\t\\t\\tuniforms.direction.sub( vector3 );\\n\\t\\t\\t\\t\\tuniforms.direction.transformDirection( viewMatrix );\\n\\n\\t\\t\\t\\t\\tuniforms.coneCos = Math.cos( light.angle );\\n\\t\\t\\t\\t\\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\\n\\t\\t\\t\\t\\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\\n\\n\\t\\t\\t\\t\\tuniforms.shadow = light.castShadow;\\n\\n\\t\\t\\t\\t\\tif ( light.castShadow ) {\\n\\n\\t\\t\\t\\t\\t\\tvar shadow = light.shadow;\\n\\n\\t\\t\\t\\t\\t\\tuniforms.shadowBias = shadow.bias;\\n\\t\\t\\t\\t\\t\\tuniforms.shadowRadius = shadow.radius;\\n\\t\\t\\t\\t\\t\\tuniforms.shadowMapSize = shadow.mapSize;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tstate.spotShadowMap[ spotLength ] = shadowMap;\\n\\t\\t\\t\\t\\tstate.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\\n\\t\\t\\t\\t\\tstate.spot[ spotLength ] = uniforms;\\n\\n\\t\\t\\t\\t\\tspotLength ++;\\n\\n\\t\\t\\t\\t} else if ( light.isRectAreaLight ) {\\n\\n\\t\\t\\t\\t\\tvar uniforms = cache.get( light );\\n\\n\\t\\t\\t\\t\\t// (a) intensity controls irradiance of entire light\\n\\t\\t\\t\\t\\tuniforms.color\\n\\t\\t\\t\\t\\t\\t.copy( color )\\n\\t\\t\\t\\t\\t\\t.multiplyScalar( intensity / ( light.width * light.height ) );\\n\\n\\t\\t\\t\\t\\t// (b) intensity controls the radiance per light area\\n\\t\\t\\t\\t\\t// uniforms.color.copy( color ).multiplyScalar( intensity );\\n\\n\\t\\t\\t\\t\\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\\n\\t\\t\\t\\t\\tuniforms.position.applyMatrix4( viewMatrix );\\n\\n\\t\\t\\t\\t\\t// extract local rotation of light to derive width/height half vectors\\n\\t\\t\\t\\t\\tmatrix42.identity();\\n\\t\\t\\t\\t\\tmatrix4.copy( light.matrixWorld );\\n\\t\\t\\t\\t\\tmatrix4.premultiply( viewMatrix );\\n\\t\\t\\t\\t\\tmatrix42.extractRotation( matrix4 );\\n\\n\\t\\t\\t\\t\\tuniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );\\n\\t\\t\\t\\t\\tuniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );\\n\\n\\t\\t\\t\\t\\tuniforms.halfWidth.applyMatrix4( matrix42 );\\n\\t\\t\\t\\t\\tuniforms.halfHeight.applyMatrix4( matrix42 );\\n\\n\\t\\t\\t\\t\\t// TODO (abelnation): RectAreaLight distance?\\n\\t\\t\\t\\t\\t// uniforms.distance = distance;\\n\\n\\t\\t\\t\\t\\tstate.rectArea[ rectAreaLength ] = uniforms;\\n\\n\\t\\t\\t\\t\\trectAreaLength ++;\\n\\n\\t\\t\\t\\t} else if ( light.isPointLight ) {\\n\\n\\t\\t\\t\\t\\tvar uniforms = cache.get( light );\\n\\n\\t\\t\\t\\t\\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\\n\\t\\t\\t\\t\\tuniforms.position.applyMatrix4( viewMatrix );\\n\\n\\t\\t\\t\\t\\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\\n\\t\\t\\t\\t\\tuniforms.distance = light.distance;\\n\\t\\t\\t\\t\\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\\n\\n\\t\\t\\t\\t\\tuniforms.shadow = light.castShadow;\\n\\n\\t\\t\\t\\t\\tif ( light.castShadow ) {\\n\\n\\t\\t\\t\\t\\t\\tvar shadow = light.shadow;\\n\\n\\t\\t\\t\\t\\t\\tuniforms.shadowBias = shadow.bias;\\n\\t\\t\\t\\t\\t\\tuniforms.shadowRadius = shadow.radius;\\n\\t\\t\\t\\t\\t\\tuniforms.shadowMapSize = shadow.mapSize;\\n\\t\\t\\t\\t\\t\\tuniforms.shadowCameraNear = shadow.camera.near;\\n\\t\\t\\t\\t\\t\\tuniforms.shadowCameraFar = shadow.camera.far;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tstate.pointShadowMap[ pointLength ] = shadowMap;\\n\\t\\t\\t\\t\\tstate.pointShadowMatrix[ pointLength ] = light.shadow.matrix;\\n\\t\\t\\t\\t\\tstate.point[ pointLength ] = uniforms;\\n\\n\\t\\t\\t\\t\\tpointLength ++;\\n\\n\\t\\t\\t\\t} else if ( light.isHemisphereLight ) {\\n\\n\\t\\t\\t\\t\\tvar uniforms = cache.get( light );\\n\\n\\t\\t\\t\\t\\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\\n\\t\\t\\t\\t\\tuniforms.direction.transformDirection( viewMatrix );\\n\\t\\t\\t\\t\\tuniforms.direction.normalize();\\n\\n\\t\\t\\t\\t\\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\\n\\t\\t\\t\\t\\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\\n\\n\\t\\t\\t\\t\\tstate.hemi[ hemiLength ] = uniforms;\\n\\n\\t\\t\\t\\t\\themiLength ++;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tstate.ambient[ 0 ] = r;\\n\\t\\t\\tstate.ambient[ 1 ] = g;\\n\\t\\t\\tstate.ambient[ 2 ] = b;\\n\\n\\t\\t\\tstate.directional.length = directionalLength;\\n\\t\\t\\tstate.spot.length = spotLength;\\n\\t\\t\\tstate.rectArea.length = rectAreaLength;\\n\\t\\t\\tstate.point.length = pointLength;\\n\\t\\t\\tstate.hemi.length = hemiLength;\\n\\n\\t\\t\\t// TODO (sam-g-steel) why aren't we using join\\n\\t\\t\\tstate.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + rectAreaLength + ',' + hemiLength + ',' + shadows.length;\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\tsetup: setup,\\n\\t\\t\\tstate: state\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLObjects( geometries, infoRender ) {\\n\\n\\t\\tvar updateList = {};\\n\\n\\t\\tfunction update( object ) {\\n\\n\\t\\t\\tvar frame = infoRender.frame;\\n\\n\\t\\t\\tvar geometry = object.geometry;\\n\\t\\t\\tvar buffergeometry = geometries.get( object, geometry );\\n\\n\\t\\t\\t// Update once per frame\\n\\n\\t\\t\\tif ( updateList[ buffergeometry.id ] !== frame ) {\\n\\n\\t\\t\\t\\tif ( geometry.isGeometry ) {\\n\\n\\t\\t\\t\\t\\tbuffergeometry.updateFromObject( object );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgeometries.update( buffergeometry );\\n\\n\\t\\t\\t\\tupdateList[ buffergeometry.id ] = frame;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn buffergeometry;\\n\\n\\t\\t}\\n\\n\\t\\tfunction clear() {\\n\\n\\t\\t\\tupdateList = {};\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tupdate: update,\\n\\t\\t\\tclear: clear\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction addLineNumbers( string ) {\\n\\n\\t\\tvar lines = string.split( '\\\\n' );\\n\\n\\t\\tfor ( var i = 0; i < lines.length; i ++ ) {\\n\\n\\t\\t\\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\\n\\n\\t\\t}\\n\\n\\t\\treturn lines.join( '\\\\n' );\\n\\n\\t}\\n\\n\\tfunction WebGLShader( gl, type, string ) {\\n\\n\\t\\tvar shader = gl.createShader( type );\\n\\n\\t\\tgl.shaderSource( shader, string );\\n\\t\\tgl.compileShader( shader );\\n\\n\\t\\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.WebGLShader: Shader couldn\\\\'t compile.' );\\n\\n\\t\\t}\\n\\n\\t\\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\\n\\n\\t\\t}\\n\\n\\t\\t// --enable-privileged-webgl-extension\\n\\t\\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\\n\\n\\t\\treturn shader;\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tvar programIdCount = 0;\\n\\n\\tfunction getEncodingComponents( encoding ) {\\n\\n\\t\\tswitch ( encoding ) {\\n\\n\\t\\t\\tcase LinearEncoding:\\n\\t\\t\\t\\treturn [ 'Linear', '( value )' ];\\n\\t\\t\\tcase sRGBEncoding:\\n\\t\\t\\t\\treturn [ 'sRGB', '( value )' ];\\n\\t\\t\\tcase RGBEEncoding:\\n\\t\\t\\t\\treturn [ 'RGBE', '( value )' ];\\n\\t\\t\\tcase RGBM7Encoding:\\n\\t\\t\\t\\treturn [ 'RGBM', '( value, 7.0 )' ];\\n\\t\\t\\tcase RGBM16Encoding:\\n\\t\\t\\t\\treturn [ 'RGBM', '( value, 16.0 )' ];\\n\\t\\t\\tcase RGBDEncoding:\\n\\t\\t\\t\\treturn [ 'RGBD', '( value, 256.0 )' ];\\n\\t\\t\\tcase GammaEncoding:\\n\\t\\t\\t\\treturn [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tthrow new Error( 'unsupported encoding: ' + encoding );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction getTexelDecodingFunction( functionName, encoding ) {\\n\\n\\t\\tvar components = getEncodingComponents( encoding );\\n\\t\\treturn 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';\\n\\n\\t}\\n\\n\\tfunction getTexelEncodingFunction( functionName, encoding ) {\\n\\n\\t\\tvar components = getEncodingComponents( encoding );\\n\\t\\treturn 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';\\n\\n\\t}\\n\\n\\tfunction getToneMappingFunction( functionName, toneMapping ) {\\n\\n\\t\\tvar toneMappingName;\\n\\n\\t\\tswitch ( toneMapping ) {\\n\\n\\t\\t\\tcase LinearToneMapping:\\n\\t\\t\\t\\ttoneMappingName = 'Linear';\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase ReinhardToneMapping:\\n\\t\\t\\t\\ttoneMappingName = 'Reinhard';\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase Uncharted2ToneMapping:\\n\\t\\t\\t\\ttoneMappingName = 'Uncharted2';\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase CineonToneMapping:\\n\\t\\t\\t\\ttoneMappingName = 'OptimizedCineon';\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\\n\\n\\t\\t}\\n\\n\\t\\treturn 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';\\n\\n\\t}\\n\\n\\tfunction generateExtensions( extensions, parameters, rendererExtensions ) {\\n\\n\\t\\textensions = extensions || {};\\n\\n\\t\\tvar chunks = [\\n\\t\\t\\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\\n\\t\\t\\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\\n\\t\\t\\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\\n\\t\\t\\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''\\n\\t\\t];\\n\\n\\t\\treturn chunks.filter( filterEmptyLine ).join( '\\\\n' );\\n\\n\\t}\\n\\n\\tfunction generateDefines( defines ) {\\n\\n\\t\\tvar chunks = [];\\n\\n\\t\\tfor ( var name in defines ) {\\n\\n\\t\\t\\tvar value = defines[ name ];\\n\\n\\t\\t\\tif ( value === false ) continue;\\n\\n\\t\\t\\tchunks.push( '#define ' + name + ' ' + value );\\n\\n\\t\\t}\\n\\n\\t\\treturn chunks.join( '\\\\n' );\\n\\n\\t}\\n\\n\\tfunction fetchAttributeLocations( gl, program ) {\\n\\n\\t\\tvar attributes = {};\\n\\n\\t\\tvar n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\\n\\n\\t\\tfor ( var i = 0; i < n; i ++ ) {\\n\\n\\t\\t\\tvar info = gl.getActiveAttrib( program, i );\\n\\t\\t\\tvar name = info.name;\\n\\n\\t\\t\\t// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );\\n\\n\\t\\t\\tattributes[ name ] = gl.getAttribLocation( program, name );\\n\\n\\t\\t}\\n\\n\\t\\treturn attributes;\\n\\n\\t}\\n\\n\\tfunction filterEmptyLine( string ) {\\n\\n\\t\\treturn string !== '';\\n\\n\\t}\\n\\n\\tfunction replaceLightNums( string, parameters ) {\\n\\n\\t\\treturn string\\n\\t\\t\\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\\n\\t\\t\\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\\n\\t\\t\\t.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )\\n\\t\\t\\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\\n\\t\\t\\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\\n\\n\\t}\\n\\n\\tfunction parseIncludes( string ) {\\n\\n\\t\\tvar pattern = /^[ \\\\t]*#include +<([\\\\w\\\\d.]+)>/gm;\\n\\n\\t\\tfunction replace( match, include ) {\\n\\n\\t\\t\\tvar replace = ShaderChunk[ include ];\\n\\n\\t\\t\\tif ( replace === undefined ) {\\n\\n\\t\\t\\t\\tthrow new Error( 'Can not resolve #include <' + include + '>' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn parseIncludes( replace );\\n\\n\\t\\t}\\n\\n\\t\\treturn string.replace( pattern, replace );\\n\\n\\t}\\n\\n\\tfunction unrollLoops( string ) {\\n\\n\\t\\tvar pattern = /for \\\\( int i \\\\= (\\\\d+)\\\\; i < (\\\\d+)\\\\; i \\\\+\\\\+ \\\\) \\\\{([\\\\s\\\\S]+?)(?=\\\\})\\\\}/g;\\n\\n\\t\\tfunction replace( match, start, end, snippet ) {\\n\\n\\t\\t\\tvar unroll = '';\\n\\n\\t\\t\\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\\n\\n\\t\\t\\t\\tunroll += snippet.replace( /\\\\[ i \\\\]/g, '[ ' + i + ' ]' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn unroll;\\n\\n\\t\\t}\\n\\n\\t\\treturn string.replace( pattern, replace );\\n\\n\\t}\\n\\n\\tfunction WebGLProgram( renderer, extensions, code, material, shader, parameters ) {\\n\\n\\t\\tvar gl = renderer.context;\\n\\n\\t\\tvar defines = material.defines;\\n\\n\\t\\tvar vertexShader = shader.vertexShader;\\n\\t\\tvar fragmentShader = shader.fragmentShader;\\n\\n\\t\\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\\n\\n\\t\\tif ( parameters.shadowMapType === PCFShadowMap ) {\\n\\n\\t\\t\\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\\n\\n\\t\\t} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {\\n\\n\\t\\t\\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\\n\\n\\t\\t}\\n\\n\\t\\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\\n\\t\\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\\n\\t\\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\\n\\n\\t\\tif ( parameters.envMap ) {\\n\\n\\t\\t\\tswitch ( material.envMap.mapping ) {\\n\\n\\t\\t\\t\\tcase CubeReflectionMapping:\\n\\t\\t\\t\\tcase CubeRefractionMapping:\\n\\t\\t\\t\\t\\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase CubeUVReflectionMapping:\\n\\t\\t\\t\\tcase CubeUVRefractionMapping:\\n\\t\\t\\t\\t\\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase EquirectangularReflectionMapping:\\n\\t\\t\\t\\tcase EquirectangularRefractionMapping:\\n\\t\\t\\t\\t\\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase SphericalReflectionMapping:\\n\\t\\t\\t\\t\\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tswitch ( material.envMap.mapping ) {\\n\\n\\t\\t\\t\\tcase CubeRefractionMapping:\\n\\t\\t\\t\\tcase EquirectangularRefractionMapping:\\n\\t\\t\\t\\t\\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tswitch ( material.combine ) {\\n\\n\\t\\t\\t\\tcase MultiplyOperation:\\n\\t\\t\\t\\t\\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase MixOperation:\\n\\t\\t\\t\\t\\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase AddOperation:\\n\\t\\t\\t\\t\\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\\n\\n\\t\\t// console.log( 'building new program ' );\\n\\n\\t\\t//\\n\\n\\t\\tvar customExtensions = generateExtensions( material.extensions, parameters, extensions );\\n\\n\\t\\tvar customDefines = generateDefines( defines );\\n\\n\\t\\t//\\n\\n\\t\\tvar program = gl.createProgram();\\n\\n\\t\\tvar prefixVertex, prefixFragment;\\n\\n\\t\\tif ( material.isRawShaderMaterial ) {\\n\\n\\t\\t\\tprefixVertex = [\\n\\n\\t\\t\\t\\tcustomDefines\\n\\n\\t\\t\\t].filter( filterEmptyLine ).join( '\\\\n' );\\n\\n\\t\\t\\tif ( prefixVertex.length > 0 ) {\\n\\n\\t\\t\\t\\tprefixVertex += '\\\\n';\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tprefixFragment = [\\n\\n\\t\\t\\t\\tcustomExtensions,\\n\\t\\t\\t\\tcustomDefines\\n\\n\\t\\t\\t].filter( filterEmptyLine ).join( '\\\\n' );\\n\\n\\t\\t\\tif ( prefixFragment.length > 0 ) {\\n\\n\\t\\t\\t\\tprefixFragment += '\\\\n';\\n\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tprefixVertex = [\\n\\n\\t\\t\\t\\t'precision ' + parameters.precision + ' float;',\\n\\t\\t\\t\\t'precision ' + parameters.precision + ' int;',\\n\\n\\t\\t\\t\\t'#define SHADER_NAME ' + shader.name,\\n\\n\\t\\t\\t\\tcustomDefines,\\n\\n\\t\\t\\t\\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\\n\\n\\t\\t\\t\\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\\n\\n\\t\\t\\t\\t'#define MAX_BONES ' + parameters.maxBones,\\n\\t\\t\\t\\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\\n\\t\\t\\t\\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\\n\\n\\t\\t\\t\\tparameters.map ? '#define USE_MAP' : '',\\n\\t\\t\\t\\tparameters.envMap ? '#define USE_ENVMAP' : '',\\n\\t\\t\\t\\tparameters.envMap ? '#define ' + envMapModeDefine : '',\\n\\t\\t\\t\\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\\n\\t\\t\\t\\tparameters.aoMap ? '#define USE_AOMAP' : '',\\n\\t\\t\\t\\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\\n\\t\\t\\t\\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\\n\\t\\t\\t\\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\\n\\t\\t\\t\\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\\n\\t\\t\\t\\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\\n\\t\\t\\t\\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\\n\\t\\t\\t\\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\\n\\t\\t\\t\\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\\n\\t\\t\\t\\tparameters.vertexColors ? '#define USE_COLOR' : '',\\n\\n\\t\\t\\t\\tparameters.flatShading ? '#define FLAT_SHADED' : '',\\n\\n\\t\\t\\t\\tparameters.skinning ? '#define USE_SKINNING' : '',\\n\\t\\t\\t\\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\\n\\n\\t\\t\\t\\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\\n\\t\\t\\t\\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\\n\\t\\t\\t\\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\\n\\t\\t\\t\\tparameters.flipSided ? '#define FLIP_SIDED' : '',\\n\\n\\t\\t\\t\\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\\n\\n\\t\\t\\t\\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\\n\\t\\t\\t\\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\\n\\n\\t\\t\\t\\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\\n\\n\\t\\t\\t\\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\\n\\t\\t\\t\\tparameters.logarithmicDepthBuffer && extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\\n\\n\\t\\t\\t\\t'uniform mat4 modelMatrix;',\\n\\t\\t\\t\\t'uniform mat4 modelViewMatrix;',\\n\\t\\t\\t\\t'uniform mat4 projectionMatrix;',\\n\\t\\t\\t\\t'uniform mat4 viewMatrix;',\\n\\t\\t\\t\\t'uniform mat3 normalMatrix;',\\n\\t\\t\\t\\t'uniform vec3 cameraPosition;',\\n\\n\\t\\t\\t\\t'attribute vec3 position;',\\n\\t\\t\\t\\t'attribute vec3 normal;',\\n\\t\\t\\t\\t'attribute vec2 uv;',\\n\\n\\t\\t\\t\\t'#ifdef USE_COLOR',\\n\\n\\t\\t\\t\\t'\\tattribute vec3 color;',\\n\\n\\t\\t\\t\\t'#endif',\\n\\n\\t\\t\\t\\t'#ifdef USE_MORPHTARGETS',\\n\\n\\t\\t\\t\\t'\\tattribute vec3 morphTarget0;',\\n\\t\\t\\t\\t'\\tattribute vec3 morphTarget1;',\\n\\t\\t\\t\\t'\\tattribute vec3 morphTarget2;',\\n\\t\\t\\t\\t'\\tattribute vec3 morphTarget3;',\\n\\n\\t\\t\\t\\t'\\t#ifdef USE_MORPHNORMALS',\\n\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphNormal0;',\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphNormal1;',\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphNormal2;',\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphNormal3;',\\n\\n\\t\\t\\t\\t'\\t#else',\\n\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphTarget4;',\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphTarget5;',\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphTarget6;',\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphTarget7;',\\n\\n\\t\\t\\t\\t'\\t#endif',\\n\\n\\t\\t\\t\\t'#endif',\\n\\n\\t\\t\\t\\t'#ifdef USE_SKINNING',\\n\\n\\t\\t\\t\\t'\\tattribute vec4 skinIndex;',\\n\\t\\t\\t\\t'\\tattribute vec4 skinWeight;',\\n\\n\\t\\t\\t\\t'#endif',\\n\\n\\t\\t\\t\\t'\\\\n'\\n\\n\\t\\t\\t].filter( filterEmptyLine ).join( '\\\\n' );\\n\\n\\t\\t\\tprefixFragment = [\\n\\n\\t\\t\\t\\tcustomExtensions,\\n\\n\\t\\t\\t\\t'precision ' + parameters.precision + ' float;',\\n\\t\\t\\t\\t'precision ' + parameters.precision + ' int;',\\n\\n\\t\\t\\t\\t'#define SHADER_NAME ' + shader.name,\\n\\n\\t\\t\\t\\tcustomDefines,\\n\\n\\t\\t\\t\\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\\n\\n\\t\\t\\t\\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\\n\\n\\t\\t\\t\\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\\n\\t\\t\\t\\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\\n\\n\\t\\t\\t\\tparameters.map ? '#define USE_MAP' : '',\\n\\t\\t\\t\\tparameters.envMap ? '#define USE_ENVMAP' : '',\\n\\t\\t\\t\\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\\n\\t\\t\\t\\tparameters.envMap ? '#define ' + envMapModeDefine : '',\\n\\t\\t\\t\\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\\n\\t\\t\\t\\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\\n\\t\\t\\t\\tparameters.aoMap ? '#define USE_AOMAP' : '',\\n\\t\\t\\t\\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\\n\\t\\t\\t\\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\\n\\t\\t\\t\\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\\n\\t\\t\\t\\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\\n\\t\\t\\t\\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\\n\\t\\t\\t\\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\\n\\t\\t\\t\\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\\n\\t\\t\\t\\tparameters.vertexColors ? '#define USE_COLOR' : '',\\n\\n\\t\\t\\t\\tparameters.gradientMap ? '#define USE_GRADIENTMAP' : '',\\n\\n\\t\\t\\t\\tparameters.flatShading ? '#define FLAT_SHADED' : '',\\n\\n\\t\\t\\t\\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\\n\\t\\t\\t\\tparameters.flipSided ? '#define FLIP_SIDED' : '',\\n\\n\\t\\t\\t\\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\\n\\t\\t\\t\\t'#define UNION_CLIPPING_PLANES ' + ( parameters.numClippingPlanes - parameters.numClipIntersection ),\\n\\n\\t\\t\\t\\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\\n\\t\\t\\t\\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\\n\\n\\t\\t\\t\\tparameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',\\n\\n\\t\\t\\t\\tparameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',\\n\\n\\t\\t\\t\\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\\n\\t\\t\\t\\tparameters.logarithmicDepthBuffer && extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\\n\\n\\t\\t\\t\\tparameters.envMap && extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\\n\\n\\t\\t\\t\\t'uniform mat4 viewMatrix;',\\n\\t\\t\\t\\t'uniform vec3 cameraPosition;',\\n\\n\\t\\t\\t\\t( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',\\n\\t\\t\\t\\t( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below\\n\\t\\t\\t\\t( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',\\n\\n\\t\\t\\t\\tparameters.dithering ? '#define DITHERING' : '',\\n\\n\\t\\t\\t\\t( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\\n\\t\\t\\t\\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\\n\\t\\t\\t\\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\\n\\t\\t\\t\\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\\n\\t\\t\\t\\tparameters.outputEncoding ? getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ) : '',\\n\\n\\t\\t\\t\\tparameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '',\\n\\n\\t\\t\\t\\t'\\\\n'\\n\\n\\t\\t\\t].filter( filterEmptyLine ).join( '\\\\n' );\\n\\n\\t\\t}\\n\\n\\t\\tvertexShader = parseIncludes( vertexShader );\\n\\t\\tvertexShader = replaceLightNums( vertexShader, parameters );\\n\\n\\t\\tfragmentShader = parseIncludes( fragmentShader );\\n\\t\\tfragmentShader = replaceLightNums( fragmentShader, parameters );\\n\\n\\t\\tif ( ! material.isShaderMaterial ) {\\n\\n\\t\\t\\tvertexShader = unrollLoops( vertexShader );\\n\\t\\t\\tfragmentShader = unrollLoops( fragmentShader );\\n\\n\\t\\t}\\n\\n\\t\\tvar vertexGlsl = prefixVertex + vertexShader;\\n\\t\\tvar fragmentGlsl = prefixFragment + fragmentShader;\\n\\n\\t\\t// console.log( '*VERTEX*', vertexGlsl );\\n\\t\\t// console.log( '*FRAGMENT*', fragmentGlsl );\\n\\n\\t\\tvar glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\\n\\t\\tvar glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\\n\\n\\t\\tgl.attachShader( program, glVertexShader );\\n\\t\\tgl.attachShader( program, glFragmentShader );\\n\\n\\t\\t// Force a particular attribute to index 0.\\n\\n\\t\\tif ( material.index0AttributeName !== undefined ) {\\n\\n\\t\\t\\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\\n\\n\\t\\t} else if ( parameters.morphTargets === true ) {\\n\\n\\t\\t\\t// programs with morphTargets displace position out of attribute 0\\n\\t\\t\\tgl.bindAttribLocation( program, 0, 'position' );\\n\\n\\t\\t}\\n\\n\\t\\tgl.linkProgram( program );\\n\\n\\t\\tvar programLog = gl.getProgramInfoLog( program );\\n\\t\\tvar vertexLog = gl.getShaderInfoLog( glVertexShader );\\n\\t\\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader );\\n\\n\\t\\tvar runnable = true;\\n\\t\\tvar haveDiagnostics = true;\\n\\n\\t\\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\\n\\t\\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\\n\\n\\t\\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\\n\\n\\t\\t\\trunnable = false;\\n\\n\\t\\t\\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\\n\\n\\t\\t} else if ( programLog !== '' ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\\n\\n\\t\\t} else if ( vertexLog === '' || fragmentLog === '' ) {\\n\\n\\t\\t\\thaveDiagnostics = false;\\n\\n\\t\\t}\\n\\n\\t\\tif ( haveDiagnostics ) {\\n\\n\\t\\t\\tthis.diagnostics = {\\n\\n\\t\\t\\t\\trunnable: runnable,\\n\\t\\t\\t\\tmaterial: material,\\n\\n\\t\\t\\t\\tprogramLog: programLog,\\n\\n\\t\\t\\t\\tvertexShader: {\\n\\n\\t\\t\\t\\t\\tlog: vertexLog,\\n\\t\\t\\t\\t\\tprefix: prefixVertex\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tfragmentShader: {\\n\\n\\t\\t\\t\\t\\tlog: fragmentLog,\\n\\t\\t\\t\\t\\tprefix: prefixFragment\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}\\n\\n\\t\\t// clean up\\n\\n\\t\\tgl.deleteShader( glVertexShader );\\n\\t\\tgl.deleteShader( glFragmentShader );\\n\\n\\t\\t// set up caching for uniform locations\\n\\n\\t\\tvar cachedUniforms;\\n\\n\\t\\tthis.getUniforms = function () {\\n\\n\\t\\t\\tif ( cachedUniforms === undefined ) {\\n\\n\\t\\t\\t\\tcachedUniforms = new WebGLUniforms( gl, program, renderer );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn cachedUniforms;\\n\\n\\t\\t};\\n\\n\\t\\t// set up caching for attribute locations\\n\\n\\t\\tvar cachedAttributes;\\n\\n\\t\\tthis.getAttributes = function () {\\n\\n\\t\\t\\tif ( cachedAttributes === undefined ) {\\n\\n\\t\\t\\t\\tcachedAttributes = fetchAttributeLocations( gl, program );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn cachedAttributes;\\n\\n\\t\\t};\\n\\n\\t\\t// free resource\\n\\n\\t\\tthis.destroy = function () {\\n\\n\\t\\t\\tgl.deleteProgram( program );\\n\\t\\t\\tthis.program = undefined;\\n\\n\\t\\t};\\n\\n\\t\\t// DEPRECATED\\n\\n\\t\\tObject.defineProperties( this, {\\n\\n\\t\\t\\tuniforms: {\\n\\t\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\\n\\t\\t\\t\\t\\treturn this.getUniforms();\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\n\\t\\t\\tattributes: {\\n\\t\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\\n\\t\\t\\t\\t\\treturn this.getAttributes();\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t} );\\n\\n\\n\\t\\t//\\n\\n\\t\\tthis.id = programIdCount ++;\\n\\t\\tthis.code = code;\\n\\t\\tthis.usedTimes = 1;\\n\\t\\tthis.program = program;\\n\\t\\tthis.vertexShader = glVertexShader;\\n\\t\\tthis.fragmentShader = glFragmentShader;\\n\\n\\t\\treturn this;\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLPrograms( renderer, extensions, capabilities ) {\\n\\n\\t\\tvar programs = [];\\n\\n\\t\\tvar shaderIDs = {\\n\\t\\t\\tMeshDepthMaterial: 'depth',\\n\\t\\t\\tMeshDistanceMaterial: 'distanceRGBA',\\n\\t\\t\\tMeshNormalMaterial: 'normal',\\n\\t\\t\\tMeshBasicMaterial: 'basic',\\n\\t\\t\\tMeshLambertMaterial: 'lambert',\\n\\t\\t\\tMeshPhongMaterial: 'phong',\\n\\t\\t\\tMeshToonMaterial: 'phong',\\n\\t\\t\\tMeshStandardMaterial: 'physical',\\n\\t\\t\\tMeshPhysicalMaterial: 'physical',\\n\\t\\t\\tLineBasicMaterial: 'basic',\\n\\t\\t\\tLineDashedMaterial: 'dashed',\\n\\t\\t\\tPointsMaterial: 'points',\\n\\t\\t\\tShadowMaterial: 'shadow'\\n\\t\\t};\\n\\n\\t\\tvar parameterNames = [\\n\\t\\t\\t\\\"precision\\\", \\\"supportsVertexTextures\\\", \\\"map\\\", \\\"mapEncoding\\\", \\\"envMap\\\", \\\"envMapMode\\\", \\\"envMapEncoding\\\",\\n\\t\\t\\t\\\"lightMap\\\", \\\"aoMap\\\", \\\"emissiveMap\\\", \\\"emissiveMapEncoding\\\", \\\"bumpMap\\\", \\\"normalMap\\\", \\\"displacementMap\\\", \\\"specularMap\\\",\\n\\t\\t\\t\\\"roughnessMap\\\", \\\"metalnessMap\\\", \\\"gradientMap\\\",\\n\\t\\t\\t\\\"alphaMap\\\", \\\"combine\\\", \\\"vertexColors\\\", \\\"fog\\\", \\\"useFog\\\", \\\"fogExp\\\",\\n\\t\\t\\t\\\"flatShading\\\", \\\"sizeAttenuation\\\", \\\"logarithmicDepthBuffer\\\", \\\"skinning\\\",\\n\\t\\t\\t\\\"maxBones\\\", \\\"useVertexTexture\\\", \\\"morphTargets\\\", \\\"morphNormals\\\",\\n\\t\\t\\t\\\"maxMorphTargets\\\", \\\"maxMorphNormals\\\", \\\"premultipliedAlpha\\\",\\n\\t\\t\\t\\\"numDirLights\\\", \\\"numPointLights\\\", \\\"numSpotLights\\\", \\\"numHemiLights\\\", \\\"numRectAreaLights\\\",\\n\\t\\t\\t\\\"shadowMapEnabled\\\", \\\"shadowMapType\\\", \\\"toneMapping\\\", 'physicallyCorrectLights',\\n\\t\\t\\t\\\"alphaTest\\\", \\\"doubleSided\\\", \\\"flipSided\\\", \\\"numClippingPlanes\\\", \\\"numClipIntersection\\\", \\\"depthPacking\\\", \\\"dithering\\\"\\n\\t\\t];\\n\\n\\n\\t\\tfunction allocateBones( object ) {\\n\\n\\t\\t\\tvar skeleton = object.skeleton;\\n\\t\\t\\tvar bones = skeleton.bones;\\n\\n\\t\\t\\tif ( capabilities.floatVertexTextures ) {\\n\\n\\t\\t\\t\\treturn 1024;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// default for when object is not specified\\n\\t\\t\\t\\t// ( for example when prebuilding shader to be used with multiple objects )\\n\\t\\t\\t\\t//\\n\\t\\t\\t\\t//  - leave some extra space for other uniforms\\n\\t\\t\\t\\t//  - limit here is ANGLE's 254 max uniform vectors\\n\\t\\t\\t\\t//    (up to 54 should be safe)\\n\\n\\t\\t\\t\\tvar nVertexUniforms = capabilities.maxVertexUniforms;\\n\\t\\t\\t\\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\\n\\n\\t\\t\\t\\tvar maxBones = Math.min( nVertexMatrices, bones.length );\\n\\n\\t\\t\\t\\tif ( maxBones < bones.length ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );\\n\\t\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn maxBones;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\\n\\n\\t\\t\\tvar encoding;\\n\\n\\t\\t\\tif ( ! map ) {\\n\\n\\t\\t\\t\\tencoding = LinearEncoding;\\n\\n\\t\\t\\t} else if ( map.isTexture ) {\\n\\n\\t\\t\\t\\tencoding = map.encoding;\\n\\n\\t\\t\\t} else if ( map.isWebGLRenderTarget ) {\\n\\n\\t\\t\\t\\tconsole.warn( \\\"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\\\" );\\n\\t\\t\\t\\tencoding = map.texture.encoding;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\\n\\t\\t\\tif ( encoding === LinearEncoding && gammaOverrideLinear ) {\\n\\n\\t\\t\\t\\tencoding = GammaEncoding;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn encoding;\\n\\n\\t\\t}\\n\\n\\t\\tthis.getParameters = function ( material, lights, shadows, fog, nClipPlanes, nClipIntersection, object ) {\\n\\n\\t\\t\\tvar shaderID = shaderIDs[ material.type ];\\n\\n\\t\\t\\t// heuristics to create shader parameters according to lights in the scene\\n\\t\\t\\t// (not to blow over maxLights budget)\\n\\n\\t\\t\\tvar maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;\\n\\t\\t\\tvar precision = capabilities.precision;\\n\\n\\t\\t\\tif ( material.precision !== null ) {\\n\\n\\t\\t\\t\\tprecision = capabilities.getMaxPrecision( material.precision );\\n\\n\\t\\t\\t\\tif ( precision !== material.precision ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar currentRenderTarget = renderer.getRenderTarget();\\n\\n\\t\\t\\tvar parameters = {\\n\\n\\t\\t\\t\\tshaderID: shaderID,\\n\\n\\t\\t\\t\\tprecision: precision,\\n\\t\\t\\t\\tsupportsVertexTextures: capabilities.vertexTextures,\\n\\t\\t\\t\\toutputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),\\n\\t\\t\\t\\tmap: !! material.map,\\n\\t\\t\\t\\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\\n\\t\\t\\t\\tenvMap: !! material.envMap,\\n\\t\\t\\t\\tenvMapMode: material.envMap && material.envMap.mapping,\\n\\t\\t\\t\\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\\n\\t\\t\\t\\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),\\n\\t\\t\\t\\tlightMap: !! material.lightMap,\\n\\t\\t\\t\\taoMap: !! material.aoMap,\\n\\t\\t\\t\\temissiveMap: !! material.emissiveMap,\\n\\t\\t\\t\\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\\n\\t\\t\\t\\tbumpMap: !! material.bumpMap,\\n\\t\\t\\t\\tnormalMap: !! material.normalMap,\\n\\t\\t\\t\\tdisplacementMap: !! material.displacementMap,\\n\\t\\t\\t\\troughnessMap: !! material.roughnessMap,\\n\\t\\t\\t\\tmetalnessMap: !! material.metalnessMap,\\n\\t\\t\\t\\tspecularMap: !! material.specularMap,\\n\\t\\t\\t\\talphaMap: !! material.alphaMap,\\n\\n\\t\\t\\t\\tgradientMap: !! material.gradientMap,\\n\\n\\t\\t\\t\\tcombine: material.combine,\\n\\n\\t\\t\\t\\tvertexColors: material.vertexColors,\\n\\n\\t\\t\\t\\tfog: !! fog,\\n\\t\\t\\t\\tuseFog: material.fog,\\n\\t\\t\\t\\tfogExp: ( fog && fog.isFogExp2 ),\\n\\n\\t\\t\\t\\tflatShading: material.flatShading,\\n\\n\\t\\t\\t\\tsizeAttenuation: material.sizeAttenuation,\\n\\t\\t\\t\\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\\n\\n\\t\\t\\t\\tskinning: material.skinning && maxBones > 0,\\n\\t\\t\\t\\tmaxBones: maxBones,\\n\\t\\t\\t\\tuseVertexTexture: capabilities.floatVertexTextures,\\n\\n\\t\\t\\t\\tmorphTargets: material.morphTargets,\\n\\t\\t\\t\\tmorphNormals: material.morphNormals,\\n\\t\\t\\t\\tmaxMorphTargets: renderer.maxMorphTargets,\\n\\t\\t\\t\\tmaxMorphNormals: renderer.maxMorphNormals,\\n\\n\\t\\t\\t\\tnumDirLights: lights.directional.length,\\n\\t\\t\\t\\tnumPointLights: lights.point.length,\\n\\t\\t\\t\\tnumSpotLights: lights.spot.length,\\n\\t\\t\\t\\tnumRectAreaLights: lights.rectArea.length,\\n\\t\\t\\t\\tnumHemiLights: lights.hemi.length,\\n\\n\\t\\t\\t\\tnumClippingPlanes: nClipPlanes,\\n\\t\\t\\t\\tnumClipIntersection: nClipIntersection,\\n\\n\\t\\t\\t\\tdithering: material.dithering,\\n\\n\\t\\t\\t\\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,\\n\\t\\t\\t\\tshadowMapType: renderer.shadowMap.type,\\n\\n\\t\\t\\t\\ttoneMapping: renderer.toneMapping,\\n\\t\\t\\t\\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\\n\\n\\t\\t\\t\\tpremultipliedAlpha: material.premultipliedAlpha,\\n\\n\\t\\t\\t\\talphaTest: material.alphaTest,\\n\\t\\t\\t\\tdoubleSided: material.side === DoubleSide,\\n\\t\\t\\t\\tflipSided: material.side === BackSide,\\n\\n\\t\\t\\t\\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\\n\\n\\t\\t\\t};\\n\\n\\t\\t\\treturn parameters;\\n\\n\\t\\t};\\n\\n\\t\\tthis.getProgramCode = function ( material, parameters ) {\\n\\n\\t\\t\\tvar array = [];\\n\\n\\t\\t\\tif ( parameters.shaderID ) {\\n\\n\\t\\t\\t\\tarray.push( parameters.shaderID );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tarray.push( material.fragmentShader );\\n\\t\\t\\t\\tarray.push( material.vertexShader );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.defines !== undefined ) {\\n\\n\\t\\t\\t\\tfor ( var name in material.defines ) {\\n\\n\\t\\t\\t\\t\\tarray.push( name );\\n\\t\\t\\t\\t\\tarray.push( material.defines[ name ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\\n\\n\\t\\t\\t\\tarray.push( parameters[ parameterNames[ i ] ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tarray.push( material.onBeforeCompile.toString() );\\n\\n\\t\\t\\tarray.push( renderer.gammaOutput );\\n\\n\\t\\t\\treturn array.join();\\n\\n\\t\\t};\\n\\n\\t\\tthis.acquireProgram = function ( material, shader, parameters, code ) {\\n\\n\\t\\t\\tvar program;\\n\\n\\t\\t\\t// Check if code has been already compiled\\n\\t\\t\\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\\n\\n\\t\\t\\t\\tvar programInfo = programs[ p ];\\n\\n\\t\\t\\t\\tif ( programInfo.code === code ) {\\n\\n\\t\\t\\t\\t\\tprogram = programInfo;\\n\\t\\t\\t\\t\\t++ program.usedTimes;\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( program === undefined ) {\\n\\n\\t\\t\\t\\tprogram = new WebGLProgram( renderer, extensions, code, material, shader, parameters );\\n\\t\\t\\t\\tprograms.push( program );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn program;\\n\\n\\t\\t};\\n\\n\\t\\tthis.releaseProgram = function ( program ) {\\n\\n\\t\\t\\tif ( -- program.usedTimes === 0 ) {\\n\\n\\t\\t\\t\\t// Remove from unordered set\\n\\t\\t\\t\\tvar i = programs.indexOf( program );\\n\\t\\t\\t\\tprograms[ i ] = programs[ programs.length - 1 ];\\n\\t\\t\\t\\tprograms.pop();\\n\\n\\t\\t\\t\\t// Free WebGL resources\\n\\t\\t\\t\\tprogram.destroy();\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\t// Exposed for resource monitoring & error feedback via renderer.info:\\n\\t\\tthis.programs = programs;\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils, infoMemory ) {\\n\\n\\t\\tvar _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof window.WebGL2RenderingContext );\\n\\t\\tvar _videoTextures = {};\\n\\n\\t\\t//\\n\\n\\t\\tfunction clampToMaxSize( image, maxSize ) {\\n\\n\\t\\t\\tif ( image.width > maxSize || image.height > maxSize ) {\\n\\n\\t\\t\\t\\t// Warning: Scaling through the canvas will only work with images that use\\n\\t\\t\\t\\t// premultiplied alpha.\\n\\n\\t\\t\\t\\tvar scale = maxSize / Math.max( image.width, image.height );\\n\\n\\t\\t\\t\\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\\n\\t\\t\\t\\tcanvas.width = Math.floor( image.width * scale );\\n\\t\\t\\t\\tcanvas.height = Math.floor( image.height * scale );\\n\\n\\t\\t\\t\\tvar context = canvas.getContext( '2d' );\\n\\t\\t\\t\\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\\n\\n\\t\\t\\t\\treturn canvas;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn image;\\n\\n\\t\\t}\\n\\n\\t\\tfunction isPowerOfTwo( image ) {\\n\\n\\t\\t\\treturn _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );\\n\\n\\t\\t}\\n\\n\\t\\tfunction makePowerOfTwo( image ) {\\n\\n\\t\\t\\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof ImageBitmap ) {\\n\\n\\t\\t\\t\\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\\n\\t\\t\\t\\tcanvas.width = _Math.floorPowerOfTwo( image.width );\\n\\t\\t\\t\\tcanvas.height = _Math.floorPowerOfTwo( image.height );\\n\\n\\t\\t\\t\\tvar context = canvas.getContext( '2d' );\\n\\t\\t\\t\\tcontext.drawImage( image, 0, 0, canvas.width, canvas.height );\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\\n\\n\\t\\t\\t\\treturn canvas;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn image;\\n\\n\\t\\t}\\n\\n\\t\\tfunction textureNeedsPowerOfTwo( texture ) {\\n\\n\\t\\t\\treturn ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||\\n\\t\\t\\t\\t( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );\\n\\n\\t\\t}\\n\\n\\t\\tfunction textureNeedsGenerateMipmaps( texture, isPowerOfTwo ) {\\n\\n\\t\\t\\treturn texture.generateMipmaps && isPowerOfTwo &&\\n\\t\\t\\t\\ttexture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\\n\\n\\t\\t}\\n\\n\\t\\t// Fallback filters for non-power-of-2 textures\\n\\n\\t\\tfunction filterFallback( f ) {\\n\\n\\t\\t\\tif ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {\\n\\n\\t\\t\\t\\treturn _gl.NEAREST;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn _gl.LINEAR;\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tfunction onTextureDispose( event ) {\\n\\n\\t\\t\\tvar texture = event.target;\\n\\n\\t\\t\\ttexture.removeEventListener( 'dispose', onTextureDispose );\\n\\n\\t\\t\\tdeallocateTexture( texture );\\n\\n\\t\\t\\tif ( texture.isVideoTexture ) {\\n\\n\\t\\t\\t\\tdelete _videoTextures[ texture.id ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tinfoMemory.textures --;\\n\\n\\t\\t}\\n\\n\\t\\tfunction onRenderTargetDispose( event ) {\\n\\n\\t\\t\\tvar renderTarget = event.target;\\n\\n\\t\\t\\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\\n\\n\\t\\t\\tdeallocateRenderTarget( renderTarget );\\n\\n\\t\\t\\tinfoMemory.textures --;\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tfunction deallocateTexture( texture ) {\\n\\n\\t\\t\\tvar textureProperties = properties.get( texture );\\n\\n\\t\\t\\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\\n\\n\\t\\t\\t\\t// cube texture\\n\\n\\t\\t\\t\\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// 2D texture\\n\\n\\t\\t\\t\\tif ( textureProperties.__webglInit === undefined ) return;\\n\\n\\t\\t\\t\\t_gl.deleteTexture( textureProperties.__webglTexture );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// remove all webgl properties\\n\\t\\t\\tproperties.remove( texture );\\n\\n\\t\\t}\\n\\n\\t\\tfunction deallocateRenderTarget( renderTarget ) {\\n\\n\\t\\t\\tvar renderTargetProperties = properties.get( renderTarget );\\n\\t\\t\\tvar textureProperties = properties.get( renderTarget.texture );\\n\\n\\t\\t\\tif ( ! renderTarget ) return;\\n\\n\\t\\t\\tif ( textureProperties.__webglTexture !== undefined ) {\\n\\n\\t\\t\\t\\t_gl.deleteTexture( textureProperties.__webglTexture );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( renderTarget.depthTexture ) {\\n\\n\\t\\t\\t\\trenderTarget.depthTexture.dispose();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( renderTarget.isWebGLRenderTargetCube ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\t\\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\\n\\t\\t\\t\\t\\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\\n\\t\\t\\t\\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tproperties.remove( renderTarget.texture );\\n\\t\\t\\tproperties.remove( renderTarget );\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\n\\n\\t\\tfunction setTexture2D( texture, slot ) {\\n\\n\\t\\t\\tvar textureProperties = properties.get( texture );\\n\\n\\t\\t\\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\\n\\n\\t\\t\\t\\tvar image = texture.image;\\n\\n\\t\\t\\t\\tif ( image === undefined ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\\n\\n\\t\\t\\t\\t} else if ( image.complete === false ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tuploadTexture( textureProperties, texture, slot );\\n\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tstate.activeTexture( _gl.TEXTURE0 + slot );\\n\\t\\t\\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\\n\\n\\t\\t}\\n\\n\\t\\tfunction setTextureCube( texture, slot ) {\\n\\n\\t\\t\\tvar textureProperties = properties.get( texture );\\n\\n\\t\\t\\tif ( texture.image.length === 6 ) {\\n\\n\\t\\t\\t\\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\\n\\n\\t\\t\\t\\t\\tif ( ! textureProperties.__image__webglTextureCube ) {\\n\\n\\t\\t\\t\\t\\t\\ttexture.addEventListener( 'dispose', onTextureDispose );\\n\\n\\t\\t\\t\\t\\t\\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\\n\\n\\t\\t\\t\\t\\t\\tinfoMemory.textures ++;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tstate.activeTexture( _gl.TEXTURE0 + slot );\\n\\t\\t\\t\\t\\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\\n\\n\\t\\t\\t\\t\\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\\n\\n\\t\\t\\t\\t\\tvar isCompressed = ( texture && texture.isCompressedTexture );\\n\\t\\t\\t\\t\\tvar isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );\\n\\n\\t\\t\\t\\t\\tvar cubeImage = [];\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( ! isCompressed && ! isDataTexture ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvar image = cubeImage[ 0 ],\\n\\t\\t\\t\\t\\t\\tisPowerOfTwoImage = isPowerOfTwo( image ),\\n\\t\\t\\t\\t\\t\\tglFormat = utils.convert( texture.format ),\\n\\t\\t\\t\\t\\t\\tglType = utils.convert( texture.type );\\n\\n\\t\\t\\t\\t\\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( ! isCompressed ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( isDataTexture ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tmipmap = mipmaps[ j ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) {\\n\\n\\t\\t\\t\\t\\t\\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ttextureProperties.__version = texture.version;\\n\\n\\t\\t\\t\\t\\tif ( texture.onUpdate ) texture.onUpdate( texture );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tstate.activeTexture( _gl.TEXTURE0 + slot );\\n\\t\\t\\t\\t\\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction setTextureCubeDynamic( texture, slot ) {\\n\\n\\t\\t\\tstate.activeTexture( _gl.TEXTURE0 + slot );\\n\\t\\t\\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\\n\\n\\t\\t}\\n\\n\\t\\tfunction setTextureParameters( textureType, texture, isPowerOfTwoImage ) {\\n\\n\\t\\t\\tvar extension;\\n\\n\\t\\t\\tif ( isPowerOfTwoImage ) {\\n\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, utils.convert( texture.wrapS ) );\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, utils.convert( texture.wrapT ) );\\n\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, utils.convert( texture.magFilter ) );\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, utils.convert( texture.minFilter ) );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\\n\\n\\t\\t\\t\\tif ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\\n\\n\\t\\t\\t\\tif ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\\n\\n\\t\\t\\tif ( extension ) {\\n\\n\\t\\t\\t\\tif ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\\n\\t\\t\\t\\tif ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\\n\\n\\t\\t\\t\\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\\n\\n\\t\\t\\t\\t\\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\\n\\t\\t\\t\\t\\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction uploadTexture( textureProperties, texture, slot ) {\\n\\n\\t\\t\\tif ( textureProperties.__webglInit === undefined ) {\\n\\n\\t\\t\\t\\ttextureProperties.__webglInit = true;\\n\\n\\t\\t\\t\\ttexture.addEventListener( 'dispose', onTextureDispose );\\n\\n\\t\\t\\t\\ttextureProperties.__webglTexture = _gl.createTexture();\\n\\n\\t\\t\\t\\tif ( texture.isVideoTexture ) {\\n\\n\\t\\t\\t\\t\\t_videoTextures[ texture.id ] = texture;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tinfoMemory.textures ++;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tstate.activeTexture( _gl.TEXTURE0 + slot );\\n\\t\\t\\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\\n\\n\\t\\t\\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\\n\\t\\t\\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\\n\\t\\t\\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\\n\\n\\t\\t\\tvar image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\\n\\n\\t\\t\\tif ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\\n\\n\\t\\t\\t\\timage = makePowerOfTwo( image );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar isPowerOfTwoImage = isPowerOfTwo( image ),\\n\\t\\t\\t\\tglFormat = utils.convert( texture.format ),\\n\\t\\t\\t\\tglType = utils.convert( texture.type );\\n\\n\\t\\t\\tsetTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\\n\\n\\t\\t\\tvar mipmap, mipmaps = texture.mipmaps;\\n\\n\\t\\t\\tif ( texture.isDepthTexture ) {\\n\\n\\t\\t\\t\\t// populate depth texture with dummy data\\n\\n\\t\\t\\t\\tvar internalFormat = _gl.DEPTH_COMPONENT;\\n\\n\\t\\t\\t\\tif ( texture.type === FloatType ) {\\n\\n\\t\\t\\t\\t\\tif ( ! _isWebGL2 ) throw new Error( 'Float Depth Texture only supported in WebGL2.0' );\\n\\t\\t\\t\\t\\tinternalFormat = _gl.DEPTH_COMPONENT32F;\\n\\n\\t\\t\\t\\t} else if ( _isWebGL2 ) {\\n\\n\\t\\t\\t\\t\\t// WebGL 2.0 requires signed internalformat for glTexImage2D\\n\\t\\t\\t\\t\\tinternalFormat = _gl.DEPTH_COMPONENT16;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( texture.format === DepthFormat && internalFormat === _gl.DEPTH_COMPONENT ) {\\n\\n\\t\\t\\t\\t\\t// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\\n\\t\\t\\t\\t\\t// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT\\n\\t\\t\\t\\t\\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\\n\\t\\t\\t\\t\\tif ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );\\n\\n\\t\\t\\t\\t\\t\\ttexture.type = UnsignedShortType;\\n\\t\\t\\t\\t\\t\\tglType = utils.convert( texture.type );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Depth stencil textures need the DEPTH_STENCIL internal format\\n\\t\\t\\t\\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\\n\\t\\t\\t\\tif ( texture.format === DepthStencilFormat ) {\\n\\n\\t\\t\\t\\t\\tinternalFormat = _gl.DEPTH_STENCIL;\\n\\n\\t\\t\\t\\t\\t// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\\n\\t\\t\\t\\t\\t// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.\\n\\t\\t\\t\\t\\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\\n\\t\\t\\t\\t\\tif ( texture.type !== UnsignedInt248Type ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );\\n\\n\\t\\t\\t\\t\\t\\ttexture.type = UnsignedInt248Type;\\n\\t\\t\\t\\t\\t\\tglType = utils.convert( texture.type );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );\\n\\n\\t\\t\\t} else if ( texture.isDataTexture ) {\\n\\n\\t\\t\\t\\t// use manually created mipmaps if available\\n\\t\\t\\t\\t// if there are no manual mipmaps\\n\\t\\t\\t\\t// set 0 level mipmap and then use GL to generate other mipmap levels\\n\\n\\t\\t\\t\\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tmipmap = mipmaps[ i ];\\n\\t\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ttexture.generateMipmaps = false;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( texture.isCompressedTexture ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\tmipmap = mipmaps[ i ];\\n\\n\\t\\t\\t\\t\\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// regular Texture (image, video, canvas)\\n\\n\\t\\t\\t\\t// use manually created mipmaps if available\\n\\t\\t\\t\\t// if there are no manual mipmaps\\n\\t\\t\\t\\t// set 0 level mipmap and then use GL to generate other mipmap levels\\n\\n\\t\\t\\t\\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tmipmap = mipmaps[ i ];\\n\\t\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ttexture.generateMipmaps = false;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) _gl.generateMipmap( _gl.TEXTURE_2D );\\n\\n\\t\\t\\ttextureProperties.__version = texture.version;\\n\\n\\t\\t\\tif ( texture.onUpdate ) texture.onUpdate( texture );\\n\\n\\t\\t}\\n\\n\\t\\t// Render targets\\n\\n\\t\\t// Setup storage for target texture and bind it to correct framebuffer\\n\\t\\tfunction setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {\\n\\n\\t\\t\\tvar glFormat = utils.convert( renderTarget.texture.format );\\n\\t\\t\\tvar glType = utils.convert( renderTarget.texture.type );\\n\\t\\t\\tstate.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\\n\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\\n\\t\\t\\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\\n\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\\n\\n\\t\\t}\\n\\n\\t\\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\\n\\t\\tfunction setupRenderBufferStorage( renderbuffer, renderTarget ) {\\n\\n\\t\\t\\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\\n\\n\\t\\t\\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\\n\\n\\t\\t\\t\\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\\n\\t\\t\\t\\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\\n\\n\\t\\t\\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\\n\\n\\t\\t\\t\\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\\n\\t\\t\\t\\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// FIXME: We don't support !depth !stencil\\n\\t\\t\\t\\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\\n\\n\\t\\t}\\n\\n\\t\\t// Setup resources for a Depth Texture for a FBO (needs an extension)\\n\\t\\tfunction setupDepthTexture( framebuffer, renderTarget ) {\\n\\n\\t\\t\\tvar isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );\\n\\t\\t\\tif ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );\\n\\n\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\\n\\n\\t\\t\\tif ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {\\n\\n\\t\\t\\t\\tthrow new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// upload an empty depth texture with framebuffer size\\n\\t\\t\\tif ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||\\n\\t\\t\\t\\t\\trenderTarget.depthTexture.image.width !== renderTarget.width ||\\n\\t\\t\\t\\t\\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\\n\\n\\t\\t\\t\\trenderTarget.depthTexture.image.width = renderTarget.width;\\n\\t\\t\\t\\trenderTarget.depthTexture.image.height = renderTarget.height;\\n\\t\\t\\t\\trenderTarget.depthTexture.needsUpdate = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tsetTexture2D( renderTarget.depthTexture, 0 );\\n\\n\\t\\t\\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\\n\\n\\t\\t\\tif ( renderTarget.depthTexture.format === DepthFormat ) {\\n\\n\\t\\t\\t\\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\\n\\n\\t\\t\\t} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {\\n\\n\\t\\t\\t\\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthrow new Error( 'Unknown depthTexture format' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// Setup GL resources for a non-texture depth buffer\\n\\t\\tfunction setupDepthRenderbuffer( renderTarget ) {\\n\\n\\t\\t\\tvar renderTargetProperties = properties.get( renderTarget );\\n\\n\\t\\t\\tvar isCube = ( renderTarget.isWebGLRenderTargetCube === true );\\n\\n\\t\\t\\tif ( renderTarget.depthTexture ) {\\n\\n\\t\\t\\t\\tif ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );\\n\\n\\t\\t\\t\\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tif ( isCube ) {\\n\\n\\t\\t\\t\\t\\trenderTargetProperties.__webglDepthbuffer = [];\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\\n\\t\\t\\t\\t\\t\\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\\n\\t\\t\\t\\t\\t\\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\\n\\t\\t\\t\\t\\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\\n\\t\\t\\t\\t\\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\\n\\n\\t\\t}\\n\\n\\t\\t// Set up GL resources for the render target\\n\\t\\tfunction setupRenderTarget( renderTarget ) {\\n\\n\\t\\t\\tvar renderTargetProperties = properties.get( renderTarget );\\n\\t\\t\\tvar textureProperties = properties.get( renderTarget.texture );\\n\\n\\t\\t\\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\\n\\n\\t\\t\\ttextureProperties.__webglTexture = _gl.createTexture();\\n\\n\\t\\t\\tinfoMemory.textures ++;\\n\\n\\t\\t\\tvar isCube = ( renderTarget.isWebGLRenderTargetCube === true );\\n\\t\\t\\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\\n\\n\\t\\t\\t// Setup framebuffer\\n\\n\\t\\t\\tif ( isCube ) {\\n\\n\\t\\t\\t\\trenderTargetProperties.__webglFramebuffer = [];\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\t\\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Setup color buffer\\n\\n\\t\\t\\tif ( isCube ) {\\n\\n\\t\\t\\t\\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\\n\\t\\t\\t\\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\t\\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\\n\\t\\t\\t\\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\\n\\t\\t\\t\\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\\n\\t\\t\\t\\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\\n\\n\\t\\t\\t\\tif ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) _gl.generateMipmap( _gl.TEXTURE_2D );\\n\\t\\t\\t\\tstate.bindTexture( _gl.TEXTURE_2D, null );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Setup depth and stencil buffers\\n\\n\\t\\t\\tif ( renderTarget.depthBuffer ) {\\n\\n\\t\\t\\t\\tsetupDepthRenderbuffer( renderTarget );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction updateRenderTargetMipmap( renderTarget ) {\\n\\n\\t\\t\\tvar texture = renderTarget.texture;\\n\\t\\t\\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\\n\\n\\t\\t\\tif ( textureNeedsGenerateMipmaps( texture, isTargetPowerOfTwo ) ) {\\n\\n\\t\\t\\t\\tvar target = renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\\n\\t\\t\\t\\tvar webglTexture = properties.get( texture ).__webglTexture;\\n\\n\\t\\t\\t\\tstate.bindTexture( target, webglTexture );\\n\\t\\t\\t\\t_gl.generateMipmap( target );\\n\\t\\t\\t\\tstate.bindTexture( target, null );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction updateVideoTextures() {\\n\\n\\t\\t\\tfor ( var id in _videoTextures ) {\\n\\n\\t\\t\\t\\t_videoTextures[ id ].update();\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tthis.setTexture2D = setTexture2D;\\n\\t\\tthis.setTextureCube = setTextureCube;\\n\\t\\tthis.setTextureCubeDynamic = setTextureCubeDynamic;\\n\\t\\tthis.setupRenderTarget = setupRenderTarget;\\n\\t\\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\\n\\t\\tthis.updateVideoTextures = updateVideoTextures;\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author fordacious / fordacious.github.io\\n\\t */\\n\\n\\tfunction WebGLProperties() {\\n\\n\\t\\tvar properties = {};\\n\\n\\t\\tfunction get( object ) {\\n\\n\\t\\t\\tvar uuid = object.uuid;\\n\\t\\t\\tvar map = properties[ uuid ];\\n\\n\\t\\t\\tif ( map === undefined ) {\\n\\n\\t\\t\\t\\tmap = {};\\n\\t\\t\\t\\tproperties[ uuid ] = map;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn map;\\n\\n\\t\\t}\\n\\n\\t\\tfunction remove( object ) {\\n\\n\\t\\t\\tdelete properties[ object.uuid ];\\n\\n\\t\\t}\\n\\n\\t\\tfunction clear() {\\n\\n\\t\\t\\tproperties = {};\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\tget: get,\\n\\t\\t\\tremove: remove,\\n\\t\\t\\tclear: clear\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLState( gl, extensions, utils ) {\\n\\n\\t\\tfunction ColorBuffer() {\\n\\n\\t\\t\\tvar locked = false;\\n\\n\\t\\t\\tvar color = new Vector4();\\n\\t\\t\\tvar currentColorMask = null;\\n\\t\\t\\tvar currentColorClear = new Vector4( 0, 0, 0, 0 );\\n\\n\\t\\t\\treturn {\\n\\n\\t\\t\\t\\tsetMask: function ( colorMask ) {\\n\\n\\t\\t\\t\\t\\tif ( currentColorMask !== colorMask && ! locked ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\\n\\t\\t\\t\\t\\t\\tcurrentColorMask = colorMask;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetLocked: function ( lock ) {\\n\\n\\t\\t\\t\\t\\tlocked = lock;\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetClear: function ( r, g, b, a, premultipliedAlpha ) {\\n\\n\\t\\t\\t\\t\\tif ( premultipliedAlpha === true ) {\\n\\n\\t\\t\\t\\t\\t\\tr *= a; g *= a; b *= a;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tcolor.set( r, g, b, a );\\n\\n\\t\\t\\t\\t\\tif ( currentColorClear.equals( color ) === false ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.clearColor( r, g, b, a );\\n\\t\\t\\t\\t\\t\\tcurrentColorClear.copy( color );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\treset: function () {\\n\\n\\t\\t\\t\\t\\tlocked = false;\\n\\n\\t\\t\\t\\t\\tcurrentColorMask = null;\\n\\t\\t\\t\\t\\tcurrentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}\\n\\n\\t\\tfunction DepthBuffer() {\\n\\n\\t\\t\\tvar locked = false;\\n\\n\\t\\t\\tvar currentDepthMask = null;\\n\\t\\t\\tvar currentDepthFunc = null;\\n\\t\\t\\tvar currentDepthClear = null;\\n\\n\\t\\t\\treturn {\\n\\n\\t\\t\\t\\tsetTest: function ( depthTest ) {\\n\\n\\t\\t\\t\\t\\tif ( depthTest ) {\\n\\n\\t\\t\\t\\t\\t\\tenable( gl.DEPTH_TEST );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tdisable( gl.DEPTH_TEST );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetMask: function ( depthMask ) {\\n\\n\\t\\t\\t\\t\\tif ( currentDepthMask !== depthMask && ! locked ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.depthMask( depthMask );\\n\\t\\t\\t\\t\\t\\tcurrentDepthMask = depthMask;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetFunc: function ( depthFunc ) {\\n\\n\\t\\t\\t\\t\\tif ( currentDepthFunc !== depthFunc ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( depthFunc ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tswitch ( depthFunc ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase NeverDepth:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.NEVER );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase AlwaysDepth:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.ALWAYS );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase LessDepth:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.LESS );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase LessEqualDepth:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.LEQUAL );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase EqualDepth:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.EQUAL );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase GreaterEqualDepth:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.GEQUAL );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase GreaterDepth:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.GREATER );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase NotEqualDepth:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.NOTEQUAL );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.LEQUAL );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.LEQUAL );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tcurrentDepthFunc = depthFunc;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetLocked: function ( lock ) {\\n\\n\\t\\t\\t\\t\\tlocked = lock;\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetClear: function ( depth ) {\\n\\n\\t\\t\\t\\t\\tif ( currentDepthClear !== depth ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.clearDepth( depth );\\n\\t\\t\\t\\t\\t\\tcurrentDepthClear = depth;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\treset: function () {\\n\\n\\t\\t\\t\\t\\tlocked = false;\\n\\n\\t\\t\\t\\t\\tcurrentDepthMask = null;\\n\\t\\t\\t\\t\\tcurrentDepthFunc = null;\\n\\t\\t\\t\\t\\tcurrentDepthClear = null;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}\\n\\n\\t\\tfunction StencilBuffer() {\\n\\n\\t\\t\\tvar locked = false;\\n\\n\\t\\t\\tvar currentStencilMask = null;\\n\\t\\t\\tvar currentStencilFunc = null;\\n\\t\\t\\tvar currentStencilRef = null;\\n\\t\\t\\tvar currentStencilFuncMask = null;\\n\\t\\t\\tvar currentStencilFail = null;\\n\\t\\t\\tvar currentStencilZFail = null;\\n\\t\\t\\tvar currentStencilZPass = null;\\n\\t\\t\\tvar currentStencilClear = null;\\n\\n\\t\\t\\treturn {\\n\\n\\t\\t\\t\\tsetTest: function ( stencilTest ) {\\n\\n\\t\\t\\t\\t\\tif ( stencilTest ) {\\n\\n\\t\\t\\t\\t\\t\\tenable( gl.STENCIL_TEST );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tdisable( gl.STENCIL_TEST );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetMask: function ( stencilMask ) {\\n\\n\\t\\t\\t\\t\\tif ( currentStencilMask !== stencilMask && ! locked ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.stencilMask( stencilMask );\\n\\t\\t\\t\\t\\t\\tcurrentStencilMask = stencilMask;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetFunc: function ( stencilFunc, stencilRef, stencilMask ) {\\n\\n\\t\\t\\t\\t\\tif ( currentStencilFunc !== stencilFunc ||\\n\\t\\t\\t\\t\\t     currentStencilRef \\t!== stencilRef \\t||\\n\\t\\t\\t\\t\\t     currentStencilFuncMask !== stencilMask ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.stencilFunc( stencilFunc, stencilRef, stencilMask );\\n\\n\\t\\t\\t\\t\\t\\tcurrentStencilFunc = stencilFunc;\\n\\t\\t\\t\\t\\t\\tcurrentStencilRef = stencilRef;\\n\\t\\t\\t\\t\\t\\tcurrentStencilFuncMask = stencilMask;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetOp: function ( stencilFail, stencilZFail, stencilZPass ) {\\n\\n\\t\\t\\t\\t\\tif ( currentStencilFail\\t !== stencilFail \\t||\\n\\t\\t\\t\\t\\t     currentStencilZFail !== stencilZFail ||\\n\\t\\t\\t\\t\\t     currentStencilZPass !== stencilZPass ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.stencilOp( stencilFail, stencilZFail, stencilZPass );\\n\\n\\t\\t\\t\\t\\t\\tcurrentStencilFail = stencilFail;\\n\\t\\t\\t\\t\\t\\tcurrentStencilZFail = stencilZFail;\\n\\t\\t\\t\\t\\t\\tcurrentStencilZPass = stencilZPass;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetLocked: function ( lock ) {\\n\\n\\t\\t\\t\\t\\tlocked = lock;\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetClear: function ( stencil ) {\\n\\n\\t\\t\\t\\t\\tif ( currentStencilClear !== stencil ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.clearStencil( stencil );\\n\\t\\t\\t\\t\\t\\tcurrentStencilClear = stencil;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\treset: function () {\\n\\n\\t\\t\\t\\t\\tlocked = false;\\n\\n\\t\\t\\t\\t\\tcurrentStencilMask = null;\\n\\t\\t\\t\\t\\tcurrentStencilFunc = null;\\n\\t\\t\\t\\t\\tcurrentStencilRef = null;\\n\\t\\t\\t\\t\\tcurrentStencilFuncMask = null;\\n\\t\\t\\t\\t\\tcurrentStencilFail = null;\\n\\t\\t\\t\\t\\tcurrentStencilZFail = null;\\n\\t\\t\\t\\t\\tcurrentStencilZPass = null;\\n\\t\\t\\t\\t\\tcurrentStencilClear = null;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tvar colorBuffer = new ColorBuffer();\\n\\t\\tvar depthBuffer = new DepthBuffer();\\n\\t\\tvar stencilBuffer = new StencilBuffer();\\n\\n\\t\\tvar maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\\n\\t\\tvar newAttributes = new Uint8Array( maxVertexAttributes );\\n\\t\\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\\n\\t\\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\\n\\n\\t\\tvar capabilities = {};\\n\\n\\t\\tvar compressedTextureFormats = null;\\n\\n\\t\\tvar currentProgram = null;\\n\\n\\t\\tvar currentBlending = null;\\n\\t\\tvar currentBlendEquation = null;\\n\\t\\tvar currentBlendSrc = null;\\n\\t\\tvar currentBlendDst = null;\\n\\t\\tvar currentBlendEquationAlpha = null;\\n\\t\\tvar currentBlendSrcAlpha = null;\\n\\t\\tvar currentBlendDstAlpha = null;\\n\\t\\tvar currentPremultipledAlpha = false;\\n\\n\\t\\tvar currentFlipSided = null;\\n\\t\\tvar currentCullFace = null;\\n\\n\\t\\tvar currentLineWidth = null;\\n\\n\\t\\tvar currentPolygonOffsetFactor = null;\\n\\t\\tvar currentPolygonOffsetUnits = null;\\n\\n\\t\\tvar maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );\\n\\n\\t\\tvar version = parseFloat( /^WebGL\\\\ ([0-9])/.exec( gl.getParameter( gl.VERSION ) )[ 1 ] );\\n\\t\\tvar lineWidthAvailable = parseFloat( version ) >= 1.0;\\n\\n\\t\\tvar currentTextureSlot = null;\\n\\t\\tvar currentBoundTextures = {};\\n\\n\\t\\tvar currentScissor = new Vector4();\\n\\t\\tvar currentViewport = new Vector4();\\n\\n\\t\\tfunction createTexture( type, target, count ) {\\n\\n\\t\\t\\tvar data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\\n\\t\\t\\tvar texture = gl.createTexture();\\n\\n\\t\\t\\tgl.bindTexture( type, texture );\\n\\t\\t\\tgl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\\n\\t\\t\\tgl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\\n\\n\\t\\t\\tfor ( var i = 0; i < count; i ++ ) {\\n\\n\\t\\t\\t\\tgl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn texture;\\n\\n\\t\\t}\\n\\n\\t\\tvar emptyTextures = {};\\n\\t\\temptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\\n\\t\\temptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\\n\\n\\t\\t// init\\n\\n\\t\\tcolorBuffer.setClear( 0, 0, 0, 1 );\\n\\t\\tdepthBuffer.setClear( 1 );\\n\\t\\tstencilBuffer.setClear( 0 );\\n\\n\\t\\tenable( gl.DEPTH_TEST );\\n\\t\\tdepthBuffer.setFunc( LessEqualDepth );\\n\\n\\t\\tsetFlipSided( false );\\n\\t\\tsetCullFace( CullFaceBack );\\n\\t\\tenable( gl.CULL_FACE );\\n\\n\\t\\tenable( gl.BLEND );\\n\\t\\tsetBlending( NormalBlending );\\n\\n\\t\\t//\\n\\n\\t\\tfunction initAttributes() {\\n\\n\\t\\t\\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tnewAttributes[ i ] = 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction enableAttribute( attribute ) {\\n\\n\\t\\t\\tnewAttributes[ attribute ] = 1;\\n\\n\\t\\t\\tif ( enabledAttributes[ attribute ] === 0 ) {\\n\\n\\t\\t\\t\\tgl.enableVertexAttribArray( attribute );\\n\\t\\t\\t\\tenabledAttributes[ attribute ] = 1;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( attributeDivisors[ attribute ] !== 0 ) {\\n\\n\\t\\t\\t\\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\\n\\n\\t\\t\\t\\textension.vertexAttribDivisorANGLE( attribute, 0 );\\n\\t\\t\\t\\tattributeDivisors[ attribute ] = 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction enableAttributeAndDivisor( attribute, meshPerAttribute ) {\\n\\n\\t\\t\\tnewAttributes[ attribute ] = 1;\\n\\n\\t\\t\\tif ( enabledAttributes[ attribute ] === 0 ) {\\n\\n\\t\\t\\t\\tgl.enableVertexAttribArray( attribute );\\n\\t\\t\\t\\tenabledAttributes[ attribute ] = 1;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\\n\\n\\t\\t\\t\\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\\n\\n\\t\\t\\t\\textension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\\n\\t\\t\\t\\tattributeDivisors[ attribute ] = meshPerAttribute;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction disableUnusedAttributes() {\\n\\n\\t\\t\\tfor ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {\\n\\n\\t\\t\\t\\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\\n\\n\\t\\t\\t\\t\\tgl.disableVertexAttribArray( i );\\n\\t\\t\\t\\t\\tenabledAttributes[ i ] = 0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction enable( id ) {\\n\\n\\t\\t\\tif ( capabilities[ id ] !== true ) {\\n\\n\\t\\t\\t\\tgl.enable( id );\\n\\t\\t\\t\\tcapabilities[ id ] = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction disable( id ) {\\n\\n\\t\\t\\tif ( capabilities[ id ] !== false ) {\\n\\n\\t\\t\\t\\tgl.disable( id );\\n\\t\\t\\t\\tcapabilities[ id ] = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction getCompressedTextureFormats() {\\n\\n\\t\\t\\tif ( compressedTextureFormats === null ) {\\n\\n\\t\\t\\t\\tcompressedTextureFormats = [];\\n\\n\\t\\t\\t\\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\\n\\t\\t\\t\\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\\n\\t\\t\\t\\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {\\n\\n\\t\\t\\t\\t\\tvar formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < formats.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tcompressedTextureFormats.push( formats[ i ] );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn compressedTextureFormats;\\n\\n\\t\\t}\\n\\n\\t\\tfunction useProgram( program ) {\\n\\n\\t\\t\\tif ( currentProgram !== program ) {\\n\\n\\t\\t\\t\\tgl.useProgram( program );\\n\\n\\t\\t\\t\\tcurrentProgram = program;\\n\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn false;\\n\\n\\t\\t}\\n\\n\\t\\tfunction setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\\n\\n\\t\\t\\tif ( blending !== NoBlending ) {\\n\\n\\t\\t\\t\\tenable( gl.BLEND );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tdisable( gl.BLEND );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( blending !== CustomBlending ) {\\n\\n\\t\\t\\t\\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\\n\\n\\t\\t\\t\\t\\tswitch ( blending ) {\\n\\n\\t\\t\\t\\t\\t\\tcase AdditiveBlending:\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( premultipliedAlpha ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquation( gl.FUNC_ADD );\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase SubtractiveBlending:\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( premultipliedAlpha ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquation( gl.FUNC_ADD );\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase MultiplyBlending:\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( premultipliedAlpha ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquation( gl.FUNC_ADD );\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( premultipliedAlpha ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcurrentBlendEquation = null;\\n\\t\\t\\t\\tcurrentBlendSrc = null;\\n\\t\\t\\t\\tcurrentBlendDst = null;\\n\\t\\t\\t\\tcurrentBlendEquationAlpha = null;\\n\\t\\t\\t\\tcurrentBlendSrcAlpha = null;\\n\\t\\t\\t\\tcurrentBlendDstAlpha = null;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tblendEquationAlpha = blendEquationAlpha || blendEquation;\\n\\t\\t\\t\\tblendSrcAlpha = blendSrcAlpha || blendSrc;\\n\\t\\t\\t\\tblendDstAlpha = blendDstAlpha || blendDst;\\n\\n\\t\\t\\t\\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\\n\\n\\t\\t\\t\\t\\tgl.blendEquationSeparate( utils.convert( blendEquation ), utils.convert( blendEquationAlpha ) );\\n\\n\\t\\t\\t\\t\\tcurrentBlendEquation = blendEquation;\\n\\t\\t\\t\\t\\tcurrentBlendEquationAlpha = blendEquationAlpha;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\\n\\n\\t\\t\\t\\t\\tgl.blendFuncSeparate( utils.convert( blendSrc ), utils.convert( blendDst ), utils.convert( blendSrcAlpha ), utils.convert( blendDstAlpha ) );\\n\\n\\t\\t\\t\\t\\tcurrentBlendSrc = blendSrc;\\n\\t\\t\\t\\t\\tcurrentBlendDst = blendDst;\\n\\t\\t\\t\\t\\tcurrentBlendSrcAlpha = blendSrcAlpha;\\n\\t\\t\\t\\t\\tcurrentBlendDstAlpha = blendDstAlpha;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tcurrentBlending = blending;\\n\\t\\t\\tcurrentPremultipledAlpha = premultipliedAlpha;\\n\\n\\t\\t}\\n\\n\\t\\tfunction setMaterial( material, frontFaceCW ) {\\n\\n\\t\\t\\tmaterial.side === DoubleSide\\n\\t\\t\\t\\t? disable( gl.CULL_FACE )\\n\\t\\t\\t\\t: enable( gl.CULL_FACE );\\n\\n\\t\\t\\tvar flipSided = ( material.side === BackSide );\\n\\t\\t\\tif ( frontFaceCW ) flipSided = ! flipSided;\\n\\n\\t\\t\\tsetFlipSided( flipSided );\\n\\n\\t\\t\\tmaterial.transparent === true\\n\\t\\t\\t\\t? setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )\\n\\t\\t\\t\\t: setBlending( NoBlending );\\n\\n\\t\\t\\tdepthBuffer.setFunc( material.depthFunc );\\n\\t\\t\\tdepthBuffer.setTest( material.depthTest );\\n\\t\\t\\tdepthBuffer.setMask( material.depthWrite );\\n\\t\\t\\tcolorBuffer.setMask( material.colorWrite );\\n\\n\\t\\t\\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tfunction setFlipSided( flipSided ) {\\n\\n\\t\\t\\tif ( currentFlipSided !== flipSided ) {\\n\\n\\t\\t\\t\\tif ( flipSided ) {\\n\\n\\t\\t\\t\\t\\tgl.frontFace( gl.CW );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tgl.frontFace( gl.CCW );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcurrentFlipSided = flipSided;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction setCullFace( cullFace ) {\\n\\n\\t\\t\\tif ( cullFace !== CullFaceNone ) {\\n\\n\\t\\t\\t\\tenable( gl.CULL_FACE );\\n\\n\\t\\t\\t\\tif ( cullFace !== currentCullFace ) {\\n\\n\\t\\t\\t\\t\\tif ( cullFace === CullFaceBack ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.cullFace( gl.BACK );\\n\\n\\t\\t\\t\\t\\t} else if ( cullFace === CullFaceFront ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.cullFace( gl.FRONT );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tgl.cullFace( gl.FRONT_AND_BACK );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tdisable( gl.CULL_FACE );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tcurrentCullFace = cullFace;\\n\\n\\t\\t}\\n\\n\\t\\tfunction setLineWidth( width ) {\\n\\n\\t\\t\\tif ( width !== currentLineWidth ) {\\n\\n\\t\\t\\t\\tif ( lineWidthAvailable ) gl.lineWidth( width );\\n\\n\\t\\t\\t\\tcurrentLineWidth = width;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction setPolygonOffset( polygonOffset, factor, units ) {\\n\\n\\t\\t\\tif ( polygonOffset ) {\\n\\n\\t\\t\\t\\tenable( gl.POLYGON_OFFSET_FILL );\\n\\n\\t\\t\\t\\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\\n\\n\\t\\t\\t\\t\\tgl.polygonOffset( factor, units );\\n\\n\\t\\t\\t\\t\\tcurrentPolygonOffsetFactor = factor;\\n\\t\\t\\t\\t\\tcurrentPolygonOffsetUnits = units;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tdisable( gl.POLYGON_OFFSET_FILL );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction setScissorTest( scissorTest ) {\\n\\n\\t\\t\\tif ( scissorTest ) {\\n\\n\\t\\t\\t\\tenable( gl.SCISSOR_TEST );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tdisable( gl.SCISSOR_TEST );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// texture\\n\\n\\t\\tfunction activeTexture( webglSlot ) {\\n\\n\\t\\t\\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\\n\\n\\t\\t\\tif ( currentTextureSlot !== webglSlot ) {\\n\\n\\t\\t\\t\\tgl.activeTexture( webglSlot );\\n\\t\\t\\t\\tcurrentTextureSlot = webglSlot;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction bindTexture( webglType, webglTexture ) {\\n\\n\\t\\t\\tif ( currentTextureSlot === null ) {\\n\\n\\t\\t\\t\\tactiveTexture();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\\n\\n\\t\\t\\tif ( boundTexture === undefined ) {\\n\\n\\t\\t\\t\\tboundTexture = { type: undefined, texture: undefined };\\n\\t\\t\\t\\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\\n\\n\\t\\t\\t\\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\\n\\n\\t\\t\\t\\tboundTexture.type = webglType;\\n\\t\\t\\t\\tboundTexture.texture = webglTexture;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction compressedTexImage2D() {\\n\\n\\t\\t\\ttry {\\n\\n\\t\\t\\t\\tgl.compressedTexImage2D.apply( gl, arguments );\\n\\n\\t\\t\\t} catch ( error ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLState:', error );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction texImage2D() {\\n\\n\\t\\t\\ttry {\\n\\n\\t\\t\\t\\tgl.texImage2D.apply( gl, arguments );\\n\\n\\t\\t\\t} catch ( error ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLState:', error );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tfunction scissor( scissor ) {\\n\\n\\t\\t\\tif ( currentScissor.equals( scissor ) === false ) {\\n\\n\\t\\t\\t\\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\\n\\t\\t\\t\\tcurrentScissor.copy( scissor );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction viewport( viewport ) {\\n\\n\\t\\t\\tif ( currentViewport.equals( viewport ) === false ) {\\n\\n\\t\\t\\t\\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\\n\\t\\t\\t\\tcurrentViewport.copy( viewport );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tfunction reset() {\\n\\n\\t\\t\\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\\n\\n\\t\\t\\t\\tif ( enabledAttributes[ i ] === 1 ) {\\n\\n\\t\\t\\t\\t\\tgl.disableVertexAttribArray( i );\\n\\t\\t\\t\\t\\tenabledAttributes[ i ] = 0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tcapabilities = {};\\n\\n\\t\\t\\tcompressedTextureFormats = null;\\n\\n\\t\\t\\tcurrentTextureSlot = null;\\n\\t\\t\\tcurrentBoundTextures = {};\\n\\n\\t\\t\\tcurrentProgram = null;\\n\\n\\t\\t\\tcurrentBlending = null;\\n\\n\\t\\t\\tcurrentFlipSided = null;\\n\\t\\t\\tcurrentCullFace = null;\\n\\n\\t\\t\\tcolorBuffer.reset();\\n\\t\\t\\tdepthBuffer.reset();\\n\\t\\t\\tstencilBuffer.reset();\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tbuffers: {\\n\\t\\t\\t\\tcolor: colorBuffer,\\n\\t\\t\\t\\tdepth: depthBuffer,\\n\\t\\t\\t\\tstencil: stencilBuffer\\n\\t\\t\\t},\\n\\n\\t\\t\\tinitAttributes: initAttributes,\\n\\t\\t\\tenableAttribute: enableAttribute,\\n\\t\\t\\tenableAttributeAndDivisor: enableAttributeAndDivisor,\\n\\t\\t\\tdisableUnusedAttributes: disableUnusedAttributes,\\n\\t\\t\\tenable: enable,\\n\\t\\t\\tdisable: disable,\\n\\t\\t\\tgetCompressedTextureFormats: getCompressedTextureFormats,\\n\\n\\t\\t\\tuseProgram: useProgram,\\n\\n\\t\\t\\tsetBlending: setBlending,\\n\\t\\t\\tsetMaterial: setMaterial,\\n\\n\\t\\t\\tsetFlipSided: setFlipSided,\\n\\t\\t\\tsetCullFace: setCullFace,\\n\\n\\t\\t\\tsetLineWidth: setLineWidth,\\n\\t\\t\\tsetPolygonOffset: setPolygonOffset,\\n\\n\\t\\t\\tsetScissorTest: setScissorTest,\\n\\n\\t\\t\\tactiveTexture: activeTexture,\\n\\t\\t\\tbindTexture: bindTexture,\\n\\t\\t\\tcompressedTexImage2D: compressedTexImage2D,\\n\\t\\t\\ttexImage2D: texImage2D,\\n\\n\\t\\t\\tscissor: scissor,\\n\\t\\t\\tviewport: viewport,\\n\\n\\t\\t\\treset: reset\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLCapabilities( gl, extensions, parameters ) {\\n\\n\\t\\tvar maxAnisotropy;\\n\\n\\t\\tfunction getMaxAnisotropy() {\\n\\n\\t\\t\\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\\n\\n\\t\\t\\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\\n\\n\\t\\t\\tif ( extension !== null ) {\\n\\n\\t\\t\\t\\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tmaxAnisotropy = 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn maxAnisotropy;\\n\\n\\t\\t}\\n\\n\\t\\tfunction getMaxPrecision( precision ) {\\n\\n\\t\\t\\tif ( precision === 'highp' ) {\\n\\n\\t\\t\\t\\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\\n\\t\\t\\t\\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\\n\\n\\t\\t\\t\\t\\treturn 'highp';\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tprecision = 'mediump';\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( precision === 'mediump' ) {\\n\\n\\t\\t\\t\\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\\n\\t\\t\\t\\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\\n\\n\\t\\t\\t\\t\\treturn 'mediump';\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn 'lowp';\\n\\n\\t\\t}\\n\\n\\t\\tvar precision = parameters.precision !== undefined ? parameters.precision : 'highp';\\n\\t\\tvar maxPrecision = getMaxPrecision( precision );\\n\\n\\t\\tif ( maxPrecision !== precision ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );\\n\\t\\t\\tprecision = maxPrecision;\\n\\n\\t\\t}\\n\\n\\t\\tvar logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;\\n\\n\\t\\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\\n\\t\\tvar maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\\n\\t\\tvar maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\\n\\t\\tvar maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\\n\\n\\t\\tvar maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\\n\\t\\tvar maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\\n\\t\\tvar maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\\n\\t\\tvar maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\\n\\n\\t\\tvar vertexTextures = maxVertexTextures > 0;\\n\\t\\tvar floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\\n\\t\\tvar floatVertexTextures = vertexTextures && floatFragmentTextures;\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tgetMaxAnisotropy: getMaxAnisotropy,\\n\\t\\t\\tgetMaxPrecision: getMaxPrecision,\\n\\n\\t\\t\\tprecision: precision,\\n\\t\\t\\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\\n\\n\\t\\t\\tmaxTextures: maxTextures,\\n\\t\\t\\tmaxVertexTextures: maxVertexTextures,\\n\\t\\t\\tmaxTextureSize: maxTextureSize,\\n\\t\\t\\tmaxCubemapSize: maxCubemapSize,\\n\\n\\t\\t\\tmaxAttributes: maxAttributes,\\n\\t\\t\\tmaxVertexUniforms: maxVertexUniforms,\\n\\t\\t\\tmaxVaryings: maxVaryings,\\n\\t\\t\\tmaxFragmentUniforms: maxFragmentUniforms,\\n\\n\\t\\t\\tvertexTextures: vertexTextures,\\n\\t\\t\\tfloatFragmentTextures: floatFragmentTextures,\\n\\t\\t\\tfloatVertexTextures: floatVertexTextures\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author greggman / http://games.greggman.com/\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction PerspectiveCamera( fov, aspect, near, far ) {\\n\\n\\t\\tCamera.call( this );\\n\\n\\t\\tthis.type = 'PerspectiveCamera';\\n\\n\\t\\tthis.fov = fov !== undefined ? fov : 50;\\n\\t\\tthis.zoom = 1;\\n\\n\\t\\tthis.near = near !== undefined ? near : 0.1;\\n\\t\\tthis.far = far !== undefined ? far : 2000;\\n\\t\\tthis.focus = 10;\\n\\n\\t\\tthis.aspect = aspect !== undefined ? aspect : 1;\\n\\t\\tthis.view = null;\\n\\n\\t\\tthis.filmGauge = 35;\\t// width of the film (default in millimeters)\\n\\t\\tthis.filmOffset = 0;\\t// horizontal film offset (same unit as gauge)\\n\\n\\t\\tthis.updateProjectionMatrix();\\n\\n\\t}\\n\\n\\tPerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\\n\\n\\t\\tconstructor: PerspectiveCamera,\\n\\n\\t\\tisPerspectiveCamera: true,\\n\\n\\t\\tcopy: function ( source, recursive ) {\\n\\n\\t\\t\\tCamera.prototype.copy.call( this, source, recursive );\\n\\n\\t\\t\\tthis.fov = source.fov;\\n\\t\\t\\tthis.zoom = source.zoom;\\n\\n\\t\\t\\tthis.near = source.near;\\n\\t\\t\\tthis.far = source.far;\\n\\t\\t\\tthis.focus = source.focus;\\n\\n\\t\\t\\tthis.aspect = source.aspect;\\n\\t\\t\\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\\n\\n\\t\\t\\tthis.filmGauge = source.filmGauge;\\n\\t\\t\\tthis.filmOffset = source.filmOffset;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Sets the FOV by focal length in respect to the current .filmGauge.\\n\\t\\t *\\n\\t\\t * The default film gauge is 35, so that the focal length can be specified for\\n\\t\\t * a 35mm (full frame) camera.\\n\\t\\t *\\n\\t\\t * Values for focal length and film gauge must have the same unit.\\n\\t\\t */\\n\\t\\tsetFocalLength: function ( focalLength ) {\\n\\n\\t\\t\\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\\n\\t\\t\\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\\n\\n\\t\\t\\tthis.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\\n\\t\\t\\tthis.updateProjectionMatrix();\\n\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Calculates the focal length from the current .fov and .filmGauge.\\n\\t\\t */\\n\\t\\tgetFocalLength: function () {\\n\\n\\t\\t\\tvar vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );\\n\\n\\t\\t\\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\\n\\n\\t\\t},\\n\\n\\t\\tgetEffectiveFOV: function () {\\n\\n\\t\\t\\treturn _Math.RAD2DEG * 2 * Math.atan(\\n\\t\\t\\t\\tMath.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\\n\\n\\t\\t},\\n\\n\\t\\tgetFilmWidth: function () {\\n\\n\\t\\t\\t// film not completely covered in portrait format (aspect < 1)\\n\\t\\t\\treturn this.filmGauge * Math.min( this.aspect, 1 );\\n\\n\\t\\t},\\n\\n\\t\\tgetFilmHeight: function () {\\n\\n\\t\\t\\t// film not completely covered in landscape format (aspect > 1)\\n\\t\\t\\treturn this.filmGauge / Math.max( this.aspect, 1 );\\n\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Sets an offset in a larger frustum. This is useful for multi-window or\\n\\t\\t * multi-monitor/multi-machine setups.\\n\\t\\t *\\n\\t\\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\\n\\t\\t * the monitors are in grid like this\\n\\t\\t *\\n\\t\\t *   +---+---+---+\\n\\t\\t *   | A | B | C |\\n\\t\\t *   +---+---+---+\\n\\t\\t *   | D | E | F |\\n\\t\\t *   +---+---+---+\\n\\t\\t *\\n\\t\\t * then for each monitor you would call it like this\\n\\t\\t *\\n\\t\\t *   var w = 1920;\\n\\t\\t *   var h = 1080;\\n\\t\\t *   var fullWidth = w * 3;\\n\\t\\t *   var fullHeight = h * 2;\\n\\t\\t *\\n\\t\\t *   --A--\\n\\t\\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\\n\\t\\t *   --B--\\n\\t\\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\\n\\t\\t *   --C--\\n\\t\\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\\n\\t\\t *   --D--\\n\\t\\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\\n\\t\\t *   --E--\\n\\t\\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\\n\\t\\t *   --F--\\n\\t\\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\\n\\t\\t *\\n\\t\\t *   Note there is no reason monitors have to be the same size or in a grid.\\n\\t\\t */\\n\\t\\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\\n\\n\\t\\t\\tthis.aspect = fullWidth / fullHeight;\\n\\n\\t\\t\\tif ( this.view === null ) {\\n\\n\\t\\t\\t\\tthis.view = {\\n\\t\\t\\t\\t\\tenabled: true,\\n\\t\\t\\t\\t\\tfullWidth: 1,\\n\\t\\t\\t\\t\\tfullHeight: 1,\\n\\t\\t\\t\\t\\toffsetX: 0,\\n\\t\\t\\t\\t\\toffsetY: 0,\\n\\t\\t\\t\\t\\twidth: 1,\\n\\t\\t\\t\\t\\theight: 1\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.view.enabled = true;\\n\\t\\t\\tthis.view.fullWidth = fullWidth;\\n\\t\\t\\tthis.view.fullHeight = fullHeight;\\n\\t\\t\\tthis.view.offsetX = x;\\n\\t\\t\\tthis.view.offsetY = y;\\n\\t\\t\\tthis.view.width = width;\\n\\t\\t\\tthis.view.height = height;\\n\\n\\t\\t\\tthis.updateProjectionMatrix();\\n\\n\\t\\t},\\n\\n\\t\\tclearViewOffset: function () {\\n\\n\\t\\t\\tif ( this.view !== null ) {\\n\\n\\t\\t\\t\\tthis.view.enabled = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.updateProjectionMatrix();\\n\\n\\t\\t},\\n\\n\\t\\tupdateProjectionMatrix: function () {\\n\\n\\t\\t\\tvar near = this.near,\\n\\t\\t\\t\\ttop = near * Math.tan(\\n\\t\\t\\t\\t\\t_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\\n\\t\\t\\t\\theight = 2 * top,\\n\\t\\t\\t\\twidth = this.aspect * height,\\n\\t\\t\\t\\tleft = - 0.5 * width,\\n\\t\\t\\t\\tview = this.view;\\n\\n\\t\\t\\tif ( this.view !== null && this.view.enabled ) {\\n\\n\\t\\t\\t\\tvar fullWidth = view.fullWidth,\\n\\t\\t\\t\\t\\tfullHeight = view.fullHeight;\\n\\n\\t\\t\\t\\tleft += view.offsetX * width / fullWidth;\\n\\t\\t\\t\\ttop -= view.offsetY * height / fullHeight;\\n\\t\\t\\t\\twidth *= view.width / fullWidth;\\n\\t\\t\\t\\theight *= view.height / fullHeight;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar skew = this.filmOffset;\\n\\t\\t\\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\\n\\n\\t\\t\\tthis.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( meta ) {\\n\\n\\t\\t\\tvar data = Object3D.prototype.toJSON.call( this, meta );\\n\\n\\t\\t\\tdata.object.fov = this.fov;\\n\\t\\t\\tdata.object.zoom = this.zoom;\\n\\n\\t\\t\\tdata.object.near = this.near;\\n\\t\\t\\tdata.object.far = this.far;\\n\\t\\t\\tdata.object.focus = this.focus;\\n\\n\\t\\t\\tdata.object.aspect = this.aspect;\\n\\n\\t\\t\\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\\n\\n\\t\\t\\tdata.object.filmGauge = this.filmGauge;\\n\\t\\t\\tdata.object.filmOffset = this.filmOffset;\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction ArrayCamera( array ) {\\n\\n\\t\\tPerspectiveCamera.call( this );\\n\\n\\t\\tthis.cameras = array || [];\\n\\n\\t}\\n\\n\\tArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {\\n\\n\\t\\tconstructor: ArrayCamera,\\n\\n\\t\\tisArrayCamera: true\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebVRManager( renderer ) {\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\tvar device = null;\\n\\t\\tvar frameData = null;\\n\\n\\t\\tvar poseTarget = null;\\n\\n\\t\\tif ( typeof window !== 'undefined' && 'VRFrameData' in window ) {\\n\\n\\t\\t\\tframeData = new window.VRFrameData();\\n\\n\\t\\t}\\n\\n\\t\\tvar matrixWorldInverse = new Matrix4();\\n\\n\\t\\tvar cameraL = new PerspectiveCamera();\\n\\t\\tcameraL.bounds = new Vector4( 0.0, 0.0, 0.5, 1.0 );\\n\\t\\tcameraL.layers.enable( 1 );\\n\\n\\t\\tvar cameraR = new PerspectiveCamera();\\n\\t\\tcameraR.bounds = new Vector4( 0.5, 0.0, 0.5, 1.0 );\\n\\t\\tcameraR.layers.enable( 2 );\\n\\n\\t\\tvar cameraVR = new ArrayCamera( [ cameraL, cameraR ] );\\n\\t\\tcameraVR.layers.enable( 1 );\\n\\t\\tcameraVR.layers.enable( 2 );\\n\\n\\t\\t//\\n\\n\\t\\tvar currentSize, currentPixelRatio;\\n\\n\\t\\tfunction onVRDisplayPresentChange() {\\n\\n\\t\\t\\tif ( device !== null && device.isPresenting ) {\\n\\n\\t\\t\\t\\tvar eyeParameters = device.getEyeParameters( 'left' );\\n\\t\\t\\t\\tvar renderWidth = eyeParameters.renderWidth;\\n\\t\\t\\t\\tvar renderHeight = eyeParameters.renderHeight;\\n\\n\\t\\t\\t\\tcurrentPixelRatio = renderer.getPixelRatio();\\n\\t\\t\\t\\tcurrentSize = renderer.getSize();\\n\\n\\t\\t\\t\\trenderer.setDrawingBufferSize( renderWidth * 2, renderHeight, 1 );\\n\\n\\t\\t\\t} else if ( scope.enabled ) {\\n\\n\\t\\t\\t\\trenderer.setDrawingBufferSize( currentSize.width, currentSize.height, currentPixelRatio );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tif ( typeof window !== 'undefined' ) {\\n\\n\\t\\t\\twindow.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tthis.enabled = false;\\n\\n\\t\\tthis.getDevice = function () {\\n\\n\\t\\t\\treturn device;\\n\\n\\t\\t};\\n\\n\\t\\tthis.setDevice = function ( value ) {\\n\\n\\t\\t\\tif ( value !== undefined ) device = value;\\n\\n\\t\\t};\\n\\n\\t\\tthis.setPoseTarget = function ( object ) {\\n\\n\\t\\t\\tif ( object !== undefined ) poseTarget = object;\\n\\n\\t\\t};\\n\\n\\t\\tthis.getCamera = function ( camera ) {\\n\\n\\t\\t\\tif ( device === null ) return camera;\\n\\n\\t\\t\\tdevice.depthNear = camera.near;\\n\\t\\t\\tdevice.depthFar = camera.far;\\n\\n\\t\\t\\tdevice.getFrameData( frameData );\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar pose = frameData.pose;\\n\\t\\t\\tvar poseObject = poseTarget !== null ? poseTarget : camera;\\n\\n\\t\\t\\tif ( pose.position !== null ) {\\n\\n\\t\\t\\t\\tposeObject.position.fromArray( pose.position );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tposeObject.position.set( 0, 0, 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( pose.orientation !== null ) {\\n\\n\\t\\t\\t\\tposeObject.quaternion.fromArray( pose.orientation );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tposeObject.updateMatrixWorld();\\n\\n\\t\\t\\tif ( device.isPresenting === false ) return camera;\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tcameraL.near = camera.near;\\n\\t\\t\\tcameraR.near = camera.near;\\n\\n\\t\\t\\tcameraL.far = camera.far;\\n\\t\\t\\tcameraR.far = camera.far;\\n\\n\\t\\t\\tcameraVR.matrixWorld.copy( camera.matrixWorld );\\n\\t\\t\\tcameraVR.matrixWorldInverse.copy( camera.matrixWorldInverse );\\n\\n\\t\\t\\tcameraL.matrixWorldInverse.fromArray( frameData.leftViewMatrix );\\n\\t\\t\\tcameraR.matrixWorldInverse.fromArray( frameData.rightViewMatrix );\\n\\n\\t\\t\\tvar parent = poseObject.parent;\\n\\n\\t\\t\\tif ( parent !== null ) {\\n\\n\\t\\t\\t\\tmatrixWorldInverse.getInverse( parent.matrixWorld );\\n\\n\\t\\t\\t\\tcameraL.matrixWorldInverse.multiply( matrixWorldInverse );\\n\\t\\t\\t\\tcameraR.matrixWorldInverse.multiply( matrixWorldInverse );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// envMap and Mirror needs camera.matrixWorld\\n\\n\\t\\t\\tcameraL.matrixWorld.getInverse( cameraL.matrixWorldInverse );\\n\\t\\t\\tcameraR.matrixWorld.getInverse( cameraR.matrixWorldInverse );\\n\\n\\t\\t\\tcameraL.projectionMatrix.fromArray( frameData.leftProjectionMatrix );\\n\\t\\t\\tcameraR.projectionMatrix.fromArray( frameData.rightProjectionMatrix );\\n\\n\\t\\t\\t// HACK @mrdoob\\n\\t\\t\\t// https://github.com/w3c/webvr/issues/203\\n\\n\\t\\t\\tcameraVR.projectionMatrix.copy( cameraL.projectionMatrix );\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar layers = device.getLayers();\\n\\n\\t\\t\\tif ( layers.length ) {\\n\\n\\t\\t\\t\\tvar layer = layers[ 0 ];\\n\\n\\t\\t\\t\\tif ( layer.leftBounds !== null && layer.leftBounds.length === 4 ) {\\n\\n\\t\\t\\t\\t\\tcameraL.bounds.fromArray( layer.leftBounds );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( layer.rightBounds !== null && layer.rightBounds.length === 4 ) {\\n\\n\\t\\t\\t\\t\\tcameraR.bounds.fromArray( layer.rightBounds );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn cameraVR;\\n\\n\\t\\t};\\n\\n\\t\\tthis.submitFrame = function () {\\n\\n\\t\\t\\tif ( device && device.isPresenting ) device.submitFrame();\\n\\n\\t\\t};\\n\\n\\t\\tthis.dispose = function () {\\n\\n\\t\\t\\tif ( typeof window !== 'undefined' ) {\\n\\n\\t\\t\\t\\twindow.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLExtensions( gl ) {\\n\\n\\t\\tvar extensions = {};\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tget: function ( name ) {\\n\\n\\t\\t\\t\\tif ( extensions[ name ] !== undefined ) {\\n\\n\\t\\t\\t\\t\\treturn extensions[ name ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar extension;\\n\\n\\t\\t\\t\\tswitch ( name ) {\\n\\n\\t\\t\\t\\t\\tcase 'WEBGL_depth_texture':\\n\\t\\t\\t\\t\\t\\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'EXT_texture_filter_anisotropic':\\n\\t\\t\\t\\t\\t\\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'WEBGL_compressed_texture_s3tc':\\n\\t\\t\\t\\t\\t\\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'WEBGL_compressed_texture_pvrtc':\\n\\t\\t\\t\\t\\t\\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'WEBGL_compressed_texture_etc1':\\n\\t\\t\\t\\t\\t\\textension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\textension = gl.getExtension( name );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( extension === null ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\textensions[ name ] = extension;\\n\\n\\t\\t\\t\\treturn extension;\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction WebGLClipping() {\\n\\n\\t\\tvar scope = this,\\n\\n\\t\\t\\tglobalState = null,\\n\\t\\t\\tnumGlobalPlanes = 0,\\n\\t\\t\\tlocalClippingEnabled = false,\\n\\t\\t\\trenderingShadows = false,\\n\\n\\t\\t\\tplane = new Plane(),\\n\\t\\t\\tviewNormalMatrix = new Matrix3(),\\n\\n\\t\\t\\tuniform = { value: null, needsUpdate: false };\\n\\n\\t\\tthis.uniform = uniform;\\n\\t\\tthis.numPlanes = 0;\\n\\t\\tthis.numIntersection = 0;\\n\\n\\t\\tthis.init = function ( planes, enableLocalClipping, camera ) {\\n\\n\\t\\t\\tvar enabled =\\n\\t\\t\\t\\tplanes.length !== 0 ||\\n\\t\\t\\t\\tenableLocalClipping ||\\n\\t\\t\\t\\t// enable state of previous frame - the clipping code has to\\n\\t\\t\\t\\t// run another frame in order to reset the state:\\n\\t\\t\\t\\tnumGlobalPlanes !== 0 ||\\n\\t\\t\\t\\tlocalClippingEnabled;\\n\\n\\t\\t\\tlocalClippingEnabled = enableLocalClipping;\\n\\n\\t\\t\\tglobalState = projectPlanes( planes, camera, 0 );\\n\\t\\t\\tnumGlobalPlanes = planes.length;\\n\\n\\t\\t\\treturn enabled;\\n\\n\\t\\t};\\n\\n\\t\\tthis.beginShadows = function () {\\n\\n\\t\\t\\trenderingShadows = true;\\n\\t\\t\\tprojectPlanes( null );\\n\\n\\t\\t};\\n\\n\\t\\tthis.endShadows = function () {\\n\\n\\t\\t\\trenderingShadows = false;\\n\\t\\t\\tresetGlobalState();\\n\\n\\t\\t};\\n\\n\\t\\tthis.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {\\n\\n\\t\\t\\tif ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {\\n\\n\\t\\t\\t\\t// there's no local clipping\\n\\n\\t\\t\\t\\tif ( renderingShadows ) {\\n\\n\\t\\t\\t\\t\\t// there's no global clipping\\n\\n\\t\\t\\t\\t\\tprojectPlanes( null );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tresetGlobalState();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tvar nGlobal = renderingShadows ? 0 : numGlobalPlanes,\\n\\t\\t\\t\\t\\tlGlobal = nGlobal * 4,\\n\\n\\t\\t\\t\\t\\tdstArray = cache.clippingState || null;\\n\\n\\t\\t\\t\\tuniform.value = dstArray; // ensure unique state\\n\\n\\t\\t\\t\\tdstArray = projectPlanes( planes, camera, lGlobal, fromCache );\\n\\n\\t\\t\\t\\tfor ( var i = 0; i !== lGlobal; ++ i ) {\\n\\n\\t\\t\\t\\t\\tdstArray[ i ] = globalState[ i ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcache.clippingState = dstArray;\\n\\t\\t\\t\\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\\n\\t\\t\\t\\tthis.numPlanes += nGlobal;\\n\\n\\t\\t\\t}\\n\\n\\n\\t\\t};\\n\\n\\t\\tfunction resetGlobalState() {\\n\\n\\t\\t\\tif ( uniform.value !== globalState ) {\\n\\n\\t\\t\\t\\tuniform.value = globalState;\\n\\t\\t\\t\\tuniform.needsUpdate = numGlobalPlanes > 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tscope.numPlanes = numGlobalPlanes;\\n\\t\\t\\tscope.numIntersection = 0;\\n\\n\\t\\t}\\n\\n\\t\\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\\n\\n\\t\\t\\tvar nPlanes = planes !== null ? planes.length : 0,\\n\\t\\t\\t\\tdstArray = null;\\n\\n\\t\\t\\tif ( nPlanes !== 0 ) {\\n\\n\\t\\t\\t\\tdstArray = uniform.value;\\n\\n\\t\\t\\t\\tif ( skipTransform !== true || dstArray === null ) {\\n\\n\\t\\t\\t\\t\\tvar flatSize = dstOffset + nPlanes * 4,\\n\\t\\t\\t\\t\\t\\tviewMatrix = camera.matrixWorldInverse;\\n\\n\\t\\t\\t\\t\\tviewNormalMatrix.getNormalMatrix( viewMatrix );\\n\\n\\t\\t\\t\\t\\tif ( dstArray === null || dstArray.length < flatSize ) {\\n\\n\\t\\t\\t\\t\\t\\tdstArray = new Float32Array( flatSize );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {\\n\\n\\t\\t\\t\\t\\t\\tplane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );\\n\\n\\t\\t\\t\\t\\t\\tplane.normal.toArray( dstArray, i4 );\\n\\t\\t\\t\\t\\t\\tdstArray[ i4 + 3 ] = plane.constant;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tuniform.value = dstArray;\\n\\t\\t\\t\\tuniform.needsUpdate = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tscope.numPlanes = nPlanes;\\n\\n\\t\\t\\treturn dstArray;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author thespite / http://www.twitter.com/thespite\\n\\t */\\n\\n\\tfunction WebGLUtils( gl, extensions ) {\\n\\n\\t\\tfunction convert( p ) {\\n\\n\\t\\t\\tvar extension;\\n\\n\\t\\t\\tif ( p === RepeatWrapping ) return gl.REPEAT;\\n\\t\\t\\tif ( p === ClampToEdgeWrapping ) return gl.CLAMP_TO_EDGE;\\n\\t\\t\\tif ( p === MirroredRepeatWrapping ) return gl.MIRRORED_REPEAT;\\n\\n\\t\\t\\tif ( p === NearestFilter ) return gl.NEAREST;\\n\\t\\t\\tif ( p === NearestMipMapNearestFilter ) return gl.NEAREST_MIPMAP_NEAREST;\\n\\t\\t\\tif ( p === NearestMipMapLinearFilter ) return gl.NEAREST_MIPMAP_LINEAR;\\n\\n\\t\\t\\tif ( p === LinearFilter ) return gl.LINEAR;\\n\\t\\t\\tif ( p === LinearMipMapNearestFilter ) return gl.LINEAR_MIPMAP_NEAREST;\\n\\t\\t\\tif ( p === LinearMipMapLinearFilter ) return gl.LINEAR_MIPMAP_LINEAR;\\n\\n\\t\\t\\tif ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;\\n\\t\\t\\tif ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;\\n\\t\\t\\tif ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;\\n\\t\\t\\tif ( p === UnsignedShort565Type ) return gl.UNSIGNED_SHORT_5_6_5;\\n\\n\\t\\t\\tif ( p === ByteType ) return gl.BYTE;\\n\\t\\t\\tif ( p === ShortType ) return gl.SHORT;\\n\\t\\t\\tif ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;\\n\\t\\t\\tif ( p === IntType ) return gl.INT;\\n\\t\\t\\tif ( p === UnsignedIntType ) return gl.UNSIGNED_INT;\\n\\t\\t\\tif ( p === FloatType ) return gl.FLOAT;\\n\\n\\t\\t\\tif ( p === HalfFloatType ) {\\n\\n\\t\\t\\t\\textension = extensions.get( 'OES_texture_half_float' );\\n\\n\\t\\t\\t\\tif ( extension !== null ) return extension.HALF_FLOAT_OES;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( p === AlphaFormat ) return gl.ALPHA;\\n\\t\\t\\tif ( p === RGBFormat ) return gl.RGB;\\n\\t\\t\\tif ( p === RGBAFormat ) return gl.RGBA;\\n\\t\\t\\tif ( p === LuminanceFormat ) return gl.LUMINANCE;\\n\\t\\t\\tif ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;\\n\\t\\t\\tif ( p === DepthFormat ) return gl.DEPTH_COMPONENT;\\n\\t\\t\\tif ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;\\n\\n\\t\\t\\tif ( p === AddEquation ) return gl.FUNC_ADD;\\n\\t\\t\\tif ( p === SubtractEquation ) return gl.FUNC_SUBTRACT;\\n\\t\\t\\tif ( p === ReverseSubtractEquation ) return gl.FUNC_REVERSE_SUBTRACT;\\n\\n\\t\\t\\tif ( p === ZeroFactor ) return gl.ZERO;\\n\\t\\t\\tif ( p === OneFactor ) return gl.ONE;\\n\\t\\t\\tif ( p === SrcColorFactor ) return gl.SRC_COLOR;\\n\\t\\t\\tif ( p === OneMinusSrcColorFactor ) return gl.ONE_MINUS_SRC_COLOR;\\n\\t\\t\\tif ( p === SrcAlphaFactor ) return gl.SRC_ALPHA;\\n\\t\\t\\tif ( p === OneMinusSrcAlphaFactor ) return gl.ONE_MINUS_SRC_ALPHA;\\n\\t\\t\\tif ( p === DstAlphaFactor ) return gl.DST_ALPHA;\\n\\t\\t\\tif ( p === OneMinusDstAlphaFactor ) return gl.ONE_MINUS_DST_ALPHA;\\n\\n\\t\\t\\tif ( p === DstColorFactor ) return gl.DST_COLOR;\\n\\t\\t\\tif ( p === OneMinusDstColorFactor ) return gl.ONE_MINUS_DST_COLOR;\\n\\t\\t\\tif ( p === SrcAlphaSaturateFactor ) return gl.SRC_ALPHA_SATURATE;\\n\\n\\t\\t\\tif ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||\\n\\t\\t\\t\\tp === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {\\n\\n\\t\\t\\t\\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\\n\\n\\t\\t\\t\\tif ( extension !== null ) {\\n\\n\\t\\t\\t\\t\\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\\n\\t\\t\\t\\t\\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\\n\\t\\t\\t\\t\\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\\n\\t\\t\\t\\t\\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||\\n\\t\\t\\t\\tp === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {\\n\\n\\t\\t\\t\\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\\n\\n\\t\\t\\t\\tif ( extension !== null ) {\\n\\n\\t\\t\\t\\t\\tif ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\\n\\t\\t\\t\\t\\tif ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\\n\\t\\t\\t\\t\\tif ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\\n\\t\\t\\t\\t\\tif ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( p === RGB_ETC1_Format ) {\\n\\n\\t\\t\\t\\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\\n\\n\\t\\t\\t\\tif ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( p === MinEquation || p === MaxEquation ) {\\n\\n\\t\\t\\t\\textension = extensions.get( 'EXT_blend_minmax' );\\n\\n\\t\\t\\t\\tif ( extension !== null ) {\\n\\n\\t\\t\\t\\t\\tif ( p === MinEquation ) return extension.MIN_EXT;\\n\\t\\t\\t\\t\\tif ( p === MaxEquation ) return extension.MAX_EXT;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( p === UnsignedInt248Type ) {\\n\\n\\t\\t\\t\\textension = extensions.get( 'WEBGL_depth_texture' );\\n\\n\\t\\t\\t\\tif ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn 0;\\n\\n\\t\\t}\\n\\n\\t\\treturn { convert: convert };\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author supereggbert / http://www.paulbrunt.co.uk/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author szimek / https://github.com/szimek/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction WebGLRenderer( parameters ) {\\n\\n\\t\\tconsole.log( 'THREE.WebGLRenderer', REVISION );\\n\\n\\t\\tparameters = parameters || {};\\n\\n\\t\\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),\\n\\t\\t\\t_context = parameters.context !== undefined ? parameters.context : null,\\n\\n\\t\\t\\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\\n\\t\\t\\t_depth = parameters.depth !== undefined ? parameters.depth : true,\\n\\t\\t\\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\\n\\t\\t\\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\\n\\t\\t\\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\\n\\t\\t\\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\\n\\t\\t\\t_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default';\\n\\n\\t\\tvar lightsArray = [];\\n\\t\\tvar shadowsArray = [];\\n\\n\\t\\tvar currentRenderList = null;\\n\\n\\t\\tvar spritesArray = [];\\n\\t\\tvar flaresArray = [];\\n\\n\\t\\t// public properties\\n\\n\\t\\tthis.domElement = _canvas;\\n\\t\\tthis.context = null;\\n\\n\\t\\t// clearing\\n\\n\\t\\tthis.autoClear = true;\\n\\t\\tthis.autoClearColor = true;\\n\\t\\tthis.autoClearDepth = true;\\n\\t\\tthis.autoClearStencil = true;\\n\\n\\t\\t// scene graph\\n\\n\\t\\tthis.sortObjects = true;\\n\\n\\t\\t// user-defined clipping\\n\\n\\t\\tthis.clippingPlanes = [];\\n\\t\\tthis.localClippingEnabled = false;\\n\\n\\t\\t// physically based shading\\n\\n\\t\\tthis.gammaFactor = 2.0;\\t// for backwards compatibility\\n\\t\\tthis.gammaInput = false;\\n\\t\\tthis.gammaOutput = false;\\n\\n\\t\\t// physical lights\\n\\n\\t\\tthis.physicallyCorrectLights = false;\\n\\n\\t\\t// tone mapping\\n\\n\\t\\tthis.toneMapping = LinearToneMapping;\\n\\t\\tthis.toneMappingExposure = 1.0;\\n\\t\\tthis.toneMappingWhitePoint = 1.0;\\n\\n\\t\\t// morphs\\n\\n\\t\\tthis.maxMorphTargets = 8;\\n\\t\\tthis.maxMorphNormals = 4;\\n\\n\\t\\t// internal properties\\n\\n\\t\\tvar _this = this,\\n\\n\\t\\t\\t_isContextLost = false,\\n\\n\\t\\t\\t// internal state cache\\n\\n\\t\\t\\t_currentRenderTarget = null,\\n\\t\\t\\t_currentFramebuffer = null,\\n\\t\\t\\t_currentMaterialId = - 1,\\n\\t\\t\\t_currentGeometryProgram = '',\\n\\n\\t\\t\\t_currentCamera = null,\\n\\t\\t\\t_currentArrayCamera = null,\\n\\n\\t\\t\\t_currentViewport = new Vector4(),\\n\\t\\t\\t_currentScissor = new Vector4(),\\n\\t\\t\\t_currentScissorTest = null,\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\t_usedTextureUnits = 0,\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\t_width = _canvas.width,\\n\\t\\t\\t_height = _canvas.height,\\n\\n\\t\\t\\t_pixelRatio = 1,\\n\\n\\t\\t\\t_viewport = new Vector4( 0, 0, _width, _height ),\\n\\t\\t\\t_scissor = new Vector4( 0, 0, _width, _height ),\\n\\t\\t\\t_scissorTest = false,\\n\\n\\t\\t\\t// frustum\\n\\n\\t\\t\\t_frustum = new Frustum(),\\n\\n\\t\\t\\t// clipping\\n\\n\\t\\t\\t_clipping = new WebGLClipping(),\\n\\t\\t\\t_clippingEnabled = false,\\n\\t\\t\\t_localClippingEnabled = false,\\n\\n\\t\\t\\t// camera matrices cache\\n\\n\\t\\t\\t_projScreenMatrix = new Matrix4(),\\n\\n\\t\\t\\t_vector3 = new Vector3(),\\n\\n\\t\\t\\t// info\\n\\n\\t\\t\\t_infoMemory = {\\n\\t\\t\\t\\tgeometries: 0,\\n\\t\\t\\t\\ttextures: 0\\n\\t\\t\\t},\\n\\n\\t\\t\\t_infoRender = {\\n\\n\\t\\t\\t\\tframe: 0,\\n\\t\\t\\t\\tcalls: 0,\\n\\t\\t\\t\\tvertices: 0,\\n\\t\\t\\t\\tfaces: 0,\\n\\t\\t\\t\\tpoints: 0\\n\\n\\t\\t\\t};\\n\\n\\t\\tthis.info = {\\n\\n\\t\\t\\trender: _infoRender,\\n\\t\\t\\tmemory: _infoMemory,\\n\\t\\t\\tprograms: null\\n\\n\\t\\t};\\n\\n\\t\\tfunction getTargetPixelRatio() {\\n\\n\\t\\t\\treturn _currentRenderTarget === null ? _pixelRatio : 1;\\n\\n\\t\\t}\\n\\n\\t\\t// initialize\\n\\n\\t\\tvar _gl;\\n\\n\\t\\ttry {\\n\\n\\t\\t\\tvar contextAttributes = {\\n\\t\\t\\t\\talpha: _alpha,\\n\\t\\t\\t\\tdepth: _depth,\\n\\t\\t\\t\\tstencil: _stencil,\\n\\t\\t\\t\\tantialias: _antialias,\\n\\t\\t\\t\\tpremultipliedAlpha: _premultipliedAlpha,\\n\\t\\t\\t\\tpreserveDrawingBuffer: _preserveDrawingBuffer,\\n\\t\\t\\t\\tpowerPreference: _powerPreference\\n\\t\\t\\t};\\n\\n\\t\\t\\t// event listeners must be registered before WebGL context is created, see #12753\\n\\n\\t\\t\\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\\n\\t\\t\\t_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );\\n\\n\\t\\t\\t_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );\\n\\n\\t\\t\\tif ( _gl === null ) {\\n\\n\\t\\t\\t\\tif ( _canvas.getContext( 'webgl' ) !== null ) {\\n\\n\\t\\t\\t\\t\\tthrow new Error( 'Error creating WebGL context with your selected attributes.' );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthrow new Error( 'Error creating WebGL context.' );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\\n\\n\\t\\t\\tif ( _gl.getShaderPrecisionFormat === undefined ) {\\n\\n\\t\\t\\t\\t_gl.getShaderPrecisionFormat = function () {\\n\\n\\t\\t\\t\\t\\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\\n\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t}\\n\\n\\t\\t} catch ( error ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.WebGLRenderer: ' + error.message );\\n\\n\\t\\t}\\n\\n\\t\\tvar extensions, capabilities, state;\\n\\t\\tvar properties, textures, attributes, geometries, objects, lights;\\n\\t\\tvar programCache, renderLists;\\n\\n\\t\\tvar background, morphtargets, bufferRenderer, indexedBufferRenderer;\\n\\t\\tvar flareRenderer, spriteRenderer;\\n\\n\\t\\tvar utils;\\n\\n\\t\\tfunction initGLContext() {\\n\\n\\t\\t\\textensions = new WebGLExtensions( _gl );\\n\\t\\t\\textensions.get( 'WEBGL_depth_texture' );\\n\\t\\t\\textensions.get( 'OES_texture_float' );\\n\\t\\t\\textensions.get( 'OES_texture_float_linear' );\\n\\t\\t\\textensions.get( 'OES_texture_half_float' );\\n\\t\\t\\textensions.get( 'OES_texture_half_float_linear' );\\n\\t\\t\\textensions.get( 'OES_standard_derivatives' );\\n\\t\\t\\textensions.get( 'OES_element_index_uint' );\\n\\t\\t\\textensions.get( 'ANGLE_instanced_arrays' );\\n\\n\\t\\t\\tutils = new WebGLUtils( _gl, extensions );\\n\\n\\t\\t\\tcapabilities = new WebGLCapabilities( _gl, extensions, parameters );\\n\\n\\t\\t\\tstate = new WebGLState( _gl, extensions, utils );\\n\\t\\t\\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\\n\\t\\t\\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\\n\\n\\t\\t\\tproperties = new WebGLProperties();\\n\\t\\t\\ttextures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, _infoMemory );\\n\\t\\t\\tattributes = new WebGLAttributes( _gl );\\n\\t\\t\\tgeometries = new WebGLGeometries( _gl, attributes, _infoMemory );\\n\\t\\t\\tobjects = new WebGLObjects( geometries, _infoRender );\\n\\t\\t\\tmorphtargets = new WebGLMorphtargets( _gl );\\n\\t\\t\\tprogramCache = new WebGLPrograms( _this, extensions, capabilities );\\n\\t\\t\\tlights = new WebGLLights();\\n\\t\\t\\trenderLists = new WebGLRenderLists();\\n\\n\\t\\t\\tbackground = new WebGLBackground( _this, state, geometries, _premultipliedAlpha );\\n\\n\\t\\t\\tbufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );\\n\\t\\t\\tindexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\\n\\n\\t\\t\\tflareRenderer = new WebGLFlareRenderer( _this, _gl, state, textures, capabilities );\\n\\t\\t\\tspriteRenderer = new WebGLSpriteRenderer( _this, _gl, state, textures, capabilities );\\n\\n\\t\\t\\t_this.info.programs = programCache.programs;\\n\\n\\t\\t\\t_this.context = _gl;\\n\\t\\t\\t_this.capabilities = capabilities;\\n\\t\\t\\t_this.extensions = extensions;\\n\\t\\t\\t_this.properties = properties;\\n\\t\\t\\t_this.renderLists = renderLists;\\n\\t\\t\\t_this.state = state;\\n\\n\\t\\t}\\n\\n\\t\\tinitGLContext();\\n\\n\\t\\t// vr\\n\\n\\t\\tvar vr = new WebVRManager( _this );\\n\\n\\t\\tthis.vr = vr;\\n\\n\\t\\t// shadow map\\n\\n\\t\\tvar shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );\\n\\n\\t\\tthis.shadowMap = shadowMap;\\n\\n\\t\\t// API\\n\\n\\t\\tthis.getContext = function () {\\n\\n\\t\\t\\treturn _gl;\\n\\n\\t\\t};\\n\\n\\t\\tthis.getContextAttributes = function () {\\n\\n\\t\\t\\treturn _gl.getContextAttributes();\\n\\n\\t\\t};\\n\\n\\t\\tthis.forceContextLoss = function () {\\n\\n\\t\\t\\tvar extension = extensions.get( 'WEBGL_lose_context' );\\n\\t\\t\\tif ( extension ) extension.loseContext();\\n\\n\\t\\t};\\n\\n\\t\\tthis.forceContextRestore = function () {\\n\\n\\t\\t\\tvar extension = extensions.get( 'WEBGL_lose_context' );\\n\\t\\t\\tif ( extension ) extension.restoreContext();\\n\\n\\t\\t};\\n\\n\\t\\tthis.getPixelRatio = function () {\\n\\n\\t\\t\\treturn _pixelRatio;\\n\\n\\t\\t};\\n\\n\\t\\tthis.setPixelRatio = function ( value ) {\\n\\n\\t\\t\\tif ( value === undefined ) return;\\n\\n\\t\\t\\t_pixelRatio = value;\\n\\n\\t\\t\\tthis.setSize( _width, _height, false );\\n\\n\\t\\t};\\n\\n\\t\\tthis.getSize = function () {\\n\\n\\t\\t\\treturn {\\n\\t\\t\\t\\twidth: _width,\\n\\t\\t\\t\\theight: _height\\n\\t\\t\\t};\\n\\n\\t\\t};\\n\\n\\t\\tthis.setSize = function ( width, height, updateStyle ) {\\n\\n\\t\\t\\tvar device = vr.getDevice();\\n\\n\\t\\t\\tif ( device && device.isPresenting ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Can\\\\'t change size while VR device is presenting.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t_width = width;\\n\\t\\t\\t_height = height;\\n\\n\\t\\t\\t_canvas.width = width * _pixelRatio;\\n\\t\\t\\t_canvas.height = height * _pixelRatio;\\n\\n\\t\\t\\tif ( updateStyle !== false ) {\\n\\n\\t\\t\\t\\t_canvas.style.width = width + 'px';\\n\\t\\t\\t\\t_canvas.style.height = height + 'px';\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.setViewport( 0, 0, width, height );\\n\\n\\t\\t};\\n\\n\\t\\tthis.getDrawingBufferSize = function () {\\n\\n\\t\\t\\treturn {\\n\\t\\t\\t\\twidth: _width * _pixelRatio,\\n\\t\\t\\t\\theight: _height * _pixelRatio\\n\\t\\t\\t};\\n\\n\\t\\t};\\n\\n\\t\\tthis.setDrawingBufferSize = function ( width, height, pixelRatio ) {\\n\\n\\t\\t\\t_width = width;\\n\\t\\t\\t_height = height;\\n\\n\\t\\t\\t_pixelRatio = pixelRatio;\\n\\n\\t\\t\\t_canvas.width = width * pixelRatio;\\n\\t\\t\\t_canvas.height = height * pixelRatio;\\n\\n\\t\\t\\tthis.setViewport( 0, 0, width, height );\\n\\n\\t\\t};\\n\\n\\t\\tthis.setViewport = function ( x, y, width, height ) {\\n\\n\\t\\t\\t_viewport.set( x, _height - y - height, width, height );\\n\\t\\t\\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\\n\\n\\t\\t};\\n\\n\\t\\tthis.setScissor = function ( x, y, width, height ) {\\n\\n\\t\\t\\t_scissor.set( x, _height - y - height, width, height );\\n\\t\\t\\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\\n\\n\\t\\t};\\n\\n\\t\\tthis.setScissorTest = function ( boolean ) {\\n\\n\\t\\t\\tstate.setScissorTest( _scissorTest = boolean );\\n\\n\\t\\t};\\n\\n\\t\\t// Clearing\\n\\n\\t\\tthis.getClearColor = function () {\\n\\n\\t\\t\\treturn background.getClearColor();\\n\\n\\t\\t};\\n\\n\\t\\tthis.setClearColor = function () {\\n\\n\\t\\t\\tbackground.setClearColor.apply( background, arguments );\\n\\n\\t\\t};\\n\\n\\t\\tthis.getClearAlpha = function () {\\n\\n\\t\\t\\treturn background.getClearAlpha();\\n\\n\\t\\t};\\n\\n\\t\\tthis.setClearAlpha = function () {\\n\\n\\t\\t\\tbackground.setClearAlpha.apply( background, arguments );\\n\\n\\t\\t};\\n\\n\\t\\tthis.clear = function ( color, depth, stencil ) {\\n\\n\\t\\t\\tvar bits = 0;\\n\\n\\t\\t\\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\\n\\t\\t\\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\\n\\t\\t\\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\\n\\n\\t\\t\\t_gl.clear( bits );\\n\\n\\t\\t};\\n\\n\\t\\tthis.clearColor = function () {\\n\\n\\t\\t\\tthis.clear( true, false, false );\\n\\n\\t\\t};\\n\\n\\t\\tthis.clearDepth = function () {\\n\\n\\t\\t\\tthis.clear( false, true, false );\\n\\n\\t\\t};\\n\\n\\t\\tthis.clearStencil = function () {\\n\\n\\t\\t\\tthis.clear( false, false, true );\\n\\n\\t\\t};\\n\\n\\t\\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\\n\\n\\t\\t\\tthis.setRenderTarget( renderTarget );\\n\\t\\t\\tthis.clear( color, depth, stencil );\\n\\n\\t\\t};\\n\\n\\t\\t//\\n\\n\\t\\tthis.dispose = function () {\\n\\n\\t\\t\\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\\n\\t\\t\\t_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );\\n\\n\\t\\t\\trenderLists.dispose();\\n\\n\\t\\t\\tvr.dispose();\\n\\n\\t\\t};\\n\\n\\t\\t// Events\\n\\n\\t\\tfunction onContextLost( event ) {\\n\\n\\t\\t\\tevent.preventDefault();\\n\\n\\t\\t\\tconsole.log( 'THREE.WebGLRenderer: Context Lost.' );\\n\\n\\t\\t\\t_isContextLost = true;\\n\\n\\t\\t}\\n\\n\\t\\tfunction onContextRestore( /* event */ ) {\\n\\n\\t\\t\\tconsole.log( 'THREE.WebGLRenderer: Context Restored.' );\\n\\n\\t\\t\\t_isContextLost = false;\\n\\n\\t\\t\\tinitGLContext();\\n\\n\\t\\t}\\n\\n\\t\\tfunction onMaterialDispose( event ) {\\n\\n\\t\\t\\tvar material = event.target;\\n\\n\\t\\t\\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\\n\\n\\t\\t\\tdeallocateMaterial( material );\\n\\n\\t\\t}\\n\\n\\t\\t// Buffer deallocation\\n\\n\\t\\tfunction deallocateMaterial( material ) {\\n\\n\\t\\t\\treleaseMaterialProgramReference( material );\\n\\n\\t\\t\\tproperties.remove( material );\\n\\n\\t\\t}\\n\\n\\n\\t\\tfunction releaseMaterialProgramReference( material ) {\\n\\n\\t\\t\\tvar programInfo = properties.get( material ).program;\\n\\n\\t\\t\\tmaterial.program = undefined;\\n\\n\\t\\t\\tif ( programInfo !== undefined ) {\\n\\n\\t\\t\\t\\tprogramCache.releaseProgram( programInfo );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// Buffer rendering\\n\\n\\t\\tfunction renderObjectImmediate( object, program, material ) {\\n\\n\\t\\t\\tobject.render( function ( object ) {\\n\\n\\t\\t\\t\\t_this.renderBufferImmediate( object, program, material );\\n\\n\\t\\t\\t} );\\n\\n\\t\\t}\\n\\n\\t\\tthis.renderBufferImmediate = function ( object, program, material ) {\\n\\n\\t\\t\\tstate.initAttributes();\\n\\n\\t\\t\\tvar buffers = properties.get( object );\\n\\n\\t\\t\\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\\n\\t\\t\\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\\n\\t\\t\\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\\n\\t\\t\\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\\n\\n\\t\\t\\tvar programAttributes = program.getAttributes();\\n\\n\\t\\t\\tif ( object.hasPositions ) {\\n\\n\\t\\t\\t\\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\\n\\t\\t\\t\\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\\n\\n\\t\\t\\t\\tstate.enableAttribute( programAttributes.position );\\n\\t\\t\\t\\t_gl.vertexAttribPointer( programAttributes.position, 3, _gl.FLOAT, false, 0, 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( object.hasNormals ) {\\n\\n\\t\\t\\t\\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\\n\\n\\t\\t\\t\\tif ( ! material.isMeshPhongMaterial &&\\n\\t\\t\\t\\t\\t! material.isMeshStandardMaterial &&\\n\\t\\t\\t\\t\\t! material.isMeshNormalMaterial &&\\n\\t\\t\\t\\t\\tmaterial.flatShading === true ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\\n\\n\\t\\t\\t\\t\\t\\tvar array = object.normalArray;\\n\\n\\t\\t\\t\\t\\t\\tvar nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\\n\\t\\t\\t\\t\\t\\tvar ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\\n\\t\\t\\t\\t\\t\\tvar nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\\n\\n\\t\\t\\t\\t\\t\\tarray[ i + 0 ] = nx;\\n\\t\\t\\t\\t\\t\\tarray[ i + 1 ] = ny;\\n\\t\\t\\t\\t\\t\\tarray[ i + 2 ] = nz;\\n\\n\\t\\t\\t\\t\\t\\tarray[ i + 3 ] = nx;\\n\\t\\t\\t\\t\\t\\tarray[ i + 4 ] = ny;\\n\\t\\t\\t\\t\\t\\tarray[ i + 5 ] = nz;\\n\\n\\t\\t\\t\\t\\t\\tarray[ i + 6 ] = nx;\\n\\t\\t\\t\\t\\t\\tarray[ i + 7 ] = ny;\\n\\t\\t\\t\\t\\t\\tarray[ i + 8 ] = nz;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\\n\\n\\t\\t\\t\\tstate.enableAttribute( programAttributes.normal );\\n\\n\\t\\t\\t\\t_gl.vertexAttribPointer( programAttributes.normal, 3, _gl.FLOAT, false, 0, 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( object.hasUvs && material.map ) {\\n\\n\\t\\t\\t\\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\\n\\t\\t\\t\\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\\n\\n\\t\\t\\t\\tstate.enableAttribute( programAttributes.uv );\\n\\n\\t\\t\\t\\t_gl.vertexAttribPointer( programAttributes.uv, 2, _gl.FLOAT, false, 0, 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( object.hasColors && material.vertexColors !== NoColors ) {\\n\\n\\t\\t\\t\\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\\n\\t\\t\\t\\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\\n\\n\\t\\t\\t\\tstate.enableAttribute( programAttributes.color );\\n\\n\\t\\t\\t\\t_gl.vertexAttribPointer( programAttributes.color, 3, _gl.FLOAT, false, 0, 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tstate.disableUnusedAttributes();\\n\\n\\t\\t\\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\\n\\n\\t\\t\\tobject.count = 0;\\n\\n\\t\\t};\\n\\n\\t\\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\\n\\n\\t\\t\\tvar frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\\n\\n\\t\\t\\tstate.setMaterial( material, frontFaceCW );\\n\\n\\t\\t\\tvar program = setProgram( camera, fog, material, object );\\n\\t\\t\\tvar geometryProgram = geometry.id + '_' + program.id + '_' + ( material.wireframe === true );\\n\\n\\t\\t\\tvar updateBuffers = false;\\n\\n\\t\\t\\tif ( geometryProgram !== _currentGeometryProgram ) {\\n\\n\\t\\t\\t\\t_currentGeometryProgram = geometryProgram;\\n\\t\\t\\t\\tupdateBuffers = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( object.morphTargetInfluences ) {\\n\\n\\t\\t\\t\\tmorphtargets.update( object, geometry, material, program );\\n\\n\\t\\t\\t\\tupdateBuffers = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar index = geometry.index;\\n\\t\\t\\tvar position = geometry.attributes.position;\\n\\t\\t\\tvar rangeFactor = 1;\\n\\n\\t\\t\\tif ( material.wireframe === true ) {\\n\\n\\t\\t\\t\\tindex = geometries.getWireframeAttribute( geometry );\\n\\t\\t\\t\\trangeFactor = 2;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar attribute;\\n\\t\\t\\tvar renderer = bufferRenderer;\\n\\n\\t\\t\\tif ( index !== null ) {\\n\\n\\t\\t\\t\\tattribute = attributes.get( index );\\n\\n\\t\\t\\t\\trenderer = indexedBufferRenderer;\\n\\t\\t\\t\\trenderer.setIndex( attribute );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( updateBuffers ) {\\n\\n\\t\\t\\t\\tsetupVertexAttributes( material, program, geometry );\\n\\n\\t\\t\\t\\tif ( index !== null ) {\\n\\n\\t\\t\\t\\t\\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attribute.buffer );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar dataCount = 0;\\n\\n\\t\\t\\tif ( index !== null ) {\\n\\n\\t\\t\\t\\tdataCount = index.count;\\n\\n\\t\\t\\t} else if ( position !== undefined ) {\\n\\n\\t\\t\\t\\tdataCount = position.count;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar rangeStart = geometry.drawRange.start * rangeFactor;\\n\\t\\t\\tvar rangeCount = geometry.drawRange.count * rangeFactor;\\n\\n\\t\\t\\tvar groupStart = group !== null ? group.start * rangeFactor : 0;\\n\\t\\t\\tvar groupCount = group !== null ? group.count * rangeFactor : Infinity;\\n\\n\\t\\t\\tvar drawStart = Math.max( rangeStart, groupStart );\\n\\t\\t\\tvar drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\\n\\n\\t\\t\\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\\n\\n\\t\\t\\tif ( drawCount === 0 ) return;\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tif ( object.isMesh ) {\\n\\n\\t\\t\\t\\tif ( material.wireframe === true ) {\\n\\n\\t\\t\\t\\t\\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\\n\\t\\t\\t\\t\\trenderer.setMode( _gl.LINES );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tswitch ( object.drawMode ) {\\n\\n\\t\\t\\t\\t\\t\\tcase TrianglesDrawMode:\\n\\t\\t\\t\\t\\t\\t\\trenderer.setMode( _gl.TRIANGLES );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase TriangleStripDrawMode:\\n\\t\\t\\t\\t\\t\\t\\trenderer.setMode( _gl.TRIANGLE_STRIP );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase TriangleFanDrawMode:\\n\\t\\t\\t\\t\\t\\t\\trenderer.setMode( _gl.TRIANGLE_FAN );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t} else if ( object.isLine ) {\\n\\n\\t\\t\\t\\tvar lineWidth = material.linewidth;\\n\\n\\t\\t\\t\\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\\n\\n\\t\\t\\t\\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\\n\\n\\t\\t\\t\\tif ( object.isLineSegments ) {\\n\\n\\t\\t\\t\\t\\trenderer.setMode( _gl.LINES );\\n\\n\\t\\t\\t\\t} else if ( object.isLineLoop ) {\\n\\n\\t\\t\\t\\t\\trenderer.setMode( _gl.LINE_LOOP );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\trenderer.setMode( _gl.LINE_STRIP );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( object.isPoints ) {\\n\\n\\t\\t\\t\\trenderer.setMode( _gl.POINTS );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry && geometry.isInstancedBufferGeometry ) {\\n\\n\\t\\t\\t\\tif ( geometry.maxInstancedCount > 0 ) {\\n\\n\\t\\t\\t\\t\\trenderer.renderInstances( geometry, drawStart, drawCount );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\trenderer.render( drawStart, drawCount );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\\n\\n\\t\\t\\tif ( geometry && geometry.isInstancedBufferGeometry ) {\\n\\n\\t\\t\\t\\tif ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) {\\n\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\\n\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( startIndex === undefined ) startIndex = 0;\\n\\n\\t\\t\\tstate.initAttributes();\\n\\n\\t\\t\\tvar geometryAttributes = geometry.attributes;\\n\\n\\t\\t\\tvar programAttributes = program.getAttributes();\\n\\n\\t\\t\\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\\n\\n\\t\\t\\tfor ( var name in programAttributes ) {\\n\\n\\t\\t\\t\\tvar programAttribute = programAttributes[ name ];\\n\\n\\t\\t\\t\\tif ( programAttribute >= 0 ) {\\n\\n\\t\\t\\t\\t\\tvar geometryAttribute = geometryAttributes[ name ];\\n\\n\\t\\t\\t\\t\\tif ( geometryAttribute !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tvar normalized = geometryAttribute.normalized;\\n\\t\\t\\t\\t\\t\\tvar size = geometryAttribute.itemSize;\\n\\n\\t\\t\\t\\t\\t\\tvar attribute = attributes.get( geometryAttribute );\\n\\n\\t\\t\\t\\t\\t\\t// TODO Attribute may not be available on context restore\\n\\n\\t\\t\\t\\t\\t\\tif ( attribute === undefined ) continue;\\n\\n\\t\\t\\t\\t\\t\\tvar buffer = attribute.buffer;\\n\\t\\t\\t\\t\\t\\tvar type = attribute.type;\\n\\t\\t\\t\\t\\t\\tvar bytesPerElement = attribute.bytesPerElement;\\n\\n\\t\\t\\t\\t\\t\\tif ( geometryAttribute.isInterleavedBufferAttribute ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar data = geometryAttribute.data;\\n\\t\\t\\t\\t\\t\\t\\tvar stride = data.stride;\\n\\t\\t\\t\\t\\t\\t\\tvar offset = geometryAttribute.offset;\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( data && data.isInstancedInterleavedBuffer ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( geometry.maxInstancedCount === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tstate.enableAttribute( programAttribute );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\\n\\t\\t\\t\\t\\t\\t\\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, ( startIndex * stride + offset ) * bytesPerElement );\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( geometryAttribute.isInstancedBufferAttribute ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( geometry.maxInstancedCount === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tstate.enableAttribute( programAttribute );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\\n\\t\\t\\t\\t\\t\\t\\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * bytesPerElement );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else if ( materialDefaultAttributeValues !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tvar value = materialDefaultAttributeValues[ name ];\\n\\n\\t\\t\\t\\t\\t\\tif ( value !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tswitch ( value.length ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase 2:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t_gl.vertexAttrib2fv( programAttribute, value );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase 3:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t_gl.vertexAttrib3fv( programAttribute, value );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase 4:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t_gl.vertexAttrib4fv( programAttribute, value );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t_gl.vertexAttrib1fv( programAttribute, value );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tstate.disableUnusedAttributes();\\n\\n\\t\\t}\\n\\n\\t\\t// Compile\\n\\n\\t\\tthis.compile = function ( scene, camera ) {\\n\\n\\t\\t\\tlightsArray.length = 0;\\n\\t\\t\\tshadowsArray.length = 0;\\n\\n\\t\\t\\tscene.traverse( function ( object ) {\\n\\n\\t\\t\\t\\tif ( object.isLight ) {\\n\\n\\t\\t\\t\\t\\tlightsArray.push( object );\\n\\n\\t\\t\\t\\t\\tif ( object.castShadow ) {\\n\\n\\t\\t\\t\\t\\t\\tshadowsArray.push( object );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} );\\n\\n\\t\\t\\tlights.setup( lightsArray, shadowsArray, camera );\\n\\n\\t\\t\\tscene.traverse( function ( object ) {\\n\\n\\t\\t\\t\\tif ( object.material ) {\\n\\n\\t\\t\\t\\t\\tif ( Array.isArray( object.material ) ) {\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < object.material.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tinitMaterial( object.material[ i ], scene.fog, object );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tinitMaterial( object.material, scene.fog, object );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} );\\n\\n\\t\\t};\\n\\n\\t\\t// Animation Loop\\n\\n\\t\\tvar isAnimating = false;\\n\\t\\tvar onAnimationFrame = null;\\n\\n\\t\\tfunction start() {\\n\\n\\t\\t\\tif ( isAnimating ) return;\\n\\n\\t\\t\\tvar device = vr.getDevice();\\n\\n\\t\\t\\tif ( device && device.isPresenting ) {\\n\\n\\t\\t\\t\\tdevice.requestAnimationFrame( loop );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\twindow.requestAnimationFrame( loop );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tisAnimating = true;\\n\\n\\t\\t}\\n\\n\\t\\tfunction loop( time ) {\\n\\n\\t\\t\\tif ( onAnimationFrame !== null ) onAnimationFrame( time );\\n\\n\\t\\t\\tvar device = vr.getDevice();\\n\\n\\t\\t\\tif ( device && device.isPresenting ) {\\n\\n\\t\\t\\t\\tdevice.requestAnimationFrame( loop );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\twindow.requestAnimationFrame( loop );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tthis.animate = function ( callback ) {\\n\\n\\t\\t\\tonAnimationFrame = callback;\\n\\t\\t\\tstart();\\n\\n\\t\\t};\\n\\n\\t\\t// Rendering\\n\\n\\t\\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\\n\\n\\t\\t\\tif ( ! ( camera && camera.isCamera ) ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( _isContextLost ) return;\\n\\n\\t\\t\\t// reset caching for this frame\\n\\n\\t\\t\\t_currentGeometryProgram = '';\\n\\t\\t\\t_currentMaterialId = - 1;\\n\\t\\t\\t_currentCamera = null;\\n\\n\\t\\t\\t// update scene graph\\n\\n\\t\\t\\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\\n\\n\\t\\t\\t// update camera matrices and frustum\\n\\n\\t\\t\\tif ( camera.parent === null ) camera.updateMatrixWorld();\\n\\n\\t\\t\\tif ( vr.enabled ) {\\n\\n\\t\\t\\t\\tcamera = vr.getCamera( camera );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\\n\\t\\t\\t_frustum.setFromMatrix( _projScreenMatrix );\\n\\n\\t\\t\\tlightsArray.length = 0;\\n\\t\\t\\tshadowsArray.length = 0;\\n\\n\\t\\t\\tspritesArray.length = 0;\\n\\t\\t\\tflaresArray.length = 0;\\n\\n\\t\\t\\t_localClippingEnabled = this.localClippingEnabled;\\n\\t\\t\\t_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\\n\\n\\t\\t\\tcurrentRenderList = renderLists.get( scene, camera );\\n\\t\\t\\tcurrentRenderList.init();\\n\\n\\t\\t\\tprojectObject( scene, camera, _this.sortObjects );\\n\\n\\t\\t\\tif ( _this.sortObjects === true ) {\\n\\n\\t\\t\\t\\tcurrentRenderList.sort();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\ttextures.updateVideoTextures();\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tif ( _clippingEnabled ) _clipping.beginShadows();\\n\\n\\t\\t\\tshadowMap.render( shadowsArray, scene, camera );\\n\\n\\t\\t\\tlights.setup( lightsArray, shadowsArray, camera );\\n\\n\\t\\t\\tif ( _clippingEnabled ) _clipping.endShadows();\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\t_infoRender.frame ++;\\n\\t\\t\\t_infoRender.calls = 0;\\n\\t\\t\\t_infoRender.vertices = 0;\\n\\t\\t\\t_infoRender.faces = 0;\\n\\t\\t\\t_infoRender.points = 0;\\n\\n\\t\\t\\tif ( renderTarget === undefined ) {\\n\\n\\t\\t\\t\\trenderTarget = null;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.setRenderTarget( renderTarget );\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tbackground.render( currentRenderList, scene, camera, forceClear );\\n\\n\\t\\t\\t// render scene\\n\\n\\t\\t\\tvar opaqueObjects = currentRenderList.opaque;\\n\\t\\t\\tvar transparentObjects = currentRenderList.transparent;\\n\\n\\t\\t\\tif ( scene.overrideMaterial ) {\\n\\n\\t\\t\\t\\tvar overrideMaterial = scene.overrideMaterial;\\n\\n\\t\\t\\t\\tif ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial );\\n\\t\\t\\t\\tif ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// opaque pass (front-to-back order)\\n\\n\\t\\t\\t\\tif ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera );\\n\\n\\t\\t\\t\\t// transparent pass (back-to-front order)\\n\\n\\t\\t\\t\\tif ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// custom renderers\\n\\n\\t\\t\\tspriteRenderer.render( spritesArray, scene, camera );\\n\\t\\t\\tflareRenderer.render( flaresArray, scene, camera, _currentViewport );\\n\\n\\t\\t\\t// Generate mipmap if we're using any kind of mipmap filtering\\n\\n\\t\\t\\tif ( renderTarget ) {\\n\\n\\t\\t\\t\\ttextures.updateRenderTargetMipmap( renderTarget );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Ensure depth buffer writing is enabled so it can be cleared on next render\\n\\n\\t\\t\\tstate.buffers.depth.setTest( true );\\n\\t\\t\\tstate.buffers.depth.setMask( true );\\n\\t\\t\\tstate.buffers.color.setMask( true );\\n\\n\\t\\t\\tstate.setPolygonOffset( false );\\n\\n\\t\\t\\tif ( vr.enabled ) {\\n\\n\\t\\t\\t\\tvr.submitFrame();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// _gl.finish();\\n\\n\\t\\t};\\n\\n\\t\\t/*\\n\\t\\t// TODO Duplicated code (Frustum)\\n\\n\\t\\tvar _sphere = new Sphere();\\n\\n\\t\\tfunction isObjectViewable( object ) {\\n\\n\\t\\t\\tvar geometry = object.geometry;\\n\\n\\t\\t\\tif ( geometry.boundingSphere === null )\\n\\t\\t\\t\\tgeometry.computeBoundingSphere();\\n\\n\\t\\t\\t_sphere.copy( geometry.boundingSphere ).\\n\\t\\t\\tapplyMatrix4( object.matrixWorld );\\n\\n\\t\\t\\treturn isSphereViewable( _sphere );\\n\\n\\t\\t}\\n\\n\\t\\tfunction isSpriteViewable( sprite ) {\\n\\n\\t\\t\\t_sphere.center.set( 0, 0, 0 );\\n\\t\\t\\t_sphere.radius = 0.7071067811865476;\\n\\t\\t\\t_sphere.applyMatrix4( sprite.matrixWorld );\\n\\n\\t\\t\\treturn isSphereViewable( _sphere );\\n\\n\\t\\t}\\n\\n\\t\\tfunction isSphereViewable( sphere ) {\\n\\n\\t\\t\\tif ( ! _frustum.intersectsSphere( sphere ) ) return false;\\n\\n\\t\\t\\tvar numPlanes = _clipping.numPlanes;\\n\\n\\t\\t\\tif ( numPlanes === 0 ) return true;\\n\\n\\t\\t\\tvar planes = _this.clippingPlanes,\\n\\n\\t\\t\\t\\tcenter = sphere.center,\\n\\t\\t\\t\\tnegRad = - sphere.radius,\\n\\t\\t\\t\\ti = 0;\\n\\n\\t\\t\\tdo {\\n\\n\\t\\t\\t\\t// out when deeper than radius in the negative halfspace\\n\\t\\t\\t\\tif ( planes[ i ].distanceToPoint( center ) < negRad ) return false;\\n\\n\\t\\t\\t} while ( ++ i !== numPlanes );\\n\\n\\t\\t\\treturn true;\\n\\n\\t\\t}\\n\\t\\t*/\\n\\n\\t\\tfunction projectObject( object, camera, sortObjects ) {\\n\\n\\t\\t\\tif ( object.visible === false ) return;\\n\\n\\t\\t\\tvar visible = object.layers.test( camera.layers );\\n\\n\\t\\t\\tif ( visible ) {\\n\\n\\t\\t\\t\\tif ( object.isLight ) {\\n\\n\\t\\t\\t\\t\\tlightsArray.push( object );\\n\\n\\t\\t\\t\\t\\tif ( object.castShadow ) {\\n\\n\\t\\t\\t\\t\\t\\tshadowsArray.push( object );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( object.isSprite ) {\\n\\n\\t\\t\\t\\t\\tif ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {\\n\\n\\t\\t\\t\\t\\t\\tspritesArray.push( object );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( object.isLensFlare ) {\\n\\n\\t\\t\\t\\t\\tflaresArray.push( object );\\n\\n\\t\\t\\t\\t} else if ( object.isImmediateRenderObject ) {\\n\\n\\t\\t\\t\\t\\tif ( sortObjects ) {\\n\\n\\t\\t\\t\\t\\t\\t_vector3.setFromMatrixPosition( object.matrixWorld )\\n\\t\\t\\t\\t\\t\\t\\t.applyMatrix4( _projScreenMatrix );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tcurrentRenderList.push( object, null, object.material, _vector3.z, null );\\n\\n\\t\\t\\t\\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\\n\\n\\t\\t\\t\\t\\tif ( object.isSkinnedMesh ) {\\n\\n\\t\\t\\t\\t\\t\\tobject.skeleton.update();\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( sortObjects ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t_vector3.setFromMatrixPosition( object.matrixWorld )\\n\\t\\t\\t\\t\\t\\t\\t\\t.applyMatrix4( _projScreenMatrix );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tvar geometry = objects.update( object );\\n\\t\\t\\t\\t\\t\\tvar material = object.material;\\n\\n\\t\\t\\t\\t\\t\\tif ( Array.isArray( material ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar groups = geometry.groups;\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar group = groups[ i ];\\n\\t\\t\\t\\t\\t\\t\\t\\tvar groupMaterial = material[ group.materialIndex ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( groupMaterial && groupMaterial.visible ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcurrentRenderList.push( object, geometry, groupMaterial, _vector3.z, group );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t} else if ( material.visible ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tcurrentRenderList.push( object, geometry, material, _vector3.z, null );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar children = object.children;\\n\\n\\t\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tprojectObject( children[ i ], camera, sortObjects );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction renderObjects( renderList, scene, camera, overrideMaterial ) {\\n\\n\\t\\t\\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar renderItem = renderList[ i ];\\n\\n\\t\\t\\t\\tvar object = renderItem.object;\\n\\t\\t\\t\\tvar geometry = renderItem.geometry;\\n\\t\\t\\t\\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\\n\\t\\t\\t\\tvar group = renderItem.group;\\n\\n\\t\\t\\t\\tif ( camera.isArrayCamera ) {\\n\\n\\t\\t\\t\\t\\t_currentArrayCamera = camera;\\n\\n\\t\\t\\t\\t\\tvar cameras = camera.cameras;\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0, jl = cameras.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar camera2 = cameras[ j ];\\n\\n\\t\\t\\t\\t\\t\\tif ( object.layers.test( camera2.layers ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar bounds = camera2.bounds;\\n\\n\\t\\t\\t\\t\\t\\t\\tvar x = bounds.x * _width;\\n\\t\\t\\t\\t\\t\\t\\tvar y = bounds.y * _height;\\n\\t\\t\\t\\t\\t\\t\\tvar width = bounds.z * _width;\\n\\t\\t\\t\\t\\t\\t\\tvar height = bounds.w * _height;\\n\\n\\t\\t\\t\\t\\t\\t\\tstate.viewport( _currentViewport.set( x, y, width, height ).multiplyScalar( _pixelRatio ) );\\n\\n\\t\\t\\t\\t\\t\\t\\trenderObject( object, scene, camera2, geometry, material, group );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t_currentArrayCamera = null;\\n\\n\\t\\t\\t\\t\\trenderObject( object, scene, camera, geometry, material, group );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction renderObject( object, scene, camera, geometry, material, group ) {\\n\\n\\t\\t\\tobject.onBeforeRender( _this, scene, camera, geometry, material, group );\\n\\n\\t\\t\\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\\n\\t\\t\\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\\n\\n\\t\\t\\tif ( object.isImmediateRenderObject ) {\\n\\n\\t\\t\\t\\tvar frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\\n\\n\\t\\t\\t\\tstate.setMaterial( material, frontFaceCW );\\n\\n\\t\\t\\t\\tvar program = setProgram( camera, scene.fog, material, object );\\n\\n\\t\\t\\t\\t_currentGeometryProgram = '';\\n\\n\\t\\t\\t\\trenderObjectImmediate( object, program, material );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tobject.onAfterRender( _this, scene, camera, geometry, material, group );\\n\\n\\t\\t}\\n\\n\\t\\tfunction initMaterial( material, fog, object ) {\\n\\n\\t\\t\\tvar materialProperties = properties.get( material );\\n\\n\\t\\t\\tvar parameters = programCache.getParameters(\\n\\t\\t\\t\\tmaterial, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object );\\n\\n\\t\\t\\tvar code = programCache.getProgramCode( material, parameters );\\n\\n\\t\\t\\tvar program = materialProperties.program;\\n\\t\\t\\tvar programChange = true;\\n\\n\\t\\t\\tif ( program === undefined ) {\\n\\n\\t\\t\\t\\t// new material\\n\\t\\t\\t\\tmaterial.addEventListener( 'dispose', onMaterialDispose );\\n\\n\\t\\t\\t} else if ( program.code !== code ) {\\n\\n\\t\\t\\t\\t// changed glsl or parameters\\n\\t\\t\\t\\treleaseMaterialProgramReference( material );\\n\\n\\t\\t\\t} else if ( parameters.shaderID !== undefined ) {\\n\\n\\t\\t\\t\\t// same glsl and uniform list\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// only rebuild uniform list\\n\\t\\t\\t\\tprogramChange = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( programChange ) {\\n\\n\\t\\t\\t\\tif ( parameters.shaderID ) {\\n\\n\\t\\t\\t\\t\\tvar shader = ShaderLib[ parameters.shaderID ];\\n\\n\\t\\t\\t\\t\\tmaterialProperties.shader = {\\n\\t\\t\\t\\t\\t\\tname: material.type,\\n\\t\\t\\t\\t\\t\\tuniforms: UniformsUtils.clone( shader.uniforms ),\\n\\t\\t\\t\\t\\t\\tvertexShader: shader.vertexShader,\\n\\t\\t\\t\\t\\t\\tfragmentShader: shader.fragmentShader\\n\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tmaterialProperties.shader = {\\n\\t\\t\\t\\t\\t\\tname: material.type,\\n\\t\\t\\t\\t\\t\\tuniforms: material.uniforms,\\n\\t\\t\\t\\t\\t\\tvertexShader: material.vertexShader,\\n\\t\\t\\t\\t\\t\\tfragmentShader: material.fragmentShader\\n\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tmaterial.onBeforeCompile( materialProperties.shader );\\n\\n\\t\\t\\t\\tprogram = programCache.acquireProgram( material, materialProperties.shader, parameters, code );\\n\\n\\t\\t\\t\\tmaterialProperties.program = program;\\n\\t\\t\\t\\tmaterial.program = program;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar programAttributes = program.getAttributes();\\n\\n\\t\\t\\tif ( material.morphTargets ) {\\n\\n\\t\\t\\t\\tmaterial.numSupportedMorphTargets = 0;\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\\n\\n\\t\\t\\t\\t\\tif ( programAttributes[ 'morphTarget' + i ] >= 0 ) {\\n\\n\\t\\t\\t\\t\\t\\tmaterial.numSupportedMorphTargets ++;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.morphNormals ) {\\n\\n\\t\\t\\t\\tmaterial.numSupportedMorphNormals = 0;\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\\n\\n\\t\\t\\t\\t\\tif ( programAttributes[ 'morphNormal' + i ] >= 0 ) {\\n\\n\\t\\t\\t\\t\\t\\tmaterial.numSupportedMorphNormals ++;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar uniforms = materialProperties.shader.uniforms;\\n\\n\\t\\t\\tif ( ! material.isShaderMaterial &&\\n\\t\\t\\t\\t! material.isRawShaderMaterial ||\\n\\t\\t\\t\\tmaterial.clipping === true ) {\\n\\n\\t\\t\\t\\tmaterialProperties.numClippingPlanes = _clipping.numPlanes;\\n\\t\\t\\t\\tmaterialProperties.numIntersection = _clipping.numIntersection;\\n\\t\\t\\t\\tuniforms.clippingPlanes = _clipping.uniform;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tmaterialProperties.fog = fog;\\n\\n\\t\\t\\t// store the light setup it was created for\\n\\n\\t\\t\\tmaterialProperties.lightsHash = lights.state.hash;\\n\\n\\t\\t\\tif ( material.lights ) {\\n\\n\\t\\t\\t\\t// wire up the material to this renderer's lighting state\\n\\n\\t\\t\\t\\tuniforms.ambientLightColor.value = lights.state.ambient;\\n\\t\\t\\t\\tuniforms.directionalLights.value = lights.state.directional;\\n\\t\\t\\t\\tuniforms.spotLights.value = lights.state.spot;\\n\\t\\t\\t\\tuniforms.rectAreaLights.value = lights.state.rectArea;\\n\\t\\t\\t\\tuniforms.pointLights.value = lights.state.point;\\n\\t\\t\\t\\tuniforms.hemisphereLights.value = lights.state.hemi;\\n\\n\\t\\t\\t\\tuniforms.directionalShadowMap.value = lights.state.directionalShadowMap;\\n\\t\\t\\t\\tuniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;\\n\\t\\t\\t\\tuniforms.spotShadowMap.value = lights.state.spotShadowMap;\\n\\t\\t\\t\\tuniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;\\n\\t\\t\\t\\tuniforms.pointShadowMap.value = lights.state.pointShadowMap;\\n\\t\\t\\t\\tuniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;\\n\\t\\t\\t\\t// TODO (abelnation): add area lights shadow info to uniforms\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar progUniforms = materialProperties.program.getUniforms(),\\n\\t\\t\\t\\tuniformsList =\\n\\t\\t\\t\\t\\tWebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\\n\\n\\t\\t\\tmaterialProperties.uniformsList = uniformsList;\\n\\n\\t\\t}\\n\\n\\t\\tfunction setProgram( camera, fog, material, object ) {\\n\\n\\t\\t\\t_usedTextureUnits = 0;\\n\\n\\t\\t\\tvar materialProperties = properties.get( material );\\n\\n\\t\\t\\tif ( _clippingEnabled ) {\\n\\n\\t\\t\\t\\tif ( _localClippingEnabled || camera !== _currentCamera ) {\\n\\n\\t\\t\\t\\t\\tvar useCache =\\n\\t\\t\\t\\t\\t\\tcamera === _currentCamera &&\\n\\t\\t\\t\\t\\t\\tmaterial.id === _currentMaterialId;\\n\\n\\t\\t\\t\\t\\t// we might want to call this function with some ClippingGroup\\n\\t\\t\\t\\t\\t// object instead of the material, once it becomes feasible\\n\\t\\t\\t\\t\\t// (#8465, #8379)\\n\\t\\t\\t\\t\\t_clipping.setState(\\n\\t\\t\\t\\t\\t\\tmaterial.clippingPlanes, material.clipIntersection, material.clipShadows,\\n\\t\\t\\t\\t\\t\\tcamera, materialProperties, useCache );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.needsUpdate === false ) {\\n\\n\\t\\t\\t\\tif ( materialProperties.program === undefined ) {\\n\\n\\t\\t\\t\\t\\tmaterial.needsUpdate = true;\\n\\n\\t\\t\\t\\t} else if ( material.fog && materialProperties.fog !== fog ) {\\n\\n\\t\\t\\t\\t\\tmaterial.needsUpdate = true;\\n\\n\\t\\t\\t\\t} else if ( material.lights && materialProperties.lightsHash !== lights.state.hash ) {\\n\\n\\t\\t\\t\\t\\tmaterial.needsUpdate = true;\\n\\n\\t\\t\\t\\t} else if ( materialProperties.numClippingPlanes !== undefined &&\\n\\t\\t\\t\\t\\t( materialProperties.numClippingPlanes !== _clipping.numPlanes ||\\n\\t\\t\\t\\t\\tmaterialProperties.numIntersection !== _clipping.numIntersection ) ) {\\n\\n\\t\\t\\t\\t\\tmaterial.needsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.needsUpdate ) {\\n\\n\\t\\t\\t\\tinitMaterial( material, fog, object );\\n\\t\\t\\t\\tmaterial.needsUpdate = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar refreshProgram = false;\\n\\t\\t\\tvar refreshMaterial = false;\\n\\t\\t\\tvar refreshLights = false;\\n\\n\\t\\t\\tvar program = materialProperties.program,\\n\\t\\t\\t\\tp_uniforms = program.getUniforms(),\\n\\t\\t\\t\\tm_uniforms = materialProperties.shader.uniforms;\\n\\n\\t\\t\\tif ( state.useProgram( program.program ) ) {\\n\\n\\t\\t\\t\\trefreshProgram = true;\\n\\t\\t\\t\\trefreshMaterial = true;\\n\\t\\t\\t\\trefreshLights = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.id !== _currentMaterialId ) {\\n\\n\\t\\t\\t\\t_currentMaterialId = material.id;\\n\\n\\t\\t\\t\\trefreshMaterial = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( refreshProgram || camera !== _currentCamera ) {\\n\\n\\t\\t\\t\\tp_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );\\n\\n\\t\\t\\t\\tif ( capabilities.logarithmicDepthBuffer ) {\\n\\n\\t\\t\\t\\t\\tp_uniforms.setValue( _gl, 'logDepthBufFC',\\n\\t\\t\\t\\t\\t\\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Avoid unneeded uniform updates per ArrayCamera's sub-camera\\n\\n\\t\\t\\t\\tif ( _currentCamera !== ( _currentArrayCamera || camera ) ) {\\n\\n\\t\\t\\t\\t\\t_currentCamera = ( _currentArrayCamera || camera );\\n\\n\\t\\t\\t\\t\\t// lighting uniforms depend on the camera so enforce an update\\n\\t\\t\\t\\t\\t// now, in case this material supports lights - or later, when\\n\\t\\t\\t\\t\\t// the next material that does gets activated:\\n\\n\\t\\t\\t\\t\\trefreshMaterial = true;\\t\\t// set to true on material change\\n\\t\\t\\t\\t\\trefreshLights = true;\\t\\t// remains set until update done\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// load material specific uniforms\\n\\t\\t\\t\\t// (shader material also gets them for the sake of genericity)\\n\\n\\t\\t\\t\\tif ( material.isShaderMaterial ||\\n\\t\\t\\t\\t\\tmaterial.isMeshPhongMaterial ||\\n\\t\\t\\t\\t\\tmaterial.isMeshStandardMaterial ||\\n\\t\\t\\t\\t\\tmaterial.envMap ) {\\n\\n\\t\\t\\t\\t\\tvar uCamPos = p_uniforms.map.cameraPosition;\\n\\n\\t\\t\\t\\t\\tif ( uCamPos !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tuCamPos.setValue( _gl,\\n\\t\\t\\t\\t\\t\\t\\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( material.isMeshPhongMaterial ||\\n\\t\\t\\t\\t\\tmaterial.isMeshLambertMaterial ||\\n\\t\\t\\t\\t\\tmaterial.isMeshBasicMaterial ||\\n\\t\\t\\t\\t\\tmaterial.isMeshStandardMaterial ||\\n\\t\\t\\t\\t\\tmaterial.isShaderMaterial ||\\n\\t\\t\\t\\t\\tmaterial.skinning ) {\\n\\n\\t\\t\\t\\t\\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// skinning uniforms must be set even if material didn't change\\n\\t\\t\\t// auto-setting of texture unit for bone texture must go before other textures\\n\\t\\t\\t// not sure why, but otherwise weird things happen\\n\\n\\t\\t\\tif ( material.skinning ) {\\n\\n\\t\\t\\t\\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\\n\\t\\t\\t\\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\\n\\n\\t\\t\\t\\tvar skeleton = object.skeleton;\\n\\n\\t\\t\\t\\tif ( skeleton ) {\\n\\n\\t\\t\\t\\t\\tvar bones = skeleton.bones;\\n\\n\\t\\t\\t\\t\\tif ( capabilities.floatVertexTextures ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( skeleton.boneTexture === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// layout (1 matrix = 4 pixels)\\n\\t\\t\\t\\t\\t\\t\\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\\n\\t\\t\\t\\t\\t\\t\\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\\n\\t\\t\\t\\t\\t\\t\\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\\n\\t\\t\\t\\t\\t\\t\\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\\n\\t\\t\\t\\t\\t\\t\\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\\n\\n\\n\\t\\t\\t\\t\\t\\t\\tvar size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix\\n\\t\\t\\t\\t\\t\\t\\tsize = _Math.ceilPowerOfTwo( size );\\n\\t\\t\\t\\t\\t\\t\\tsize = Math.max( size, 4 );\\n\\n\\t\\t\\t\\t\\t\\t\\tvar boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel\\n\\t\\t\\t\\t\\t\\t\\tboneMatrices.set( skeleton.boneMatrices ); // copy current values\\n\\n\\t\\t\\t\\t\\t\\t\\tvar boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );\\n\\n\\t\\t\\t\\t\\t\\t\\tskeleton.boneMatrices = boneMatrices;\\n\\t\\t\\t\\t\\t\\t\\tskeleton.boneTexture = boneTexture;\\n\\t\\t\\t\\t\\t\\t\\tskeleton.boneTextureSize = size;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tp_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture );\\n\\t\\t\\t\\t\\t\\tp_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( refreshMaterial ) {\\n\\n\\t\\t\\t\\tp_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );\\n\\t\\t\\t\\tp_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );\\n\\n\\t\\t\\t\\tif ( material.lights ) {\\n\\n\\t\\t\\t\\t\\t// the current material requires lighting info\\n\\n\\t\\t\\t\\t\\t// note: all lighting uniforms are always set correctly\\n\\t\\t\\t\\t\\t// they simply reference the renderer's state for their\\n\\t\\t\\t\\t\\t// values\\n\\t\\t\\t\\t\\t//\\n\\t\\t\\t\\t\\t// use the current material's .needsUpdate flags to set\\n\\t\\t\\t\\t\\t// the GL state when required\\n\\n\\t\\t\\t\\t\\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// refresh uniforms common to several materials\\n\\n\\t\\t\\t\\tif ( fog && material.fog ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsFog( m_uniforms, fog );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( material.isMeshBasicMaterial ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsCommon( m_uniforms, material );\\n\\n\\t\\t\\t\\t} else if ( material.isMeshLambertMaterial ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsCommon( m_uniforms, material );\\n\\t\\t\\t\\t\\trefreshUniformsLambert( m_uniforms, material );\\n\\n\\t\\t\\t\\t} else if ( material.isMeshPhongMaterial ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsCommon( m_uniforms, material );\\n\\n\\t\\t\\t\\t\\tif ( material.isMeshToonMaterial ) {\\n\\n\\t\\t\\t\\t\\t\\trefreshUniformsToon( m_uniforms, material );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\trefreshUniformsPhong( m_uniforms, material );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( material.isMeshStandardMaterial ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsCommon( m_uniforms, material );\\n\\n\\t\\t\\t\\t\\tif ( material.isMeshPhysicalMaterial ) {\\n\\n\\t\\t\\t\\t\\t\\trefreshUniformsPhysical( m_uniforms, material );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\trefreshUniformsStandard( m_uniforms, material );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( material.isMeshDepthMaterial ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsCommon( m_uniforms, material );\\n\\t\\t\\t\\t\\trefreshUniformsDepth( m_uniforms, material );\\n\\n\\t\\t\\t\\t} else if ( material.isMeshDistanceMaterial ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsCommon( m_uniforms, material );\\n\\t\\t\\t\\t\\trefreshUniformsDistance( m_uniforms, material );\\n\\n\\t\\t\\t\\t} else if ( material.isMeshNormalMaterial ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsCommon( m_uniforms, material );\\n\\t\\t\\t\\t\\trefreshUniformsNormal( m_uniforms, material );\\n\\n\\t\\t\\t\\t} else if ( material.isLineBasicMaterial ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsLine( m_uniforms, material );\\n\\n\\t\\t\\t\\t\\tif ( material.isLineDashedMaterial ) {\\n\\n\\t\\t\\t\\t\\t\\trefreshUniformsDash( m_uniforms, material );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( material.isPointsMaterial ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsPoints( m_uniforms, material );\\n\\n\\t\\t\\t\\t} else if ( material.isShadowMaterial ) {\\n\\n\\t\\t\\t\\t\\tm_uniforms.color.value = material.color;\\n\\t\\t\\t\\t\\tm_uniforms.opacity.value = material.opacity;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// RectAreaLight Texture\\n\\t\\t\\t\\t// TODO (mrdoob): Find a nicer implementation\\n\\n\\t\\t\\t\\tif ( m_uniforms.ltcMat !== undefined ) m_uniforms.ltcMat.value = UniformsLib.LTC_MAT_TEXTURE;\\n\\t\\t\\t\\tif ( m_uniforms.ltcMag !== undefined ) m_uniforms.ltcMag.value = UniformsLib.LTC_MAG_TEXTURE;\\n\\n\\t\\t\\t\\tWebGLUniforms.upload(\\n\\t\\t\\t\\t\\t_gl, materialProperties.uniformsList, m_uniforms, _this );\\n\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\t// common matrices\\n\\n\\t\\t\\tp_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );\\n\\t\\t\\tp_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );\\n\\t\\t\\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\\n\\n\\t\\t\\treturn program;\\n\\n\\t\\t}\\n\\n\\t\\t// Uniforms (refresh uniforms objects)\\n\\n\\t\\tfunction refreshUniformsCommon( uniforms, material ) {\\n\\n\\t\\t\\tuniforms.opacity.value = material.opacity;\\n\\n\\t\\t\\tif ( material.color ) {\\n\\n\\t\\t\\t\\tuniforms.diffuse.value = material.color;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.emissive ) {\\n\\n\\t\\t\\t\\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.map ) {\\n\\n\\t\\t\\t\\tuniforms.map.value = material.map;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.alphaMap ) {\\n\\n\\t\\t\\t\\tuniforms.alphaMap.value = material.alphaMap;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.specularMap ) {\\n\\n\\t\\t\\t\\tuniforms.specularMap.value = material.specularMap;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.envMap ) {\\n\\n\\t\\t\\t\\tuniforms.envMap.value = material.envMap;\\n\\n\\t\\t\\t\\t// don't flip CubeTexture envMaps, flip everything else:\\n\\t\\t\\t\\t//  WebGLRenderTargetCube will be flipped for backwards compatibility\\n\\t\\t\\t\\t//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\\n\\t\\t\\t\\t// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\\n\\t\\t\\t\\tuniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;\\n\\n\\t\\t\\t\\tuniforms.reflectivity.value = material.reflectivity;\\n\\t\\t\\t\\tuniforms.refractionRatio.value = material.refractionRatio;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.lightMap ) {\\n\\n\\t\\t\\t\\tuniforms.lightMap.value = material.lightMap;\\n\\t\\t\\t\\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.aoMap ) {\\n\\n\\t\\t\\t\\tuniforms.aoMap.value = material.aoMap;\\n\\t\\t\\t\\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// uv repeat and offset setting priorities\\n\\t\\t\\t// 1. color map\\n\\t\\t\\t// 2. specular map\\n\\t\\t\\t// 3. normal map\\n\\t\\t\\t// 4. bump map\\n\\t\\t\\t// 5. alpha map\\n\\t\\t\\t// 6. emissive map\\n\\n\\t\\t\\tvar uvScaleMap;\\n\\n\\t\\t\\tif ( material.map ) {\\n\\n\\t\\t\\t\\tuvScaleMap = material.map;\\n\\n\\t\\t\\t} else if ( material.specularMap ) {\\n\\n\\t\\t\\t\\tuvScaleMap = material.specularMap;\\n\\n\\t\\t\\t} else if ( material.displacementMap ) {\\n\\n\\t\\t\\t\\tuvScaleMap = material.displacementMap;\\n\\n\\t\\t\\t} else if ( material.normalMap ) {\\n\\n\\t\\t\\t\\tuvScaleMap = material.normalMap;\\n\\n\\t\\t\\t} else if ( material.bumpMap ) {\\n\\n\\t\\t\\t\\tuvScaleMap = material.bumpMap;\\n\\n\\t\\t\\t} else if ( material.roughnessMap ) {\\n\\n\\t\\t\\t\\tuvScaleMap = material.roughnessMap;\\n\\n\\t\\t\\t} else if ( material.metalnessMap ) {\\n\\n\\t\\t\\t\\tuvScaleMap = material.metalnessMap;\\n\\n\\t\\t\\t} else if ( material.alphaMap ) {\\n\\n\\t\\t\\t\\tuvScaleMap = material.alphaMap;\\n\\n\\t\\t\\t} else if ( material.emissiveMap ) {\\n\\n\\t\\t\\t\\tuvScaleMap = material.emissiveMap;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( uvScaleMap !== undefined ) {\\n\\n\\t\\t\\t\\t// backwards compatibility\\n\\t\\t\\t\\tif ( uvScaleMap.isWebGLRenderTarget ) {\\n\\n\\t\\t\\t\\t\\tuvScaleMap = uvScaleMap.texture;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( uvScaleMap.matrixAutoUpdate === true ) {\\n\\n\\t\\t\\t\\t\\tvar offset = uvScaleMap.offset;\\n\\t\\t\\t\\t\\tvar repeat = uvScaleMap.repeat;\\n\\t\\t\\t\\t\\tvar rotation = uvScaleMap.rotation;\\n\\t\\t\\t\\t\\tvar center = uvScaleMap.center;\\n\\n\\t\\t\\t\\t\\tuvScaleMap.matrix.setUvTransform( offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tuniforms.uvTransform.value.copy( uvScaleMap.matrix );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsLine( uniforms, material ) {\\n\\n\\t\\t\\tuniforms.diffuse.value = material.color;\\n\\t\\t\\tuniforms.opacity.value = material.opacity;\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsDash( uniforms, material ) {\\n\\n\\t\\t\\tuniforms.dashSize.value = material.dashSize;\\n\\t\\t\\tuniforms.totalSize.value = material.dashSize + material.gapSize;\\n\\t\\t\\tuniforms.scale.value = material.scale;\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsPoints( uniforms, material ) {\\n\\n\\t\\t\\tuniforms.diffuse.value = material.color;\\n\\t\\t\\tuniforms.opacity.value = material.opacity;\\n\\t\\t\\tuniforms.size.value = material.size * _pixelRatio;\\n\\t\\t\\tuniforms.scale.value = _height * 0.5;\\n\\n\\t\\t\\tuniforms.map.value = material.map;\\n\\n\\t\\t\\tif ( material.map !== null ) {\\n\\n\\t\\t\\t\\tif ( material.map.matrixAutoUpdate === true ) {\\n\\n\\t\\t\\t\\t\\tvar offset = material.map.offset;\\n\\t\\t\\t\\t\\tvar repeat = material.map.repeat;\\n\\t\\t\\t\\t\\tvar rotation = material.map.rotation;\\n\\t\\t\\t\\t\\tvar center = material.map.center;\\n\\n\\t\\t\\t\\t\\tmaterial.map.matrix.setUvTransform( offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tuniforms.uvTransform.value.copy( material.map.matrix );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsFog( uniforms, fog ) {\\n\\n\\t\\t\\tuniforms.fogColor.value = fog.color;\\n\\n\\t\\t\\tif ( fog.isFog ) {\\n\\n\\t\\t\\t\\tuniforms.fogNear.value = fog.near;\\n\\t\\t\\t\\tuniforms.fogFar.value = fog.far;\\n\\n\\t\\t\\t} else if ( fog.isFogExp2 ) {\\n\\n\\t\\t\\t\\tuniforms.fogDensity.value = fog.density;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsLambert( uniforms, material ) {\\n\\n\\t\\t\\tif ( material.emissiveMap ) {\\n\\n\\t\\t\\t\\tuniforms.emissiveMap.value = material.emissiveMap;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsPhong( uniforms, material ) {\\n\\n\\t\\t\\tuniforms.specular.value = material.specular;\\n\\t\\t\\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\\n\\n\\t\\t\\tif ( material.emissiveMap ) {\\n\\n\\t\\t\\t\\tuniforms.emissiveMap.value = material.emissiveMap;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.bumpMap ) {\\n\\n\\t\\t\\t\\tuniforms.bumpMap.value = material.bumpMap;\\n\\t\\t\\t\\tuniforms.bumpScale.value = material.bumpScale;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.normalMap ) {\\n\\n\\t\\t\\t\\tuniforms.normalMap.value = material.normalMap;\\n\\t\\t\\t\\tuniforms.normalScale.value.copy( material.normalScale );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.displacementMap ) {\\n\\n\\t\\t\\t\\tuniforms.displacementMap.value = material.displacementMap;\\n\\t\\t\\t\\tuniforms.displacementScale.value = material.displacementScale;\\n\\t\\t\\t\\tuniforms.displacementBias.value = material.displacementBias;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsToon( uniforms, material ) {\\n\\n\\t\\t\\trefreshUniformsPhong( uniforms, material );\\n\\n\\t\\t\\tif ( material.gradientMap ) {\\n\\n\\t\\t\\t\\tuniforms.gradientMap.value = material.gradientMap;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsStandard( uniforms, material ) {\\n\\n\\t\\t\\tuniforms.roughness.value = material.roughness;\\n\\t\\t\\tuniforms.metalness.value = material.metalness;\\n\\n\\t\\t\\tif ( material.roughnessMap ) {\\n\\n\\t\\t\\t\\tuniforms.roughnessMap.value = material.roughnessMap;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.metalnessMap ) {\\n\\n\\t\\t\\t\\tuniforms.metalnessMap.value = material.metalnessMap;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.emissiveMap ) {\\n\\n\\t\\t\\t\\tuniforms.emissiveMap.value = material.emissiveMap;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.bumpMap ) {\\n\\n\\t\\t\\t\\tuniforms.bumpMap.value = material.bumpMap;\\n\\t\\t\\t\\tuniforms.bumpScale.value = material.bumpScale;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.normalMap ) {\\n\\n\\t\\t\\t\\tuniforms.normalMap.value = material.normalMap;\\n\\t\\t\\t\\tuniforms.normalScale.value.copy( material.normalScale );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.displacementMap ) {\\n\\n\\t\\t\\t\\tuniforms.displacementMap.value = material.displacementMap;\\n\\t\\t\\t\\tuniforms.displacementScale.value = material.displacementScale;\\n\\t\\t\\t\\tuniforms.displacementBias.value = material.displacementBias;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.envMap ) {\\n\\n\\t\\t\\t\\t//uniforms.envMap.value = material.envMap; // part of uniforms common\\n\\t\\t\\t\\tuniforms.envMapIntensity.value = material.envMapIntensity;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsPhysical( uniforms, material ) {\\n\\n\\t\\t\\tuniforms.clearCoat.value = material.clearCoat;\\n\\t\\t\\tuniforms.clearCoatRoughness.value = material.clearCoatRoughness;\\n\\n\\t\\t\\trefreshUniformsStandard( uniforms, material );\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsDepth( uniforms, material ) {\\n\\n\\t\\t\\tif ( material.displacementMap ) {\\n\\n\\t\\t\\t\\tuniforms.displacementMap.value = material.displacementMap;\\n\\t\\t\\t\\tuniforms.displacementScale.value = material.displacementScale;\\n\\t\\t\\t\\tuniforms.displacementBias.value = material.displacementBias;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsDistance( uniforms, material ) {\\n\\n\\t\\t\\tif ( material.displacementMap ) {\\n\\n\\t\\t\\t\\tuniforms.displacementMap.value = material.displacementMap;\\n\\t\\t\\t\\tuniforms.displacementScale.value = material.displacementScale;\\n\\t\\t\\t\\tuniforms.displacementBias.value = material.displacementBias;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tuniforms.referencePosition.value.copy( material.referencePosition );\\n\\t\\t\\tuniforms.nearDistance.value = material.nearDistance;\\n\\t\\t\\tuniforms.farDistance.value = material.farDistance;\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsNormal( uniforms, material ) {\\n\\n\\t\\t\\tif ( material.bumpMap ) {\\n\\n\\t\\t\\t\\tuniforms.bumpMap.value = material.bumpMap;\\n\\t\\t\\t\\tuniforms.bumpScale.value = material.bumpScale;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.normalMap ) {\\n\\n\\t\\t\\t\\tuniforms.normalMap.value = material.normalMap;\\n\\t\\t\\t\\tuniforms.normalScale.value.copy( material.normalScale );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.displacementMap ) {\\n\\n\\t\\t\\t\\tuniforms.displacementMap.value = material.displacementMap;\\n\\t\\t\\t\\tuniforms.displacementScale.value = material.displacementScale;\\n\\t\\t\\t\\tuniforms.displacementBias.value = material.displacementBias;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\\n\\n\\t\\tfunction markUniformsLightsNeedsUpdate( uniforms, value ) {\\n\\n\\t\\t\\tuniforms.ambientLightColor.needsUpdate = value;\\n\\n\\t\\t\\tuniforms.directionalLights.needsUpdate = value;\\n\\t\\t\\tuniforms.pointLights.needsUpdate = value;\\n\\t\\t\\tuniforms.spotLights.needsUpdate = value;\\n\\t\\t\\tuniforms.rectAreaLights.needsUpdate = value;\\n\\t\\t\\tuniforms.hemisphereLights.needsUpdate = value;\\n\\n\\t\\t}\\n\\n\\t\\t// GL state setting\\n\\n\\t\\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\\n\\n\\t\\t\\tstate.setCullFace( cullFace );\\n\\t\\t\\tstate.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );\\n\\n\\t\\t};\\n\\n\\t\\t// Textures\\n\\n\\t\\tfunction allocTextureUnit() {\\n\\n\\t\\t\\tvar textureUnit = _usedTextureUnits;\\n\\n\\t\\t\\tif ( textureUnit >= capabilities.maxTextures ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t_usedTextureUnits += 1;\\n\\n\\t\\t\\treturn textureUnit;\\n\\n\\t\\t}\\n\\n\\t\\tthis.allocTextureUnit = allocTextureUnit;\\n\\n\\t\\t// this.setTexture2D = setTexture2D;\\n\\t\\tthis.setTexture2D = ( function () {\\n\\n\\t\\t\\tvar warned = false;\\n\\n\\t\\t\\t// backwards compatibility: peel texture.texture\\n\\t\\t\\treturn function setTexture2D( texture, slot ) {\\n\\n\\t\\t\\t\\tif ( texture && texture.isWebGLRenderTarget ) {\\n\\n\\t\\t\\t\\t\\tif ( ! warned ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( \\\"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\\\" );\\n\\t\\t\\t\\t\\t\\twarned = true;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ttexture = texture.texture;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttextures.setTexture2D( texture, slot );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}() );\\n\\n\\t\\tthis.setTexture = ( function () {\\n\\n\\t\\t\\tvar warned = false;\\n\\n\\t\\t\\treturn function setTexture( texture, slot ) {\\n\\n\\t\\t\\t\\tif ( ! warned ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( \\\"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\\\" );\\n\\t\\t\\t\\t\\twarned = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttextures.setTexture2D( texture, slot );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}() );\\n\\n\\t\\tthis.setTextureCube = ( function () {\\n\\n\\t\\t\\tvar warned = false;\\n\\n\\t\\t\\treturn function setTextureCube( texture, slot ) {\\n\\n\\t\\t\\t\\t// backwards compatibility: peel texture.texture\\n\\t\\t\\t\\tif ( texture && texture.isWebGLRenderTargetCube ) {\\n\\n\\t\\t\\t\\t\\tif ( ! warned ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( \\\"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\\\" );\\n\\t\\t\\t\\t\\t\\twarned = true;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ttexture = texture.texture;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\\n\\t\\t\\t\\t// TODO: unify these code paths\\n\\t\\t\\t\\tif ( ( texture && texture.isCubeTexture ) ||\\n\\t\\t\\t\\t\\t( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\\n\\n\\t\\t\\t\\t\\t// CompressedTexture can have Array in image :/\\n\\n\\t\\t\\t\\t\\t// this function alone should take care of cube textures\\n\\t\\t\\t\\t\\ttextures.setTextureCube( texture, slot );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// assumed: texture property of THREE.WebGLRenderTargetCube\\n\\n\\t\\t\\t\\t\\ttextures.setTextureCubeDynamic( texture, slot );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}() );\\n\\n\\t\\tthis.getRenderTarget = function () {\\n\\n\\t\\t\\treturn _currentRenderTarget;\\n\\n\\t\\t};\\n\\n\\t\\tthis.setRenderTarget = function ( renderTarget ) {\\n\\n\\t\\t\\t_currentRenderTarget = renderTarget;\\n\\n\\t\\t\\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\\n\\n\\t\\t\\t\\ttextures.setupRenderTarget( renderTarget );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar framebuffer = null;\\n\\t\\t\\tvar isCube = false;\\n\\n\\t\\t\\tif ( renderTarget ) {\\n\\n\\t\\t\\t\\tvar __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;\\n\\n\\t\\t\\t\\tif ( renderTarget.isWebGLRenderTargetCube ) {\\n\\n\\t\\t\\t\\t\\tframebuffer = __webglFramebuffer[ renderTarget.activeCubeFace ];\\n\\t\\t\\t\\t\\tisCube = true;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tframebuffer = __webglFramebuffer;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t_currentViewport.copy( renderTarget.viewport );\\n\\t\\t\\t\\t_currentScissor.copy( renderTarget.scissor );\\n\\t\\t\\t\\t_currentScissorTest = renderTarget.scissorTest;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\\n\\t\\t\\t\\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\\n\\t\\t\\t\\t_currentScissorTest = _scissorTest;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( _currentFramebuffer !== framebuffer ) {\\n\\n\\t\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\\n\\t\\t\\t\\t_currentFramebuffer = framebuffer;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tstate.viewport( _currentViewport );\\n\\t\\t\\tstate.scissor( _currentScissor );\\n\\t\\t\\tstate.setScissorTest( _currentScissorTest );\\n\\n\\t\\t\\tif ( isCube ) {\\n\\n\\t\\t\\t\\tvar textureProperties = properties.get( renderTarget.texture );\\n\\t\\t\\t\\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\\n\\n\\t\\t\\tif ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\\n\\n\\t\\t\\tif ( framebuffer ) {\\n\\n\\t\\t\\t\\tvar restore = false;\\n\\n\\t\\t\\t\\tif ( framebuffer !== _currentFramebuffer ) {\\n\\n\\t\\t\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\\n\\n\\t\\t\\t\\t\\trestore = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttry {\\n\\n\\t\\t\\t\\t\\tvar texture = renderTarget.texture;\\n\\t\\t\\t\\t\\tvar textureFormat = texture.format;\\n\\t\\t\\t\\t\\tvar textureType = texture.type;\\n\\n\\t\\t\\t\\t\\tif ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\\n\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)\\n\\t\\t\\t\\t\\t\\t! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox\\n\\t\\t\\t\\t\\t\\t! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\\n\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\\n\\n\\t\\t\\t\\t\\t\\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\\n\\n\\t\\t\\t\\t\\t\\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} finally {\\n\\n\\t\\t\\t\\t\\tif ( restore ) {\\n\\n\\t\\t\\t\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction FogExp2( color, density ) {\\n\\n\\t\\tthis.name = '';\\n\\n\\t\\tthis.color = new Color( color );\\n\\t\\tthis.density = ( density !== undefined ) ? density : 0.00025;\\n\\n\\t}\\n\\n\\tFogExp2.prototype.isFogExp2 = true;\\n\\n\\tFogExp2.prototype.clone = function () {\\n\\n\\t\\treturn new FogExp2( this.color.getHex(), this.density );\\n\\n\\t};\\n\\n\\tFogExp2.prototype.toJSON = function ( /* meta */ ) {\\n\\n\\t\\treturn {\\n\\t\\t\\ttype: 'FogExp2',\\n\\t\\t\\tcolor: this.color.getHex(),\\n\\t\\t\\tdensity: this.density\\n\\t\\t};\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction Fog( color, near, far ) {\\n\\n\\t\\tthis.name = '';\\n\\n\\t\\tthis.color = new Color( color );\\n\\n\\t\\tthis.near = ( near !== undefined ) ? near : 1;\\n\\t\\tthis.far = ( far !== undefined ) ? far : 1000;\\n\\n\\t}\\n\\n\\tFog.prototype.isFog = true;\\n\\n\\tFog.prototype.clone = function () {\\n\\n\\t\\treturn new Fog( this.color.getHex(), this.near, this.far );\\n\\n\\t};\\n\\n\\tFog.prototype.toJSON = function ( /* meta */ ) {\\n\\n\\t\\treturn {\\n\\t\\t\\ttype: 'Fog',\\n\\t\\t\\tcolor: this.color.getHex(),\\n\\t\\t\\tnear: this.near,\\n\\t\\t\\tfar: this.far\\n\\t\\t};\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction Scene() {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Scene';\\n\\n\\t\\tthis.background = null;\\n\\t\\tthis.fog = null;\\n\\t\\tthis.overrideMaterial = null;\\n\\n\\t\\tthis.autoUpdate = true; // checked by the renderer\\n\\n\\t}\\n\\n\\tScene.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Scene,\\n\\n\\t\\tcopy: function ( source, recursive ) {\\n\\n\\t\\t\\tObject3D.prototype.copy.call( this, source, recursive );\\n\\n\\t\\t\\tif ( source.background !== null ) this.background = source.background.clone();\\n\\t\\t\\tif ( source.fog !== null ) this.fog = source.fog.clone();\\n\\t\\t\\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\\n\\n\\t\\t\\tthis.autoUpdate = source.autoUpdate;\\n\\t\\t\\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( meta ) {\\n\\n\\t\\t\\tvar data = Object3D.prototype.toJSON.call( this, meta );\\n\\n\\t\\t\\tif ( this.background !== null ) data.object.background = this.background.toJSON( meta );\\n\\t\\t\\tif ( this.fog !== null ) data.object.fog = this.fog.toJSON();\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction LensFlare( texture, size, distance, blending, color ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.lensFlares = [];\\n\\n\\t\\tthis.positionScreen = new Vector3();\\n\\t\\tthis.customUpdateCallback = undefined;\\n\\n\\t\\tif ( texture !== undefined ) {\\n\\n\\t\\t\\tthis.add( texture, size, distance, blending, color );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tLensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: LensFlare,\\n\\n\\t\\tisLensFlare: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tObject3D.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.positionScreen.copy( source.positionScreen );\\n\\t\\t\\tthis.customUpdateCallback = source.customUpdateCallback;\\n\\n\\t\\t\\tfor ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tthis.lensFlares.push( source.lensFlares[ i ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tadd: function ( texture, size, distance, blending, color, opacity ) {\\n\\n\\t\\t\\tif ( size === undefined ) size = - 1;\\n\\t\\t\\tif ( distance === undefined ) distance = 0;\\n\\t\\t\\tif ( opacity === undefined ) opacity = 1;\\n\\t\\t\\tif ( color === undefined ) color = new Color( 0xffffff );\\n\\t\\t\\tif ( blending === undefined ) blending = NormalBlending;\\n\\n\\t\\t\\tdistance = Math.min( distance, Math.max( 0, distance ) );\\n\\n\\t\\t\\tthis.lensFlares.push( {\\n\\t\\t\\t\\ttexture: texture,\\t// THREE.Texture\\n\\t\\t\\t\\tsize: size, \\t\\t// size in pixels (-1 = use texture.width)\\n\\t\\t\\t\\tdistance: distance, \\t// distance (0-1) from light source (0=at light source)\\n\\t\\t\\t\\tx: 0, y: 0, z: 0,\\t// screen position (-1 => 1) z = 0 is in front z = 1 is back\\n\\t\\t\\t\\tscale: 1, \\t\\t// scale\\n\\t\\t\\t\\trotation: 0, \\t\\t// rotation\\n\\t\\t\\t\\topacity: opacity,\\t// opacity\\n\\t\\t\\t\\tcolor: color,\\t\\t// color\\n\\t\\t\\t\\tblending: blending\\t// blending\\n\\t\\t\\t} );\\n\\n\\t\\t},\\n\\n\\t\\t/*\\n\\t\\t * Update lens flares update positions on all flares based on the screen position\\n\\t\\t * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\\n\\t\\t */\\n\\n\\t\\tupdateLensFlares: function () {\\n\\n\\t\\t\\tvar f, fl = this.lensFlares.length;\\n\\t\\t\\tvar flare;\\n\\t\\t\\tvar vecX = - this.positionScreen.x * 2;\\n\\t\\t\\tvar vecY = - this.positionScreen.y * 2;\\n\\n\\t\\t\\tfor ( f = 0; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\tflare = this.lensFlares[ f ];\\n\\n\\t\\t\\t\\tflare.x = this.positionScreen.x + vecX * flare.distance;\\n\\t\\t\\t\\tflare.y = this.positionScreen.y + vecY * flare.distance;\\n\\n\\t\\t\\t\\tflare.wantedRotation = flare.x * Math.PI * 0.25;\\n\\t\\t\\t\\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t *\\n\\t * parameters = {\\n\\t *  color: <hex>,\\n\\t *  opacity: <float>,\\n\\t *  map: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *\\tuvOffset: new THREE.Vector2(),\\n\\t *\\tuvScale: new THREE.Vector2()\\n\\t * }\\n\\t */\\n\\n\\tfunction SpriteMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'SpriteMaterial';\\n\\n\\t\\tthis.color = new Color( 0xffffff );\\n\\t\\tthis.map = null;\\n\\n\\t\\tthis.rotation = 0;\\n\\n\\t\\tthis.fog = false;\\n\\t\\tthis.lights = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tSpriteMaterial.prototype = Object.create( Material.prototype );\\n\\tSpriteMaterial.prototype.constructor = SpriteMaterial;\\n\\tSpriteMaterial.prototype.isSpriteMaterial = true;\\n\\n\\tSpriteMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.color.copy( source.color );\\n\\t\\tthis.map = source.map;\\n\\n\\t\\tthis.rotation = source.rotation;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction Sprite( material ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Sprite';\\n\\n\\t\\tthis.material = ( material !== undefined ) ? material : new SpriteMaterial();\\n\\n\\t}\\n\\n\\tSprite.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Sprite,\\n\\n\\t\\tisSprite: true,\\n\\n\\t\\traycast: ( function () {\\n\\n\\t\\t\\tvar intersectPoint = new Vector3();\\n\\t\\t\\tvar worldPosition = new Vector3();\\n\\t\\t\\tvar worldScale = new Vector3();\\n\\n\\t\\t\\treturn function raycast( raycaster, intersects ) {\\n\\n\\t\\t\\t\\tworldPosition.setFromMatrixPosition( this.matrixWorld );\\n\\t\\t\\t\\traycaster.ray.closestPointToPoint( worldPosition, intersectPoint );\\n\\n\\t\\t\\t\\tworldScale.setFromMatrixScale( this.matrixWorld );\\n\\t\\t\\t\\tvar guessSizeSq = worldScale.x * worldScale.y / 4;\\n\\n\\t\\t\\t\\tif ( worldPosition.distanceToSquared( intersectPoint ) > guessSizeSq ) return;\\n\\n\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\\n\\n\\t\\t\\t\\tif ( distance < raycaster.near || distance > raycaster.far ) return;\\n\\n\\t\\t\\t\\tintersects.push( {\\n\\n\\t\\t\\t\\t\\tdistance: distance,\\n\\t\\t\\t\\t\\tpoint: intersectPoint.clone(),\\n\\t\\t\\t\\t\\tface: null,\\n\\t\\t\\t\\t\\tobject: this\\n\\n\\t\\t\\t\\t} );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}() ),\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.material ).copy( this );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction LOD() {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'LOD';\\n\\n\\t\\tObject.defineProperties( this, {\\n\\t\\t\\tlevels: {\\n\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t\\tvalue: []\\n\\t\\t\\t}\\n\\t\\t} );\\n\\n\\t}\\n\\n\\tLOD.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: LOD,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tObject3D.prototype.copy.call( this, source, false );\\n\\n\\t\\t\\tvar levels = source.levels;\\n\\n\\t\\t\\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar level = levels[ i ];\\n\\n\\t\\t\\t\\tthis.addLevel( level.object.clone(), level.distance );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddLevel: function ( object, distance ) {\\n\\n\\t\\t\\tif ( distance === undefined ) distance = 0;\\n\\n\\t\\t\\tdistance = Math.abs( distance );\\n\\n\\t\\t\\tvar levels = this.levels;\\n\\n\\t\\t\\tfor ( var l = 0; l < levels.length; l ++ ) {\\n\\n\\t\\t\\t\\tif ( distance < levels[ l ].distance ) {\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tlevels.splice( l, 0, { distance: distance, object: object } );\\n\\n\\t\\t\\tthis.add( object );\\n\\n\\t\\t},\\n\\n\\t\\tgetObjectForDistance: function ( distance ) {\\n\\n\\t\\t\\tvar levels = this.levels;\\n\\n\\t\\t\\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tif ( distance < levels[ i ].distance ) {\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn levels[ i - 1 ].object;\\n\\n\\t\\t},\\n\\n\\t\\traycast: ( function () {\\n\\n\\t\\t\\tvar matrixPosition = new Vector3();\\n\\n\\t\\t\\treturn function raycast( raycaster, intersects ) {\\n\\n\\t\\t\\t\\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\\n\\n\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\\n\\n\\t\\t\\t\\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}() ),\\n\\n\\t\\tupdate: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\t\\t\\tvar v2 = new Vector3();\\n\\n\\t\\t\\treturn function update( camera ) {\\n\\n\\t\\t\\t\\tvar levels = this.levels;\\n\\n\\t\\t\\t\\tif ( levels.length > 1 ) {\\n\\n\\t\\t\\t\\t\\tv1.setFromMatrixPosition( camera.matrixWorld );\\n\\t\\t\\t\\t\\tv2.setFromMatrixPosition( this.matrixWorld );\\n\\n\\t\\t\\t\\t\\tvar distance = v1.distanceTo( v2 );\\n\\n\\t\\t\\t\\t\\tlevels[ 0 ].object.visible = true;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( distance >= levels[ i ].distance ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tlevels[ i - 1 ].object.visible = false;\\n\\t\\t\\t\\t\\t\\t\\tlevels[ i ].object.visible = true;\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfor ( ; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tlevels[ i ].object.visible = false;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttoJSON: function ( meta ) {\\n\\n\\t\\t\\tvar data = Object3D.prototype.toJSON.call( this, meta );\\n\\n\\t\\t\\tdata.object.levels = [];\\n\\n\\t\\t\\tvar levels = this.levels;\\n\\n\\t\\t\\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar level = levels[ i ];\\n\\n\\t\\t\\t\\tdata.object.levels.push( {\\n\\t\\t\\t\\t\\tobject: level.object.uuid,\\n\\t\\t\\t\\t\\tdistance: level.distance\\n\\t\\t\\t\\t} );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author michael guerrero / http://realitymeltdown.com\\n\\t * @author ikerr / http://verold.com\\n\\t */\\n\\n\\tfunction Skeleton( bones, boneInverses ) {\\n\\n\\t\\t// copy the bone array\\n\\n\\t\\tbones = bones || [];\\n\\n\\t\\tthis.bones = bones.slice( 0 );\\n\\t\\tthis.boneMatrices = new Float32Array( this.bones.length * 16 );\\n\\n\\t\\t// use the supplied bone inverses or calculate the inverses\\n\\n\\t\\tif ( boneInverses === undefined ) {\\n\\n\\t\\t\\tthis.calculateInverses();\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tif ( this.bones.length === boneInverses.length ) {\\n\\n\\t\\t\\t\\tthis.boneInverses = boneInverses.slice( 0 );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Skeleton boneInverses is the wrong length.' );\\n\\n\\t\\t\\t\\tthis.boneInverses = [];\\n\\n\\t\\t\\t\\tfor ( var i = 0, il = this.bones.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\tthis.boneInverses.push( new Matrix4() );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tObject.assign( Skeleton.prototype, {\\n\\n\\t\\tcalculateInverses: function () {\\n\\n\\t\\t\\tthis.boneInverses = [];\\n\\n\\t\\t\\tfor ( var i = 0, il = this.bones.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar inverse = new Matrix4();\\n\\n\\t\\t\\t\\tif ( this.bones[ i ] ) {\\n\\n\\t\\t\\t\\t\\tinverse.getInverse( this.bones[ i ].matrixWorld );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.boneInverses.push( inverse );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tpose: function () {\\n\\n\\t\\t\\tvar bone, i, il;\\n\\n\\t\\t\\t// recover the bind-time world matrices\\n\\n\\t\\t\\tfor ( i = 0, il = this.bones.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tbone = this.bones[ i ];\\n\\n\\t\\t\\t\\tif ( bone ) {\\n\\n\\t\\t\\t\\t\\tbone.matrixWorld.getInverse( this.boneInverses[ i ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// compute the local matrices, positions, rotations and scales\\n\\n\\t\\t\\tfor ( i = 0, il = this.bones.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tbone = this.bones[ i ];\\n\\n\\t\\t\\t\\tif ( bone ) {\\n\\n\\t\\t\\t\\t\\tif ( bone.parent && bone.parent.isBone ) {\\n\\n\\t\\t\\t\\t\\t\\tbone.matrix.getInverse( bone.parent.matrixWorld );\\n\\t\\t\\t\\t\\t\\tbone.matrix.multiply( bone.matrixWorld );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tbone.matrix.copy( bone.matrixWorld );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tupdate: ( function () {\\n\\n\\t\\t\\tvar offsetMatrix = new Matrix4();\\n\\t\\t\\tvar identityMatrix = new Matrix4();\\n\\n\\t\\t\\treturn function update() {\\n\\n\\t\\t\\t\\tvar bones = this.bones;\\n\\t\\t\\t\\tvar boneInverses = this.boneInverses;\\n\\t\\t\\t\\tvar boneMatrices = this.boneMatrices;\\n\\t\\t\\t\\tvar boneTexture = this.boneTexture;\\n\\n\\t\\t\\t\\t// flatten bone matrices to array\\n\\n\\t\\t\\t\\tfor ( var i = 0, il = bones.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t// compute the offset between the current and the original transform\\n\\n\\t\\t\\t\\t\\tvar matrix = bones[ i ] ? bones[ i ].matrixWorld : identityMatrix;\\n\\n\\t\\t\\t\\t\\toffsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );\\n\\t\\t\\t\\t\\toffsetMatrix.toArray( boneMatrices, i * 16 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( boneTexture !== undefined ) {\\n\\n\\t\\t\\t\\t\\tboneTexture.needsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )(),\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new Skeleton( this.bones, this.boneInverses );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author ikerr / http://verold.com\\n\\t */\\n\\n\\tfunction Bone() {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Bone';\\n\\n\\t}\\n\\n\\tBone.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Bone,\\n\\n\\t\\tisBone: true\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author ikerr / http://verold.com\\n\\t */\\n\\n\\tfunction SkinnedMesh( geometry, material ) {\\n\\n\\t\\tMesh.call( this, geometry, material );\\n\\n\\t\\tthis.type = 'SkinnedMesh';\\n\\n\\t\\tthis.bindMode = 'attached';\\n\\t\\tthis.bindMatrix = new Matrix4();\\n\\t\\tthis.bindMatrixInverse = new Matrix4();\\n\\n\\t\\tvar bones = this.initBones();\\n\\t\\tvar skeleton = new Skeleton( bones );\\n\\n\\t\\tthis.bind( skeleton, this.matrixWorld );\\n\\n\\t\\tthis.normalizeSkinWeights();\\n\\n\\t}\\n\\n\\tSkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {\\n\\n\\t\\tconstructor: SkinnedMesh,\\n\\n\\t\\tisSkinnedMesh: true,\\n\\n\\t\\tinitBones: function () {\\n\\n\\t\\t\\tvar bones = [], bone, gbone;\\n\\t\\t\\tvar i, il;\\n\\n\\t\\t\\tif ( this.geometry && this.geometry.bones !== undefined ) {\\n\\n\\t\\t\\t\\t// first, create array of 'Bone' objects from geometry data\\n\\n\\t\\t\\t\\tfor ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\tgbone = this.geometry.bones[ i ];\\n\\n\\t\\t\\t\\t\\t// create new 'Bone' object\\n\\n\\t\\t\\t\\t\\tbone = new Bone();\\n\\t\\t\\t\\t\\tbones.push( bone );\\n\\n\\t\\t\\t\\t\\t// apply values\\n\\n\\t\\t\\t\\t\\tbone.name = gbone.name;\\n\\t\\t\\t\\t\\tbone.position.fromArray( gbone.pos );\\n\\t\\t\\t\\t\\tbone.quaternion.fromArray( gbone.rotq );\\n\\t\\t\\t\\t\\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// second, create bone hierarchy\\n\\n\\t\\t\\t\\tfor ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\tgbone = this.geometry.bones[ i ];\\n\\n\\t\\t\\t\\t\\tif ( ( gbone.parent !== - 1 ) && ( gbone.parent !== null ) && ( bones[ gbone.parent ] !== undefined ) ) {\\n\\n\\t\\t\\t\\t\\t\\t// subsequent bones in the hierarchy\\n\\n\\t\\t\\t\\t\\t\\tbones[ gbone.parent ].add( bones[ i ] );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t// topmost bone, immediate child of the skinned mesh\\n\\n\\t\\t\\t\\t\\t\\tthis.add( bones[ i ] );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// now the bones are part of the scene graph and children of the skinned mesh.\\n\\t\\t\\t// let's update the corresponding matrices\\n\\n\\t\\t\\tthis.updateMatrixWorld( true );\\n\\n\\t\\t\\treturn bones;\\n\\n\\t\\t},\\n\\n\\t\\tbind: function ( skeleton, bindMatrix ) {\\n\\n\\t\\t\\tthis.skeleton = skeleton;\\n\\n\\t\\t\\tif ( bindMatrix === undefined ) {\\n\\n\\t\\t\\t\\tthis.updateMatrixWorld( true );\\n\\n\\t\\t\\t\\tthis.skeleton.calculateInverses();\\n\\n\\t\\t\\t\\tbindMatrix = this.matrixWorld;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.bindMatrix.copy( bindMatrix );\\n\\t\\t\\tthis.bindMatrixInverse.getInverse( bindMatrix );\\n\\n\\t\\t},\\n\\n\\t\\tpose: function () {\\n\\n\\t\\t\\tthis.skeleton.pose();\\n\\n\\t\\t},\\n\\n\\t\\tnormalizeSkinWeights: function () {\\n\\n\\t\\t\\tvar scale, i;\\n\\n\\t\\t\\tif ( this.geometry && this.geometry.isGeometry ) {\\n\\n\\t\\t\\t\\tfor ( i = 0; i < this.geometry.skinWeights.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar sw = this.geometry.skinWeights[ i ];\\n\\n\\t\\t\\t\\t\\tscale = 1.0 / sw.manhattanLength();\\n\\n\\t\\t\\t\\t\\tif ( scale !== Infinity ) {\\n\\n\\t\\t\\t\\t\\t\\tsw.multiplyScalar( scale );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tsw.set( 1, 0, 0, 0 ); // do something reasonable\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( this.geometry && this.geometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\tvar vec = new Vector4();\\n\\n\\t\\t\\t\\tvar skinWeight = this.geometry.attributes.skinWeight;\\n\\n\\t\\t\\t\\tfor ( i = 0; i < skinWeight.count; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvec.x = skinWeight.getX( i );\\n\\t\\t\\t\\t\\tvec.y = skinWeight.getY( i );\\n\\t\\t\\t\\t\\tvec.z = skinWeight.getZ( i );\\n\\t\\t\\t\\t\\tvec.w = skinWeight.getW( i );\\n\\n\\t\\t\\t\\t\\tscale = 1.0 / vec.manhattanLength();\\n\\n\\t\\t\\t\\t\\tif ( scale !== Infinity ) {\\n\\n\\t\\t\\t\\t\\t\\tvec.multiplyScalar( scale );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tvec.set( 1, 0, 0, 0 ); // do something reasonable\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tskinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tupdateMatrixWorld: function ( force ) {\\n\\n\\t\\t\\tMesh.prototype.updateMatrixWorld.call( this, force );\\n\\n\\t\\t\\tif ( this.bindMode === 'attached' ) {\\n\\n\\t\\t\\t\\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\\n\\n\\t\\t\\t} else if ( this.bindMode === 'detached' ) {\\n\\n\\t\\t\\t\\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.geometry, this.material ).copy( this );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t *\\n\\t * parameters = {\\n\\t *  color: <hex>,\\n\\t *  opacity: <float>,\\n\\t *\\n\\t *  linewidth: <float>,\\n\\t *  linecap: \\\"round\\\",\\n\\t *  linejoin: \\\"round\\\"\\n\\t * }\\n\\t */\\n\\n\\tfunction LineBasicMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'LineBasicMaterial';\\n\\n\\t\\tthis.color = new Color( 0xffffff );\\n\\n\\t\\tthis.linewidth = 1;\\n\\t\\tthis.linecap = 'round';\\n\\t\\tthis.linejoin = 'round';\\n\\n\\t\\tthis.lights = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tLineBasicMaterial.prototype = Object.create( Material.prototype );\\n\\tLineBasicMaterial.prototype.constructor = LineBasicMaterial;\\n\\n\\tLineBasicMaterial.prototype.isLineBasicMaterial = true;\\n\\n\\tLineBasicMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.color.copy( source.color );\\n\\n\\t\\tthis.linewidth = source.linewidth;\\n\\t\\tthis.linecap = source.linecap;\\n\\t\\tthis.linejoin = source.linejoin;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction Line( geometry, material, mode ) {\\n\\n\\t\\tif ( mode === 1 ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\\n\\t\\t\\treturn new LineSegments( geometry, material );\\n\\n\\t\\t}\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Line';\\n\\n\\t\\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\\n\\t\\tthis.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );\\n\\n\\t}\\n\\n\\tLine.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Line,\\n\\n\\t\\tisLine: true,\\n\\n\\t\\traycast: ( function () {\\n\\n\\t\\t\\tvar inverseMatrix = new Matrix4();\\n\\t\\t\\tvar ray = new Ray();\\n\\t\\t\\tvar sphere = new Sphere();\\n\\n\\t\\t\\treturn function raycast( raycaster, intersects ) {\\n\\n\\t\\t\\t\\tvar precision = raycaster.linePrecision;\\n\\t\\t\\t\\tvar precisionSq = precision * precision;\\n\\n\\t\\t\\t\\tvar geometry = this.geometry;\\n\\t\\t\\t\\tvar matrixWorld = this.matrixWorld;\\n\\n\\t\\t\\t\\t// Checking boundingSphere distance to ray\\n\\n\\t\\t\\t\\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\\n\\n\\t\\t\\t\\tsphere.copy( geometry.boundingSphere );\\n\\t\\t\\t\\tsphere.applyMatrix4( matrixWorld );\\n\\n\\t\\t\\t\\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\\n\\n\\t\\t\\t\\t//\\n\\n\\t\\t\\t\\tinverseMatrix.getInverse( matrixWorld );\\n\\t\\t\\t\\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\\n\\n\\t\\t\\t\\tvar vStart = new Vector3();\\n\\t\\t\\t\\tvar vEnd = new Vector3();\\n\\t\\t\\t\\tvar interSegment = new Vector3();\\n\\t\\t\\t\\tvar interRay = new Vector3();\\n\\t\\t\\t\\tvar step = ( this && this.isLineSegments ) ? 2 : 1;\\n\\n\\t\\t\\t\\tif ( geometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\t\\tvar index = geometry.index;\\n\\t\\t\\t\\t\\tvar attributes = geometry.attributes;\\n\\t\\t\\t\\t\\tvar positions = attributes.position.array;\\n\\n\\t\\t\\t\\t\\tif ( index !== null ) {\\n\\n\\t\\t\\t\\t\\t\\tvar indices = index.array;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar a = indices[ i ];\\n\\t\\t\\t\\t\\t\\t\\tvar b = indices[ i + 1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\tvStart.fromArray( positions, a * 3 );\\n\\t\\t\\t\\t\\t\\t\\tvEnd.fromArray( positions, b * 3 );\\n\\n\\t\\t\\t\\t\\t\\t\\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( distSq > precisionSq ) continue;\\n\\n\\t\\t\\t\\t\\t\\t\\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\\n\\n\\t\\t\\t\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( interRay );\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\\n\\n\\t\\t\\t\\t\\t\\t\\tintersects.push( {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tdistance: distance,\\n\\t\\t\\t\\t\\t\\t\\t\\t// What do we want? intersection point on the ray or on the segment??\\n\\t\\t\\t\\t\\t\\t\\t\\t// point: raycaster.ray.at( distance ),\\n\\t\\t\\t\\t\\t\\t\\t\\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\\n\\t\\t\\t\\t\\t\\t\\t\\tindex: i,\\n\\t\\t\\t\\t\\t\\t\\t\\tface: null,\\n\\t\\t\\t\\t\\t\\t\\t\\tfaceIndex: null,\\n\\t\\t\\t\\t\\t\\t\\t\\tobject: this\\n\\n\\t\\t\\t\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvStart.fromArray( positions, 3 * i );\\n\\t\\t\\t\\t\\t\\t\\tvEnd.fromArray( positions, 3 * i + 3 );\\n\\n\\t\\t\\t\\t\\t\\t\\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( distSq > precisionSq ) continue;\\n\\n\\t\\t\\t\\t\\t\\t\\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\\n\\n\\t\\t\\t\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( interRay );\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\\n\\n\\t\\t\\t\\t\\t\\t\\tintersects.push( {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tdistance: distance,\\n\\t\\t\\t\\t\\t\\t\\t\\t// What do we want? intersection point on the ray or on the segment??\\n\\t\\t\\t\\t\\t\\t\\t\\t// point: raycaster.ray.at( distance ),\\n\\t\\t\\t\\t\\t\\t\\t\\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\\n\\t\\t\\t\\t\\t\\t\\t\\tindex: i,\\n\\t\\t\\t\\t\\t\\t\\t\\tface: null,\\n\\t\\t\\t\\t\\t\\t\\t\\tfaceIndex: null,\\n\\t\\t\\t\\t\\t\\t\\t\\tobject: this\\n\\n\\t\\t\\t\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( geometry.isGeometry ) {\\n\\n\\t\\t\\t\\t\\tvar vertices = geometry.vertices;\\n\\t\\t\\t\\t\\tvar nbVertices = vertices.length;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\\n\\n\\t\\t\\t\\t\\t\\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\\n\\n\\t\\t\\t\\t\\t\\tif ( distSq > precisionSq ) continue;\\n\\n\\t\\t\\t\\t\\t\\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\\n\\n\\t\\t\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( interRay );\\n\\n\\t\\t\\t\\t\\t\\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\\n\\n\\t\\t\\t\\t\\t\\tintersects.push( {\\n\\n\\t\\t\\t\\t\\t\\t\\tdistance: distance,\\n\\t\\t\\t\\t\\t\\t\\t// What do we want? intersection point on the ray or on the segment??\\n\\t\\t\\t\\t\\t\\t\\t// point: raycaster.ray.at( distance ),\\n\\t\\t\\t\\t\\t\\t\\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\\n\\t\\t\\t\\t\\t\\t\\tindex: i,\\n\\t\\t\\t\\t\\t\\t\\tface: null,\\n\\t\\t\\t\\t\\t\\t\\tfaceIndex: null,\\n\\t\\t\\t\\t\\t\\t\\tobject: this\\n\\n\\t\\t\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}() ),\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.geometry, this.material ).copy( this );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction LineSegments( geometry, material ) {\\n\\n\\t\\tLine.call( this, geometry, material );\\n\\n\\t\\tthis.type = 'LineSegments';\\n\\n\\t}\\n\\n\\tLineSegments.prototype = Object.assign( Object.create( Line.prototype ), {\\n\\n\\t\\tconstructor: LineSegments,\\n\\n\\t\\tisLineSegments: true\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mgreter / http://github.com/mgreter\\n\\t */\\n\\n\\tfunction LineLoop( geometry, material ) {\\n\\n\\t\\tLine.call( this, geometry, material );\\n\\n\\t\\tthis.type = 'LineLoop';\\n\\n\\t}\\n\\n\\tLineLoop.prototype = Object.assign( Object.create( Line.prototype ), {\\n\\n\\t\\tconstructor: LineLoop,\\n\\n\\t\\tisLineLoop: true,\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t *\\n\\t * parameters = {\\n\\t *  color: <hex>,\\n\\t *  opacity: <float>,\\n\\t *  map: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  size: <float>,\\n\\t *  sizeAttenuation: <bool>\\n\\t * }\\n\\t */\\n\\n\\tfunction PointsMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'PointsMaterial';\\n\\n\\t\\tthis.color = new Color( 0xffffff );\\n\\n\\t\\tthis.map = null;\\n\\n\\t\\tthis.size = 1;\\n\\t\\tthis.sizeAttenuation = true;\\n\\n\\t\\tthis.lights = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tPointsMaterial.prototype = Object.create( Material.prototype );\\n\\tPointsMaterial.prototype.constructor = PointsMaterial;\\n\\n\\tPointsMaterial.prototype.isPointsMaterial = true;\\n\\n\\tPointsMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.color.copy( source.color );\\n\\n\\t\\tthis.map = source.map;\\n\\n\\t\\tthis.size = source.size;\\n\\t\\tthis.sizeAttenuation = source.sizeAttenuation;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction Points( geometry, material ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Points';\\n\\n\\t\\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\\n\\t\\tthis.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );\\n\\n\\t}\\n\\n\\tPoints.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Points,\\n\\n\\t\\tisPoints: true,\\n\\n\\t\\traycast: ( function () {\\n\\n\\t\\t\\tvar inverseMatrix = new Matrix4();\\n\\t\\t\\tvar ray = new Ray();\\n\\t\\t\\tvar sphere = new Sphere();\\n\\n\\t\\t\\treturn function raycast( raycaster, intersects ) {\\n\\n\\t\\t\\t\\tvar object = this;\\n\\t\\t\\t\\tvar geometry = this.geometry;\\n\\t\\t\\t\\tvar matrixWorld = this.matrixWorld;\\n\\t\\t\\t\\tvar threshold = raycaster.params.Points.threshold;\\n\\n\\t\\t\\t\\t// Checking boundingSphere distance to ray\\n\\n\\t\\t\\t\\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\\n\\n\\t\\t\\t\\tsphere.copy( geometry.boundingSphere );\\n\\t\\t\\t\\tsphere.applyMatrix4( matrixWorld );\\n\\t\\t\\t\\tsphere.radius += threshold;\\n\\n\\t\\t\\t\\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\\n\\n\\t\\t\\t\\t//\\n\\n\\t\\t\\t\\tinverseMatrix.getInverse( matrixWorld );\\n\\t\\t\\t\\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\\n\\n\\t\\t\\t\\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\\n\\t\\t\\t\\tvar localThresholdSq = localThreshold * localThreshold;\\n\\t\\t\\t\\tvar position = new Vector3();\\n\\n\\t\\t\\t\\tfunction testPoint( point, index ) {\\n\\n\\t\\t\\t\\t\\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\\n\\n\\t\\t\\t\\t\\tif ( rayPointDistanceSq < localThresholdSq ) {\\n\\n\\t\\t\\t\\t\\t\\tvar intersectPoint = ray.closestPointToPoint( point );\\n\\t\\t\\t\\t\\t\\tintersectPoint.applyMatrix4( matrixWorld );\\n\\n\\t\\t\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\\n\\n\\t\\t\\t\\t\\t\\tif ( distance < raycaster.near || distance > raycaster.far ) return;\\n\\n\\t\\t\\t\\t\\t\\tintersects.push( {\\n\\n\\t\\t\\t\\t\\t\\t\\tdistance: distance,\\n\\t\\t\\t\\t\\t\\t\\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\\n\\t\\t\\t\\t\\t\\t\\tpoint: intersectPoint.clone(),\\n\\t\\t\\t\\t\\t\\t\\tindex: index,\\n\\t\\t\\t\\t\\t\\t\\tface: null,\\n\\t\\t\\t\\t\\t\\t\\tobject: object\\n\\n\\t\\t\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( geometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\t\\tvar index = geometry.index;\\n\\t\\t\\t\\t\\tvar attributes = geometry.attributes;\\n\\t\\t\\t\\t\\tvar positions = attributes.position.array;\\n\\n\\t\\t\\t\\t\\tif ( index !== null ) {\\n\\n\\t\\t\\t\\t\\t\\tvar indices = index.array;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar a = indices[ i ];\\n\\n\\t\\t\\t\\t\\t\\t\\tposition.fromArray( positions, a * 3 );\\n\\n\\t\\t\\t\\t\\t\\t\\ttestPoint( position, a );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tposition.fromArray( positions, i * 3 );\\n\\n\\t\\t\\t\\t\\t\\t\\ttestPoint( position, i );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tvar vertices = geometry.vertices;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\ttestPoint( vertices[ i ], i );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}() ),\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.geometry, this.material ).copy( this );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction Group() {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Group';\\n\\n\\t}\\n\\n\\tGroup.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Group,\\n\\n\\t\\tisGroup: true\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\\n\\n\\t\\tTexture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\\n\\n\\t\\tthis.generateMipmaps = false;\\n\\n\\t\\t// Set needsUpdate when first frame is ready\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\tfunction onLoaded() {\\n\\n\\t\\t\\tvideo.removeEventListener( 'loadeddata', onLoaded, false );\\n\\t\\t\\tscope.needsUpdate = true;\\n\\n\\t\\t}\\n\\n\\t\\tvideo.addEventListener( 'loadeddata', onLoaded, false );\\n\\n\\t}\\n\\n\\tVideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), {\\n\\n\\t\\tconstructor: VideoTexture,\\n\\n\\t\\tisVideoTexture: true,\\n\\n\\t\\tupdate: function () {\\n\\n\\t\\t\\tvar video = this.image;\\n\\n\\t\\t\\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\\n\\n\\t\\t\\t\\tthis.needsUpdate = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\\n\\n\\t\\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\\n\\n\\t\\tthis.image = { width: width, height: height };\\n\\t\\tthis.mipmaps = mipmaps;\\n\\n\\t\\t// no flipping for cube textures\\n\\t\\t// (also flipping doesn't work for compressed textures )\\n\\n\\t\\tthis.flipY = false;\\n\\n\\t\\t// can't generate mipmaps for compressed textures\\n\\t\\t// mips must be embedded in DDS files\\n\\n\\t\\tthis.generateMipmaps = false;\\n\\n\\t}\\n\\n\\tCompressedTexture.prototype = Object.create( Texture.prototype );\\n\\tCompressedTexture.prototype.constructor = CompressedTexture;\\n\\n\\tCompressedTexture.prototype.isCompressedTexture = true;\\n\\n\\t/**\\n\\t * @author Matt DesLauriers / @mattdesl\\n\\t * @author atix / arthursilber.de\\n\\t */\\n\\n\\tfunction DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {\\n\\n\\t\\tformat = format !== undefined ? format : DepthFormat;\\n\\n\\t\\tif ( format !== DepthFormat && format !== DepthStencilFormat ) {\\n\\n\\t\\t\\tthrow new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );\\n\\n\\t\\t}\\n\\n\\t\\tif ( type === undefined && format === DepthFormat ) type = UnsignedShortType;\\n\\t\\tif ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;\\n\\n\\t\\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\\n\\n\\t\\tthis.image = { width: width, height: height };\\n\\n\\t\\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\\n\\t\\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\\n\\n\\t\\tthis.flipY = false;\\n\\t\\tthis.generateMipmaps\\t= false;\\n\\n\\t}\\n\\n\\tDepthTexture.prototype = Object.create( Texture.prototype );\\n\\tDepthTexture.prototype.constructor = DepthTexture;\\n\\tDepthTexture.prototype.isDepthTexture = true;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\tfunction WireframeGeometry( geometry ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'WireframeGeometry';\\n\\n\\t\\t// buffer\\n\\n\\t\\tvar vertices = [];\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar i, j, l, o, ol;\\n\\t\\tvar edge = [ 0, 0 ], edges = {}, e, edge1, edge2;\\n\\t\\tvar key, keys = [ 'a', 'b', 'c' ];\\n\\t\\tvar vertex;\\n\\n\\t\\t// different logic for Geometry and BufferGeometry\\n\\n\\t\\tif ( geometry && geometry.isGeometry ) {\\n\\n\\t\\t\\t// create a data structure that contains all edges without duplicates\\n\\n\\t\\t\\tvar faces = geometry.faces;\\n\\n\\t\\t\\tfor ( i = 0, l = faces.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar face = faces[ i ];\\n\\n\\t\\t\\t\\tfor ( j = 0; j < 3; j ++ ) {\\n\\n\\t\\t\\t\\t\\tedge1 = face[ keys[ j ] ];\\n\\t\\t\\t\\t\\tedge2 = face[ keys[ ( j + 1 ) % 3 ] ];\\n\\t\\t\\t\\t\\tedge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates\\n\\t\\t\\t\\t\\tedge[ 1 ] = Math.max( edge1, edge2 );\\n\\n\\t\\t\\t\\t\\tkey = edge[ 0 ] + ',' + edge[ 1 ];\\n\\n\\t\\t\\t\\t\\tif ( edges[ key ] === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// generate vertices\\n\\n\\t\\t\\tfor ( key in edges ) {\\n\\n\\t\\t\\t\\te = edges[ key ];\\n\\n\\t\\t\\t\\tvertex = geometry.vertices[ e.index1 ];\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\tvertex = geometry.vertices[ e.index2 ];\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t}\\n\\n\\t\\t} else if ( geometry && geometry.isBufferGeometry ) {\\n\\n\\t\\t\\tvar position, indices, groups;\\n\\t\\t\\tvar group, start, count;\\n\\t\\t\\tvar index1, index2;\\n\\n\\t\\t\\tvertex = new Vector3();\\n\\n\\t\\t\\tif ( geometry.index !== null ) {\\n\\n\\t\\t\\t\\t// indexed BufferGeometry\\n\\n\\t\\t\\t\\tposition = geometry.attributes.position;\\n\\t\\t\\t\\tindices = geometry.index;\\n\\t\\t\\t\\tgroups = geometry.groups;\\n\\n\\t\\t\\t\\tif ( groups.length === 0 ) {\\n\\n\\t\\t\\t\\t\\tgroups = [ { start: 0, count: indices.count, materialIndex: 0 } ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// create a data structure that contains all eges without duplicates\\n\\n\\t\\t\\t\\tfor ( o = 0, ol = groups.length; o < ol; ++ o ) {\\n\\n\\t\\t\\t\\t\\tgroup = groups[ o ];\\n\\n\\t\\t\\t\\t\\tstart = group.start;\\n\\t\\t\\t\\t\\tcount = group.count;\\n\\n\\t\\t\\t\\t\\tfor ( i = start, l = ( start + count ); i < l; i += 3 ) {\\n\\n\\t\\t\\t\\t\\t\\tfor ( j = 0; j < 3; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tedge1 = indices.getX( i + j );\\n\\t\\t\\t\\t\\t\\t\\tedge2 = indices.getX( i + ( j + 1 ) % 3 );\\n\\t\\t\\t\\t\\t\\t\\tedge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates\\n\\t\\t\\t\\t\\t\\t\\tedge[ 1 ] = Math.max( edge1, edge2 );\\n\\n\\t\\t\\t\\t\\t\\t\\tkey = edge[ 0 ] + ',' + edge[ 1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( edges[ key ] === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// generate vertices\\n\\n\\t\\t\\t\\tfor ( key in edges ) {\\n\\n\\t\\t\\t\\t\\te = edges[ key ];\\n\\n\\t\\t\\t\\t\\tvertex.fromBufferAttribute( position, e.index1 );\\n\\t\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t\\tvertex.fromBufferAttribute( position, e.index2 );\\n\\t\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// non-indexed BufferGeometry\\n\\n\\t\\t\\t\\tposition = geometry.attributes.position;\\n\\n\\t\\t\\t\\tfor ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tfor ( j = 0; j < 3; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t// three edges per triangle, an edge is represented as (index1, index2)\\n\\t\\t\\t\\t\\t\\t// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\\n\\n\\t\\t\\t\\t\\t\\tindex1 = 3 * i + j;\\n\\t\\t\\t\\t\\t\\tvertex.fromBufferAttribute( position, index1 );\\n\\t\\t\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t\\t\\tindex2 = 3 * i + ( ( j + 1 ) % 3 );\\n\\t\\t\\t\\t\\t\\tvertex.fromBufferAttribute( position, index2 );\\n\\t\\t\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\n\\t}\\n\\n\\tWireframeGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tWireframeGeometry.prototype.constructor = WireframeGeometry;\\n\\n\\t/**\\n\\t * @author zz85 / https://github.com/zz85\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t *\\n\\t * Parametric Surfaces Geometry\\n\\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\\n\\t */\\n\\n\\t// ParametricGeometry\\n\\n\\tfunction ParametricGeometry( func, slices, stacks ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'ParametricGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tfunc: func,\\n\\t\\t\\tslices: slices,\\n\\t\\t\\tstacks: stacks\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tParametricGeometry.prototype = Object.create( Geometry.prototype );\\n\\tParametricGeometry.prototype.constructor = ParametricGeometry;\\n\\n\\t// ParametricBufferGeometry\\n\\n\\tfunction ParametricBufferGeometry( func, slices, stacks ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'ParametricBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tfunc: func,\\n\\t\\t\\tslices: slices,\\n\\t\\t\\tstacks: stacks\\n\\t\\t};\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\tvar EPS = 0.00001;\\n\\n\\t\\tvar normal = new Vector3();\\n\\n\\t\\tvar p0 = new Vector3(), p1 = new Vector3();\\n\\t\\tvar pu = new Vector3(), pv = new Vector3();\\n\\n\\t\\tvar i, j;\\n\\n\\t\\t// generate vertices, normals and uvs\\n\\n\\t\\tvar sliceCount = slices + 1;\\n\\n\\t\\tfor ( i = 0; i <= stacks; i ++ ) {\\n\\n\\t\\t\\tvar v = i / stacks;\\n\\n\\t\\t\\tfor ( j = 0; j <= slices; j ++ ) {\\n\\n\\t\\t\\t\\tvar u = j / slices;\\n\\n\\t\\t\\t\\t// vertex\\n\\n\\t\\t\\t\\tp0 = func( u, v, p0 );\\n\\t\\t\\t\\tvertices.push( p0.x, p0.y, p0.z );\\n\\n\\t\\t\\t\\t// normal\\n\\n\\t\\t\\t\\t// approximate tangent vectors via finite differences\\n\\n\\t\\t\\t\\tif ( u - EPS >= 0 ) {\\n\\n\\t\\t\\t\\t\\tp1 = func( u - EPS, v, p1 );\\n\\t\\t\\t\\t\\tpu.subVectors( p0, p1 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tp1 = func( u + EPS, v, p1 );\\n\\t\\t\\t\\t\\tpu.subVectors( p1, p0 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( v - EPS >= 0 ) {\\n\\n\\t\\t\\t\\t\\tp1 = func( u, v - EPS, p1 );\\n\\t\\t\\t\\t\\tpv.subVectors( p0, p1 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tp1 = func( u, v + EPS, p1 );\\n\\t\\t\\t\\t\\tpv.subVectors( p1, p0 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// cross product of tangent vectors returns surface normal\\n\\n\\t\\t\\t\\tnormal.crossVectors( pu, pv ).normalize();\\n\\t\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\n\\n\\t\\t\\t\\t// uv\\n\\n\\t\\t\\t\\tuvs.push( u, v );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// generate indices\\n\\n\\t\\tfor ( i = 0; i < stacks; i ++ ) {\\n\\n\\t\\t\\tfor ( j = 0; j < slices; j ++ ) {\\n\\n\\t\\t\\t\\tvar a = i * sliceCount + j;\\n\\t\\t\\t\\tvar b = i * sliceCount + j + 1;\\n\\t\\t\\t\\tvar c = ( i + 1 ) * sliceCount + j + 1;\\n\\t\\t\\t\\tvar d = ( i + 1 ) * sliceCount + j;\\n\\n\\t\\t\\t\\t// faces one and two\\n\\n\\t\\t\\t\\tindices.push( a, b, d );\\n\\t\\t\\t\\tindices.push( b, c, d );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t}\\n\\n\\tParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;\\n\\n\\t/**\\n\\t * @author clockworkgeek / https://github.com/clockworkgeek\\n\\t * @author timothypratley / https://github.com/timothypratley\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// PolyhedronGeometry\\n\\n\\tfunction PolyhedronGeometry( vertices, indices, radius, detail ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'PolyhedronGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tvertices: vertices,\\n\\t\\t\\tindices: indices,\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tPolyhedronGeometry.prototype = Object.create( Geometry.prototype );\\n\\tPolyhedronGeometry.prototype.constructor = PolyhedronGeometry;\\n\\n\\t// PolyhedronBufferGeometry\\n\\n\\tfunction PolyhedronBufferGeometry( vertices, indices, radius, detail ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'PolyhedronBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tvertices: vertices,\\n\\t\\t\\tindices: indices,\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t\\tradius = radius || 1;\\n\\t\\tdetail = detail || 0;\\n\\n\\t\\t// default buffer data\\n\\n\\t\\tvar vertexBuffer = [];\\n\\t\\tvar uvBuffer = [];\\n\\n\\t\\t// the subdivision creates the vertex buffer data\\n\\n\\t\\tsubdivide( detail );\\n\\n\\t\\t// all vertices should lie on a conceptual sphere with a given radius\\n\\n\\t\\tappplyRadius( radius );\\n\\n\\t\\t// finally, create the uv data\\n\\n\\t\\tgenerateUVs();\\n\\n\\t\\t// build non-indexed geometry\\n\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );\\n\\n\\t\\tif ( detail === 0 ) {\\n\\n\\t\\t\\tthis.computeVertexNormals(); // flat normals\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tthis.normalizeNormals(); // smooth normals\\n\\n\\t\\t}\\n\\n\\t\\t// helper functions\\n\\n\\t\\tfunction subdivide( detail ) {\\n\\n\\t\\t\\tvar a = new Vector3();\\n\\t\\t\\tvar b = new Vector3();\\n\\t\\t\\tvar c = new Vector3();\\n\\n\\t\\t\\t// iterate over all faces and apply a subdivison with the given detail value\\n\\n\\t\\t\\tfor ( var i = 0; i < indices.length; i += 3 ) {\\n\\n\\t\\t\\t\\t// get the vertices of the face\\n\\n\\t\\t\\t\\tgetVertexByIndex( indices[ i + 0 ], a );\\n\\t\\t\\t\\tgetVertexByIndex( indices[ i + 1 ], b );\\n\\t\\t\\t\\tgetVertexByIndex( indices[ i + 2 ], c );\\n\\n\\t\\t\\t\\t// perform subdivision\\n\\n\\t\\t\\t\\tsubdivideFace( a, b, c, detail );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction subdivideFace( a, b, c, detail ) {\\n\\n\\t\\t\\tvar cols = Math.pow( 2, detail );\\n\\n\\t\\t\\t// we use this multidimensional array as a data structure for creating the subdivision\\n\\n\\t\\t\\tvar v = [];\\n\\n\\t\\t\\tvar i, j;\\n\\n\\t\\t\\t// construct all of the vertices for this subdivision\\n\\n\\t\\t\\tfor ( i = 0; i <= cols; i ++ ) {\\n\\n\\t\\t\\t\\tv[ i ] = [];\\n\\n\\t\\t\\t\\tvar aj = a.clone().lerp( c, i / cols );\\n\\t\\t\\t\\tvar bj = b.clone().lerp( c, i / cols );\\n\\n\\t\\t\\t\\tvar rows = cols - i;\\n\\n\\t\\t\\t\\tfor ( j = 0; j <= rows; j ++ ) {\\n\\n\\t\\t\\t\\t\\tif ( j === 0 && i === cols ) {\\n\\n\\t\\t\\t\\t\\t\\tv[ i ][ j ] = aj;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// construct all of the faces\\n\\n\\t\\t\\tfor ( i = 0; i < cols; i ++ ) {\\n\\n\\t\\t\\t\\tfor ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\\n\\n\\t\\t\\t\\t\\tvar k = Math.floor( j / 2 );\\n\\n\\t\\t\\t\\t\\tif ( j % 2 === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\tpushVertex( v[ i ][ k + 1 ] );\\n\\t\\t\\t\\t\\t\\tpushVertex( v[ i + 1 ][ k ] );\\n\\t\\t\\t\\t\\t\\tpushVertex( v[ i ][ k ] );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tpushVertex( v[ i ][ k + 1 ] );\\n\\t\\t\\t\\t\\t\\tpushVertex( v[ i + 1 ][ k + 1 ] );\\n\\t\\t\\t\\t\\t\\tpushVertex( v[ i + 1 ][ k ] );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction appplyRadius( radius ) {\\n\\n\\t\\t\\tvar vertex = new Vector3();\\n\\n\\t\\t\\t// iterate over the entire buffer and apply the radius to each vertex\\n\\n\\t\\t\\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\\n\\n\\t\\t\\t\\tvertex.x = vertexBuffer[ i + 0 ];\\n\\t\\t\\t\\tvertex.y = vertexBuffer[ i + 1 ];\\n\\t\\t\\t\\tvertex.z = vertexBuffer[ i + 2 ];\\n\\n\\t\\t\\t\\tvertex.normalize().multiplyScalar( radius );\\n\\n\\t\\t\\t\\tvertexBuffer[ i + 0 ] = vertex.x;\\n\\t\\t\\t\\tvertexBuffer[ i + 1 ] = vertex.y;\\n\\t\\t\\t\\tvertexBuffer[ i + 2 ] = vertex.z;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction generateUVs() {\\n\\n\\t\\t\\tvar vertex = new Vector3();\\n\\n\\t\\t\\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\\n\\n\\t\\t\\t\\tvertex.x = vertexBuffer[ i + 0 ];\\n\\t\\t\\t\\tvertex.y = vertexBuffer[ i + 1 ];\\n\\t\\t\\t\\tvertex.z = vertexBuffer[ i + 2 ];\\n\\n\\t\\t\\t\\tvar u = azimuth( vertex ) / 2 / Math.PI + 0.5;\\n\\t\\t\\t\\tvar v = inclination( vertex ) / Math.PI + 0.5;\\n\\t\\t\\t\\tuvBuffer.push( u, 1 - v );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tcorrectUVs();\\n\\n\\t\\t\\tcorrectSeam();\\n\\n\\t\\t}\\n\\n\\t\\tfunction correctSeam() {\\n\\n\\t\\t\\t// handle case when face straddles the seam, see #3269\\n\\n\\t\\t\\tfor ( var i = 0; i < uvBuffer.length; i += 6 ) {\\n\\n\\t\\t\\t\\t// uv data of a single face\\n\\n\\t\\t\\t\\tvar x0 = uvBuffer[ i + 0 ];\\n\\t\\t\\t\\tvar x1 = uvBuffer[ i + 2 ];\\n\\t\\t\\t\\tvar x2 = uvBuffer[ i + 4 ];\\n\\n\\t\\t\\t\\tvar max = Math.max( x0, x1, x2 );\\n\\t\\t\\t\\tvar min = Math.min( x0, x1, x2 );\\n\\n\\t\\t\\t\\t// 0.9 is somewhat arbitrary\\n\\n\\t\\t\\t\\tif ( max > 0.9 && min < 0.1 ) {\\n\\n\\t\\t\\t\\t\\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\\n\\t\\t\\t\\t\\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\\n\\t\\t\\t\\t\\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction pushVertex( vertex ) {\\n\\n\\t\\t\\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t}\\n\\n\\t\\tfunction getVertexByIndex( index, vertex ) {\\n\\n\\t\\t\\tvar stride = index * 3;\\n\\n\\t\\t\\tvertex.x = vertices[ stride + 0 ];\\n\\t\\t\\tvertex.y = vertices[ stride + 1 ];\\n\\t\\t\\tvertex.z = vertices[ stride + 2 ];\\n\\n\\t\\t}\\n\\n\\t\\tfunction correctUVs() {\\n\\n\\t\\t\\tvar a = new Vector3();\\n\\t\\t\\tvar b = new Vector3();\\n\\t\\t\\tvar c = new Vector3();\\n\\n\\t\\t\\tvar centroid = new Vector3();\\n\\n\\t\\t\\tvar uvA = new Vector2();\\n\\t\\t\\tvar uvB = new Vector2();\\n\\t\\t\\tvar uvC = new Vector2();\\n\\n\\t\\t\\tfor ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\\n\\n\\t\\t\\t\\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\\n\\t\\t\\t\\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\\n\\t\\t\\t\\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\\n\\n\\t\\t\\t\\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\\n\\t\\t\\t\\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\\n\\t\\t\\t\\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\\n\\n\\t\\t\\t\\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\\n\\n\\t\\t\\t\\tvar azi = azimuth( centroid );\\n\\n\\t\\t\\t\\tcorrectUV( uvA, j + 0, a, azi );\\n\\t\\t\\t\\tcorrectUV( uvB, j + 2, b, azi );\\n\\t\\t\\t\\tcorrectUV( uvC, j + 4, c, azi );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction correctUV( uv, stride, vector, azimuth ) {\\n\\n\\t\\t\\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\\n\\n\\t\\t\\t\\tuvBuffer[ stride ] = uv.x - 1;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\\n\\n\\t\\t\\t\\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// Angle around the Y axis, counter-clockwise when looking from above.\\n\\n\\t\\tfunction azimuth( vector ) {\\n\\n\\t\\t\\treturn Math.atan2( vector.z, - vector.x );\\n\\n\\t\\t}\\n\\n\\n\\t\\t// Angle above the XZ plane.\\n\\n\\t\\tfunction inclination( vector ) {\\n\\n\\t\\t\\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tPolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tPolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;\\n\\n\\t/**\\n\\t * @author timothypratley / https://github.com/timothypratley\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// TetrahedronGeometry\\n\\n\\tfunction TetrahedronGeometry( radius, detail ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'TetrahedronGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tTetrahedronGeometry.prototype = Object.create( Geometry.prototype );\\n\\tTetrahedronGeometry.prototype.constructor = TetrahedronGeometry;\\n\\n\\t// TetrahedronBufferGeometry\\n\\n\\tfunction TetrahedronBufferGeometry( radius, detail ) {\\n\\n\\t\\tvar vertices = [\\n\\t\\t\\t1, 1, 1, \\t- 1, - 1, 1, \\t- 1, 1, - 1, \\t1, - 1, - 1\\n\\t\\t];\\n\\n\\t\\tvar indices = [\\n\\t\\t\\t2, 1, 0, \\t0, 3, 2,\\t1, 3, 0,\\t2, 3, 1\\n\\t\\t];\\n\\n\\t\\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\\n\\n\\t\\tthis.type = 'TetrahedronBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t}\\n\\n\\tTetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\\n\\tTetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;\\n\\n\\t/**\\n\\t * @author timothypratley / https://github.com/timothypratley\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// OctahedronGeometry\\n\\n\\tfunction OctahedronGeometry( radius, detail ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'OctahedronGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tOctahedronGeometry.prototype = Object.create( Geometry.prototype );\\n\\tOctahedronGeometry.prototype.constructor = OctahedronGeometry;\\n\\n\\t// OctahedronBufferGeometry\\n\\n\\tfunction OctahedronBufferGeometry( radius, detail ) {\\n\\n\\t\\tvar vertices = [\\n\\t\\t\\t1, 0, 0, \\t- 1, 0, 0,\\t0, 1, 0,\\n\\t\\t\\t0, - 1, 0, \\t0, 0, 1,\\t0, 0, - 1\\n\\t\\t];\\n\\n\\t\\tvar indices = [\\n\\t\\t\\t0, 2, 4,\\t0, 4, 3,\\t0, 3, 5,\\n\\t\\t\\t0, 5, 2,\\t1, 2, 5,\\t1, 5, 3,\\n\\t\\t\\t1, 3, 4,\\t1, 4, 2\\n\\t\\t];\\n\\n\\t\\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\\n\\n\\t\\tthis.type = 'OctahedronBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t}\\n\\n\\tOctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\\n\\tOctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;\\n\\n\\t/**\\n\\t * @author timothypratley / https://github.com/timothypratley\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// IcosahedronGeometry\\n\\n\\tfunction IcosahedronGeometry( radius, detail ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'IcosahedronGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tIcosahedronGeometry.prototype = Object.create( Geometry.prototype );\\n\\tIcosahedronGeometry.prototype.constructor = IcosahedronGeometry;\\n\\n\\t// IcosahedronBufferGeometry\\n\\n\\tfunction IcosahedronBufferGeometry( radius, detail ) {\\n\\n\\t\\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\\n\\n\\t\\tvar vertices = [\\n\\t\\t\\t- 1, t, 0, \\t1, t, 0, \\t- 1, - t, 0, \\t1, - t, 0,\\n\\t\\t\\t 0, - 1, t, \\t0, 1, t,\\t0, - 1, - t, \\t0, 1, - t,\\n\\t\\t\\t t, 0, - 1, \\tt, 0, 1, \\t- t, 0, - 1, \\t- t, 0, 1\\n\\t\\t];\\n\\n\\t\\tvar indices = [\\n\\t\\t\\t 0, 11, 5, \\t0, 5, 1, \\t0, 1, 7, \\t0, 7, 10, \\t0, 10, 11,\\n\\t\\t\\t 1, 5, 9, \\t5, 11, 4,\\t11, 10, 2,\\t10, 7, 6,\\t7, 1, 8,\\n\\t\\t\\t 3, 9, 4, \\t3, 4, 2,\\t3, 2, 6,\\t3, 6, 8,\\t3, 8, 9,\\n\\t\\t\\t 4, 9, 5, \\t2, 4, 11,\\t6, 2, 10,\\t8, 6, 7,\\t9, 8, 1\\n\\t\\t];\\n\\n\\t\\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\\n\\n\\t\\tthis.type = 'IcosahedronBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t}\\n\\n\\tIcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\\n\\tIcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;\\n\\n\\t/**\\n\\t * @author Abe Pazos / https://hamoid.com\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// DodecahedronGeometry\\n\\n\\tfunction DodecahedronGeometry( radius, detail ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'DodecahedronGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tDodecahedronGeometry.prototype = Object.create( Geometry.prototype );\\n\\tDodecahedronGeometry.prototype.constructor = DodecahedronGeometry;\\n\\n\\t// DodecahedronBufferGeometry\\n\\n\\tfunction DodecahedronBufferGeometry( radius, detail ) {\\n\\n\\t\\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\\n\\t\\tvar r = 1 / t;\\n\\n\\t\\tvar vertices = [\\n\\n\\t\\t\\t// (±1, ±1, ±1)\\n\\t\\t\\t- 1, - 1, - 1,\\t- 1, - 1, 1,\\n\\t\\t\\t- 1, 1, - 1, - 1, 1, 1,\\n\\t\\t\\t1, - 1, - 1, 1, - 1, 1,\\n\\t\\t\\t1, 1, - 1, 1, 1, 1,\\n\\n\\t\\t\\t// (0, ±1/φ, ±φ)\\n\\t\\t\\t 0, - r, - t, 0, - r, t,\\n\\t\\t\\t 0, r, - t, 0, r, t,\\n\\n\\t\\t\\t// (±1/φ, ±φ, 0)\\n\\t\\t\\t- r, - t, 0, - r, t, 0,\\n\\t\\t\\t r, - t, 0, r, t, 0,\\n\\n\\t\\t\\t// (±φ, 0, ±1/φ)\\n\\t\\t\\t- t, 0, - r, t, 0, - r,\\n\\t\\t\\t- t, 0, r, t, 0, r\\n\\t\\t];\\n\\n\\t\\tvar indices = [\\n\\t\\t\\t3, 11, 7, \\t3, 7, 15, \\t3, 15, 13,\\n\\t\\t\\t7, 19, 17, \\t7, 17, 6, \\t7, 6, 15,\\n\\t\\t\\t17, 4, 8, \\t17, 8, 10, \\t17, 10, 6,\\n\\t\\t\\t8, 0, 16, \\t8, 16, 2, \\t8, 2, 10,\\n\\t\\t\\t0, 12, 1, \\t0, 1, 18, \\t0, 18, 16,\\n\\t\\t\\t6, 10, 2, \\t6, 2, 13, \\t6, 13, 15,\\n\\t\\t\\t2, 16, 18, \\t2, 18, 3, \\t2, 3, 13,\\n\\t\\t\\t18, 1, 9, \\t18, 9, 11, \\t18, 11, 3,\\n\\t\\t\\t4, 14, 12, \\t4, 12, 0, \\t4, 0, 8,\\n\\t\\t\\t11, 9, 5, \\t11, 5, 19, \\t11, 19, 7,\\n\\t\\t\\t19, 5, 14, \\t19, 14, 4, \\t19, 4, 17,\\n\\t\\t\\t1, 12, 14, \\t1, 14, 5, \\t1, 5, 9\\n\\t\\t];\\n\\n\\t\\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\\n\\n\\t\\tthis.type = 'DodecahedronBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t}\\n\\n\\tDodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\\n\\tDodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;\\n\\n\\t/**\\n\\t * @author oosmoxiecode / https://github.com/oosmoxiecode\\n\\t * @author WestLangley / https://github.com/WestLangley\\n\\t * @author zz85 / https://github.com/zz85\\n\\t * @author miningold / https://github.com/miningold\\n\\t * @author jonobr1 / https://github.com/jonobr1\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t *\\n\\t */\\n\\n\\t// TubeGeometry\\n\\n\\tfunction TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'TubeGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tpath: path,\\n\\t\\t\\ttubularSegments: tubularSegments,\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\tclosed: closed\\n\\t\\t};\\n\\n\\t\\tif ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );\\n\\n\\t\\tvar bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );\\n\\n\\t\\t// expose internals\\n\\n\\t\\tthis.tangents = bufferGeometry.tangents;\\n\\t\\tthis.normals = bufferGeometry.normals;\\n\\t\\tthis.binormals = bufferGeometry.binormals;\\n\\n\\t\\t// create geometry\\n\\n\\t\\tthis.fromBufferGeometry( bufferGeometry );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tTubeGeometry.prototype = Object.create( Geometry.prototype );\\n\\tTubeGeometry.prototype.constructor = TubeGeometry;\\n\\n\\t// TubeBufferGeometry\\n\\n\\tfunction TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'TubeBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tpath: path,\\n\\t\\t\\ttubularSegments: tubularSegments,\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\tclosed: closed\\n\\t\\t};\\n\\n\\t\\ttubularSegments = tubularSegments || 64;\\n\\t\\tradius = radius || 1;\\n\\t\\tradialSegments = radialSegments || 8;\\n\\t\\tclosed = closed || false;\\n\\n\\t\\tvar frames = path.computeFrenetFrames( tubularSegments, closed );\\n\\n\\t\\t// expose internals\\n\\n\\t\\tthis.tangents = frames.tangents;\\n\\t\\tthis.normals = frames.normals;\\n\\t\\tthis.binormals = frames.binormals;\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar vertex = new Vector3();\\n\\t\\tvar normal = new Vector3();\\n\\t\\tvar uv = new Vector2();\\n\\t\\tvar P = new Vector3();\\n\\n\\t\\tvar i, j;\\n\\n\\t\\t// buffer\\n\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\t\\tvar indices = [];\\n\\n\\t\\t// create buffer data\\n\\n\\t\\tgenerateBufferData();\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t\\t// functions\\n\\n\\t\\tfunction generateBufferData() {\\n\\n\\t\\t\\tfor ( i = 0; i < tubularSegments; i ++ ) {\\n\\n\\t\\t\\t\\tgenerateSegment( i );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// if the geometry is not closed, generate the last row of vertices and normals\\n\\t\\t\\t// at the regular position on the given path\\n\\t\\t\\t//\\n\\t\\t\\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\\n\\n\\t\\t\\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\\n\\n\\t\\t\\t// uvs are generated in a separate function.\\n\\t\\t\\t// this makes it easy compute correct values for closed geometries\\n\\n\\t\\t\\tgenerateUVs();\\n\\n\\t\\t\\t// finally create faces\\n\\n\\t\\t\\tgenerateIndices();\\n\\n\\t\\t}\\n\\n\\t\\tfunction generateSegment( i ) {\\n\\n\\t\\t\\t// we use getPointAt to sample evenly distributed points from the given path\\n\\n\\t\\t\\tP = path.getPointAt( i / tubularSegments, P );\\n\\n\\t\\t\\t// retrieve corresponding normal and binormal\\n\\n\\t\\t\\tvar N = frames.normals[ i ];\\n\\t\\t\\tvar B = frames.binormals[ i ];\\n\\n\\t\\t\\t// generate normals and vertices for the current segment\\n\\n\\t\\t\\tfor ( j = 0; j <= radialSegments; j ++ ) {\\n\\n\\t\\t\\t\\tvar v = j / radialSegments * Math.PI * 2;\\n\\n\\t\\t\\t\\tvar sin = Math.sin( v );\\n\\t\\t\\t\\tvar cos = - Math.cos( v );\\n\\n\\t\\t\\t\\t// normal\\n\\n\\t\\t\\t\\tnormal.x = ( cos * N.x + sin * B.x );\\n\\t\\t\\t\\tnormal.y = ( cos * N.y + sin * B.y );\\n\\t\\t\\t\\tnormal.z = ( cos * N.z + sin * B.z );\\n\\t\\t\\t\\tnormal.normalize();\\n\\n\\t\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\n\\n\\t\\t\\t\\t// vertex\\n\\n\\t\\t\\t\\tvertex.x = P.x + radius * normal.x;\\n\\t\\t\\t\\tvertex.y = P.y + radius * normal.y;\\n\\t\\t\\t\\tvertex.z = P.z + radius * normal.z;\\n\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction generateIndices() {\\n\\n\\t\\t\\tfor ( j = 1; j <= tubularSegments; j ++ ) {\\n\\n\\t\\t\\t\\tfor ( i = 1; i <= radialSegments; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\\n\\t\\t\\t\\t\\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\\n\\t\\t\\t\\t\\tvar c = ( radialSegments + 1 ) * j + i;\\n\\t\\t\\t\\t\\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\\n\\n\\t\\t\\t\\t\\t// faces\\n\\n\\t\\t\\t\\t\\tindices.push( a, b, d );\\n\\t\\t\\t\\t\\tindices.push( b, c, d );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction generateUVs() {\\n\\n\\t\\t\\tfor ( i = 0; i <= tubularSegments; i ++ ) {\\n\\n\\t\\t\\t\\tfor ( j = 0; j <= radialSegments; j ++ ) {\\n\\n\\t\\t\\t\\t\\tuv.x = i / tubularSegments;\\n\\t\\t\\t\\t\\tuv.y = j / radialSegments;\\n\\n\\t\\t\\t\\t\\tuvs.push( uv.x, uv.y );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tTubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tTubeBufferGeometry.prototype.constructor = TubeBufferGeometry;\\n\\n\\t/**\\n\\t * @author oosmoxiecode\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t *\\n\\t * based on http://www.blackpawn.com/texts/pqtorus/\\n\\t */\\n\\n\\t// TorusKnotGeometry\\n\\n\\tfunction TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'TorusKnotGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\ttube: tube,\\n\\t\\t\\ttubularSegments: tubularSegments,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\tp: p,\\n\\t\\t\\tq: q\\n\\t\\t};\\n\\n\\t\\tif ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\\n\\n\\t\\tthis.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tTorusKnotGeometry.prototype = Object.create( Geometry.prototype );\\n\\tTorusKnotGeometry.prototype.constructor = TorusKnotGeometry;\\n\\n\\t// TorusKnotBufferGeometry\\n\\n\\tfunction TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'TorusKnotBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\ttube: tube,\\n\\t\\t\\ttubularSegments: tubularSegments,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\tp: p,\\n\\t\\t\\tq: q\\n\\t\\t};\\n\\n\\t\\tradius = radius || 1;\\n\\t\\ttube = tube || 0.4;\\n\\t\\ttubularSegments = Math.floor( tubularSegments ) || 64;\\n\\t\\tradialSegments = Math.floor( radialSegments ) || 8;\\n\\t\\tp = p || 2;\\n\\t\\tq = q || 3;\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar i, j;\\n\\n\\t\\tvar vertex = new Vector3();\\n\\t\\tvar normal = new Vector3();\\n\\n\\t\\tvar P1 = new Vector3();\\n\\t\\tvar P2 = new Vector3();\\n\\n\\t\\tvar B = new Vector3();\\n\\t\\tvar T = new Vector3();\\n\\t\\tvar N = new Vector3();\\n\\n\\t\\t// generate vertices, normals and uvs\\n\\n\\t\\tfor ( i = 0; i <= tubularSegments; ++ i ) {\\n\\n\\t\\t\\t// the radian \\\"u\\\" is used to calculate the position on the torus curve of the current tubular segement\\n\\n\\t\\t\\tvar u = i / tubularSegments * p * Math.PI * 2;\\n\\n\\t\\t\\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\\n\\t\\t\\t// these points are used to create a special \\\"coordinate space\\\", which is necessary to calculate the correct vertex positions\\n\\n\\t\\t\\tcalculatePositionOnCurve( u, p, q, radius, P1 );\\n\\t\\t\\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\\n\\n\\t\\t\\t// calculate orthonormal basis\\n\\n\\t\\t\\tT.subVectors( P2, P1 );\\n\\t\\t\\tN.addVectors( P2, P1 );\\n\\t\\t\\tB.crossVectors( T, N );\\n\\t\\t\\tN.crossVectors( B, T );\\n\\n\\t\\t\\t// normalize B, N. T can be ignored, we don't use it\\n\\n\\t\\t\\tB.normalize();\\n\\t\\t\\tN.normalize();\\n\\n\\t\\t\\tfor ( j = 0; j <= radialSegments; ++ j ) {\\n\\n\\t\\t\\t\\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\\n\\t\\t\\t\\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\\n\\n\\t\\t\\t\\tvar v = j / radialSegments * Math.PI * 2;\\n\\t\\t\\t\\tvar cx = - tube * Math.cos( v );\\n\\t\\t\\t\\tvar cy = tube * Math.sin( v );\\n\\n\\t\\t\\t\\t// now calculate the final vertex position.\\n\\t\\t\\t\\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\\n\\n\\t\\t\\t\\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\\n\\t\\t\\t\\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\\n\\t\\t\\t\\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\\n\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\\n\\n\\t\\t\\t\\tnormal.subVectors( vertex, P1 ).normalize();\\n\\n\\t\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\n\\n\\t\\t\\t\\t// uv\\n\\n\\t\\t\\t\\tuvs.push( i / tubularSegments );\\n\\t\\t\\t\\tuvs.push( j / radialSegments );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// generate indices\\n\\n\\t\\tfor ( j = 1; j <= tubularSegments; j ++ ) {\\n\\n\\t\\t\\tfor ( i = 1; i <= radialSegments; i ++ ) {\\n\\n\\t\\t\\t\\t// indices\\n\\n\\t\\t\\t\\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\\n\\t\\t\\t\\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\\n\\t\\t\\t\\tvar c = ( radialSegments + 1 ) * j + i;\\n\\t\\t\\t\\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\\n\\n\\t\\t\\t\\t// faces\\n\\n\\t\\t\\t\\tindices.push( a, b, d );\\n\\t\\t\\t\\tindices.push( b, c, d );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t\\t// this function calculates the current position on the torus curve\\n\\n\\t\\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\\n\\n\\t\\t\\tvar cu = Math.cos( u );\\n\\t\\t\\tvar su = Math.sin( u );\\n\\t\\t\\tvar quOverP = q / p * u;\\n\\t\\t\\tvar cs = Math.cos( quOverP );\\n\\n\\t\\t\\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\\n\\t\\t\\tposition.y = radius * ( 2 + cs ) * su * 0.5;\\n\\t\\t\\tposition.z = radius * Math.sin( quOverP ) * 0.5;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tTorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tTorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;\\n\\n\\t/**\\n\\t * @author oosmoxiecode\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// TorusGeometry\\n\\n\\tfunction TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'TorusGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\ttube: tube,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\ttubularSegments: tubularSegments,\\n\\t\\t\\tarc: arc\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tTorusGeometry.prototype = Object.create( Geometry.prototype );\\n\\tTorusGeometry.prototype.constructor = TorusGeometry;\\n\\n\\t// TorusBufferGeometry\\n\\n\\tfunction TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'TorusBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\ttube: tube,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\ttubularSegments: tubularSegments,\\n\\t\\t\\tarc: arc\\n\\t\\t};\\n\\n\\t\\tradius = radius || 1;\\n\\t\\ttube = tube || 0.4;\\n\\t\\tradialSegments = Math.floor( radialSegments ) || 8;\\n\\t\\ttubularSegments = Math.floor( tubularSegments ) || 6;\\n\\t\\tarc = arc || Math.PI * 2;\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar center = new Vector3();\\n\\t\\tvar vertex = new Vector3();\\n\\t\\tvar normal = new Vector3();\\n\\n\\t\\tvar j, i;\\n\\n\\t\\t// generate vertices, normals and uvs\\n\\n\\t\\tfor ( j = 0; j <= radialSegments; j ++ ) {\\n\\n\\t\\t\\tfor ( i = 0; i <= tubularSegments; i ++ ) {\\n\\n\\t\\t\\t\\tvar u = i / tubularSegments * arc;\\n\\t\\t\\t\\tvar v = j / radialSegments * Math.PI * 2;\\n\\n\\t\\t\\t\\t// vertex\\n\\n\\t\\t\\t\\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\\n\\t\\t\\t\\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\\n\\t\\t\\t\\tvertex.z = tube * Math.sin( v );\\n\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t// normal\\n\\n\\t\\t\\t\\tcenter.x = radius * Math.cos( u );\\n\\t\\t\\t\\tcenter.y = radius * Math.sin( u );\\n\\t\\t\\t\\tnormal.subVectors( vertex, center ).normalize();\\n\\n\\t\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\n\\n\\t\\t\\t\\t// uv\\n\\n\\t\\t\\t\\tuvs.push( i / tubularSegments );\\n\\t\\t\\t\\tuvs.push( j / radialSegments );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// generate indices\\n\\n\\t\\tfor ( j = 1; j <= radialSegments; j ++ ) {\\n\\n\\t\\t\\tfor ( i = 1; i <= tubularSegments; i ++ ) {\\n\\n\\t\\t\\t\\t// indices\\n\\n\\t\\t\\t\\tvar a = ( tubularSegments + 1 ) * j + i - 1;\\n\\t\\t\\t\\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\\n\\t\\t\\t\\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\\n\\t\\t\\t\\tvar d = ( tubularSegments + 1 ) * j + i;\\n\\n\\t\\t\\t\\t// faces\\n\\n\\t\\t\\t\\tindices.push( a, b, d );\\n\\t\\t\\t\\tindices.push( b, c, d );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t}\\n\\n\\tTorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tTorusBufferGeometry.prototype.constructor = TorusBufferGeometry;\\n\\n\\t/**\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t * Port from https://github.com/mapbox/earcut (v2.1.2)\\n\\t */\\n\\n\\tvar Earcut = {\\n\\n\\t\\ttriangulate: function ( data, holeIndices, dim ) {\\n\\n\\t\\t\\tdim = dim || 2;\\n\\n\\t\\t\\tvar hasHoles = holeIndices && holeIndices.length,\\n\\t\\t\\t\\touterLen = hasHoles ? holeIndices[ 0 ] * dim : data.length,\\n\\t\\t\\t\\touterNode = linkedList( data, 0, outerLen, dim, true ),\\n\\t\\t\\t\\ttriangles = [];\\n\\n\\t\\t\\tif ( ! outerNode ) return triangles;\\n\\n\\t\\t\\tvar minX, minY, maxX, maxY, x, y, invSize;\\n\\n\\t\\t\\tif ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );\\n\\n\\t\\t\\t// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\\n\\n\\t\\t\\tif ( data.length > 80 * dim ) {\\n\\n\\t\\t\\t\\tminX = maxX = data[ 0 ];\\n\\t\\t\\t\\tminY = maxY = data[ 1 ];\\n\\n\\t\\t\\t\\tfor ( var i = dim; i < outerLen; i += dim ) {\\n\\n\\t\\t\\t\\t\\tx = data[ i ];\\n\\t\\t\\t\\t\\ty = data[ i + 1 ];\\n\\t\\t\\t\\t\\tif ( x < minX ) minX = x;\\n\\t\\t\\t\\t\\tif ( y < minY ) minY = y;\\n\\t\\t\\t\\t\\tif ( x > maxX ) maxX = x;\\n\\t\\t\\t\\t\\tif ( y > maxY ) maxY = y;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// minX, minY and invSize are later used to transform coords into integers for z-order calculation\\n\\n\\t\\t\\t\\tinvSize = Math.max( maxX - minX, maxY - minY );\\n\\t\\t\\t\\tinvSize = invSize !== 0 ? 1 / invSize : 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tearcutLinked( outerNode, triangles, dim, minX, minY, invSize );\\n\\n\\t\\t\\treturn triangles;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t// create a circular doubly linked list from polygon points in the specified winding order\\n\\n\\tfunction linkedList( data, start, end, dim, clockwise ) {\\n\\n\\t\\tvar i, last;\\n\\n\\t\\tif ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {\\n\\n\\t\\t\\tfor ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tfor ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\\n\\n\\t\\t}\\n\\n\\t\\tif ( last && equals( last, last.next ) ) {\\n\\n\\t\\t\\tremoveNode( last );\\n\\t\\t\\tlast = last.next;\\n\\n\\t\\t}\\n\\n\\t\\treturn last;\\n\\n\\t}\\n\\n\\t// eliminate colinear or duplicate points\\n\\n\\tfunction filterPoints( start, end ) {\\n\\n\\t\\tif ( ! start ) return start;\\n\\t\\tif ( ! end ) end = start;\\n\\n\\t\\tvar p = start, again;\\n\\n\\t\\tdo {\\n\\n\\t\\t\\tagain = false;\\n\\n\\t\\t\\tif ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {\\n\\n\\t\\t\\t\\tremoveNode( p );\\n\\t\\t\\t\\tp = end = p.prev;\\n\\t\\t\\t\\tif ( p === p.next ) break;\\n\\t\\t\\t\\tagain = true;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tp = p.next;\\n\\n\\t\\t\\t}\\n\\n\\t\\t} while ( again || p !== end );\\n\\n\\t\\treturn end;\\n\\n\\t}\\n\\n\\t// main ear slicing loop which triangulates a polygon (given as a linked list)\\n\\n\\tfunction earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {\\n\\n\\t\\tif ( ! ear ) return;\\n\\n\\t\\t// interlink polygon nodes in z-order\\n\\n\\t\\tif ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );\\n\\n\\t\\tvar stop = ear, prev, next;\\n\\n\\t\\t// iterate through ears, slicing them one by one\\n\\n\\t\\twhile ( ear.prev !== ear.next ) {\\n\\n\\t\\t\\tprev = ear.prev;\\n\\t\\t\\tnext = ear.next;\\n\\n\\t\\t\\tif ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {\\n\\n\\t\\t\\t\\t// cut off the triangle\\n\\t\\t\\t\\ttriangles.push( prev.i / dim );\\n\\t\\t\\t\\ttriangles.push( ear.i / dim );\\n\\t\\t\\t\\ttriangles.push( next.i / dim );\\n\\n\\t\\t\\t\\tremoveNode( ear );\\n\\n\\t\\t\\t\\t// skipping the next vertice leads to less sliver triangles\\n\\t\\t\\t\\tear = next.next;\\n\\t\\t\\t\\tstop = next.next;\\n\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tear = next;\\n\\n\\t\\t\\t// if we looped through the whole remaining polygon and can't find any more ears\\n\\n\\t\\t\\tif ( ear === stop ) {\\n\\n\\t\\t\\t\\t// try filtering points and slicing again\\n\\n\\t\\t\\t\\tif ( ! pass ) {\\n\\n\\t\\t\\t\\t\\tearcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );\\n\\n\\t\\t\\t\\t\\t// if this didn't work, try curing all small self-intersections locally\\n\\n\\t\\t\\t\\t} else if ( pass === 1 ) {\\n\\n\\t\\t\\t\\t\\tear = cureLocalIntersections( ear, triangles, dim );\\n\\t\\t\\t\\t\\tearcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );\\n\\n\\t\\t\\t\\t// as a last resort, try splitting the remaining polygon into two\\n\\n\\t\\t\\t\\t} else if ( pass === 2 ) {\\n\\n\\t\\t\\t\\t\\tsplitEarcut( ear, triangles, dim, minX, minY, invSize );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// check whether a polygon node forms a valid ear with adjacent nodes\\n\\n\\tfunction isEar( ear ) {\\n\\n\\t\\tvar a = ear.prev,\\n\\t\\t\\tb = ear,\\n\\t\\t\\tc = ear.next;\\n\\n\\t\\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\\n\\n\\t\\t// now make sure we don't have other points inside the potential ear\\n\\t\\tvar p = ear.next.next;\\n\\n\\t\\twhile ( p !== ear.prev ) {\\n\\n\\t\\t\\tif ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) {\\n\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tp = p.next;\\n\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\n\\t}\\n\\n\\tfunction isEarHashed( ear, minX, minY, invSize ) {\\n\\n\\t\\tvar a = ear.prev,\\n\\t\\t\\tb = ear,\\n\\t\\t\\tc = ear.next;\\n\\n\\t\\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\\n\\n\\t\\t// triangle bbox; min & max are calculated like this for speed\\n\\n\\t\\tvar minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),\\n\\t\\t\\tminTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),\\n\\t\\t\\tmaxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),\\n\\t\\t\\tmaxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );\\n\\n\\t\\t// z-order range for the current triangle bbox;\\n\\n\\t\\tvar minZ = zOrder( minTX, minTY, minX, minY, invSize ),\\n\\t\\t\\tmaxZ = zOrder( maxTX, maxTY, minX, minY, invSize );\\n\\n\\t\\t// first look for points inside the triangle in increasing z-order\\n\\n\\t\\tvar p = ear.nextZ;\\n\\n\\t\\twhile ( p && p.z <= maxZ ) {\\n\\n\\t\\t\\tif ( p !== ear.prev && p !== ear.next &&\\n\\t\\t\\t\\t\\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\\n\\t\\t\\t\\t\\tarea( p.prev, p, p.next ) >= 0 ) return false;\\n\\t\\t\\tp = p.nextZ;\\n\\n\\t\\t}\\n\\n\\t\\t// then look for points in decreasing z-order\\n\\n\\t\\tp = ear.prevZ;\\n\\n\\t\\twhile ( p && p.z >= minZ ) {\\n\\n\\t\\t\\tif ( p !== ear.prev && p !== ear.next &&\\n\\t\\t\\t\\t\\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\\n\\t\\t\\t\\t\\tarea( p.prev, p, p.next ) >= 0 ) return false;\\n\\n\\t\\t\\tp = p.prevZ;\\n\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\n\\t}\\n\\n\\t// go through all polygon nodes and cure small local self-intersections\\n\\n\\tfunction cureLocalIntersections( start, triangles, dim ) {\\n\\n\\t\\tvar p = start;\\n\\n\\t\\tdo {\\n\\n\\t\\t\\tvar a = p.prev, b = p.next.next;\\n\\n\\t\\t\\tif ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {\\n\\n\\t\\t\\t\\ttriangles.push( a.i / dim );\\n\\t\\t\\t\\ttriangles.push( p.i / dim );\\n\\t\\t\\t\\ttriangles.push( b.i / dim );\\n\\n\\t\\t\\t\\t// remove two nodes involved\\n\\n\\t\\t\\t\\tremoveNode( p );\\n\\t\\t\\t\\tremoveNode( p.next );\\n\\n\\t\\t\\t\\tp = start = b;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tp = p.next;\\n\\n\\t\\t} while ( p !== start );\\n\\n\\t\\treturn p;\\n\\n\\t}\\n\\n\\t// try splitting polygon into two and triangulate them independently\\n\\n\\tfunction splitEarcut( start, triangles, dim, minX, minY, invSize ) {\\n\\n\\t\\t// look for a valid diagonal that divides the polygon into two\\n\\n\\t\\tvar a = start;\\n\\n\\t\\tdo {\\n\\n\\t\\t\\tvar b = a.next.next;\\n\\n\\t\\t\\twhile ( b !== a.prev ) {\\n\\n\\t\\t\\t\\tif ( a.i !== b.i && isValidDiagonal( a, b ) ) {\\n\\n\\t\\t\\t\\t\\t// split the polygon in two by the diagonal\\n\\n\\t\\t\\t\\t\\tvar c = splitPolygon( a, b );\\n\\n\\t\\t\\t\\t\\t// filter colinear points around the cuts\\n\\n\\t\\t\\t\\t\\ta = filterPoints( a, a.next );\\n\\t\\t\\t\\t\\tc = filterPoints( c, c.next );\\n\\n\\t\\t\\t\\t\\t// run earcut on each half\\n\\n\\t\\t\\t\\t\\tearcutLinked( a, triangles, dim, minX, minY, invSize );\\n\\t\\t\\t\\t\\tearcutLinked( c, triangles, dim, minX, minY, invSize );\\n\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tb = b.next;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\ta = a.next;\\n\\n\\t\\t} while ( a !== start );\\n\\n\\t}\\n\\n\\t// link every hole into the outer loop, producing a single-ring polygon without holes\\n\\n\\tfunction eliminateHoles( data, holeIndices, outerNode, dim ) {\\n\\n\\t\\tvar queue = [], i, len, start, end, list;\\n\\n\\t\\tfor ( i = 0, len = holeIndices.length; i < len; i ++ ) {\\n\\n\\t\\t\\tstart = holeIndices[ i ] * dim;\\n\\t\\t\\tend = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;\\n\\t\\t\\tlist = linkedList( data, start, end, dim, false );\\n\\t\\t\\tif ( list === list.next ) list.steiner = true;\\n\\t\\t\\tqueue.push( getLeftmost( list ) );\\n\\n\\t\\t}\\n\\n\\t\\tqueue.sort( compareX );\\n\\n\\t\\t// process holes from left to right\\n\\n\\t\\tfor ( i = 0; i < queue.length; i ++ ) {\\n\\n\\t\\t\\teliminateHole( queue[ i ], outerNode );\\n\\t\\t\\touterNode = filterPoints( outerNode, outerNode.next );\\n\\n\\t\\t}\\n\\n\\t\\treturn outerNode;\\n\\n\\t}\\n\\n\\tfunction compareX( a, b ) {\\n\\n\\t\\treturn a.x - b.x;\\n\\n\\t}\\n\\n\\t// find a bridge between vertices that connects hole with an outer ring and and link it\\n\\n\\tfunction eliminateHole( hole, outerNode ) {\\n\\n\\t\\touterNode = findHoleBridge( hole, outerNode );\\n\\n\\t\\tif ( outerNode ) {\\n\\n\\t\\t\\tvar b = splitPolygon( outerNode, hole );\\n\\n\\t\\t\\tfilterPoints( b, b.next );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// David Eberly's algorithm for finding a bridge between hole and outer polygon\\n\\n\\tfunction findHoleBridge( hole, outerNode ) {\\n\\n\\t\\tvar p = outerNode,\\n\\t\\t\\thx = hole.x,\\n\\t\\t\\thy = hole.y,\\n\\t\\t\\tqx = - Infinity,\\n\\t\\t\\tm;\\n\\n\\t\\t// find a segment intersected by a ray from the hole's leftmost point to the left;\\n\\t\\t// segment's endpoint with lesser x will be potential connection point\\n\\n\\t\\tdo {\\n\\n\\t\\t\\tif ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {\\n\\n\\t\\t\\t\\tvar x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );\\n\\n\\t\\t\\t\\tif ( x <= hx && x > qx ) {\\n\\n\\t\\t\\t\\t\\tqx = x;\\n\\n\\t\\t\\t\\t\\tif ( x === hx ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( hy === p.y ) return p;\\n\\t\\t\\t\\t\\t\\tif ( hy === p.next.y ) return p.next;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tm = p.x < p.next.x ? p : p.next;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tp = p.next;\\n\\n\\t\\t} while ( p !== outerNode );\\n\\n\\t\\tif ( ! m ) return null;\\n\\n\\t\\tif ( hx === qx ) return m.prev; // hole touches outer segment; pick lower endpoint\\n\\n\\t\\t// look for points inside the triangle of hole point, segment intersection and endpoint;\\n\\t\\t// if there are no points found, we have a valid connection;\\n\\t\\t// otherwise choose the point of the minimum angle with the ray as connection point\\n\\n\\t\\tvar stop = m,\\n\\t\\t\\tmx = m.x,\\n\\t\\t\\tmy = m.y,\\n\\t\\t\\ttanMin = Infinity,\\n\\t\\t\\ttan;\\n\\n\\t\\tp = m.next;\\n\\n\\t\\twhile ( p !== stop ) {\\n\\n\\t\\t\\tif ( hx >= p.x && p.x >= mx && hx !== p.x &&\\n\\t\\t\\t\\t\\t\\t\\tpointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {\\n\\n\\t\\t\\t\\ttan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential\\n\\n\\t\\t\\t\\tif ( ( tan < tanMin || ( tan === tanMin && p.x > m.x ) ) && locallyInside( p, hole ) ) {\\n\\n\\t\\t\\t\\t\\tm = p;\\n\\t\\t\\t\\t\\ttanMin = tan;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tp = p.next;\\n\\n\\t\\t}\\n\\n\\t\\treturn m;\\n\\n\\t}\\n\\n\\t// interlink polygon nodes in z-order\\n\\n\\tfunction indexCurve( start, minX, minY, invSize ) {\\n\\n\\t\\tvar p = start;\\n\\n\\t\\tdo {\\n\\n\\t\\t\\tif ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );\\n\\t\\t\\tp.prevZ = p.prev;\\n\\t\\t\\tp.nextZ = p.next;\\n\\t\\t\\tp = p.next;\\n\\n\\t\\t} while ( p !== start );\\n\\n\\t\\tp.prevZ.nextZ = null;\\n\\t\\tp.prevZ = null;\\n\\n\\t\\tsortLinked( p );\\n\\n\\t}\\n\\n\\t// Simon Tatham's linked list merge sort algorithm\\n\\t// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\\n\\n\\tfunction sortLinked( list ) {\\n\\n\\t\\tvar i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;\\n\\n\\t\\tdo {\\n\\n\\t\\t\\tp = list;\\n\\t\\t\\tlist = null;\\n\\t\\t\\ttail = null;\\n\\t\\t\\tnumMerges = 0;\\n\\n\\t\\t\\twhile ( p ) {\\n\\n\\t\\t\\t\\tnumMerges ++;\\n\\t\\t\\t\\tq = p;\\n\\t\\t\\t\\tpSize = 0;\\n\\n\\t\\t\\t\\tfor ( i = 0; i < inSize; i ++ ) {\\n\\n\\t\\t\\t\\t\\tpSize ++;\\n\\t\\t\\t\\t\\tq = q.nextZ;\\n\\t\\t\\t\\t\\tif ( ! q ) break;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tqSize = inSize;\\n\\n\\t\\t\\t\\twhile ( pSize > 0 || ( qSize > 0 && q ) ) {\\n\\n\\t\\t\\t\\t\\tif ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {\\n\\n\\t\\t\\t\\t\\t\\te = p;\\n\\t\\t\\t\\t\\t\\tp = p.nextZ;\\n\\t\\t\\t\\t\\t\\tpSize --;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\te = q;\\n\\t\\t\\t\\t\\t\\tq = q.nextZ;\\n\\t\\t\\t\\t\\t\\tqSize --;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( tail ) tail.nextZ = e;\\n\\t\\t\\t\\t\\telse list = e;\\n\\n\\t\\t\\t\\t\\te.prevZ = tail;\\n\\t\\t\\t\\t\\ttail = e;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tp = q;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\ttail.nextZ = null;\\n\\t\\t\\tinSize *= 2;\\n\\n\\t\\t} while ( numMerges > 1 );\\n\\n\\t\\treturn list;\\n\\n\\t}\\n\\n\\t// z-order of a point given coords and inverse of the longer side of data bbox\\n\\n\\tfunction zOrder( x, y, minX, minY, invSize ) {\\n\\n\\t\\t// coords are transformed into non-negative 15-bit integer range\\n\\n\\t\\tx = 32767 * ( x - minX ) * invSize;\\n\\t\\ty = 32767 * ( y - minY ) * invSize;\\n\\n\\t\\tx = ( x | ( x << 8 ) ) & 0x00FF00FF;\\n\\t\\tx = ( x | ( x << 4 ) ) & 0x0F0F0F0F;\\n\\t\\tx = ( x | ( x << 2 ) ) & 0x33333333;\\n\\t\\tx = ( x | ( x << 1 ) ) & 0x55555555;\\n\\n\\t\\ty = ( y | ( y << 8 ) ) & 0x00FF00FF;\\n\\t\\ty = ( y | ( y << 4 ) ) & 0x0F0F0F0F;\\n\\t\\ty = ( y | ( y << 2 ) ) & 0x33333333;\\n\\t\\ty = ( y | ( y << 1 ) ) & 0x55555555;\\n\\n\\t\\treturn x | ( y << 1 );\\n\\n\\t}\\n\\n\\t// find the leftmost node of a polygon ring\\n\\n\\tfunction getLeftmost( start ) {\\n\\n\\t\\tvar p = start, leftmost = start;\\n\\n\\t\\tdo {\\n\\n\\t\\t\\tif ( p.x < leftmost.x ) leftmost = p;\\n\\t\\t\\tp = p.next;\\n\\n\\t\\t} while ( p !== start );\\n\\n\\t\\treturn leftmost;\\n\\n\\t}\\n\\n\\t// check if a point lies within a convex triangle\\n\\n\\tfunction pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {\\n\\n\\t\\treturn ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&\\n\\t\\t ( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&\\n\\t\\t ( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;\\n\\n\\t}\\n\\n\\t// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\\n\\n\\tfunction isValidDiagonal( a, b ) {\\n\\n\\t\\treturn a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) &&\\n\\t\\t\\tlocallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b );\\n\\n\\t}\\n\\n\\t// signed area of a triangle\\n\\n\\tfunction area( p, q, r ) {\\n\\n\\t\\treturn ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );\\n\\n\\t}\\n\\n\\t// check if two points are equal\\n\\n\\tfunction equals( p1, p2 ) {\\n\\n\\t\\treturn p1.x === p2.x && p1.y === p2.y;\\n\\n\\t}\\n\\n\\t// check if two segments intersect\\n\\n\\tfunction intersects( p1, q1, p2, q2 ) {\\n\\n\\t\\tif ( ( equals( p1, q1 ) && equals( p2, q2 ) ) ||\\n\\t\\t\\t\\t( equals( p1, q2 ) && equals( p2, q1 ) ) ) return true;\\n\\n\\t\\treturn area( p1, q1, p2 ) > 0 !== area( p1, q1, q2 ) > 0 &&\\n\\t\\t\\t\\t\\t area( p2, q2, p1 ) > 0 !== area( p2, q2, q1 ) > 0;\\n\\n\\t}\\n\\n\\t// check if a polygon diagonal intersects any polygon segments\\n\\n\\tfunction intersectsPolygon( a, b ) {\\n\\n\\t\\tvar p = a;\\n\\n\\t\\tdo {\\n\\n\\t\\t\\tif ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\\n\\t\\t\\t\\t\\t\\t\\tintersects( p, p.next, a, b ) ) {\\n\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tp = p.next;\\n\\n\\t\\t} while ( p !== a );\\n\\n\\t\\treturn false;\\n\\n\\t}\\n\\n\\t// check if a polygon diagonal is locally inside the polygon\\n\\n\\tfunction locallyInside( a, b ) {\\n\\n\\t\\treturn area( a.prev, a, a.next ) < 0 ?\\n\\t\\t\\tarea( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :\\n\\t\\t\\tarea( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;\\n\\n\\t}\\n\\n\\t// check if the middle point of a polygon diagonal is inside the polygon\\n\\n\\tfunction middleInside( a, b ) {\\n\\n\\t\\tvar p = a,\\n\\t\\t\\tinside = false,\\n\\t\\t\\tpx = ( a.x + b.x ) / 2,\\n\\t\\t\\tpy = ( a.y + b.y ) / 2;\\n\\n\\t\\tdo {\\n\\n\\t\\t\\tif ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&\\n\\t\\t\\t\\t\\t\\t\\t( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) ) {\\n\\n\\t\\t\\t\\tinside = ! inside;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tp = p.next;\\n\\n\\t\\t} while ( p !== a );\\n\\n\\t\\treturn inside;\\n\\n\\t}\\n\\n\\t// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\\n\\t// if one belongs to the outer ring and another to a hole, it merges it into a single ring\\n\\n\\tfunction splitPolygon( a, b ) {\\n\\n\\t\\tvar a2 = new Node( a.i, a.x, a.y ),\\n\\t\\t\\tb2 = new Node( b.i, b.x, b.y ),\\n\\t\\t\\tan = a.next,\\n\\t\\t\\tbp = b.prev;\\n\\n\\t\\ta.next = b;\\n\\t\\tb.prev = a;\\n\\n\\t\\ta2.next = an;\\n\\t\\tan.prev = a2;\\n\\n\\t\\tb2.next = a2;\\n\\t\\ta2.prev = b2;\\n\\n\\t\\tbp.next = b2;\\n\\t\\tb2.prev = bp;\\n\\n\\t\\treturn b2;\\n\\n\\t}\\n\\n\\t// create a node and optionally link it with previous one (in a circular doubly linked list)\\n\\n\\tfunction insertNode( i, x, y, last ) {\\n\\n\\t\\tvar p = new Node( i, x, y );\\n\\n\\t\\tif ( ! last ) {\\n\\n\\t\\t\\tp.prev = p;\\n\\t\\t\\tp.next = p;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tp.next = last.next;\\n\\t\\t\\tp.prev = last;\\n\\t\\t\\tlast.next.prev = p;\\n\\t\\t\\tlast.next = p;\\n\\n\\t\\t}\\n\\n\\t\\treturn p;\\n\\n\\t}\\n\\n\\tfunction removeNode( p ) {\\n\\n\\t\\tp.next.prev = p.prev;\\n\\t\\tp.prev.next = p.next;\\n\\n\\t\\tif ( p.prevZ ) p.prevZ.nextZ = p.nextZ;\\n\\t\\tif ( p.nextZ ) p.nextZ.prevZ = p.prevZ;\\n\\n\\t}\\n\\n\\tfunction Node( i, x, y ) {\\n\\n\\t\\t// vertice index in coordinates array\\n\\t\\tthis.i = i;\\n\\n\\t\\t// vertex coordinates\\n\\t\\tthis.x = x;\\n\\t\\tthis.y = y;\\n\\n\\t\\t// previous and next vertice nodes in a polygon ring\\n\\t\\tthis.prev = null;\\n\\t\\tthis.next = null;\\n\\n\\t\\t// z-order curve value\\n\\t\\tthis.z = null;\\n\\n\\t\\t// previous and next nodes in z-order\\n\\t\\tthis.prevZ = null;\\n\\t\\tthis.nextZ = null;\\n\\n\\t\\t// indicates whether this is a steiner point\\n\\t\\tthis.steiner = false;\\n\\n\\t}\\n\\n\\tfunction signedArea( data, start, end, dim ) {\\n\\n\\t\\tvar sum = 0;\\n\\n\\t\\tfor ( var i = start, j = end - dim; i < end; i += dim ) {\\n\\n\\t\\t\\tsum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );\\n\\t\\t\\tj = i;\\n\\n\\t\\t}\\n\\n\\t\\treturn sum;\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t */\\n\\n\\tvar ShapeUtils = {\\n\\n\\t\\t// calculate area of the contour polygon\\n\\n\\t\\tarea: function ( contour ) {\\n\\n\\t\\t\\tvar n = contour.length;\\n\\t\\t\\tvar a = 0.0;\\n\\n\\t\\t\\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\\n\\n\\t\\t\\t\\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn a * 0.5;\\n\\n\\t\\t},\\n\\n\\t\\tisClockWise: function ( pts ) {\\n\\n\\t\\t\\treturn ShapeUtils.area( pts ) < 0;\\n\\n\\t\\t},\\n\\n\\t\\ttriangulateShape: function ( contour, holes ) {\\n\\n\\t\\t\\tfunction removeDupEndPts( points ) {\\n\\n\\t\\t\\t\\tvar l = points.length;\\n\\n\\t\\t\\t\\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\\n\\n\\t\\t\\t\\t\\tpoints.pop();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction addContour( vertices, contour ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < contour.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvertices.push( contour[ i ].x );\\n\\t\\t\\t\\t\\tvertices.push( contour[ i ].y );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\\n\\t\\t\\tvar holeIndices = []; // array of hole indices\\n\\t\\t\\tvar faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\\n\\n\\t\\t\\tremoveDupEndPts( contour );\\n\\t\\t\\taddContour( vertices, contour );\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar holeIndex = contour.length;\\n\\t\\t\\tholes.forEach( removeDupEndPts );\\n\\n\\t\\t\\tfor ( i = 0; i < holes.length; i ++ ) {\\n\\n\\t\\t\\t\\tholeIndices.push( holeIndex );\\n\\t\\t\\t\\tholeIndex += holes[ i ].length;\\n\\t\\t\\t\\taddContour( vertices, holes[ i ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar triangles = Earcut.triangulate( vertices, holeIndices );\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tfor ( var i = 0; i < triangles.length; i += 3 ) {\\n\\n\\t\\t\\t\\tfaces.push( triangles.slice( i, i + 3 ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn faces;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t *\\n\\t * Creates extruded geometry from a path shape.\\n\\t *\\n\\t * parameters = {\\n\\t *\\n\\t *  curveSegments: <int>, // number of points on the curves\\n\\t *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\\n\\t *  amount: <int>, // Depth to extrude the shape\\n\\t *\\n\\t *  bevelEnabled: <bool>, // turn on bevel\\n\\t *  bevelThickness: <float>, // how deep into the original shape bevel goes\\n\\t *  bevelSize: <float>, // how far from shape outline is bevel\\n\\t *  bevelSegments: <int>, // number of bevel layers\\n\\t *\\n\\t *  extrudePath: <THREE.Curve> // curve to extrude shape along\\n\\t *  frames: <Object> // containing arrays of tangents, normals, binormals\\n\\t *\\n\\t *  UVGenerator: <Object> // object that provides UV generator functions\\n\\t *\\n\\t * }\\n\\t */\\n\\n\\t// ExtrudeGeometry\\n\\n\\tfunction ExtrudeGeometry( shapes, options ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'ExtrudeGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tshapes: shapes,\\n\\t\\t\\toptions: options\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tExtrudeGeometry.prototype = Object.create( Geometry.prototype );\\n\\tExtrudeGeometry.prototype.constructor = ExtrudeGeometry;\\n\\n\\t// ExtrudeBufferGeometry\\n\\n\\tfunction ExtrudeBufferGeometry( shapes, options ) {\\n\\n\\t\\tif ( typeof ( shapes ) === \\\"undefined\\\" ) {\\n\\n\\t\\t\\treturn;\\n\\n\\t\\t}\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'ExtrudeBufferGeometry';\\n\\n\\t\\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\\n\\n\\t\\tthis.addShapeList( shapes, options );\\n\\n\\t\\tthis.computeVertexNormals();\\n\\n\\t\\t// can't really use automatic vertex normals\\n\\t\\t// as then front and back sides get smoothed too\\n\\t\\t// should do separate smoothing just for sides\\n\\n\\t\\t//this.computeVertexNormals();\\n\\n\\t\\t//console.log( \\\"took\\\", ( Date.now() - startTime ) );\\n\\n\\t}\\n\\n\\tExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;\\n\\n\\tExtrudeBufferGeometry.prototype.getArrays = function () {\\n\\n\\t\\tvar positionAttribute = this.getAttribute( \\\"position\\\" );\\n\\t\\tvar verticesArray = positionAttribute ? Array.prototype.slice.call( positionAttribute.array ) : [];\\n\\n\\t\\tvar uvAttribute = this.getAttribute( \\\"uv\\\" );\\n\\t\\tvar uvArray = uvAttribute ? Array.prototype.slice.call( uvAttribute.array ) : [];\\n\\n\\t\\tvar IndexAttribute = this.index;\\n\\t\\tvar indicesArray = IndexAttribute ? Array.prototype.slice.call( IndexAttribute.array ) : [];\\n\\n\\t\\treturn {\\n\\t\\t\\tposition: verticesArray,\\n\\t\\t\\tuv: uvArray,\\n\\t\\t\\tindex: indicesArray\\n\\t\\t};\\n\\n\\t};\\n\\n\\tExtrudeBufferGeometry.prototype.addShapeList = function ( shapes, options ) {\\n\\n\\t\\tvar sl = shapes.length;\\n\\t\\toptions.arrays = this.getArrays();\\n\\n\\t\\tfor ( var s = 0; s < sl; s ++ ) {\\n\\n\\t\\t\\tvar shape = shapes[ s ];\\n\\t\\t\\tthis.addShape( shape, options );\\n\\n\\t\\t}\\n\\n\\t\\tthis.setIndex( options.arrays.index );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( options.arrays.position, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( options.arrays.uv, 2 ) );\\n\\n\\t};\\n\\n\\tExtrudeBufferGeometry.prototype.addShape = function ( shape, options ) {\\n\\n\\t\\tvar arrays = options.arrays ? options.arrays : this.getArrays();\\n\\t\\tvar verticesArray = arrays.position;\\n\\t\\tvar indicesArray = arrays.index;\\n\\t\\tvar uvArray = arrays.uv;\\n\\n\\t\\tvar placeholder = [];\\n\\n\\n\\t\\tvar amount = options.amount !== undefined ? options.amount : 100;\\n\\n\\t\\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\\n\\t\\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\\n\\t\\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\\n\\n\\t\\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\\n\\n\\t\\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\\n\\n\\t\\tvar steps = options.steps !== undefined ? options.steps : 1;\\n\\n\\t\\tvar extrudePath = options.extrudePath;\\n\\t\\tvar extrudePts, extrudeByPath = false;\\n\\n\\t\\t// Use default WorldUVGenerator if no UV generators are specified.\\n\\t\\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;\\n\\n\\t\\tvar splineTube, binormal, normal, position2;\\n\\t\\tif ( extrudePath ) {\\n\\n\\t\\t\\textrudePts = extrudePath.getSpacedPoints( steps );\\n\\n\\t\\t\\textrudeByPath = true;\\n\\t\\t\\tbevelEnabled = false; // bevels not supported for path extrusion\\n\\n\\t\\t\\t// SETUP TNB variables\\n\\n\\t\\t\\t// TODO1 - have a .isClosed in spline?\\n\\n\\t\\t\\tsplineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );\\n\\n\\t\\t\\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\\n\\n\\t\\t\\tbinormal = new Vector3();\\n\\t\\t\\tnormal = new Vector3();\\n\\t\\t\\tposition2 = new Vector3();\\n\\n\\t\\t}\\n\\n\\t\\t// Safeguards if bevels are not enabled\\n\\n\\t\\tif ( ! bevelEnabled ) {\\n\\n\\t\\t\\tbevelSegments = 0;\\n\\t\\t\\tbevelThickness = 0;\\n\\t\\t\\tbevelSize = 0;\\n\\n\\t\\t}\\n\\n\\t\\t// Variables initialization\\n\\n\\t\\tvar ahole, h, hl; // looping of holes\\n\\t\\tvar scope = this;\\n\\n\\t\\tvar shapePoints = shape.extractPoints( curveSegments );\\n\\n\\t\\tvar vertices = shapePoints.shape;\\n\\t\\tvar holes = shapePoints.holes;\\n\\n\\t\\tvar reverse = ! ShapeUtils.isClockWise( vertices );\\n\\n\\t\\tif ( reverse ) {\\n\\n\\t\\t\\tvertices = vertices.reverse();\\n\\n\\t\\t\\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\\n\\n\\t\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\n\\n\\t\\t\\t\\tahole = holes[ h ];\\n\\n\\t\\t\\t\\tif ( ShapeUtils.isClockWise( ahole ) ) {\\n\\n\\t\\t\\t\\t\\tholes[ h ] = ahole.reverse();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\n\\t\\tvar faces = ShapeUtils.triangulateShape( vertices, holes );\\n\\n\\t\\t/* Vertices */\\n\\n\\t\\tvar contour = vertices; // vertices has all points but contour has only points of circumference\\n\\n\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\n\\n\\t\\t\\tahole = holes[ h ];\\n\\n\\t\\t\\tvertices = vertices.concat( ahole );\\n\\n\\t\\t}\\n\\n\\n\\t\\tfunction scalePt2( pt, vec, size ) {\\n\\n\\t\\t\\tif ( ! vec ) console.error( \\\"THREE.ExtrudeGeometry: vec does not exist\\\" );\\n\\n\\t\\t\\treturn vec.clone().multiplyScalar( size ).add( pt );\\n\\n\\t\\t}\\n\\n\\t\\tvar b, bs, t, z,\\n\\t\\t\\tvert, vlen = vertices.length,\\n\\t\\t\\tface, flen = faces.length;\\n\\n\\n\\t\\t// Find directions for point movement\\n\\n\\n\\t\\tfunction getBevelVec( inPt, inPrev, inNext ) {\\n\\n\\t\\t\\t// computes for inPt the corresponding point inPt' on a new contour\\n\\t\\t\\t//   shifted by 1 unit (length of normalized vector) to the left\\n\\t\\t\\t// if we walk along contour clockwise, this new contour is outside the old one\\n\\t\\t\\t//\\n\\t\\t\\t// inPt' is the intersection of the two lines parallel to the two\\n\\t\\t\\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\\n\\n\\t\\t\\tvar v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\\n\\n\\t\\t\\t// good reading for geometry algorithms (here: line-line intersection)\\n\\t\\t\\t// http://geomalgorithms.com/a05-_intersect-1.html\\n\\n\\t\\t\\tvar v_prev_x = inPt.x - inPrev.x,\\n\\t\\t\\t\\tv_prev_y = inPt.y - inPrev.y;\\n\\t\\t\\tvar v_next_x = inNext.x - inPt.x,\\n\\t\\t\\t\\tv_next_y = inNext.y - inPt.y;\\n\\n\\t\\t\\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\\n\\n\\t\\t\\t// check for collinear edges\\n\\t\\t\\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\\n\\n\\t\\t\\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\\n\\n\\t\\t\\t\\t// not collinear\\n\\n\\t\\t\\t\\t// length of vectors for normalizing\\n\\n\\t\\t\\t\\tvar v_prev_len = Math.sqrt( v_prev_lensq );\\n\\t\\t\\t\\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\\n\\n\\t\\t\\t\\t// shift adjacent points by unit vectors to the left\\n\\n\\t\\t\\t\\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\\n\\t\\t\\t\\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\\n\\n\\t\\t\\t\\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\\n\\t\\t\\t\\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\\n\\n\\t\\t\\t\\t// scaling factor for v_prev to intersection point\\n\\n\\t\\t\\t\\tvar sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\\n\\t\\t\\t\\t\\t\\t( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /\\n\\t\\t\\t\\t\\t( v_prev_x * v_next_y - v_prev_y * v_next_x );\\n\\n\\t\\t\\t\\t// vector from inPt to intersection point\\n\\n\\t\\t\\t\\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\\n\\t\\t\\t\\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\\n\\n\\t\\t\\t\\t// Don't normalize!, otherwise sharp corners become ugly\\n\\t\\t\\t\\t//  but prevent crazy spikes\\n\\t\\t\\t\\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\\n\\t\\t\\t\\tif ( v_trans_lensq <= 2 ) {\\n\\n\\t\\t\\t\\t\\treturn new Vector2( v_trans_x, v_trans_y );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// handle special case of collinear edges\\n\\n\\t\\t\\t\\tvar direction_eq = false; // assumes: opposite\\n\\t\\t\\t\\tif ( v_prev_x > Number.EPSILON ) {\\n\\n\\t\\t\\t\\t\\tif ( v_next_x > Number.EPSILON ) {\\n\\n\\t\\t\\t\\t\\t\\tdirection_eq = true;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tif ( v_prev_x < - Number.EPSILON ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( v_next_x < - Number.EPSILON ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tdirection_eq = true;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tdirection_eq = true;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( direction_eq ) {\\n\\n\\t\\t\\t\\t\\t// console.log(\\\"Warning: lines are a straight sequence\\\");\\n\\t\\t\\t\\t\\tv_trans_x = - v_prev_y;\\n\\t\\t\\t\\t\\tv_trans_y = v_prev_x;\\n\\t\\t\\t\\t\\tshrink_by = Math.sqrt( v_prev_lensq );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// console.log(\\\"Warning: lines are a straight spike\\\");\\n\\t\\t\\t\\t\\tv_trans_x = v_prev_x;\\n\\t\\t\\t\\t\\tv_trans_y = v_prev_y;\\n\\t\\t\\t\\t\\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\\n\\n\\t\\t}\\n\\n\\n\\t\\tvar contourMovements = [];\\n\\n\\t\\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\\n\\n\\t\\t\\tif ( j === il ) j = 0;\\n\\t\\t\\tif ( k === il ) k = 0;\\n\\n\\t\\t\\t//  (j)---(i)---(k)\\n\\t\\t\\t// console.log('i,j,k', i, j , k)\\n\\n\\t\\t\\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\\n\\n\\t\\t}\\n\\n\\t\\tvar holesMovements = [],\\n\\t\\t\\toneHoleMovements, verticesMovements = contourMovements.concat();\\n\\n\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\n\\n\\t\\t\\tahole = holes[ h ];\\n\\n\\t\\t\\toneHoleMovements = [];\\n\\n\\t\\t\\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\\n\\n\\t\\t\\t\\tif ( j === il ) j = 0;\\n\\t\\t\\t\\tif ( k === il ) k = 0;\\n\\n\\t\\t\\t\\t//  (j)---(i)---(k)\\n\\t\\t\\t\\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tholesMovements.push( oneHoleMovements );\\n\\t\\t\\tverticesMovements = verticesMovements.concat( oneHoleMovements );\\n\\n\\t\\t}\\n\\n\\n\\t\\t// Loop bevelSegments, 1 for the front, 1 for the back\\n\\n\\t\\tfor ( b = 0; b < bevelSegments; b ++ ) {\\n\\n\\t\\t\\t//for ( b = bevelSegments; b > 0; b -- ) {\\n\\n\\t\\t\\tt = b / bevelSegments;\\n\\t\\t\\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\\n\\t\\t\\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\\n\\n\\t\\t\\t// contract shape\\n\\n\\t\\t\\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\\n\\n\\t\\t\\t\\tv( vert.x, vert.y, - z );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// expand holes\\n\\n\\t\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\n\\n\\t\\t\\t\\tahole = holes[ h ];\\n\\t\\t\\t\\toneHoleMovements = holesMovements[ h ];\\n\\n\\t\\t\\t\\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\\n\\n\\t\\t\\t\\t\\tv( vert.x, vert.y, - z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tbs = bevelSize;\\n\\n\\t\\t// Back facing vertices\\n\\n\\t\\tfor ( i = 0; i < vlen; i ++ ) {\\n\\n\\t\\t\\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\\n\\n\\t\\t\\tif ( ! extrudeByPath ) {\\n\\n\\t\\t\\t\\tv( vert.x, vert.y, 0 );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\\n\\n\\t\\t\\t\\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\\n\\t\\t\\t\\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\\n\\n\\t\\t\\t\\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\\n\\n\\t\\t\\t\\tv( position2.x, position2.y, position2.z );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// Add stepped vertices...\\n\\t\\t// Including front facing vertices\\n\\n\\t\\tvar s;\\n\\n\\t\\tfor ( s = 1; s <= steps; s ++ ) {\\n\\n\\t\\t\\tfor ( i = 0; i < vlen; i ++ ) {\\n\\n\\t\\t\\t\\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\\n\\n\\t\\t\\t\\tif ( ! extrudeByPath ) {\\n\\n\\t\\t\\t\\t\\tv( vert.x, vert.y, amount / steps * s );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\\n\\n\\t\\t\\t\\t\\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\\n\\t\\t\\t\\t\\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\\n\\n\\t\\t\\t\\t\\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\\n\\n\\t\\t\\t\\t\\tv( position2.x, position2.y, position2.z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\n\\t\\t// Add bevel segments planes\\n\\n\\t\\t//for ( b = 1; b <= bevelSegments; b ++ ) {\\n\\t\\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\\n\\n\\t\\t\\tt = b / bevelSegments;\\n\\t\\t\\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\\n\\t\\t\\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\\n\\n\\t\\t\\t// contract shape\\n\\n\\t\\t\\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\\n\\t\\t\\t\\tv( vert.x, vert.y, amount + z );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// expand holes\\n\\n\\t\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\n\\n\\t\\t\\t\\tahole = holes[ h ];\\n\\t\\t\\t\\toneHoleMovements = holesMovements[ h ];\\n\\n\\t\\t\\t\\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\\n\\n\\t\\t\\t\\t\\tif ( ! extrudeByPath ) {\\n\\n\\t\\t\\t\\t\\t\\tv( vert.x, vert.y, amount + z );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t/* Faces */\\n\\n\\t\\t// Top and bottom faces\\n\\n\\t\\tbuildLidFaces();\\n\\n\\t\\t// Sides faces\\n\\n\\t\\tbuildSideFaces();\\n\\n\\n\\t\\t/////  Internal functions\\n\\n\\t\\tfunction buildLidFaces() {\\n\\n\\t\\t\\tvar start = verticesArray.length / 3;\\n\\n\\t\\t\\tif ( bevelEnabled ) {\\n\\n\\t\\t\\t\\tvar layer = 0; // steps + 1\\n\\t\\t\\t\\tvar offset = vlen * layer;\\n\\n\\t\\t\\t\\t// Bottom faces\\n\\n\\t\\t\\t\\tfor ( i = 0; i < flen; i ++ ) {\\n\\n\\t\\t\\t\\t\\tface = faces[ i ];\\n\\t\\t\\t\\t\\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tlayer = steps + bevelSegments * 2;\\n\\t\\t\\t\\toffset = vlen * layer;\\n\\n\\t\\t\\t\\t// Top faces\\n\\n\\t\\t\\t\\tfor ( i = 0; i < flen; i ++ ) {\\n\\n\\t\\t\\t\\t\\tface = faces[ i ];\\n\\t\\t\\t\\t\\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Bottom faces\\n\\n\\t\\t\\t\\tfor ( i = 0; i < flen; i ++ ) {\\n\\n\\t\\t\\t\\t\\tface = faces[ i ];\\n\\t\\t\\t\\t\\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Top faces\\n\\n\\t\\t\\t\\tfor ( i = 0; i < flen; i ++ ) {\\n\\n\\t\\t\\t\\t\\tface = faces[ i ];\\n\\t\\t\\t\\t\\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tscope.addGroup( start, verticesArray.length / 3 - start, options.material !== undefined ? options.material : 0 );\\n\\n\\t\\t}\\n\\n\\t\\t// Create faces for the z-sides of the shape\\n\\n\\t\\tfunction buildSideFaces() {\\n\\n\\t\\t\\tvar start = verticesArray.length / 3;\\n\\t\\t\\tvar layeroffset = 0;\\n\\t\\t\\tsidewalls( contour, layeroffset );\\n\\t\\t\\tlayeroffset += contour.length;\\n\\n\\t\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\n\\n\\t\\t\\t\\tahole = holes[ h ];\\n\\t\\t\\t\\tsidewalls( ahole, layeroffset );\\n\\n\\t\\t\\t\\t//, true\\n\\t\\t\\t\\tlayeroffset += ahole.length;\\n\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\tscope.addGroup( start, verticesArray.length / 3 - start, options.extrudeMaterial !== undefined ? options.extrudeMaterial : 1 );\\n\\n\\n\\t\\t}\\n\\n\\t\\tfunction sidewalls( contour, layeroffset ) {\\n\\n\\t\\t\\tvar j, k;\\n\\t\\t\\ti = contour.length;\\n\\n\\t\\t\\twhile ( -- i >= 0 ) {\\n\\n\\t\\t\\t\\tj = i;\\n\\t\\t\\t\\tk = i - 1;\\n\\t\\t\\t\\tif ( k < 0 ) k = contour.length - 1;\\n\\n\\t\\t\\t\\t//console.log('b', i,j, i-1, k,vertices.length);\\n\\n\\t\\t\\t\\tvar s = 0,\\n\\t\\t\\t\\t\\tsl = steps + bevelSegments * 2;\\n\\n\\t\\t\\t\\tfor ( s = 0; s < sl; s ++ ) {\\n\\n\\t\\t\\t\\t\\tvar slen1 = vlen * s;\\n\\t\\t\\t\\t\\tvar slen2 = vlen * ( s + 1 );\\n\\n\\t\\t\\t\\t\\tvar a = layeroffset + j + slen1,\\n\\t\\t\\t\\t\\t\\tb = layeroffset + k + slen1,\\n\\t\\t\\t\\t\\t\\tc = layeroffset + k + slen2,\\n\\t\\t\\t\\t\\t\\td = layeroffset + j + slen2;\\n\\n\\t\\t\\t\\t\\tf4( a, b, c, d );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction v( x, y, z ) {\\n\\n\\t\\t\\tplaceholder.push( x );\\n\\t\\t\\tplaceholder.push( y );\\n\\t\\t\\tplaceholder.push( z );\\n\\n\\t\\t}\\n\\n\\n\\t\\tfunction f3( a, b, c ) {\\n\\n\\t\\t\\taddVertex( a );\\n\\t\\t\\taddVertex( b );\\n\\t\\t\\taddVertex( c );\\n\\n\\t\\t\\tvar nextIndex = verticesArray.length / 3;\\n\\t\\t\\tvar uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\\n\\n\\t\\t\\taddUV( uvs[ 0 ] );\\n\\t\\t\\taddUV( uvs[ 1 ] );\\n\\t\\t\\taddUV( uvs[ 2 ] );\\n\\n\\t\\t}\\n\\n\\t\\tfunction f4( a, b, c, d ) {\\n\\n\\t\\t\\taddVertex( a );\\n\\t\\t\\taddVertex( b );\\n\\t\\t\\taddVertex( d );\\n\\n\\t\\t\\taddVertex( b );\\n\\t\\t\\taddVertex( c );\\n\\t\\t\\taddVertex( d );\\n\\n\\n\\t\\t\\tvar nextIndex = verticesArray.length / 3;\\n\\t\\t\\tvar uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\\n\\n\\t\\t\\taddUV( uvs[ 0 ] );\\n\\t\\t\\taddUV( uvs[ 1 ] );\\n\\t\\t\\taddUV( uvs[ 3 ] );\\n\\n\\t\\t\\taddUV( uvs[ 1 ] );\\n\\t\\t\\taddUV( uvs[ 2 ] );\\n\\t\\t\\taddUV( uvs[ 3 ] );\\n\\n\\t\\t}\\n\\n\\t\\tfunction addVertex( index ) {\\n\\n\\t\\t\\tindicesArray.push( verticesArray.length / 3 );\\n\\t\\t\\tverticesArray.push( placeholder[ index * 3 + 0 ] );\\n\\t\\t\\tverticesArray.push( placeholder[ index * 3 + 1 ] );\\n\\t\\t\\tverticesArray.push( placeholder[ index * 3 + 2 ] );\\n\\n\\t\\t}\\n\\n\\n\\t\\tfunction addUV( vector2 ) {\\n\\n\\t\\t\\tuvArray.push( vector2.x );\\n\\t\\t\\tuvArray.push( vector2.y );\\n\\n\\t\\t}\\n\\n\\t\\tif ( ! options.arrays ) {\\n\\n\\t\\t\\tthis.setIndex( indicesArray );\\n\\t\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );\\n\\t\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tExtrudeGeometry.WorldUVGenerator = {\\n\\n\\t\\tgenerateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {\\n\\n\\t\\t\\tvar a_x = vertices[ indexA * 3 ];\\n\\t\\t\\tvar a_y = vertices[ indexA * 3 + 1 ];\\n\\t\\t\\tvar b_x = vertices[ indexB * 3 ];\\n\\t\\t\\tvar b_y = vertices[ indexB * 3 + 1 ];\\n\\t\\t\\tvar c_x = vertices[ indexC * 3 ];\\n\\t\\t\\tvar c_y = vertices[ indexC * 3 + 1 ];\\n\\n\\t\\t\\treturn [\\n\\t\\t\\t\\tnew Vector2( a_x, a_y ),\\n\\t\\t\\t\\tnew Vector2( b_x, b_y ),\\n\\t\\t\\t\\tnew Vector2( c_x, c_y )\\n\\t\\t\\t];\\n\\n\\t\\t},\\n\\n\\t\\tgenerateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {\\n\\n\\t\\t\\tvar a_x = vertices[ indexA * 3 ];\\n\\t\\t\\tvar a_y = vertices[ indexA * 3 + 1 ];\\n\\t\\t\\tvar a_z = vertices[ indexA * 3 + 2 ];\\n\\t\\t\\tvar b_x = vertices[ indexB * 3 ];\\n\\t\\t\\tvar b_y = vertices[ indexB * 3 + 1 ];\\n\\t\\t\\tvar b_z = vertices[ indexB * 3 + 2 ];\\n\\t\\t\\tvar c_x = vertices[ indexC * 3 ];\\n\\t\\t\\tvar c_y = vertices[ indexC * 3 + 1 ];\\n\\t\\t\\tvar c_z = vertices[ indexC * 3 + 2 ];\\n\\t\\t\\tvar d_x = vertices[ indexD * 3 ];\\n\\t\\t\\tvar d_y = vertices[ indexD * 3 + 1 ];\\n\\t\\t\\tvar d_z = vertices[ indexD * 3 + 2 ];\\n\\n\\t\\t\\tif ( Math.abs( a_y - b_y ) < 0.01 ) {\\n\\n\\t\\t\\t\\treturn [\\n\\t\\t\\t\\t\\tnew Vector2( a_x, 1 - a_z ),\\n\\t\\t\\t\\t\\tnew Vector2( b_x, 1 - b_z ),\\n\\t\\t\\t\\t\\tnew Vector2( c_x, 1 - c_z ),\\n\\t\\t\\t\\t\\tnew Vector2( d_x, 1 - d_z )\\n\\t\\t\\t\\t];\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\treturn [\\n\\t\\t\\t\\t\\tnew Vector2( a_y, 1 - a_z ),\\n\\t\\t\\t\\t\\tnew Vector2( b_y, 1 - b_z ),\\n\\t\\t\\t\\t\\tnew Vector2( c_y, 1 - c_z ),\\n\\t\\t\\t\\t\\tnew Vector2( d_y, 1 - d_z )\\n\\t\\t\\t\\t];\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t *\\n\\t * Text = 3D Text\\n\\t *\\n\\t * parameters = {\\n\\t *  font: <THREE.Font>, // font\\n\\t *\\n\\t *  size: <float>, // size of the text\\n\\t *  height: <float>, // thickness to extrude text\\n\\t *  curveSegments: <int>, // number of points on the curves\\n\\t *\\n\\t *  bevelEnabled: <bool>, // turn on bevel\\n\\t *  bevelThickness: <float>, // how deep into text bevel goes\\n\\t *  bevelSize: <float> // how far from text outline is bevel\\n\\t * }\\n\\t */\\n\\n\\t// TextGeometry\\n\\n\\tfunction TextGeometry( text, parameters ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'TextGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\ttext: text,\\n\\t\\t\\tparameters: parameters\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tTextGeometry.prototype = Object.create( Geometry.prototype );\\n\\tTextGeometry.prototype.constructor = TextGeometry;\\n\\n\\t// TextBufferGeometry\\n\\n\\tfunction TextBufferGeometry( text, parameters ) {\\n\\n\\t\\tparameters = parameters || {};\\n\\n\\t\\tvar font = parameters.font;\\n\\n\\t\\tif ( ! ( font && font.isFont ) ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\\n\\t\\t\\treturn new Geometry();\\n\\n\\t\\t}\\n\\n\\t\\tvar shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\\n\\n\\t\\t// translate parameters to ExtrudeGeometry API\\n\\n\\t\\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\\n\\n\\t\\t// defaults\\n\\n\\t\\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\\n\\t\\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\\n\\t\\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\\n\\n\\t\\tExtrudeBufferGeometry.call( this, shapes, parameters );\\n\\n\\t\\tthis.type = 'TextBufferGeometry';\\n\\n\\t}\\n\\n\\tTextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype );\\n\\tTextBufferGeometry.prototype.constructor = TextBufferGeometry;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author benaadams / https://twitter.com/ben_a_adams\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// SphereGeometry\\n\\n\\tfunction SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'SphereGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\twidthSegments: widthSegments,\\n\\t\\t\\theightSegments: heightSegments,\\n\\t\\t\\tphiStart: phiStart,\\n\\t\\t\\tphiLength: phiLength,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tSphereGeometry.prototype = Object.create( Geometry.prototype );\\n\\tSphereGeometry.prototype.constructor = SphereGeometry;\\n\\n\\t// SphereBufferGeometry\\n\\n\\tfunction SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'SphereBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\twidthSegments: widthSegments,\\n\\t\\t\\theightSegments: heightSegments,\\n\\t\\t\\tphiStart: phiStart,\\n\\t\\t\\tphiLength: phiLength,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t\\tradius = radius || 1;\\n\\n\\t\\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\\n\\t\\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\\n\\n\\t\\tphiStart = phiStart !== undefined ? phiStart : 0;\\n\\t\\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\\n\\n\\t\\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\\n\\t\\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\\n\\n\\t\\tvar thetaEnd = thetaStart + thetaLength;\\n\\n\\t\\tvar ix, iy;\\n\\n\\t\\tvar index = 0;\\n\\t\\tvar grid = [];\\n\\n\\t\\tvar vertex = new Vector3();\\n\\t\\tvar normal = new Vector3();\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// generate vertices, normals and uvs\\n\\n\\t\\tfor ( iy = 0; iy <= heightSegments; iy ++ ) {\\n\\n\\t\\t\\tvar verticesRow = [];\\n\\n\\t\\t\\tvar v = iy / heightSegments;\\n\\n\\t\\t\\tfor ( ix = 0; ix <= widthSegments; ix ++ ) {\\n\\n\\t\\t\\t\\tvar u = ix / widthSegments;\\n\\n\\t\\t\\t\\t// vertex\\n\\n\\t\\t\\t\\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\\n\\t\\t\\t\\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\\n\\t\\t\\t\\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\\n\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t// normal\\n\\n\\t\\t\\t\\tnormal.set( vertex.x, vertex.y, vertex.z ).normalize();\\n\\t\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\n\\n\\t\\t\\t\\t// uv\\n\\n\\t\\t\\t\\tuvs.push( u, 1 - v );\\n\\n\\t\\t\\t\\tverticesRow.push( index ++ );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tgrid.push( verticesRow );\\n\\n\\t\\t}\\n\\n\\t\\t// indices\\n\\n\\t\\tfor ( iy = 0; iy < heightSegments; iy ++ ) {\\n\\n\\t\\t\\tfor ( ix = 0; ix < widthSegments; ix ++ ) {\\n\\n\\t\\t\\t\\tvar a = grid[ iy ][ ix + 1 ];\\n\\t\\t\\t\\tvar b = grid[ iy ][ ix ];\\n\\t\\t\\t\\tvar c = grid[ iy + 1 ][ ix ];\\n\\t\\t\\t\\tvar d = grid[ iy + 1 ][ ix + 1 ];\\n\\n\\t\\t\\t\\tif ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );\\n\\t\\t\\t\\tif ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t}\\n\\n\\tSphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tSphereBufferGeometry.prototype.constructor = SphereBufferGeometry;\\n\\n\\t/**\\n\\t * @author Kaleb Murphy\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// RingGeometry\\n\\n\\tfunction RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'RingGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tinnerRadius: innerRadius,\\n\\t\\t\\touterRadius: outerRadius,\\n\\t\\t\\tthetaSegments: thetaSegments,\\n\\t\\t\\tphiSegments: phiSegments,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tRingGeometry.prototype = Object.create( Geometry.prototype );\\n\\tRingGeometry.prototype.constructor = RingGeometry;\\n\\n\\t// RingBufferGeometry\\n\\n\\tfunction RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'RingBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tinnerRadius: innerRadius,\\n\\t\\t\\touterRadius: outerRadius,\\n\\t\\t\\tthetaSegments: thetaSegments,\\n\\t\\t\\tphiSegments: phiSegments,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t\\tinnerRadius = innerRadius || 0.5;\\n\\t\\touterRadius = outerRadius || 1;\\n\\n\\t\\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\\n\\t\\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\\n\\n\\t\\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\\n\\t\\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// some helper variables\\n\\n\\t\\tvar segment;\\n\\t\\tvar radius = innerRadius;\\n\\t\\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\\n\\t\\tvar vertex = new Vector3();\\n\\t\\tvar uv = new Vector2();\\n\\t\\tvar j, i;\\n\\n\\t\\t// generate vertices, normals and uvs\\n\\n\\t\\tfor ( j = 0; j <= phiSegments; j ++ ) {\\n\\n\\t\\t\\tfor ( i = 0; i <= thetaSegments; i ++ ) {\\n\\n\\t\\t\\t\\t// values are generate from the inside of the ring to the outside\\n\\n\\t\\t\\t\\tsegment = thetaStart + i / thetaSegments * thetaLength;\\n\\n\\t\\t\\t\\t// vertex\\n\\n\\t\\t\\t\\tvertex.x = radius * Math.cos( segment );\\n\\t\\t\\t\\tvertex.y = radius * Math.sin( segment );\\n\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t// normal\\n\\n\\t\\t\\t\\tnormals.push( 0, 0, 1 );\\n\\n\\t\\t\\t\\t// uv\\n\\n\\t\\t\\t\\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\\n\\t\\t\\t\\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\\n\\n\\t\\t\\t\\tuvs.push( uv.x, uv.y );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// increase the radius for next row of vertices\\n\\n\\t\\t\\tradius += radiusStep;\\n\\n\\t\\t}\\n\\n\\t\\t// indices\\n\\n\\t\\tfor ( j = 0; j < phiSegments; j ++ ) {\\n\\n\\t\\t\\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\\n\\n\\t\\t\\tfor ( i = 0; i < thetaSegments; i ++ ) {\\n\\n\\t\\t\\t\\tsegment = i + thetaSegmentLevel;\\n\\n\\t\\t\\t\\tvar a = segment;\\n\\t\\t\\t\\tvar b = segment + thetaSegments + 1;\\n\\t\\t\\t\\tvar c = segment + thetaSegments + 2;\\n\\t\\t\\t\\tvar d = segment + 1;\\n\\n\\t\\t\\t\\t// faces\\n\\n\\t\\t\\t\\tindices.push( a, b, d );\\n\\t\\t\\t\\tindices.push( b, c, d );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t}\\n\\n\\tRingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tRingBufferGeometry.prototype.constructor = RingBufferGeometry;\\n\\n\\t/**\\n\\t * @author astrodud / http://astrodud.isgreat.org/\\n\\t * @author zz85 / https://github.com/zz85\\n\\t * @author bhouston / http://clara.io\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// LatheGeometry\\n\\n\\tfunction LatheGeometry( points, segments, phiStart, phiLength ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'LatheGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tpoints: points,\\n\\t\\t\\tsegments: segments,\\n\\t\\t\\tphiStart: phiStart,\\n\\t\\t\\tphiLength: phiLength\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tLatheGeometry.prototype = Object.create( Geometry.prototype );\\n\\tLatheGeometry.prototype.constructor = LatheGeometry;\\n\\n\\t// LatheBufferGeometry\\n\\n\\tfunction LatheBufferGeometry( points, segments, phiStart, phiLength ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'LatheBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tpoints: points,\\n\\t\\t\\tsegments: segments,\\n\\t\\t\\tphiStart: phiStart,\\n\\t\\t\\tphiLength: phiLength\\n\\t\\t};\\n\\n\\t\\tsegments = Math.floor( segments ) || 12;\\n\\t\\tphiStart = phiStart || 0;\\n\\t\\tphiLength = phiLength || Math.PI * 2;\\n\\n\\t\\t// clamp phiLength so it's in range of [ 0, 2PI ]\\n\\n\\t\\tphiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );\\n\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar base;\\n\\t\\tvar inverseSegments = 1.0 / segments;\\n\\t\\tvar vertex = new Vector3();\\n\\t\\tvar uv = new Vector2();\\n\\t\\tvar i, j;\\n\\n\\t\\t// generate vertices and uvs\\n\\n\\t\\tfor ( i = 0; i <= segments; i ++ ) {\\n\\n\\t\\t\\tvar phi = phiStart + i * inverseSegments * phiLength;\\n\\n\\t\\t\\tvar sin = Math.sin( phi );\\n\\t\\t\\tvar cos = Math.cos( phi );\\n\\n\\t\\t\\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\\n\\n\\t\\t\\t\\t// vertex\\n\\n\\t\\t\\t\\tvertex.x = points[ j ].x * sin;\\n\\t\\t\\t\\tvertex.y = points[ j ].y;\\n\\t\\t\\t\\tvertex.z = points[ j ].x * cos;\\n\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t// uv\\n\\n\\t\\t\\t\\tuv.x = i / segments;\\n\\t\\t\\t\\tuv.y = j / ( points.length - 1 );\\n\\n\\t\\t\\t\\tuvs.push( uv.x, uv.y );\\n\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// indices\\n\\n\\t\\tfor ( i = 0; i < segments; i ++ ) {\\n\\n\\t\\t\\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\\n\\n\\t\\t\\t\\tbase = j + i * points.length;\\n\\n\\t\\t\\t\\tvar a = base;\\n\\t\\t\\t\\tvar b = base + points.length;\\n\\t\\t\\t\\tvar c = base + points.length + 1;\\n\\t\\t\\t\\tvar d = base + 1;\\n\\n\\t\\t\\t\\t// faces\\n\\n\\t\\t\\t\\tindices.push( a, b, d );\\n\\t\\t\\t\\tindices.push( b, c, d );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t\\t// generate normals\\n\\n\\t\\tthis.computeVertexNormals();\\n\\n\\t\\t// if the geometry is closed, we need to average the normals along the seam.\\n\\t\\t// because the corresponding vertices are identical (but still have different UVs).\\n\\n\\t\\tif ( phiLength === Math.PI * 2 ) {\\n\\n\\t\\t\\tvar normals = this.attributes.normal.array;\\n\\t\\t\\tvar n1 = new Vector3();\\n\\t\\t\\tvar n2 = new Vector3();\\n\\t\\t\\tvar n = new Vector3();\\n\\n\\t\\t\\t// this is the buffer offset for the last line of vertices\\n\\n\\t\\t\\tbase = segments * points.length * 3;\\n\\n\\t\\t\\tfor ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\\n\\n\\t\\t\\t\\t// select the normal of the vertex in the first line\\n\\n\\t\\t\\t\\tn1.x = normals[ j + 0 ];\\n\\t\\t\\t\\tn1.y = normals[ j + 1 ];\\n\\t\\t\\t\\tn1.z = normals[ j + 2 ];\\n\\n\\t\\t\\t\\t// select the normal of the vertex in the last line\\n\\n\\t\\t\\t\\tn2.x = normals[ base + j + 0 ];\\n\\t\\t\\t\\tn2.y = normals[ base + j + 1 ];\\n\\t\\t\\t\\tn2.z = normals[ base + j + 2 ];\\n\\n\\t\\t\\t\\t// average normals\\n\\n\\t\\t\\t\\tn.addVectors( n1, n2 ).normalize();\\n\\n\\t\\t\\t\\t// assign the new values to both normals\\n\\n\\t\\t\\t\\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\\n\\t\\t\\t\\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\\n\\t\\t\\t\\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tLatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tLatheBufferGeometry.prototype.constructor = LatheBufferGeometry;\\n\\n\\t/**\\n\\t * @author jonobr1 / http://jonobr1.com\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// ShapeGeometry\\n\\n\\tfunction ShapeGeometry( shapes, curveSegments ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'ShapeGeometry';\\n\\n\\t\\tif ( typeof curveSegments === 'object' ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );\\n\\n\\t\\t\\tcurveSegments = curveSegments.curveSegments;\\n\\n\\t\\t}\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tshapes: shapes,\\n\\t\\t\\tcurveSegments: curveSegments\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tShapeGeometry.prototype = Object.create( Geometry.prototype );\\n\\tShapeGeometry.prototype.constructor = ShapeGeometry;\\n\\n\\tShapeGeometry.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Geometry.prototype.toJSON.call( this );\\n\\n\\t\\tvar shapes = this.parameters.shapes;\\n\\n\\t\\treturn toJSON( shapes, data );\\n\\n\\t};\\n\\n\\t// ShapeBufferGeometry\\n\\n\\tfunction ShapeBufferGeometry( shapes, curveSegments ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'ShapeBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tshapes: shapes,\\n\\t\\t\\tcurveSegments: curveSegments\\n\\t\\t};\\n\\n\\t\\tcurveSegments = curveSegments || 12;\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar groupStart = 0;\\n\\t\\tvar groupCount = 0;\\n\\n\\t\\t// allow single and array values for \\\"shapes\\\" parameter\\n\\n\\t\\tif ( Array.isArray( shapes ) === false ) {\\n\\n\\t\\t\\taddShape( shapes );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tfor ( var i = 0; i < shapes.length; i ++ ) {\\n\\n\\t\\t\\t\\taddShape( shapes[ i ] );\\n\\n\\t\\t\\t\\tthis.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support\\n\\n\\t\\t\\t\\tgroupStart += groupCount;\\n\\t\\t\\t\\tgroupCount = 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\n\\t\\t// helper functions\\n\\n\\t\\tfunction addShape( shape ) {\\n\\n\\t\\t\\tvar i, l, shapeHole;\\n\\n\\t\\t\\tvar indexOffset = vertices.length / 3;\\n\\t\\t\\tvar points = shape.extractPoints( curveSegments );\\n\\n\\t\\t\\tvar shapeVertices = points.shape;\\n\\t\\t\\tvar shapeHoles = points.holes;\\n\\n\\t\\t\\t// check direction of vertices\\n\\n\\t\\t\\tif ( ShapeUtils.isClockWise( shapeVertices ) === false ) {\\n\\n\\t\\t\\t\\tshapeVertices = shapeVertices.reverse();\\n\\n\\t\\t\\t\\t// also check if holes are in the opposite direction\\n\\n\\t\\t\\t\\tfor ( i = 0, l = shapeHoles.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tshapeHole = shapeHoles[ i ];\\n\\n\\t\\t\\t\\t\\tif ( ShapeUtils.isClockWise( shapeHole ) === true ) {\\n\\n\\t\\t\\t\\t\\t\\tshapeHoles[ i ] = shapeHole.reverse();\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );\\n\\n\\t\\t\\t// join vertices of inner and outer paths to a single array\\n\\n\\t\\t\\tfor ( i = 0, l = shapeHoles.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tshapeHole = shapeHoles[ i ];\\n\\t\\t\\t\\tshapeVertices = shapeVertices.concat( shapeHole );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// vertices, normals, uvs\\n\\n\\t\\t\\tfor ( i = 0, l = shapeVertices.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar vertex = shapeVertices[ i ];\\n\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, 0 );\\n\\t\\t\\t\\tnormals.push( 0, 0, 1 );\\n\\t\\t\\t\\tuvs.push( vertex.x, vertex.y ); // world uvs\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// incides\\n\\n\\t\\t\\tfor ( i = 0, l = faces.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar face = faces[ i ];\\n\\n\\t\\t\\t\\tvar a = face[ 0 ] + indexOffset;\\n\\t\\t\\t\\tvar b = face[ 1 ] + indexOffset;\\n\\t\\t\\t\\tvar c = face[ 2 ] + indexOffset;\\n\\n\\t\\t\\t\\tindices.push( a, b, c );\\n\\t\\t\\t\\tgroupCount += 3;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;\\n\\n\\tShapeBufferGeometry.prototype.toJSON = function () {\\n\\n\\t\\tvar data = BufferGeometry.prototype.toJSON.call( this );\\n\\n\\t\\tvar shapes = this.parameters.shapes;\\n\\n\\t\\treturn toJSON( shapes, data );\\n\\n\\t};\\n\\n\\t//\\n\\n\\tfunction toJSON( shapes, data ) {\\n\\n\\t\\tdata.shapes = [];\\n\\n\\t\\tif ( Array.isArray( shapes ) ) {\\n\\n\\t\\t\\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar shape = shapes[ i ];\\n\\n\\t\\t\\t\\tdata.shapes.push( shape.uuid );\\n\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tdata.shapes.push( shapes.uuid );\\n\\n\\t\\t}\\n\\n\\t\\treturn data;\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\tfunction EdgesGeometry( geometry, thresholdAngle ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'EdgesGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tthresholdAngle: thresholdAngle\\n\\t\\t};\\n\\n\\t\\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\\n\\n\\t\\t// buffer\\n\\n\\t\\tvar vertices = [];\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );\\n\\t\\tvar edge = [ 0, 0 ], edges = {}, edge1, edge2;\\n\\t\\tvar key, keys = [ 'a', 'b', 'c' ];\\n\\n\\t\\t// prepare source geometry\\n\\n\\t\\tvar geometry2;\\n\\n\\t\\tif ( geometry.isBufferGeometry ) {\\n\\n\\t\\t\\tgeometry2 = new Geometry();\\n\\t\\t\\tgeometry2.fromBufferGeometry( geometry );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tgeometry2 = geometry.clone();\\n\\n\\t\\t}\\n\\n\\t\\tgeometry2.mergeVertices();\\n\\t\\tgeometry2.computeFaceNormals();\\n\\n\\t\\tvar sourceVertices = geometry2.vertices;\\n\\t\\tvar faces = geometry2.faces;\\n\\n\\t\\t// now create a data structure where each entry represents an edge with its adjoining faces\\n\\n\\t\\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\\n\\n\\t\\t\\tvar face = faces[ i ];\\n\\n\\t\\t\\tfor ( var j = 0; j < 3; j ++ ) {\\n\\n\\t\\t\\t\\tedge1 = face[ keys[ j ] ];\\n\\t\\t\\t\\tedge2 = face[ keys[ ( j + 1 ) % 3 ] ];\\n\\t\\t\\t\\tedge[ 0 ] = Math.min( edge1, edge2 );\\n\\t\\t\\t\\tedge[ 1 ] = Math.max( edge1, edge2 );\\n\\n\\t\\t\\t\\tkey = edge[ 0 ] + ',' + edge[ 1 ];\\n\\n\\t\\t\\t\\tif ( edges[ key ] === undefined ) {\\n\\n\\t\\t\\t\\t\\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tedges[ key ].face2 = i;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// generate vertices\\n\\n\\t\\tfor ( key in edges ) {\\n\\n\\t\\t\\tvar e = edges[ key ];\\n\\n\\t\\t\\t// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.\\n\\n\\t\\t\\tif ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {\\n\\n\\t\\t\\t\\tvar vertex = sourceVertices[ e.index1 ];\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\tvertex = sourceVertices[ e.index2 ];\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\n\\t}\\n\\n\\tEdgesGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tEdgesGeometry.prototype.constructor = EdgesGeometry;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// CylinderGeometry\\n\\n\\tfunction CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'CylinderGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradiusTop: radiusTop,\\n\\t\\t\\tradiusBottom: radiusBottom,\\n\\t\\t\\theight: height,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\theightSegments: heightSegments,\\n\\t\\t\\topenEnded: openEnded,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tCylinderGeometry.prototype = Object.create( Geometry.prototype );\\n\\tCylinderGeometry.prototype.constructor = CylinderGeometry;\\n\\n\\t// CylinderBufferGeometry\\n\\n\\tfunction CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'CylinderBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradiusTop: radiusTop,\\n\\t\\t\\tradiusBottom: radiusBottom,\\n\\t\\t\\theight: height,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\theightSegments: heightSegments,\\n\\t\\t\\topenEnded: openEnded,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\tradiusTop = radiusTop !== undefined ? radiusTop : 1;\\n\\t\\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 1;\\n\\t\\theight = height || 1;\\n\\n\\t\\tradialSegments = Math.floor( radialSegments ) || 8;\\n\\t\\theightSegments = Math.floor( heightSegments ) || 1;\\n\\n\\t\\topenEnded = openEnded !== undefined ? openEnded : false;\\n\\t\\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\\n\\t\\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar index = 0;\\n\\t\\tvar indexArray = [];\\n\\t\\tvar halfHeight = height / 2;\\n\\t\\tvar groupStart = 0;\\n\\n\\t\\t// generate geometry\\n\\n\\t\\tgenerateTorso();\\n\\n\\t\\tif ( openEnded === false ) {\\n\\n\\t\\t\\tif ( radiusTop > 0 ) generateCap( true );\\n\\t\\t\\tif ( radiusBottom > 0 ) generateCap( false );\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t\\tfunction generateTorso() {\\n\\n\\t\\t\\tvar x, y;\\n\\t\\t\\tvar normal = new Vector3();\\n\\t\\t\\tvar vertex = new Vector3();\\n\\n\\t\\t\\tvar groupCount = 0;\\n\\n\\t\\t\\t// this will be used to calculate the normal\\n\\t\\t\\tvar slope = ( radiusBottom - radiusTop ) / height;\\n\\n\\t\\t\\t// generate vertices, normals and uvs\\n\\n\\t\\t\\tfor ( y = 0; y <= heightSegments; y ++ ) {\\n\\n\\t\\t\\t\\tvar indexRow = [];\\n\\n\\t\\t\\t\\tvar v = y / heightSegments;\\n\\n\\t\\t\\t\\t// calculate the radius of the current row\\n\\n\\t\\t\\t\\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\\n\\n\\t\\t\\t\\tfor ( x = 0; x <= radialSegments; x ++ ) {\\n\\n\\t\\t\\t\\t\\tvar u = x / radialSegments;\\n\\n\\t\\t\\t\\t\\tvar theta = u * thetaLength + thetaStart;\\n\\n\\t\\t\\t\\t\\tvar sinTheta = Math.sin( theta );\\n\\t\\t\\t\\t\\tvar cosTheta = Math.cos( theta );\\n\\n\\t\\t\\t\\t\\t// vertex\\n\\n\\t\\t\\t\\t\\tvertex.x = radius * sinTheta;\\n\\t\\t\\t\\t\\tvertex.y = - v * height + halfHeight;\\n\\t\\t\\t\\t\\tvertex.z = radius * cosTheta;\\n\\t\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t\\t// normal\\n\\n\\t\\t\\t\\t\\tnormal.set( sinTheta, slope, cosTheta ).normalize();\\n\\t\\t\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\n\\n\\t\\t\\t\\t\\t// uv\\n\\n\\t\\t\\t\\t\\tuvs.push( u, 1 - v );\\n\\n\\t\\t\\t\\t\\t// save index of vertex in respective row\\n\\n\\t\\t\\t\\t\\tindexRow.push( index ++ );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// now save vertices of the row in our index array\\n\\n\\t\\t\\t\\tindexArray.push( indexRow );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// generate indices\\n\\n\\t\\t\\tfor ( x = 0; x < radialSegments; x ++ ) {\\n\\n\\t\\t\\t\\tfor ( y = 0; y < heightSegments; y ++ ) {\\n\\n\\t\\t\\t\\t\\t// we use the index array to access the correct indices\\n\\n\\t\\t\\t\\t\\tvar a = indexArray[ y ][ x ];\\n\\t\\t\\t\\t\\tvar b = indexArray[ y + 1 ][ x ];\\n\\t\\t\\t\\t\\tvar c = indexArray[ y + 1 ][ x + 1 ];\\n\\t\\t\\t\\t\\tvar d = indexArray[ y ][ x + 1 ];\\n\\n\\t\\t\\t\\t\\t// faces\\n\\n\\t\\t\\t\\t\\tindices.push( a, b, d );\\n\\t\\t\\t\\t\\tindices.push( b, c, d );\\n\\n\\t\\t\\t\\t\\t// update group counter\\n\\n\\t\\t\\t\\t\\tgroupCount += 6;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// add a group to the geometry. this will ensure multi material support\\n\\n\\t\\t\\tscope.addGroup( groupStart, groupCount, 0 );\\n\\n\\t\\t\\t// calculate new start value for groups\\n\\n\\t\\t\\tgroupStart += groupCount;\\n\\n\\t\\t}\\n\\n\\t\\tfunction generateCap( top ) {\\n\\n\\t\\t\\tvar x, centerIndexStart, centerIndexEnd;\\n\\n\\t\\t\\tvar uv = new Vector2();\\n\\t\\t\\tvar vertex = new Vector3();\\n\\n\\t\\t\\tvar groupCount = 0;\\n\\n\\t\\t\\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\\n\\t\\t\\tvar sign = ( top === true ) ? 1 : - 1;\\n\\n\\t\\t\\t// save the index of the first center vertex\\n\\t\\t\\tcenterIndexStart = index;\\n\\n\\t\\t\\t// first we generate the center vertex data of the cap.\\n\\t\\t\\t// because the geometry needs one set of uvs per face,\\n\\t\\t\\t// we must generate a center vertex per face/segment\\n\\n\\t\\t\\tfor ( x = 1; x <= radialSegments; x ++ ) {\\n\\n\\t\\t\\t\\t// vertex\\n\\n\\t\\t\\t\\tvertices.push( 0, halfHeight * sign, 0 );\\n\\n\\t\\t\\t\\t// normal\\n\\n\\t\\t\\t\\tnormals.push( 0, sign, 0 );\\n\\n\\t\\t\\t\\t// uv\\n\\n\\t\\t\\t\\tuvs.push( 0.5, 0.5 );\\n\\n\\t\\t\\t\\t// increase index\\n\\n\\t\\t\\t\\tindex ++;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// save the index of the last center vertex\\n\\n\\t\\t\\tcenterIndexEnd = index;\\n\\n\\t\\t\\t// now we generate the surrounding vertices, normals and uvs\\n\\n\\t\\t\\tfor ( x = 0; x <= radialSegments; x ++ ) {\\n\\n\\t\\t\\t\\tvar u = x / radialSegments;\\n\\t\\t\\t\\tvar theta = u * thetaLength + thetaStart;\\n\\n\\t\\t\\t\\tvar cosTheta = Math.cos( theta );\\n\\t\\t\\t\\tvar sinTheta = Math.sin( theta );\\n\\n\\t\\t\\t\\t// vertex\\n\\n\\t\\t\\t\\tvertex.x = radius * sinTheta;\\n\\t\\t\\t\\tvertex.y = halfHeight * sign;\\n\\t\\t\\t\\tvertex.z = radius * cosTheta;\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t// normal\\n\\n\\t\\t\\t\\tnormals.push( 0, sign, 0 );\\n\\n\\t\\t\\t\\t// uv\\n\\n\\t\\t\\t\\tuv.x = ( cosTheta * 0.5 ) + 0.5;\\n\\t\\t\\t\\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\\n\\t\\t\\t\\tuvs.push( uv.x, uv.y );\\n\\n\\t\\t\\t\\t// increase index\\n\\n\\t\\t\\t\\tindex ++;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// generate indices\\n\\n\\t\\t\\tfor ( x = 0; x < radialSegments; x ++ ) {\\n\\n\\t\\t\\t\\tvar c = centerIndexStart + x;\\n\\t\\t\\t\\tvar i = centerIndexEnd + x;\\n\\n\\t\\t\\t\\tif ( top === true ) {\\n\\n\\t\\t\\t\\t\\t// face top\\n\\n\\t\\t\\t\\t\\tindices.push( i, i + 1, c );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// face bottom\\n\\n\\t\\t\\t\\t\\tindices.push( i + 1, i, c );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgroupCount += 3;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// add a group to the geometry. this will ensure multi material support\\n\\n\\t\\t\\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\\n\\n\\t\\t\\t// calculate new start value for groups\\n\\n\\t\\t\\tgroupStart += groupCount;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tCylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tCylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;\\n\\n\\t/**\\n\\t * @author abelnation / http://github.com/abelnation\\n\\t */\\n\\n\\t// ConeGeometry\\n\\n\\tfunction ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\\n\\n\\t\\tCylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\\n\\n\\t\\tthis.type = 'ConeGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\theight: height,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\theightSegments: heightSegments,\\n\\t\\t\\topenEnded: openEnded,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t}\\n\\n\\tConeGeometry.prototype = Object.create( CylinderGeometry.prototype );\\n\\tConeGeometry.prototype.constructor = ConeGeometry;\\n\\n\\t// ConeBufferGeometry\\n\\n\\tfunction ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\\n\\n\\t\\tCylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\\n\\n\\t\\tthis.type = 'ConeBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\theight: height,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\theightSegments: heightSegments,\\n\\t\\t\\topenEnded: openEnded,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t}\\n\\n\\tConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );\\n\\tConeBufferGeometry.prototype.constructor = ConeBufferGeometry;\\n\\n\\t/**\\n\\t * @author benaadams / https://twitter.com/ben_a_adams\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t * @author hughes\\n\\t */\\n\\n\\t// CircleGeometry\\n\\n\\tfunction CircleGeometry( radius, segments, thetaStart, thetaLength ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'CircleGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tsegments: segments,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tCircleGeometry.prototype = Object.create( Geometry.prototype );\\n\\tCircleGeometry.prototype.constructor = CircleGeometry;\\n\\n\\t// CircleBufferGeometry\\n\\n\\tfunction CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'CircleBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tsegments: segments,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t\\tradius = radius || 1;\\n\\t\\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\\n\\n\\t\\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\\n\\t\\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar i, s;\\n\\t\\tvar vertex = new Vector3();\\n\\t\\tvar uv = new Vector2();\\n\\n\\t\\t// center point\\n\\n\\t\\tvertices.push( 0, 0, 0 );\\n\\t\\tnormals.push( 0, 0, 1 );\\n\\t\\tuvs.push( 0.5, 0.5 );\\n\\n\\t\\tfor ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {\\n\\n\\t\\t\\tvar segment = thetaStart + s / segments * thetaLength;\\n\\n\\t\\t\\t// vertex\\n\\n\\t\\t\\tvertex.x = radius * Math.cos( segment );\\n\\t\\t\\tvertex.y = radius * Math.sin( segment );\\n\\n\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t// normal\\n\\n\\t\\t\\tnormals.push( 0, 0, 1 );\\n\\n\\t\\t\\t// uvs\\n\\n\\t\\t\\tuv.x = ( vertices[ i ] / radius + 1 ) / 2;\\n\\t\\t\\tuv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;\\n\\n\\t\\t\\tuvs.push( uv.x, uv.y );\\n\\n\\t\\t}\\n\\n\\t\\t// indices\\n\\n\\t\\tfor ( i = 1; i <= segments; i ++ ) {\\n\\n\\t\\t\\tindices.push( i, i + 1, 0 );\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t}\\n\\n\\tCircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tCircleBufferGeometry.prototype.constructor = CircleBufferGeometry;\\n\\n\\n\\n\\tvar Geometries = Object.freeze({\\n\\t\\tWireframeGeometry: WireframeGeometry,\\n\\t\\tParametricGeometry: ParametricGeometry,\\n\\t\\tParametricBufferGeometry: ParametricBufferGeometry,\\n\\t\\tTetrahedronGeometry: TetrahedronGeometry,\\n\\t\\tTetrahedronBufferGeometry: TetrahedronBufferGeometry,\\n\\t\\tOctahedronGeometry: OctahedronGeometry,\\n\\t\\tOctahedronBufferGeometry: OctahedronBufferGeometry,\\n\\t\\tIcosahedronGeometry: IcosahedronGeometry,\\n\\t\\tIcosahedronBufferGeometry: IcosahedronBufferGeometry,\\n\\t\\tDodecahedronGeometry: DodecahedronGeometry,\\n\\t\\tDodecahedronBufferGeometry: DodecahedronBufferGeometry,\\n\\t\\tPolyhedronGeometry: PolyhedronGeometry,\\n\\t\\tPolyhedronBufferGeometry: PolyhedronBufferGeometry,\\n\\t\\tTubeGeometry: TubeGeometry,\\n\\t\\tTubeBufferGeometry: TubeBufferGeometry,\\n\\t\\tTorusKnotGeometry: TorusKnotGeometry,\\n\\t\\tTorusKnotBufferGeometry: TorusKnotBufferGeometry,\\n\\t\\tTorusGeometry: TorusGeometry,\\n\\t\\tTorusBufferGeometry: TorusBufferGeometry,\\n\\t\\tTextGeometry: TextGeometry,\\n\\t\\tTextBufferGeometry: TextBufferGeometry,\\n\\t\\tSphereGeometry: SphereGeometry,\\n\\t\\tSphereBufferGeometry: SphereBufferGeometry,\\n\\t\\tRingGeometry: RingGeometry,\\n\\t\\tRingBufferGeometry: RingBufferGeometry,\\n\\t\\tPlaneGeometry: PlaneGeometry,\\n\\t\\tPlaneBufferGeometry: PlaneBufferGeometry,\\n\\t\\tLatheGeometry: LatheGeometry,\\n\\t\\tLatheBufferGeometry: LatheBufferGeometry,\\n\\t\\tShapeGeometry: ShapeGeometry,\\n\\t\\tShapeBufferGeometry: ShapeBufferGeometry,\\n\\t\\tExtrudeGeometry: ExtrudeGeometry,\\n\\t\\tExtrudeBufferGeometry: ExtrudeBufferGeometry,\\n\\t\\tEdgesGeometry: EdgesGeometry,\\n\\t\\tConeGeometry: ConeGeometry,\\n\\t\\tConeBufferGeometry: ConeBufferGeometry,\\n\\t\\tCylinderGeometry: CylinderGeometry,\\n\\t\\tCylinderBufferGeometry: CylinderBufferGeometry,\\n\\t\\tCircleGeometry: CircleGeometry,\\n\\t\\tCircleBufferGeometry: CircleBufferGeometry,\\n\\t\\tBoxGeometry: BoxGeometry,\\n\\t\\tBoxBufferGeometry: BoxBufferGeometry\\n\\t});\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t *\\n\\t * parameters = {\\n\\t *  color: <THREE.Color>,\\n\\t *  opacity: <float>\\n\\t * }\\n\\t */\\n\\n\\tfunction ShadowMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'ShadowMaterial';\\n\\n\\t\\tthis.color = new Color( 0x000000 );\\n\\t\\tthis.opacity = 1.0;\\n\\n\\t\\tthis.lights = true;\\n\\t\\tthis.transparent = true;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tShadowMaterial.prototype = Object.create( Material.prototype );\\n\\tShadowMaterial.prototype.constructor = ShadowMaterial;\\n\\n\\tShadowMaterial.prototype.isShadowMaterial = true;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction RawShaderMaterial( parameters ) {\\n\\n\\t\\tShaderMaterial.call( this, parameters );\\n\\n\\t\\tthis.type = 'RawShaderMaterial';\\n\\n\\t}\\n\\n\\tRawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );\\n\\tRawShaderMaterial.prototype.constructor = RawShaderMaterial;\\n\\n\\tRawShaderMaterial.prototype.isRawShaderMaterial = true;\\n\\n\\t/**\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t *\\n\\t * parameters = {\\n\\t *  color: <hex>,\\n\\t *  roughness: <float>,\\n\\t *  metalness: <float>,\\n\\t *  opacity: <float>,\\n\\t *\\n\\t *  map: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  lightMap: new THREE.Texture( <Image> ),\\n\\t *  lightMapIntensity: <float>\\n\\t *\\n\\t *  aoMap: new THREE.Texture( <Image> ),\\n\\t *  aoMapIntensity: <float>\\n\\t *\\n\\t *  emissive: <hex>,\\n\\t *  emissiveIntensity: <float>\\n\\t *  emissiveMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  bumpMap: new THREE.Texture( <Image> ),\\n\\t *  bumpScale: <float>,\\n\\t *\\n\\t *  normalMap: new THREE.Texture( <Image> ),\\n\\t *  normalScale: <Vector2>,\\n\\t *\\n\\t *  displacementMap: new THREE.Texture( <Image> ),\\n\\t *  displacementScale: <float>,\\n\\t *  displacementBias: <float>,\\n\\t *\\n\\t *  roughnessMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  metalnessMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  alphaMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\\n\\t *  envMapIntensity: <float>\\n\\t *\\n\\t *  refractionRatio: <float>,\\n\\t *\\n\\t *  wireframe: <boolean>,\\n\\t *  wireframeLinewidth: <float>,\\n\\t *\\n\\t *  skinning: <bool>,\\n\\t *  morphTargets: <bool>,\\n\\t *  morphNormals: <bool>\\n\\t * }\\n\\t */\\n\\n\\tfunction MeshStandardMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.defines = { 'STANDARD': '' };\\n\\n\\t\\tthis.type = 'MeshStandardMaterial';\\n\\n\\t\\tthis.color = new Color( 0xffffff ); // diffuse\\n\\t\\tthis.roughness = 0.5;\\n\\t\\tthis.metalness = 0.5;\\n\\n\\t\\tthis.map = null;\\n\\n\\t\\tthis.lightMap = null;\\n\\t\\tthis.lightMapIntensity = 1.0;\\n\\n\\t\\tthis.aoMap = null;\\n\\t\\tthis.aoMapIntensity = 1.0;\\n\\n\\t\\tthis.emissive = new Color( 0x000000 );\\n\\t\\tthis.emissiveIntensity = 1.0;\\n\\t\\tthis.emissiveMap = null;\\n\\n\\t\\tthis.bumpMap = null;\\n\\t\\tthis.bumpScale = 1;\\n\\n\\t\\tthis.normalMap = null;\\n\\t\\tthis.normalScale = new Vector2( 1, 1 );\\n\\n\\t\\tthis.displacementMap = null;\\n\\t\\tthis.displacementScale = 1;\\n\\t\\tthis.displacementBias = 0;\\n\\n\\t\\tthis.roughnessMap = null;\\n\\n\\t\\tthis.metalnessMap = null;\\n\\n\\t\\tthis.alphaMap = null;\\n\\n\\t\\tthis.envMap = null;\\n\\t\\tthis.envMapIntensity = 1.0;\\n\\n\\t\\tthis.refractionRatio = 0.98;\\n\\n\\t\\tthis.wireframe = false;\\n\\t\\tthis.wireframeLinewidth = 1;\\n\\t\\tthis.wireframeLinecap = 'round';\\n\\t\\tthis.wireframeLinejoin = 'round';\\n\\n\\t\\tthis.skinning = false;\\n\\t\\tthis.morphTargets = false;\\n\\t\\tthis.morphNormals = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tMeshStandardMaterial.prototype = Object.create( Material.prototype );\\n\\tMeshStandardMaterial.prototype.constructor = MeshStandardMaterial;\\n\\n\\tMeshStandardMaterial.prototype.isMeshStandardMaterial = true;\\n\\n\\tMeshStandardMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.defines = { 'STANDARD': '' };\\n\\n\\t\\tthis.color.copy( source.color );\\n\\t\\tthis.roughness = source.roughness;\\n\\t\\tthis.metalness = source.metalness;\\n\\n\\t\\tthis.map = source.map;\\n\\n\\t\\tthis.lightMap = source.lightMap;\\n\\t\\tthis.lightMapIntensity = source.lightMapIntensity;\\n\\n\\t\\tthis.aoMap = source.aoMap;\\n\\t\\tthis.aoMapIntensity = source.aoMapIntensity;\\n\\n\\t\\tthis.emissive.copy( source.emissive );\\n\\t\\tthis.emissiveMap = source.emissiveMap;\\n\\t\\tthis.emissiveIntensity = source.emissiveIntensity;\\n\\n\\t\\tthis.bumpMap = source.bumpMap;\\n\\t\\tthis.bumpScale = source.bumpScale;\\n\\n\\t\\tthis.normalMap = source.normalMap;\\n\\t\\tthis.normalScale.copy( source.normalScale );\\n\\n\\t\\tthis.displacementMap = source.displacementMap;\\n\\t\\tthis.displacementScale = source.displacementScale;\\n\\t\\tthis.displacementBias = source.displacementBias;\\n\\n\\t\\tthis.roughnessMap = source.roughnessMap;\\n\\n\\t\\tthis.metalnessMap = source.metalnessMap;\\n\\n\\t\\tthis.alphaMap = source.alphaMap;\\n\\n\\t\\tthis.envMap = source.envMap;\\n\\t\\tthis.envMapIntensity = source.envMapIntensity;\\n\\n\\t\\tthis.refractionRatio = source.refractionRatio;\\n\\n\\t\\tthis.wireframe = source.wireframe;\\n\\t\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\n\\t\\tthis.wireframeLinecap = source.wireframeLinecap;\\n\\t\\tthis.wireframeLinejoin = source.wireframeLinejoin;\\n\\n\\t\\tthis.skinning = source.skinning;\\n\\t\\tthis.morphTargets = source.morphTargets;\\n\\t\\tthis.morphNormals = source.morphNormals;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t *\\n\\t * parameters = {\\n\\t *  reflectivity: <float>\\n\\t * }\\n\\t */\\n\\n\\tfunction MeshPhysicalMaterial( parameters ) {\\n\\n\\t\\tMeshStandardMaterial.call( this );\\n\\n\\t\\tthis.defines = { 'PHYSICAL': '' };\\n\\n\\t\\tthis.type = 'MeshPhysicalMaterial';\\n\\n\\t\\tthis.reflectivity = 0.5; // maps to F0 = 0.04\\n\\n\\t\\tthis.clearCoat = 0.0;\\n\\t\\tthis.clearCoatRoughness = 0.0;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tMeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );\\n\\tMeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;\\n\\n\\tMeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;\\n\\n\\tMeshPhysicalMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMeshStandardMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.defines = { 'PHYSICAL': '' };\\n\\n\\t\\tthis.reflectivity = source.reflectivity;\\n\\n\\t\\tthis.clearCoat = source.clearCoat;\\n\\t\\tthis.clearCoatRoughness = source.clearCoatRoughness;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t *\\n\\t * parameters = {\\n\\t *  color: <hex>,\\n\\t *  specular: <hex>,\\n\\t *  shininess: <float>,\\n\\t *  opacity: <float>,\\n\\t *\\n\\t *  map: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  lightMap: new THREE.Texture( <Image> ),\\n\\t *  lightMapIntensity: <float>\\n\\t *\\n\\t *  aoMap: new THREE.Texture( <Image> ),\\n\\t *  aoMapIntensity: <float>\\n\\t *\\n\\t *  emissive: <hex>,\\n\\t *  emissiveIntensity: <float>\\n\\t *  emissiveMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  bumpMap: new THREE.Texture( <Image> ),\\n\\t *  bumpScale: <float>,\\n\\t *\\n\\t *  normalMap: new THREE.Texture( <Image> ),\\n\\t *  normalScale: <Vector2>,\\n\\t *\\n\\t *  displacementMap: new THREE.Texture( <Image> ),\\n\\t *  displacementScale: <float>,\\n\\t *  displacementBias: <float>,\\n\\t *\\n\\t *  specularMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  alphaMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\\n\\t *  combine: THREE.Multiply,\\n\\t *  reflectivity: <float>,\\n\\t *  refractionRatio: <float>,\\n\\t *\\n\\t *  wireframe: <boolean>,\\n\\t *  wireframeLinewidth: <float>,\\n\\t *\\n\\t *  skinning: <bool>,\\n\\t *  morphTargets: <bool>,\\n\\t *  morphNormals: <bool>\\n\\t * }\\n\\t */\\n\\n\\tfunction MeshPhongMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'MeshPhongMaterial';\\n\\n\\t\\tthis.color = new Color( 0xffffff ); // diffuse\\n\\t\\tthis.specular = new Color( 0x111111 );\\n\\t\\tthis.shininess = 30;\\n\\n\\t\\tthis.map = null;\\n\\n\\t\\tthis.lightMap = null;\\n\\t\\tthis.lightMapIntensity = 1.0;\\n\\n\\t\\tthis.aoMap = null;\\n\\t\\tthis.aoMapIntensity = 1.0;\\n\\n\\t\\tthis.emissive = new Color( 0x000000 );\\n\\t\\tthis.emissiveIntensity = 1.0;\\n\\t\\tthis.emissiveMap = null;\\n\\n\\t\\tthis.bumpMap = null;\\n\\t\\tthis.bumpScale = 1;\\n\\n\\t\\tthis.normalMap = null;\\n\\t\\tthis.normalScale = new Vector2( 1, 1 );\\n\\n\\t\\tthis.displacementMap = null;\\n\\t\\tthis.displacementScale = 1;\\n\\t\\tthis.displacementBias = 0;\\n\\n\\t\\tthis.specularMap = null;\\n\\n\\t\\tthis.alphaMap = null;\\n\\n\\t\\tthis.envMap = null;\\n\\t\\tthis.combine = MultiplyOperation;\\n\\t\\tthis.reflectivity = 1;\\n\\t\\tthis.refractionRatio = 0.98;\\n\\n\\t\\tthis.wireframe = false;\\n\\t\\tthis.wireframeLinewidth = 1;\\n\\t\\tthis.wireframeLinecap = 'round';\\n\\t\\tthis.wireframeLinejoin = 'round';\\n\\n\\t\\tthis.skinning = false;\\n\\t\\tthis.morphTargets = false;\\n\\t\\tthis.morphNormals = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tMeshPhongMaterial.prototype = Object.create( Material.prototype );\\n\\tMeshPhongMaterial.prototype.constructor = MeshPhongMaterial;\\n\\n\\tMeshPhongMaterial.prototype.isMeshPhongMaterial = true;\\n\\n\\tMeshPhongMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.color.copy( source.color );\\n\\t\\tthis.specular.copy( source.specular );\\n\\t\\tthis.shininess = source.shininess;\\n\\n\\t\\tthis.map = source.map;\\n\\n\\t\\tthis.lightMap = source.lightMap;\\n\\t\\tthis.lightMapIntensity = source.lightMapIntensity;\\n\\n\\t\\tthis.aoMap = source.aoMap;\\n\\t\\tthis.aoMapIntensity = source.aoMapIntensity;\\n\\n\\t\\tthis.emissive.copy( source.emissive );\\n\\t\\tthis.emissiveMap = source.emissiveMap;\\n\\t\\tthis.emissiveIntensity = source.emissiveIntensity;\\n\\n\\t\\tthis.bumpMap = source.bumpMap;\\n\\t\\tthis.bumpScale = source.bumpScale;\\n\\n\\t\\tthis.normalMap = source.normalMap;\\n\\t\\tthis.normalScale.copy( source.normalScale );\\n\\n\\t\\tthis.displacementMap = source.displacementMap;\\n\\t\\tthis.displacementScale = source.displacementScale;\\n\\t\\tthis.displacementBias = source.displacementBias;\\n\\n\\t\\tthis.specularMap = source.specularMap;\\n\\n\\t\\tthis.alphaMap = source.alphaMap;\\n\\n\\t\\tthis.envMap = source.envMap;\\n\\t\\tthis.combine = source.combine;\\n\\t\\tthis.reflectivity = source.reflectivity;\\n\\t\\tthis.refractionRatio = source.refractionRatio;\\n\\n\\t\\tthis.wireframe = source.wireframe;\\n\\t\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\n\\t\\tthis.wireframeLinecap = source.wireframeLinecap;\\n\\t\\tthis.wireframeLinejoin = source.wireframeLinejoin;\\n\\n\\t\\tthis.skinning = source.skinning;\\n\\t\\tthis.morphTargets = source.morphTargets;\\n\\t\\tthis.morphNormals = source.morphNormals;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author takahirox / http://github.com/takahirox\\n\\t *\\n\\t * parameters = {\\n\\t *  gradientMap: new THREE.Texture( <Image> )\\n\\t * }\\n\\t */\\n\\n\\tfunction MeshToonMaterial( parameters ) {\\n\\n\\t\\tMeshPhongMaterial.call( this );\\n\\n\\t\\tthis.defines = { 'TOON': '' };\\n\\n\\t\\tthis.type = 'MeshToonMaterial';\\n\\n\\t\\tthis.gradientMap = null;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tMeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );\\n\\tMeshToonMaterial.prototype.constructor = MeshToonMaterial;\\n\\n\\tMeshToonMaterial.prototype.isMeshToonMaterial = true;\\n\\n\\tMeshToonMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMeshPhongMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.gradientMap = source.gradientMap;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t *\\n\\t * parameters = {\\n\\t *  opacity: <float>,\\n\\t *\\n\\t *  bumpMap: new THREE.Texture( <Image> ),\\n\\t *  bumpScale: <float>,\\n\\t *\\n\\t *  normalMap: new THREE.Texture( <Image> ),\\n\\t *  normalScale: <Vector2>,\\n\\t *\\n\\t *  displacementMap: new THREE.Texture( <Image> ),\\n\\t *  displacementScale: <float>,\\n\\t *  displacementBias: <float>,\\n\\t *\\n\\t *  wireframe: <boolean>,\\n\\t *  wireframeLinewidth: <float>\\n\\t *\\n\\t *  skinning: <bool>,\\n\\t *  morphTargets: <bool>,\\n\\t *  morphNormals: <bool>\\n\\t * }\\n\\t */\\n\\n\\tfunction MeshNormalMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'MeshNormalMaterial';\\n\\n\\t\\tthis.bumpMap = null;\\n\\t\\tthis.bumpScale = 1;\\n\\n\\t\\tthis.normalMap = null;\\n\\t\\tthis.normalScale = new Vector2( 1, 1 );\\n\\n\\t\\tthis.displacementMap = null;\\n\\t\\tthis.displacementScale = 1;\\n\\t\\tthis.displacementBias = 0;\\n\\n\\t\\tthis.wireframe = false;\\n\\t\\tthis.wireframeLinewidth = 1;\\n\\n\\t\\tthis.fog = false;\\n\\t\\tthis.lights = false;\\n\\n\\t\\tthis.skinning = false;\\n\\t\\tthis.morphTargets = false;\\n\\t\\tthis.morphNormals = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tMeshNormalMaterial.prototype = Object.create( Material.prototype );\\n\\tMeshNormalMaterial.prototype.constructor = MeshNormalMaterial;\\n\\n\\tMeshNormalMaterial.prototype.isMeshNormalMaterial = true;\\n\\n\\tMeshNormalMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.bumpMap = source.bumpMap;\\n\\t\\tthis.bumpScale = source.bumpScale;\\n\\n\\t\\tthis.normalMap = source.normalMap;\\n\\t\\tthis.normalScale.copy( source.normalScale );\\n\\n\\t\\tthis.displacementMap = source.displacementMap;\\n\\t\\tthis.displacementScale = source.displacementScale;\\n\\t\\tthis.displacementBias = source.displacementBias;\\n\\n\\t\\tthis.wireframe = source.wireframe;\\n\\t\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\n\\n\\t\\tthis.skinning = source.skinning;\\n\\t\\tthis.morphTargets = source.morphTargets;\\n\\t\\tthis.morphNormals = source.morphNormals;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t *\\n\\t * parameters = {\\n\\t *  color: <hex>,\\n\\t *  opacity: <float>,\\n\\t *\\n\\t *  map: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  lightMap: new THREE.Texture( <Image> ),\\n\\t *  lightMapIntensity: <float>\\n\\t *\\n\\t *  aoMap: new THREE.Texture( <Image> ),\\n\\t *  aoMapIntensity: <float>\\n\\t *\\n\\t *  emissive: <hex>,\\n\\t *  emissiveIntensity: <float>\\n\\t *  emissiveMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  specularMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  alphaMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\\n\\t *  combine: THREE.Multiply,\\n\\t *  reflectivity: <float>,\\n\\t *  refractionRatio: <float>,\\n\\t *\\n\\t *  wireframe: <boolean>,\\n\\t *  wireframeLinewidth: <float>,\\n\\t *\\n\\t *  skinning: <bool>,\\n\\t *  morphTargets: <bool>,\\n\\t *  morphNormals: <bool>\\n\\t * }\\n\\t */\\n\\n\\tfunction MeshLambertMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'MeshLambertMaterial';\\n\\n\\t\\tthis.color = new Color( 0xffffff ); // diffuse\\n\\n\\t\\tthis.map = null;\\n\\n\\t\\tthis.lightMap = null;\\n\\t\\tthis.lightMapIntensity = 1.0;\\n\\n\\t\\tthis.aoMap = null;\\n\\t\\tthis.aoMapIntensity = 1.0;\\n\\n\\t\\tthis.emissive = new Color( 0x000000 );\\n\\t\\tthis.emissiveIntensity = 1.0;\\n\\t\\tthis.emissiveMap = null;\\n\\n\\t\\tthis.specularMap = null;\\n\\n\\t\\tthis.alphaMap = null;\\n\\n\\t\\tthis.envMap = null;\\n\\t\\tthis.combine = MultiplyOperation;\\n\\t\\tthis.reflectivity = 1;\\n\\t\\tthis.refractionRatio = 0.98;\\n\\n\\t\\tthis.wireframe = false;\\n\\t\\tthis.wireframeLinewidth = 1;\\n\\t\\tthis.wireframeLinecap = 'round';\\n\\t\\tthis.wireframeLinejoin = 'round';\\n\\n\\t\\tthis.skinning = false;\\n\\t\\tthis.morphTargets = false;\\n\\t\\tthis.morphNormals = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tMeshLambertMaterial.prototype = Object.create( Material.prototype );\\n\\tMeshLambertMaterial.prototype.constructor = MeshLambertMaterial;\\n\\n\\tMeshLambertMaterial.prototype.isMeshLambertMaterial = true;\\n\\n\\tMeshLambertMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.color.copy( source.color );\\n\\n\\t\\tthis.map = source.map;\\n\\n\\t\\tthis.lightMap = source.lightMap;\\n\\t\\tthis.lightMapIntensity = source.lightMapIntensity;\\n\\n\\t\\tthis.aoMap = source.aoMap;\\n\\t\\tthis.aoMapIntensity = source.aoMapIntensity;\\n\\n\\t\\tthis.emissive.copy( source.emissive );\\n\\t\\tthis.emissiveMap = source.emissiveMap;\\n\\t\\tthis.emissiveIntensity = source.emissiveIntensity;\\n\\n\\t\\tthis.specularMap = source.specularMap;\\n\\n\\t\\tthis.alphaMap = source.alphaMap;\\n\\n\\t\\tthis.envMap = source.envMap;\\n\\t\\tthis.combine = source.combine;\\n\\t\\tthis.reflectivity = source.reflectivity;\\n\\t\\tthis.refractionRatio = source.refractionRatio;\\n\\n\\t\\tthis.wireframe = source.wireframe;\\n\\t\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\n\\t\\tthis.wireframeLinecap = source.wireframeLinecap;\\n\\t\\tthis.wireframeLinejoin = source.wireframeLinejoin;\\n\\n\\t\\tthis.skinning = source.skinning;\\n\\t\\tthis.morphTargets = source.morphTargets;\\n\\t\\tthis.morphNormals = source.morphNormals;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t *\\n\\t * parameters = {\\n\\t *  color: <hex>,\\n\\t *  opacity: <float>,\\n\\t *\\n\\t *  linewidth: <float>,\\n\\t *\\n\\t *  scale: <float>,\\n\\t *  dashSize: <float>,\\n\\t *  gapSize: <float>\\n\\t * }\\n\\t */\\n\\n\\tfunction LineDashedMaterial( parameters ) {\\n\\n\\t\\tLineBasicMaterial.call( this );\\n\\n\\t\\tthis.type = 'LineDashedMaterial';\\n\\n\\t\\tthis.scale = 1;\\n\\t\\tthis.dashSize = 3;\\n\\t\\tthis.gapSize = 1;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tLineDashedMaterial.prototype = Object.create( LineBasicMaterial.prototype );\\n\\tLineDashedMaterial.prototype.constructor = LineDashedMaterial;\\n\\n\\tLineDashedMaterial.prototype.isLineDashedMaterial = true;\\n\\n\\tLineDashedMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tLineBasicMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.scale = source.scale;\\n\\t\\tthis.dashSize = source.dashSize;\\n\\t\\tthis.gapSize = source.gapSize;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\n\\n\\tvar Materials = Object.freeze({\\n\\t\\tShadowMaterial: ShadowMaterial,\\n\\t\\tSpriteMaterial: SpriteMaterial,\\n\\t\\tRawShaderMaterial: RawShaderMaterial,\\n\\t\\tShaderMaterial: ShaderMaterial,\\n\\t\\tPointsMaterial: PointsMaterial,\\n\\t\\tMeshPhysicalMaterial: MeshPhysicalMaterial,\\n\\t\\tMeshStandardMaterial: MeshStandardMaterial,\\n\\t\\tMeshPhongMaterial: MeshPhongMaterial,\\n\\t\\tMeshToonMaterial: MeshToonMaterial,\\n\\t\\tMeshNormalMaterial: MeshNormalMaterial,\\n\\t\\tMeshLambertMaterial: MeshLambertMaterial,\\n\\t\\tMeshDepthMaterial: MeshDepthMaterial,\\n\\t\\tMeshDistanceMaterial: MeshDistanceMaterial,\\n\\t\\tMeshBasicMaterial: MeshBasicMaterial,\\n\\t\\tLineDashedMaterial: LineDashedMaterial,\\n\\t\\tLineBasicMaterial: LineBasicMaterial,\\n\\t\\tMaterial: Material\\n\\t});\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tvar Cache = {\\n\\n\\t\\tenabled: false,\\n\\n\\t\\tfiles: {},\\n\\n\\t\\tadd: function ( key, file ) {\\n\\n\\t\\t\\tif ( this.enabled === false ) return;\\n\\n\\t\\t\\t// console.log( 'THREE.Cache', 'Adding key:', key );\\n\\n\\t\\t\\tthis.files[ key ] = file;\\n\\n\\t\\t},\\n\\n\\t\\tget: function ( key ) {\\n\\n\\t\\t\\tif ( this.enabled === false ) return;\\n\\n\\t\\t\\t// console.log( 'THREE.Cache', 'Checking key:', key );\\n\\n\\t\\t\\treturn this.files[ key ];\\n\\n\\t\\t},\\n\\n\\t\\tremove: function ( key ) {\\n\\n\\t\\t\\tdelete this.files[ key ];\\n\\n\\t\\t},\\n\\n\\t\\tclear: function () {\\n\\n\\t\\t\\tthis.files = {};\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction LoadingManager( onLoad, onProgress, onError ) {\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\tvar isLoading = false;\\n\\t\\tvar itemsLoaded = 0;\\n\\t\\tvar itemsTotal = 0;\\n\\t\\tvar urlModifier = undefined;\\n\\n\\t\\tthis.onStart = undefined;\\n\\t\\tthis.onLoad = onLoad;\\n\\t\\tthis.onProgress = onProgress;\\n\\t\\tthis.onError = onError;\\n\\n\\t\\tthis.itemStart = function ( url ) {\\n\\n\\t\\t\\titemsTotal ++;\\n\\n\\t\\t\\tif ( isLoading === false ) {\\n\\n\\t\\t\\t\\tif ( scope.onStart !== undefined ) {\\n\\n\\t\\t\\t\\t\\tscope.onStart( url, itemsLoaded, itemsTotal );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tisLoading = true;\\n\\n\\t\\t};\\n\\n\\t\\tthis.itemEnd = function ( url ) {\\n\\n\\t\\t\\titemsLoaded ++;\\n\\n\\t\\t\\tif ( scope.onProgress !== undefined ) {\\n\\n\\t\\t\\t\\tscope.onProgress( url, itemsLoaded, itemsTotal );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( itemsLoaded === itemsTotal ) {\\n\\n\\t\\t\\t\\tisLoading = false;\\n\\n\\t\\t\\t\\tif ( scope.onLoad !== undefined ) {\\n\\n\\t\\t\\t\\t\\tscope.onLoad();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tthis.itemError = function ( url ) {\\n\\n\\t\\t\\tif ( scope.onError !== undefined ) {\\n\\n\\t\\t\\t\\tscope.onError( url );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tthis.resolveURL = function ( url ) {\\n\\n\\t\\t\\tif ( urlModifier ) {\\n\\n\\t\\t\\t\\treturn urlModifier( url );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn url;\\n\\n\\t\\t};\\n\\n\\t\\tthis.setURLModifier = function ( transform ) {\\n\\n\\t\\t\\turlModifier = transform;\\n\\t\\t\\treturn this;\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\tvar DefaultLoadingManager = new LoadingManager();\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tvar loading = {};\\n\\n\\tfunction FileLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t}\\n\\n\\tObject.assign( FileLoader.prototype, {\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tif ( url === undefined ) url = '';\\n\\n\\t\\t\\tif ( this.path !== undefined ) url = this.path + url;\\n\\n\\t\\t\\turl = this.manager.resolveURL( url );\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar cached = Cache.get( url );\\n\\n\\t\\t\\tif ( cached !== undefined ) {\\n\\n\\t\\t\\t\\tscope.manager.itemStart( url );\\n\\n\\t\\t\\t\\tsetTimeout( function () {\\n\\n\\t\\t\\t\\t\\tif ( onLoad ) onLoad( cached );\\n\\n\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\n\\t\\t\\t\\t}, 0 );\\n\\n\\t\\t\\t\\treturn cached;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Check if request is duplicate\\n\\n\\t\\t\\tif ( loading[ url ] !== undefined ) {\\n\\n\\t\\t\\t\\tloading[ url ].push( {\\n\\n\\t\\t\\t\\t\\tonLoad: onLoad,\\n\\t\\t\\t\\t\\tonProgress: onProgress,\\n\\t\\t\\t\\t\\tonError: onError\\n\\n\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Check for data: URI\\n\\t\\t\\tvar dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\\n\\t\\t\\tvar dataUriRegexResult = url.match( dataUriRegex );\\n\\n\\t\\t\\t// Safari can not handle Data URIs through XMLHttpRequest so process manually\\n\\t\\t\\tif ( dataUriRegexResult ) {\\n\\n\\t\\t\\t\\tvar mimeType = dataUriRegexResult[ 1 ];\\n\\t\\t\\t\\tvar isBase64 = !! dataUriRegexResult[ 2 ];\\n\\t\\t\\t\\tvar data = dataUriRegexResult[ 3 ];\\n\\n\\t\\t\\t\\tdata = window.decodeURIComponent( data );\\n\\n\\t\\t\\t\\tif ( isBase64 ) data = window.atob( data );\\n\\n\\t\\t\\t\\ttry {\\n\\n\\t\\t\\t\\t\\tvar response;\\n\\t\\t\\t\\t\\tvar responseType = ( this.responseType || '' ).toLowerCase();\\n\\n\\t\\t\\t\\t\\tswitch ( responseType ) {\\n\\n\\t\\t\\t\\t\\t\\tcase 'arraybuffer':\\n\\t\\t\\t\\t\\t\\tcase 'blob':\\n\\n\\t\\t\\t\\t\\t\\t\\tvar view = new Uint8Array( data.length );\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < data.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tview[ i ] = data.charCodeAt( i );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( responseType === 'blob' ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tresponse = new Blob( [ view.buffer ], { type: mimeType } );\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tresponse = view.buffer;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'document':\\n\\n\\t\\t\\t\\t\\t\\t\\tvar parser = new DOMParser();\\n\\t\\t\\t\\t\\t\\t\\tresponse = parser.parseFromString( data, mimeType );\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'json':\\n\\n\\t\\t\\t\\t\\t\\t\\tresponse = JSON.parse( data );\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tdefault: // 'text' or other\\n\\n\\t\\t\\t\\t\\t\\t\\tresponse = data;\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Wait for next browser tick like standard XMLHttpRequest event dispatching does\\n\\t\\t\\t\\t\\twindow.setTimeout( function () {\\n\\n\\t\\t\\t\\t\\t\\tif ( onLoad ) onLoad( response );\\n\\n\\t\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\n\\t\\t\\t\\t\\t}, 0 );\\n\\n\\t\\t\\t\\t} catch ( error ) {\\n\\n\\t\\t\\t\\t\\t// Wait for next browser tick like standard XMLHttpRequest event dispatching does\\n\\t\\t\\t\\t\\twindow.setTimeout( function () {\\n\\n\\t\\t\\t\\t\\t\\tif ( onError ) onError( error );\\n\\n\\t\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\t\\t\\t\\t\\t\\tscope.manager.itemError( url );\\n\\n\\t\\t\\t\\t\\t}, 0 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Initialise array for duplicate requests\\n\\n\\t\\t\\t\\tloading[ url ] = [];\\n\\n\\t\\t\\t\\tloading[ url ].push( {\\n\\n\\t\\t\\t\\t\\tonLoad: onLoad,\\n\\t\\t\\t\\t\\tonProgress: onProgress,\\n\\t\\t\\t\\t\\tonError: onError\\n\\n\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\tvar request = new XMLHttpRequest();\\n\\n\\t\\t\\t\\trequest.open( 'GET', url, true );\\n\\n\\t\\t\\t\\trequest.addEventListener( 'load', function ( event ) {\\n\\n\\t\\t\\t\\t\\tvar response = this.response;\\n\\n\\t\\t\\t\\t\\tCache.add( url, response );\\n\\n\\t\\t\\t\\t\\tvar callbacks = loading[ url ];\\n\\n\\t\\t\\t\\t\\tdelete loading[ url ];\\n\\n\\t\\t\\t\\t\\tif ( this.status === 200 ) {\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar callback = callbacks[ i ];\\n\\t\\t\\t\\t\\t\\t\\tif ( callback.onLoad ) callback.onLoad( response );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\n\\t\\t\\t\\t\\t} else if ( this.status === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\t// Some browsers return HTTP Status 0 when using non-http protocol\\n\\t\\t\\t\\t\\t\\t// e.g. 'file://' or 'data://'. Handle as success.\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.FileLoader: HTTP Status 0 received.' );\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar callback = callbacks[ i ];\\n\\t\\t\\t\\t\\t\\t\\tif ( callback.onLoad ) callback.onLoad( response );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar callback = callbacks[ i ];\\n\\t\\t\\t\\t\\t\\t\\tif ( callback.onError ) callback.onError( event );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\t\\t\\t\\t\\t\\tscope.manager.itemError( url );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}, false );\\n\\n\\t\\t\\t\\trequest.addEventListener( 'progress', function ( event ) {\\n\\n\\t\\t\\t\\t\\tvar callbacks = loading[ url ];\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar callback = callbacks[ i ];\\n\\t\\t\\t\\t\\t\\tif ( callback.onProgress ) callback.onProgress( event );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}, false );\\n\\n\\t\\t\\t\\trequest.addEventListener( 'error', function ( event ) {\\n\\n\\t\\t\\t\\t\\tvar callbacks = loading[ url ];\\n\\n\\t\\t\\t\\t\\tdelete loading[ url ];\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar callback = callbacks[ i ];\\n\\t\\t\\t\\t\\t\\tif ( callback.onError ) callback.onError( event );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\t\\t\\t\\t\\tscope.manager.itemError( url );\\n\\n\\t\\t\\t\\t}, false );\\n\\n\\t\\t\\t\\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\\n\\t\\t\\t\\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\\n\\n\\t\\t\\t\\tif ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );\\n\\n\\t\\t\\t\\tfor ( var header in this.requestHeader ) {\\n\\n\\t\\t\\t\\t\\trequest.setRequestHeader( header, this.requestHeader[ header ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\trequest.send( null );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tscope.manager.itemStart( url );\\n\\n\\t\\t\\treturn request;\\n\\n\\t\\t},\\n\\n\\t\\tsetPath: function ( value ) {\\n\\n\\t\\t\\tthis.path = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetResponseType: function ( value ) {\\n\\n\\t\\t\\tthis.responseType = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetWithCredentials: function ( value ) {\\n\\n\\t\\t\\tthis.withCredentials = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetMimeType: function ( value ) {\\n\\n\\t\\t\\tthis.mimeType = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetRequestHeader: function ( value ) {\\n\\n\\t\\t\\tthis.requestHeader = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t *\\n\\t * Abstract Base class to block based textures loader (dds, pvr, ...)\\n\\t */\\n\\n\\tfunction CompressedTextureLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t\\t// override in sub classes\\n\\t\\tthis._parser = null;\\n\\n\\t}\\n\\n\\tObject.assign( CompressedTextureLoader.prototype, {\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar images = [];\\n\\n\\t\\t\\tvar texture = new CompressedTexture();\\n\\t\\t\\ttexture.image = images;\\n\\n\\t\\t\\tvar loader = new FileLoader( this.manager );\\n\\t\\t\\tloader.setPath( this.path );\\n\\t\\t\\tloader.setResponseType( 'arraybuffer' );\\n\\n\\t\\t\\tfunction loadTexture( i ) {\\n\\n\\t\\t\\t\\tloader.load( url[ i ], function ( buffer ) {\\n\\n\\t\\t\\t\\t\\tvar texDatas = scope._parser( buffer, true );\\n\\n\\t\\t\\t\\t\\timages[ i ] = {\\n\\t\\t\\t\\t\\t\\twidth: texDatas.width,\\n\\t\\t\\t\\t\\t\\theight: texDatas.height,\\n\\t\\t\\t\\t\\t\\tformat: texDatas.format,\\n\\t\\t\\t\\t\\t\\tmipmaps: texDatas.mipmaps\\n\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\tloaded += 1;\\n\\n\\t\\t\\t\\t\\tif ( loaded === 6 ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( texDatas.mipmapCount === 1 )\\n\\t\\t\\t\\t\\t\\t\\ttexture.minFilter = LinearFilter;\\n\\n\\t\\t\\t\\t\\t\\ttexture.format = texDatas.format;\\n\\t\\t\\t\\t\\t\\ttexture.needsUpdate = true;\\n\\n\\t\\t\\t\\t\\t\\tif ( onLoad ) onLoad( texture );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}, onProgress, onError );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( Array.isArray( url ) ) {\\n\\n\\t\\t\\t\\tvar loaded = 0;\\n\\n\\t\\t\\t\\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\\n\\n\\t\\t\\t\\t\\tloadTexture( i );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// compressed cubemap texture stored in a single DDS file\\n\\n\\t\\t\\t\\tloader.load( url, function ( buffer ) {\\n\\n\\t\\t\\t\\t\\tvar texDatas = scope._parser( buffer, true );\\n\\n\\t\\t\\t\\t\\tif ( texDatas.isCubemap ) {\\n\\n\\t\\t\\t\\t\\t\\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var f = 0; f < faces; f ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\timages[ f ] = { mipmaps: [] };\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\\n\\t\\t\\t\\t\\t\\t\\t\\timages[ f ].format = texDatas.format;\\n\\t\\t\\t\\t\\t\\t\\t\\timages[ f ].width = texDatas.width;\\n\\t\\t\\t\\t\\t\\t\\t\\timages[ f ].height = texDatas.height;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\ttexture.image.width = texDatas.width;\\n\\t\\t\\t\\t\\t\\ttexture.image.height = texDatas.height;\\n\\t\\t\\t\\t\\t\\ttexture.mipmaps = texDatas.mipmaps;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( texDatas.mipmapCount === 1 ) {\\n\\n\\t\\t\\t\\t\\t\\ttexture.minFilter = LinearFilter;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ttexture.format = texDatas.format;\\n\\t\\t\\t\\t\\ttexture.needsUpdate = true;\\n\\n\\t\\t\\t\\t\\tif ( onLoad ) onLoad( texture );\\n\\n\\t\\t\\t\\t}, onProgress, onError );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn texture;\\n\\n\\t\\t},\\n\\n\\t\\tsetPath: function ( value ) {\\n\\n\\t\\t\\tthis.path = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author Nikos M. / https://github.com/foo123/\\n\\t *\\n\\t * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\\n\\t */\\n\\n\\tfunction DataTextureLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t\\t// override in sub classes\\n\\t\\tthis._parser = null;\\n\\n\\t}\\n\\n\\tObject.assign( DataTextureLoader.prototype, {\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar texture = new DataTexture();\\n\\n\\t\\t\\tvar loader = new FileLoader( this.manager );\\n\\t\\t\\tloader.setResponseType( 'arraybuffer' );\\n\\n\\t\\t\\tloader.load( url, function ( buffer ) {\\n\\n\\t\\t\\t\\tvar texData = scope._parser( buffer );\\n\\n\\t\\t\\t\\tif ( ! texData ) return;\\n\\n\\t\\t\\t\\tif ( undefined !== texData.image ) {\\n\\n\\t\\t\\t\\t\\ttexture.image = texData.image;\\n\\n\\t\\t\\t\\t} else if ( undefined !== texData.data ) {\\n\\n\\t\\t\\t\\t\\ttexture.image.width = texData.width;\\n\\t\\t\\t\\t\\ttexture.image.height = texData.height;\\n\\t\\t\\t\\t\\ttexture.image.data = texData.data;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;\\n\\t\\t\\t\\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;\\n\\n\\t\\t\\t\\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;\\n\\t\\t\\t\\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;\\n\\n\\t\\t\\t\\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\\n\\n\\t\\t\\t\\tif ( undefined !== texData.format ) {\\n\\n\\t\\t\\t\\t\\ttexture.format = texData.format;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( undefined !== texData.type ) {\\n\\n\\t\\t\\t\\t\\ttexture.type = texData.type;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( undefined !== texData.mipmaps ) {\\n\\n\\t\\t\\t\\t\\ttexture.mipmaps = texData.mipmaps;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( 1 === texData.mipmapCount ) {\\n\\n\\t\\t\\t\\t\\ttexture.minFilter = LinearFilter;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttexture.needsUpdate = true;\\n\\n\\t\\t\\t\\tif ( onLoad ) onLoad( texture, texData );\\n\\n\\t\\t\\t}, onProgress, onError );\\n\\n\\n\\t\\t\\treturn texture;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction ImageLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t}\\n\\n\\tObject.assign( ImageLoader.prototype, {\\n\\n\\t\\tcrossOrigin: 'Anonymous',\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tif ( url === undefined ) url = '';\\n\\n\\t\\t\\tif ( this.path !== undefined ) url = this.path + url;\\n\\n\\t\\t\\turl = this.manager.resolveURL( url );\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar cached = Cache.get( url );\\n\\n\\t\\t\\tif ( cached !== undefined ) {\\n\\n\\t\\t\\t\\tscope.manager.itemStart( url );\\n\\n\\t\\t\\t\\tsetTimeout( function () {\\n\\n\\t\\t\\t\\t\\tif ( onLoad ) onLoad( cached );\\n\\n\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\n\\t\\t\\t\\t}, 0 );\\n\\n\\t\\t\\t\\treturn cached;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\\n\\n\\t\\t\\timage.addEventListener( 'load', function () {\\n\\n\\t\\t\\t\\tCache.add( url, this );\\n\\n\\t\\t\\t\\tif ( onLoad ) onLoad( this );\\n\\n\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\n\\t\\t\\t}, false );\\n\\n\\t\\t\\t/*\\n\\t\\t\\timage.addEventListener( 'progress', function ( event ) {\\n\\n\\t\\t\\t\\tif ( onProgress ) onProgress( event );\\n\\n\\t\\t\\t}, false );\\n\\t\\t\\t*/\\n\\n\\t\\t\\timage.addEventListener( 'error', function ( event ) {\\n\\n\\t\\t\\t\\tif ( onError ) onError( event );\\n\\n\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\t\\t\\t\\tscope.manager.itemError( url );\\n\\n\\t\\t\\t}, false );\\n\\n\\t\\t\\tif ( url.substr( 0, 5 ) !== 'data:' ) {\\n\\n\\t\\t\\t\\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tscope.manager.itemStart( url );\\n\\n\\t\\t\\timage.src = url;\\n\\n\\t\\t\\treturn image;\\n\\n\\t\\t},\\n\\n\\t\\tsetCrossOrigin: function ( value ) {\\n\\n\\t\\t\\tthis.crossOrigin = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetPath: function ( value ) {\\n\\n\\t\\t\\tthis.path = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction CubeTextureLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t}\\n\\n\\tObject.assign( CubeTextureLoader.prototype, {\\n\\n\\t\\tcrossOrigin: 'Anonymous',\\n\\n\\t\\tload: function ( urls, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tvar texture = new CubeTexture();\\n\\n\\t\\t\\tvar loader = new ImageLoader( this.manager );\\n\\t\\t\\tloader.setCrossOrigin( this.crossOrigin );\\n\\t\\t\\tloader.setPath( this.path );\\n\\n\\t\\t\\tvar loaded = 0;\\n\\n\\t\\t\\tfunction loadTexture( i ) {\\n\\n\\t\\t\\t\\tloader.load( urls[ i ], function ( image ) {\\n\\n\\t\\t\\t\\t\\ttexture.images[ i ] = image;\\n\\n\\t\\t\\t\\t\\tloaded ++;\\n\\n\\t\\t\\t\\t\\tif ( loaded === 6 ) {\\n\\n\\t\\t\\t\\t\\t\\ttexture.needsUpdate = true;\\n\\n\\t\\t\\t\\t\\t\\tif ( onLoad ) onLoad( texture );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}, undefined, onError );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var i = 0; i < urls.length; ++ i ) {\\n\\n\\t\\t\\t\\tloadTexture( i );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn texture;\\n\\n\\t\\t},\\n\\n\\t\\tsetCrossOrigin: function ( value ) {\\n\\n\\t\\t\\tthis.crossOrigin = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetPath: function ( value ) {\\n\\n\\t\\t\\tthis.path = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction TextureLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t}\\n\\n\\tObject.assign( TextureLoader.prototype, {\\n\\n\\t\\tcrossOrigin: 'Anonymous',\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tvar texture = new Texture();\\n\\n\\t\\t\\tvar loader = new ImageLoader( this.manager );\\n\\t\\t\\tloader.setCrossOrigin( this.crossOrigin );\\n\\t\\t\\tloader.setPath( this.path );\\n\\n\\t\\t\\tloader.load( url, function ( image ) {\\n\\n\\t\\t\\t\\ttexture.image = image;\\n\\n\\t\\t\\t\\t// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\\n\\t\\t\\t\\tvar isJPEG = url.search( /\\\\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\\\\:image\\\\/jpeg/ ) === 0;\\n\\n\\t\\t\\t\\ttexture.format = isJPEG ? RGBFormat : RGBAFormat;\\n\\t\\t\\t\\ttexture.needsUpdate = true;\\n\\n\\t\\t\\t\\tif ( onLoad !== undefined ) {\\n\\n\\t\\t\\t\\t\\tonLoad( texture );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}, onProgress, onError );\\n\\n\\t\\t\\treturn texture;\\n\\n\\t\\t},\\n\\n\\t\\tsetCrossOrigin: function ( value ) {\\n\\n\\t\\t\\tthis.crossOrigin = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetPath: function ( value ) {\\n\\n\\t\\t\\tthis.path = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t * Extensible curve object\\n\\t *\\n\\t * Some common of curve methods:\\n\\t * .getPoint( t, optionalTarget ), .getTangent( t )\\n\\t * .getPointAt( u, optionalTarget ), .getTangentAt( u )\\n\\t * .getPoints(), .getSpacedPoints()\\n\\t * .getLength()\\n\\t * .updateArcLengths()\\n\\t *\\n\\t * This following curves inherit from THREE.Curve:\\n\\t *\\n\\t * -- 2D curves --\\n\\t * THREE.ArcCurve\\n\\t * THREE.CubicBezierCurve\\n\\t * THREE.EllipseCurve\\n\\t * THREE.LineCurve\\n\\t * THREE.QuadraticBezierCurve\\n\\t * THREE.SplineCurve\\n\\t *\\n\\t * -- 3D curves --\\n\\t * THREE.CatmullRomCurve3\\n\\t * THREE.CubicBezierCurve3\\n\\t * THREE.LineCurve3\\n\\t * THREE.QuadraticBezierCurve3\\n\\t *\\n\\t * A series of curves can be represented as a THREE.CurvePath.\\n\\t *\\n\\t **/\\n\\n\\t/**************************************************************\\n\\t *\\tAbstract Curve base class\\n\\t **************************************************************/\\n\\n\\tfunction Curve() {\\n\\n\\t\\tthis.type = 'Curve';\\n\\n\\t\\tthis.arcLengthDivisions = 200;\\n\\n\\t}\\n\\n\\tObject.assign( Curve.prototype, {\\n\\n\\t\\t// Virtual base class method to overwrite and implement in subclasses\\n\\t\\t//\\t- t [0 .. 1]\\n\\n\\t\\tgetPoint: function ( /* t, optionalTarget */ ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Curve: .getPoint() not implemented.' );\\n\\t\\t\\treturn null;\\n\\n\\t\\t},\\n\\n\\t\\t// Get point at relative position in curve according to arc length\\n\\t\\t// - u [0 .. 1]\\n\\n\\t\\tgetPointAt: function ( u, optionalTarget ) {\\n\\n\\t\\t\\tvar t = this.getUtoTmapping( u );\\n\\t\\t\\treturn this.getPoint( t, optionalTarget );\\n\\n\\t\\t},\\n\\n\\t\\t// Get sequence of points using getPoint( t )\\n\\n\\t\\tgetPoints: function ( divisions ) {\\n\\n\\t\\t\\tif ( divisions === undefined ) divisions = 5;\\n\\n\\t\\t\\tvar points = [];\\n\\n\\t\\t\\tfor ( var d = 0; d <= divisions; d ++ ) {\\n\\n\\t\\t\\t\\tpoints.push( this.getPoint( d / divisions ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn points;\\n\\n\\t\\t},\\n\\n\\t\\t// Get sequence of points using getPointAt( u )\\n\\n\\t\\tgetSpacedPoints: function ( divisions ) {\\n\\n\\t\\t\\tif ( divisions === undefined ) divisions = 5;\\n\\n\\t\\t\\tvar points = [];\\n\\n\\t\\t\\tfor ( var d = 0; d <= divisions; d ++ ) {\\n\\n\\t\\t\\t\\tpoints.push( this.getPointAt( d / divisions ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn points;\\n\\n\\t\\t},\\n\\n\\t\\t// Get total curve arc length\\n\\n\\t\\tgetLength: function () {\\n\\n\\t\\t\\tvar lengths = this.getLengths();\\n\\t\\t\\treturn lengths[ lengths.length - 1 ];\\n\\n\\t\\t},\\n\\n\\t\\t// Get list of cumulative segment lengths\\n\\n\\t\\tgetLengths: function ( divisions ) {\\n\\n\\t\\t\\tif ( divisions === undefined ) divisions = this.arcLengthDivisions;\\n\\n\\t\\t\\tif ( this.cacheArcLengths &&\\n\\t\\t\\t\\t( this.cacheArcLengths.length === divisions + 1 ) &&\\n\\t\\t\\t\\t! this.needsUpdate ) {\\n\\n\\t\\t\\t\\treturn this.cacheArcLengths;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.needsUpdate = false;\\n\\n\\t\\t\\tvar cache = [];\\n\\t\\t\\tvar current, last = this.getPoint( 0 );\\n\\t\\t\\tvar p, sum = 0;\\n\\n\\t\\t\\tcache.push( 0 );\\n\\n\\t\\t\\tfor ( p = 1; p <= divisions; p ++ ) {\\n\\n\\t\\t\\t\\tcurrent = this.getPoint( p / divisions );\\n\\t\\t\\t\\tsum += current.distanceTo( last );\\n\\t\\t\\t\\tcache.push( sum );\\n\\t\\t\\t\\tlast = current;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.cacheArcLengths = cache;\\n\\n\\t\\t\\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\\n\\n\\t\\t},\\n\\n\\t\\tupdateArcLengths: function () {\\n\\n\\t\\t\\tthis.needsUpdate = true;\\n\\t\\t\\tthis.getLengths();\\n\\n\\t\\t},\\n\\n\\t\\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\\n\\n\\t\\tgetUtoTmapping: function ( u, distance ) {\\n\\n\\t\\t\\tvar arcLengths = this.getLengths();\\n\\n\\t\\t\\tvar i = 0, il = arcLengths.length;\\n\\n\\t\\t\\tvar targetArcLength; // The targeted u distance value to get\\n\\n\\t\\t\\tif ( distance ) {\\n\\n\\t\\t\\t\\ttargetArcLength = distance;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\ttargetArcLength = u * arcLengths[ il - 1 ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// binary search for the index with largest value smaller than target u distance\\n\\n\\t\\t\\tvar low = 0, high = il - 1, comparison;\\n\\n\\t\\t\\twhile ( low <= high ) {\\n\\n\\t\\t\\t\\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\\n\\n\\t\\t\\t\\tcomparison = arcLengths[ i ] - targetArcLength;\\n\\n\\t\\t\\t\\tif ( comparison < 0 ) {\\n\\n\\t\\t\\t\\t\\tlow = i + 1;\\n\\n\\t\\t\\t\\t} else if ( comparison > 0 ) {\\n\\n\\t\\t\\t\\t\\thigh = i - 1;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\thigh = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t// DONE\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\ti = high;\\n\\n\\t\\t\\tif ( arcLengths[ i ] === targetArcLength ) {\\n\\n\\t\\t\\t\\treturn i / ( il - 1 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// we could get finer grain at lengths, or use simple interpolation between two points\\n\\n\\t\\t\\tvar lengthBefore = arcLengths[ i ];\\n\\t\\t\\tvar lengthAfter = arcLengths[ i + 1 ];\\n\\n\\t\\t\\tvar segmentLength = lengthAfter - lengthBefore;\\n\\n\\t\\t\\t// determine where we are between the 'before' and 'after' points\\n\\n\\t\\t\\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\\n\\n\\t\\t\\t// add that fractional amount to t\\n\\n\\t\\t\\tvar t = ( i + segmentFraction ) / ( il - 1 );\\n\\n\\t\\t\\treturn t;\\n\\n\\t\\t},\\n\\n\\t\\t// Returns a unit vector tangent at t\\n\\t\\t// In case any sub curve does not implement its tangent derivation,\\n\\t\\t// 2 points a small delta apart will be used to find its gradient\\n\\t\\t// which seems to give a reasonable approximation\\n\\n\\t\\tgetTangent: function ( t ) {\\n\\n\\t\\t\\tvar delta = 0.0001;\\n\\t\\t\\tvar t1 = t - delta;\\n\\t\\t\\tvar t2 = t + delta;\\n\\n\\t\\t\\t// Capping in case of danger\\n\\n\\t\\t\\tif ( t1 < 0 ) t1 = 0;\\n\\t\\t\\tif ( t2 > 1 ) t2 = 1;\\n\\n\\t\\t\\tvar pt1 = this.getPoint( t1 );\\n\\t\\t\\tvar pt2 = this.getPoint( t2 );\\n\\n\\t\\t\\tvar vec = pt2.clone().sub( pt1 );\\n\\t\\t\\treturn vec.normalize();\\n\\n\\t\\t},\\n\\n\\t\\tgetTangentAt: function ( u ) {\\n\\n\\t\\t\\tvar t = this.getUtoTmapping( u );\\n\\t\\t\\treturn this.getTangent( t );\\n\\n\\t\\t},\\n\\n\\t\\tcomputeFrenetFrames: function ( segments, closed ) {\\n\\n\\t\\t\\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\\n\\n\\t\\t\\tvar normal = new Vector3();\\n\\n\\t\\t\\tvar tangents = [];\\n\\t\\t\\tvar normals = [];\\n\\t\\t\\tvar binormals = [];\\n\\n\\t\\t\\tvar vec = new Vector3();\\n\\t\\t\\tvar mat = new Matrix4();\\n\\n\\t\\t\\tvar i, u, theta;\\n\\n\\t\\t\\t// compute the tangent vectors for each segment on the curve\\n\\n\\t\\t\\tfor ( i = 0; i <= segments; i ++ ) {\\n\\n\\t\\t\\t\\tu = i / segments;\\n\\n\\t\\t\\t\\ttangents[ i ] = this.getTangentAt( u );\\n\\t\\t\\t\\ttangents[ i ].normalize();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// select an initial normal vector perpendicular to the first tangent vector,\\n\\t\\t\\t// and in the direction of the minimum tangent xyz component\\n\\n\\t\\t\\tnormals[ 0 ] = new Vector3();\\n\\t\\t\\tbinormals[ 0 ] = new Vector3();\\n\\t\\t\\tvar min = Number.MAX_VALUE;\\n\\t\\t\\tvar tx = Math.abs( tangents[ 0 ].x );\\n\\t\\t\\tvar ty = Math.abs( tangents[ 0 ].y );\\n\\t\\t\\tvar tz = Math.abs( tangents[ 0 ].z );\\n\\n\\t\\t\\tif ( tx <= min ) {\\n\\n\\t\\t\\t\\tmin = tx;\\n\\t\\t\\t\\tnormal.set( 1, 0, 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( ty <= min ) {\\n\\n\\t\\t\\t\\tmin = ty;\\n\\t\\t\\t\\tnormal.set( 0, 1, 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( tz <= min ) {\\n\\n\\t\\t\\t\\tnormal.set( 0, 0, 1 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\\n\\n\\t\\t\\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\\n\\t\\t\\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\\n\\n\\n\\t\\t\\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\\n\\n\\t\\t\\tfor ( i = 1; i <= segments; i ++ ) {\\n\\n\\t\\t\\t\\tnormals[ i ] = normals[ i - 1 ].clone();\\n\\n\\t\\t\\t\\tbinormals[ i ] = binormals[ i - 1 ].clone();\\n\\n\\t\\t\\t\\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\\n\\n\\t\\t\\t\\tif ( vec.length() > Number.EPSILON ) {\\n\\n\\t\\t\\t\\t\\tvec.normalize();\\n\\n\\t\\t\\t\\t\\ttheta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\\n\\n\\t\\t\\t\\t\\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\\n\\n\\t\\t\\tif ( closed === true ) {\\n\\n\\t\\t\\t\\ttheta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\\n\\t\\t\\t\\ttheta /= segments;\\n\\n\\t\\t\\t\\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\\n\\n\\t\\t\\t\\t\\ttheta = - theta;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor ( i = 1; i <= segments; i ++ ) {\\n\\n\\t\\t\\t\\t\\t// twist a little...\\n\\t\\t\\t\\t\\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\\n\\t\\t\\t\\t\\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn {\\n\\t\\t\\t\\ttangents: tangents,\\n\\t\\t\\t\\tnormals: normals,\\n\\t\\t\\t\\tbinormals: binormals\\n\\t\\t\\t};\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tthis.arcLengthDivisions = source.arcLengthDivisions;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function () {\\n\\n\\t\\t\\tvar data = {\\n\\t\\t\\t\\tmetadata: {\\n\\t\\t\\t\\t\\tversion: 4.5,\\n\\t\\t\\t\\t\\ttype: 'Curve',\\n\\t\\t\\t\\t\\tgenerator: 'Curve.toJSON'\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\t\\tdata.arcLengthDivisions = this.arcLengthDivisions;\\n\\t\\t\\tdata.type = this.type;\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t},\\n\\n\\t\\tfromJSON: function ( json ) {\\n\\n\\t\\t\\tthis.arcLengthDivisions = json.arcLengthDivisions;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tfunction EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'EllipseCurve';\\n\\n\\t\\tthis.aX = aX || 0;\\n\\t\\tthis.aY = aY || 0;\\n\\n\\t\\tthis.xRadius = xRadius || 1;\\n\\t\\tthis.yRadius = yRadius || 1;\\n\\n\\t\\tthis.aStartAngle = aStartAngle || 0;\\n\\t\\tthis.aEndAngle = aEndAngle || 2 * Math.PI;\\n\\n\\t\\tthis.aClockwise = aClockwise || false;\\n\\n\\t\\tthis.aRotation = aRotation || 0;\\n\\n\\t}\\n\\n\\tEllipseCurve.prototype = Object.create( Curve.prototype );\\n\\tEllipseCurve.prototype.constructor = EllipseCurve;\\n\\n\\tEllipseCurve.prototype.isEllipseCurve = true;\\n\\n\\tEllipseCurve.prototype.getPoint = function ( t, optionalTarget ) {\\n\\n\\t\\tvar point = optionalTarget || new Vector2();\\n\\n\\t\\tvar twoPi = Math.PI * 2;\\n\\t\\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\\n\\t\\tvar samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\\n\\n\\t\\t// ensures that deltaAngle is 0 .. 2 PI\\n\\t\\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\\n\\t\\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\\n\\n\\t\\tif ( deltaAngle < Number.EPSILON ) {\\n\\n\\t\\t\\tif ( samePoints ) {\\n\\n\\t\\t\\t\\tdeltaAngle = 0;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tdeltaAngle = twoPi;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tif ( this.aClockwise === true && ! samePoints ) {\\n\\n\\t\\t\\tif ( deltaAngle === twoPi ) {\\n\\n\\t\\t\\t\\tdeltaAngle = - twoPi;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tdeltaAngle = deltaAngle - twoPi;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tvar angle = this.aStartAngle + t * deltaAngle;\\n\\t\\tvar x = this.aX + this.xRadius * Math.cos( angle );\\n\\t\\tvar y = this.aY + this.yRadius * Math.sin( angle );\\n\\n\\t\\tif ( this.aRotation !== 0 ) {\\n\\n\\t\\t\\tvar cos = Math.cos( this.aRotation );\\n\\t\\t\\tvar sin = Math.sin( this.aRotation );\\n\\n\\t\\t\\tvar tx = x - this.aX;\\n\\t\\t\\tvar ty = y - this.aY;\\n\\n\\t\\t\\t// Rotate the point about the center of the ellipse.\\n\\t\\t\\tx = tx * cos - ty * sin + this.aX;\\n\\t\\t\\ty = tx * sin + ty * cos + this.aY;\\n\\n\\t\\t}\\n\\n\\t\\treturn point.set( x, y );\\n\\n\\t};\\n\\n\\tEllipseCurve.prototype.copy = function ( source ) {\\n\\n\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\tthis.aX = source.aX;\\n\\t\\tthis.aY = source.aY;\\n\\n\\t\\tthis.xRadius = source.xRadius;\\n\\t\\tthis.yRadius = source.yRadius;\\n\\n\\t\\tthis.aStartAngle = source.aStartAngle;\\n\\t\\tthis.aEndAngle = source.aEndAngle;\\n\\n\\t\\tthis.aClockwise = source.aClockwise;\\n\\n\\t\\tthis.aRotation = source.aRotation;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\n\\tEllipseCurve.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\tdata.aX = this.aX;\\n\\t\\tdata.aY = this.aY;\\n\\n\\t\\tdata.xRadius = this.xRadius;\\n\\t\\tdata.yRadius = this.yRadius;\\n\\n\\t\\tdata.aStartAngle = this.aStartAngle;\\n\\t\\tdata.aEndAngle = this.aEndAngle;\\n\\n\\t\\tdata.aClockwise = this.aClockwise;\\n\\n\\t\\tdata.aRotation = this.aRotation;\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tEllipseCurve.prototype.fromJSON = function ( json ) {\\n\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\tthis.aX = json.aX;\\n\\t\\tthis.aY = json.aY;\\n\\n\\t\\tthis.xRadius = json.xRadius;\\n\\t\\tthis.yRadius = json.yRadius;\\n\\n\\t\\tthis.aStartAngle = json.aStartAngle;\\n\\t\\tthis.aEndAngle = json.aEndAngle;\\n\\n\\t\\tthis.aClockwise = json.aClockwise;\\n\\n\\t\\tthis.aRotation = json.aRotation;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\\n\\n\\t\\tEllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\\n\\n\\t\\tthis.type = 'ArcCurve';\\n\\n\\t}\\n\\n\\tArcCurve.prototype = Object.create( EllipseCurve.prototype );\\n\\tArcCurve.prototype.constructor = ArcCurve;\\n\\n\\tArcCurve.prototype.isArcCurve = true;\\n\\n\\t/**\\n\\t * @author zz85 https://github.com/zz85\\n\\t *\\n\\t * Centripetal CatmullRom Curve - which is useful for avoiding\\n\\t * cusps and self-intersections in non-uniform catmull rom curves.\\n\\t * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\\n\\t *\\n\\t * curve.type accepts centripetal(default), chordal and catmullrom\\n\\t * curve.tension is used for catmullrom which defaults to 0.5\\n\\t */\\n\\n\\n\\t/*\\n\\tBased on an optimized c++ solution in\\n\\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\\n\\t - http://ideone.com/NoEbVM\\n\\n\\tThis CubicPoly class could be used for reusing some variables and calculations,\\n\\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\\n\\twhich can be placed in CurveUtils.\\n\\t*/\\n\\n\\tfunction CubicPoly() {\\n\\n\\t\\tvar c0 = 0, c1 = 0, c2 = 0, c3 = 0;\\n\\n\\t\\t/*\\n\\t\\t * Compute coefficients for a cubic polynomial\\n\\t\\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\\n\\t\\t * such that\\n\\t\\t *   p(0) = x0, p(1) = x1\\n\\t\\t *  and\\n\\t\\t *   p'(0) = t0, p'(1) = t1.\\n\\t\\t */\\n\\t\\tfunction init( x0, x1, t0, t1 ) {\\n\\n\\t\\t\\tc0 = x0;\\n\\t\\t\\tc1 = t0;\\n\\t\\t\\tc2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\\n\\t\\t\\tc3 = 2 * x0 - 2 * x1 + t0 + t1;\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tinitCatmullRom: function ( x0, x1, x2, x3, tension ) {\\n\\n\\t\\t\\t\\tinit( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tinitNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {\\n\\n\\t\\t\\t\\t// compute tangents when parameterized in [t1,t2]\\n\\t\\t\\t\\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\\n\\t\\t\\t\\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\\n\\n\\t\\t\\t\\t// rescale tangents for parametrization in [0,1]\\n\\t\\t\\t\\tt1 *= dt1;\\n\\t\\t\\t\\tt2 *= dt1;\\n\\n\\t\\t\\t\\tinit( x1, x2, t1, t2 );\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tcalc: function ( t ) {\\n\\n\\t\\t\\t\\tvar t2 = t * t;\\n\\t\\t\\t\\tvar t3 = t2 * t;\\n\\t\\t\\t\\treturn c0 + c1 * t + c2 * t2 + c3 * t3;\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t//\\n\\n\\tvar tmp = new Vector3();\\n\\tvar px = new CubicPoly();\\n\\tvar py = new CubicPoly();\\n\\tvar pz = new CubicPoly();\\n\\n\\tfunction CatmullRomCurve3( points, closed, curveType, tension ) {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'CatmullRomCurve3';\\n\\n\\t\\tthis.points = points || [];\\n\\t\\tthis.closed = closed || false;\\n\\t\\tthis.curveType = curveType || 'centripetal';\\n\\t\\tthis.tension = tension || 0.5;\\n\\n\\t}\\n\\n\\tCatmullRomCurve3.prototype = Object.create( Curve.prototype );\\n\\tCatmullRomCurve3.prototype.constructor = CatmullRomCurve3;\\n\\n\\tCatmullRomCurve3.prototype.isCatmullRomCurve3 = true;\\n\\n\\tCatmullRomCurve3.prototype.getPoint = function ( t, optionalTarget ) {\\n\\n\\t\\tvar point = optionalTarget || new Vector3();\\n\\n\\t\\tvar points = this.points;\\n\\t\\tvar l = points.length;\\n\\n\\t\\tvar p = ( l - ( this.closed ? 0 : 1 ) ) * t;\\n\\t\\tvar intPoint = Math.floor( p );\\n\\t\\tvar weight = p - intPoint;\\n\\n\\t\\tif ( this.closed ) {\\n\\n\\t\\t\\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\\n\\n\\t\\t} else if ( weight === 0 && intPoint === l - 1 ) {\\n\\n\\t\\t\\tintPoint = l - 2;\\n\\t\\t\\tweight = 1;\\n\\n\\t\\t}\\n\\n\\t\\tvar p0, p1, p2, p3; // 4 points\\n\\n\\t\\tif ( this.closed || intPoint > 0 ) {\\n\\n\\t\\t\\tp0 = points[ ( intPoint - 1 ) % l ];\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t// extrapolate first point\\n\\t\\t\\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\\n\\t\\t\\tp0 = tmp;\\n\\n\\t\\t}\\n\\n\\t\\tp1 = points[ intPoint % l ];\\n\\t\\tp2 = points[ ( intPoint + 1 ) % l ];\\n\\n\\t\\tif ( this.closed || intPoint + 2 < l ) {\\n\\n\\t\\t\\tp3 = points[ ( intPoint + 2 ) % l ];\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t// extrapolate last point\\n\\t\\t\\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\\n\\t\\t\\tp3 = tmp;\\n\\n\\t\\t}\\n\\n\\t\\tif ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {\\n\\n\\t\\t\\t// init Centripetal / Chordal Catmull-Rom\\n\\t\\t\\tvar pow = this.curveType === 'chordal' ? 0.5 : 0.25;\\n\\t\\t\\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\\n\\t\\t\\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\\n\\t\\t\\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\\n\\n\\t\\t\\t// safety check for repeated points\\n\\t\\t\\tif ( dt1 < 1e-4 ) dt1 = 1.0;\\n\\t\\t\\tif ( dt0 < 1e-4 ) dt0 = dt1;\\n\\t\\t\\tif ( dt2 < 1e-4 ) dt2 = dt1;\\n\\n\\t\\t\\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\\n\\t\\t\\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\\n\\t\\t\\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\\n\\n\\t\\t} else if ( this.curveType === 'catmullrom' ) {\\n\\n\\t\\t\\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );\\n\\t\\t\\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );\\n\\t\\t\\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );\\n\\n\\t\\t}\\n\\n\\t\\tpoint.set(\\n\\t\\t\\tpx.calc( weight ),\\n\\t\\t\\tpy.calc( weight ),\\n\\t\\t\\tpz.calc( weight )\\n\\t\\t);\\n\\n\\t\\treturn point;\\n\\n\\t};\\n\\n\\tCatmullRomCurve3.prototype.copy = function ( source ) {\\n\\n\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\tthis.points = [];\\n\\n\\t\\tfor ( var i = 0, l = source.points.length; i < l; i ++ ) {\\n\\n\\t\\t\\tvar point = source.points[ i ];\\n\\n\\t\\t\\tthis.points.push( point.clone() );\\n\\n\\t\\t}\\n\\n\\t\\tthis.closed = source.closed;\\n\\t\\tthis.curveType = source.curveType;\\n\\t\\tthis.tension = source.tension;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tCatmullRomCurve3.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\tdata.points = [];\\n\\n\\t\\tfor ( var i = 0, l = this.points.length; i < l; i ++ ) {\\n\\n\\t\\t\\tvar point = this.points[ i ];\\n\\t\\t\\tdata.points.push( point.toArray() );\\n\\n\\t\\t}\\n\\n\\t\\tdata.closed = this.closed;\\n\\t\\tdata.curveType = this.curveType;\\n\\t\\tdata.tension = this.tension;\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tCatmullRomCurve3.prototype.fromJSON = function ( json ) {\\n\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\tthis.points = [];\\n\\n\\t\\tfor ( var i = 0, l = json.points.length; i < l; i ++ ) {\\n\\n\\t\\t\\tvar point = json.points[ i ];\\n\\t\\t\\tthis.points.push( new Vector3().fromArray( point ) );\\n\\n\\t\\t}\\n\\n\\t\\tthis.closed = json.closed;\\n\\t\\tthis.curveType = json.curveType;\\n\\t\\tthis.tension = json.tension;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t *\\n\\t * Bezier Curves formulas obtained from\\n\\t * http://en.wikipedia.org/wiki/Bézier_curve\\n\\t */\\n\\n\\tfunction CatmullRom( t, p0, p1, p2, p3 ) {\\n\\n\\t\\tvar v0 = ( p2 - p0 ) * 0.5;\\n\\t\\tvar v1 = ( p3 - p1 ) * 0.5;\\n\\t\\tvar t2 = t * t;\\n\\t\\tvar t3 = t * t2;\\n\\t\\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\\n\\n\\t}\\n\\n\\t//\\n\\n\\tfunction QuadraticBezierP0( t, p ) {\\n\\n\\t\\tvar k = 1 - t;\\n\\t\\treturn k * k * p;\\n\\n\\t}\\n\\n\\tfunction QuadraticBezierP1( t, p ) {\\n\\n\\t\\treturn 2 * ( 1 - t ) * t * p;\\n\\n\\t}\\n\\n\\tfunction QuadraticBezierP2( t, p ) {\\n\\n\\t\\treturn t * t * p;\\n\\n\\t}\\n\\n\\tfunction QuadraticBezier( t, p0, p1, p2 ) {\\n\\n\\t\\treturn QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +\\n\\t\\t\\tQuadraticBezierP2( t, p2 );\\n\\n\\t}\\n\\n\\t//\\n\\n\\tfunction CubicBezierP0( t, p ) {\\n\\n\\t\\tvar k = 1 - t;\\n\\t\\treturn k * k * k * p;\\n\\n\\t}\\n\\n\\tfunction CubicBezierP1( t, p ) {\\n\\n\\t\\tvar k = 1 - t;\\n\\t\\treturn 3 * k * k * t * p;\\n\\n\\t}\\n\\n\\tfunction CubicBezierP2( t, p ) {\\n\\n\\t\\treturn 3 * ( 1 - t ) * t * t * p;\\n\\n\\t}\\n\\n\\tfunction CubicBezierP3( t, p ) {\\n\\n\\t\\treturn t * t * t * p;\\n\\n\\t}\\n\\n\\tfunction CubicBezier( t, p0, p1, p2, p3 ) {\\n\\n\\t\\treturn CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +\\n\\t\\t\\tCubicBezierP3( t, p3 );\\n\\n\\t}\\n\\n\\tfunction CubicBezierCurve( v0, v1, v2, v3 ) {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'CubicBezierCurve';\\n\\n\\t\\tthis.v0 = v0 || new Vector2();\\n\\t\\tthis.v1 = v1 || new Vector2();\\n\\t\\tthis.v2 = v2 || new Vector2();\\n\\t\\tthis.v3 = v3 || new Vector2();\\n\\n\\t}\\n\\n\\tCubicBezierCurve.prototype = Object.create( Curve.prototype );\\n\\tCubicBezierCurve.prototype.constructor = CubicBezierCurve;\\n\\n\\tCubicBezierCurve.prototype.isCubicBezierCurve = true;\\n\\n\\tCubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {\\n\\n\\t\\tvar point = optionalTarget || new Vector2();\\n\\n\\t\\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\\n\\n\\t\\tpoint.set(\\n\\t\\t\\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\\n\\t\\t\\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y )\\n\\t\\t);\\n\\n\\t\\treturn point;\\n\\n\\t};\\n\\n\\tCubicBezierCurve.prototype.copy = function ( source ) {\\n\\n\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\tthis.v0.copy( source.v0 );\\n\\t\\tthis.v1.copy( source.v1 );\\n\\t\\tthis.v2.copy( source.v2 );\\n\\t\\tthis.v3.copy( source.v3 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tCubicBezierCurve.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\tdata.v0 = this.v0.toArray();\\n\\t\\tdata.v1 = this.v1.toArray();\\n\\t\\tdata.v2 = this.v2.toArray();\\n\\t\\tdata.v3 = this.v3.toArray();\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tCubicBezierCurve.prototype.fromJSON = function ( json ) {\\n\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\tthis.v0.fromArray( json.v0 );\\n\\t\\tthis.v1.fromArray( json.v1 );\\n\\t\\tthis.v2.fromArray( json.v2 );\\n\\t\\tthis.v3.fromArray( json.v3 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction CubicBezierCurve3( v0, v1, v2, v3 ) {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'CubicBezierCurve3';\\n\\n\\t\\tthis.v0 = v0 || new Vector3();\\n\\t\\tthis.v1 = v1 || new Vector3();\\n\\t\\tthis.v2 = v2 || new Vector3();\\n\\t\\tthis.v3 = v3 || new Vector3();\\n\\n\\t}\\n\\n\\tCubicBezierCurve3.prototype = Object.create( Curve.prototype );\\n\\tCubicBezierCurve3.prototype.constructor = CubicBezierCurve3;\\n\\n\\tCubicBezierCurve3.prototype.isCubicBezierCurve3 = true;\\n\\n\\tCubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {\\n\\n\\t\\tvar point = optionalTarget || new Vector3();\\n\\n\\t\\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\\n\\n\\t\\tpoint.set(\\n\\t\\t\\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\\n\\t\\t\\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y ),\\n\\t\\t\\tCubicBezier( t, v0.z, v1.z, v2.z, v3.z )\\n\\t\\t);\\n\\n\\t\\treturn point;\\n\\n\\t};\\n\\n\\tCubicBezierCurve3.prototype.copy = function ( source ) {\\n\\n\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\tthis.v0.copy( source.v0 );\\n\\t\\tthis.v1.copy( source.v1 );\\n\\t\\tthis.v2.copy( source.v2 );\\n\\t\\tthis.v3.copy( source.v3 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tCubicBezierCurve3.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\tdata.v0 = this.v0.toArray();\\n\\t\\tdata.v1 = this.v1.toArray();\\n\\t\\tdata.v2 = this.v2.toArray();\\n\\t\\tdata.v3 = this.v3.toArray();\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tCubicBezierCurve3.prototype.fromJSON = function ( json ) {\\n\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\tthis.v0.fromArray( json.v0 );\\n\\t\\tthis.v1.fromArray( json.v1 );\\n\\t\\tthis.v2.fromArray( json.v2 );\\n\\t\\tthis.v3.fromArray( json.v3 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction LineCurve( v1, v2 ) {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'LineCurve';\\n\\n\\t\\tthis.v1 = v1 || new Vector2();\\n\\t\\tthis.v2 = v2 || new Vector2();\\n\\n\\t}\\n\\n\\tLineCurve.prototype = Object.create( Curve.prototype );\\n\\tLineCurve.prototype.constructor = LineCurve;\\n\\n\\tLineCurve.prototype.isLineCurve = true;\\n\\n\\tLineCurve.prototype.getPoint = function ( t, optionalTarget ) {\\n\\n\\t\\tvar point = optionalTarget || new Vector2();\\n\\n\\t\\tif ( t === 1 ) {\\n\\n\\t\\t\\tpoint.copy( this.v2 );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tpoint.copy( this.v2 ).sub( this.v1 );\\n\\t\\t\\tpoint.multiplyScalar( t ).add( this.v1 );\\n\\n\\t\\t}\\n\\n\\t\\treturn point;\\n\\n\\t};\\n\\n\\t// Line curve is linear, so we can overwrite default getPointAt\\n\\n\\tLineCurve.prototype.getPointAt = function ( u, optionalTarget ) {\\n\\n\\t\\treturn this.getPoint( u, optionalTarget );\\n\\n\\t};\\n\\n\\tLineCurve.prototype.getTangent = function ( /* t */ ) {\\n\\n\\t\\tvar tangent = this.v2.clone().sub( this.v1 );\\n\\n\\t\\treturn tangent.normalize();\\n\\n\\t};\\n\\n\\tLineCurve.prototype.copy = function ( source ) {\\n\\n\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\tthis.v1.copy( source.v1 );\\n\\t\\tthis.v2.copy( source.v2 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tLineCurve.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\tdata.v1 = this.v1.toArray();\\n\\t\\tdata.v2 = this.v2.toArray();\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tLineCurve.prototype.fromJSON = function ( json ) {\\n\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\tthis.v1.fromArray( json.v1 );\\n\\t\\tthis.v2.fromArray( json.v2 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction LineCurve3( v1, v2 ) {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'LineCurve3';\\n\\n\\t\\tthis.v1 = v1 || new Vector3();\\n\\t\\tthis.v2 = v2 || new Vector3();\\n\\n\\t}\\n\\n\\tLineCurve3.prototype = Object.create( Curve.prototype );\\n\\tLineCurve3.prototype.constructor = LineCurve3;\\n\\n\\tLineCurve3.prototype.isLineCurve3 = true;\\n\\n\\tLineCurve3.prototype.getPoint = function ( t, optionalTarget ) {\\n\\n\\t\\tvar point = optionalTarget || new Vector3();\\n\\n\\t\\tif ( t === 1 ) {\\n\\n\\t\\t\\tpoint.copy( this.v2 );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tpoint.copy( this.v2 ).sub( this.v1 );\\n\\t\\t\\tpoint.multiplyScalar( t ).add( this.v1 );\\n\\n\\t\\t}\\n\\n\\t\\treturn point;\\n\\n\\t};\\n\\n\\t// Line curve is linear, so we can overwrite default getPointAt\\n\\n\\tLineCurve3.prototype.getPointAt = function ( u, optionalTarget ) {\\n\\n\\t\\treturn this.getPoint( u, optionalTarget );\\n\\n\\t};\\n\\n\\tLineCurve3.prototype.copy = function ( source ) {\\n\\n\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\tthis.v1.copy( source.v1 );\\n\\t\\tthis.v2.copy( source.v2 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tLineCurve3.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\tdata.v1 = this.v1.toArray();\\n\\t\\tdata.v2 = this.v2.toArray();\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tLineCurve3.prototype.fromJSON = function ( json ) {\\n\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\tthis.v1.fromArray( json.v1 );\\n\\t\\tthis.v2.fromArray( json.v2 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction QuadraticBezierCurve( v0, v1, v2 ) {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'QuadraticBezierCurve';\\n\\n\\t\\tthis.v0 = v0 || new Vector2();\\n\\t\\tthis.v1 = v1 || new Vector2();\\n\\t\\tthis.v2 = v2 || new Vector2();\\n\\n\\t}\\n\\n\\tQuadraticBezierCurve.prototype = Object.create( Curve.prototype );\\n\\tQuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;\\n\\n\\tQuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;\\n\\n\\tQuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {\\n\\n\\t\\tvar point = optionalTarget || new Vector2();\\n\\n\\t\\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2;\\n\\n\\t\\tpoint.set(\\n\\t\\t\\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\\n\\t\\t\\tQuadraticBezier( t, v0.y, v1.y, v2.y )\\n\\t\\t);\\n\\n\\t\\treturn point;\\n\\n\\t};\\n\\n\\tQuadraticBezierCurve.prototype.copy = function ( source ) {\\n\\n\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\tthis.v0.copy( source.v0 );\\n\\t\\tthis.v1.copy( source.v1 );\\n\\t\\tthis.v2.copy( source.v2 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tQuadraticBezierCurve.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\tdata.v0 = this.v0.toArray();\\n\\t\\tdata.v1 = this.v1.toArray();\\n\\t\\tdata.v2 = this.v2.toArray();\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tQuadraticBezierCurve.prototype.fromJSON = function ( json ) {\\n\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\tthis.v0.fromArray( json.v0 );\\n\\t\\tthis.v1.fromArray( json.v1 );\\n\\t\\tthis.v2.fromArray( json.v2 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction QuadraticBezierCurve3( v0, v1, v2 ) {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'QuadraticBezierCurve3';\\n\\n\\t\\tthis.v0 = v0 || new Vector3();\\n\\t\\tthis.v1 = v1 || new Vector3();\\n\\t\\tthis.v2 = v2 || new Vector3();\\n\\n\\t}\\n\\n\\tQuadraticBezierCurve3.prototype = Object.create( Curve.prototype );\\n\\tQuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;\\n\\n\\tQuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;\\n\\n\\tQuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {\\n\\n\\t\\tvar point = optionalTarget || new Vector3();\\n\\n\\t\\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2;\\n\\n\\t\\tpoint.set(\\n\\t\\t\\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\\n\\t\\t\\tQuadraticBezier( t, v0.y, v1.y, v2.y ),\\n\\t\\t\\tQuadraticBezier( t, v0.z, v1.z, v2.z )\\n\\t\\t);\\n\\n\\t\\treturn point;\\n\\n\\t};\\n\\n\\tQuadraticBezierCurve3.prototype.copy = function ( source ) {\\n\\n\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\tthis.v0.copy( source.v0 );\\n\\t\\tthis.v1.copy( source.v1 );\\n\\t\\tthis.v2.copy( source.v2 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tQuadraticBezierCurve3.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\tdata.v0 = this.v0.toArray();\\n\\t\\tdata.v1 = this.v1.toArray();\\n\\t\\tdata.v2 = this.v2.toArray();\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tQuadraticBezierCurve3.prototype.fromJSON = function ( json ) {\\n\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\tthis.v0.fromArray( json.v0 );\\n\\t\\tthis.v1.fromArray( json.v1 );\\n\\t\\tthis.v2.fromArray( json.v2 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction SplineCurve( points /* array of Vector2 */ ) {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'SplineCurve';\\n\\n\\t\\tthis.points = points || [];\\n\\n\\t}\\n\\n\\tSplineCurve.prototype = Object.create( Curve.prototype );\\n\\tSplineCurve.prototype.constructor = SplineCurve;\\n\\n\\tSplineCurve.prototype.isSplineCurve = true;\\n\\n\\tSplineCurve.prototype.getPoint = function ( t, optionalTarget ) {\\n\\n\\t\\tvar point = optionalTarget || new Vector2();\\n\\n\\t\\tvar points = this.points;\\n\\t\\tvar p = ( points.length - 1 ) * t;\\n\\n\\t\\tvar intPoint = Math.floor( p );\\n\\t\\tvar weight = p - intPoint;\\n\\n\\t\\tvar p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\\n\\t\\tvar p1 = points[ intPoint ];\\n\\t\\tvar p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\\n\\t\\tvar p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\\n\\n\\t\\tpoint.set(\\n\\t\\t\\tCatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),\\n\\t\\t\\tCatmullRom( weight, p0.y, p1.y, p2.y, p3.y )\\n\\t\\t);\\n\\n\\t\\treturn point;\\n\\n\\t};\\n\\n\\tSplineCurve.prototype.copy = function ( source ) {\\n\\n\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\tthis.points = [];\\n\\n\\t\\tfor ( var i = 0, l = source.points.length; i < l; i ++ ) {\\n\\n\\t\\t\\tvar point = source.points[ i ];\\n\\n\\t\\t\\tthis.points.push( point.clone() );\\n\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tSplineCurve.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\tdata.points = [];\\n\\n\\t\\tfor ( var i = 0, l = this.points.length; i < l; i ++ ) {\\n\\n\\t\\t\\tvar point = this.points[ i ];\\n\\t\\t\\tdata.points.push( point.toArray() );\\n\\n\\t\\t}\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tSplineCurve.prototype.fromJSON = function ( json ) {\\n\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\tthis.points = [];\\n\\n\\t\\tfor ( var i = 0, l = json.points.length; i < l; i ++ ) {\\n\\n\\t\\t\\tvar point = json.points[ i ];\\n\\t\\t\\tthis.points.push( new Vector2().fromArray( point ) );\\n\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\n\\n\\tvar Curves = Object.freeze({\\n\\t\\tArcCurve: ArcCurve,\\n\\t\\tCatmullRomCurve3: CatmullRomCurve3,\\n\\t\\tCubicBezierCurve: CubicBezierCurve,\\n\\t\\tCubicBezierCurve3: CubicBezierCurve3,\\n\\t\\tEllipseCurve: EllipseCurve,\\n\\t\\tLineCurve: LineCurve,\\n\\t\\tLineCurve3: LineCurve3,\\n\\t\\tQuadraticBezierCurve: QuadraticBezierCurve,\\n\\t\\tQuadraticBezierCurve3: QuadraticBezierCurve3,\\n\\t\\tSplineCurve: SplineCurve\\n\\t});\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t *\\n\\t **/\\n\\n\\t/**************************************************************\\n\\t *\\tCurved Path - a curve path is simply a array of connected\\n\\t *  curves, but retains the api of a curve\\n\\t **************************************************************/\\n\\n\\tfunction CurvePath() {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'CurvePath';\\n\\n\\t\\tthis.curves = [];\\n\\t\\tthis.autoClose = false; // Automatically closes the path\\n\\n\\t}\\n\\n\\tCurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {\\n\\n\\t\\tconstructor: CurvePath,\\n\\n\\t\\tadd: function ( curve ) {\\n\\n\\t\\t\\tthis.curves.push( curve );\\n\\n\\t\\t},\\n\\n\\t\\tclosePath: function () {\\n\\n\\t\\t\\t// Add a line curve if start and end of lines are not connected\\n\\t\\t\\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\\n\\t\\t\\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\\n\\n\\t\\t\\tif ( ! startPoint.equals( endPoint ) ) {\\n\\n\\t\\t\\t\\tthis.curves.push( new LineCurve( endPoint, startPoint ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t// To get accurate point with reference to\\n\\t\\t// entire path distance at time t,\\n\\t\\t// following has to be done:\\n\\n\\t\\t// 1. Length of each sub path have to be known\\n\\t\\t// 2. Locate and identify type of curve\\n\\t\\t// 3. Get t for the curve\\n\\t\\t// 4. Return curve.getPointAt(t')\\n\\n\\t\\tgetPoint: function ( t ) {\\n\\n\\t\\t\\tvar d = t * this.getLength();\\n\\t\\t\\tvar curveLengths = this.getCurveLengths();\\n\\t\\t\\tvar i = 0;\\n\\n\\t\\t\\t// To think about boundaries points.\\n\\n\\t\\t\\twhile ( i < curveLengths.length ) {\\n\\n\\t\\t\\t\\tif ( curveLengths[ i ] >= d ) {\\n\\n\\t\\t\\t\\t\\tvar diff = curveLengths[ i ] - d;\\n\\t\\t\\t\\t\\tvar curve = this.curves[ i ];\\n\\n\\t\\t\\t\\t\\tvar segmentLength = curve.getLength();\\n\\t\\t\\t\\t\\tvar u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\\n\\n\\t\\t\\t\\t\\treturn curve.getPointAt( u );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ti ++;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn null;\\n\\n\\t\\t\\t// loop where sum != 0, sum > d , sum+1 <d\\n\\n\\t\\t},\\n\\n\\t\\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\\n\\t\\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\\n\\t\\t// getPoint() depends on getLength\\n\\n\\t\\tgetLength: function () {\\n\\n\\t\\t\\tvar lens = this.getCurveLengths();\\n\\t\\t\\treturn lens[ lens.length - 1 ];\\n\\n\\t\\t},\\n\\n\\t\\t// cacheLengths must be recalculated.\\n\\t\\tupdateArcLengths: function () {\\n\\n\\t\\t\\tthis.needsUpdate = true;\\n\\t\\t\\tthis.cacheLengths = null;\\n\\t\\t\\tthis.getCurveLengths();\\n\\n\\t\\t},\\n\\n\\t\\t// Compute lengths and cache them\\n\\t\\t// We cannot overwrite getLengths() because UtoT mapping uses it.\\n\\n\\t\\tgetCurveLengths: function () {\\n\\n\\t\\t\\t// We use cache values if curves and cache array are same length\\n\\n\\t\\t\\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\\n\\n\\t\\t\\t\\treturn this.cacheLengths;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Get length of sub-curve\\n\\t\\t\\t// Push sums into cached array\\n\\n\\t\\t\\tvar lengths = [], sums = 0;\\n\\n\\t\\t\\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tsums += this.curves[ i ].getLength();\\n\\t\\t\\t\\tlengths.push( sums );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.cacheLengths = lengths;\\n\\n\\t\\t\\treturn lengths;\\n\\n\\t\\t},\\n\\n\\t\\tgetSpacedPoints: function ( divisions ) {\\n\\n\\t\\t\\tif ( divisions === undefined ) divisions = 40;\\n\\n\\t\\t\\tvar points = [];\\n\\n\\t\\t\\tfor ( var i = 0; i <= divisions; i ++ ) {\\n\\n\\t\\t\\t\\tpoints.push( this.getPoint( i / divisions ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.autoClose ) {\\n\\n\\t\\t\\t\\tpoints.push( points[ 0 ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn points;\\n\\n\\t\\t},\\n\\n\\t\\tgetPoints: function ( divisions ) {\\n\\n\\t\\t\\tdivisions = divisions || 12;\\n\\n\\t\\t\\tvar points = [], last;\\n\\n\\t\\t\\tfor ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {\\n\\n\\t\\t\\t\\tvar curve = curves[ i ];\\n\\t\\t\\t\\tvar resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2\\n\\t\\t\\t\\t\\t: ( curve && curve.isLineCurve ) ? 1\\n\\t\\t\\t\\t\\t\\t: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length\\n\\t\\t\\t\\t\\t\\t\\t: divisions;\\n\\n\\t\\t\\t\\tvar pts = curve.getPoints( resolution );\\n\\n\\t\\t\\t\\tfor ( var j = 0; j < pts.length; j ++ ) {\\n\\n\\t\\t\\t\\t\\tvar point = pts[ j ];\\n\\n\\t\\t\\t\\t\\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\\n\\n\\t\\t\\t\\t\\tpoints.push( point );\\n\\t\\t\\t\\t\\tlast = point;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {\\n\\n\\t\\t\\t\\tpoints.push( points[ 0 ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn points;\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.curves = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = source.curves.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar curve = source.curves[ i ];\\n\\n\\t\\t\\t\\tthis.curves.push( curve.clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.autoClose = source.autoClose;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function () {\\n\\n\\t\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\t\\tdata.autoClose = this.autoClose;\\n\\t\\t\\tdata.curves = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar curve = this.curves[ i ];\\n\\t\\t\\t\\tdata.curves.push( curve.toJSON() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t},\\n\\n\\t\\tfromJSON: function ( json ) {\\n\\n\\t\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\t\\tthis.autoClose = json.autoClose;\\n\\t\\t\\tthis.curves = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = json.curves.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar curve = json.curves[ i ];\\n\\t\\t\\t\\tthis.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t * Creates free form 2d path using series of points, lines or curves.\\n\\t **/\\n\\n\\tfunction Path( points ) {\\n\\n\\t\\tCurvePath.call( this );\\n\\n\\t\\tthis.type = 'Path';\\n\\n\\t\\tthis.currentPoint = new Vector2();\\n\\n\\t\\tif ( points ) {\\n\\n\\t\\t\\tthis.setFromPoints( points );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tPath.prototype = Object.assign( Object.create( CurvePath.prototype ), {\\n\\n\\t\\tconstructor: Path,\\n\\n\\t\\tsetFromPoints: function ( points ) {\\n\\n\\t\\t\\tthis.moveTo( points[ 0 ].x, points[ 0 ].y );\\n\\n\\t\\t\\tfor ( var i = 1, l = points.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tthis.lineTo( points[ i ].x, points[ i ].y );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tmoveTo: function ( x, y ) {\\n\\n\\t\\t\\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\\n\\n\\t\\t},\\n\\n\\t\\tlineTo: function ( x, y ) {\\n\\n\\t\\t\\tvar curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\\n\\t\\t\\tthis.curves.push( curve );\\n\\n\\t\\t\\tthis.currentPoint.set( x, y );\\n\\n\\t\\t},\\n\\n\\t\\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\\n\\n\\t\\t\\tvar curve = new QuadraticBezierCurve(\\n\\t\\t\\t\\tthis.currentPoint.clone(),\\n\\t\\t\\t\\tnew Vector2( aCPx, aCPy ),\\n\\t\\t\\t\\tnew Vector2( aX, aY )\\n\\t\\t\\t);\\n\\n\\t\\t\\tthis.curves.push( curve );\\n\\n\\t\\t\\tthis.currentPoint.set( aX, aY );\\n\\n\\t\\t},\\n\\n\\t\\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\\n\\n\\t\\t\\tvar curve = new CubicBezierCurve(\\n\\t\\t\\t\\tthis.currentPoint.clone(),\\n\\t\\t\\t\\tnew Vector2( aCP1x, aCP1y ),\\n\\t\\t\\t\\tnew Vector2( aCP2x, aCP2y ),\\n\\t\\t\\t\\tnew Vector2( aX, aY )\\n\\t\\t\\t);\\n\\n\\t\\t\\tthis.curves.push( curve );\\n\\n\\t\\t\\tthis.currentPoint.set( aX, aY );\\n\\n\\t\\t},\\n\\n\\t\\tsplineThru: function ( pts /*Array of Vector*/ ) {\\n\\n\\t\\t\\tvar npts = [ this.currentPoint.clone() ].concat( pts );\\n\\n\\t\\t\\tvar curve = new SplineCurve( npts );\\n\\t\\t\\tthis.curves.push( curve );\\n\\n\\t\\t\\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\\n\\n\\t\\t},\\n\\n\\t\\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\\n\\n\\t\\t\\tvar x0 = this.currentPoint.x;\\n\\t\\t\\tvar y0 = this.currentPoint.y;\\n\\n\\t\\t\\tthis.absarc( aX + x0, aY + y0, aRadius,\\n\\t\\t\\t\\taStartAngle, aEndAngle, aClockwise );\\n\\n\\t\\t},\\n\\n\\t\\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\\n\\n\\t\\t\\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\\n\\n\\t\\t},\\n\\n\\t\\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\\n\\n\\t\\t\\tvar x0 = this.currentPoint.x;\\n\\t\\t\\tvar y0 = this.currentPoint.y;\\n\\n\\t\\t\\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\\n\\n\\t\\t},\\n\\n\\t\\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\\n\\n\\t\\t\\tvar curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\\n\\n\\t\\t\\tif ( this.curves.length > 0 ) {\\n\\n\\t\\t\\t\\t// if a previous curve is present, attempt to join\\n\\t\\t\\t\\tvar firstPoint = curve.getPoint( 0 );\\n\\n\\t\\t\\t\\tif ( ! firstPoint.equals( this.currentPoint ) ) {\\n\\n\\t\\t\\t\\t\\tthis.lineTo( firstPoint.x, firstPoint.y );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.curves.push( curve );\\n\\n\\t\\t\\tvar lastPoint = curve.getPoint( 1 );\\n\\t\\t\\tthis.currentPoint.copy( lastPoint );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tCurvePath.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.currentPoint.copy( source.currentPoint );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function () {\\n\\n\\t\\t\\tvar data = CurvePath.prototype.toJSON.call( this );\\n\\n\\t\\t\\tdata.currentPoint = this.currentPoint.toArray();\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t},\\n\\n\\t\\tfromJSON: function ( json ) {\\n\\n\\t\\t\\tCurvePath.prototype.fromJSON.call( this, json );\\n\\n\\t\\t\\tthis.currentPoint.fromArray( json.currentPoint );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t * Defines a 2d shape plane using paths.\\n\\t **/\\n\\n\\t// STEP 1 Create a path.\\n\\t// STEP 2 Turn path into shape.\\n\\t// STEP 3 ExtrudeGeometry takes in Shape/Shapes\\n\\t// STEP 3a - Extract points from each shape, turn to vertices\\n\\t// STEP 3b - Triangulate each shape, add faces.\\n\\n\\tfunction Shape( points ) {\\n\\n\\t\\tPath.call( this, points );\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\tthis.type = 'Shape';\\n\\n\\t\\tthis.holes = [];\\n\\n\\t}\\n\\n\\tShape.prototype = Object.assign( Object.create( Path.prototype ), {\\n\\n\\t\\tconstructor: Shape,\\n\\n\\t\\tgetPointsHoles: function ( divisions ) {\\n\\n\\t\\t\\tvar holesPts = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn holesPts;\\n\\n\\t\\t},\\n\\n\\t\\t// get points of shape and holes (keypoints based on segments parameter)\\n\\n\\t\\textractPoints: function ( divisions ) {\\n\\n\\t\\t\\treturn {\\n\\n\\t\\t\\t\\tshape: this.getPoints( divisions ),\\n\\t\\t\\t\\tholes: this.getPointsHoles( divisions )\\n\\n\\t\\t\\t};\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tPath.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.holes = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = source.holes.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar hole = source.holes[ i ];\\n\\n\\t\\t\\t\\tthis.holes.push( hole.clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function () {\\n\\n\\t\\t\\tvar data = Path.prototype.toJSON.call( this );\\n\\n\\t\\t\\tdata.uuid = this.uuid;\\n\\t\\t\\tdata.holes = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar hole = this.holes[ i ];\\n\\t\\t\\t\\tdata.holes.push( hole.toJSON() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t},\\n\\n\\t\\tfromJSON: function ( json ) {\\n\\n\\t\\t\\tPath.prototype.fromJSON.call( this, json );\\n\\n\\t\\t\\tthis.uuid = json.uuid;\\n\\t\\t\\tthis.holes = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = json.holes.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar hole = json.holes[ i ];\\n\\t\\t\\t\\tthis.holes.push( new Path().fromJSON( hole ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction Light( color, intensity ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Light';\\n\\n\\t\\tthis.color = new Color( color );\\n\\t\\tthis.intensity = intensity !== undefined ? intensity : 1;\\n\\n\\t\\tthis.receiveShadow = undefined;\\n\\n\\t}\\n\\n\\tLight.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Light,\\n\\n\\t\\tisLight: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tObject3D.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.color.copy( source.color );\\n\\t\\t\\tthis.intensity = source.intensity;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( meta ) {\\n\\n\\t\\t\\tvar data = Object3D.prototype.toJSON.call( this, meta );\\n\\n\\t\\t\\tdata.object.color = this.color.getHex();\\n\\t\\t\\tdata.object.intensity = this.intensity;\\n\\n\\t\\t\\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\\n\\n\\t\\t\\tif ( this.distance !== undefined ) data.object.distance = this.distance;\\n\\t\\t\\tif ( this.angle !== undefined ) data.object.angle = this.angle;\\n\\t\\t\\tif ( this.decay !== undefined ) data.object.decay = this.decay;\\n\\t\\t\\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\\n\\n\\t\\t\\tif ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction HemisphereLight( skyColor, groundColor, intensity ) {\\n\\n\\t\\tLight.call( this, skyColor, intensity );\\n\\n\\t\\tthis.type = 'HemisphereLight';\\n\\n\\t\\tthis.castShadow = undefined;\\n\\n\\t\\tthis.position.copy( Object3D.DefaultUp );\\n\\t\\tthis.updateMatrix();\\n\\n\\t\\tthis.groundColor = new Color( groundColor );\\n\\n\\t}\\n\\n\\tHemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {\\n\\n\\t\\tconstructor: HemisphereLight,\\n\\n\\t\\tisHemisphereLight: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tLight.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.groundColor.copy( source.groundColor );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction LightShadow( camera ) {\\n\\n\\t\\tthis.camera = camera;\\n\\n\\t\\tthis.bias = 0;\\n\\t\\tthis.radius = 1;\\n\\n\\t\\tthis.mapSize = new Vector2( 512, 512 );\\n\\n\\t\\tthis.map = null;\\n\\t\\tthis.matrix = new Matrix4();\\n\\n\\t}\\n\\n\\tObject.assign( LightShadow.prototype, {\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tthis.camera = source.camera.clone();\\n\\n\\t\\t\\tthis.bias = source.bias;\\n\\t\\t\\tthis.radius = source.radius;\\n\\n\\t\\t\\tthis.mapSize.copy( source.mapSize );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function () {\\n\\n\\t\\t\\tvar object = {};\\n\\n\\t\\t\\tif ( this.bias !== 0 ) object.bias = this.bias;\\n\\t\\t\\tif ( this.radius !== 1 ) object.radius = this.radius;\\n\\t\\t\\tif ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();\\n\\n\\t\\t\\tobject.camera = this.camera.toJSON( false ).object;\\n\\t\\t\\tdelete object.camera.matrix;\\n\\n\\t\\t\\treturn object;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction SpotLightShadow() {\\n\\n\\t\\tLightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );\\n\\n\\t}\\n\\n\\tSpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\\n\\n\\t\\tconstructor: SpotLightShadow,\\n\\n\\t\\tisSpotLightShadow: true,\\n\\n\\t\\tupdate: function ( light ) {\\n\\n\\t\\t\\tvar camera = this.camera;\\n\\n\\t\\t\\tvar fov = _Math.RAD2DEG * 2 * light.angle;\\n\\t\\t\\tvar aspect = this.mapSize.width / this.mapSize.height;\\n\\t\\t\\tvar far = light.distance || camera.far;\\n\\n\\t\\t\\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\\n\\n\\t\\t\\t\\tcamera.fov = fov;\\n\\t\\t\\t\\tcamera.aspect = aspect;\\n\\t\\t\\t\\tcamera.far = far;\\n\\t\\t\\t\\tcamera.updateProjectionMatrix();\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction SpotLight( color, intensity, distance, angle, penumbra, decay ) {\\n\\n\\t\\tLight.call( this, color, intensity );\\n\\n\\t\\tthis.type = 'SpotLight';\\n\\n\\t\\tthis.position.copy( Object3D.DefaultUp );\\n\\t\\tthis.updateMatrix();\\n\\n\\t\\tthis.target = new Object3D();\\n\\n\\t\\tObject.defineProperty( this, 'power', {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\t// intensity = power per solid angle.\\n\\t\\t\\t\\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\\n\\t\\t\\t\\treturn this.intensity * Math.PI;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( power ) {\\n\\n\\t\\t\\t\\t// intensity = power per solid angle.\\n\\t\\t\\t\\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\\n\\t\\t\\t\\tthis.intensity = power / Math.PI;\\n\\n\\t\\t\\t}\\n\\t\\t} );\\n\\n\\t\\tthis.distance = ( distance !== undefined ) ? distance : 0;\\n\\t\\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\\n\\t\\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\\n\\t\\tthis.decay = ( decay !== undefined ) ? decay : 1;\\t// for physically correct lights, should be 2.\\n\\n\\t\\tthis.shadow = new SpotLightShadow();\\n\\n\\t}\\n\\n\\tSpotLight.prototype = Object.assign( Object.create( Light.prototype ), {\\n\\n\\t\\tconstructor: SpotLight,\\n\\n\\t\\tisSpotLight: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tLight.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.distance = source.distance;\\n\\t\\t\\tthis.angle = source.angle;\\n\\t\\t\\tthis.penumbra = source.penumbra;\\n\\t\\t\\tthis.decay = source.decay;\\n\\n\\t\\t\\tthis.target = source.target.clone();\\n\\n\\t\\t\\tthis.shadow = source.shadow.clone();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\n\\tfunction PointLight( color, intensity, distance, decay ) {\\n\\n\\t\\tLight.call( this, color, intensity );\\n\\n\\t\\tthis.type = 'PointLight';\\n\\n\\t\\tObject.defineProperty( this, 'power', {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\t// intensity = power per solid angle.\\n\\t\\t\\t\\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\\n\\t\\t\\t\\treturn this.intensity * 4 * Math.PI;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( power ) {\\n\\n\\t\\t\\t\\t// intensity = power per solid angle.\\n\\t\\t\\t\\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\\n\\t\\t\\t\\tthis.intensity = power / ( 4 * Math.PI );\\n\\n\\t\\t\\t}\\n\\t\\t} );\\n\\n\\t\\tthis.distance = ( distance !== undefined ) ? distance : 0;\\n\\t\\tthis.decay = ( decay !== undefined ) ? decay : 1;\\t// for physically correct lights, should be 2.\\n\\n\\t\\tthis.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );\\n\\n\\t}\\n\\n\\tPointLight.prototype = Object.assign( Object.create( Light.prototype ), {\\n\\n\\t\\tconstructor: PointLight,\\n\\n\\t\\tisPointLight: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tLight.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.distance = source.distance;\\n\\t\\t\\tthis.decay = source.decay;\\n\\n\\t\\t\\tthis.shadow = source.shadow.clone();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction DirectionalLightShadow( ) {\\n\\n\\t\\tLightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\\n\\n\\t}\\n\\n\\tDirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\\n\\n\\t\\tconstructor: DirectionalLightShadow\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction DirectionalLight( color, intensity ) {\\n\\n\\t\\tLight.call( this, color, intensity );\\n\\n\\t\\tthis.type = 'DirectionalLight';\\n\\n\\t\\tthis.position.copy( Object3D.DefaultUp );\\n\\t\\tthis.updateMatrix();\\n\\n\\t\\tthis.target = new Object3D();\\n\\n\\t\\tthis.shadow = new DirectionalLightShadow();\\n\\n\\t}\\n\\n\\tDirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {\\n\\n\\t\\tconstructor: DirectionalLight,\\n\\n\\t\\tisDirectionalLight: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tLight.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.target = source.target.clone();\\n\\n\\t\\t\\tthis.shadow = source.shadow.clone();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction AmbientLight( color, intensity ) {\\n\\n\\t\\tLight.call( this, color, intensity );\\n\\n\\t\\tthis.type = 'AmbientLight';\\n\\n\\t\\tthis.castShadow = undefined;\\n\\n\\t}\\n\\n\\tAmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {\\n\\n\\t\\tconstructor: AmbientLight,\\n\\n\\t\\tisAmbientLight: true\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author abelnation / http://github.com/abelnation\\n\\t */\\n\\n\\tfunction RectAreaLight( color, intensity, width, height ) {\\n\\n\\t\\tLight.call( this, color, intensity );\\n\\n\\t\\tthis.type = 'RectAreaLight';\\n\\n\\t\\tthis.position.set( 0, 1, 0 );\\n\\t\\tthis.updateMatrix();\\n\\n\\t\\tthis.width = ( width !== undefined ) ? width : 10;\\n\\t\\tthis.height = ( height !== undefined ) ? height : 10;\\n\\n\\t\\t// TODO (abelnation): distance/decay\\n\\n\\t\\t// TODO (abelnation): update method for RectAreaLight to update transform to lookat target\\n\\n\\t\\t// TODO (abelnation): shadows\\n\\n\\t}\\n\\n\\t// TODO (abelnation): RectAreaLight update when light shape is changed\\n\\tRectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {\\n\\n\\t\\tconstructor: RectAreaLight,\\n\\n\\t\\tisRectAreaLight: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tLight.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.width = source.width;\\n\\t\\t\\tthis.height = source.height;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( meta ) {\\n\\n\\t\\t\\tvar data = Light.prototype.toJSON.call( this, meta );\\n\\n\\t\\t\\tdata.object.width = this.width;\\n\\t\\t\\tdata.object.height = this.height;\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * A Track that interpolates Strings\\n\\t *\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction StringKeyframeTrack( name, times, values, interpolation ) {\\n\\n\\t\\tKeyframeTrack.call( this, name, times, values, interpolation );\\n\\n\\t}\\n\\n\\tStringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\n\\n\\t\\tconstructor: StringKeyframeTrack,\\n\\n\\t\\tValueTypeName: 'string',\\n\\t\\tValueBufferType: Array,\\n\\n\\t\\tDefaultInterpolation: InterpolateDiscrete,\\n\\n\\t\\tInterpolantFactoryMethodLinear: undefined,\\n\\n\\t\\tInterpolantFactoryMethodSmooth: undefined\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * A Track of Boolean keyframe values.\\n\\t *\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction BooleanKeyframeTrack( name, times, values ) {\\n\\n\\t\\tKeyframeTrack.call( this, name, times, values );\\n\\n\\t}\\n\\n\\tBooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\n\\n\\t\\tconstructor: BooleanKeyframeTrack,\\n\\n\\t\\tValueTypeName: 'bool',\\n\\t\\tValueBufferType: Array,\\n\\n\\t\\tDefaultInterpolation: InterpolateDiscrete,\\n\\n\\t\\tInterpolantFactoryMethodLinear: undefined,\\n\\t\\tInterpolantFactoryMethodSmooth: undefined\\n\\n\\t\\t// Note: Actually this track could have a optimized / compressed\\n\\t\\t// representation of a single value and a custom interpolant that\\n\\t\\t// computes \\\"firstValue ^ isOdd( index )\\\".\\n\\n\\t} );\\n\\n\\t/**\\n\\t * Abstract base class of interpolants over parametric samples.\\n\\t *\\n\\t * The parameter domain is one dimensional, typically the time or a path\\n\\t * along a curve defined by the data.\\n\\t *\\n\\t * The sample values can have any dimensionality and derived classes may\\n\\t * apply special interpretations to the data.\\n\\t *\\n\\t * This class provides the interval seek in a Template Method, deferring\\n\\t * the actual interpolation to derived classes.\\n\\t *\\n\\t * Time complexity is O(1) for linear access crossing at most two points\\n\\t * and O(log N) for random access, where N is the number of positions.\\n\\t *\\n\\t * References:\\n\\t *\\n\\t * \\t\\thttp://www.oodesign.com/template-method-pattern.html\\n\\t *\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\\n\\n\\t\\tthis.parameterPositions = parameterPositions;\\n\\t\\tthis._cachedIndex = 0;\\n\\n\\t\\tthis.resultBuffer = resultBuffer !== undefined ?\\n\\t\\t\\tresultBuffer : new sampleValues.constructor( sampleSize );\\n\\t\\tthis.sampleValues = sampleValues;\\n\\t\\tthis.valueSize = sampleSize;\\n\\n\\t}\\n\\n\\tObject.assign( Interpolant.prototype, {\\n\\n\\t\\tevaluate: function ( t ) {\\n\\n\\t\\t\\tvar pp = this.parameterPositions,\\n\\t\\t\\t\\ti1 = this._cachedIndex,\\n\\n\\t\\t\\t\\tt1 = pp[ i1 ],\\n\\t\\t\\t\\tt0 = pp[ i1 - 1 ];\\n\\n\\t\\t\\tvalidate_interval: {\\n\\n\\t\\t\\t\\tseek: {\\n\\n\\t\\t\\t\\t\\tvar right;\\n\\n\\t\\t\\t\\t\\tlinear_scan: {\\n\\n\\t\\t\\t\\t\\t\\t//- See http://jsperf.com/comparison-to-undefined/3\\n\\t\\t\\t\\t\\t\\t//- slower code:\\n\\t\\t\\t\\t\\t\\t//-\\n\\t\\t\\t\\t\\t\\t//- \\t\\t\\t\\tif ( t >= t1 || t1 === undefined ) {\\n\\t\\t\\t\\t\\t\\tforward_scan: if ( ! ( t < t1 ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var giveUpAt = i1 + 2; ; ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( t1 === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( t < t0 ) break forward_scan;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// after end\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ti1 = pp.length;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthis._cachedIndex = i1;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturn this.afterEnd_( i1 - 1, t, t0 );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( i1 === giveUpAt ) break; // this loop\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tt0 = t1;\\n\\t\\t\\t\\t\\t\\t\\t\\tt1 = pp[ ++ i1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( t < t1 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// we have arrived at the sought interval\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak seek;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t// prepare binary search on the right side of the index\\n\\t\\t\\t\\t\\t\\t\\tright = pp.length;\\n\\t\\t\\t\\t\\t\\t\\tbreak linear_scan;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t//- slower code:\\n\\t\\t\\t\\t\\t\\t//-\\t\\t\\t\\t\\tif ( t < t0 || t0 === undefined ) {\\n\\t\\t\\t\\t\\t\\tif ( ! ( t >= t0 ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// looping?\\n\\n\\t\\t\\t\\t\\t\\t\\tvar t1global = pp[ 1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( t < t1global ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\ti1 = 2; // + 1, using the scan for the details\\n\\t\\t\\t\\t\\t\\t\\t\\tt0 = t1global;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t// linear reverse scan\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var giveUpAt = i1 - 2; ; ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( t0 === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// before start\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthis._cachedIndex = 0;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturn this.beforeStart_( 0, t, t1 );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( i1 === giveUpAt ) break; // this loop\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tt1 = t0;\\n\\t\\t\\t\\t\\t\\t\\t\\tt0 = pp[ -- i1 - 1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( t >= t0 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// we have arrived at the sought interval\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak seek;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t// prepare binary search on the left side of the index\\n\\t\\t\\t\\t\\t\\t\\tright = i1;\\n\\t\\t\\t\\t\\t\\t\\ti1 = 0;\\n\\t\\t\\t\\t\\t\\t\\tbreak linear_scan;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// the interval is valid\\n\\n\\t\\t\\t\\t\\t\\tbreak validate_interval;\\n\\n\\t\\t\\t\\t\\t} // linear scan\\n\\n\\t\\t\\t\\t\\t// binary search\\n\\n\\t\\t\\t\\t\\twhile ( i1 < right ) {\\n\\n\\t\\t\\t\\t\\t\\tvar mid = ( i1 + right ) >>> 1;\\n\\n\\t\\t\\t\\t\\t\\tif ( t < pp[ mid ] ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tright = mid;\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\ti1 = mid + 1;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tt1 = pp[ i1 ];\\n\\t\\t\\t\\t\\tt0 = pp[ i1 - 1 ];\\n\\n\\t\\t\\t\\t\\t// check boundary cases, again\\n\\n\\t\\t\\t\\t\\tif ( t0 === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tthis._cachedIndex = 0;\\n\\t\\t\\t\\t\\t\\treturn this.beforeStart_( 0, t, t1 );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( t1 === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\ti1 = pp.length;\\n\\t\\t\\t\\t\\t\\tthis._cachedIndex = i1;\\n\\t\\t\\t\\t\\t\\treturn this.afterEnd_( i1 - 1, t0, t );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} // seek\\n\\n\\t\\t\\t\\tthis._cachedIndex = i1;\\n\\n\\t\\t\\t\\tthis.intervalChanged_( i1, t0, t1 );\\n\\n\\t\\t\\t} // validate_interval\\n\\n\\t\\t\\treturn this.interpolate_( i1, t0, t, t1 );\\n\\n\\t\\t},\\n\\n\\t\\tsettings: null, // optional, subclass-specific settings structure\\n\\t\\t// Note: The indirection allows central control of many interpolants.\\n\\n\\t\\t// --- Protected interface\\n\\n\\t\\tDefaultSettings_: {},\\n\\n\\t\\tgetSettings_: function () {\\n\\n\\t\\t\\treturn this.settings || this.DefaultSettings_;\\n\\n\\t\\t},\\n\\n\\t\\tcopySampleValue_: function ( index ) {\\n\\n\\t\\t\\t// copies a sample value to the result buffer\\n\\n\\t\\t\\tvar result = this.resultBuffer,\\n\\t\\t\\t\\tvalues = this.sampleValues,\\n\\t\\t\\t\\tstride = this.valueSize,\\n\\t\\t\\t\\toffset = index * stride;\\n\\n\\t\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\n\\n\\t\\t\\t\\tresult[ i ] = values[ offset + i ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\n\\t\\t},\\n\\n\\t\\t// Template methods for derived classes:\\n\\n\\t\\tinterpolate_: function ( /* i1, t0, t, t1 */ ) {\\n\\n\\t\\t\\tthrow new Error( 'call to abstract method' );\\n\\t\\t\\t// implementations shall return this.resultBuffer\\n\\n\\t\\t},\\n\\n\\t\\tintervalChanged_: function ( /* i1, t0, t1 */ ) {\\n\\n\\t\\t\\t// empty\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//!\\\\ DECLARE ALIAS AFTER assign prototype !\\n\\tObject.assign( Interpolant.prototype, {\\n\\n\\t\\t//( 0, t, t0 ), returns this.resultBuffer\\n\\t\\tbeforeStart_: Interpolant.prototype.copySampleValue_,\\n\\n\\t\\t//( N-1, tN-1, t ), returns this.resultBuffer\\n\\t\\tafterEnd_: Interpolant.prototype.copySampleValue_,\\n\\n\\t} );\\n\\n\\t/**\\n\\t * Spherical linear unit quaternion interpolant.\\n\\t *\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\\n\\n\\t\\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\\n\\n\\t}\\n\\n\\tQuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\\n\\n\\t\\tconstructor: QuaternionLinearInterpolant,\\n\\n\\t\\tinterpolate_: function ( i1, t0, t, t1 ) {\\n\\n\\t\\t\\tvar result = this.resultBuffer,\\n\\t\\t\\t\\tvalues = this.sampleValues,\\n\\t\\t\\t\\tstride = this.valueSize,\\n\\n\\t\\t\\t\\toffset = i1 * stride,\\n\\n\\t\\t\\t\\talpha = ( t - t0 ) / ( t1 - t0 );\\n\\n\\t\\t\\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\\n\\n\\t\\t\\t\\tQuaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * A Track of quaternion keyframe values.\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction QuaternionKeyframeTrack( name, times, values, interpolation ) {\\n\\n\\t\\tKeyframeTrack.call( this, name, times, values, interpolation );\\n\\n\\t}\\n\\n\\tQuaternionKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\n\\n\\t\\tconstructor: QuaternionKeyframeTrack,\\n\\n\\t\\tValueTypeName: 'quaternion',\\n\\n\\t\\t// ValueBufferType is inherited\\n\\n\\t\\tDefaultInterpolation: InterpolateLinear,\\n\\n\\t\\tInterpolantFactoryMethodLinear: function ( result ) {\\n\\n\\t\\t\\treturn new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );\\n\\n\\t\\t},\\n\\n\\t\\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * A Track of keyframe values that represent color.\\n\\t *\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction ColorKeyframeTrack( name, times, values, interpolation ) {\\n\\n\\t\\tKeyframeTrack.call( this, name, times, values, interpolation );\\n\\n\\t}\\n\\n\\tColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\n\\n\\t\\tconstructor: ColorKeyframeTrack,\\n\\n\\t\\tValueTypeName: 'color'\\n\\n\\t\\t// ValueBufferType is inherited\\n\\n\\t\\t// DefaultInterpolation is inherited\\n\\n\\t\\t// Note: Very basic implementation and nothing special yet.\\n\\t\\t// However, this is the place for color space parameterization.\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * A Track of numeric keyframe values.\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction NumberKeyframeTrack( name, times, values, interpolation ) {\\n\\n\\t\\tKeyframeTrack.call( this, name, times, values, interpolation );\\n\\n\\t}\\n\\n\\tNumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\n\\n\\t\\tconstructor: NumberKeyframeTrack,\\n\\n\\t\\tValueTypeName: 'number'\\n\\n\\t\\t// ValueBufferType is inherited\\n\\n\\t\\t// DefaultInterpolation is inherited\\n\\n\\t} );\\n\\n\\t/**\\n\\t * Fast and simple cubic spline interpolant.\\n\\t *\\n\\t * It was derived from a Hermitian construction setting the first derivative\\n\\t * at each sample position to the linear slope between neighboring positions\\n\\t * over their parameter interval.\\n\\t *\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\\n\\n\\t\\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\\n\\n\\t\\tthis._weightPrev = - 0;\\n\\t\\tthis._offsetPrev = - 0;\\n\\t\\tthis._weightNext = - 0;\\n\\t\\tthis._offsetNext = - 0;\\n\\n\\t}\\n\\n\\tCubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\\n\\n\\t\\tconstructor: CubicInterpolant,\\n\\n\\t\\tDefaultSettings_: {\\n\\n\\t\\t\\tendingStart: ZeroCurvatureEnding,\\n\\t\\t\\tendingEnd: ZeroCurvatureEnding\\n\\n\\t\\t},\\n\\n\\t\\tintervalChanged_: function ( i1, t0, t1 ) {\\n\\n\\t\\t\\tvar pp = this.parameterPositions,\\n\\t\\t\\t\\tiPrev = i1 - 2,\\n\\t\\t\\t\\tiNext = i1 + 1,\\n\\n\\t\\t\\t\\ttPrev = pp[ iPrev ],\\n\\t\\t\\t\\ttNext = pp[ iNext ];\\n\\n\\t\\t\\tif ( tPrev === undefined ) {\\n\\n\\t\\t\\t\\tswitch ( this.getSettings_().endingStart ) {\\n\\n\\t\\t\\t\\t\\tcase ZeroSlopeEnding:\\n\\n\\t\\t\\t\\t\\t\\t// f'(t0) = 0\\n\\t\\t\\t\\t\\t\\tiPrev = i1;\\n\\t\\t\\t\\t\\t\\ttPrev = 2 * t0 - t1;\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase WrapAroundEnding:\\n\\n\\t\\t\\t\\t\\t\\t// use the other end of the curve\\n\\t\\t\\t\\t\\t\\tiPrev = pp.length - 2;\\n\\t\\t\\t\\t\\t\\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tdefault: // ZeroCurvatureEnding\\n\\n\\t\\t\\t\\t\\t\\t// f''(t0) = 0 a.k.a. Natural Spline\\n\\t\\t\\t\\t\\t\\tiPrev = i1;\\n\\t\\t\\t\\t\\t\\ttPrev = t1;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( tNext === undefined ) {\\n\\n\\t\\t\\t\\tswitch ( this.getSettings_().endingEnd ) {\\n\\n\\t\\t\\t\\t\\tcase ZeroSlopeEnding:\\n\\n\\t\\t\\t\\t\\t\\t// f'(tN) = 0\\n\\t\\t\\t\\t\\t\\tiNext = i1;\\n\\t\\t\\t\\t\\t\\ttNext = 2 * t1 - t0;\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase WrapAroundEnding:\\n\\n\\t\\t\\t\\t\\t\\t// use the other end of the curve\\n\\t\\t\\t\\t\\t\\tiNext = 1;\\n\\t\\t\\t\\t\\t\\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tdefault: // ZeroCurvatureEnding\\n\\n\\t\\t\\t\\t\\t\\t// f''(tN) = 0, a.k.a. Natural Spline\\n\\t\\t\\t\\t\\t\\tiNext = i1 - 1;\\n\\t\\t\\t\\t\\t\\ttNext = t0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar halfDt = ( t1 - t0 ) * 0.5,\\n\\t\\t\\t\\tstride = this.valueSize;\\n\\n\\t\\t\\tthis._weightPrev = halfDt / ( t0 - tPrev );\\n\\t\\t\\tthis._weightNext = halfDt / ( tNext - t1 );\\n\\t\\t\\tthis._offsetPrev = iPrev * stride;\\n\\t\\t\\tthis._offsetNext = iNext * stride;\\n\\n\\t\\t},\\n\\n\\t\\tinterpolate_: function ( i1, t0, t, t1 ) {\\n\\n\\t\\t\\tvar result = this.resultBuffer,\\n\\t\\t\\t\\tvalues = this.sampleValues,\\n\\t\\t\\t\\tstride = this.valueSize,\\n\\n\\t\\t\\t\\to1 = i1 * stride,\\t\\to0 = o1 - stride,\\n\\t\\t\\t\\toP = this._offsetPrev, \\toN = this._offsetNext,\\n\\t\\t\\t\\twP = this._weightPrev,\\twN = this._weightNext,\\n\\n\\t\\t\\t\\tp = ( t - t0 ) / ( t1 - t0 ),\\n\\t\\t\\t\\tpp = p * p,\\n\\t\\t\\t\\tppp = pp * p;\\n\\n\\t\\t\\t// evaluate polynomials\\n\\n\\t\\t\\tvar sP = - wP * ppp + 2 * wP * pp - wP * p;\\n\\t\\t\\tvar s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;\\n\\t\\t\\tvar s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;\\n\\t\\t\\tvar sN = wN * ppp - wN * pp;\\n\\n\\t\\t\\t// combine data linearly\\n\\n\\t\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\n\\n\\t\\t\\t\\tresult[ i ] =\\n\\t\\t\\t\\t\\t\\tsP * values[ oP + i ] +\\n\\t\\t\\t\\t\\t\\ts0 * values[ o0 + i ] +\\n\\t\\t\\t\\t\\t\\ts1 * values[ o1 + i ] +\\n\\t\\t\\t\\t\\t\\tsN * values[ oN + i ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\\n\\n\\t\\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\\n\\n\\t}\\n\\n\\tLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\\n\\n\\t\\tconstructor: LinearInterpolant,\\n\\n\\t\\tinterpolate_: function ( i1, t0, t, t1 ) {\\n\\n\\t\\t\\tvar result = this.resultBuffer,\\n\\t\\t\\t\\tvalues = this.sampleValues,\\n\\t\\t\\t\\tstride = this.valueSize,\\n\\n\\t\\t\\t\\toffset1 = i1 * stride,\\n\\t\\t\\t\\toffset0 = offset1 - stride,\\n\\n\\t\\t\\t\\tweight1 = ( t - t0 ) / ( t1 - t0 ),\\n\\t\\t\\t\\tweight0 = 1 - weight1;\\n\\n\\t\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\n\\n\\t\\t\\t\\tresult[ i ] =\\n\\t\\t\\t\\t\\t\\tvalues[ offset0 + i ] * weight0 +\\n\\t\\t\\t\\t\\t\\tvalues[ offset1 + i ] * weight1;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * Interpolant that evaluates to the sample value at the position preceeding\\n\\t * the parameter.\\n\\t *\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\\n\\n\\t\\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\\n\\n\\t}\\n\\n\\tDiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\\n\\n\\t\\tconstructor: DiscreteInterpolant,\\n\\n\\t\\tinterpolate_: function ( i1 /*, t0, t, t1 */ ) {\\n\\n\\t\\t\\treturn this.copySampleValue_( i1 - 1 );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author tschw\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t */\\n\\n\\tvar AnimationUtils = {\\n\\n\\t\\t// same as Array.prototype.slice, but also works on typed arrays\\n\\t\\tarraySlice: function ( array, from, to ) {\\n\\n\\t\\t\\tif ( AnimationUtils.isTypedArray( array ) ) {\\n\\n\\t\\t\\t\\t// in ios9 array.subarray(from, undefined) will return empty array\\n\\t\\t\\t\\t// but array.subarray(from) or array.subarray(from, len) is correct\\n\\t\\t\\t\\treturn new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn array.slice( from, to );\\n\\n\\t\\t},\\n\\n\\t\\t// converts an array to a specific type\\n\\t\\tconvertArray: function ( array, type, forceClone ) {\\n\\n\\t\\t\\tif ( ! array || // let 'undefined' and 'null' pass\\n\\t\\t\\t\\t\\t! forceClone && array.constructor === type ) return array;\\n\\n\\t\\t\\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\\n\\n\\t\\t\\t\\treturn new type( array ); // create typed array\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn Array.prototype.slice.call( array ); // create Array\\n\\n\\t\\t},\\n\\n\\t\\tisTypedArray: function ( object ) {\\n\\n\\t\\t\\treturn ArrayBuffer.isView( object ) &&\\n\\t\\t\\t\\t\\t! ( object instanceof DataView );\\n\\n\\t\\t},\\n\\n\\t\\t// returns an array by which times and values can be sorted\\n\\t\\tgetKeyframeOrder: function ( times ) {\\n\\n\\t\\t\\tfunction compareTime( i, j ) {\\n\\n\\t\\t\\t\\treturn times[ i ] - times[ j ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar n = times.length;\\n\\t\\t\\tvar result = new Array( n );\\n\\t\\t\\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\\n\\n\\t\\t\\tresult.sort( compareTime );\\n\\n\\t\\t\\treturn result;\\n\\n\\t\\t},\\n\\n\\t\\t// uses the array previously returned by 'getKeyframeOrder' to sort data\\n\\t\\tsortedArray: function ( values, stride, order ) {\\n\\n\\t\\t\\tvar nValues = values.length;\\n\\t\\t\\tvar result = new values.constructor( nValues );\\n\\n\\t\\t\\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\\n\\n\\t\\t\\t\\tvar srcOffset = order[ i ] * stride;\\n\\n\\t\\t\\t\\tfor ( var j = 0; j !== stride; ++ j ) {\\n\\n\\t\\t\\t\\t\\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\n\\t\\t},\\n\\n\\t\\t// function for parsing AOS keyframe formats\\n\\t\\tflattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {\\n\\n\\t\\t\\tvar i = 1, key = jsonKeys[ 0 ];\\n\\n\\t\\t\\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\\n\\n\\t\\t\\t\\tkey = jsonKeys[ i ++ ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( key === undefined ) return; // no data\\n\\n\\t\\t\\tvar value = key[ valuePropertyName ];\\n\\t\\t\\tif ( value === undefined ) return; // no data\\n\\n\\t\\t\\tif ( Array.isArray( value ) ) {\\n\\n\\t\\t\\t\\tdo {\\n\\n\\t\\t\\t\\t\\tvalue = key[ valuePropertyName ];\\n\\n\\t\\t\\t\\t\\tif ( value !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\ttimes.push( key.time );\\n\\t\\t\\t\\t\\t\\tvalues.push.apply( values, value ); // push all elements\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tkey = jsonKeys[ i ++ ];\\n\\n\\t\\t\\t\\t} while ( key !== undefined );\\n\\n\\t\\t\\t} else if ( value.toArray !== undefined ) {\\n\\n\\t\\t\\t\\t// ...assume THREE.Math-ish\\n\\n\\t\\t\\t\\tdo {\\n\\n\\t\\t\\t\\t\\tvalue = key[ valuePropertyName ];\\n\\n\\t\\t\\t\\t\\tif ( value !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\ttimes.push( key.time );\\n\\t\\t\\t\\t\\t\\tvalue.toArray( values, values.length );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tkey = jsonKeys[ i ++ ];\\n\\n\\t\\t\\t\\t} while ( key !== undefined );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// otherwise push as-is\\n\\n\\t\\t\\t\\tdo {\\n\\n\\t\\t\\t\\t\\tvalue = key[ valuePropertyName ];\\n\\n\\t\\t\\t\\t\\tif ( value !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\ttimes.push( key.time );\\n\\t\\t\\t\\t\\t\\tvalues.push( value );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tkey = jsonKeys[ i ++ ];\\n\\n\\t\\t\\t\\t} while ( key !== undefined );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t *\\n\\t * A timed sequence of keyframes for a specific property.\\n\\t *\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction KeyframeTrack( name, times, values, interpolation ) {\\n\\n\\t\\tif ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );\\n\\t\\tif ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );\\n\\n\\t\\tthis.name = name;\\n\\n\\t\\tthis.times = AnimationUtils.convertArray( times, this.TimeBufferType );\\n\\t\\tthis.values = AnimationUtils.convertArray( values, this.ValueBufferType );\\n\\n\\t\\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\\n\\n\\t\\tthis.validate();\\n\\t\\tthis.optimize();\\n\\n\\t}\\n\\n\\t// Static methods:\\n\\n\\tObject.assign( KeyframeTrack, {\\n\\n\\t\\t// Serialization (in static context, because of constructor invocation\\n\\t\\t// and automatic invocation of .toJSON):\\n\\n\\t\\tparse: function ( json ) {\\n\\n\\t\\t\\tif ( json.type === undefined ) {\\n\\n\\t\\t\\t\\tthrow new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );\\n\\n\\t\\t\\tif ( json.times === undefined ) {\\n\\n\\t\\t\\t\\tvar times = [], values = [];\\n\\n\\t\\t\\t\\tAnimationUtils.flattenJSON( json.keys, times, values, 'value' );\\n\\n\\t\\t\\t\\tjson.times = times;\\n\\t\\t\\t\\tjson.values = values;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// derived classes can define a static parse method\\n\\t\\t\\tif ( trackType.parse !== undefined ) {\\n\\n\\t\\t\\t\\treturn trackType.parse( json );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// by default, we assume a constructor compatible with the base\\n\\t\\t\\t\\treturn new trackType( json.name, json.times, json.values, json.interpolation );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( track ) {\\n\\n\\t\\t\\tvar trackType = track.constructor;\\n\\n\\t\\t\\tvar json;\\n\\n\\t\\t\\t// derived classes can define a static toJSON method\\n\\t\\t\\tif ( trackType.toJSON !== undefined ) {\\n\\n\\t\\t\\t\\tjson = trackType.toJSON( track );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// by default, we assume the data can be serialized as-is\\n\\t\\t\\t\\tjson = {\\n\\n\\t\\t\\t\\t\\t'name': track.name,\\n\\t\\t\\t\\t\\t'times': AnimationUtils.convertArray( track.times, Array ),\\n\\t\\t\\t\\t\\t'values': AnimationUtils.convertArray( track.values, Array )\\n\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\tvar interpolation = track.getInterpolation();\\n\\n\\t\\t\\t\\tif ( interpolation !== track.DefaultInterpolation ) {\\n\\n\\t\\t\\t\\t\\tjson.interpolation = interpolation;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tjson.type = track.ValueTypeName; // mandatory\\n\\n\\t\\t\\treturn json;\\n\\n\\t\\t},\\n\\n\\t\\t_getTrackTypeForValueTypeName: function ( typeName ) {\\n\\n\\t\\t\\tswitch ( typeName.toLowerCase() ) {\\n\\n\\t\\t\\t\\tcase 'scalar':\\n\\t\\t\\t\\tcase 'double':\\n\\t\\t\\t\\tcase 'float':\\n\\t\\t\\t\\tcase 'number':\\n\\t\\t\\t\\tcase 'integer':\\n\\n\\t\\t\\t\\t\\treturn NumberKeyframeTrack;\\n\\n\\t\\t\\t\\tcase 'vector':\\n\\t\\t\\t\\tcase 'vector2':\\n\\t\\t\\t\\tcase 'vector3':\\n\\t\\t\\t\\tcase 'vector4':\\n\\n\\t\\t\\t\\t\\treturn VectorKeyframeTrack;\\n\\n\\t\\t\\t\\tcase 'color':\\n\\n\\t\\t\\t\\t\\treturn ColorKeyframeTrack;\\n\\n\\t\\t\\t\\tcase 'quaternion':\\n\\n\\t\\t\\t\\t\\treturn QuaternionKeyframeTrack;\\n\\n\\t\\t\\t\\tcase 'bool':\\n\\t\\t\\t\\tcase 'boolean':\\n\\n\\t\\t\\t\\t\\treturn BooleanKeyframeTrack;\\n\\n\\t\\t\\t\\tcase 'string':\\n\\n\\t\\t\\t\\t\\treturn StringKeyframeTrack;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthrow new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( KeyframeTrack.prototype, {\\n\\n\\t\\tconstructor: KeyframeTrack,\\n\\n\\t\\tTimeBufferType: Float32Array,\\n\\n\\t\\tValueBufferType: Float32Array,\\n\\n\\t\\tDefaultInterpolation: InterpolateLinear,\\n\\n\\t\\tInterpolantFactoryMethodDiscrete: function ( result ) {\\n\\n\\t\\t\\treturn new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );\\n\\n\\t\\t},\\n\\n\\t\\tInterpolantFactoryMethodLinear: function ( result ) {\\n\\n\\t\\t\\treturn new LinearInterpolant( this.times, this.values, this.getValueSize(), result );\\n\\n\\t\\t},\\n\\n\\t\\tInterpolantFactoryMethodSmooth: function ( result ) {\\n\\n\\t\\t\\treturn new CubicInterpolant( this.times, this.values, this.getValueSize(), result );\\n\\n\\t\\t},\\n\\n\\t\\tsetInterpolation: function ( interpolation ) {\\n\\n\\t\\t\\tvar factoryMethod;\\n\\n\\t\\t\\tswitch ( interpolation ) {\\n\\n\\t\\t\\t\\tcase InterpolateDiscrete:\\n\\n\\t\\t\\t\\t\\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase InterpolateLinear:\\n\\n\\t\\t\\t\\t\\tfactoryMethod = this.InterpolantFactoryMethodLinear;\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase InterpolateSmooth:\\n\\n\\t\\t\\t\\t\\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( factoryMethod === undefined ) {\\n\\n\\t\\t\\t\\tvar message = \\\"unsupported interpolation for \\\" +\\n\\t\\t\\t\\t\\tthis.ValueTypeName + \\\" keyframe track named \\\" + this.name;\\n\\n\\t\\t\\t\\tif ( this.createInterpolant === undefined ) {\\n\\n\\t\\t\\t\\t\\t// fall back to default, unless the default itself is messed up\\n\\t\\t\\t\\t\\tif ( interpolation !== this.DefaultInterpolation ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.setInterpolation( this.DefaultInterpolation );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tthrow new Error( message ); // fatal, in this case\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.KeyframeTrack:', message );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.createInterpolant = factoryMethod;\\n\\n\\t\\t},\\n\\n\\t\\tgetInterpolation: function () {\\n\\n\\t\\t\\tswitch ( this.createInterpolant ) {\\n\\n\\t\\t\\t\\tcase this.InterpolantFactoryMethodDiscrete:\\n\\n\\t\\t\\t\\t\\treturn InterpolateDiscrete;\\n\\n\\t\\t\\t\\tcase this.InterpolantFactoryMethodLinear:\\n\\n\\t\\t\\t\\t\\treturn InterpolateLinear;\\n\\n\\t\\t\\t\\tcase this.InterpolantFactoryMethodSmooth:\\n\\n\\t\\t\\t\\t\\treturn InterpolateSmooth;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tgetValueSize: function () {\\n\\n\\t\\t\\treturn this.values.length / this.times.length;\\n\\n\\t\\t},\\n\\n\\t\\t// move all keyframes either forwards or backwards in time\\n\\t\\tshift: function ( timeOffset ) {\\n\\n\\t\\t\\tif ( timeOffset !== 0.0 ) {\\n\\n\\t\\t\\t\\tvar times = this.times;\\n\\n\\t\\t\\t\\tfor ( var i = 0, n = times.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\ttimes[ i ] += timeOffset;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\\n\\t\\tscale: function ( timeScale ) {\\n\\n\\t\\t\\tif ( timeScale !== 1.0 ) {\\n\\n\\t\\t\\t\\tvar times = this.times;\\n\\n\\t\\t\\t\\tfor ( var i = 0, n = times.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\ttimes[ i ] *= timeScale;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\\n\\t\\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\\n\\t\\ttrim: function ( startTime, endTime ) {\\n\\n\\t\\t\\tvar times = this.times,\\n\\t\\t\\t\\tnKeys = times.length,\\n\\t\\t\\t\\tfrom = 0,\\n\\t\\t\\t\\tto = nKeys - 1;\\n\\n\\t\\t\\twhile ( from !== nKeys && times[ from ] < startTime ) {\\n\\n\\t\\t\\t\\t++ from;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile ( to !== - 1 && times[ to ] > endTime ) {\\n\\n\\t\\t\\t\\t-- to;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t++ to; // inclusive -> exclusive bound\\n\\n\\t\\t\\tif ( from !== 0 || to !== nKeys ) {\\n\\n\\t\\t\\t\\t// empty tracks are forbidden, so keep at least one keyframe\\n\\t\\t\\t\\tif ( from >= to ) to = Math.max( to, 1 ), from = to - 1;\\n\\n\\t\\t\\t\\tvar stride = this.getValueSize();\\n\\t\\t\\t\\tthis.times = AnimationUtils.arraySlice( times, from, to );\\n\\t\\t\\t\\tthis.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\\n\\t\\tvalidate: function () {\\n\\n\\t\\t\\tvar valid = true;\\n\\n\\t\\t\\tvar valueSize = this.getValueSize();\\n\\t\\t\\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );\\n\\t\\t\\t\\tvalid = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar times = this.times,\\n\\t\\t\\t\\tvalues = this.values,\\n\\n\\t\\t\\t\\tnKeys = times.length;\\n\\n\\t\\t\\tif ( nKeys === 0 ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.KeyframeTrack: Track is empty.', this );\\n\\t\\t\\t\\tvalid = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar prevTime = null;\\n\\n\\t\\t\\tfor ( var i = 0; i !== nKeys; i ++ ) {\\n\\n\\t\\t\\t\\tvar currTime = times[ i ];\\n\\n\\t\\t\\t\\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\\n\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );\\n\\t\\t\\t\\t\\tvalid = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( prevTime !== null && prevTime > currTime ) {\\n\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );\\n\\t\\t\\t\\t\\tvalid = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tprevTime = currTime;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( values !== undefined ) {\\n\\n\\t\\t\\t\\tif ( AnimationUtils.isTypedArray( values ) ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\t\\tvar value = values[ i ];\\n\\n\\t\\t\\t\\t\\t\\tif ( isNaN( value ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );\\n\\t\\t\\t\\t\\t\\t\\tvalid = false;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn valid;\\n\\n\\t\\t},\\n\\n\\t\\t// removes equivalent sequential keys as common in morph target sequences\\n\\t\\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\\n\\t\\toptimize: function () {\\n\\n\\t\\t\\tvar times = this.times,\\n\\t\\t\\t\\tvalues = this.values,\\n\\t\\t\\t\\tstride = this.getValueSize(),\\n\\n\\t\\t\\t\\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\\n\\n\\t\\t\\t\\twriteIndex = 1,\\n\\t\\t\\t\\tlastIndex = times.length - 1;\\n\\n\\t\\t\\tfor ( var i = 1; i < lastIndex; ++ i ) {\\n\\n\\t\\t\\t\\tvar keep = false;\\n\\n\\t\\t\\t\\tvar time = times[ i ];\\n\\t\\t\\t\\tvar timeNext = times[ i + 1 ];\\n\\n\\t\\t\\t\\t// remove adjacent keyframes scheduled at the same time\\n\\n\\t\\t\\t\\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\\n\\n\\t\\t\\t\\t\\tif ( ! smoothInterpolation ) {\\n\\n\\t\\t\\t\\t\\t\\t// remove unnecessary keyframes same as their neighbors\\n\\n\\t\\t\\t\\t\\t\\tvar offset = i * stride,\\n\\t\\t\\t\\t\\t\\t\\toffsetP = offset - stride,\\n\\t\\t\\t\\t\\t\\t\\toffsetN = offset + stride;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var j = 0; j !== stride; ++ j ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar value = values[ offset + j ];\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( value !== values[ offsetP + j ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\tvalue !== values[ offsetN + j ] ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tkeep = true;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tkeep = true;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// in-place compaction\\n\\n\\t\\t\\t\\tif ( keep ) {\\n\\n\\t\\t\\t\\t\\tif ( i !== writeIndex ) {\\n\\n\\t\\t\\t\\t\\t\\ttimes[ writeIndex ] = times[ i ];\\n\\n\\t\\t\\t\\t\\t\\tvar readOffset = i * stride,\\n\\t\\t\\t\\t\\t\\t\\twriteOffset = writeIndex * stride;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var j = 0; j !== stride; ++ j ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvalues[ writeOffset + j ] = values[ readOffset + j ];\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t++ writeIndex;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// flush last keyframe (compaction looks ahead)\\n\\n\\t\\t\\tif ( lastIndex > 0 ) {\\n\\n\\t\\t\\t\\ttimes[ writeIndex ] = times[ lastIndex ];\\n\\n\\t\\t\\t\\tfor ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {\\n\\n\\t\\t\\t\\t\\tvalues[ writeOffset + j ] = values[ readOffset + j ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t++ writeIndex;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( writeIndex !== times.length ) {\\n\\n\\t\\t\\t\\tthis.times = AnimationUtils.arraySlice( times, 0, writeIndex );\\n\\t\\t\\t\\tthis.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * A Track of vectored keyframe values.\\n\\t *\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction VectorKeyframeTrack( name, times, values, interpolation ) {\\n\\n\\t\\tKeyframeTrack.call( this, name, times, values, interpolation );\\n\\n\\t}\\n\\n\\tVectorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\n\\n\\t\\tconstructor: VectorKeyframeTrack,\\n\\n\\t\\tValueTypeName: 'vector'\\n\\n\\t\\t// ValueBufferType is inherited\\n\\n\\t\\t// DefaultInterpolation is inherited\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * Reusable set of Tracks that represent an animation.\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t */\\n\\n\\tfunction AnimationClip( name, duration, tracks ) {\\n\\n\\t\\tthis.name = name;\\n\\t\\tthis.tracks = tracks;\\n\\t\\tthis.duration = ( duration !== undefined ) ? duration : - 1;\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\t// this means it should figure out its duration by scanning the tracks\\n\\t\\tif ( this.duration < 0 ) {\\n\\n\\t\\t\\tthis.resetDuration();\\n\\n\\t\\t}\\n\\n\\t\\tthis.optimize();\\n\\n\\t}\\n\\n\\tObject.assign( AnimationClip, {\\n\\n\\t\\tparse: function ( json ) {\\n\\n\\t\\t\\tvar tracks = [],\\n\\t\\t\\t\\tjsonTracks = json.tracks,\\n\\t\\t\\t\\tframeTime = 1.0 / ( json.fps || 1.0 );\\n\\n\\t\\t\\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\ttracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn new AnimationClip( json.name, json.duration, tracks );\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( clip ) {\\n\\n\\t\\t\\tvar tracks = [],\\n\\t\\t\\t\\tclipTracks = clip.tracks;\\n\\n\\t\\t\\tvar json = {\\n\\n\\t\\t\\t\\t'name': clip.name,\\n\\t\\t\\t\\t'duration': clip.duration,\\n\\t\\t\\t\\t'tracks': tracks\\n\\n\\t\\t\\t};\\n\\n\\t\\t\\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn json;\\n\\n\\t\\t},\\n\\n\\t\\tCreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {\\n\\n\\t\\t\\tvar numMorphTargets = morphTargetSequence.length;\\n\\t\\t\\tvar tracks = [];\\n\\n\\t\\t\\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\\n\\n\\t\\t\\t\\tvar times = [];\\n\\t\\t\\t\\tvar values = [];\\n\\n\\t\\t\\t\\ttimes.push(\\n\\t\\t\\t\\t\\t( i + numMorphTargets - 1 ) % numMorphTargets,\\n\\t\\t\\t\\t\\ti,\\n\\t\\t\\t\\t\\t( i + 1 ) % numMorphTargets );\\n\\n\\t\\t\\t\\tvalues.push( 0, 1, 0 );\\n\\n\\t\\t\\t\\tvar order = AnimationUtils.getKeyframeOrder( times );\\n\\t\\t\\t\\ttimes = AnimationUtils.sortedArray( times, 1, order );\\n\\t\\t\\t\\tvalues = AnimationUtils.sortedArray( values, 1, order );\\n\\n\\t\\t\\t\\t// if there is a key at the first frame, duplicate it as the\\n\\t\\t\\t\\t// last frame as well for perfect loop.\\n\\t\\t\\t\\tif ( ! noLoop && times[ 0 ] === 0 ) {\\n\\n\\t\\t\\t\\t\\ttimes.push( numMorphTargets );\\n\\t\\t\\t\\t\\tvalues.push( values[ 0 ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttracks.push(\\n\\t\\t\\t\\t\\tnew NumberKeyframeTrack(\\n\\t\\t\\t\\t\\t\\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\\n\\t\\t\\t\\t\\t\\ttimes, values\\n\\t\\t\\t\\t\\t).scale( 1.0 / fps ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn new AnimationClip( name, - 1, tracks );\\n\\n\\t\\t},\\n\\n\\t\\tfindByName: function ( objectOrClipArray, name ) {\\n\\n\\t\\t\\tvar clipArray = objectOrClipArray;\\n\\n\\t\\t\\tif ( ! Array.isArray( objectOrClipArray ) ) {\\n\\n\\t\\t\\t\\tvar o = objectOrClipArray;\\n\\t\\t\\t\\tclipArray = o.geometry && o.geometry.animations || o.animations;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var i = 0; i < clipArray.length; i ++ ) {\\n\\n\\t\\t\\t\\tif ( clipArray[ i ].name === name ) {\\n\\n\\t\\t\\t\\t\\treturn clipArray[ i ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn null;\\n\\n\\t\\t},\\n\\n\\t\\tCreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {\\n\\n\\t\\t\\tvar animationToMorphTargets = {};\\n\\n\\t\\t\\t// tested with https://regex101.com/ on trick sequences\\n\\t\\t\\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\\n\\t\\t\\tvar pattern = /^([\\\\w-]*?)([\\\\d]+)$/;\\n\\n\\t\\t\\t// sort morph target names into animation groups based\\n\\t\\t\\t// patterns like Walk_001, Walk_002, Run_001, Run_002\\n\\t\\t\\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar morphTarget = morphTargets[ i ];\\n\\t\\t\\t\\tvar parts = morphTarget.name.match( pattern );\\n\\n\\t\\t\\t\\tif ( parts && parts.length > 1 ) {\\n\\n\\t\\t\\t\\t\\tvar name = parts[ 1 ];\\n\\n\\t\\t\\t\\t\\tvar animationMorphTargets = animationToMorphTargets[ name ];\\n\\t\\t\\t\\t\\tif ( ! animationMorphTargets ) {\\n\\n\\t\\t\\t\\t\\t\\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tanimationMorphTargets.push( morphTarget );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar clips = [];\\n\\n\\t\\t\\tfor ( var name in animationToMorphTargets ) {\\n\\n\\t\\t\\t\\tclips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn clips;\\n\\n\\t\\t},\\n\\n\\t\\t// parse the animation.hierarchy format\\n\\t\\tparseAnimation: function ( animation, bones ) {\\n\\n\\t\\t\\tif ( ! animation ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );\\n\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {\\n\\n\\t\\t\\t\\t// only return track if there are actually keys.\\n\\t\\t\\t\\tif ( animationKeys.length !== 0 ) {\\n\\n\\t\\t\\t\\t\\tvar times = [];\\n\\t\\t\\t\\t\\tvar values = [];\\n\\n\\t\\t\\t\\t\\tAnimationUtils.flattenJSON( animationKeys, times, values, propertyName );\\n\\n\\t\\t\\t\\t\\t// empty keys are filtered out, so check again\\n\\t\\t\\t\\t\\tif ( times.length !== 0 ) {\\n\\n\\t\\t\\t\\t\\t\\tdestTracks.push( new trackType( trackName, times, values ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t\\tvar tracks = [];\\n\\n\\t\\t\\tvar clipName = animation.name || 'default';\\n\\t\\t\\t// automatic length determination in AnimationClip.\\n\\t\\t\\tvar duration = animation.length || - 1;\\n\\t\\t\\tvar fps = animation.fps || 30;\\n\\n\\t\\t\\tvar hierarchyTracks = animation.hierarchy || [];\\n\\n\\t\\t\\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\\n\\n\\t\\t\\t\\tvar animationKeys = hierarchyTracks[ h ].keys;\\n\\n\\t\\t\\t\\t// skip empty tracks\\n\\t\\t\\t\\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\\n\\n\\t\\t\\t\\t// process morph targets\\n\\t\\t\\t\\tif ( animationKeys[ 0 ].morphTargets ) {\\n\\n\\t\\t\\t\\t\\t// figure out all morph targets used in this track\\n\\t\\t\\t\\t\\tvar morphTargetNames = {};\\n\\n\\t\\t\\t\\t\\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( animationKeys[ k ].morphTargets ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tmorphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// create a track for each morph target with all zero\\n\\t\\t\\t\\t\\t// morphTargetInfluences except for the keys in which\\n\\t\\t\\t\\t\\t// the morphTarget is named.\\n\\t\\t\\t\\t\\tfor ( var morphTargetName in morphTargetNames ) {\\n\\n\\t\\t\\t\\t\\t\\tvar times = [];\\n\\t\\t\\t\\t\\t\\tvar values = [];\\n\\n\\t\\t\\t\\t\\t\\tfor ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar animationKey = animationKeys[ k ];\\n\\n\\t\\t\\t\\t\\t\\t\\ttimes.push( animationKey.time );\\n\\t\\t\\t\\t\\t\\t\\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\ttracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tduration = morphTargetNames.length * ( fps || 1.0 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// ...assume skeletal animation\\n\\n\\t\\t\\t\\t\\tvar boneName = '.bones[' + bones[ h ].name + ']';\\n\\n\\t\\t\\t\\t\\taddNonemptyTrack(\\n\\t\\t\\t\\t\\t\\tVectorKeyframeTrack, boneName + '.position',\\n\\t\\t\\t\\t\\t\\tanimationKeys, 'pos', tracks );\\n\\n\\t\\t\\t\\t\\taddNonemptyTrack(\\n\\t\\t\\t\\t\\t\\tQuaternionKeyframeTrack, boneName + '.quaternion',\\n\\t\\t\\t\\t\\t\\tanimationKeys, 'rot', tracks );\\n\\n\\t\\t\\t\\t\\taddNonemptyTrack(\\n\\t\\t\\t\\t\\t\\tVectorKeyframeTrack, boneName + '.scale',\\n\\t\\t\\t\\t\\t\\tanimationKeys, 'scl', tracks );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( tracks.length === 0 ) {\\n\\n\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar clip = new AnimationClip( clipName, duration, tracks );\\n\\n\\t\\t\\treturn clip;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( AnimationClip.prototype, {\\n\\n\\t\\tresetDuration: function () {\\n\\n\\t\\t\\tvar tracks = this.tracks, duration = 0;\\n\\n\\t\\t\\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\tvar track = this.tracks[ i ];\\n\\n\\t\\t\\t\\tduration = Math.max( duration, track.times[ track.times.length - 1 ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.duration = duration;\\n\\n\\t\\t},\\n\\n\\t\\ttrim: function () {\\n\\n\\t\\t\\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\\n\\n\\t\\t\\t\\tthis.tracks[ i ].trim( 0, this.duration );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\toptimize: function () {\\n\\n\\t\\t\\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\\n\\n\\t\\t\\t\\tthis.tracks[ i ].optimize();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction MaterialLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\t\\tthis.textures = {};\\n\\n\\t}\\n\\n\\tObject.assign( MaterialLoader.prototype, {\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar loader = new FileLoader( scope.manager );\\n\\t\\t\\tloader.load( url, function ( text ) {\\n\\n\\t\\t\\t\\tonLoad( scope.parse( JSON.parse( text ) ) );\\n\\n\\t\\t\\t}, onProgress, onError );\\n\\n\\t\\t},\\n\\n\\t\\tsetTextures: function ( value ) {\\n\\n\\t\\t\\tthis.textures = value;\\n\\n\\t\\t},\\n\\n\\t\\tparse: function ( json ) {\\n\\n\\t\\t\\tvar textures = this.textures;\\n\\n\\t\\t\\tfunction getTexture( name ) {\\n\\n\\t\\t\\t\\tif ( textures[ name ] === undefined ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn textures[ name ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar material = new Materials[ json.type ]();\\n\\n\\t\\t\\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\\n\\t\\t\\tif ( json.name !== undefined ) material.name = json.name;\\n\\t\\t\\tif ( json.color !== undefined ) material.color.setHex( json.color );\\n\\t\\t\\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\\n\\t\\t\\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\\n\\t\\t\\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\\n\\t\\t\\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\\n\\t\\t\\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\\n\\t\\t\\tif ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;\\n\\t\\t\\tif ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;\\n\\t\\t\\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\\n\\t\\t\\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\\n\\t\\t\\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\\n\\t\\t\\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\\n\\t\\t\\tif ( json.fog !== undefined ) material.fog = json.fog;\\n\\t\\t\\tif ( json.flatShading !== undefined ) material.flatShading = json.flatShading;\\n\\t\\t\\tif ( json.blending !== undefined ) material.blending = json.blending;\\n\\t\\t\\tif ( json.side !== undefined ) material.side = json.side;\\n\\t\\t\\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\\n\\t\\t\\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\\n\\t\\t\\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\\n\\t\\t\\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\\n\\t\\t\\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\\n\\t\\t\\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\\n\\t\\t\\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\\n\\t\\t\\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\\n\\t\\t\\tif ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;\\n\\t\\t\\tif ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;\\n\\n\\t\\t\\tif ( json.rotation !== undefined ) material.rotation = json.rotation;\\n\\n\\t\\t\\tif ( json.linewidth !== 1 ) material.linewidth = json.linewidth;\\n\\t\\t\\tif ( json.dashSize !== undefined ) material.dashSize = json.dashSize;\\n\\t\\t\\tif ( json.gapSize !== undefined ) material.gapSize = json.gapSize;\\n\\t\\t\\tif ( json.scale !== undefined ) material.scale = json.scale;\\n\\n\\t\\t\\tif ( json.skinning !== undefined ) material.skinning = json.skinning;\\n\\t\\t\\tif ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;\\n\\t\\t\\tif ( json.dithering !== undefined ) material.dithering = json.dithering;\\n\\n\\t\\t\\tif ( json.visible !== undefined ) material.visible = json.visible;\\n\\t\\t\\tif ( json.userData !== undefined ) material.userData = json.userData;\\n\\n\\t\\t\\t// Deprecated\\n\\n\\t\\t\\tif ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading\\n\\n\\t\\t\\t// for PointsMaterial\\n\\n\\t\\t\\tif ( json.size !== undefined ) material.size = json.size;\\n\\t\\t\\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\\n\\n\\t\\t\\t// maps\\n\\n\\t\\t\\tif ( json.map !== undefined ) material.map = getTexture( json.map );\\n\\n\\t\\t\\tif ( json.alphaMap !== undefined ) {\\n\\n\\t\\t\\t\\tmaterial.alphaMap = getTexture( json.alphaMap );\\n\\t\\t\\t\\tmaterial.transparent = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );\\n\\t\\t\\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\\n\\n\\t\\t\\tif ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );\\n\\t\\t\\tif ( json.normalScale !== undefined ) {\\n\\n\\t\\t\\t\\tvar normalScale = json.normalScale;\\n\\n\\t\\t\\t\\tif ( Array.isArray( normalScale ) === false ) {\\n\\n\\t\\t\\t\\t\\t// Blender exporter used to export a scalar. See #7459\\n\\n\\t\\t\\t\\t\\tnormalScale = [ normalScale, normalScale ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tmaterial.normalScale = new Vector2().fromArray( normalScale );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );\\n\\t\\t\\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\\n\\t\\t\\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\\n\\n\\t\\t\\tif ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );\\n\\t\\t\\tif ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );\\n\\n\\t\\t\\tif ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );\\n\\t\\t\\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\\n\\n\\t\\t\\tif ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );\\n\\n\\t\\t\\tif ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );\\n\\n\\t\\t\\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\\n\\n\\t\\t\\tif ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );\\n\\t\\t\\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\\n\\n\\t\\t\\tif ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );\\n\\t\\t\\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\\n\\n\\t\\t\\tif ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );\\n\\n\\t\\t\\treturn material;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction BufferGeometryLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t}\\n\\n\\tObject.assign( BufferGeometryLoader.prototype, {\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar loader = new FileLoader( scope.manager );\\n\\t\\t\\tloader.load( url, function ( text ) {\\n\\n\\t\\t\\t\\tonLoad( scope.parse( JSON.parse( text ) ) );\\n\\n\\t\\t\\t}, onProgress, onError );\\n\\n\\t\\t},\\n\\n\\t\\tparse: function ( json ) {\\n\\n\\t\\t\\tvar geometry = new BufferGeometry();\\n\\n\\t\\t\\tvar index = json.data.index;\\n\\n\\t\\t\\tif ( index !== undefined ) {\\n\\n\\t\\t\\t\\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\\n\\t\\t\\t\\tgeometry.setIndex( new BufferAttribute( typedArray, 1 ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar attributes = json.data.attributes;\\n\\n\\t\\t\\tfor ( var key in attributes ) {\\n\\n\\t\\t\\t\\tvar attribute = attributes[ key ];\\n\\t\\t\\t\\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\\n\\n\\t\\t\\t\\tgeometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\\n\\n\\t\\t\\tif ( groups !== undefined ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\tvar group = groups[ i ];\\n\\n\\t\\t\\t\\t\\tgeometry.addGroup( group.start, group.count, group.materialIndex );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar boundingSphere = json.data.boundingSphere;\\n\\n\\t\\t\\tif ( boundingSphere !== undefined ) {\\n\\n\\t\\t\\t\\tvar center = new Vector3();\\n\\n\\t\\t\\t\\tif ( boundingSphere.center !== undefined ) {\\n\\n\\t\\t\\t\\t\\tcenter.fromArray( boundingSphere.center );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgeometry.boundingSphere = new Sphere( center, boundingSphere.radius );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn geometry;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tvar TYPED_ARRAYS = {\\n\\t\\tInt8Array: Int8Array,\\n\\t\\tUint8Array: Uint8Array,\\n\\t\\t// Workaround for IE11 pre KB2929437. See #11440\\n\\t\\tUint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,\\n\\t\\tInt16Array: Int16Array,\\n\\t\\tUint16Array: Uint16Array,\\n\\t\\tInt32Array: Int32Array,\\n\\t\\tUint32Array: Uint32Array,\\n\\t\\tFloat32Array: Float32Array,\\n\\t\\tFloat64Array: Float64Array\\n\\t};\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction Loader() {\\n\\n\\t\\tthis.onLoadStart = function () {};\\n\\t\\tthis.onLoadProgress = function () {};\\n\\t\\tthis.onLoadComplete = function () {};\\n\\n\\t}\\n\\n\\tLoader.Handlers = {\\n\\n\\t\\thandlers: [],\\n\\n\\t\\tadd: function ( regex, loader ) {\\n\\n\\t\\t\\tthis.handlers.push( regex, loader );\\n\\n\\t\\t},\\n\\n\\t\\tget: function ( file ) {\\n\\n\\t\\t\\tvar handlers = this.handlers;\\n\\n\\t\\t\\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\\n\\n\\t\\t\\t\\tvar regex = handlers[ i ];\\n\\t\\t\\t\\tvar loader = handlers[ i + 1 ];\\n\\n\\t\\t\\t\\tif ( regex.test( file ) ) {\\n\\n\\t\\t\\t\\t\\treturn loader;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn null;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tObject.assign( Loader.prototype, {\\n\\n\\t\\tcrossOrigin: undefined,\\n\\n\\t\\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\\n\\n\\t\\t\\tvar array = [];\\n\\n\\t\\t\\tfor ( var i = 0; i < materials.length; ++ i ) {\\n\\n\\t\\t\\t\\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn array;\\n\\n\\t\\t},\\n\\n\\t\\tcreateMaterial: ( function () {\\n\\n\\t\\t\\tvar BlendingMode = {\\n\\t\\t\\t\\tNoBlending: NoBlending,\\n\\t\\t\\t\\tNormalBlending: NormalBlending,\\n\\t\\t\\t\\tAdditiveBlending: AdditiveBlending,\\n\\t\\t\\t\\tSubtractiveBlending: SubtractiveBlending,\\n\\t\\t\\t\\tMultiplyBlending: MultiplyBlending,\\n\\t\\t\\t\\tCustomBlending: CustomBlending\\n\\t\\t\\t};\\n\\n\\t\\t\\tvar color = new Color();\\n\\t\\t\\tvar textureLoader = new TextureLoader();\\n\\t\\t\\tvar materialLoader = new MaterialLoader();\\n\\n\\t\\t\\treturn function createMaterial( m, texturePath, crossOrigin ) {\\n\\n\\t\\t\\t\\t// convert from old material format\\n\\n\\t\\t\\t\\tvar textures = {};\\n\\n\\t\\t\\t\\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\\n\\n\\t\\t\\t\\t\\tvar fullPath = texturePath + path;\\n\\t\\t\\t\\t\\tvar loader = Loader.Handlers.get( fullPath );\\n\\n\\t\\t\\t\\t\\tvar texture;\\n\\n\\t\\t\\t\\t\\tif ( loader !== null ) {\\n\\n\\t\\t\\t\\t\\t\\ttexture = loader.load( fullPath );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\ttextureLoader.setCrossOrigin( crossOrigin );\\n\\t\\t\\t\\t\\t\\ttexture = textureLoader.load( fullPath );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( repeat !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\ttexture.repeat.fromArray( repeat );\\n\\n\\t\\t\\t\\t\\t\\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;\\n\\t\\t\\t\\t\\t\\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( offset !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\ttexture.offset.fromArray( offset );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( wrap !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;\\n\\t\\t\\t\\t\\t\\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;\\n\\n\\t\\t\\t\\t\\t\\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;\\n\\t\\t\\t\\t\\t\\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( anisotropy !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\ttexture.anisotropy = anisotropy;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvar uuid = _Math.generateUUID();\\n\\n\\t\\t\\t\\t\\ttextures[ uuid ] = texture;\\n\\n\\t\\t\\t\\t\\treturn uuid;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t//\\n\\n\\t\\t\\t\\tvar json = {\\n\\t\\t\\t\\t\\tuuid: _Math.generateUUID(),\\n\\t\\t\\t\\t\\ttype: 'MeshLambertMaterial'\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\tfor ( var name in m ) {\\n\\n\\t\\t\\t\\t\\tvar value = m[ name ];\\n\\n\\t\\t\\t\\t\\tswitch ( name ) {\\n\\n\\t\\t\\t\\t\\t\\tcase 'DbgColor':\\n\\t\\t\\t\\t\\t\\tcase 'DbgIndex':\\n\\t\\t\\t\\t\\t\\tcase 'opticalDensity':\\n\\t\\t\\t\\t\\t\\tcase 'illumination':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'DbgName':\\n\\t\\t\\t\\t\\t\\t\\tjson.name = value;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'blending':\\n\\t\\t\\t\\t\\t\\t\\tjson.blending = BlendingMode[ value ];\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'colorAmbient':\\n\\t\\t\\t\\t\\t\\tcase 'mapAmbient':\\n\\t\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'colorDiffuse':\\n\\t\\t\\t\\t\\t\\t\\tjson.color = color.fromArray( value ).getHex();\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'colorSpecular':\\n\\t\\t\\t\\t\\t\\t\\tjson.specular = color.fromArray( value ).getHex();\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'colorEmissive':\\n\\t\\t\\t\\t\\t\\t\\tjson.emissive = color.fromArray( value ).getHex();\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'specularCoef':\\n\\t\\t\\t\\t\\t\\t\\tjson.shininess = value;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'shading':\\n\\t\\t\\t\\t\\t\\t\\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\\n\\t\\t\\t\\t\\t\\t\\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\\n\\t\\t\\t\\t\\t\\t\\tif ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapDiffuse':\\n\\t\\t\\t\\t\\t\\t\\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapDiffuseRepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapDiffuseOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapDiffuseWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapDiffuseAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapEmissive':\\n\\t\\t\\t\\t\\t\\t\\tjson.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapEmissiveRepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapEmissiveOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapEmissiveWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapEmissiveAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapLight':\\n\\t\\t\\t\\t\\t\\t\\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapLightRepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapLightOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapLightWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapLightAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapAO':\\n\\t\\t\\t\\t\\t\\t\\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapAORepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapAOOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapAOWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapAOAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapBump':\\n\\t\\t\\t\\t\\t\\t\\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapBumpScale':\\n\\t\\t\\t\\t\\t\\t\\tjson.bumpScale = value;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapBumpRepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapBumpOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapBumpWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapBumpAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapNormal':\\n\\t\\t\\t\\t\\t\\t\\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapNormalFactor':\\n\\t\\t\\t\\t\\t\\t\\tjson.normalScale = [ value, value ];\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapNormalRepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapNormalOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapNormalWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapNormalAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapSpecular':\\n\\t\\t\\t\\t\\t\\t\\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapSpecularRepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapSpecularOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapSpecularWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapSpecularAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapMetalness':\\n\\t\\t\\t\\t\\t\\t\\tjson.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapMetalnessRepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapMetalnessOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapMetalnessWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapMetalnessAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapRoughness':\\n\\t\\t\\t\\t\\t\\t\\tjson.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapRoughnessRepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapRoughnessOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapRoughnessWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapRoughnessAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapAlpha':\\n\\t\\t\\t\\t\\t\\t\\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapAlphaRepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapAlphaOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapAlphaWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapAlphaAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'flipSided':\\n\\t\\t\\t\\t\\t\\t\\tjson.side = BackSide;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'doubleSided':\\n\\t\\t\\t\\t\\t\\t\\tjson.side = DoubleSide;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'transparency':\\n\\t\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\\n\\t\\t\\t\\t\\t\\t\\tjson.opacity = value;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'depthTest':\\n\\t\\t\\t\\t\\t\\tcase 'depthWrite':\\n\\t\\t\\t\\t\\t\\tcase 'colorWrite':\\n\\t\\t\\t\\t\\t\\tcase 'opacity':\\n\\t\\t\\t\\t\\t\\tcase 'reflectivity':\\n\\t\\t\\t\\t\\t\\tcase 'transparent':\\n\\t\\t\\t\\t\\t\\tcase 'visible':\\n\\t\\t\\t\\t\\t\\tcase 'wireframe':\\n\\t\\t\\t\\t\\t\\t\\tjson[ name ] = value;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'vertexColors':\\n\\t\\t\\t\\t\\t\\t\\tif ( value === true ) json.vertexColors = VertexColors;\\n\\t\\t\\t\\t\\t\\t\\tif ( value === 'face' ) json.vertexColors = FaceColors;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\\n\\t\\t\\t\\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\\n\\n\\t\\t\\t\\tif ( json.opacity < 1 ) json.transparent = true;\\n\\n\\t\\t\\t\\tmaterialLoader.setTextures( textures );\\n\\n\\t\\t\\t\\treturn materialLoader.parse( json );\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )()\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author Don McCurdy / https://www.donmccurdy.com\\n\\t */\\n\\n\\tvar LoaderUtils = {\\n\\n\\t\\tdecodeText: function ( array ) {\\n\\n\\t\\t\\tif ( typeof TextDecoder !== 'undefined' ) {\\n\\n\\t\\t\\t\\treturn new TextDecoder().decode( array );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Avoid the String.fromCharCode.apply(null, array) shortcut, which\\n\\t\\t\\t// throws a \\\"maximum call stack size exceeded\\\" error for large arrays.\\n\\n\\t\\t\\tvar s = '';\\n\\n\\t\\t\\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t// Implicitly assumes little-endian.\\n\\t\\t\\t\\ts += String.fromCharCode( array[ i ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn s;\\n\\n\\t\\t},\\n\\n\\t\\textractUrlBase: function ( url ) {\\n\\n\\t\\t\\tvar parts = url.split( '/' );\\n\\n\\t\\t\\tif ( parts.length === 1 ) return './';\\n\\n\\t\\t\\tparts.pop();\\n\\n\\t\\t\\treturn parts.join( '/' ) + '/';\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction JSONLoader( manager ) {\\n\\n\\t\\tif ( typeof manager === 'boolean' ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\\n\\t\\t\\tmanager = undefined;\\n\\n\\t\\t}\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t\\tthis.withCredentials = false;\\n\\n\\t}\\n\\n\\tObject.assign( JSONLoader.prototype, {\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar texturePath = this.texturePath && ( typeof this.texturePath === 'string' ) ? this.texturePath : LoaderUtils.extractUrlBase( url );\\n\\n\\t\\t\\tvar loader = new FileLoader( this.manager );\\n\\t\\t\\tloader.setWithCredentials( this.withCredentials );\\n\\t\\t\\tloader.load( url, function ( text ) {\\n\\n\\t\\t\\t\\tvar json = JSON.parse( text );\\n\\t\\t\\t\\tvar metadata = json.metadata;\\n\\n\\t\\t\\t\\tif ( metadata !== undefined ) {\\n\\n\\t\\t\\t\\t\\tvar type = metadata.type;\\n\\n\\t\\t\\t\\t\\tif ( type !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( type.toLowerCase() === 'object' ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif ( type.toLowerCase() === 'scene' ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar object = scope.parse( json, texturePath );\\n\\t\\t\\t\\tonLoad( object.geometry, object.materials );\\n\\n\\t\\t\\t}, onProgress, onError );\\n\\n\\t\\t},\\n\\n\\t\\tsetTexturePath: function ( value ) {\\n\\n\\t\\t\\tthis.texturePath = value;\\n\\n\\t\\t},\\n\\n\\t\\tparse: ( function () {\\n\\n\\t\\t\\tfunction parseModel( json, geometry ) {\\n\\n\\t\\t\\t\\tfunction isBitSet( value, position ) {\\n\\n\\t\\t\\t\\t\\treturn value & ( 1 << position );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar i, j, fi,\\n\\n\\t\\t\\t\\t\\toffset, zLength,\\n\\n\\t\\t\\t\\t\\tcolorIndex, normalIndex, uvIndex, materialIndex,\\n\\n\\t\\t\\t\\t\\ttype,\\n\\t\\t\\t\\t\\tisQuad,\\n\\t\\t\\t\\t\\thasMaterial,\\n\\t\\t\\t\\t\\thasFaceVertexUv,\\n\\t\\t\\t\\t\\thasFaceNormal, hasFaceVertexNormal,\\n\\t\\t\\t\\t\\thasFaceColor, hasFaceVertexColor,\\n\\n\\t\\t\\t\\t\\tvertex, face, faceA, faceB, hex, normal,\\n\\n\\t\\t\\t\\t\\tuvLayer, uv, u, v,\\n\\n\\t\\t\\t\\t\\tfaces = json.faces,\\n\\t\\t\\t\\t\\tvertices = json.vertices,\\n\\t\\t\\t\\t\\tnormals = json.normals,\\n\\t\\t\\t\\t\\tcolors = json.colors,\\n\\n\\t\\t\\t\\t\\tscale = json.scale,\\n\\n\\t\\t\\t\\t\\tnUvLayers = 0;\\n\\n\\n\\t\\t\\t\\tif ( json.uvs !== undefined ) {\\n\\n\\t\\t\\t\\t\\t// disregard empty arrays\\n\\n\\t\\t\\t\\t\\tfor ( i = 0; i < json.uvs.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( json.uvs[ i ].length ) nUvLayers ++;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfor ( i = 0; i < nUvLayers; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tgeometry.faceVertexUvs[ i ] = [];\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\toffset = 0;\\n\\t\\t\\t\\tzLength = vertices.length;\\n\\n\\t\\t\\t\\twhile ( offset < zLength ) {\\n\\n\\t\\t\\t\\t\\tvertex = new Vector3();\\n\\n\\t\\t\\t\\t\\tvertex.x = vertices[ offset ++ ] * scale;\\n\\t\\t\\t\\t\\tvertex.y = vertices[ offset ++ ] * scale;\\n\\t\\t\\t\\t\\tvertex.z = vertices[ offset ++ ] * scale;\\n\\n\\t\\t\\t\\t\\tgeometry.vertices.push( vertex );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\toffset = 0;\\n\\t\\t\\t\\tzLength = faces.length;\\n\\n\\t\\t\\t\\twhile ( offset < zLength ) {\\n\\n\\t\\t\\t\\t\\ttype = faces[ offset ++ ];\\n\\n\\t\\t\\t\\t\\tisQuad = isBitSet( type, 0 );\\n\\t\\t\\t\\t\\thasMaterial = isBitSet( type, 1 );\\n\\t\\t\\t\\t\\thasFaceVertexUv = isBitSet( type, 3 );\\n\\t\\t\\t\\t\\thasFaceNormal = isBitSet( type, 4 );\\n\\t\\t\\t\\t\\thasFaceVertexNormal = isBitSet( type, 5 );\\n\\t\\t\\t\\t\\thasFaceColor = isBitSet( type, 6 );\\n\\t\\t\\t\\t\\thasFaceVertexColor = isBitSet( type, 7 );\\n\\n\\t\\t\\t\\t\\t// console.log(\\\"type\\\", type, \\\"bits\\\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\\n\\n\\t\\t\\t\\t\\tif ( isQuad ) {\\n\\n\\t\\t\\t\\t\\t\\tfaceA = new Face3();\\n\\t\\t\\t\\t\\t\\tfaceA.a = faces[ offset ];\\n\\t\\t\\t\\t\\t\\tfaceA.b = faces[ offset + 1 ];\\n\\t\\t\\t\\t\\t\\tfaceA.c = faces[ offset + 3 ];\\n\\n\\t\\t\\t\\t\\t\\tfaceB = new Face3();\\n\\t\\t\\t\\t\\t\\tfaceB.a = faces[ offset + 1 ];\\n\\t\\t\\t\\t\\t\\tfaceB.b = faces[ offset + 2 ];\\n\\t\\t\\t\\t\\t\\tfaceB.c = faces[ offset + 3 ];\\n\\n\\t\\t\\t\\t\\t\\toffset += 4;\\n\\n\\t\\t\\t\\t\\t\\tif ( hasMaterial ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tmaterialIndex = faces[ offset ++ ];\\n\\t\\t\\t\\t\\t\\t\\tfaceA.materialIndex = materialIndex;\\n\\t\\t\\t\\t\\t\\t\\tfaceB.materialIndex = materialIndex;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// to get face <=> uv index correspondence\\n\\n\\t\\t\\t\\t\\t\\tfi = geometry.faces.length;\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceVertexUv ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( i = 0; i < nUvLayers; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tuvLayer = json.uvs[ i ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgeometry.faceVertexUvs[ i ][ fi ] = [];\\n\\t\\t\\t\\t\\t\\t\\t\\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tfor ( j = 0; j < 4; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tuvIndex = faces[ offset ++ ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tu = uvLayer[ uvIndex * 2 ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tv = uvLayer[ uvIndex * 2 + 1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tuv = new Vector2( u, v );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceNormal ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tnormalIndex = faces[ offset ++ ] * 3;\\n\\n\\t\\t\\t\\t\\t\\t\\tfaceA.normal.set(\\n\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\n\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\n\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ]\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tfaceB.normal.copy( faceA.normal );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceVertexNormal ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( i = 0; i < 4; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tnormalIndex = faces[ offset ++ ] * 3;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tnormal = new Vector3(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ]\\n\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceColor ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tcolorIndex = faces[ offset ++ ];\\n\\t\\t\\t\\t\\t\\t\\thex = colors[ colorIndex ];\\n\\n\\t\\t\\t\\t\\t\\t\\tfaceA.color.setHex( hex );\\n\\t\\t\\t\\t\\t\\t\\tfaceB.color.setHex( hex );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceVertexColor ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( i = 0; i < 4; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcolorIndex = faces[ offset ++ ];\\n\\t\\t\\t\\t\\t\\t\\t\\thex = colors[ colorIndex ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tgeometry.faces.push( faceA );\\n\\t\\t\\t\\t\\t\\tgeometry.faces.push( faceB );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tface = new Face3();\\n\\t\\t\\t\\t\\t\\tface.a = faces[ offset ++ ];\\n\\t\\t\\t\\t\\t\\tface.b = faces[ offset ++ ];\\n\\t\\t\\t\\t\\t\\tface.c = faces[ offset ++ ];\\n\\n\\t\\t\\t\\t\\t\\tif ( hasMaterial ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tmaterialIndex = faces[ offset ++ ];\\n\\t\\t\\t\\t\\t\\t\\tface.materialIndex = materialIndex;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// to get face <=> uv index correspondence\\n\\n\\t\\t\\t\\t\\t\\tfi = geometry.faces.length;\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceVertexUv ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( i = 0; i < nUvLayers; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tuvLayer = json.uvs[ i ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgeometry.faceVertexUvs[ i ][ fi ] = [];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tfor ( j = 0; j < 3; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tuvIndex = faces[ offset ++ ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tu = uvLayer[ uvIndex * 2 ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tv = uvLayer[ uvIndex * 2 + 1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tuv = new Vector2( u, v );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceNormal ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tnormalIndex = faces[ offset ++ ] * 3;\\n\\n\\t\\t\\t\\t\\t\\t\\tface.normal.set(\\n\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\n\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\n\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ]\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceVertexNormal ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( i = 0; i < 3; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tnormalIndex = faces[ offset ++ ] * 3;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tnormal = new Vector3(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ]\\n\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tface.vertexNormals.push( normal );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceColor ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tcolorIndex = faces[ offset ++ ];\\n\\t\\t\\t\\t\\t\\t\\tface.color.setHex( colors[ colorIndex ] );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceVertexColor ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( i = 0; i < 3; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcolorIndex = faces[ offset ++ ];\\n\\t\\t\\t\\t\\t\\t\\t\\tface.vertexColors.push( new Color( colors[ colorIndex ] ) );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tgeometry.faces.push( face );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction parseSkin( json, geometry ) {\\n\\n\\t\\t\\t\\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\\n\\n\\t\\t\\t\\tif ( json.skinWeights ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\\n\\n\\t\\t\\t\\t\\t\\tvar x = json.skinWeights[ i ];\\n\\t\\t\\t\\t\\t\\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\\n\\t\\t\\t\\t\\t\\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\\n\\t\\t\\t\\t\\t\\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\\n\\n\\t\\t\\t\\t\\t\\tgeometry.skinWeights.push( new Vector4( x, y, z, w ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( json.skinIndices ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\\n\\n\\t\\t\\t\\t\\t\\tvar a = json.skinIndices[ i ];\\n\\t\\t\\t\\t\\t\\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\\n\\t\\t\\t\\t\\t\\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\\n\\t\\t\\t\\t\\t\\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\\n\\n\\t\\t\\t\\t\\t\\tgeometry.skinIndices.push( new Vector4( a, b, c, d ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgeometry.bones = json.bones;\\n\\n\\t\\t\\t\\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\\n\\t\\t\\t\\t\\t\\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction parseMorphing( json, geometry ) {\\n\\n\\t\\t\\t\\tvar scale = json.scale;\\n\\n\\t\\t\\t\\tif ( json.morphTargets !== undefined ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tgeometry.morphTargets[ i ] = {};\\n\\t\\t\\t\\t\\t\\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\\n\\t\\t\\t\\t\\t\\tgeometry.morphTargets[ i ].vertices = [];\\n\\n\\t\\t\\t\\t\\t\\tvar dstVertices = geometry.morphTargets[ i ].vertices;\\n\\t\\t\\t\\t\\t\\tvar srcVertices = json.morphTargets[ i ].vertices;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar vertex = new Vector3();\\n\\t\\t\\t\\t\\t\\t\\tvertex.x = srcVertices[ v ] * scale;\\n\\t\\t\\t\\t\\t\\t\\tvertex.y = srcVertices[ v + 1 ] * scale;\\n\\t\\t\\t\\t\\t\\t\\tvertex.z = srcVertices[ v + 2 ] * scale;\\n\\n\\t\\t\\t\\t\\t\\t\\tdstVertices.push( vertex );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.JSONLoader: \\\"morphColors\\\" no longer supported. Using them as face colors.' );\\n\\n\\t\\t\\t\\t\\tvar faces = geometry.faces;\\n\\t\\t\\t\\t\\tvar morphColors = json.morphColors[ 0 ].colors;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tfaces[ i ].color.fromArray( morphColors, i * 3 );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction parseAnimations( json, geometry ) {\\n\\n\\t\\t\\t\\tvar outputAnimations = [];\\n\\n\\t\\t\\t\\t// parse old style Bone/Hierarchy animations\\n\\t\\t\\t\\tvar animations = [];\\n\\n\\t\\t\\t\\tif ( json.animation !== undefined ) {\\n\\n\\t\\t\\t\\t\\tanimations.push( json.animation );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( json.animations !== undefined ) {\\n\\n\\t\\t\\t\\t\\tif ( json.animations.length ) {\\n\\n\\t\\t\\t\\t\\t\\tanimations = animations.concat( json.animations );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tanimations.push( json.animations );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < animations.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );\\n\\t\\t\\t\\t\\tif ( clip ) outputAnimations.push( clip );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// parse implicit morph animations\\n\\t\\t\\t\\tif ( geometry.morphTargets ) {\\n\\n\\t\\t\\t\\t\\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\\n\\t\\t\\t\\t\\tvar morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\\n\\t\\t\\t\\t\\toutputAnimations = outputAnimations.concat( morphAnimationClips );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn function ( json, texturePath ) {\\n\\n\\t\\t\\t\\tif ( json.data !== undefined ) {\\n\\n\\t\\t\\t\\t\\t// Geometry 4.0 spec\\n\\t\\t\\t\\t\\tjson = json.data;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( json.scale !== undefined ) {\\n\\n\\t\\t\\t\\t\\tjson.scale = 1.0 / json.scale;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tjson.scale = 1.0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar geometry = new Geometry();\\n\\n\\t\\t\\t\\tparseModel( json, geometry );\\n\\t\\t\\t\\tparseSkin( json, geometry );\\n\\t\\t\\t\\tparseMorphing( json, geometry );\\n\\t\\t\\t\\tparseAnimations( json, geometry );\\n\\n\\t\\t\\t\\tgeometry.computeFaceNormals();\\n\\t\\t\\t\\tgeometry.computeBoundingSphere();\\n\\n\\t\\t\\t\\tif ( json.materials === undefined || json.materials.length === 0 ) {\\n\\n\\t\\t\\t\\t\\treturn { geometry: geometry };\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tvar materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\\n\\n\\t\\t\\t\\t\\treturn { geometry: geometry, materials: materials };\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )()\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction ObjectLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\t\\tthis.texturePath = '';\\n\\n\\t}\\n\\n\\tObject.assign( ObjectLoader.prototype, {\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tif ( this.texturePath === '' ) {\\n\\n\\t\\t\\t\\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar loader = new FileLoader( scope.manager );\\n\\t\\t\\tloader.load( url, function ( text ) {\\n\\n\\t\\t\\t\\tvar json = null;\\n\\n\\t\\t\\t\\ttry {\\n\\n\\t\\t\\t\\t\\tjson = JSON.parse( text );\\n\\n\\t\\t\\t\\t} catch ( error ) {\\n\\n\\t\\t\\t\\t\\tif ( onError !== undefined ) onError( error );\\n\\n\\t\\t\\t\\t\\tconsole.error( 'THREE:ObjectLoader: Can\\\\'t parse ' + url + '.', error.message );\\n\\n\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar metadata = json.metadata;\\n\\n\\t\\t\\t\\tif ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\\n\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.ObjectLoader: Can\\\\'t load ' + url + '. Use THREE.JSONLoader instead.' );\\n\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tscope.parse( json, onLoad );\\n\\n\\t\\t\\t}, onProgress, onError );\\n\\n\\t\\t},\\n\\n\\t\\tsetTexturePath: function ( value ) {\\n\\n\\t\\t\\tthis.texturePath = value;\\n\\n\\t\\t},\\n\\n\\t\\tsetCrossOrigin: function ( value ) {\\n\\n\\t\\t\\tthis.crossOrigin = value;\\n\\n\\t\\t},\\n\\n\\t\\tparse: function ( json, onLoad ) {\\n\\n\\t\\t\\tvar shapes = this.parseShape( json.shapes );\\n\\t\\t\\tvar geometries = this.parseGeometries( json.geometries, shapes );\\n\\n\\t\\t\\tvar images = this.parseImages( json.images, function () {\\n\\n\\t\\t\\t\\tif ( onLoad !== undefined ) onLoad( object );\\n\\n\\t\\t\\t} );\\n\\n\\t\\t\\tvar textures = this.parseTextures( json.textures, images );\\n\\t\\t\\tvar materials = this.parseMaterials( json.materials, textures );\\n\\n\\t\\t\\tvar object = this.parseObject( json.object, geometries, materials );\\n\\n\\t\\t\\tif ( json.animations ) {\\n\\n\\t\\t\\t\\tobject.animations = this.parseAnimations( json.animations );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( json.images === undefined || json.images.length === 0 ) {\\n\\n\\t\\t\\t\\tif ( onLoad !== undefined ) onLoad( object );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn object;\\n\\n\\t\\t},\\n\\n\\t\\tparseShape: function ( json ) {\\n\\n\\t\\t\\tvar shapes = {};\\n\\n\\t\\t\\tif ( json !== undefined ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar shape = new Shape().fromJSON( json[ i ] );\\n\\n\\t\\t\\t\\t\\tshapes[ shape.uuid ] = shape;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn shapes;\\n\\n\\t\\t},\\n\\n\\t\\tparseGeometries: function ( json, shapes ) {\\n\\n\\t\\t\\tvar geometries = {};\\n\\n\\t\\t\\tif ( json !== undefined ) {\\n\\n\\t\\t\\t\\tvar geometryLoader = new JSONLoader();\\n\\t\\t\\t\\tvar bufferGeometryLoader = new BufferGeometryLoader();\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar geometry;\\n\\t\\t\\t\\t\\tvar data = json[ i ];\\n\\n\\t\\t\\t\\t\\tswitch ( data.type ) {\\n\\n\\t\\t\\t\\t\\t\\tcase 'PlaneGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'PlaneBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.width,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.height,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.widthSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.heightSegments\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'BoxGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'BoxBufferGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'CubeGeometry': // backwards compatible\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.width,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.height,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.depth,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.widthSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.heightSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.depthSegments\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'CircleGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'CircleBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radius,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.segments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaStart,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaLength\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'CylinderGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'CylinderBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radiusTop,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radiusBottom,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.height,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radialSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.heightSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.openEnded,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaStart,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaLength\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'ConeGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'ConeBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radius,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.height,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radialSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.heightSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.openEnded,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaStart,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaLength\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'SphereGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'SphereBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radius,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.widthSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.heightSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.phiStart,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.phiLength,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaStart,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaLength\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'DodecahedronGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'DodecahedronBufferGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'IcosahedronGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'IcosahedronBufferGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'OctahedronGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'OctahedronBufferGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'TetrahedronGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'TetrahedronBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radius,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.detail\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'RingGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'RingBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.innerRadius,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.outerRadius,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.phiSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaStart,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaLength\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'TorusGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'TorusBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radius,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.tube,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radialSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.tubularSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.arc\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'TorusKnotGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'TorusKnotBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radius,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.tube,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.tubularSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radialSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.p,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.q\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'LatheGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'LatheBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.points,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.segments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.phiStart,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.phiLength\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'PolyhedronGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'PolyhedronBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.vertices,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.indices,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radius,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.details\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'ShapeGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'ShapeBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tvar geometryShapes = [];\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = data.shapes.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar shape = shapes[ data.shapes[ i ] ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgeometryShapes.push( shape );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tgeometryShapes,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.curveSegments\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'BufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = bufferGeometryLoader.parse( data );\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'Geometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = geometryLoader.parse( data, this.texturePath ).geometry;\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \\\"' + data.type + '\\\"' );\\n\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tgeometry.uuid = data.uuid;\\n\\n\\t\\t\\t\\t\\tif ( data.name !== undefined ) geometry.name = data.name;\\n\\n\\t\\t\\t\\t\\tgeometries[ data.uuid ] = geometry;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn geometries;\\n\\n\\t\\t},\\n\\n\\t\\tparseMaterials: function ( json, textures ) {\\n\\n\\t\\t\\tvar materials = {};\\n\\n\\t\\t\\tif ( json !== undefined ) {\\n\\n\\t\\t\\t\\tvar loader = new MaterialLoader();\\n\\t\\t\\t\\tloader.setTextures( textures );\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar data = json[ i ];\\n\\n\\t\\t\\t\\t\\tif ( data.type === 'MultiMaterial' ) {\\n\\n\\t\\t\\t\\t\\t\\t// Deprecated\\n\\n\\t\\t\\t\\t\\t\\tvar array = [];\\n\\n\\t\\t\\t\\t\\t\\tfor ( var j = 0; j < data.materials.length; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tarray.push( loader.parse( data.materials[ j ] ) );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tmaterials[ data.uuid ] = array;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tmaterials[ data.uuid ] = loader.parse( data );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn materials;\\n\\n\\t\\t},\\n\\n\\t\\tparseAnimations: function ( json ) {\\n\\n\\t\\t\\tvar animations = [];\\n\\n\\t\\t\\tfor ( var i = 0; i < json.length; i ++ ) {\\n\\n\\t\\t\\t\\tvar clip = AnimationClip.parse( json[ i ] );\\n\\n\\t\\t\\t\\tanimations.push( clip );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn animations;\\n\\n\\t\\t},\\n\\n\\t\\tparseImages: function ( json, onLoad ) {\\n\\n\\t\\t\\tvar scope = this;\\n\\t\\t\\tvar images = {};\\n\\n\\t\\t\\tfunction loadImage( url ) {\\n\\n\\t\\t\\t\\tscope.manager.itemStart( url );\\n\\n\\t\\t\\t\\treturn loader.load( url, function () {\\n\\n\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\n\\t\\t\\t\\t}, undefined, function () {\\n\\n\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\t\\t\\t\\t\\tscope.manager.itemError( url );\\n\\n\\t\\t\\t\\t} );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( json !== undefined && json.length > 0 ) {\\n\\n\\t\\t\\t\\tvar manager = new LoadingManager( onLoad );\\n\\n\\t\\t\\t\\tvar loader = new ImageLoader( manager );\\n\\t\\t\\t\\tloader.setCrossOrigin( this.crossOrigin );\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar image = json[ i ];\\n\\t\\t\\t\\t\\tvar path = /^(\\\\/\\\\/)|([a-z]+:(\\\\/\\\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\\n\\n\\t\\t\\t\\t\\timages[ image.uuid ] = loadImage( path );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn images;\\n\\n\\t\\t},\\n\\n\\t\\tparseTextures: function ( json, images ) {\\n\\n\\t\\t\\tfunction parseConstant( value, type ) {\\n\\n\\t\\t\\t\\tif ( typeof value === 'number' ) return value;\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\\n\\n\\t\\t\\t\\treturn type[ value ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar textures = {};\\n\\n\\t\\t\\tif ( json !== undefined ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar data = json[ i ];\\n\\n\\t\\t\\t\\t\\tif ( data.image === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: No \\\"image\\\" specified for', data.uuid );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( images[ data.image ] === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvar texture = new Texture( images[ data.image ] );\\n\\t\\t\\t\\t\\ttexture.needsUpdate = true;\\n\\n\\t\\t\\t\\t\\ttexture.uuid = data.uuid;\\n\\n\\t\\t\\t\\t\\tif ( data.name !== undefined ) texture.name = data.name;\\n\\n\\t\\t\\t\\t\\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );\\n\\n\\t\\t\\t\\t\\tif ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\\n\\t\\t\\t\\t\\tif ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\\n\\t\\t\\t\\t\\tif ( data.center !== undefined ) texture.center.fromArray( data.center );\\n\\t\\t\\t\\t\\tif ( data.rotation !== undefined ) texture.rotation = data.rotation;\\n\\n\\t\\t\\t\\t\\tif ( data.wrap !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\ttexture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );\\n\\t\\t\\t\\t\\t\\ttexture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );\\n\\t\\t\\t\\t\\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );\\n\\t\\t\\t\\t\\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\\n\\n\\t\\t\\t\\t\\tif ( data.flipY !== undefined ) texture.flipY = data.flipY;\\n\\n\\t\\t\\t\\t\\ttextures[ data.uuid ] = texture;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn textures;\\n\\n\\t\\t},\\n\\n\\t\\tparseObject: function () {\\n\\n\\t\\t\\tvar matrix = new Matrix4();\\n\\n\\t\\t\\treturn function parseObject( data, geometries, materials ) {\\n\\n\\t\\t\\t\\tvar object;\\n\\n\\t\\t\\t\\tfunction getGeometry( name ) {\\n\\n\\t\\t\\t\\t\\tif ( geometries[ name ] === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn geometries[ name ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfunction getMaterial( name ) {\\n\\n\\t\\t\\t\\t\\tif ( name === undefined ) return undefined;\\n\\n\\t\\t\\t\\t\\tif ( Array.isArray( name ) ) {\\n\\n\\t\\t\\t\\t\\t\\tvar array = [];\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = name.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar uuid = name[ i ];\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( materials[ uuid ] === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: Undefined material', uuid );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tarray.push( materials[ uuid ] );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\treturn array;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( materials[ name ] === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn materials[ name ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tswitch ( data.type ) {\\n\\n\\t\\t\\t\\t\\tcase 'Scene':\\n\\n\\t\\t\\t\\t\\t\\tobject = new Scene();\\n\\n\\t\\t\\t\\t\\t\\tif ( data.background !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( Number.isInteger( data.background ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tobject.background = new Color( data.background );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif ( data.fog !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( data.fog.type === 'Fog' ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tobject.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );\\n\\n\\t\\t\\t\\t\\t\\t\\t} else if ( data.fog.type === 'FogExp2' ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tobject.fog = new FogExp2( data.fog.color, data.fog.density );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'PerspectiveCamera':\\n\\n\\t\\t\\t\\t\\t\\tobject = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\\n\\n\\t\\t\\t\\t\\t\\tif ( data.focus !== undefined ) object.focus = data.focus;\\n\\t\\t\\t\\t\\t\\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\\n\\t\\t\\t\\t\\t\\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\\n\\t\\t\\t\\t\\t\\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\\n\\t\\t\\t\\t\\t\\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'OrthographicCamera':\\n\\n\\t\\t\\t\\t\\t\\tobject = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'AmbientLight':\\n\\n\\t\\t\\t\\t\\t\\tobject = new AmbientLight( data.color, data.intensity );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'DirectionalLight':\\n\\n\\t\\t\\t\\t\\t\\tobject = new DirectionalLight( data.color, data.intensity );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'PointLight':\\n\\n\\t\\t\\t\\t\\t\\tobject = new PointLight( data.color, data.intensity, data.distance, data.decay );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'RectAreaLight':\\n\\n\\t\\t\\t\\t\\t\\tobject = new RectAreaLight( data.color, data.intensity, data.width, data.height );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'SpotLight':\\n\\n\\t\\t\\t\\t\\t\\tobject = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'HemisphereLight':\\n\\n\\t\\t\\t\\t\\t\\tobject = new HemisphereLight( data.color, data.groundColor, data.intensity );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'SkinnedMesh':\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );\\n\\n\\t\\t\\t\\t\\tcase 'Mesh':\\n\\n\\t\\t\\t\\t\\t\\tvar geometry = getGeometry( data.geometry );\\n\\t\\t\\t\\t\\t\\tvar material = getMaterial( data.material );\\n\\n\\t\\t\\t\\t\\t\\tif ( geometry.bones && geometry.bones.length > 0 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tobject = new SkinnedMesh( geometry, material );\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tobject = new Mesh( geometry, material );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'LOD':\\n\\n\\t\\t\\t\\t\\t\\tobject = new LOD();\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'Line':\\n\\n\\t\\t\\t\\t\\t\\tobject = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'LineLoop':\\n\\n\\t\\t\\t\\t\\t\\tobject = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'LineSegments':\\n\\n\\t\\t\\t\\t\\t\\tobject = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'PointCloud':\\n\\t\\t\\t\\t\\tcase 'Points':\\n\\n\\t\\t\\t\\t\\t\\tobject = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'Sprite':\\n\\n\\t\\t\\t\\t\\t\\tobject = new Sprite( getMaterial( data.material ) );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'Group':\\n\\n\\t\\t\\t\\t\\t\\tobject = new Group();\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\t\\t\\tobject = new Object3D();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tobject.uuid = data.uuid;\\n\\n\\t\\t\\t\\tif ( data.name !== undefined ) object.name = data.name;\\n\\t\\t\\t\\tif ( data.matrix !== undefined ) {\\n\\n\\t\\t\\t\\t\\tmatrix.fromArray( data.matrix );\\n\\t\\t\\t\\t\\tmatrix.decompose( object.position, object.quaternion, object.scale );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tif ( data.position !== undefined ) object.position.fromArray( data.position );\\n\\t\\t\\t\\t\\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\\n\\t\\t\\t\\t\\tif ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );\\n\\t\\t\\t\\t\\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\\n\\t\\t\\t\\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\\n\\n\\t\\t\\t\\tif ( data.shadow ) {\\n\\n\\t\\t\\t\\t\\tif ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;\\n\\t\\t\\t\\t\\tif ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;\\n\\t\\t\\t\\t\\tif ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );\\n\\t\\t\\t\\t\\tif ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( data.visible !== undefined ) object.visible = data.visible;\\n\\t\\t\\t\\tif ( data.userData !== undefined ) object.userData = data.userData;\\n\\n\\t\\t\\t\\tif ( data.children !== undefined ) {\\n\\n\\t\\t\\t\\t\\tvar children = data.children;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < children.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tobject.add( this.parseObject( children[ i ], geometries, materials ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( data.type === 'LOD' ) {\\n\\n\\t\\t\\t\\t\\tvar levels = data.levels;\\n\\n\\t\\t\\t\\t\\tfor ( var l = 0; l < levels.length; l ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar level = levels[ l ];\\n\\t\\t\\t\\t\\t\\tvar child = object.getObjectByProperty( 'uuid', level.object );\\n\\n\\t\\t\\t\\t\\t\\tif ( child !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tobject.addLevel( child, level.distance );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn object;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}()\\n\\n\\t} );\\n\\n\\tvar TEXTURE_MAPPING = {\\n\\t\\tUVMapping: UVMapping,\\n\\t\\tCubeReflectionMapping: CubeReflectionMapping,\\n\\t\\tCubeRefractionMapping: CubeRefractionMapping,\\n\\t\\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\\n\\t\\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\\n\\t\\tSphericalReflectionMapping: SphericalReflectionMapping,\\n\\t\\tCubeUVReflectionMapping: CubeUVReflectionMapping,\\n\\t\\tCubeUVRefractionMapping: CubeUVRefractionMapping\\n\\t};\\n\\n\\tvar TEXTURE_WRAPPING = {\\n\\t\\tRepeatWrapping: RepeatWrapping,\\n\\t\\tClampToEdgeWrapping: ClampToEdgeWrapping,\\n\\t\\tMirroredRepeatWrapping: MirroredRepeatWrapping\\n\\t};\\n\\n\\tvar TEXTURE_FILTER = {\\n\\t\\tNearestFilter: NearestFilter,\\n\\t\\tNearestMipMapNearestFilter: NearestMipMapNearestFilter,\\n\\t\\tNearestMipMapLinearFilter: NearestMipMapLinearFilter,\\n\\t\\tLinearFilter: LinearFilter,\\n\\t\\tLinearMipMapNearestFilter: LinearMipMapNearestFilter,\\n\\t\\tLinearMipMapLinearFilter: LinearMipMapLinearFilter\\n\\t};\\n\\n\\t/**\\n\\t * @author thespite / http://clicktorelease.com/\\n\\t */\\n\\n\\tfunction ImageBitmapLoader( manager ) {\\n\\n\\t\\tif ( typeof createImageBitmap === 'undefined' ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );\\n\\n\\t\\t}\\n\\n\\t\\tif ( typeof fetch === 'undefined' ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );\\n\\n\\t\\t}\\n\\n\\t\\tthis.manager = manager !== undefined ? manager : DefaultLoadingManager;\\n\\t\\tthis.options = undefined;\\n\\n\\t}\\n\\n\\tImageBitmapLoader.prototype = {\\n\\n\\t\\tconstructor: ImageBitmapLoader,\\n\\n\\t\\tsetOptions: function setOptions( options ) {\\n\\n\\t\\t\\tthis.options = options;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tload: function load( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tif ( url === undefined ) url = '';\\n\\n\\t\\t\\tif ( this.path !== undefined ) url = this.path + url;\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar cached = Cache.get( url );\\n\\n\\t\\t\\tif ( cached !== undefined ) {\\n\\n\\t\\t\\t\\tscope.manager.itemStart( url );\\n\\n\\t\\t\\t\\tsetTimeout( function () {\\n\\n\\t\\t\\t\\t\\tif ( onLoad ) onLoad( cached );\\n\\n\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\n\\t\\t\\t\\t}, 0 );\\n\\n\\t\\t\\t\\treturn cached;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfetch( url ).then( function ( res ) {\\n\\n\\t\\t\\t\\treturn res.blob();\\n\\n\\t\\t\\t} ).then( function ( blob ) {\\n\\n\\t\\t\\t\\treturn createImageBitmap( blob, scope.options );\\n\\n\\t\\t\\t} ).then( function ( imageBitmap ) {\\n\\n\\t\\t\\t\\tCache.add( url, imageBitmap );\\n\\n\\t\\t\\t\\tif ( onLoad ) onLoad( imageBitmap );\\n\\n\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\n\\t\\t\\t} ).catch( function ( e ) {\\n\\n\\t\\t\\t\\tif ( onError ) onError( e );\\n\\n\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\t\\t\\t\\tscope.manager.itemError( url );\\n\\n\\t\\t\\t} );\\n\\n\\t\\t},\\n\\n\\t\\tsetCrossOrigin: function ( /* value */ ) {\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetPath: function ( value ) {\\n\\n\\t\\t\\tthis.path = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t * minimal class for proxing functions to Path. Replaces old \\\"extractSubpaths()\\\"\\n\\t **/\\n\\n\\tfunction ShapePath() {\\n\\n\\t\\tthis.type = 'ShapePath';\\n\\n\\t\\tthis.subPaths = [];\\n\\t\\tthis.currentPath = null;\\n\\n\\t}\\n\\n\\tObject.assign( ShapePath.prototype, {\\n\\n\\t\\tmoveTo: function ( x, y ) {\\n\\n\\t\\t\\tthis.currentPath = new Path();\\n\\t\\t\\tthis.subPaths.push( this.currentPath );\\n\\t\\t\\tthis.currentPath.moveTo( x, y );\\n\\n\\t\\t},\\n\\n\\t\\tlineTo: function ( x, y ) {\\n\\n\\t\\t\\tthis.currentPath.lineTo( x, y );\\n\\n\\t\\t},\\n\\n\\t\\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\\n\\n\\t\\t\\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\\n\\n\\t\\t},\\n\\n\\t\\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\\n\\n\\t\\t\\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\\n\\n\\t\\t},\\n\\n\\t\\tsplineThru: function ( pts ) {\\n\\n\\t\\t\\tthis.currentPath.splineThru( pts );\\n\\n\\t\\t},\\n\\n\\t\\ttoShapes: function ( isCCW, noHoles ) {\\n\\n\\t\\t\\tfunction toShapesNoHoles( inSubpaths ) {\\n\\n\\t\\t\\t\\tvar shapes = [];\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar tmpPath = inSubpaths[ i ];\\n\\n\\t\\t\\t\\t\\tvar tmpShape = new Shape();\\n\\t\\t\\t\\t\\ttmpShape.curves = tmpPath.curves;\\n\\n\\t\\t\\t\\t\\tshapes.push( tmpShape );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn shapes;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction isPointInsidePolygon( inPt, inPolygon ) {\\n\\n\\t\\t\\t\\tvar polyLen = inPolygon.length;\\n\\n\\t\\t\\t\\t// inPt on polygon contour => immediate success    or\\n\\t\\t\\t\\t// toggling of inside/outside at every single! intersection point of an edge\\n\\t\\t\\t\\t//  with the horizontal line through inPt, left of inPt\\n\\t\\t\\t\\t//  not counting lowerY endpoints of edges and whole edges on that line\\n\\t\\t\\t\\tvar inside = false;\\n\\t\\t\\t\\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\\n\\n\\t\\t\\t\\t\\tvar edgeLowPt = inPolygon[ p ];\\n\\t\\t\\t\\t\\tvar edgeHighPt = inPolygon[ q ];\\n\\n\\t\\t\\t\\t\\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\\n\\t\\t\\t\\t\\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\\n\\n\\t\\t\\t\\t\\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\\n\\n\\t\\t\\t\\t\\t\\t// not parallel\\n\\t\\t\\t\\t\\t\\tif ( edgeDy < 0 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tedgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;\\n\\t\\t\\t\\t\\t\\t\\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \\t\\tcontinue;\\n\\n\\t\\t\\t\\t\\t\\tif ( inPt.y === edgeLowPt.y ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( inPt.x === edgeLowPt.x )\\t\\treturn\\ttrue;\\t\\t// inPt is on contour ?\\n\\t\\t\\t\\t\\t\\t\\t// continue;\\t\\t\\t\\t// no intersection or edgeLowPt => doesn't count !!!\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\\n\\t\\t\\t\\t\\t\\t\\tif ( perpEdge === 0 )\\t\\t\\t\\treturn\\ttrue;\\t\\t// inPt is on contour ?\\n\\t\\t\\t\\t\\t\\t\\tif ( perpEdge < 0 ) \\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t\\tinside = ! inside;\\t\\t// true intersection left of inPt\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t// parallel or collinear\\n\\t\\t\\t\\t\\t\\tif ( inPt.y !== edgeLowPt.y ) \\t\\tcontinue;\\t\\t\\t// parallel\\n\\t\\t\\t\\t\\t\\t// edge lies on the same horizontal line as inPt\\n\\t\\t\\t\\t\\t\\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\\n\\t\\t\\t\\t\\t\\t\\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\\t\\treturn\\ttrue;\\t// inPt: Point on contour !\\n\\t\\t\\t\\t\\t\\t// continue;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn\\tinside;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar isClockWise = ShapeUtils.isClockWise;\\n\\n\\t\\t\\tvar subPaths = this.subPaths;\\n\\t\\t\\tif ( subPaths.length === 0 ) return [];\\n\\n\\t\\t\\tif ( noHoles === true )\\treturn\\ttoShapesNoHoles( subPaths );\\n\\n\\n\\t\\t\\tvar solid, tmpPath, tmpShape, shapes = [];\\n\\n\\t\\t\\tif ( subPaths.length === 1 ) {\\n\\n\\t\\t\\t\\ttmpPath = subPaths[ 0 ];\\n\\t\\t\\t\\ttmpShape = new Shape();\\n\\t\\t\\t\\ttmpShape.curves = tmpPath.curves;\\n\\t\\t\\t\\tshapes.push( tmpShape );\\n\\t\\t\\t\\treturn shapes;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\\n\\t\\t\\tholesFirst = isCCW ? ! holesFirst : holesFirst;\\n\\n\\t\\t\\t// console.log(\\\"Holes first\\\", holesFirst);\\n\\n\\t\\t\\tvar betterShapeHoles = [];\\n\\t\\t\\tvar newShapes = [];\\n\\t\\t\\tvar newShapeHoles = [];\\n\\t\\t\\tvar mainIdx = 0;\\n\\t\\t\\tvar tmpPoints;\\n\\n\\t\\t\\tnewShapes[ mainIdx ] = undefined;\\n\\t\\t\\tnewShapeHoles[ mainIdx ] = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\ttmpPath = subPaths[ i ];\\n\\t\\t\\t\\ttmpPoints = tmpPath.getPoints();\\n\\t\\t\\t\\tsolid = isClockWise( tmpPoints );\\n\\t\\t\\t\\tsolid = isCCW ? ! solid : solid;\\n\\n\\t\\t\\t\\tif ( solid ) {\\n\\n\\t\\t\\t\\t\\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\\tmainIdx ++;\\n\\n\\t\\t\\t\\t\\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\\n\\t\\t\\t\\t\\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\\n\\n\\t\\t\\t\\t\\tif ( holesFirst )\\tmainIdx ++;\\n\\t\\t\\t\\t\\tnewShapeHoles[ mainIdx ] = [];\\n\\n\\t\\t\\t\\t\\t//console.log('cw', i);\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\\n\\n\\t\\t\\t\\t\\t//console.log('ccw', i);\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// only Holes? -> probably all Shapes with wrong orientation\\n\\t\\t\\tif ( ! newShapes[ 0 ] )\\treturn\\ttoShapesNoHoles( subPaths );\\n\\n\\n\\t\\t\\tif ( newShapes.length > 1 ) {\\n\\n\\t\\t\\t\\tvar ambiguous = false;\\n\\t\\t\\t\\tvar toChange = [];\\n\\n\\t\\t\\t\\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\\n\\n\\t\\t\\t\\t\\tbetterShapeHoles[ sIdx ] = [];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\\n\\n\\t\\t\\t\\t\\tvar sho = newShapeHoles[ sIdx ];\\n\\n\\t\\t\\t\\t\\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar ho = sho[ hIdx ];\\n\\t\\t\\t\\t\\t\\tvar hole_unassigned = true;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( sIdx !== s2Idx )\\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( hole_unassigned ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\thole_unassigned = false;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbetterShapeHoles[ s2Idx ].push( ho );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tambiguous = true;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif ( hole_unassigned ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tbetterShapeHoles[ sIdx ].push( ho );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// console.log(\\\"ambiguous: \\\", ambiguous);\\n\\t\\t\\t\\tif ( toChange.length > 0 ) {\\n\\n\\t\\t\\t\\t\\t// console.log(\\\"to change: \\\", toChange);\\n\\t\\t\\t\\t\\tif ( ! ambiguous )\\tnewShapeHoles = betterShapeHoles;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar tmpHoles;\\n\\n\\t\\t\\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\ttmpShape = newShapes[ i ].s;\\n\\t\\t\\t\\tshapes.push( tmpShape );\\n\\t\\t\\t\\ttmpHoles = newShapeHoles[ i ];\\n\\n\\t\\t\\t\\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\ttmpShape.holes.push( tmpHoles[ j ].h );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//console.log(\\\"shape\\\", shapes);\\n\\n\\t\\t\\treturn shapes;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction Font( data ) {\\n\\n\\t\\tthis.type = 'Font';\\n\\n\\t\\tthis.data = data;\\n\\n\\t}\\n\\n\\tObject.assign( Font.prototype, {\\n\\n\\t\\tisFont: true,\\n\\n\\t\\tgenerateShapes: function ( text, size, divisions ) {\\n\\n\\t\\t\\tfunction createPaths( text ) {\\n\\n\\t\\t\\t\\tvar chars = String( text ).split( '' );\\n\\t\\t\\t\\tvar scale = size / data.resolution;\\n\\t\\t\\t\\tvar line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;\\n\\n\\t\\t\\t\\tvar offsetX = 0, offsetY = 0;\\n\\n\\t\\t\\t\\tvar paths = [];\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < chars.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar char = chars[ i ];\\n\\n\\t\\t\\t\\t\\tif ( char === '\\\\n' ) {\\n\\n\\t\\t\\t\\t\\t\\toffsetX = 0;\\n\\t\\t\\t\\t\\t\\toffsetY -= line_height;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tvar ret = createPath( char, scale, offsetX, offsetY );\\n\\t\\t\\t\\t\\t\\toffsetX += ret.offsetX;\\n\\t\\t\\t\\t\\t\\tpaths.push( ret.path );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn paths;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction createPath( c, scale, offsetX, offsetY ) {\\n\\n\\t\\t\\t\\tvar glyph = data.glyphs[ c ] || data.glyphs[ '?' ];\\n\\n\\t\\t\\t\\tif ( ! glyph ) return;\\n\\n\\t\\t\\t\\tvar path = new ShapePath();\\n\\n\\t\\t\\t\\tvar pts = [];\\n\\t\\t\\t\\tvar x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;\\n\\n\\t\\t\\t\\tif ( glyph.o ) {\\n\\n\\t\\t\\t\\t\\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = outline.length; i < l; ) {\\n\\n\\t\\t\\t\\t\\t\\tvar action = outline[ i ++ ];\\n\\n\\t\\t\\t\\t\\t\\tswitch ( action ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tcase 'm': // moveTo\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tx = outline[ i ++ ] * scale + offsetX;\\n\\t\\t\\t\\t\\t\\t\\t\\ty = outline[ i ++ ] * scale + offsetY;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tpath.moveTo( x, y );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\tcase 'l': // lineTo\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tx = outline[ i ++ ] * scale + offsetX;\\n\\t\\t\\t\\t\\t\\t\\t\\ty = outline[ i ++ ] * scale + offsetY;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tpath.lineTo( x, y );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\tcase 'q': // quadraticCurveTo\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcpx = outline[ i ++ ] * scale + offsetX;\\n\\t\\t\\t\\t\\t\\t\\t\\tcpy = outline[ i ++ ] * scale + offsetY;\\n\\t\\t\\t\\t\\t\\t\\t\\tcpx1 = outline[ i ++ ] * scale + offsetX;\\n\\t\\t\\t\\t\\t\\t\\t\\tcpy1 = outline[ i ++ ] * scale + offsetY;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tlaste = pts[ pts.length - 1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( laste ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcpx0 = laste.x;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcpy0 = laste.y;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\tcase 'b': // bezierCurveTo\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcpx = outline[ i ++ ] * scale + offsetX;\\n\\t\\t\\t\\t\\t\\t\\t\\tcpy = outline[ i ++ ] * scale + offsetY;\\n\\t\\t\\t\\t\\t\\t\\t\\tcpx1 = outline[ i ++ ] * scale + offsetX;\\n\\t\\t\\t\\t\\t\\t\\t\\tcpy1 = outline[ i ++ ] * scale + offsetY;\\n\\t\\t\\t\\t\\t\\t\\t\\tcpx2 = outline[ i ++ ] * scale + offsetX;\\n\\t\\t\\t\\t\\t\\t\\t\\tcpy2 = outline[ i ++ ] * scale + offsetY;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tlaste = pts[ pts.length - 1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( laste ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcpx0 = laste.x;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcpy0 = laste.y;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn { offsetX: glyph.ha * scale, path: path };\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tif ( size === undefined ) size = 100;\\n\\t\\t\\tif ( divisions === undefined ) divisions = 4;\\n\\n\\t\\t\\tvar data = this.data;\\n\\n\\t\\t\\tvar paths = createPaths( text );\\n\\t\\t\\tvar shapes = [];\\n\\n\\t\\t\\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\\n\\n\\t\\t\\t\\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn shapes;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction FontLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t}\\n\\n\\tObject.assign( FontLoader.prototype, {\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar loader = new FileLoader( this.manager );\\n\\t\\t\\tloader.setPath( this.path );\\n\\t\\t\\tloader.load( url, function ( text ) {\\n\\n\\t\\t\\t\\tvar json;\\n\\n\\t\\t\\t\\ttry {\\n\\n\\t\\t\\t\\t\\tjson = JSON.parse( text );\\n\\n\\t\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\\n\\t\\t\\t\\t\\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar font = scope.parse( json );\\n\\n\\t\\t\\t\\tif ( onLoad ) onLoad( font );\\n\\n\\t\\t\\t}, onProgress, onError );\\n\\n\\t\\t},\\n\\n\\t\\tparse: function ( json ) {\\n\\n\\t\\t\\treturn new Font( json );\\n\\n\\t\\t},\\n\\n\\t\\tsetPath: function ( value ) {\\n\\n\\t\\t\\tthis.path = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tvar context;\\n\\n\\tvar AudioContext = {\\n\\n\\t\\tgetContext: function () {\\n\\n\\t\\t\\tif ( context === undefined ) {\\n\\n\\t\\t\\t\\tcontext = new ( window.AudioContext || window.webkitAudioContext )();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn context;\\n\\n\\t\\t},\\n\\n\\t\\tsetContext: function ( value ) {\\n\\n\\t\\t\\tcontext = value;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\\n\\t */\\n\\n\\tfunction AudioLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t}\\n\\n\\tObject.assign( AudioLoader.prototype, {\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tvar loader = new FileLoader( this.manager );\\n\\t\\t\\tloader.setResponseType( 'arraybuffer' );\\n\\t\\t\\tloader.load( url, function ( buffer ) {\\n\\n\\t\\t\\t\\tvar context = AudioContext.getContext();\\n\\n\\t\\t\\t\\tcontext.decodeAudioData( buffer, function ( audioBuffer ) {\\n\\n\\t\\t\\t\\t\\tonLoad( audioBuffer );\\n\\n\\t\\t\\t\\t} );\\n\\n\\t\\t\\t}, onProgress, onError );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction StereoCamera() {\\n\\n\\t\\tthis.type = 'StereoCamera';\\n\\n\\t\\tthis.aspect = 1;\\n\\n\\t\\tthis.eyeSep = 0.064;\\n\\n\\t\\tthis.cameraL = new PerspectiveCamera();\\n\\t\\tthis.cameraL.layers.enable( 1 );\\n\\t\\tthis.cameraL.matrixAutoUpdate = false;\\n\\n\\t\\tthis.cameraR = new PerspectiveCamera();\\n\\t\\tthis.cameraR.layers.enable( 2 );\\n\\t\\tthis.cameraR.matrixAutoUpdate = false;\\n\\n\\t}\\n\\n\\tObject.assign( StereoCamera.prototype, {\\n\\n\\t\\tupdate: ( function () {\\n\\n\\t\\t\\tvar instance, focus, fov, aspect, near, far, zoom, eyeSep;\\n\\n\\t\\t\\tvar eyeRight = new Matrix4();\\n\\t\\t\\tvar eyeLeft = new Matrix4();\\n\\n\\t\\t\\treturn function update( camera ) {\\n\\n\\t\\t\\t\\tvar needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\taspect !== camera.aspect * this.aspect || near !== camera.near ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfar !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;\\n\\n\\t\\t\\t\\tif ( needsUpdate ) {\\n\\n\\t\\t\\t\\t\\tinstance = this;\\n\\t\\t\\t\\t\\tfocus = camera.focus;\\n\\t\\t\\t\\t\\tfov = camera.fov;\\n\\t\\t\\t\\t\\taspect = camera.aspect * this.aspect;\\n\\t\\t\\t\\t\\tnear = camera.near;\\n\\t\\t\\t\\t\\tfar = camera.far;\\n\\t\\t\\t\\t\\tzoom = camera.zoom;\\n\\n\\t\\t\\t\\t\\t// Off-axis stereoscopic effect based on\\n\\t\\t\\t\\t\\t// http://paulbourke.net/stereographics/stereorender/\\n\\n\\t\\t\\t\\t\\tvar projectionMatrix = camera.projectionMatrix.clone();\\n\\t\\t\\t\\t\\teyeSep = this.eyeSep / 2;\\n\\t\\t\\t\\t\\tvar eyeSepOnProjection = eyeSep * near / focus;\\n\\t\\t\\t\\t\\tvar ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;\\n\\t\\t\\t\\t\\tvar xmin, xmax;\\n\\n\\t\\t\\t\\t\\t// translate xOffset\\n\\n\\t\\t\\t\\t\\teyeLeft.elements[ 12 ] = - eyeSep;\\n\\t\\t\\t\\t\\teyeRight.elements[ 12 ] = eyeSep;\\n\\n\\t\\t\\t\\t\\t// for left eye\\n\\n\\t\\t\\t\\t\\txmin = - ymax * aspect + eyeSepOnProjection;\\n\\t\\t\\t\\t\\txmax = ymax * aspect + eyeSepOnProjection;\\n\\n\\t\\t\\t\\t\\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\\n\\t\\t\\t\\t\\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\\n\\n\\t\\t\\t\\t\\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\\n\\n\\t\\t\\t\\t\\t// for right eye\\n\\n\\t\\t\\t\\t\\txmin = - ymax * aspect - eyeSepOnProjection;\\n\\t\\t\\t\\t\\txmax = ymax * aspect - eyeSepOnProjection;\\n\\n\\t\\t\\t\\t\\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\\n\\t\\t\\t\\t\\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\\n\\n\\t\\t\\t\\t\\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\\n\\t\\t\\t\\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )()\\n\\n\\t} );\\n\\n\\t/**\\n\\t * Camera for rendering cube maps\\n\\t *\\t- renders scene into axis-aligned cube\\n\\t *\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction CubeCamera( near, far, cubeResolution ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'CubeCamera';\\n\\n\\t\\tvar fov = 90, aspect = 1;\\n\\n\\t\\tvar cameraPX = new PerspectiveCamera( fov, aspect, near, far );\\n\\t\\tcameraPX.up.set( 0, - 1, 0 );\\n\\t\\tcameraPX.lookAt( new Vector3( 1, 0, 0 ) );\\n\\t\\tthis.add( cameraPX );\\n\\n\\t\\tvar cameraNX = new PerspectiveCamera( fov, aspect, near, far );\\n\\t\\tcameraNX.up.set( 0, - 1, 0 );\\n\\t\\tcameraNX.lookAt( new Vector3( - 1, 0, 0 ) );\\n\\t\\tthis.add( cameraNX );\\n\\n\\t\\tvar cameraPY = new PerspectiveCamera( fov, aspect, near, far );\\n\\t\\tcameraPY.up.set( 0, 0, 1 );\\n\\t\\tcameraPY.lookAt( new Vector3( 0, 1, 0 ) );\\n\\t\\tthis.add( cameraPY );\\n\\n\\t\\tvar cameraNY = new PerspectiveCamera( fov, aspect, near, far );\\n\\t\\tcameraNY.up.set( 0, 0, - 1 );\\n\\t\\tcameraNY.lookAt( new Vector3( 0, - 1, 0 ) );\\n\\t\\tthis.add( cameraNY );\\n\\n\\t\\tvar cameraPZ = new PerspectiveCamera( fov, aspect, near, far );\\n\\t\\tcameraPZ.up.set( 0, - 1, 0 );\\n\\t\\tcameraPZ.lookAt( new Vector3( 0, 0, 1 ) );\\n\\t\\tthis.add( cameraPZ );\\n\\n\\t\\tvar cameraNZ = new PerspectiveCamera( fov, aspect, near, far );\\n\\t\\tcameraNZ.up.set( 0, - 1, 0 );\\n\\t\\tcameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );\\n\\t\\tthis.add( cameraNZ );\\n\\n\\t\\tvar options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };\\n\\n\\t\\tthis.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\\n\\t\\tthis.renderTarget.texture.name = \\\"CubeCamera\\\";\\n\\n\\t\\tthis.update = function ( renderer, scene ) {\\n\\n\\t\\t\\tif ( this.parent === null ) this.updateMatrixWorld();\\n\\n\\t\\t\\tvar renderTarget = this.renderTarget;\\n\\t\\t\\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\\n\\n\\t\\t\\trenderTarget.texture.generateMipmaps = false;\\n\\n\\t\\t\\trenderTarget.activeCubeFace = 0;\\n\\t\\t\\trenderer.render( scene, cameraPX, renderTarget );\\n\\n\\t\\t\\trenderTarget.activeCubeFace = 1;\\n\\t\\t\\trenderer.render( scene, cameraNX, renderTarget );\\n\\n\\t\\t\\trenderTarget.activeCubeFace = 2;\\n\\t\\t\\trenderer.render( scene, cameraPY, renderTarget );\\n\\n\\t\\t\\trenderTarget.activeCubeFace = 3;\\n\\t\\t\\trenderer.render( scene, cameraNY, renderTarget );\\n\\n\\t\\t\\trenderTarget.activeCubeFace = 4;\\n\\t\\t\\trenderer.render( scene, cameraPZ, renderTarget );\\n\\n\\t\\t\\trenderTarget.texture.generateMipmaps = generateMipmaps;\\n\\n\\t\\t\\trenderTarget.activeCubeFace = 5;\\n\\t\\t\\trenderer.render( scene, cameraNZ, renderTarget );\\n\\n\\t\\t\\trenderer.setRenderTarget( null );\\n\\n\\t\\t};\\n\\n\\t\\tthis.clear = function ( renderer, color, depth, stencil ) {\\n\\n\\t\\t\\tvar renderTarget = this.renderTarget;\\n\\n\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\trenderTarget.activeCubeFace = i;\\n\\t\\t\\t\\trenderer.setRenderTarget( renderTarget );\\n\\n\\t\\t\\t\\trenderer.clear( color, depth, stencil );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\trenderer.setRenderTarget( null );\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\tCubeCamera.prototype = Object.create( Object3D.prototype );\\n\\tCubeCamera.prototype.constructor = CubeCamera;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction AudioListener() {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'AudioListener';\\n\\n\\t\\tthis.context = AudioContext.getContext();\\n\\n\\t\\tthis.gain = this.context.createGain();\\n\\t\\tthis.gain.connect( this.context.destination );\\n\\n\\t\\tthis.filter = null;\\n\\n\\t}\\n\\n\\tAudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: AudioListener,\\n\\n\\t\\tgetInput: function () {\\n\\n\\t\\t\\treturn this.gain;\\n\\n\\t\\t},\\n\\n\\t\\tremoveFilter: function ( ) {\\n\\n\\t\\t\\tif ( this.filter !== null ) {\\n\\n\\t\\t\\t\\tthis.gain.disconnect( this.filter );\\n\\t\\t\\t\\tthis.filter.disconnect( this.context.destination );\\n\\t\\t\\t\\tthis.gain.connect( this.context.destination );\\n\\t\\t\\t\\tthis.filter = null;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tgetFilter: function () {\\n\\n\\t\\t\\treturn this.filter;\\n\\n\\t\\t},\\n\\n\\t\\tsetFilter: function ( value ) {\\n\\n\\t\\t\\tif ( this.filter !== null ) {\\n\\n\\t\\t\\t\\tthis.gain.disconnect( this.filter );\\n\\t\\t\\t\\tthis.filter.disconnect( this.context.destination );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.gain.disconnect( this.context.destination );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.filter = value;\\n\\t\\t\\tthis.gain.connect( this.filter );\\n\\t\\t\\tthis.filter.connect( this.context.destination );\\n\\n\\t\\t},\\n\\n\\t\\tgetMasterVolume: function () {\\n\\n\\t\\t\\treturn this.gain.gain.value;\\n\\n\\t\\t},\\n\\n\\t\\tsetMasterVolume: function ( value ) {\\n\\n\\t\\t\\tthis.gain.gain.value = value;\\n\\n\\t\\t},\\n\\n\\t\\tupdateMatrixWorld: ( function () {\\n\\n\\t\\t\\tvar position = new Vector3();\\n\\t\\t\\tvar quaternion = new Quaternion();\\n\\t\\t\\tvar scale = new Vector3();\\n\\n\\t\\t\\tvar orientation = new Vector3();\\n\\n\\t\\t\\treturn function updateMatrixWorld( force ) {\\n\\n\\t\\t\\t\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\n\\n\\t\\t\\t\\tvar listener = this.context.listener;\\n\\t\\t\\t\\tvar up = this.up;\\n\\n\\t\\t\\t\\tthis.matrixWorld.decompose( position, quaternion, scale );\\n\\n\\t\\t\\t\\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\\n\\n\\t\\t\\t\\tif ( listener.positionX ) {\\n\\n\\t\\t\\t\\t\\tlistener.positionX.setValueAtTime( position.x, this.context.currentTime );\\n\\t\\t\\t\\t\\tlistener.positionY.setValueAtTime( position.y, this.context.currentTime );\\n\\t\\t\\t\\t\\tlistener.positionZ.setValueAtTime( position.z, this.context.currentTime );\\n\\t\\t\\t\\t\\tlistener.forwardX.setValueAtTime( orientation.x, this.context.currentTime );\\n\\t\\t\\t\\t\\tlistener.forwardY.setValueAtTime( orientation.y, this.context.currentTime );\\n\\t\\t\\t\\t\\tlistener.forwardZ.setValueAtTime( orientation.z, this.context.currentTime );\\n\\t\\t\\t\\t\\tlistener.upX.setValueAtTime( up.x, this.context.currentTime );\\n\\t\\t\\t\\t\\tlistener.upY.setValueAtTime( up.y, this.context.currentTime );\\n\\t\\t\\t\\t\\tlistener.upZ.setValueAtTime( up.z, this.context.currentTime );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tlistener.setPosition( position.x, position.y, position.z );\\n\\t\\t\\t\\t\\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )()\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\\n\\t */\\n\\n\\tfunction Audio( listener ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Audio';\\n\\n\\t\\tthis.context = listener.context;\\n\\n\\t\\tthis.gain = this.context.createGain();\\n\\t\\tthis.gain.connect( listener.getInput() );\\n\\n\\t\\tthis.autoplay = false;\\n\\n\\t\\tthis.buffer = null;\\n\\t\\tthis.loop = false;\\n\\t\\tthis.startTime = 0;\\n\\t\\tthis.offset = 0;\\n\\t\\tthis.playbackRate = 1;\\n\\t\\tthis.isPlaying = false;\\n\\t\\tthis.hasPlaybackControl = true;\\n\\t\\tthis.sourceType = 'empty';\\n\\n\\t\\tthis.filters = [];\\n\\n\\t}\\n\\n\\tAudio.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Audio,\\n\\n\\t\\tgetOutput: function () {\\n\\n\\t\\t\\treturn this.gain;\\n\\n\\t\\t},\\n\\n\\t\\tsetNodeSource: function ( audioNode ) {\\n\\n\\t\\t\\tthis.hasPlaybackControl = false;\\n\\t\\t\\tthis.sourceType = 'audioNode';\\n\\t\\t\\tthis.source = audioNode;\\n\\t\\t\\tthis.connect();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetBuffer: function ( audioBuffer ) {\\n\\n\\t\\t\\tthis.buffer = audioBuffer;\\n\\t\\t\\tthis.sourceType = 'buffer';\\n\\n\\t\\t\\tif ( this.autoplay ) this.play();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tplay: function () {\\n\\n\\t\\t\\tif ( this.isPlaying === true ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.hasPlaybackControl === false ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar source = this.context.createBufferSource();\\n\\n\\t\\t\\tsource.buffer = this.buffer;\\n\\t\\t\\tsource.loop = this.loop;\\n\\t\\t\\tsource.onended = this.onEnded.bind( this );\\n\\t\\t\\tsource.playbackRate.setValueAtTime( this.playbackRate, this.startTime );\\n\\t\\t\\tthis.startTime = this.context.currentTime;\\n\\t\\t\\tsource.start( this.startTime, this.offset );\\n\\n\\t\\t\\tthis.isPlaying = true;\\n\\n\\t\\t\\tthis.source = source;\\n\\n\\t\\t\\treturn this.connect();\\n\\n\\t\\t},\\n\\n\\t\\tpause: function () {\\n\\n\\t\\t\\tif ( this.hasPlaybackControl === false ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.isPlaying === true ) {\\n\\n\\t\\t\\t\\tthis.source.stop();\\n\\t\\t\\t\\tthis.offset += ( this.context.currentTime - this.startTime ) * this.playbackRate;\\n\\t\\t\\t\\tthis.isPlaying = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tstop: function () {\\n\\n\\t\\t\\tif ( this.hasPlaybackControl === false ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.source.stop();\\n\\t\\t\\tthis.offset = 0;\\n\\t\\t\\tthis.isPlaying = false;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tconnect: function () {\\n\\n\\t\\t\\tif ( this.filters.length > 0 ) {\\n\\n\\t\\t\\t\\tthis.source.connect( this.filters[ 0 ] );\\n\\n\\t\\t\\t\\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.source.connect( this.getOutput() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdisconnect: function () {\\n\\n\\t\\t\\tif ( this.filters.length > 0 ) {\\n\\n\\t\\t\\t\\tthis.source.disconnect( this.filters[ 0 ] );\\n\\n\\t\\t\\t\\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.source.disconnect( this.getOutput() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetFilters: function () {\\n\\n\\t\\t\\treturn this.filters;\\n\\n\\t\\t},\\n\\n\\t\\tsetFilters: function ( value ) {\\n\\n\\t\\t\\tif ( ! value ) value = [];\\n\\n\\t\\t\\tif ( this.isPlaying === true ) {\\n\\n\\t\\t\\t\\tthis.disconnect();\\n\\t\\t\\t\\tthis.filters = value;\\n\\t\\t\\t\\tthis.connect();\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.filters = value;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetFilter: function () {\\n\\n\\t\\t\\treturn this.getFilters()[ 0 ];\\n\\n\\t\\t},\\n\\n\\t\\tsetFilter: function ( filter ) {\\n\\n\\t\\t\\treturn this.setFilters( filter ? [ filter ] : [] );\\n\\n\\t\\t},\\n\\n\\t\\tsetPlaybackRate: function ( value ) {\\n\\n\\t\\t\\tif ( this.hasPlaybackControl === false ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.playbackRate = value;\\n\\n\\t\\t\\tif ( this.isPlaying === true ) {\\n\\n\\t\\t\\t\\tthis.source.playbackRate.setValueAtTime( this.playbackRate, this.context.currentTime );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetPlaybackRate: function () {\\n\\n\\t\\t\\treturn this.playbackRate;\\n\\n\\t\\t},\\n\\n\\t\\tonEnded: function () {\\n\\n\\t\\t\\tthis.isPlaying = false;\\n\\n\\t\\t},\\n\\n\\t\\tgetLoop: function () {\\n\\n\\t\\t\\tif ( this.hasPlaybackControl === false ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this.loop;\\n\\n\\t\\t},\\n\\n\\t\\tsetLoop: function ( value ) {\\n\\n\\t\\t\\tif ( this.hasPlaybackControl === false ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.loop = value;\\n\\n\\t\\t\\tif ( this.isPlaying === true ) {\\n\\n\\t\\t\\t\\tthis.source.loop = this.loop;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetVolume: function () {\\n\\n\\t\\t\\treturn this.gain.gain.value;\\n\\n\\t\\t},\\n\\n\\t\\tsetVolume: function ( value ) {\\n\\n\\t\\t\\tthis.gain.gain.value = value;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction PositionalAudio( listener ) {\\n\\n\\t\\tAudio.call( this, listener );\\n\\n\\t\\tthis.panner = this.context.createPanner();\\n\\t\\tthis.panner.connect( this.gain );\\n\\n\\t}\\n\\n\\tPositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {\\n\\n\\t\\tconstructor: PositionalAudio,\\n\\n\\t\\tgetOutput: function () {\\n\\n\\t\\t\\treturn this.panner;\\n\\n\\t\\t},\\n\\n\\t\\tgetRefDistance: function () {\\n\\n\\t\\t\\treturn this.panner.refDistance;\\n\\n\\t\\t},\\n\\n\\t\\tsetRefDistance: function ( value ) {\\n\\n\\t\\t\\tthis.panner.refDistance = value;\\n\\n\\t\\t},\\n\\n\\t\\tgetRolloffFactor: function () {\\n\\n\\t\\t\\treturn this.panner.rolloffFactor;\\n\\n\\t\\t},\\n\\n\\t\\tsetRolloffFactor: function ( value ) {\\n\\n\\t\\t\\tthis.panner.rolloffFactor = value;\\n\\n\\t\\t},\\n\\n\\t\\tgetDistanceModel: function () {\\n\\n\\t\\t\\treturn this.panner.distanceModel;\\n\\n\\t\\t},\\n\\n\\t\\tsetDistanceModel: function ( value ) {\\n\\n\\t\\t\\tthis.panner.distanceModel = value;\\n\\n\\t\\t},\\n\\n\\t\\tgetMaxDistance: function () {\\n\\n\\t\\t\\treturn this.panner.maxDistance;\\n\\n\\t\\t},\\n\\n\\t\\tsetMaxDistance: function ( value ) {\\n\\n\\t\\t\\tthis.panner.maxDistance = value;\\n\\n\\t\\t},\\n\\n\\t\\tupdateMatrixWorld: ( function () {\\n\\n\\t\\t\\tvar position = new Vector3();\\n\\n\\t\\t\\treturn function updateMatrixWorld( force ) {\\n\\n\\t\\t\\t\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\n\\n\\t\\t\\t\\tposition.setFromMatrixPosition( this.matrixWorld );\\n\\n\\t\\t\\t\\tthis.panner.setPosition( position.x, position.y, position.z );\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )()\\n\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction AudioAnalyser( audio, fftSize ) {\\n\\n\\t\\tthis.analyser = audio.context.createAnalyser();\\n\\t\\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\\n\\n\\t\\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\\n\\n\\t\\taudio.getOutput().connect( this.analyser );\\n\\n\\t}\\n\\n\\tObject.assign( AudioAnalyser.prototype, {\\n\\n\\t\\tgetFrequencyData: function () {\\n\\n\\t\\t\\tthis.analyser.getByteFrequencyData( this.data );\\n\\n\\t\\t\\treturn this.data;\\n\\n\\t\\t},\\n\\n\\t\\tgetAverageFrequency: function () {\\n\\n\\t\\t\\tvar value = 0, data = this.getFrequencyData();\\n\\n\\t\\t\\tfor ( var i = 0; i < data.length; i ++ ) {\\n\\n\\t\\t\\t\\tvalue += data[ i ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn value / data.length;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * Buffered scene graph property that allows weighted accumulation.\\n\\t *\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction PropertyMixer( binding, typeName, valueSize ) {\\n\\n\\t\\tthis.binding = binding;\\n\\t\\tthis.valueSize = valueSize;\\n\\n\\t\\tvar bufferType = Float64Array,\\n\\t\\t\\tmixFunction;\\n\\n\\t\\tswitch ( typeName ) {\\n\\n\\t\\t\\tcase 'quaternion':\\n\\t\\t\\t\\tmixFunction = this._slerp;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 'string':\\n\\t\\t\\tcase 'bool':\\n\\t\\t\\t\\tbufferType = Array;\\n\\t\\t\\t\\tmixFunction = this._select;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tmixFunction = this._lerp;\\n\\n\\t\\t}\\n\\n\\t\\tthis.buffer = new bufferType( valueSize * 4 );\\n\\t\\t// layout: [ incoming | accu0 | accu1 | orig ]\\n\\t\\t//\\n\\t\\t// interpolators can use .buffer as their .result\\n\\t\\t// the data then goes to 'incoming'\\n\\t\\t//\\n\\t\\t// 'accu0' and 'accu1' are used frame-interleaved for\\n\\t\\t// the cumulative result and are compared to detect\\n\\t\\t// changes\\n\\t\\t//\\n\\t\\t// 'orig' stores the original state of the property\\n\\n\\t\\tthis._mixBufferRegion = mixFunction;\\n\\n\\t\\tthis.cumulativeWeight = 0;\\n\\n\\t\\tthis.useCount = 0;\\n\\t\\tthis.referenceCount = 0;\\n\\n\\t}\\n\\n\\tObject.assign( PropertyMixer.prototype, {\\n\\n\\t\\t// accumulate data in the 'incoming' region into 'accu<i>'\\n\\t\\taccumulate: function ( accuIndex, weight ) {\\n\\n\\t\\t\\t// note: happily accumulating nothing when weight = 0, the caller knows\\n\\t\\t\\t// the weight and shouldn't have made the call in the first place\\n\\n\\t\\t\\tvar buffer = this.buffer,\\n\\t\\t\\t\\tstride = this.valueSize,\\n\\t\\t\\t\\toffset = accuIndex * stride + stride,\\n\\n\\t\\t\\t\\tcurrentWeight = this.cumulativeWeight;\\n\\n\\t\\t\\tif ( currentWeight === 0 ) {\\n\\n\\t\\t\\t\\t// accuN := incoming * weight\\n\\n\\t\\t\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\n\\n\\t\\t\\t\\t\\tbuffer[ offset + i ] = buffer[ i ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcurrentWeight = weight;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// accuN := accuN + incoming * weight\\n\\n\\t\\t\\t\\tcurrentWeight += weight;\\n\\t\\t\\t\\tvar mix = weight / currentWeight;\\n\\t\\t\\t\\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.cumulativeWeight = currentWeight;\\n\\n\\t\\t},\\n\\n\\t\\t// apply the state of 'accu<i>' to the binding when accus differ\\n\\t\\tapply: function ( accuIndex ) {\\n\\n\\t\\t\\tvar stride = this.valueSize,\\n\\t\\t\\t\\tbuffer = this.buffer,\\n\\t\\t\\t\\toffset = accuIndex * stride + stride,\\n\\n\\t\\t\\t\\tweight = this.cumulativeWeight,\\n\\n\\t\\t\\t\\tbinding = this.binding;\\n\\n\\t\\t\\tthis.cumulativeWeight = 0;\\n\\n\\t\\t\\tif ( weight < 1 ) {\\n\\n\\t\\t\\t\\t// accuN := accuN + original * ( 1 - cumulativeWeight )\\n\\n\\t\\t\\t\\tvar originalValueOffset = stride * 3;\\n\\n\\t\\t\\t\\tthis._mixBufferRegion(\\n\\t\\t\\t\\t\\tbuffer, offset, originalValueOffset, 1 - weight, stride );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\\n\\n\\t\\t\\t\\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\\n\\n\\t\\t\\t\\t\\t// value has changed -> update scene graph\\n\\n\\t\\t\\t\\t\\tbinding.setValue( buffer, offset );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t// remember the state of the bound property and copy it to both accus\\n\\t\\tsaveOriginalState: function () {\\n\\n\\t\\t\\tvar binding = this.binding;\\n\\n\\t\\t\\tvar buffer = this.buffer,\\n\\t\\t\\t\\tstride = this.valueSize,\\n\\n\\t\\t\\t\\toriginalValueOffset = stride * 3;\\n\\n\\t\\t\\tbinding.getValue( buffer, originalValueOffset );\\n\\n\\t\\t\\t// accu[0..1] := orig -- initially detect changes against the original\\n\\t\\t\\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\\n\\n\\t\\t\\t\\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.cumulativeWeight = 0;\\n\\n\\t\\t},\\n\\n\\t\\t// apply the state previously taken via 'saveOriginalState' to the binding\\n\\t\\trestoreOriginalState: function () {\\n\\n\\t\\t\\tvar originalValueOffset = this.valueSize * 3;\\n\\t\\t\\tthis.binding.setValue( this.buffer, originalValueOffset );\\n\\n\\t\\t},\\n\\n\\n\\t\\t// mix functions\\n\\n\\t\\t_select: function ( buffer, dstOffset, srcOffset, t, stride ) {\\n\\n\\t\\t\\tif ( t >= 0.5 ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\n\\n\\t\\t\\t\\t\\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t_slerp: function ( buffer, dstOffset, srcOffset, t ) {\\n\\n\\t\\t\\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );\\n\\n\\t\\t},\\n\\n\\t\\t_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {\\n\\n\\t\\t\\tvar s = 1 - t;\\n\\n\\t\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\n\\n\\t\\t\\t\\tvar j = dstOffset + i;\\n\\n\\t\\t\\t\\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * A reference to a real property in the scene graph.\\n\\t *\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction Composite( targetGroup, path, optionalParsedPath ) {\\n\\n\\t\\tvar parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );\\n\\n\\t\\tthis._targetGroup = targetGroup;\\n\\t\\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\\n\\n\\t}\\n\\n\\tObject.assign( Composite.prototype, {\\n\\n\\t\\tgetValue: function ( array, offset ) {\\n\\n\\t\\t\\tthis.bind(); // bind all binding\\n\\n\\t\\t\\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\\n\\t\\t\\t\\tbinding = this._bindings[ firstValidIndex ];\\n\\n\\t\\t\\t// and only call .getValue on the first\\n\\t\\t\\tif ( binding !== undefined ) binding.getValue( array, offset );\\n\\n\\t\\t},\\n\\n\\t\\tsetValue: function ( array, offset ) {\\n\\n\\t\\t\\tvar bindings = this._bindings;\\n\\n\\t\\t\\tfor ( var i = this._targetGroup.nCachedObjects_,\\n\\t\\t\\t\\t\\t  n = bindings.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\tbindings[ i ].setValue( array, offset );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tbind: function () {\\n\\n\\t\\t\\tvar bindings = this._bindings;\\n\\n\\t\\t\\tfor ( var i = this._targetGroup.nCachedObjects_,\\n\\t\\t\\t\\t\\t  n = bindings.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\tbindings[ i ].bind();\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tunbind: function () {\\n\\n\\t\\t\\tvar bindings = this._bindings;\\n\\n\\t\\t\\tfor ( var i = this._targetGroup.nCachedObjects_,\\n\\t\\t\\t\\t\\t  n = bindings.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\tbindings[ i ].unbind();\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\n\\tfunction PropertyBinding( rootNode, path, parsedPath ) {\\n\\n\\t\\tthis.path = path;\\n\\t\\tthis.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );\\n\\n\\t\\tthis.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;\\n\\n\\t\\tthis.rootNode = rootNode;\\n\\n\\t}\\n\\n\\tObject.assign( PropertyBinding, {\\n\\n\\t\\tComposite: Composite,\\n\\n\\t\\tcreate: function ( root, path, parsedPath ) {\\n\\n\\t\\t\\tif ( ! ( root && root.isAnimationObjectGroup ) ) {\\n\\n\\t\\t\\t\\treturn new PropertyBinding( root, path, parsedPath );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\treturn new PropertyBinding.Composite( root, path, parsedPath );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Replaces spaces with underscores and removes unsupported characters from\\n\\t\\t * node names, to ensure compatibility with parseTrackName().\\n\\t\\t *\\n\\t\\t * @param  {string} name Node name to be sanitized.\\n\\t\\t * @return {string}\\n\\t\\t */\\n\\t\\tsanitizeNodeName: function ( name ) {\\n\\n\\t\\t\\treturn name.replace( /\\\\s/g, '_' ).replace( /[^\\\\w-]/g, '' );\\n\\n\\t\\t},\\n\\n\\t\\tparseTrackName: function () {\\n\\n\\t\\t\\t// Parent directories, delimited by '/' or ':'. Currently unused, but must\\n\\t\\t\\t// be matched to parse the rest of the track name.\\n\\t\\t\\tvar directoryRe = /((?:[\\\\w-]+[\\\\/:])*)/;\\n\\n\\t\\t\\t// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\\n\\t\\t\\tvar nodeRe = /([\\\\w-\\\\.]+)?/;\\n\\n\\t\\t\\t// Object on target node, and accessor. Name may contain only word\\n\\t\\t\\t// characters. Accessor may contain any character except closing bracket.\\n\\t\\t\\tvar objectRe = /(?:\\\\.([\\\\w-]+)(?:\\\\[(.+)\\\\])?)?/;\\n\\n\\t\\t\\t// Property and accessor. May contain only word characters. Accessor may\\n\\t\\t\\t// contain any non-bracket characters.\\n\\t\\t\\tvar propertyRe = /\\\\.([\\\\w-]+)(?:\\\\[(.+)\\\\])?/;\\n\\n\\t\\t\\tvar trackRe = new RegExp( ''\\n\\t\\t\\t\\t+ '^'\\n\\t\\t\\t\\t+ directoryRe.source\\n\\t\\t\\t\\t+ nodeRe.source\\n\\t\\t\\t\\t+ objectRe.source\\n\\t\\t\\t\\t+ propertyRe.source\\n\\t\\t\\t\\t+ '$'\\n\\t\\t\\t);\\n\\n\\t\\t\\tvar supportedObjectNames = [ 'material', 'materials', 'bones' ];\\n\\n\\t\\t\\treturn function ( trackName ) {\\n\\n\\t\\t\\t\\tvar matches = trackRe.exec( trackName );\\n\\n\\t\\t\\t\\tif ( ! matches ) {\\n\\n\\t\\t\\t\\t\\tthrow new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar results = {\\n\\t\\t\\t\\t\\t// directoryName: matches[ 1 ], // (tschw) currently unused\\n\\t\\t\\t\\t\\tnodeName: matches[ 2 ],\\n\\t\\t\\t\\t\\tobjectName: matches[ 3 ],\\n\\t\\t\\t\\t\\tobjectIndex: matches[ 4 ],\\n\\t\\t\\t\\t\\tpropertyName: matches[ 5 ], // required\\n\\t\\t\\t\\t\\tpropertyIndex: matches[ 6 ]\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\tvar lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );\\n\\n\\t\\t\\t\\tif ( lastDot !== undefined && lastDot !== - 1 ) {\\n\\n\\t\\t\\t\\t\\tvar objectName = results.nodeName.substring( lastDot + 1 );\\n\\n\\t\\t\\t\\t\\t// Object names must be checked against a whitelist. Otherwise, there\\n\\t\\t\\t\\t\\t// is no way to parse 'foo.bar.baz': 'baz' must be a property, but\\n\\t\\t\\t\\t\\t// 'bar' could be the objectName, or part of a nodeName (which can\\n\\t\\t\\t\\t\\t// include '.' characters).\\n\\t\\t\\t\\t\\tif ( supportedObjectNames.indexOf( objectName ) !== - 1 ) {\\n\\n\\t\\t\\t\\t\\t\\tresults.nodeName = results.nodeName.substring( 0, lastDot );\\n\\t\\t\\t\\t\\t\\tresults.objectName = objectName;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\\n\\n\\t\\t\\t\\t\\tthrow new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn results;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tfindNode: function ( root, nodeName ) {\\n\\n\\t\\t\\tif ( ! nodeName || nodeName === \\\"\\\" || nodeName === \\\"root\\\" || nodeName === \\\".\\\" || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {\\n\\n\\t\\t\\t\\treturn root;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// search into skeleton bones.\\n\\t\\t\\tif ( root.skeleton ) {\\n\\n\\t\\t\\t\\tvar searchSkeleton = function ( skeleton ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < skeleton.bones.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar bone = skeleton.bones[ i ];\\n\\n\\t\\t\\t\\t\\t\\tif ( bone.name === nodeName ) {\\n\\n\\t\\t\\t\\t\\t\\t\\treturn bone;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\tvar bone = searchSkeleton( root.skeleton );\\n\\n\\t\\t\\t\\tif ( bone ) {\\n\\n\\t\\t\\t\\t\\treturn bone;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// search into node subtree.\\n\\t\\t\\tif ( root.children ) {\\n\\n\\t\\t\\t\\tvar searchNodeSubtree = function ( children ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < children.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar childNode = children[ i ];\\n\\n\\t\\t\\t\\t\\t\\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\\n\\n\\t\\t\\t\\t\\t\\t\\treturn childNode;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tvar result = searchNodeSubtree( childNode.children );\\n\\n\\t\\t\\t\\t\\t\\tif ( result ) return result;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\tvar subTreeNode = searchNodeSubtree( root.children );\\n\\n\\t\\t\\t\\tif ( subTreeNode ) {\\n\\n\\t\\t\\t\\t\\treturn subTreeNode;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn null;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( PropertyBinding.prototype, { // prototype, continued\\n\\n\\t\\t// these are used to \\\"bind\\\" a nonexistent property\\n\\t\\t_getValue_unavailable: function () {},\\n\\t\\t_setValue_unavailable: function () {},\\n\\n\\t\\tBindingType: {\\n\\t\\t\\tDirect: 0,\\n\\t\\t\\tEntireArray: 1,\\n\\t\\t\\tArrayElement: 2,\\n\\t\\t\\tHasFromToArray: 3\\n\\t\\t},\\n\\n\\t\\tVersioning: {\\n\\t\\t\\tNone: 0,\\n\\t\\t\\tNeedsUpdate: 1,\\n\\t\\t\\tMatrixWorldNeedsUpdate: 2\\n\\t\\t},\\n\\n\\t\\tGetterByBindingType: [\\n\\n\\t\\t\\tfunction getValue_direct( buffer, offset ) {\\n\\n\\t\\t\\t\\tbuffer[ offset ] = this.node[ this.propertyName ];\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tfunction getValue_array( buffer, offset ) {\\n\\n\\t\\t\\t\\tvar source = this.resolvedProperty;\\n\\n\\t\\t\\t\\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\tbuffer[ offset ++ ] = source[ i ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tfunction getValue_arrayElement( buffer, offset ) {\\n\\n\\t\\t\\t\\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tfunction getValue_toArray( buffer, offset ) {\\n\\n\\t\\t\\t\\tthis.resolvedProperty.toArray( buffer, offset );\\n\\n\\t\\t\\t}\\n\\n\\t\\t],\\n\\n\\t\\tSetterByBindingTypeAndVersioning: [\\n\\n\\t\\t\\t[\\n\\t\\t\\t\\t// Direct\\n\\n\\t\\t\\t\\tfunction setValue_direct( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\\n\\t\\t\\t\\t\\tthis.targetObject.needsUpdate = true;\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\\n\\t\\t\\t\\t\\tthis.targetObject.matrixWorldNeedsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t], [\\n\\n\\t\\t\\t\\t// EntireArray\\n\\n\\t\\t\\t\\tfunction setValue_array( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tvar dest = this.resolvedProperty;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\t\\tdest[ i ] = buffer[ offset ++ ];\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tvar dest = this.resolvedProperty;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\t\\tdest[ i ] = buffer[ offset ++ ];\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tthis.targetObject.needsUpdate = true;\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tvar dest = this.resolvedProperty;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\t\\tdest[ i ] = buffer[ offset ++ ];\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tthis.targetObject.matrixWorldNeedsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t], [\\n\\n\\t\\t\\t\\t// ArrayElement\\n\\n\\t\\t\\t\\tfunction setValue_arrayElement( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\\n\\t\\t\\t\\t\\tthis.targetObject.needsUpdate = true;\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\\n\\t\\t\\t\\t\\tthis.targetObject.matrixWorldNeedsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t], [\\n\\n\\t\\t\\t\\t// HasToFromArray\\n\\n\\t\\t\\t\\tfunction setValue_fromArray( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tthis.resolvedProperty.fromArray( buffer, offset );\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tthis.resolvedProperty.fromArray( buffer, offset );\\n\\t\\t\\t\\t\\tthis.targetObject.needsUpdate = true;\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tthis.resolvedProperty.fromArray( buffer, offset );\\n\\t\\t\\t\\t\\tthis.targetObject.matrixWorldNeedsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t]\\n\\n\\t\\t],\\n\\n\\t\\tgetValue: function getValue_unbound( targetArray, offset ) {\\n\\n\\t\\t\\tthis.bind();\\n\\t\\t\\tthis.getValue( targetArray, offset );\\n\\n\\t\\t\\t// Note: This class uses a State pattern on a per-method basis:\\n\\t\\t\\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\\n\\t\\t\\t// prototype version of these methods with one that represents\\n\\t\\t\\t// the bound state. When the property is not found, the methods\\n\\t\\t\\t// become no-ops.\\n\\n\\t\\t},\\n\\n\\t\\tsetValue: function getValue_unbound( sourceArray, offset ) {\\n\\n\\t\\t\\tthis.bind();\\n\\t\\t\\tthis.setValue( sourceArray, offset );\\n\\n\\t\\t},\\n\\n\\t\\t// create getter / setter pair for a property in the scene graph\\n\\t\\tbind: function () {\\n\\n\\t\\t\\tvar targetObject = this.node,\\n\\t\\t\\t\\tparsedPath = this.parsedPath,\\n\\n\\t\\t\\t\\tobjectName = parsedPath.objectName,\\n\\t\\t\\t\\tpropertyName = parsedPath.propertyName,\\n\\t\\t\\t\\tpropertyIndex = parsedPath.propertyIndex;\\n\\n\\t\\t\\tif ( ! targetObject ) {\\n\\n\\t\\t\\t\\ttargetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;\\n\\n\\t\\t\\t\\tthis.node = targetObject;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// set fail state so we can just 'return' on error\\n\\t\\t\\tthis.getValue = this._getValue_unavailable;\\n\\t\\t\\tthis.setValue = this._setValue_unavailable;\\n\\n\\t\\t\\t// ensure there is a value node\\n\\t\\t\\tif ( ! targetObject ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\\\\'t found.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( objectName ) {\\n\\n\\t\\t\\t\\tvar objectIndex = parsedPath.objectIndex;\\n\\n\\t\\t\\t\\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\\n\\t\\t\\t\\tswitch ( objectName ) {\\n\\n\\t\\t\\t\\t\\tcase 'materials':\\n\\n\\t\\t\\t\\t\\t\\tif ( ! targetObject.material ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif ( ! targetObject.material.materials ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\ttargetObject = targetObject.material.materials;\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'bones':\\n\\n\\t\\t\\t\\t\\t\\tif ( ! targetObject.skeleton ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// potential future optimization: skip this if propertyIndex is already an integer\\n\\t\\t\\t\\t\\t\\t// and convert the integer string to a true integer.\\n\\n\\t\\t\\t\\t\\t\\ttargetObject = targetObject.skeleton.bones;\\n\\n\\t\\t\\t\\t\\t\\t// support resolving morphTarget names into indices.\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < targetObject.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( targetObject[ i ].name === objectIndex ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tobjectIndex = i;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\t\\t\\tif ( targetObject[ objectName ] === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\ttargetObject = targetObject[ objectName ];\\n\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\tif ( objectIndex !== undefined ) {\\n\\n\\t\\t\\t\\t\\tif ( targetObject[ objectIndex ] === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );\\n\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ttargetObject = targetObject[ objectIndex ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// resolve property\\n\\t\\t\\tvar nodeProperty = targetObject[ propertyName ];\\n\\n\\t\\t\\tif ( nodeProperty === undefined ) {\\n\\n\\t\\t\\t\\tvar nodeName = parsedPath.nodeName;\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +\\n\\t\\t\\t\\t\\t'.' + propertyName + ' but it wasn\\\\'t found.', targetObject );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// determine versioning scheme\\n\\t\\t\\tvar versioning = this.Versioning.None;\\n\\n\\t\\t\\tif ( targetObject.needsUpdate !== undefined ) { // material\\n\\n\\t\\t\\t\\tversioning = this.Versioning.NeedsUpdate;\\n\\t\\t\\t\\tthis.targetObject = targetObject;\\n\\n\\t\\t\\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\\n\\n\\t\\t\\t\\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\\n\\t\\t\\t\\tthis.targetObject = targetObject;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// determine how the property gets bound\\n\\t\\t\\tvar bindingType = this.BindingType.Direct;\\n\\n\\t\\t\\tif ( propertyIndex !== undefined ) {\\n\\n\\t\\t\\t\\t// access a sub element of the property array (only primitives are supported right now)\\n\\n\\t\\t\\t\\tif ( propertyName === \\\"morphTargetInfluences\\\" ) {\\n\\n\\t\\t\\t\\t\\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\\n\\n\\t\\t\\t\\t\\t// support resolving morphTarget names into indices.\\n\\t\\t\\t\\t\\tif ( ! targetObject.geometry ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );\\n\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( targetObject.geometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( ! targetObject.geometry.morphAttributes ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tpropertyIndex = i;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tif ( ! targetObject.geometry.morphTargets ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this );\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tpropertyIndex = i;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbindingType = this.BindingType.ArrayElement;\\n\\n\\t\\t\\t\\tthis.resolvedProperty = nodeProperty;\\n\\t\\t\\t\\tthis.propertyIndex = propertyIndex;\\n\\n\\t\\t\\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\\n\\n\\t\\t\\t\\t// must use copy for Object3D.Euler/Quaternion\\n\\n\\t\\t\\t\\tbindingType = this.BindingType.HasFromToArray;\\n\\n\\t\\t\\t\\tthis.resolvedProperty = nodeProperty;\\n\\n\\t\\t\\t} else if ( Array.isArray( nodeProperty ) ) {\\n\\n\\t\\t\\t\\tbindingType = this.BindingType.EntireArray;\\n\\n\\t\\t\\t\\tthis.resolvedProperty = nodeProperty;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.propertyName = propertyName;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// select getter / setter\\n\\t\\t\\tthis.getValue = this.GetterByBindingType[ bindingType ];\\n\\t\\t\\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\\n\\n\\t\\t},\\n\\n\\t\\tunbind: function () {\\n\\n\\t\\t\\tthis.node = null;\\n\\n\\t\\t\\t// back to the prototype version of getValue / setValue\\n\\t\\t\\t// note: avoiding to mutate the shape of 'this' via 'delete'\\n\\t\\t\\tthis.getValue = this._getValue_unbound;\\n\\t\\t\\tthis.setValue = this._setValue_unbound;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//!\\\\ DECLARE ALIAS AFTER assign prototype !\\n\\tObject.assign( PropertyBinding.prototype, {\\n\\n\\t\\t// initial state of these methods that calls 'bind'\\n\\t\\t_getValue_unbound: PropertyBinding.prototype.getValue,\\n\\t\\t_setValue_unbound: PropertyBinding.prototype.setValue,\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * A group of objects that receives a shared animation state.\\n\\t *\\n\\t * Usage:\\n\\t *\\n\\t * \\t-\\tAdd objects you would otherwise pass as 'root' to the\\n\\t * \\t\\tconstructor or the .clipAction method of AnimationMixer.\\n\\t *\\n\\t * \\t-\\tInstead pass this object as 'root'.\\n\\t *\\n\\t * \\t-\\tYou can also add and remove objects later when the mixer\\n\\t * \\t\\tis running.\\n\\t *\\n\\t * Note:\\n\\t *\\n\\t *  \\tObjects of this class appear as one object to the mixer,\\n\\t *  \\tso cache control of the individual objects must be done\\n\\t *  \\ton the group.\\n\\t *\\n\\t * Limitation:\\n\\t *\\n\\t * \\t- \\tThe animated properties must be compatible among the\\n\\t * \\t\\tall objects in the group.\\n\\t *\\n\\t *  -\\tA single property can either be controlled through a\\n\\t *  \\ttarget group or directly, but not both.\\n\\t *\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction AnimationObjectGroup() {\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\t// cached objects followed by the active ones\\n\\t\\tthis._objects = Array.prototype.slice.call( arguments );\\n\\n\\t\\tthis.nCachedObjects_ = 0;\\t\\t\\t// threshold\\n\\t\\t// note: read by PropertyBinding.Composite\\n\\n\\t\\tvar indices = {};\\n\\t\\tthis._indicesByUUID = indices;\\t\\t// for bookkeeping\\n\\n\\t\\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\\n\\n\\t\\t\\tindices[ arguments[ i ].uuid ] = i;\\n\\n\\t\\t}\\n\\n\\t\\tthis._paths = [];\\t\\t\\t\\t\\t// inside: string\\n\\t\\tthis._parsedPaths = [];\\t\\t\\t\\t// inside: { we don't care, here }\\n\\t\\tthis._bindings = []; \\t\\t\\t\\t// inside: Array< PropertyBinding >\\n\\t\\tthis._bindingsIndicesByPath = {}; \\t// inside: indices in these arrays\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\tthis.stats = {\\n\\n\\t\\t\\tobjects: {\\n\\t\\t\\t\\tget total() {\\n\\n\\t\\t\\t\\t\\treturn scope._objects.length;\\n\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tget inUse() {\\n\\n\\t\\t\\t\\t\\treturn this.total - scope.nCachedObjects_;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tget bindingsPerObject() {\\n\\n\\t\\t\\t\\treturn scope._bindings.length;\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\tObject.assign( AnimationObjectGroup.prototype, {\\n\\n\\t\\tisAnimationObjectGroup: true,\\n\\n\\t\\tadd: function () {\\n\\n\\t\\t\\tvar objects = this._objects,\\n\\t\\t\\t\\tnObjects = objects.length,\\n\\t\\t\\t\\tnCachedObjects = this.nCachedObjects_,\\n\\t\\t\\t\\tindicesByUUID = this._indicesByUUID,\\n\\t\\t\\t\\tpaths = this._paths,\\n\\t\\t\\t\\tparsedPaths = this._parsedPaths,\\n\\t\\t\\t\\tbindings = this._bindings,\\n\\t\\t\\t\\tnBindings = bindings.length;\\n\\n\\t\\t\\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\tvar object = arguments[ i ],\\n\\t\\t\\t\\t\\tuuid = object.uuid,\\n\\t\\t\\t\\t\\tindex = indicesByUUID[ uuid ],\\n\\t\\t\\t\\t\\tknownObject = undefined;\\n\\n\\t\\t\\t\\tif ( index === undefined ) {\\n\\n\\t\\t\\t\\t\\t// unknown object -> add it to the ACTIVE region\\n\\n\\t\\t\\t\\t\\tindex = nObjects ++;\\n\\t\\t\\t\\t\\tindicesByUUID[ uuid ] = index;\\n\\t\\t\\t\\t\\tobjects.push( object );\\n\\n\\t\\t\\t\\t\\t// accounting is done, now do the same for all bindings\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\\n\\n\\t\\t\\t\\t\\t\\tbindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( index < nCachedObjects ) {\\n\\n\\t\\t\\t\\t\\tknownObject = objects[ index ];\\n\\n\\t\\t\\t\\t\\t// move existing object to the ACTIVE region\\n\\n\\t\\t\\t\\t\\tvar firstActiveIndex = -- nCachedObjects,\\n\\t\\t\\t\\t\\t\\tlastCachedObject = objects[ firstActiveIndex ];\\n\\n\\t\\t\\t\\t\\tindicesByUUID[ lastCachedObject.uuid ] = index;\\n\\t\\t\\t\\t\\tobjects[ index ] = lastCachedObject;\\n\\n\\t\\t\\t\\t\\tindicesByUUID[ uuid ] = firstActiveIndex;\\n\\t\\t\\t\\t\\tobjects[ firstActiveIndex ] = object;\\n\\n\\t\\t\\t\\t\\t// accounting is done, now do the same for all bindings\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\\n\\n\\t\\t\\t\\t\\t\\tvar bindingsForPath = bindings[ j ],\\n\\t\\t\\t\\t\\t\\t\\tlastCached = bindingsForPath[ firstActiveIndex ],\\n\\t\\t\\t\\t\\t\\t\\tbinding = bindingsForPath[ index ];\\n\\n\\t\\t\\t\\t\\t\\tbindingsForPath[ index ] = lastCached;\\n\\n\\t\\t\\t\\t\\t\\tif ( binding === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// since we do not bother to create new bindings\\n\\t\\t\\t\\t\\t\\t\\t// for objects that are cached, the binding may\\n\\t\\t\\t\\t\\t\\t\\t// or may not exist\\n\\n\\t\\t\\t\\t\\t\\t\\tbinding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tbindingsForPath[ firstActiveIndex ] = binding;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( objects[ index ] !== knownObject ) {\\n\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +\\n\\t\\t\\t\\t\\t\\t\\t'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );\\n\\n\\t\\t\\t\\t} // else the object is already where we want it to be\\n\\n\\t\\t\\t} // for arguments\\n\\n\\t\\t\\tthis.nCachedObjects_ = nCachedObjects;\\n\\n\\t\\t},\\n\\n\\t\\tremove: function () {\\n\\n\\t\\t\\tvar objects = this._objects,\\n\\t\\t\\t\\tnCachedObjects = this.nCachedObjects_,\\n\\t\\t\\t\\tindicesByUUID = this._indicesByUUID,\\n\\t\\t\\t\\tbindings = this._bindings,\\n\\t\\t\\t\\tnBindings = bindings.length;\\n\\n\\t\\t\\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\tvar object = arguments[ i ],\\n\\t\\t\\t\\t\\tuuid = object.uuid,\\n\\t\\t\\t\\t\\tindex = indicesByUUID[ uuid ];\\n\\n\\t\\t\\t\\tif ( index !== undefined && index >= nCachedObjects ) {\\n\\n\\t\\t\\t\\t\\t// move existing object into the CACHED region\\n\\n\\t\\t\\t\\t\\tvar lastCachedIndex = nCachedObjects ++,\\n\\t\\t\\t\\t\\t\\tfirstActiveObject = objects[ lastCachedIndex ];\\n\\n\\t\\t\\t\\t\\tindicesByUUID[ firstActiveObject.uuid ] = index;\\n\\t\\t\\t\\t\\tobjects[ index ] = firstActiveObject;\\n\\n\\t\\t\\t\\t\\tindicesByUUID[ uuid ] = lastCachedIndex;\\n\\t\\t\\t\\t\\tobjects[ lastCachedIndex ] = object;\\n\\n\\t\\t\\t\\t\\t// accounting is done, now do the same for all bindings\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\\n\\n\\t\\t\\t\\t\\t\\tvar bindingsForPath = bindings[ j ],\\n\\t\\t\\t\\t\\t\\t\\tfirstActive = bindingsForPath[ lastCachedIndex ],\\n\\t\\t\\t\\t\\t\\t\\tbinding = bindingsForPath[ index ];\\n\\n\\t\\t\\t\\t\\t\\tbindingsForPath[ index ] = firstActive;\\n\\t\\t\\t\\t\\t\\tbindingsForPath[ lastCachedIndex ] = binding;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} // for arguments\\n\\n\\t\\t\\tthis.nCachedObjects_ = nCachedObjects;\\n\\n\\t\\t},\\n\\n\\t\\t// remove & forget\\n\\t\\tuncache: function () {\\n\\n\\t\\t\\tvar objects = this._objects,\\n\\t\\t\\t\\tnObjects = objects.length,\\n\\t\\t\\t\\tnCachedObjects = this.nCachedObjects_,\\n\\t\\t\\t\\tindicesByUUID = this._indicesByUUID,\\n\\t\\t\\t\\tbindings = this._bindings,\\n\\t\\t\\t\\tnBindings = bindings.length;\\n\\n\\t\\t\\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\tvar object = arguments[ i ],\\n\\t\\t\\t\\t\\tuuid = object.uuid,\\n\\t\\t\\t\\t\\tindex = indicesByUUID[ uuid ];\\n\\n\\t\\t\\t\\tif ( index !== undefined ) {\\n\\n\\t\\t\\t\\t\\tdelete indicesByUUID[ uuid ];\\n\\n\\t\\t\\t\\t\\tif ( index < nCachedObjects ) {\\n\\n\\t\\t\\t\\t\\t\\t// object is cached, shrink the CACHED region\\n\\n\\t\\t\\t\\t\\t\\tvar firstActiveIndex = -- nCachedObjects,\\n\\t\\t\\t\\t\\t\\t\\tlastCachedObject = objects[ firstActiveIndex ],\\n\\t\\t\\t\\t\\t\\t\\tlastIndex = -- nObjects,\\n\\t\\t\\t\\t\\t\\t\\tlastObject = objects[ lastIndex ];\\n\\n\\t\\t\\t\\t\\t\\t// last cached object takes this object's place\\n\\t\\t\\t\\t\\t\\tindicesByUUID[ lastCachedObject.uuid ] = index;\\n\\t\\t\\t\\t\\t\\tobjects[ index ] = lastCachedObject;\\n\\n\\t\\t\\t\\t\\t\\t// last object goes to the activated slot and pop\\n\\t\\t\\t\\t\\t\\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\\n\\t\\t\\t\\t\\t\\tobjects[ firstActiveIndex ] = lastObject;\\n\\t\\t\\t\\t\\t\\tobjects.pop();\\n\\n\\t\\t\\t\\t\\t\\t// accounting is done, now do the same for all bindings\\n\\n\\t\\t\\t\\t\\t\\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar bindingsForPath = bindings[ j ],\\n\\t\\t\\t\\t\\t\\t\\t\\tlastCached = bindingsForPath[ firstActiveIndex ],\\n\\t\\t\\t\\t\\t\\t\\t\\tlast = bindingsForPath[ lastIndex ];\\n\\n\\t\\t\\t\\t\\t\\t\\tbindingsForPath[ index ] = lastCached;\\n\\t\\t\\t\\t\\t\\t\\tbindingsForPath[ firstActiveIndex ] = last;\\n\\t\\t\\t\\t\\t\\t\\tbindingsForPath.pop();\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t// object is active, just swap with the last and pop\\n\\n\\t\\t\\t\\t\\t\\tvar lastIndex = -- nObjects,\\n\\t\\t\\t\\t\\t\\t\\tlastObject = objects[ lastIndex ];\\n\\n\\t\\t\\t\\t\\t\\tindicesByUUID[ lastObject.uuid ] = index;\\n\\t\\t\\t\\t\\t\\tobjects[ index ] = lastObject;\\n\\t\\t\\t\\t\\t\\tobjects.pop();\\n\\n\\t\\t\\t\\t\\t\\t// accounting is done, now do the same for all bindings\\n\\n\\t\\t\\t\\t\\t\\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar bindingsForPath = bindings[ j ];\\n\\n\\t\\t\\t\\t\\t\\t\\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\\n\\t\\t\\t\\t\\t\\t\\tbindingsForPath.pop();\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} // cached or active\\n\\n\\t\\t\\t\\t} // if object is known\\n\\n\\t\\t\\t} // for arguments\\n\\n\\t\\t\\tthis.nCachedObjects_ = nCachedObjects;\\n\\n\\t\\t},\\n\\n\\t\\t// Internal interface used by befriended PropertyBinding.Composite:\\n\\n\\t\\tsubscribe_: function ( path, parsedPath ) {\\n\\n\\t\\t\\t// returns an array of bindings for the given path that is changed\\n\\t\\t\\t// according to the contained objects in the group\\n\\n\\t\\t\\tvar indicesByPath = this._bindingsIndicesByPath,\\n\\t\\t\\t\\tindex = indicesByPath[ path ],\\n\\t\\t\\t\\tbindings = this._bindings;\\n\\n\\t\\t\\tif ( index !== undefined ) return bindings[ index ];\\n\\n\\t\\t\\tvar paths = this._paths,\\n\\t\\t\\t\\tparsedPaths = this._parsedPaths,\\n\\t\\t\\t\\tobjects = this._objects,\\n\\t\\t\\t\\tnObjects = objects.length,\\n\\t\\t\\t\\tnCachedObjects = this.nCachedObjects_,\\n\\t\\t\\t\\tbindingsForPath = new Array( nObjects );\\n\\n\\t\\t\\tindex = bindings.length;\\n\\n\\t\\t\\tindicesByPath[ path ] = index;\\n\\n\\t\\t\\tpaths.push( path );\\n\\t\\t\\tparsedPaths.push( parsedPath );\\n\\t\\t\\tbindings.push( bindingsForPath );\\n\\n\\t\\t\\tfor ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\tvar object = objects[ i ];\\n\\t\\t\\t\\tbindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn bindingsForPath;\\n\\n\\t\\t},\\n\\n\\t\\tunsubscribe_: function ( path ) {\\n\\n\\t\\t\\t// tells the group to forget about a property path and no longer\\n\\t\\t\\t// update the array previously obtained with 'subscribe_'\\n\\n\\t\\t\\tvar indicesByPath = this._bindingsIndicesByPath,\\n\\t\\t\\t\\tindex = indicesByPath[ path ];\\n\\n\\t\\t\\tif ( index !== undefined ) {\\n\\n\\t\\t\\t\\tvar paths = this._paths,\\n\\t\\t\\t\\t\\tparsedPaths = this._parsedPaths,\\n\\t\\t\\t\\t\\tbindings = this._bindings,\\n\\t\\t\\t\\t\\tlastBindingsIndex = bindings.length - 1,\\n\\t\\t\\t\\t\\tlastBindings = bindings[ lastBindingsIndex ],\\n\\t\\t\\t\\t\\tlastBindingsPath = path[ lastBindingsIndex ];\\n\\n\\t\\t\\t\\tindicesByPath[ lastBindingsPath ] = index;\\n\\n\\t\\t\\t\\tbindings[ index ] = lastBindings;\\n\\t\\t\\t\\tbindings.pop();\\n\\n\\t\\t\\t\\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\\n\\t\\t\\t\\tparsedPaths.pop();\\n\\n\\t\\t\\t\\tpaths[ index ] = paths[ lastBindingsIndex ];\\n\\t\\t\\t\\tpaths.pop();\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * Action provided by AnimationMixer for scheduling clip playback on specific\\n\\t * objects.\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t *\\n\\t */\\n\\n\\tfunction AnimationAction( mixer, clip, localRoot ) {\\n\\n\\t\\tthis._mixer = mixer;\\n\\t\\tthis._clip = clip;\\n\\t\\tthis._localRoot = localRoot || null;\\n\\n\\t\\tvar tracks = clip.tracks,\\n\\t\\t\\tnTracks = tracks.length,\\n\\t\\t\\tinterpolants = new Array( nTracks );\\n\\n\\t\\tvar interpolantSettings = {\\n\\t\\t\\tendingStart: ZeroCurvatureEnding,\\n\\t\\t\\tendingEnd: ZeroCurvatureEnding\\n\\t\\t};\\n\\n\\t\\tfor ( var i = 0; i !== nTracks; ++ i ) {\\n\\n\\t\\t\\tvar interpolant = tracks[ i ].createInterpolant( null );\\n\\t\\t\\tinterpolants[ i ] = interpolant;\\n\\t\\t\\tinterpolant.settings = interpolantSettings;\\n\\n\\t\\t}\\n\\n\\t\\tthis._interpolantSettings = interpolantSettings;\\n\\n\\t\\tthis._interpolants = interpolants;\\t// bound by the mixer\\n\\n\\t\\t// inside: PropertyMixer (managed by the mixer)\\n\\t\\tthis._propertyBindings = new Array( nTracks );\\n\\n\\t\\tthis._cacheIndex = null;\\t\\t\\t// for the memory manager\\n\\t\\tthis._byClipCacheIndex = null;\\t\\t// for the memory manager\\n\\n\\t\\tthis._timeScaleInterpolant = null;\\n\\t\\tthis._weightInterpolant = null;\\n\\n\\t\\tthis.loop = LoopRepeat;\\n\\t\\tthis._loopCount = - 1;\\n\\n\\t\\t// global mixer time when the action is to be started\\n\\t\\t// it's set back to 'null' upon start of the action\\n\\t\\tthis._startTime = null;\\n\\n\\t\\t// scaled local time of the action\\n\\t\\t// gets clamped or wrapped to 0..clip.duration according to loop\\n\\t\\tthis.time = 0;\\n\\n\\t\\tthis.timeScale = 1;\\n\\t\\tthis._effectiveTimeScale = 1;\\n\\n\\t\\tthis.weight = 1;\\n\\t\\tthis._effectiveWeight = 1;\\n\\n\\t\\tthis.repetitions = Infinity; \\t\\t// no. of repetitions when looping\\n\\n\\t\\tthis.paused = false;\\t\\t\\t\\t// true -> zero effective time scale\\n\\t\\tthis.enabled = true;\\t\\t\\t\\t// false -> zero effective weight\\n\\n\\t\\tthis.clampWhenFinished \\t= false;\\t// keep feeding the last frame?\\n\\n\\t\\tthis.zeroSlopeAtStart \\t= true;\\t\\t// for smooth interpolation w/o separate\\n\\t\\tthis.zeroSlopeAtEnd\\t\\t= true;\\t\\t// clips for start, loop and end\\n\\n\\t}\\n\\n\\tObject.assign( AnimationAction.prototype, {\\n\\n\\t\\t// State & Scheduling\\n\\n\\t\\tplay: function () {\\n\\n\\t\\t\\tthis._mixer._activateAction( this );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tstop: function () {\\n\\n\\t\\t\\tthis._mixer._deactivateAction( this );\\n\\n\\t\\t\\treturn this.reset();\\n\\n\\t\\t},\\n\\n\\t\\treset: function () {\\n\\n\\t\\t\\tthis.paused = false;\\n\\t\\t\\tthis.enabled = true;\\n\\n\\t\\t\\tthis.time = 0;\\t\\t\\t// restart clip\\n\\t\\t\\tthis._loopCount = - 1;\\t// forget previous loops\\n\\t\\t\\tthis._startTime = null;\\t// forget scheduling\\n\\n\\t\\t\\treturn this.stopFading().stopWarping();\\n\\n\\t\\t},\\n\\n\\t\\tisRunning: function () {\\n\\n\\t\\t\\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\\n\\t\\t\\t\\t\\tthis._startTime === null && this._mixer._isActiveAction( this );\\n\\n\\t\\t},\\n\\n\\t\\t// return true when play has been called\\n\\t\\tisScheduled: function () {\\n\\n\\t\\t\\treturn this._mixer._isActiveAction( this );\\n\\n\\t\\t},\\n\\n\\t\\tstartAt: function ( time ) {\\n\\n\\t\\t\\tthis._startTime = time;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetLoop: function ( mode, repetitions ) {\\n\\n\\t\\t\\tthis.loop = mode;\\n\\t\\t\\tthis.repetitions = repetitions;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t// Weight\\n\\n\\t\\t// set the weight stopping any scheduled fading\\n\\t\\t// although .enabled = false yields an effective weight of zero, this\\n\\t\\t// method does *not* change .enabled, because it would be confusing\\n\\t\\tsetEffectiveWeight: function ( weight ) {\\n\\n\\t\\t\\tthis.weight = weight;\\n\\n\\t\\t\\t// note: same logic as when updated at runtime\\n\\t\\t\\tthis._effectiveWeight = this.enabled ? weight : 0;\\n\\n\\t\\t\\treturn this.stopFading();\\n\\n\\t\\t},\\n\\n\\t\\t// return the weight considering fading and .enabled\\n\\t\\tgetEffectiveWeight: function () {\\n\\n\\t\\t\\treturn this._effectiveWeight;\\n\\n\\t\\t},\\n\\n\\t\\tfadeIn: function ( duration ) {\\n\\n\\t\\t\\treturn this._scheduleFading( duration, 0, 1 );\\n\\n\\t\\t},\\n\\n\\t\\tfadeOut: function ( duration ) {\\n\\n\\t\\t\\treturn this._scheduleFading( duration, 1, 0 );\\n\\n\\t\\t},\\n\\n\\t\\tcrossFadeFrom: function ( fadeOutAction, duration, warp ) {\\n\\n\\t\\t\\tfadeOutAction.fadeOut( duration );\\n\\t\\t\\tthis.fadeIn( duration );\\n\\n\\t\\t\\tif ( warp ) {\\n\\n\\t\\t\\t\\tvar fadeInDuration = this._clip.duration,\\n\\t\\t\\t\\t\\tfadeOutDuration = fadeOutAction._clip.duration,\\n\\n\\t\\t\\t\\t\\tstartEndRatio = fadeOutDuration / fadeInDuration,\\n\\t\\t\\t\\t\\tendStartRatio = fadeInDuration / fadeOutDuration;\\n\\n\\t\\t\\t\\tfadeOutAction.warp( 1.0, startEndRatio, duration );\\n\\t\\t\\t\\tthis.warp( endStartRatio, 1.0, duration );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcrossFadeTo: function ( fadeInAction, duration, warp ) {\\n\\n\\t\\t\\treturn fadeInAction.crossFadeFrom( this, duration, warp );\\n\\n\\t\\t},\\n\\n\\t\\tstopFading: function () {\\n\\n\\t\\t\\tvar weightInterpolant = this._weightInterpolant;\\n\\n\\t\\t\\tif ( weightInterpolant !== null ) {\\n\\n\\t\\t\\t\\tthis._weightInterpolant = null;\\n\\t\\t\\t\\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t// Time Scale Control\\n\\n\\t\\t// set the time scale stopping any scheduled warping\\n\\t\\t// although .paused = true yields an effective time scale of zero, this\\n\\t\\t// method does *not* change .paused, because it would be confusing\\n\\t\\tsetEffectiveTimeScale: function ( timeScale ) {\\n\\n\\t\\t\\tthis.timeScale = timeScale;\\n\\t\\t\\tthis._effectiveTimeScale = this.paused ? 0 : timeScale;\\n\\n\\t\\t\\treturn this.stopWarping();\\n\\n\\t\\t},\\n\\n\\t\\t// return the time scale considering warping and .paused\\n\\t\\tgetEffectiveTimeScale: function () {\\n\\n\\t\\t\\treturn this._effectiveTimeScale;\\n\\n\\t\\t},\\n\\n\\t\\tsetDuration: function ( duration ) {\\n\\n\\t\\t\\tthis.timeScale = this._clip.duration / duration;\\n\\n\\t\\t\\treturn this.stopWarping();\\n\\n\\t\\t},\\n\\n\\t\\tsyncWith: function ( action ) {\\n\\n\\t\\t\\tthis.time = action.time;\\n\\t\\t\\tthis.timeScale = action.timeScale;\\n\\n\\t\\t\\treturn this.stopWarping();\\n\\n\\t\\t},\\n\\n\\t\\thalt: function ( duration ) {\\n\\n\\t\\t\\treturn this.warp( this._effectiveTimeScale, 0, duration );\\n\\n\\t\\t},\\n\\n\\t\\twarp: function ( startTimeScale, endTimeScale, duration ) {\\n\\n\\t\\t\\tvar mixer = this._mixer, now = mixer.time,\\n\\t\\t\\t\\tinterpolant = this._timeScaleInterpolant,\\n\\n\\t\\t\\t\\ttimeScale = this.timeScale;\\n\\n\\t\\t\\tif ( interpolant === null ) {\\n\\n\\t\\t\\t\\tinterpolant = mixer._lendControlInterpolant();\\n\\t\\t\\t\\tthis._timeScaleInterpolant = interpolant;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar times = interpolant.parameterPositions,\\n\\t\\t\\t\\tvalues = interpolant.sampleValues;\\n\\n\\t\\t\\ttimes[ 0 ] = now;\\n\\t\\t\\ttimes[ 1 ] = now + duration;\\n\\n\\t\\t\\tvalues[ 0 ] = startTimeScale / timeScale;\\n\\t\\t\\tvalues[ 1 ] = endTimeScale / timeScale;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tstopWarping: function () {\\n\\n\\t\\t\\tvar timeScaleInterpolant = this._timeScaleInterpolant;\\n\\n\\t\\t\\tif ( timeScaleInterpolant !== null ) {\\n\\n\\t\\t\\t\\tthis._timeScaleInterpolant = null;\\n\\t\\t\\t\\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t// Object Accessors\\n\\n\\t\\tgetMixer: function () {\\n\\n\\t\\t\\treturn this._mixer;\\n\\n\\t\\t},\\n\\n\\t\\tgetClip: function () {\\n\\n\\t\\t\\treturn this._clip;\\n\\n\\t\\t},\\n\\n\\t\\tgetRoot: function () {\\n\\n\\t\\t\\treturn this._localRoot || this._mixer._root;\\n\\n\\t\\t},\\n\\n\\t\\t// Interna\\n\\n\\t\\t_update: function ( time, deltaTime, timeDirection, accuIndex ) {\\n\\n\\t\\t\\t// called by the mixer\\n\\n\\t\\t\\tif ( ! this.enabled ) {\\n\\n\\t\\t\\t\\t// call ._updateWeight() to update ._effectiveWeight\\n\\n\\t\\t\\t\\tthis._updateWeight( time );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar startTime = this._startTime;\\n\\n\\t\\t\\tif ( startTime !== null ) {\\n\\n\\t\\t\\t\\t// check for scheduled start of action\\n\\n\\t\\t\\t\\tvar timeRunning = ( time - startTime ) * timeDirection;\\n\\t\\t\\t\\tif ( timeRunning < 0 || timeDirection === 0 ) {\\n\\n\\t\\t\\t\\t\\treturn; // yet to come / don't decide when delta = 0\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// start\\n\\n\\t\\t\\t\\tthis._startTime = null; // unschedule\\n\\t\\t\\t\\tdeltaTime = timeDirection * timeRunning;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// apply time scale and advance time\\n\\n\\t\\t\\tdeltaTime *= this._updateTimeScale( time );\\n\\t\\t\\tvar clipTime = this._updateTime( deltaTime );\\n\\n\\t\\t\\t// note: _updateTime may disable the action resulting in\\n\\t\\t\\t// an effective weight of 0\\n\\n\\t\\t\\tvar weight = this._updateWeight( time );\\n\\n\\t\\t\\tif ( weight > 0 ) {\\n\\n\\t\\t\\t\\tvar interpolants = this._interpolants;\\n\\t\\t\\t\\tvar propertyMixers = this._propertyBindings;\\n\\n\\t\\t\\t\\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\\n\\n\\t\\t\\t\\t\\tinterpolants[ j ].evaluate( clipTime );\\n\\t\\t\\t\\t\\tpropertyMixers[ j ].accumulate( accuIndex, weight );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t_updateWeight: function ( time ) {\\n\\n\\t\\t\\tvar weight = 0;\\n\\n\\t\\t\\tif ( this.enabled ) {\\n\\n\\t\\t\\t\\tweight = this.weight;\\n\\t\\t\\t\\tvar interpolant = this._weightInterpolant;\\n\\n\\t\\t\\t\\tif ( interpolant !== null ) {\\n\\n\\t\\t\\t\\t\\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\\n\\n\\t\\t\\t\\t\\tweight *= interpolantValue;\\n\\n\\t\\t\\t\\t\\tif ( time > interpolant.parameterPositions[ 1 ] ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.stopFading();\\n\\n\\t\\t\\t\\t\\t\\tif ( interpolantValue === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// faded out, disable\\n\\t\\t\\t\\t\\t\\t\\tthis.enabled = false;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._effectiveWeight = weight;\\n\\t\\t\\treturn weight;\\n\\n\\t\\t},\\n\\n\\t\\t_updateTimeScale: function ( time ) {\\n\\n\\t\\t\\tvar timeScale = 0;\\n\\n\\t\\t\\tif ( ! this.paused ) {\\n\\n\\t\\t\\t\\ttimeScale = this.timeScale;\\n\\n\\t\\t\\t\\tvar interpolant = this._timeScaleInterpolant;\\n\\n\\t\\t\\t\\tif ( interpolant !== null ) {\\n\\n\\t\\t\\t\\t\\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\\n\\n\\t\\t\\t\\t\\ttimeScale *= interpolantValue;\\n\\n\\t\\t\\t\\t\\tif ( time > interpolant.parameterPositions[ 1 ] ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.stopWarping();\\n\\n\\t\\t\\t\\t\\t\\tif ( timeScale === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// motion has halted, pause\\n\\t\\t\\t\\t\\t\\t\\tthis.paused = true;\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t// warp done - apply final time scale\\n\\t\\t\\t\\t\\t\\t\\tthis.timeScale = timeScale;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._effectiveTimeScale = timeScale;\\n\\t\\t\\treturn timeScale;\\n\\n\\t\\t},\\n\\n\\t\\t_updateTime: function ( deltaTime ) {\\n\\n\\t\\t\\tvar time = this.time + deltaTime;\\n\\n\\t\\t\\tif ( deltaTime === 0 ) return time;\\n\\n\\t\\t\\tvar duration = this._clip.duration,\\n\\n\\t\\t\\t\\tloop = this.loop,\\n\\t\\t\\t\\tloopCount = this._loopCount;\\n\\n\\t\\t\\tif ( loop === LoopOnce ) {\\n\\n\\t\\t\\t\\tif ( loopCount === - 1 ) {\\n\\n\\t\\t\\t\\t\\t// just started\\n\\n\\t\\t\\t\\t\\tthis._loopCount = 0;\\n\\t\\t\\t\\t\\tthis._setEndings( true, true, false );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\thandle_stop: {\\n\\n\\t\\t\\t\\t\\tif ( time >= duration ) {\\n\\n\\t\\t\\t\\t\\t\\ttime = duration;\\n\\n\\t\\t\\t\\t\\t} else if ( time < 0 ) {\\n\\n\\t\\t\\t\\t\\t\\ttime = 0;\\n\\n\\t\\t\\t\\t\\t} else break handle_stop;\\n\\n\\t\\t\\t\\t\\tif ( this.clampWhenFinished ) this.paused = true;\\n\\t\\t\\t\\t\\telse this.enabled = false;\\n\\n\\t\\t\\t\\t\\tthis._mixer.dispatchEvent( {\\n\\t\\t\\t\\t\\t\\ttype: 'finished', action: this,\\n\\t\\t\\t\\t\\t\\tdirection: deltaTime < 0 ? - 1 : 1\\n\\t\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else { // repetitive Repeat or PingPong\\n\\n\\t\\t\\t\\tvar pingPong = ( loop === LoopPingPong );\\n\\n\\t\\t\\t\\tif ( loopCount === - 1 ) {\\n\\n\\t\\t\\t\\t\\t// just started\\n\\n\\t\\t\\t\\t\\tif ( deltaTime >= 0 ) {\\n\\n\\t\\t\\t\\t\\t\\tloopCount = 0;\\n\\n\\t\\t\\t\\t\\t\\tthis._setEndings( true, this.repetitions === 0, pingPong );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t// when looping in reverse direction, the initial\\n\\t\\t\\t\\t\\t\\t// transition through zero counts as a repetition,\\n\\t\\t\\t\\t\\t\\t// so leave loopCount at -1\\n\\n\\t\\t\\t\\t\\t\\tthis._setEndings( this.repetitions === 0, true, pingPong );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( time >= duration || time < 0 ) {\\n\\n\\t\\t\\t\\t\\t// wrap around\\n\\n\\t\\t\\t\\t\\tvar loopDelta = Math.floor( time / duration ); // signed\\n\\t\\t\\t\\t\\ttime -= duration * loopDelta;\\n\\n\\t\\t\\t\\t\\tloopCount += Math.abs( loopDelta );\\n\\n\\t\\t\\t\\t\\tvar pending = this.repetitions - loopCount;\\n\\n\\t\\t\\t\\t\\tif ( pending < 0 ) {\\n\\n\\t\\t\\t\\t\\t\\t// have to stop (switch state, clamp time, fire event)\\n\\n\\t\\t\\t\\t\\t\\tif ( this.clampWhenFinished ) this.paused = true;\\n\\t\\t\\t\\t\\t\\telse this.enabled = false;\\n\\n\\t\\t\\t\\t\\t\\ttime = deltaTime > 0 ? duration : 0;\\n\\n\\t\\t\\t\\t\\t\\tthis._mixer.dispatchEvent( {\\n\\t\\t\\t\\t\\t\\t\\ttype: 'finished', action: this,\\n\\t\\t\\t\\t\\t\\t\\tdirection: deltaTime > 0 ? 1 : - 1\\n\\t\\t\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t// keep running\\n\\n\\t\\t\\t\\t\\t\\tif ( pending === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// entering the last round\\n\\n\\t\\t\\t\\t\\t\\t\\tvar atStart = deltaTime < 0;\\n\\t\\t\\t\\t\\t\\t\\tthis._setEndings( atStart, ! atStart, pingPong );\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tthis._setEndings( false, false, pingPong );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tthis._loopCount = loopCount;\\n\\n\\t\\t\\t\\t\\t\\tthis._mixer.dispatchEvent( {\\n\\t\\t\\t\\t\\t\\t\\ttype: 'loop', action: this, loopDelta: loopDelta\\n\\t\\t\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\\n\\n\\t\\t\\t\\t\\t// invert time for the \\\"pong round\\\"\\n\\n\\t\\t\\t\\t\\tthis.time = time;\\n\\t\\t\\t\\t\\treturn duration - time;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.time = time;\\n\\t\\t\\treturn time;\\n\\n\\t\\t},\\n\\n\\t\\t_setEndings: function ( atStart, atEnd, pingPong ) {\\n\\n\\t\\t\\tvar settings = this._interpolantSettings;\\n\\n\\t\\t\\tif ( pingPong ) {\\n\\n\\t\\t\\t\\tsettings.endingStart \\t= ZeroSlopeEnding;\\n\\t\\t\\t\\tsettings.endingEnd\\t\\t= ZeroSlopeEnding;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// assuming for LoopOnce atStart == atEnd == true\\n\\n\\t\\t\\t\\tif ( atStart ) {\\n\\n\\t\\t\\t\\t\\tsettings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tsettings.endingStart = WrapAroundEnding;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( atEnd ) {\\n\\n\\t\\t\\t\\t\\tsettings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tsettings.endingEnd \\t = WrapAroundEnding;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t_scheduleFading: function ( duration, weightNow, weightThen ) {\\n\\n\\t\\t\\tvar mixer = this._mixer, now = mixer.time,\\n\\t\\t\\t\\tinterpolant = this._weightInterpolant;\\n\\n\\t\\t\\tif ( interpolant === null ) {\\n\\n\\t\\t\\t\\tinterpolant = mixer._lendControlInterpolant();\\n\\t\\t\\t\\tthis._weightInterpolant = interpolant;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar times = interpolant.parameterPositions,\\n\\t\\t\\t\\tvalues = interpolant.sampleValues;\\n\\n\\t\\t\\ttimes[ 0 ] = now; \\t\\t\\t\\tvalues[ 0 ] = weightNow;\\n\\t\\t\\ttimes[ 1 ] = now + duration;\\tvalues[ 1 ] = weightThen;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * Player for AnimationClips.\\n\\t *\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction AnimationMixer( root ) {\\n\\n\\t\\tthis._root = root;\\n\\t\\tthis._initMemoryManager();\\n\\t\\tthis._accuIndex = 0;\\n\\n\\t\\tthis.time = 0;\\n\\n\\t\\tthis.timeScale = 1.0;\\n\\n\\t}\\n\\n\\tAnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\n\\n\\t\\tconstructor: AnimationMixer,\\n\\n\\t\\t_bindAction: function ( action, prototypeAction ) {\\n\\n\\t\\t\\tvar root = action._localRoot || this._root,\\n\\t\\t\\t\\ttracks = action._clip.tracks,\\n\\t\\t\\t\\tnTracks = tracks.length,\\n\\t\\t\\t\\tbindings = action._propertyBindings,\\n\\t\\t\\t\\tinterpolants = action._interpolants,\\n\\t\\t\\t\\trootUuid = root.uuid,\\n\\t\\t\\t\\tbindingsByRoot = this._bindingsByRootAndName,\\n\\t\\t\\t\\tbindingsByName = bindingsByRoot[ rootUuid ];\\n\\n\\t\\t\\tif ( bindingsByName === undefined ) {\\n\\n\\t\\t\\t\\tbindingsByName = {};\\n\\t\\t\\t\\tbindingsByRoot[ rootUuid ] = bindingsByName;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var i = 0; i !== nTracks; ++ i ) {\\n\\n\\t\\t\\t\\tvar track = tracks[ i ],\\n\\t\\t\\t\\t\\ttrackName = track.name,\\n\\t\\t\\t\\t\\tbinding = bindingsByName[ trackName ];\\n\\n\\t\\t\\t\\tif ( binding !== undefined ) {\\n\\n\\t\\t\\t\\t\\tbindings[ i ] = binding;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tbinding = bindings[ i ];\\n\\n\\t\\t\\t\\t\\tif ( binding !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t// existing binding, make sure the cache knows\\n\\n\\t\\t\\t\\t\\t\\tif ( binding._cacheIndex === null ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t++ binding.referenceCount;\\n\\t\\t\\t\\t\\t\\t\\tthis._addInactiveBinding( binding, rootUuid, trackName );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvar path = prototypeAction && prototypeAction.\\n\\t\\t\\t\\t\\t\\t_propertyBindings[ i ].binding.parsedPath;\\n\\n\\t\\t\\t\\t\\tbinding = new PropertyMixer(\\n\\t\\t\\t\\t\\t\\tPropertyBinding.create( root, trackName, path ),\\n\\t\\t\\t\\t\\t\\ttrack.ValueTypeName, track.getValueSize() );\\n\\n\\t\\t\\t\\t\\t++ binding.referenceCount;\\n\\t\\t\\t\\t\\tthis._addInactiveBinding( binding, rootUuid, trackName );\\n\\n\\t\\t\\t\\t\\tbindings[ i ] = binding;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tinterpolants[ i ].resultBuffer = binding.buffer;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t_activateAction: function ( action ) {\\n\\n\\t\\t\\tif ( ! this._isActiveAction( action ) ) {\\n\\n\\t\\t\\t\\tif ( action._cacheIndex === null ) {\\n\\n\\t\\t\\t\\t\\t// this action has been forgotten by the cache, but the user\\n\\t\\t\\t\\t\\t// appears to be still using it -> rebind\\n\\n\\t\\t\\t\\t\\tvar rootUuid = ( action._localRoot || this._root ).uuid,\\n\\t\\t\\t\\t\\t\\tclipUuid = action._clip.uuid,\\n\\t\\t\\t\\t\\t\\tactionsForClip = this._actionsByClip[ clipUuid ];\\n\\n\\t\\t\\t\\t\\tthis._bindAction( action,\\n\\t\\t\\t\\t\\t\\tactionsForClip && actionsForClip.knownActions[ 0 ] );\\n\\n\\t\\t\\t\\t\\tthis._addInactiveAction( action, clipUuid, rootUuid );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar bindings = action._propertyBindings;\\n\\n\\t\\t\\t\\t// increment reference counts / sort out state\\n\\t\\t\\t\\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\tvar binding = bindings[ i ];\\n\\n\\t\\t\\t\\t\\tif ( binding.useCount ++ === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\tthis._lendBinding( binding );\\n\\t\\t\\t\\t\\t\\tbinding.saveOriginalState();\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis._lendAction( action );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t_deactivateAction: function ( action ) {\\n\\n\\t\\t\\tif ( this._isActiveAction( action ) ) {\\n\\n\\t\\t\\t\\tvar bindings = action._propertyBindings;\\n\\n\\t\\t\\t\\t// decrement reference counts / sort out state\\n\\t\\t\\t\\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\tvar binding = bindings[ i ];\\n\\n\\t\\t\\t\\t\\tif ( -- binding.useCount === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\tbinding.restoreOriginalState();\\n\\t\\t\\t\\t\\t\\tthis._takeBackBinding( binding );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis._takeBackAction( action );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t// Memory manager\\n\\n\\t\\t_initMemoryManager: function () {\\n\\n\\t\\t\\tthis._actions = []; // 'nActiveActions' followed by inactive ones\\n\\t\\t\\tthis._nActiveActions = 0;\\n\\n\\t\\t\\tthis._actionsByClip = {};\\n\\t\\t\\t// inside:\\n\\t\\t\\t// {\\n\\t\\t\\t// \\t\\tknownActions: Array< AnimationAction >\\t- used as prototypes\\n\\t\\t\\t// \\t\\tactionByRoot: AnimationAction\\t\\t\\t- lookup\\n\\t\\t\\t// }\\n\\n\\n\\t\\t\\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\\n\\t\\t\\tthis._nActiveBindings = 0;\\n\\n\\t\\t\\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\\n\\n\\n\\t\\t\\tthis._controlInterpolants = []; // same game as above\\n\\t\\t\\tthis._nActiveControlInterpolants = 0;\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tthis.stats = {\\n\\n\\t\\t\\t\\tactions: {\\n\\t\\t\\t\\t\\tget total() {\\n\\n\\t\\t\\t\\t\\t\\treturn scope._actions.length;\\n\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\tget inUse() {\\n\\n\\t\\t\\t\\t\\t\\treturn scope._nActiveActions;\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tbindings: {\\n\\t\\t\\t\\t\\tget total() {\\n\\n\\t\\t\\t\\t\\t\\treturn scope._bindings.length;\\n\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\tget inUse() {\\n\\n\\t\\t\\t\\t\\t\\treturn scope._nActiveBindings;\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tcontrolInterpolants: {\\n\\t\\t\\t\\t\\tget total() {\\n\\n\\t\\t\\t\\t\\t\\treturn scope._controlInterpolants.length;\\n\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\tget inUse() {\\n\\n\\t\\t\\t\\t\\t\\treturn scope._nActiveControlInterpolants;\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t},\\n\\n\\t\\t// Memory management for AnimationAction objects\\n\\n\\t\\t_isActiveAction: function ( action ) {\\n\\n\\t\\t\\tvar index = action._cacheIndex;\\n\\t\\t\\treturn index !== null && index < this._nActiveActions;\\n\\n\\t\\t},\\n\\n\\t\\t_addInactiveAction: function ( action, clipUuid, rootUuid ) {\\n\\n\\t\\t\\tvar actions = this._actions,\\n\\t\\t\\t\\tactionsByClip = this._actionsByClip,\\n\\t\\t\\t\\tactionsForClip = actionsByClip[ clipUuid ];\\n\\n\\t\\t\\tif ( actionsForClip === undefined ) {\\n\\n\\t\\t\\t\\tactionsForClip = {\\n\\n\\t\\t\\t\\t\\tknownActions: [ action ],\\n\\t\\t\\t\\t\\tactionByRoot: {}\\n\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\taction._byClipCacheIndex = 0;\\n\\n\\t\\t\\t\\tactionsByClip[ clipUuid ] = actionsForClip;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tvar knownActions = actionsForClip.knownActions;\\n\\n\\t\\t\\t\\taction._byClipCacheIndex = knownActions.length;\\n\\t\\t\\t\\tknownActions.push( action );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\taction._cacheIndex = actions.length;\\n\\t\\t\\tactions.push( action );\\n\\n\\t\\t\\tactionsForClip.actionByRoot[ rootUuid ] = action;\\n\\n\\t\\t},\\n\\n\\t\\t_removeInactiveAction: function ( action ) {\\n\\n\\t\\t\\tvar actions = this._actions,\\n\\t\\t\\t\\tlastInactiveAction = actions[ actions.length - 1 ],\\n\\t\\t\\t\\tcacheIndex = action._cacheIndex;\\n\\n\\t\\t\\tlastInactiveAction._cacheIndex = cacheIndex;\\n\\t\\t\\tactions[ cacheIndex ] = lastInactiveAction;\\n\\t\\t\\tactions.pop();\\n\\n\\t\\t\\taction._cacheIndex = null;\\n\\n\\n\\t\\t\\tvar clipUuid = action._clip.uuid,\\n\\t\\t\\t\\tactionsByClip = this._actionsByClip,\\n\\t\\t\\t\\tactionsForClip = actionsByClip[ clipUuid ],\\n\\t\\t\\t\\tknownActionsForClip = actionsForClip.knownActions,\\n\\n\\t\\t\\t\\tlastKnownAction =\\n\\t\\t\\t\\t\\tknownActionsForClip[ knownActionsForClip.length - 1 ],\\n\\n\\t\\t\\t\\tbyClipCacheIndex = action._byClipCacheIndex;\\n\\n\\t\\t\\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\\n\\t\\t\\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\\n\\t\\t\\tknownActionsForClip.pop();\\n\\n\\t\\t\\taction._byClipCacheIndex = null;\\n\\n\\n\\t\\t\\tvar actionByRoot = actionsForClip.actionByRoot,\\n\\t\\t\\t\\trootUuid = ( action._localRoot || this._root ).uuid;\\n\\n\\t\\t\\tdelete actionByRoot[ rootUuid ];\\n\\n\\t\\t\\tif ( knownActionsForClip.length === 0 ) {\\n\\n\\t\\t\\t\\tdelete actionsByClip[ clipUuid ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._removeInactiveBindingsForAction( action );\\n\\n\\t\\t},\\n\\n\\t\\t_removeInactiveBindingsForAction: function ( action ) {\\n\\n\\t\\t\\tvar bindings = action._propertyBindings;\\n\\t\\t\\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\tvar binding = bindings[ i ];\\n\\n\\t\\t\\t\\tif ( -- binding.referenceCount === 0 ) {\\n\\n\\t\\t\\t\\t\\tthis._removeInactiveBinding( binding );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t_lendAction: function ( action ) {\\n\\n\\t\\t\\t// [ active actions |  inactive actions  ]\\n\\t\\t\\t// [  active actions >| inactive actions ]\\n\\t\\t\\t//                 s        a\\n\\t\\t\\t//                  <-swap->\\n\\t\\t\\t//                 a        s\\n\\n\\t\\t\\tvar actions = this._actions,\\n\\t\\t\\t\\tprevIndex = action._cacheIndex,\\n\\n\\t\\t\\t\\tlastActiveIndex = this._nActiveActions ++,\\n\\n\\t\\t\\t\\tfirstInactiveAction = actions[ lastActiveIndex ];\\n\\n\\t\\t\\taction._cacheIndex = lastActiveIndex;\\n\\t\\t\\tactions[ lastActiveIndex ] = action;\\n\\n\\t\\t\\tfirstInactiveAction._cacheIndex = prevIndex;\\n\\t\\t\\tactions[ prevIndex ] = firstInactiveAction;\\n\\n\\t\\t},\\n\\n\\t\\t_takeBackAction: function ( action ) {\\n\\n\\t\\t\\t// [  active actions  | inactive actions ]\\n\\t\\t\\t// [ active actions |< inactive actions  ]\\n\\t\\t\\t//        a        s\\n\\t\\t\\t//         <-swap->\\n\\t\\t\\t//        s        a\\n\\n\\t\\t\\tvar actions = this._actions,\\n\\t\\t\\t\\tprevIndex = action._cacheIndex,\\n\\n\\t\\t\\t\\tfirstInactiveIndex = -- this._nActiveActions,\\n\\n\\t\\t\\t\\tlastActiveAction = actions[ firstInactiveIndex ];\\n\\n\\t\\t\\taction._cacheIndex = firstInactiveIndex;\\n\\t\\t\\tactions[ firstInactiveIndex ] = action;\\n\\n\\t\\t\\tlastActiveAction._cacheIndex = prevIndex;\\n\\t\\t\\tactions[ prevIndex ] = lastActiveAction;\\n\\n\\t\\t},\\n\\n\\t\\t// Memory management for PropertyMixer objects\\n\\n\\t\\t_addInactiveBinding: function ( binding, rootUuid, trackName ) {\\n\\n\\t\\t\\tvar bindingsByRoot = this._bindingsByRootAndName,\\n\\t\\t\\t\\tbindingByName = bindingsByRoot[ rootUuid ],\\n\\n\\t\\t\\t\\tbindings = this._bindings;\\n\\n\\t\\t\\tif ( bindingByName === undefined ) {\\n\\n\\t\\t\\t\\tbindingByName = {};\\n\\t\\t\\t\\tbindingsByRoot[ rootUuid ] = bindingByName;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tbindingByName[ trackName ] = binding;\\n\\n\\t\\t\\tbinding._cacheIndex = bindings.length;\\n\\t\\t\\tbindings.push( binding );\\n\\n\\t\\t},\\n\\n\\t\\t_removeInactiveBinding: function ( binding ) {\\n\\n\\t\\t\\tvar bindings = this._bindings,\\n\\t\\t\\t\\tpropBinding = binding.binding,\\n\\t\\t\\t\\trootUuid = propBinding.rootNode.uuid,\\n\\t\\t\\t\\ttrackName = propBinding.path,\\n\\t\\t\\t\\tbindingsByRoot = this._bindingsByRootAndName,\\n\\t\\t\\t\\tbindingByName = bindingsByRoot[ rootUuid ],\\n\\n\\t\\t\\t\\tlastInactiveBinding = bindings[ bindings.length - 1 ],\\n\\t\\t\\t\\tcacheIndex = binding._cacheIndex;\\n\\n\\t\\t\\tlastInactiveBinding._cacheIndex = cacheIndex;\\n\\t\\t\\tbindings[ cacheIndex ] = lastInactiveBinding;\\n\\t\\t\\tbindings.pop();\\n\\n\\t\\t\\tdelete bindingByName[ trackName ];\\n\\n\\t\\t\\tremove_empty_map: {\\n\\n\\t\\t\\t\\tfor ( var _ in bindingByName ) break remove_empty_map; // eslint-disable-line no-unused-vars\\n\\n\\t\\t\\t\\tdelete bindingsByRoot[ rootUuid ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t_lendBinding: function ( binding ) {\\n\\n\\t\\t\\tvar bindings = this._bindings,\\n\\t\\t\\t\\tprevIndex = binding._cacheIndex,\\n\\n\\t\\t\\t\\tlastActiveIndex = this._nActiveBindings ++,\\n\\n\\t\\t\\t\\tfirstInactiveBinding = bindings[ lastActiveIndex ];\\n\\n\\t\\t\\tbinding._cacheIndex = lastActiveIndex;\\n\\t\\t\\tbindings[ lastActiveIndex ] = binding;\\n\\n\\t\\t\\tfirstInactiveBinding._cacheIndex = prevIndex;\\n\\t\\t\\tbindings[ prevIndex ] = firstInactiveBinding;\\n\\n\\t\\t},\\n\\n\\t\\t_takeBackBinding: function ( binding ) {\\n\\n\\t\\t\\tvar bindings = this._bindings,\\n\\t\\t\\t\\tprevIndex = binding._cacheIndex,\\n\\n\\t\\t\\t\\tfirstInactiveIndex = -- this._nActiveBindings,\\n\\n\\t\\t\\t\\tlastActiveBinding = bindings[ firstInactiveIndex ];\\n\\n\\t\\t\\tbinding._cacheIndex = firstInactiveIndex;\\n\\t\\t\\tbindings[ firstInactiveIndex ] = binding;\\n\\n\\t\\t\\tlastActiveBinding._cacheIndex = prevIndex;\\n\\t\\t\\tbindings[ prevIndex ] = lastActiveBinding;\\n\\n\\t\\t},\\n\\n\\n\\t\\t// Memory management of Interpolants for weight and time scale\\n\\n\\t\\t_lendControlInterpolant: function () {\\n\\n\\t\\t\\tvar interpolants = this._controlInterpolants,\\n\\t\\t\\t\\tlastActiveIndex = this._nActiveControlInterpolants ++,\\n\\t\\t\\t\\tinterpolant = interpolants[ lastActiveIndex ];\\n\\n\\t\\t\\tif ( interpolant === undefined ) {\\n\\n\\t\\t\\t\\tinterpolant = new LinearInterpolant(\\n\\t\\t\\t\\t\\tnew Float32Array( 2 ), new Float32Array( 2 ),\\n\\t\\t\\t\\t\\t1, this._controlInterpolantsResultBuffer );\\n\\n\\t\\t\\t\\tinterpolant.__cacheIndex = lastActiveIndex;\\n\\t\\t\\t\\tinterpolants[ lastActiveIndex ] = interpolant;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn interpolant;\\n\\n\\t\\t},\\n\\n\\t\\t_takeBackControlInterpolant: function ( interpolant ) {\\n\\n\\t\\t\\tvar interpolants = this._controlInterpolants,\\n\\t\\t\\t\\tprevIndex = interpolant.__cacheIndex,\\n\\n\\t\\t\\t\\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\\n\\n\\t\\t\\t\\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\\n\\n\\t\\t\\tinterpolant.__cacheIndex = firstInactiveIndex;\\n\\t\\t\\tinterpolants[ firstInactiveIndex ] = interpolant;\\n\\n\\t\\t\\tlastActiveInterpolant.__cacheIndex = prevIndex;\\n\\t\\t\\tinterpolants[ prevIndex ] = lastActiveInterpolant;\\n\\n\\t\\t},\\n\\n\\t\\t_controlInterpolantsResultBuffer: new Float32Array( 1 ),\\n\\n\\t\\t// return an action for a clip optionally using a custom root target\\n\\t\\t// object (this method allocates a lot of dynamic memory in case a\\n\\t\\t// previously unknown clip/root combination is specified)\\n\\t\\tclipAction: function ( clip, optionalRoot ) {\\n\\n\\t\\t\\tvar root = optionalRoot || this._root,\\n\\t\\t\\t\\trootUuid = root.uuid,\\n\\n\\t\\t\\t\\tclipObject = typeof clip === 'string' ?\\n\\t\\t\\t\\t\\tAnimationClip.findByName( root, clip ) : clip,\\n\\n\\t\\t\\t\\tclipUuid = clipObject !== null ? clipObject.uuid : clip,\\n\\n\\t\\t\\t\\tactionsForClip = this._actionsByClip[ clipUuid ],\\n\\t\\t\\t\\tprototypeAction = null;\\n\\n\\t\\t\\tif ( actionsForClip !== undefined ) {\\n\\n\\t\\t\\t\\tvar existingAction =\\n\\t\\t\\t\\t\\t\\tactionsForClip.actionByRoot[ rootUuid ];\\n\\n\\t\\t\\t\\tif ( existingAction !== undefined ) {\\n\\n\\t\\t\\t\\t\\treturn existingAction;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// we know the clip, so we don't have to parse all\\n\\t\\t\\t\\t// the bindings again but can just copy\\n\\t\\t\\t\\tprototypeAction = actionsForClip.knownActions[ 0 ];\\n\\n\\t\\t\\t\\t// also, take the clip from the prototype action\\n\\t\\t\\t\\tif ( clipObject === null )\\n\\t\\t\\t\\t\\tclipObject = prototypeAction._clip;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// clip must be known when specified via string\\n\\t\\t\\tif ( clipObject === null ) return null;\\n\\n\\t\\t\\t// allocate all resources required to run it\\n\\t\\t\\tvar newAction = new AnimationAction( this, clipObject, optionalRoot );\\n\\n\\t\\t\\tthis._bindAction( newAction, prototypeAction );\\n\\n\\t\\t\\t// and make the action known to the memory manager\\n\\t\\t\\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\\n\\n\\t\\t\\treturn newAction;\\n\\n\\t\\t},\\n\\n\\t\\t// get an existing action\\n\\t\\texistingAction: function ( clip, optionalRoot ) {\\n\\n\\t\\t\\tvar root = optionalRoot || this._root,\\n\\t\\t\\t\\trootUuid = root.uuid,\\n\\n\\t\\t\\t\\tclipObject = typeof clip === 'string' ?\\n\\t\\t\\t\\t\\tAnimationClip.findByName( root, clip ) : clip,\\n\\n\\t\\t\\t\\tclipUuid = clipObject ? clipObject.uuid : clip,\\n\\n\\t\\t\\t\\tactionsForClip = this._actionsByClip[ clipUuid ];\\n\\n\\t\\t\\tif ( actionsForClip !== undefined ) {\\n\\n\\t\\t\\t\\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn null;\\n\\n\\t\\t},\\n\\n\\t\\t// deactivates all previously scheduled actions\\n\\t\\tstopAllAction: function () {\\n\\n\\t\\t\\tvar actions = this._actions,\\n\\t\\t\\t\\tnActions = this._nActiveActions,\\n\\t\\t\\t\\tbindings = this._bindings,\\n\\t\\t\\t\\tnBindings = this._nActiveBindings;\\n\\n\\t\\t\\tthis._nActiveActions = 0;\\n\\t\\t\\tthis._nActiveBindings = 0;\\n\\n\\t\\t\\tfor ( var i = 0; i !== nActions; ++ i ) {\\n\\n\\t\\t\\t\\tactions[ i ].reset();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var i = 0; i !== nBindings; ++ i ) {\\n\\n\\t\\t\\t\\tbindings[ i ].useCount = 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t// advance the time and update apply the animation\\n\\t\\tupdate: function ( deltaTime ) {\\n\\n\\t\\t\\tdeltaTime *= this.timeScale;\\n\\n\\t\\t\\tvar actions = this._actions,\\n\\t\\t\\t\\tnActions = this._nActiveActions,\\n\\n\\t\\t\\t\\ttime = this.time += deltaTime,\\n\\t\\t\\t\\ttimeDirection = Math.sign( deltaTime ),\\n\\n\\t\\t\\t\\taccuIndex = this._accuIndex ^= 1;\\n\\n\\t\\t\\t// run active actions\\n\\n\\t\\t\\tfor ( var i = 0; i !== nActions; ++ i ) {\\n\\n\\t\\t\\t\\tvar action = actions[ i ];\\n\\n\\t\\t\\t\\taction._update( time, deltaTime, timeDirection, accuIndex );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// update scene graph\\n\\n\\t\\t\\tvar bindings = this._bindings,\\n\\t\\t\\t\\tnBindings = this._nActiveBindings;\\n\\n\\t\\t\\tfor ( var i = 0; i !== nBindings; ++ i ) {\\n\\n\\t\\t\\t\\tbindings[ i ].apply( accuIndex );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t// return this mixer's root target object\\n\\t\\tgetRoot: function () {\\n\\n\\t\\t\\treturn this._root;\\n\\n\\t\\t},\\n\\n\\t\\t// free all resources specific to a particular clip\\n\\t\\tuncacheClip: function ( clip ) {\\n\\n\\t\\t\\tvar actions = this._actions,\\n\\t\\t\\t\\tclipUuid = clip.uuid,\\n\\t\\t\\t\\tactionsByClip = this._actionsByClip,\\n\\t\\t\\t\\tactionsForClip = actionsByClip[ clipUuid ];\\n\\n\\t\\t\\tif ( actionsForClip !== undefined ) {\\n\\n\\t\\t\\t\\t// note: just calling _removeInactiveAction would mess up the\\n\\t\\t\\t\\t// iteration state and also require updating the state we can\\n\\t\\t\\t\\t// just throw away\\n\\n\\t\\t\\t\\tvar actionsToRemove = actionsForClip.knownActions;\\n\\n\\t\\t\\t\\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\tvar action = actionsToRemove[ i ];\\n\\n\\t\\t\\t\\t\\tthis._deactivateAction( action );\\n\\n\\t\\t\\t\\t\\tvar cacheIndex = action._cacheIndex,\\n\\t\\t\\t\\t\\t\\tlastInactiveAction = actions[ actions.length - 1 ];\\n\\n\\t\\t\\t\\t\\taction._cacheIndex = null;\\n\\t\\t\\t\\t\\taction._byClipCacheIndex = null;\\n\\n\\t\\t\\t\\t\\tlastInactiveAction._cacheIndex = cacheIndex;\\n\\t\\t\\t\\t\\tactions[ cacheIndex ] = lastInactiveAction;\\n\\t\\t\\t\\t\\tactions.pop();\\n\\n\\t\\t\\t\\t\\tthis._removeInactiveBindingsForAction( action );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdelete actionsByClip[ clipUuid ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t// free all resources specific to a particular root target object\\n\\t\\tuncacheRoot: function ( root ) {\\n\\n\\t\\t\\tvar rootUuid = root.uuid,\\n\\t\\t\\t\\tactionsByClip = this._actionsByClip;\\n\\n\\t\\t\\tfor ( var clipUuid in actionsByClip ) {\\n\\n\\t\\t\\t\\tvar actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\\n\\t\\t\\t\\t\\taction = actionByRoot[ rootUuid ];\\n\\n\\t\\t\\t\\tif ( action !== undefined ) {\\n\\n\\t\\t\\t\\t\\tthis._deactivateAction( action );\\n\\t\\t\\t\\t\\tthis._removeInactiveAction( action );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar bindingsByRoot = this._bindingsByRootAndName,\\n\\t\\t\\t\\tbindingByName = bindingsByRoot[ rootUuid ];\\n\\n\\t\\t\\tif ( bindingByName !== undefined ) {\\n\\n\\t\\t\\t\\tfor ( var trackName in bindingByName ) {\\n\\n\\t\\t\\t\\t\\tvar binding = bindingByName[ trackName ];\\n\\t\\t\\t\\t\\tbinding.restoreOriginalState();\\n\\t\\t\\t\\t\\tthis._removeInactiveBinding( binding );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t// remove a targeted clip from the cache\\n\\t\\tuncacheAction: function ( clip, optionalRoot ) {\\n\\n\\t\\t\\tvar action = this.existingAction( clip, optionalRoot );\\n\\n\\t\\t\\tif ( action !== null ) {\\n\\n\\t\\t\\t\\tthis._deactivateAction( action );\\n\\t\\t\\t\\tthis._removeInactiveAction( action );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction Uniform( value ) {\\n\\n\\t\\tif ( typeof value === 'string' ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\\n\\t\\t\\tvalue = arguments[ 1 ];\\n\\n\\t\\t}\\n\\n\\t\\tthis.value = value;\\n\\n\\t}\\n\\n\\tUniform.prototype.clone = function () {\\n\\n\\t\\treturn new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author benaadams / https://twitter.com/ben_a_adams\\n\\t */\\n\\n\\tfunction InstancedBufferGeometry() {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'InstancedBufferGeometry';\\n\\t\\tthis.maxInstancedCount = undefined;\\n\\n\\t}\\n\\n\\tInstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {\\n\\n\\t\\tconstructor: InstancedBufferGeometry,\\n\\n\\t\\tisInstancedBufferGeometry: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tBufferGeometry.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.maxInstancedCount = source.maxInstancedCount;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author benaadams / https://twitter.com/ben_a_adams\\n\\t */\\n\\n\\tfunction InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\tthis.data = interleavedBuffer;\\n\\t\\tthis.itemSize = itemSize;\\n\\t\\tthis.offset = offset;\\n\\n\\t\\tthis.normalized = normalized === true;\\n\\n\\t}\\n\\n\\tObject.defineProperties( InterleavedBufferAttribute.prototype, {\\n\\n\\t\\tcount: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this.data.count;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tarray: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this.data.array;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( InterleavedBufferAttribute.prototype, {\\n\\n\\t\\tisInterleavedBufferAttribute: true,\\n\\n\\t\\tsetX: function ( index, x ) {\\n\\n\\t\\t\\tthis.data.array[ index * this.data.stride + this.offset ] = x;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetY: function ( index, y ) {\\n\\n\\t\\t\\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetZ: function ( index, z ) {\\n\\n\\t\\t\\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetW: function ( index, w ) {\\n\\n\\t\\t\\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetX: function ( index ) {\\n\\n\\t\\t\\treturn this.data.array[ index * this.data.stride + this.offset ];\\n\\n\\t\\t},\\n\\n\\t\\tgetY: function ( index ) {\\n\\n\\t\\t\\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\\n\\n\\t\\t},\\n\\n\\t\\tgetZ: function ( index ) {\\n\\n\\t\\t\\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\\n\\n\\t\\t},\\n\\n\\t\\tgetW: function ( index ) {\\n\\n\\t\\t\\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\\n\\n\\t\\t},\\n\\n\\t\\tsetXY: function ( index, x, y ) {\\n\\n\\t\\t\\tindex = index * this.data.stride + this.offset;\\n\\n\\t\\t\\tthis.data.array[ index + 0 ] = x;\\n\\t\\t\\tthis.data.array[ index + 1 ] = y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetXYZ: function ( index, x, y, z ) {\\n\\n\\t\\t\\tindex = index * this.data.stride + this.offset;\\n\\n\\t\\t\\tthis.data.array[ index + 0 ] = x;\\n\\t\\t\\tthis.data.array[ index + 1 ] = y;\\n\\t\\t\\tthis.data.array[ index + 2 ] = z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetXYZW: function ( index, x, y, z, w ) {\\n\\n\\t\\t\\tindex = index * this.data.stride + this.offset;\\n\\n\\t\\t\\tthis.data.array[ index + 0 ] = x;\\n\\t\\t\\tthis.data.array[ index + 1 ] = y;\\n\\t\\t\\tthis.data.array[ index + 2 ] = z;\\n\\t\\t\\tthis.data.array[ index + 3 ] = w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author benaadams / https://twitter.com/ben_a_adams\\n\\t */\\n\\n\\tfunction InterleavedBuffer( array, stride ) {\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\tthis.array = array;\\n\\t\\tthis.stride = stride;\\n\\t\\tthis.count = array !== undefined ? array.length / stride : 0;\\n\\n\\t\\tthis.dynamic = false;\\n\\t\\tthis.updateRange = { offset: 0, count: - 1 };\\n\\n\\t\\tthis.onUploadCallback = function () {};\\n\\n\\t\\tthis.version = 0;\\n\\n\\t}\\n\\n\\tObject.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tif ( value === true ) this.version ++;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( InterleavedBuffer.prototype, {\\n\\n\\t\\tisInterleavedBuffer: true,\\n\\n\\t\\tsetArray: function ( array ) {\\n\\n\\t\\t\\tif ( Array.isArray( array ) ) {\\n\\n\\t\\t\\t\\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.count = array !== undefined ? array.length / this.stride : 0;\\n\\t\\t\\tthis.array = array;\\n\\n\\t\\t},\\n\\n\\t\\tsetDynamic: function ( value ) {\\n\\n\\t\\t\\tthis.dynamic = value;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tthis.array = new source.array.constructor( source.array );\\n\\t\\t\\tthis.count = source.count;\\n\\t\\t\\tthis.stride = source.stride;\\n\\t\\t\\tthis.dynamic = source.dynamic;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyAt: function ( index1, attribute, index2 ) {\\n\\n\\t\\t\\tindex1 *= this.stride;\\n\\t\\t\\tindex2 *= attribute.stride;\\n\\n\\t\\t\\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value, offset ) {\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tthis.array.set( value, offset );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tonUpload: function ( callback ) {\\n\\n\\t\\t\\tthis.onUploadCallback = callback;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author benaadams / https://twitter.com/ben_a_adams\\n\\t */\\n\\n\\tfunction InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {\\n\\n\\t\\tInterleavedBuffer.call( this, array, stride );\\n\\n\\t\\tthis.meshPerAttribute = meshPerAttribute || 1;\\n\\n\\t}\\n\\n\\tInstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {\\n\\n\\t\\tconstructor: InstancedInterleavedBuffer,\\n\\n\\t\\tisInstancedInterleavedBuffer: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tInterleavedBuffer.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.meshPerAttribute = source.meshPerAttribute;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author benaadams / https://twitter.com/ben_a_adams\\n\\t */\\n\\n\\tfunction InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {\\n\\n\\t\\tBufferAttribute.call( this, array, itemSize );\\n\\n\\t\\tthis.meshPerAttribute = meshPerAttribute || 1;\\n\\n\\t}\\n\\n\\tInstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {\\n\\n\\t\\tconstructor: InstancedBufferAttribute,\\n\\n\\t\\tisInstancedBufferAttribute: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tBufferAttribute.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.meshPerAttribute = source.meshPerAttribute;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author bhouston / http://clara.io/\\n\\t * @author stephomi / http://stephaneginier.com/\\n\\t */\\n\\n\\tfunction Raycaster( origin, direction, near, far ) {\\n\\n\\t\\tthis.ray = new Ray( origin, direction );\\n\\t\\t// direction is assumed to be normalized (for accurate distance calculations)\\n\\n\\t\\tthis.near = near || 0;\\n\\t\\tthis.far = far || Infinity;\\n\\n\\t\\tthis.params = {\\n\\t\\t\\tMesh: {},\\n\\t\\t\\tLine: {},\\n\\t\\t\\tLOD: {},\\n\\t\\t\\tPoints: { threshold: 1 },\\n\\t\\t\\tSprite: {}\\n\\t\\t};\\n\\n\\t\\tObject.defineProperties( this.params, {\\n\\t\\t\\tPointCloud: {\\n\\t\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\\n\\t\\t\\t\\t\\treturn this.Points;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} );\\n\\n\\t}\\n\\n\\tfunction ascSort( a, b ) {\\n\\n\\t\\treturn a.distance - b.distance;\\n\\n\\t}\\n\\n\\tfunction intersectObject( object, raycaster, intersects, recursive ) {\\n\\n\\t\\tif ( object.visible === false ) return;\\n\\n\\t\\tobject.raycast( raycaster, intersects );\\n\\n\\t\\tif ( recursive === true ) {\\n\\n\\t\\t\\tvar children = object.children;\\n\\n\\t\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tintersectObject( children[ i ], raycaster, intersects, true );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tObject.assign( Raycaster.prototype, {\\n\\n\\t\\tlinePrecision: 1,\\n\\n\\t\\tset: function ( origin, direction ) {\\n\\n\\t\\t\\t// direction is assumed to be normalized (for accurate distance calculations)\\n\\n\\t\\t\\tthis.ray.set( origin, direction );\\n\\n\\t\\t},\\n\\n\\t\\tsetFromCamera: function ( coords, camera ) {\\n\\n\\t\\t\\tif ( ( camera && camera.isPerspectiveCamera ) ) {\\n\\n\\t\\t\\t\\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\\n\\t\\t\\t\\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\\n\\n\\t\\t\\t} else if ( ( camera && camera.isOrthographicCamera ) ) {\\n\\n\\t\\t\\t\\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\\n\\t\\t\\t\\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tintersectObject: function ( object, recursive ) {\\n\\n\\t\\t\\tvar intersects = [];\\n\\n\\t\\t\\tintersectObject( object, this, intersects, recursive );\\n\\n\\t\\t\\tintersects.sort( ascSort );\\n\\n\\t\\t\\treturn intersects;\\n\\n\\t\\t},\\n\\n\\t\\tintersectObjects: function ( objects, recursive ) {\\n\\n\\t\\t\\tvar intersects = [];\\n\\n\\t\\t\\tif ( Array.isArray( objects ) === false ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\\n\\t\\t\\t\\treturn intersects;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tintersectObject( objects[ i ], this, intersects, recursive );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tintersects.sort( ascSort );\\n\\n\\t\\t\\treturn intersects;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction Clock( autoStart ) {\\n\\n\\t\\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\\n\\n\\t\\tthis.startTime = 0;\\n\\t\\tthis.oldTime = 0;\\n\\t\\tthis.elapsedTime = 0;\\n\\n\\t\\tthis.running = false;\\n\\n\\t}\\n\\n\\tObject.assign( Clock.prototype, {\\n\\n\\t\\tstart: function () {\\n\\n\\t\\t\\tthis.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732\\n\\n\\t\\t\\tthis.oldTime = this.startTime;\\n\\t\\t\\tthis.elapsedTime = 0;\\n\\t\\t\\tthis.running = true;\\n\\n\\t\\t},\\n\\n\\t\\tstop: function () {\\n\\n\\t\\t\\tthis.getElapsedTime();\\n\\t\\t\\tthis.running = false;\\n\\t\\t\\tthis.autoStart = false;\\n\\n\\t\\t},\\n\\n\\t\\tgetElapsedTime: function () {\\n\\n\\t\\t\\tthis.getDelta();\\n\\t\\t\\treturn this.elapsedTime;\\n\\n\\t\\t},\\n\\n\\t\\tgetDelta: function () {\\n\\n\\t\\t\\tvar diff = 0;\\n\\n\\t\\t\\tif ( this.autoStart && ! this.running ) {\\n\\n\\t\\t\\t\\tthis.start();\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.running ) {\\n\\n\\t\\t\\t\\tvar newTime = ( typeof performance === 'undefined' ? Date : performance ).now();\\n\\n\\t\\t\\t\\tdiff = ( newTime - this.oldTime ) / 1000;\\n\\t\\t\\t\\tthis.oldTime = newTime;\\n\\n\\t\\t\\t\\tthis.elapsedTime += diff;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn diff;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author bhouston / http://clara.io\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t *\\n\\t * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\\n\\t *\\n\\t * The poles (phi) are at the positive and negative y axis.\\n\\t * The equator starts at positive z.\\n\\t */\\n\\n\\tfunction Spherical( radius, phi, theta ) {\\n\\n\\t\\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\\n\\t\\tthis.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole\\n\\t\\tthis.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere\\n\\n\\t\\treturn this;\\n\\n\\t}\\n\\n\\tObject.assign( Spherical.prototype, {\\n\\n\\t\\tset: function ( radius, phi, theta ) {\\n\\n\\t\\t\\tthis.radius = radius;\\n\\t\\t\\tthis.phi = phi;\\n\\t\\t\\tthis.theta = theta;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( other ) {\\n\\n\\t\\t\\tthis.radius = other.radius;\\n\\t\\t\\tthis.phi = other.phi;\\n\\t\\t\\tthis.theta = other.theta;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t// restrict phi to be betwee EPS and PI-EPS\\n\\t\\tmakeSafe: function () {\\n\\n\\t\\t\\tvar EPS = 0.000001;\\n\\t\\t\\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromVector3: function ( vec3 ) {\\n\\n\\t\\t\\tthis.radius = vec3.length();\\n\\n\\t\\t\\tif ( this.radius === 0 ) {\\n\\n\\t\\t\\t\\tthis.theta = 0;\\n\\t\\t\\t\\tthis.phi = 0;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis\\n\\t\\t\\t\\tthis.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t *\\n\\t * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system\\n\\t *\\n\\t */\\n\\n\\tfunction Cylindrical( radius, theta, y ) {\\n\\n\\t\\tthis.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane\\n\\t\\tthis.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis\\n\\t\\tthis.y = ( y !== undefined ) ? y : 0; // height above the x-z plane\\n\\n\\t\\treturn this;\\n\\n\\t}\\n\\n\\tObject.assign( Cylindrical.prototype, {\\n\\n\\t\\tset: function ( radius, theta, y ) {\\n\\n\\t\\t\\tthis.radius = radius;\\n\\t\\t\\tthis.theta = theta;\\n\\t\\t\\tthis.y = y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( other ) {\\n\\n\\t\\t\\tthis.radius = other.radius;\\n\\t\\t\\tthis.theta = other.theta;\\n\\t\\t\\tthis.y = other.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromVector3: function ( vec3 ) {\\n\\n\\t\\t\\tthis.radius = Math.sqrt( vec3.x * vec3.x + vec3.z * vec3.z );\\n\\t\\t\\tthis.theta = Math.atan2( vec3.x, vec3.z );\\n\\t\\t\\tthis.y = vec3.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction ImmediateRenderObject( material ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.material = material;\\n\\t\\tthis.render = function ( /* renderCallback */ ) {};\\n\\n\\t}\\n\\n\\tImmediateRenderObject.prototype = Object.create( Object3D.prototype );\\n\\tImmediateRenderObject.prototype.constructor = ImmediateRenderObject;\\n\\n\\tImmediateRenderObject.prototype.isImmediateRenderObject = true;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction VertexNormalsHelper( object, size, hex, linewidth ) {\\n\\n\\t\\tthis.object = object;\\n\\n\\t\\tthis.size = ( size !== undefined ) ? size : 1;\\n\\n\\t\\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\\n\\n\\t\\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\\n\\n\\t\\t//\\n\\n\\t\\tvar nNormals = 0;\\n\\n\\t\\tvar objGeometry = this.object.geometry;\\n\\n\\t\\tif ( objGeometry && objGeometry.isGeometry ) {\\n\\n\\t\\t\\tnNormals = objGeometry.faces.length * 3;\\n\\n\\t\\t} else if ( objGeometry && objGeometry.isBufferGeometry ) {\\n\\n\\t\\t\\tnNormals = objGeometry.attributes.normal.count;\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\n\\t\\tvar positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );\\n\\n\\t\\tgeometry.addAttribute( 'position', positions );\\n\\n\\t\\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\\n\\n\\t\\t//\\n\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\n\\t\\tthis.update();\\n\\n\\t}\\n\\n\\tVertexNormalsHelper.prototype = Object.create( LineSegments.prototype );\\n\\tVertexNormalsHelper.prototype.constructor = VertexNormalsHelper;\\n\\n\\tVertexNormalsHelper.prototype.update = ( function () {\\n\\n\\t\\tvar v1 = new Vector3();\\n\\t\\tvar v2 = new Vector3();\\n\\t\\tvar normalMatrix = new Matrix3();\\n\\n\\t\\treturn function update() {\\n\\n\\t\\t\\tvar keys = [ 'a', 'b', 'c' ];\\n\\n\\t\\t\\tthis.object.updateMatrixWorld( true );\\n\\n\\t\\t\\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\\n\\n\\t\\t\\tvar matrixWorld = this.object.matrixWorld;\\n\\n\\t\\t\\tvar position = this.geometry.attributes.position;\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar objGeometry = this.object.geometry;\\n\\n\\t\\t\\tif ( objGeometry && objGeometry.isGeometry ) {\\n\\n\\t\\t\\t\\tvar vertices = objGeometry.vertices;\\n\\n\\t\\t\\t\\tvar faces = objGeometry.faces;\\n\\n\\t\\t\\t\\tvar idx = 0;\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar face = faces[ i ];\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar vertex = vertices[ face[ keys[ j ] ] ];\\n\\n\\t\\t\\t\\t\\t\\tvar normal = face.vertexNormals[ j ];\\n\\n\\t\\t\\t\\t\\t\\tv1.copy( vertex ).applyMatrix4( matrixWorld );\\n\\n\\t\\t\\t\\t\\t\\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\\n\\n\\t\\t\\t\\t\\t\\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\\n\\n\\t\\t\\t\\t\\t\\tidx = idx + 1;\\n\\n\\t\\t\\t\\t\\t\\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\\n\\n\\t\\t\\t\\t\\t\\tidx = idx + 1;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( objGeometry && objGeometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\tvar objPos = objGeometry.attributes.position;\\n\\n\\t\\t\\t\\tvar objNorm = objGeometry.attributes.normal;\\n\\n\\t\\t\\t\\tvar idx = 0;\\n\\n\\t\\t\\t\\t// for simplicity, ignore index and drawcalls, and render every normal\\n\\n\\t\\t\\t\\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\\n\\n\\t\\t\\t\\t\\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\\n\\n\\t\\t\\t\\t\\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\\n\\n\\t\\t\\t\\t\\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\\n\\n\\t\\t\\t\\t\\tidx = idx + 1;\\n\\n\\t\\t\\t\\t\\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\\n\\n\\t\\t\\t\\t\\tidx = idx + 1;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tposition.needsUpdate = true;\\n\\n\\t\\t};\\n\\n\\t}() );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction SpotLightHelper( light, color ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.light = light;\\n\\t\\tthis.light.updateMatrixWorld();\\n\\n\\t\\tthis.matrix = light.matrixWorld;\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\n\\t\\tthis.color = color;\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\n\\t\\tvar positions = [\\n\\t\\t\\t0, 0, 0, \\t0, 0, 1,\\n\\t\\t\\t0, 0, 0, \\t1, 0, 1,\\n\\t\\t\\t0, 0, 0,\\t- 1, 0, 1,\\n\\t\\t\\t0, 0, 0, \\t0, 1, 1,\\n\\t\\t\\t0, 0, 0, \\t0, - 1, 1\\n\\t\\t];\\n\\n\\t\\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\\n\\n\\t\\t\\tvar p1 = ( i / l ) * Math.PI * 2;\\n\\t\\t\\tvar p2 = ( j / l ) * Math.PI * 2;\\n\\n\\t\\t\\tpositions.push(\\n\\t\\t\\t\\tMath.cos( p1 ), Math.sin( p1 ), 1,\\n\\t\\t\\t\\tMath.cos( p2 ), Math.sin( p2 ), 1\\n\\t\\t\\t);\\n\\n\\t\\t}\\n\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\\n\\n\\t\\tvar material = new LineBasicMaterial( { fog: false } );\\n\\n\\t\\tthis.cone = new LineSegments( geometry, material );\\n\\t\\tthis.add( this.cone );\\n\\n\\t\\tthis.update();\\n\\n\\t}\\n\\n\\tSpotLightHelper.prototype = Object.create( Object3D.prototype );\\n\\tSpotLightHelper.prototype.constructor = SpotLightHelper;\\n\\n\\tSpotLightHelper.prototype.dispose = function () {\\n\\n\\t\\tthis.cone.geometry.dispose();\\n\\t\\tthis.cone.material.dispose();\\n\\n\\t};\\n\\n\\tSpotLightHelper.prototype.update = function () {\\n\\n\\t\\tvar vector = new Vector3();\\n\\t\\tvar vector2 = new Vector3();\\n\\n\\t\\treturn function update() {\\n\\n\\t\\t\\tthis.light.updateMatrixWorld();\\n\\n\\t\\t\\tvar coneLength = this.light.distance ? this.light.distance : 1000;\\n\\t\\t\\tvar coneWidth = coneLength * Math.tan( this.light.angle );\\n\\n\\t\\t\\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\\n\\n\\t\\t\\tvector.setFromMatrixPosition( this.light.matrixWorld );\\n\\t\\t\\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\\n\\n\\t\\t\\tthis.cone.lookAt( vector2.sub( vector ) );\\n\\n\\t\\t\\tif ( this.color !== undefined ) {\\n\\n\\t\\t\\t\\tthis.cone.material.color.set( this.color );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.cone.material.color.copy( this.light.color );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\t/**\\n\\t * @author Sean Griffin / http://twitter.com/sgrif\\n\\t * @author Michael Guerrero / http://realitymeltdown.com\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author ikerr / http://verold.com\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\tfunction getBoneList( object ) {\\n\\n\\t\\tvar boneList = [];\\n\\n\\t\\tif ( object && object.isBone ) {\\n\\n\\t\\t\\tboneList.push( object );\\n\\n\\t\\t}\\n\\n\\t\\tfor ( var i = 0; i < object.children.length; i ++ ) {\\n\\n\\t\\t\\tboneList.push.apply( boneList, getBoneList( object.children[ i ] ) );\\n\\n\\t\\t}\\n\\n\\t\\treturn boneList;\\n\\n\\t}\\n\\n\\tfunction SkeletonHelper( object ) {\\n\\n\\t\\tvar bones = getBoneList( object );\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\n\\t\\tvar vertices = [];\\n\\t\\tvar colors = [];\\n\\n\\t\\tvar color1 = new Color( 0, 0, 1 );\\n\\t\\tvar color2 = new Color( 0, 1, 0 );\\n\\n\\t\\tfor ( var i = 0; i < bones.length; i ++ ) {\\n\\n\\t\\t\\tvar bone = bones[ i ];\\n\\n\\t\\t\\tif ( bone.parent && bone.parent.isBone ) {\\n\\n\\t\\t\\t\\tvertices.push( 0, 0, 0 );\\n\\t\\t\\t\\tvertices.push( 0, 0, 0 );\\n\\t\\t\\t\\tcolors.push( color1.r, color1.g, color1.b );\\n\\t\\t\\t\\tcolors.push( color2.r, color2.g, color2.b );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\\n\\n\\t\\tvar material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );\\n\\n\\t\\tLineSegments.call( this, geometry, material );\\n\\n\\t\\tthis.root = object;\\n\\t\\tthis.bones = bones;\\n\\n\\t\\tthis.matrix = object.matrixWorld;\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\n\\t}\\n\\n\\tSkeletonHelper.prototype = Object.create( LineSegments.prototype );\\n\\tSkeletonHelper.prototype.constructor = SkeletonHelper;\\n\\n\\tSkeletonHelper.prototype.updateMatrixWorld = function () {\\n\\n\\t\\tvar vector = new Vector3();\\n\\n\\t\\tvar boneMatrix = new Matrix4();\\n\\t\\tvar matrixWorldInv = new Matrix4();\\n\\n\\t\\treturn function updateMatrixWorld( force ) {\\n\\n\\t\\t\\tvar bones = this.bones;\\n\\n\\t\\t\\tvar geometry = this.geometry;\\n\\t\\t\\tvar position = geometry.getAttribute( 'position' );\\n\\n\\t\\t\\tmatrixWorldInv.getInverse( this.root.matrixWorld );\\n\\n\\t\\t\\tfor ( var i = 0, j = 0; i < bones.length; i ++ ) {\\n\\n\\t\\t\\t\\tvar bone = bones[ i ];\\n\\n\\t\\t\\t\\tif ( bone.parent && bone.parent.isBone ) {\\n\\n\\t\\t\\t\\t\\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\\n\\t\\t\\t\\t\\tvector.setFromMatrixPosition( boneMatrix );\\n\\t\\t\\t\\t\\tposition.setXYZ( j, vector.x, vector.y, vector.z );\\n\\n\\t\\t\\t\\t\\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\\n\\t\\t\\t\\t\\tvector.setFromMatrixPosition( boneMatrix );\\n\\t\\t\\t\\t\\tposition.setXYZ( j + 1, vector.x, vector.y, vector.z );\\n\\n\\t\\t\\t\\t\\tj += 2;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tgeometry.getAttribute( 'position' ).needsUpdate = true;\\n\\n\\t\\t\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction PointLightHelper( light, sphereSize, color ) {\\n\\n\\t\\tthis.light = light;\\n\\t\\tthis.light.updateMatrixWorld();\\n\\n\\t\\tthis.color = color;\\n\\n\\t\\tvar geometry = new SphereBufferGeometry( sphereSize, 4, 2 );\\n\\t\\tvar material = new MeshBasicMaterial( { wireframe: true, fog: false } );\\n\\n\\t\\tMesh.call( this, geometry, material );\\n\\n\\t\\tthis.matrix = this.light.matrixWorld;\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\n\\t\\tthis.update();\\n\\n\\n\\t\\t/*\\n\\t\\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\\n\\t\\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\\n\\n\\t\\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\\n\\t\\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\\n\\n\\t\\tvar d = light.distance;\\n\\n\\t\\tif ( d === 0.0 ) {\\n\\n\\t\\t\\tthis.lightDistance.visible = false;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tthis.lightDistance.scale.set( d, d, d );\\n\\n\\t\\t}\\n\\n\\t\\tthis.add( this.lightDistance );\\n\\t\\t*/\\n\\n\\t}\\n\\n\\tPointLightHelper.prototype = Object.create( Mesh.prototype );\\n\\tPointLightHelper.prototype.constructor = PointLightHelper;\\n\\n\\tPointLightHelper.prototype.dispose = function () {\\n\\n\\t\\tthis.geometry.dispose();\\n\\t\\tthis.material.dispose();\\n\\n\\t};\\n\\n\\tPointLightHelper.prototype.update = function () {\\n\\n\\t\\tif ( this.color !== undefined ) {\\n\\n\\t\\t\\tthis.material.color.set( this.color );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tthis.material.color.copy( this.light.color );\\n\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\tvar d = this.light.distance;\\n\\n\\t\\tif ( d === 0.0 ) {\\n\\n\\t\\t\\tthis.lightDistance.visible = false;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tthis.lightDistance.visible = true;\\n\\t\\t\\tthis.lightDistance.scale.set( d, d, d );\\n\\n\\t\\t}\\n\\t\\t*/\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author abelnation / http://github.com/abelnation\\n\\t * @author Mugen87 / http://github.com/Mugen87\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction RectAreaLightHelper( light, color ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.light = light;\\n\\t\\tthis.light.updateMatrixWorld();\\n\\n\\t\\tthis.matrix = light.matrixWorld;\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\n\\t\\tthis.color = color;\\n\\n\\t\\tvar material = new LineBasicMaterial( { fog: false } );\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\n\\t\\tgeometry.addAttribute( 'position', new BufferAttribute( new Float32Array( 5 * 3 ), 3 ) );\\n\\n\\t\\tthis.line = new Line( geometry, material );\\n\\t\\tthis.add( this.line );\\n\\n\\n\\t\\tthis.update();\\n\\n\\t}\\n\\n\\tRectAreaLightHelper.prototype = Object.create( Object3D.prototype );\\n\\tRectAreaLightHelper.prototype.constructor = RectAreaLightHelper;\\n\\n\\tRectAreaLightHelper.prototype.dispose = function () {\\n\\n\\t\\tthis.children[ 0 ].geometry.dispose();\\n\\t\\tthis.children[ 0 ].material.dispose();\\n\\n\\t};\\n\\n\\tRectAreaLightHelper.prototype.update = function () {\\n\\n\\t\\t// calculate new dimensions of the helper\\n\\n\\t\\tvar hx = this.light.width * 0.5;\\n\\t\\tvar hy = this.light.height * 0.5;\\n\\n\\t\\tvar position = this.line.geometry.attributes.position;\\n\\t\\tvar array = position.array;\\n\\n\\t\\t// update vertices\\n\\n\\t\\tarray[ 0 ] = hx; array[ 1 ] = - hy; array[ 2 ] = 0;\\n\\t\\tarray[ 3 ] = hx; array[ 4 ] = hy; array[ 5 ] = 0;\\n\\t\\tarray[ 6 ] = - hx; array[ 7 ] = hy; array[ 8 ] = 0;\\n\\t\\tarray[ 9 ] = - hx; array[ 10 ] = - hy; array[ 11 ] = 0;\\n\\t\\tarray[ 12 ] = hx; array[ 13 ] = - hy; array[ 14 ] = 0;\\n\\n\\t\\tposition.needsUpdate = true;\\n\\n\\t\\tif ( this.color !== undefined ) {\\n\\n\\t\\t\\tthis.line.material.color.set( this.color );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tthis.line.material.color.copy( this.light.color );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\tfunction HemisphereLightHelper( light, size, color ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.light = light;\\n\\t\\tthis.light.updateMatrixWorld();\\n\\n\\t\\tthis.matrix = light.matrixWorld;\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\n\\t\\tthis.color = color;\\n\\n\\t\\tvar geometry = new OctahedronBufferGeometry( size );\\n\\t\\tgeometry.rotateY( Math.PI * 0.5 );\\n\\n\\t\\tthis.material = new MeshBasicMaterial( { wireframe: true, fog: false } );\\n\\t\\tif ( this.color === undefined ) this.material.vertexColors = VertexColors;\\n\\n\\t\\tvar position = geometry.getAttribute( 'position' );\\n\\t\\tvar colors = new Float32Array( position.count * 3 );\\n\\n\\t\\tgeometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );\\n\\n\\t\\tthis.add( new Mesh( geometry, this.material ) );\\n\\n\\t\\tthis.update();\\n\\n\\t}\\n\\n\\tHemisphereLightHelper.prototype = Object.create( Object3D.prototype );\\n\\tHemisphereLightHelper.prototype.constructor = HemisphereLightHelper;\\n\\n\\tHemisphereLightHelper.prototype.dispose = function () {\\n\\n\\t\\tthis.children[ 0 ].geometry.dispose();\\n\\t\\tthis.children[ 0 ].material.dispose();\\n\\n\\t};\\n\\n\\tHemisphereLightHelper.prototype.update = function () {\\n\\n\\t\\tvar vector = new Vector3();\\n\\n\\t\\tvar color1 = new Color();\\n\\t\\tvar color2 = new Color();\\n\\n\\t\\treturn function update() {\\n\\n\\t\\t\\tvar mesh = this.children[ 0 ];\\n\\n\\t\\t\\tif ( this.color !== undefined ) {\\n\\n\\t\\t\\t\\tthis.material.color.set( this.color );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tvar colors = mesh.geometry.getAttribute( 'color' );\\n\\n\\t\\t\\t\\tcolor1.copy( this.light.color );\\n\\t\\t\\t\\tcolor2.copy( this.light.groundColor );\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = colors.count; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar color = ( i < ( l / 2 ) ) ? color1 : color2;\\n\\n\\t\\t\\t\\t\\tcolors.setXYZ( i, color.r, color.g, color.b );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcolors.needsUpdate = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tmesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction GridHelper( size, divisions, color1, color2 ) {\\n\\n\\t\\tsize = size || 10;\\n\\t\\tdivisions = divisions || 10;\\n\\t\\tcolor1 = new Color( color1 !== undefined ? color1 : 0x444444 );\\n\\t\\tcolor2 = new Color( color2 !== undefined ? color2 : 0x888888 );\\n\\n\\t\\tvar center = divisions / 2;\\n\\t\\tvar step = size / divisions;\\n\\t\\tvar halfSize = size / 2;\\n\\n\\t\\tvar vertices = [], colors = [];\\n\\n\\t\\tfor ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {\\n\\n\\t\\t\\tvertices.push( - halfSize, 0, k, halfSize, 0, k );\\n\\t\\t\\tvertices.push( k, 0, - halfSize, k, 0, halfSize );\\n\\n\\t\\t\\tvar color = i === center ? color1 : color2;\\n\\n\\t\\t\\tcolor.toArray( colors, j ); j += 3;\\n\\t\\t\\tcolor.toArray( colors, j ); j += 3;\\n\\t\\t\\tcolor.toArray( colors, j ); j += 3;\\n\\t\\t\\tcolor.toArray( colors, j ); j += 3;\\n\\n\\t\\t}\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\\n\\n\\t\\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\\n\\n\\t\\tLineSegments.call( this, geometry, material );\\n\\n\\t}\\n\\n\\tGridHelper.prototype = Object.create( LineSegments.prototype );\\n\\tGridHelper.prototype.constructor = GridHelper;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author Mugen87 / http://github.com/Mugen87\\n\\t * @author Hectate / http://www.github.com/Hectate\\n\\t */\\n\\n\\tfunction PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {\\n\\n\\t\\tradius = radius || 10;\\n\\t\\tradials = radials || 16;\\n\\t\\tcircles = circles || 8;\\n\\t\\tdivisions = divisions || 64;\\n\\t\\tcolor1 = new Color( color1 !== undefined ? color1 : 0x444444 );\\n\\t\\tcolor2 = new Color( color2 !== undefined ? color2 : 0x888888 );\\n\\n\\t\\tvar vertices = [];\\n\\t\\tvar colors = [];\\n\\n\\t\\tvar x, z;\\n\\t\\tvar v, i, j, r, color;\\n\\n\\t\\t// create the radials\\n\\n\\t\\tfor ( i = 0; i <= radials; i ++ ) {\\n\\n\\t\\t\\tv = ( i / radials ) * ( Math.PI * 2 );\\n\\n\\t\\t\\tx = Math.sin( v ) * radius;\\n\\t\\t\\tz = Math.cos( v ) * radius;\\n\\n\\t\\t\\tvertices.push( 0, 0, 0 );\\n\\t\\t\\tvertices.push( x, 0, z );\\n\\n\\t\\t\\tcolor = ( i & 1 ) ? color1 : color2;\\n\\n\\t\\t\\tcolors.push( color.r, color.g, color.b );\\n\\t\\t\\tcolors.push( color.r, color.g, color.b );\\n\\n\\t\\t}\\n\\n\\t\\t// create the circles\\n\\n\\t\\tfor ( i = 0; i <= circles; i ++ ) {\\n\\n\\t\\t\\tcolor = ( i & 1 ) ? color1 : color2;\\n\\n\\t\\t\\tr = radius - ( radius / circles * i );\\n\\n\\t\\t\\tfor ( j = 0; j < divisions; j ++ ) {\\n\\n\\t\\t\\t\\t// first vertex\\n\\n\\t\\t\\t\\tv = ( j / divisions ) * ( Math.PI * 2 );\\n\\n\\t\\t\\t\\tx = Math.sin( v ) * r;\\n\\t\\t\\t\\tz = Math.cos( v ) * r;\\n\\n\\t\\t\\t\\tvertices.push( x, 0, z );\\n\\t\\t\\t\\tcolors.push( color.r, color.g, color.b );\\n\\n\\t\\t\\t\\t// second vertex\\n\\n\\t\\t\\t\\tv = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );\\n\\n\\t\\t\\t\\tx = Math.sin( v ) * r;\\n\\t\\t\\t\\tz = Math.cos( v ) * r;\\n\\n\\t\\t\\t\\tvertices.push( x, 0, z );\\n\\t\\t\\t\\tcolors.push( color.r, color.g, color.b );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\\n\\n\\t\\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\\n\\n\\t\\tLineSegments.call( this, geometry, material );\\n\\n\\t}\\n\\n\\tPolarGridHelper.prototype = Object.create( LineSegments.prototype );\\n\\tPolarGridHelper.prototype.constructor = PolarGridHelper;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction FaceNormalsHelper( object, size, hex, linewidth ) {\\n\\n\\t\\t// FaceNormalsHelper only supports THREE.Geometry\\n\\n\\t\\tthis.object = object;\\n\\n\\t\\tthis.size = ( size !== undefined ) ? size : 1;\\n\\n\\t\\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\\n\\n\\t\\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\\n\\n\\t\\t//\\n\\n\\t\\tvar nNormals = 0;\\n\\n\\t\\tvar objGeometry = this.object.geometry;\\n\\n\\t\\tif ( objGeometry && objGeometry.isGeometry ) {\\n\\n\\t\\t\\tnNormals = objGeometry.faces.length;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\n\\t\\tvar positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );\\n\\n\\t\\tgeometry.addAttribute( 'position', positions );\\n\\n\\t\\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\\n\\n\\t\\t//\\n\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\t\\tthis.update();\\n\\n\\t}\\n\\n\\tFaceNormalsHelper.prototype = Object.create( LineSegments.prototype );\\n\\tFaceNormalsHelper.prototype.constructor = FaceNormalsHelper;\\n\\n\\tFaceNormalsHelper.prototype.update = ( function () {\\n\\n\\t\\tvar v1 = new Vector3();\\n\\t\\tvar v2 = new Vector3();\\n\\t\\tvar normalMatrix = new Matrix3();\\n\\n\\t\\treturn function update() {\\n\\n\\t\\t\\tthis.object.updateMatrixWorld( true );\\n\\n\\t\\t\\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\\n\\n\\t\\t\\tvar matrixWorld = this.object.matrixWorld;\\n\\n\\t\\t\\tvar position = this.geometry.attributes.position;\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar objGeometry = this.object.geometry;\\n\\n\\t\\t\\tvar vertices = objGeometry.vertices;\\n\\n\\t\\t\\tvar faces = objGeometry.faces;\\n\\n\\t\\t\\tvar idx = 0;\\n\\n\\t\\t\\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar face = faces[ i ];\\n\\n\\t\\t\\t\\tvar normal = face.normal;\\n\\n\\t\\t\\t\\tv1.copy( vertices[ face.a ] )\\n\\t\\t\\t\\t\\t.add( vertices[ face.b ] )\\n\\t\\t\\t\\t\\t.add( vertices[ face.c ] )\\n\\t\\t\\t\\t\\t.divideScalar( 3 )\\n\\t\\t\\t\\t\\t.applyMatrix4( matrixWorld );\\n\\n\\t\\t\\t\\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\\n\\n\\t\\t\\t\\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\\n\\n\\t\\t\\t\\tidx = idx + 1;\\n\\n\\t\\t\\t\\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\\n\\n\\t\\t\\t\\tidx = idx + 1;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tposition.needsUpdate = true;\\n\\n\\t\\t};\\n\\n\\t}() );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction DirectionalLightHelper( light, size, color ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.light = light;\\n\\t\\tthis.light.updateMatrixWorld();\\n\\n\\t\\tthis.matrix = light.matrixWorld;\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\n\\t\\tthis.color = color;\\n\\n\\t\\tif ( size === undefined ) size = 1;\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( [\\n\\t\\t\\t- size, size, 0,\\n\\t\\t\\tsize, size, 0,\\n\\t\\t\\tsize, - size, 0,\\n\\t\\t\\t- size, - size, 0,\\n\\t\\t\\t- size, size, 0\\n\\t\\t], 3 ) );\\n\\n\\t\\tvar material = new LineBasicMaterial( { fog: false } );\\n\\n\\t\\tthis.lightPlane = new Line( geometry, material );\\n\\t\\tthis.add( this.lightPlane );\\n\\n\\t\\tgeometry = new BufferGeometry();\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\\n\\n\\t\\tthis.targetLine = new Line( geometry, material );\\n\\t\\tthis.add( this.targetLine );\\n\\n\\t\\tthis.update();\\n\\n\\t}\\n\\n\\tDirectionalLightHelper.prototype = Object.create( Object3D.prototype );\\n\\tDirectionalLightHelper.prototype.constructor = DirectionalLightHelper;\\n\\n\\tDirectionalLightHelper.prototype.dispose = function () {\\n\\n\\t\\tthis.lightPlane.geometry.dispose();\\n\\t\\tthis.lightPlane.material.dispose();\\n\\t\\tthis.targetLine.geometry.dispose();\\n\\t\\tthis.targetLine.material.dispose();\\n\\n\\t};\\n\\n\\tDirectionalLightHelper.prototype.update = function () {\\n\\n\\t\\tvar v1 = new Vector3();\\n\\t\\tvar v2 = new Vector3();\\n\\t\\tvar v3 = new Vector3();\\n\\n\\t\\treturn function update() {\\n\\n\\t\\t\\tv1.setFromMatrixPosition( this.light.matrixWorld );\\n\\t\\t\\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\\n\\t\\t\\tv3.subVectors( v2, v1 );\\n\\n\\t\\t\\tthis.lightPlane.lookAt( v3 );\\n\\n\\t\\t\\tif ( this.color !== undefined ) {\\n\\n\\t\\t\\t\\tthis.lightPlane.material.color.set( this.color );\\n\\t\\t\\t\\tthis.targetLine.material.color.set( this.color );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.lightPlane.material.color.copy( this.light.color );\\n\\t\\t\\t\\tthis.targetLine.material.color.copy( this.light.color );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.targetLine.lookAt( v3 );\\n\\t\\t\\tthis.targetLine.scale.z = v3.length();\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t *\\n\\t *\\t- shows frustum, line of sight and up of the camera\\n\\t *\\t- suitable for fast updates\\n\\t * \\t- based on frustum visualization in lightgl.js shadowmap example\\n\\t *\\t\\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\\n\\t */\\n\\n\\tfunction CameraHelper( camera ) {\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\t\\tvar material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );\\n\\n\\t\\tvar vertices = [];\\n\\t\\tvar colors = [];\\n\\n\\t\\tvar pointMap = {};\\n\\n\\t\\t// colors\\n\\n\\t\\tvar colorFrustum = new Color( 0xffaa00 );\\n\\t\\tvar colorCone = new Color( 0xff0000 );\\n\\t\\tvar colorUp = new Color( 0x00aaff );\\n\\t\\tvar colorTarget = new Color( 0xffffff );\\n\\t\\tvar colorCross = new Color( 0x333333 );\\n\\n\\t\\t// near\\n\\n\\t\\taddLine( 'n1', 'n2', colorFrustum );\\n\\t\\taddLine( 'n2', 'n4', colorFrustum );\\n\\t\\taddLine( 'n4', 'n3', colorFrustum );\\n\\t\\taddLine( 'n3', 'n1', colorFrustum );\\n\\n\\t\\t// far\\n\\n\\t\\taddLine( 'f1', 'f2', colorFrustum );\\n\\t\\taddLine( 'f2', 'f4', colorFrustum );\\n\\t\\taddLine( 'f4', 'f3', colorFrustum );\\n\\t\\taddLine( 'f3', 'f1', colorFrustum );\\n\\n\\t\\t// sides\\n\\n\\t\\taddLine( 'n1', 'f1', colorFrustum );\\n\\t\\taddLine( 'n2', 'f2', colorFrustum );\\n\\t\\taddLine( 'n3', 'f3', colorFrustum );\\n\\t\\taddLine( 'n4', 'f4', colorFrustum );\\n\\n\\t\\t// cone\\n\\n\\t\\taddLine( 'p', 'n1', colorCone );\\n\\t\\taddLine( 'p', 'n2', colorCone );\\n\\t\\taddLine( 'p', 'n3', colorCone );\\n\\t\\taddLine( 'p', 'n4', colorCone );\\n\\n\\t\\t// up\\n\\n\\t\\taddLine( 'u1', 'u2', colorUp );\\n\\t\\taddLine( 'u2', 'u3', colorUp );\\n\\t\\taddLine( 'u3', 'u1', colorUp );\\n\\n\\t\\t// target\\n\\n\\t\\taddLine( 'c', 't', colorTarget );\\n\\t\\taddLine( 'p', 'c', colorCross );\\n\\n\\t\\t// cross\\n\\n\\t\\taddLine( 'cn1', 'cn2', colorCross );\\n\\t\\taddLine( 'cn3', 'cn4', colorCross );\\n\\n\\t\\taddLine( 'cf1', 'cf2', colorCross );\\n\\t\\taddLine( 'cf3', 'cf4', colorCross );\\n\\n\\t\\tfunction addLine( a, b, color ) {\\n\\n\\t\\t\\taddPoint( a, color );\\n\\t\\t\\taddPoint( b, color );\\n\\n\\t\\t}\\n\\n\\t\\tfunction addPoint( id, color ) {\\n\\n\\t\\t\\tvertices.push( 0, 0, 0 );\\n\\t\\t\\tcolors.push( color.r, color.g, color.b );\\n\\n\\t\\t\\tif ( pointMap[ id ] === undefined ) {\\n\\n\\t\\t\\t\\tpointMap[ id ] = [];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tpointMap[ id ].push( ( vertices.length / 3 ) - 1 );\\n\\n\\t\\t}\\n\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\\n\\n\\t\\tLineSegments.call( this, geometry, material );\\n\\n\\t\\tthis.camera = camera;\\n\\t\\tif ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\\n\\n\\t\\tthis.matrix = camera.matrixWorld;\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\n\\t\\tthis.pointMap = pointMap;\\n\\n\\t\\tthis.update();\\n\\n\\t}\\n\\n\\tCameraHelper.prototype = Object.create( LineSegments.prototype );\\n\\tCameraHelper.prototype.constructor = CameraHelper;\\n\\n\\tCameraHelper.prototype.update = function () {\\n\\n\\t\\tvar geometry, pointMap;\\n\\n\\t\\tvar vector = new Vector3();\\n\\t\\tvar camera = new Camera();\\n\\n\\t\\tfunction setPoint( point, x, y, z ) {\\n\\n\\t\\t\\tvector.set( x, y, z ).unproject( camera );\\n\\n\\t\\t\\tvar points = pointMap[ point ];\\n\\n\\t\\t\\tif ( points !== undefined ) {\\n\\n\\t\\t\\t\\tvar position = geometry.getAttribute( 'position' );\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tposition.setXYZ( points[ i ], vector.x, vector.y, vector.z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn function update() {\\n\\n\\t\\t\\tgeometry = this.geometry;\\n\\t\\t\\tpointMap = this.pointMap;\\n\\n\\t\\t\\tvar w = 1, h = 1;\\n\\n\\t\\t\\t// we need just camera projection matrix\\n\\t\\t\\t// world matrix must be identity\\n\\n\\t\\t\\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\\n\\n\\t\\t\\t// center / target\\n\\n\\t\\t\\tsetPoint( 'c', 0, 0, - 1 );\\n\\t\\t\\tsetPoint( 't', 0, 0, 1 );\\n\\n\\t\\t\\t// near\\n\\n\\t\\t\\tsetPoint( 'n1', - w, - h, - 1 );\\n\\t\\t\\tsetPoint( 'n2', w, - h, - 1 );\\n\\t\\t\\tsetPoint( 'n3', - w, h, - 1 );\\n\\t\\t\\tsetPoint( 'n4', w, h, - 1 );\\n\\n\\t\\t\\t// far\\n\\n\\t\\t\\tsetPoint( 'f1', - w, - h, 1 );\\n\\t\\t\\tsetPoint( 'f2', w, - h, 1 );\\n\\t\\t\\tsetPoint( 'f3', - w, h, 1 );\\n\\t\\t\\tsetPoint( 'f4', w, h, 1 );\\n\\n\\t\\t\\t// up\\n\\n\\t\\t\\tsetPoint( 'u1', w * 0.7, h * 1.1, - 1 );\\n\\t\\t\\tsetPoint( 'u2', - w * 0.7, h * 1.1, - 1 );\\n\\t\\t\\tsetPoint( 'u3', 0, h * 2, - 1 );\\n\\n\\t\\t\\t// cross\\n\\n\\t\\t\\tsetPoint( 'cf1', - w, 0, 1 );\\n\\t\\t\\tsetPoint( 'cf2', w, 0, 1 );\\n\\t\\t\\tsetPoint( 'cf3', 0, - h, 1 );\\n\\t\\t\\tsetPoint( 'cf4', 0, h, 1 );\\n\\n\\t\\t\\tsetPoint( 'cn1', - w, 0, - 1 );\\n\\t\\t\\tsetPoint( 'cn2', w, 0, - 1 );\\n\\t\\t\\tsetPoint( 'cn3', 0, - h, - 1 );\\n\\t\\t\\tsetPoint( 'cn4', 0, h, - 1 );\\n\\n\\t\\t\\tgeometry.getAttribute( 'position' ).needsUpdate = true;\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author Mugen87 / http://github.com/Mugen87\\n\\t */\\n\\n\\tfunction BoxHelper( object, color ) {\\n\\n\\t\\tthis.object = object;\\n\\n\\t\\tif ( color === undefined ) color = 0xffff00;\\n\\n\\t\\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\\n\\t\\tvar positions = new Float32Array( 8 * 3 );\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\t\\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\\n\\t\\tgeometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );\\n\\n\\t\\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );\\n\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\n\\t\\tthis.update();\\n\\n\\t}\\n\\n\\tBoxHelper.prototype = Object.create( LineSegments.prototype );\\n\\tBoxHelper.prototype.constructor = BoxHelper;\\n\\n\\tBoxHelper.prototype.update = ( function () {\\n\\n\\t\\tvar box = new Box3();\\n\\n\\t\\treturn function update( object ) {\\n\\n\\t\\t\\tif ( object !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.object !== undefined ) {\\n\\n\\t\\t\\t\\tbox.setFromObject( this.object );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( box.isEmpty() ) return;\\n\\n\\t\\t\\tvar min = box.min;\\n\\t\\t\\tvar max = box.max;\\n\\n\\t\\t\\t/*\\n\\t\\t\\t  5____4\\n\\t\\t\\t1/___0/|\\n\\t\\t\\t| 6__|_7\\n\\t\\t\\t2/___3/\\n\\n\\t\\t\\t0: max.x, max.y, max.z\\n\\t\\t\\t1: min.x, max.y, max.z\\n\\t\\t\\t2: min.x, min.y, max.z\\n\\t\\t\\t3: max.x, min.y, max.z\\n\\t\\t\\t4: max.x, max.y, min.z\\n\\t\\t\\t5: min.x, max.y, min.z\\n\\t\\t\\t6: min.x, min.y, min.z\\n\\t\\t\\t7: max.x, min.y, min.z\\n\\t\\t\\t*/\\n\\n\\t\\t\\tvar position = this.geometry.attributes.position;\\n\\t\\t\\tvar array = position.array;\\n\\n\\t\\t\\tarray[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;\\n\\t\\t\\tarray[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;\\n\\t\\t\\tarray[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;\\n\\t\\t\\tarray[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\\n\\t\\t\\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\\n\\t\\t\\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\\n\\t\\t\\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\\n\\t\\t\\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\\n\\n\\t\\t\\tposition.needsUpdate = true;\\n\\n\\t\\t\\tthis.geometry.computeBoundingSphere();\\n\\n\\t\\t};\\n\\n\\t} )();\\n\\n\\tBoxHelper.prototype.setFromObject = function ( object ) {\\n\\n\\t\\tthis.object = object;\\n\\t\\tthis.update();\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction Box3Helper( box, hex ) {\\n\\n\\t\\tthis.type = 'Box3Helper';\\n\\n\\t\\tthis.box = box;\\n\\n\\t\\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\\n\\n\\t\\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\\n\\n\\t\\tvar positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\n\\t\\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\\n\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\\n\\n\\t\\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );\\n\\n\\t\\tthis.geometry.computeBoundingSphere();\\n\\n\\t}\\n\\n\\tBox3Helper.prototype = Object.create( LineSegments.prototype );\\n\\tBox3Helper.prototype.constructor = Box3Helper;\\n\\n\\tBox3Helper.prototype.updateMatrixWorld = function ( force ) {\\n\\n\\t\\tvar box = this.box;\\n\\n\\t\\tif ( box.isEmpty() ) return;\\n\\n\\t\\tbox.getCenter( this.position );\\n\\n\\t\\tbox.getSize( this.scale );\\n\\n\\t\\tthis.scale.multiplyScalar( 0.5 );\\n\\n\\t\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction PlaneHelper( plane, size, hex ) {\\n\\n\\t\\tthis.type = 'PlaneHelper';\\n\\n\\t\\tthis.plane = plane;\\n\\n\\t\\tthis.size = ( size === undefined ) ? 1 : size;\\n\\n\\t\\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\\n\\n\\t\\tvar positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\\n\\t\\tgeometry.computeBoundingSphere();\\n\\n\\t\\tLine.call( this, geometry, new LineBasicMaterial( { color: color } ) );\\n\\n\\t\\t//\\n\\n\\t\\tvar positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];\\n\\n\\t\\tvar geometry2 = new BufferGeometry();\\n\\t\\tgeometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );\\n\\t\\tgeometry2.computeBoundingSphere();\\n\\n\\t\\tthis.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false } ) ) );\\n\\n\\t}\\n\\n\\tPlaneHelper.prototype = Object.create( Line.prototype );\\n\\tPlaneHelper.prototype.constructor = PlaneHelper;\\n\\n\\tPlaneHelper.prototype.updateMatrixWorld = function ( force ) {\\n\\n\\t\\tvar scale = - this.plane.constant;\\n\\n\\t\\tif ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter\\n\\n\\t\\tthis.scale.set( 0.5 * this.size, 0.5 * this.size, scale );\\n\\n\\t\\tthis.lookAt( this.plane.normal );\\n\\n\\t\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t * @author zz85 / http://github.com/zz85\\n\\t * @author bhouston / http://clara.io\\n\\t *\\n\\t * Creates an arrow for visualizing directions\\n\\t *\\n\\t * Parameters:\\n\\t *  dir - Vector3\\n\\t *  origin - Vector3\\n\\t *  length - Number\\n\\t *  color - color in hex value\\n\\t *  headLength - Number\\n\\t *  headWidth - Number\\n\\t */\\n\\n\\tvar lineGeometry;\\n\\tvar coneGeometry;\\n\\n\\tfunction ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\\n\\n\\t\\t// dir is assumed to be normalized\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tif ( color === undefined ) color = 0xffff00;\\n\\t\\tif ( length === undefined ) length = 1;\\n\\t\\tif ( headLength === undefined ) headLength = 0.2 * length;\\n\\t\\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\\n\\n\\t\\tif ( lineGeometry === undefined ) {\\n\\n\\t\\t\\tlineGeometry = new BufferGeometry();\\n\\t\\t\\tlineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\\n\\n\\t\\t\\tconeGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );\\n\\t\\t\\tconeGeometry.translate( 0, - 0.5, 0 );\\n\\n\\t\\t}\\n\\n\\t\\tthis.position.copy( origin );\\n\\n\\t\\tthis.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );\\n\\t\\tthis.line.matrixAutoUpdate = false;\\n\\t\\tthis.add( this.line );\\n\\n\\t\\tthis.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );\\n\\t\\tthis.cone.matrixAutoUpdate = false;\\n\\t\\tthis.add( this.cone );\\n\\n\\t\\tthis.setDirection( dir );\\n\\t\\tthis.setLength( length, headLength, headWidth );\\n\\n\\t}\\n\\n\\tArrowHelper.prototype = Object.create( Object3D.prototype );\\n\\tArrowHelper.prototype.constructor = ArrowHelper;\\n\\n\\tArrowHelper.prototype.setDirection = ( function () {\\n\\n\\t\\tvar axis = new Vector3();\\n\\t\\tvar radians;\\n\\n\\t\\treturn function setDirection( dir ) {\\n\\n\\t\\t\\t// dir is assumed to be normalized\\n\\n\\t\\t\\tif ( dir.y > 0.99999 ) {\\n\\n\\t\\t\\t\\tthis.quaternion.set( 0, 0, 0, 1 );\\n\\n\\t\\t\\t} else if ( dir.y < - 0.99999 ) {\\n\\n\\t\\t\\t\\tthis.quaternion.set( 1, 0, 0, 0 );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\taxis.set( dir.z, 0, - dir.x ).normalize();\\n\\n\\t\\t\\t\\tradians = Math.acos( dir.y );\\n\\n\\t\\t\\t\\tthis.quaternion.setFromAxisAngle( axis, radians );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}() );\\n\\n\\tArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\\n\\n\\t\\tif ( headLength === undefined ) headLength = 0.2 * length;\\n\\t\\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\\n\\n\\t\\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\\n\\t\\tthis.line.updateMatrix();\\n\\n\\t\\tthis.cone.scale.set( headWidth, headLength, headWidth );\\n\\t\\tthis.cone.position.y = length;\\n\\t\\tthis.cone.updateMatrix();\\n\\n\\t};\\n\\n\\tArrowHelper.prototype.setColor = function ( color ) {\\n\\n\\t\\tthis.line.material.color.copy( color );\\n\\t\\tthis.cone.material.color.copy( color );\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author sroucheray / http://sroucheray.org/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction AxesHelper( size ) {\\n\\n\\t\\tsize = size || 1;\\n\\n\\t\\tvar vertices = [\\n\\t\\t\\t0, 0, 0,\\tsize, 0, 0,\\n\\t\\t\\t0, 0, 0,\\t0, size, 0,\\n\\t\\t\\t0, 0, 0,\\t0, 0, size\\n\\t\\t];\\n\\n\\t\\tvar colors = [\\n\\t\\t\\t1, 0, 0,\\t1, 0.6, 0,\\n\\t\\t\\t0, 1, 0,\\t0.6, 1, 0,\\n\\t\\t\\t0, 0, 1,\\t0, 0.6, 1\\n\\t\\t];\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\\n\\n\\t\\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\\n\\n\\t\\tLineSegments.call( this, geometry, material );\\n\\n\\t}\\n\\n\\tAxesHelper.prototype = Object.create( LineSegments.prototype );\\n\\tAxesHelper.prototype.constructor = AxesHelper;\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tvar SceneUtils = {\\n\\n\\t\\tcreateMultiMaterialObject: function ( geometry, materials ) {\\n\\n\\t\\t\\tvar group = new Group();\\n\\n\\t\\t\\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tgroup.add( new Mesh( geometry, materials[ i ] ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn group;\\n\\n\\t\\t},\\n\\n\\t\\tdetach: function ( child, parent, scene ) {\\n\\n\\t\\t\\tchild.applyMatrix( parent.matrixWorld );\\n\\t\\t\\tparent.remove( child );\\n\\t\\t\\tscene.add( child );\\n\\n\\t\\t},\\n\\n\\t\\tattach: function ( child, scene, parent ) {\\n\\n\\t\\t\\tchild.applyMatrix( new Matrix4().getInverse( parent.matrixWorld ) );\\n\\n\\t\\t\\tscene.remove( child );\\n\\t\\t\\tparent.add( child );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction Face4( a, b, c, d, normal, color, materialIndex ) {\\n\\n\\t\\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\\n\\t\\treturn new Face3( a, b, c, normal, color, materialIndex );\\n\\n\\t}\\n\\n\\tvar LineStrip = 0;\\n\\n\\tvar LinePieces = 1;\\n\\n\\tfunction MeshFaceMaterial( materials ) {\\n\\n\\t\\tconsole.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );\\n\\t\\treturn materials;\\n\\n\\t}\\n\\n\\tfunction MultiMaterial( materials ) {\\n\\n\\t\\tif ( materials === undefined ) materials = [];\\n\\n\\t\\tconsole.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );\\n\\t\\tmaterials.isMultiMaterial = true;\\n\\t\\tmaterials.materials = materials;\\n\\t\\tmaterials.clone = function () {\\n\\n\\t\\t\\treturn materials.slice();\\n\\n\\t\\t};\\n\\t\\treturn materials;\\n\\n\\t}\\n\\n\\tfunction PointCloud( geometry, material ) {\\n\\n\\t\\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\\n\\t\\treturn new Points( geometry, material );\\n\\n\\t}\\n\\n\\tfunction Particle( material ) {\\n\\n\\t\\tconsole.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );\\n\\t\\treturn new Sprite( material );\\n\\n\\t}\\n\\n\\tfunction ParticleSystem( geometry, material ) {\\n\\n\\t\\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\\n\\t\\treturn new Points( geometry, material );\\n\\n\\t}\\n\\n\\tfunction PointCloudMaterial( parameters ) {\\n\\n\\t\\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\\n\\t\\treturn new PointsMaterial( parameters );\\n\\n\\t}\\n\\n\\tfunction ParticleBasicMaterial( parameters ) {\\n\\n\\t\\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\\n\\t\\treturn new PointsMaterial( parameters );\\n\\n\\t}\\n\\n\\tfunction ParticleSystemMaterial( parameters ) {\\n\\n\\t\\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\\n\\t\\treturn new PointsMaterial( parameters );\\n\\n\\t}\\n\\n\\tfunction Vertex( x, y, z ) {\\n\\n\\t\\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\\n\\t\\treturn new Vector3( x, y, z );\\n\\n\\t}\\n\\n\\t//\\n\\n\\tfunction DynamicBufferAttribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\\n\\t\\treturn new BufferAttribute( array, itemSize ).setDynamic( true );\\n\\n\\t}\\n\\n\\tfunction Int8Attribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );\\n\\t\\treturn new Int8BufferAttribute( array, itemSize );\\n\\n\\t}\\n\\n\\tfunction Uint8Attribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );\\n\\t\\treturn new Uint8BufferAttribute( array, itemSize );\\n\\n\\t}\\n\\n\\tfunction Uint8ClampedAttribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );\\n\\t\\treturn new Uint8ClampedBufferAttribute( array, itemSize );\\n\\n\\t}\\n\\n\\tfunction Int16Attribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );\\n\\t\\treturn new Int16BufferAttribute( array, itemSize );\\n\\n\\t}\\n\\n\\tfunction Uint16Attribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );\\n\\t\\treturn new Uint16BufferAttribute( array, itemSize );\\n\\n\\t}\\n\\n\\tfunction Int32Attribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );\\n\\t\\treturn new Int32BufferAttribute( array, itemSize );\\n\\n\\t}\\n\\n\\tfunction Uint32Attribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );\\n\\t\\treturn new Uint32BufferAttribute( array, itemSize );\\n\\n\\t}\\n\\n\\tfunction Float32Attribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );\\n\\t\\treturn new Float32BufferAttribute( array, itemSize );\\n\\n\\t}\\n\\n\\tfunction Float64Attribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );\\n\\t\\treturn new Float64BufferAttribute( array, itemSize );\\n\\n\\t}\\n\\n\\t//\\n\\n\\tCurve.create = function ( construct, getPoint ) {\\n\\n\\t\\tconsole.log( 'THREE.Curve.create() has been deprecated' );\\n\\n\\t\\tconstruct.prototype = Object.create( Curve.prototype );\\n\\t\\tconstruct.prototype.constructor = construct;\\n\\t\\tconstruct.prototype.getPoint = getPoint;\\n\\n\\t\\treturn construct;\\n\\n\\t};\\n\\n\\t//\\n\\n\\tObject.assign( CurvePath.prototype, {\\n\\n\\t\\tcreatePointsGeometry: function ( divisions ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );\\n\\n\\t\\t\\t// generate geometry from path points (for Line or Points objects)\\n\\n\\t\\t\\tvar pts = this.getPoints( divisions );\\n\\t\\t\\treturn this.createGeometry( pts );\\n\\n\\t\\t},\\n\\n\\t\\tcreateSpacedPointsGeometry: function ( divisions ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );\\n\\n\\t\\t\\t// generate geometry from equidistant sampling along the path\\n\\n\\t\\t\\tvar pts = this.getSpacedPoints( divisions );\\n\\t\\t\\treturn this.createGeometry( pts );\\n\\n\\t\\t},\\n\\n\\t\\tcreateGeometry: function ( points ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );\\n\\n\\t\\t\\tvar geometry = new Geometry();\\n\\n\\t\\t\\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar point = points[ i ];\\n\\t\\t\\t\\tgeometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn geometry;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tObject.assign( Path.prototype, {\\n\\n\\t\\tfromPoints: function ( points ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );\\n\\t\\t\\tthis.setFromPoints( points );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tfunction ClosedSplineCurve3( points ) {\\n\\n\\t\\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );\\n\\n\\t\\tCatmullRomCurve3.call( this, points );\\n\\t\\tthis.type = 'catmullrom';\\n\\t\\tthis.closed = true;\\n\\n\\t}\\n\\n\\tClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );\\n\\n\\t//\\n\\n\\tfunction SplineCurve3( points ) {\\n\\n\\t\\tconsole.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );\\n\\n\\t\\tCatmullRomCurve3.call( this, points );\\n\\t\\tthis.type = 'catmullrom';\\n\\n\\t}\\n\\n\\tSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );\\n\\n\\t//\\n\\n\\tfunction Spline( points ) {\\n\\n\\t\\tconsole.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );\\n\\n\\t\\tCatmullRomCurve3.call( this, points );\\n\\t\\tthis.type = 'catmullrom';\\n\\n\\t}\\n\\n\\tSpline.prototype = Object.create( CatmullRomCurve3.prototype );\\n\\n\\tObject.assign( Spline.prototype, {\\n\\n\\t\\tinitFromArray: function ( /* a */ ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.Spline: .initFromArray() has been removed.' );\\n\\n\\t\\t},\\n\\t\\tgetControlPointsArray: function ( /* optionalTarget */ ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );\\n\\n\\t\\t},\\n\\t\\treparametrizeByArcLength: function ( /* samplingCoef */ ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tfunction AxisHelper( size ) {\\n\\n\\t\\tconsole.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );\\n\\t\\treturn new AxesHelper( size );\\n\\n\\t}\\n\\n\\tfunction BoundingBoxHelper( object, color ) {\\n\\n\\t\\tconsole.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );\\n\\t\\treturn new BoxHelper( object, color );\\n\\n\\t}\\n\\n\\tfunction EdgesHelper( object, hex ) {\\n\\n\\t\\tconsole.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );\\n\\t\\treturn new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\\n\\n\\t}\\n\\n\\tGridHelper.prototype.setColors = function () {\\n\\n\\t\\tconsole.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\\n\\n\\t};\\n\\n\\tSkeletonHelper.prototype.update = function () {\\n\\n\\t\\tconsole.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );\\n\\n\\t};\\n\\n\\tfunction WireframeHelper( object, hex ) {\\n\\n\\t\\tconsole.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );\\n\\t\\treturn new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\\n\\n\\t}\\n\\n\\t//\\n\\n\\tObject.assign( Loader.prototype, {\\n\\n\\t\\textractUrlBase: function ( url ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );\\n\\t\\t\\treturn LoaderUtils.extractUrlBase( url );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tfunction XHRLoader( manager ) {\\n\\n\\t\\tconsole.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );\\n\\t\\treturn new FileLoader( manager );\\n\\n\\t}\\n\\n\\tfunction BinaryTextureLoader( manager ) {\\n\\n\\t\\tconsole.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );\\n\\t\\treturn new DataTextureLoader( manager );\\n\\n\\t}\\n\\n\\t//\\n\\n\\tObject.assign( Box2.prototype, {\\n\\n\\t\\tcenter: function ( optionalTarget ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );\\n\\t\\t\\treturn this.getCenter( optionalTarget );\\n\\n\\t\\t},\\n\\t\\tempty: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\\n\\t\\t\\treturn this.isEmpty();\\n\\n\\t\\t},\\n\\t\\tisIntersectionBox: function ( box ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\\n\\t\\t\\treturn this.intersectsBox( box );\\n\\n\\t\\t},\\n\\t\\tsize: function ( optionalTarget ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );\\n\\t\\t\\treturn this.getSize( optionalTarget );\\n\\n\\t\\t}\\n\\t} );\\n\\n\\tObject.assign( Box3.prototype, {\\n\\n\\t\\tcenter: function ( optionalTarget ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );\\n\\t\\t\\treturn this.getCenter( optionalTarget );\\n\\n\\t\\t},\\n\\t\\tempty: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\\n\\t\\t\\treturn this.isEmpty();\\n\\n\\t\\t},\\n\\t\\tisIntersectionBox: function ( box ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\\n\\t\\t\\treturn this.intersectsBox( box );\\n\\n\\t\\t},\\n\\t\\tisIntersectionSphere: function ( sphere ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\\n\\t\\t\\treturn this.intersectsSphere( sphere );\\n\\n\\t\\t},\\n\\t\\tsize: function ( optionalTarget ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );\\n\\t\\t\\treturn this.getSize( optionalTarget );\\n\\n\\t\\t}\\n\\t} );\\n\\n\\tLine3.prototype.center = function ( optionalTarget ) {\\n\\n\\t\\tconsole.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );\\n\\t\\treturn this.getCenter( optionalTarget );\\n\\n\\t};\\n\\n\\tObject.assign( _Math, {\\n\\n\\t\\trandom16: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );\\n\\t\\t\\treturn Math.random();\\n\\n\\t\\t},\\n\\n\\t\\tnearestPowerOfTwo: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );\\n\\t\\t\\treturn _Math.floorPowerOfTwo( value );\\n\\n\\t\\t},\\n\\n\\t\\tnextPowerOfTwo: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );\\n\\t\\t\\treturn _Math.ceilPowerOfTwo( value );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( Matrix3.prototype, {\\n\\n\\t\\tflattenToArrayOffset: function ( array, offset ) {\\n\\n\\t\\t\\tconsole.warn( \\\"THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\\\" );\\n\\t\\t\\treturn this.toArray( array, offset );\\n\\n\\t\\t},\\n\\t\\tmultiplyVector3: function ( vector ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\\n\\t\\t\\treturn vector.applyMatrix3( this );\\n\\n\\t\\t},\\n\\t\\tmultiplyVector3Array: function ( /* a */ ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );\\n\\n\\t\\t},\\n\\t\\tapplyToBuffer: function ( buffer /*, offset, length */ ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );\\n\\t\\t\\treturn this.applyToBufferAttribute( buffer );\\n\\n\\t\\t},\\n\\t\\tapplyToVector3Array: function ( /* array, offset, length */ ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( Matrix4.prototype, {\\n\\n\\t\\textractPosition: function ( m ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\\n\\t\\t\\treturn this.copyPosition( m );\\n\\n\\t\\t},\\n\\t\\tflattenToArrayOffset: function ( array, offset ) {\\n\\n\\t\\t\\tconsole.warn( \\\"THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\\\" );\\n\\t\\t\\treturn this.toArray( array, offset );\\n\\n\\t\\t},\\n\\t\\tgetPosition: function () {\\n\\n\\t\\t\\tvar v1;\\n\\n\\t\\t\\treturn function getPosition() {\\n\\n\\t\\t\\t\\tif ( v1 === undefined ) v1 = new Vector3();\\n\\t\\t\\t\\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\\n\\t\\t\\t\\treturn v1.setFromMatrixColumn( this, 3 );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\t\\tsetRotationFromQuaternion: function ( q ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\\n\\t\\t\\treturn this.makeRotationFromQuaternion( q );\\n\\n\\t\\t},\\n\\t\\tmultiplyToArray: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );\\n\\n\\t\\t},\\n\\t\\tmultiplyVector3: function ( vector ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\\n\\t\\t\\treturn vector.applyMatrix4( this );\\n\\n\\t\\t},\\n\\t\\tmultiplyVector4: function ( vector ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\\n\\t\\t\\treturn vector.applyMatrix4( this );\\n\\n\\t\\t},\\n\\t\\tmultiplyVector3Array: function ( /* a */ ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );\\n\\n\\t\\t},\\n\\t\\trotateAxis: function ( v ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\\n\\t\\t\\tv.transformDirection( this );\\n\\n\\t\\t},\\n\\t\\tcrossVector: function ( vector ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\\n\\t\\t\\treturn vector.applyMatrix4( this );\\n\\n\\t\\t},\\n\\t\\ttranslate: function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\\n\\n\\t\\t},\\n\\t\\trotateX: function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\\n\\n\\t\\t},\\n\\t\\trotateY: function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\\n\\n\\t\\t},\\n\\t\\trotateZ: function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\\n\\n\\t\\t},\\n\\t\\trotateByAxis: function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\\n\\n\\t\\t},\\n\\t\\tapplyToBuffer: function ( buffer /*, offset, length */ ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );\\n\\t\\t\\treturn this.applyToBufferAttribute( buffer );\\n\\n\\t\\t},\\n\\t\\tapplyToVector3Array: function ( /* array, offset, length */ ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );\\n\\n\\t\\t},\\n\\t\\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );\\n\\t\\t\\treturn this.makePerspective( left, right, top, bottom, near, far );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tPlane.prototype.isIntersectionLine = function ( line ) {\\n\\n\\t\\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\\n\\t\\treturn this.intersectsLine( line );\\n\\n\\t};\\n\\n\\tQuaternion.prototype.multiplyVector3 = function ( vector ) {\\n\\n\\t\\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\\n\\t\\treturn vector.applyQuaternion( this );\\n\\n\\t};\\n\\n\\tObject.assign( Ray.prototype, {\\n\\n\\t\\tisIntersectionBox: function ( box ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\\n\\t\\t\\treturn this.intersectsBox( box );\\n\\n\\t\\t},\\n\\t\\tisIntersectionPlane: function ( plane ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\\n\\t\\t\\treturn this.intersectsPlane( plane );\\n\\n\\t\\t},\\n\\t\\tisIntersectionSphere: function ( sphere ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\\n\\t\\t\\treturn this.intersectsSphere( sphere );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( Shape.prototype, {\\n\\n\\t\\textractAllPoints: function ( divisions ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );\\n\\t\\t\\treturn this.extractPoints( divisions );\\n\\n\\t\\t},\\n\\t\\textrude: function ( options ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );\\n\\t\\t\\treturn new ExtrudeGeometry( this, options );\\n\\n\\t\\t},\\n\\t\\tmakeGeometry: function ( options ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );\\n\\t\\t\\treturn new ShapeGeometry( this, options );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( Vector2.prototype, {\\n\\n\\t\\tfromAttribute: function ( attribute, index, offset ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );\\n\\t\\t\\treturn this.fromBufferAttribute( attribute, index, offset );\\n\\n\\t\\t},\\n\\t\\tdistanceToManhattan: function ( v ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );\\n\\t\\t\\treturn this.manhattanDistanceTo( v );\\n\\n\\t\\t},\\n\\t\\tlengthManhattan: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );\\n\\t\\t\\treturn this.manhattanLength();\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( Vector3.prototype, {\\n\\n\\t\\tsetEulerFromRotationMatrix: function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\\n\\n\\t\\t},\\n\\t\\tsetEulerFromQuaternion: function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\\n\\n\\t\\t},\\n\\t\\tgetPositionFromMatrix: function ( m ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\\n\\t\\t\\treturn this.setFromMatrixPosition( m );\\n\\n\\t\\t},\\n\\t\\tgetScaleFromMatrix: function ( m ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\\n\\t\\t\\treturn this.setFromMatrixScale( m );\\n\\n\\t\\t},\\n\\t\\tgetColumnFromMatrix: function ( index, matrix ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\\n\\t\\t\\treturn this.setFromMatrixColumn( matrix, index );\\n\\n\\t\\t},\\n\\t\\tapplyProjection: function ( m ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );\\n\\t\\t\\treturn this.applyMatrix4( m );\\n\\n\\t\\t},\\n\\t\\tfromAttribute: function ( attribute, index, offset ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );\\n\\t\\t\\treturn this.fromBufferAttribute( attribute, index, offset );\\n\\n\\t\\t},\\n\\t\\tdistanceToManhattan: function ( v ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );\\n\\t\\t\\treturn this.manhattanDistanceTo( v );\\n\\n\\t\\t},\\n\\t\\tlengthManhattan: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );\\n\\t\\t\\treturn this.manhattanLength();\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( Vector4.prototype, {\\n\\n\\t\\tfromAttribute: function ( attribute, index, offset ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );\\n\\t\\t\\treturn this.fromBufferAttribute( attribute, index, offset );\\n\\n\\t\\t},\\n\\t\\tlengthManhattan: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );\\n\\t\\t\\treturn this.manhattanLength();\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tGeometry.prototype.computeTangents = function () {\\n\\n\\t\\tconsole.warn( 'THREE.Geometry: .computeTangents() has been removed.' );\\n\\n\\t};\\n\\n\\tObject.assign( Object3D.prototype, {\\n\\n\\t\\tgetChildByName: function ( name ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\\n\\t\\t\\treturn this.getObjectByName( name );\\n\\n\\t\\t},\\n\\t\\trenderDepth: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\\n\\n\\t\\t},\\n\\t\\ttranslate: function ( distance, axis ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\\n\\t\\t\\treturn this.translateOnAxis( axis, distance );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperties( Object3D.prototype, {\\n\\n\\t\\teulerOrder: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\\n\\t\\t\\t\\treturn this.rotation.order;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\\n\\t\\t\\t\\tthis.rotation.order = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tuseQuaternion: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperties( LOD.prototype, {\\n\\n\\t\\tobjects: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\\n\\t\\t\\t\\treturn this.levels;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperty( Skeleton.prototype, 'useVertexTexture', {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );\\n\\n\\t\\t},\\n\\t\\tset: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperty( Curve.prototype, '__arcLengthDivisions', {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );\\n\\t\\t\\treturn this.arcLengthDivisions;\\n\\n\\t\\t},\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );\\n\\t\\t\\tthis.arcLengthDivisions = value;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tPerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\\n\\n\\t\\tconsole.warn( \\\"THREE.PerspectiveCamera.setLens is deprecated. \\\" +\\n\\t\\t\\t\\t\\\"Use .setFocalLength and .filmGauge for a photographic setup.\\\" );\\n\\n\\t\\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\\n\\t\\tthis.setFocalLength( focalLength );\\n\\n\\t};\\n\\n\\t//\\n\\n\\tObject.defineProperties( Light.prototype, {\\n\\t\\tonlyShadow: {\\n\\t\\t\\tset: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowCameraFov: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\\n\\t\\t\\t\\tthis.shadow.camera.fov = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowCameraLeft: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\\n\\t\\t\\t\\tthis.shadow.camera.left = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowCameraRight: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\\n\\t\\t\\t\\tthis.shadow.camera.right = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowCameraTop: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\\n\\t\\t\\t\\tthis.shadow.camera.top = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowCameraBottom: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\\n\\t\\t\\t\\tthis.shadow.camera.bottom = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowCameraNear: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\\n\\t\\t\\t\\tthis.shadow.camera.near = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowCameraFar: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\\n\\t\\t\\t\\tthis.shadow.camera.far = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowCameraVisible: {\\n\\t\\t\\tset: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowBias: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\\n\\t\\t\\t\\tthis.shadow.bias = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowDarkness: {\\n\\t\\t\\tset: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowMapWidth: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\\n\\t\\t\\t\\tthis.shadow.mapSize.width = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowMapHeight: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\\n\\t\\t\\t\\tthis.shadow.mapSize.height = value;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} );\\n\\n\\t//\\n\\n\\tObject.defineProperties( BufferAttribute.prototype, {\\n\\n\\t\\tlength: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );\\n\\t\\t\\t\\treturn this.array.length;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( BufferGeometry.prototype, {\\n\\n\\t\\taddIndex: function ( index ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\\n\\t\\t\\tthis.setIndex( index );\\n\\n\\t\\t},\\n\\t\\taddDrawCall: function ( start, count, indexOffset ) {\\n\\n\\t\\t\\tif ( indexOffset !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\\n\\n\\t\\t\\t}\\n\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\\n\\t\\t\\tthis.addGroup( start, count );\\n\\n\\t\\t},\\n\\t\\tclearDrawCalls: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\\n\\t\\t\\tthis.clearGroups();\\n\\n\\t\\t},\\n\\t\\tcomputeTangents: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\\n\\n\\t\\t},\\n\\t\\tcomputeOffsets: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperties( BufferGeometry.prototype, {\\n\\n\\t\\tdrawcalls: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\\n\\t\\t\\t\\treturn this.groups;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\toffsets: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\\n\\t\\t\\t\\treturn this.groups;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tObject.defineProperties( Uniform.prototype, {\\n\\n\\t\\tdynamic: {\\n\\t\\t\\tset: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tonUpdate: {\\n\\t\\t\\tvalue: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tObject.defineProperties( Material.prototype, {\\n\\n\\t\\twrapAround: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Material: .wrapAround has been removed.' );\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Material: .wrapAround has been removed.' );\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\twrapRGB: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Material: .wrapRGB has been removed.' );\\n\\t\\t\\t\\treturn new Color();\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tshading: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\\n\\t\\t\\t\\tthis.flatShading = ( value === FlatShading );\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperties( MeshPhongMaterial.prototype, {\\n\\n\\t\\tmetal: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperties( ShaderMaterial.prototype, {\\n\\n\\t\\tderivatives: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\\n\\t\\t\\t\\treturn this.extensions.derivatives;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\\n\\t\\t\\t\\tthis.extensions.derivatives = value;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tObject.assign( WebGLRenderer.prototype, {\\n\\n\\t\\tgetCurrentRenderTarget: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );\\n\\t\\t\\treturn this.getRenderTarget();\\n\\n\\t\\t},\\n\\n\\t\\tgetMaxAnisotropy: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );\\n\\t\\t\\treturn this.capabilities.getMaxAnisotropy();\\n\\n\\t\\t},\\n\\n\\t\\tgetPrecision: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );\\n\\t\\t\\treturn this.capabilities.precision;\\n\\n\\t\\t},\\n\\n\\t\\tresetGLState: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );\\n\\t\\t\\treturn this.state.reset();\\n\\n\\t\\t},\\n\\n\\t\\tsupportsFloatTextures: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\\\'OES_texture_float\\\\' ).' );\\n\\t\\t\\treturn this.extensions.get( 'OES_texture_float' );\\n\\n\\t\\t},\\n\\t\\tsupportsHalfFloatTextures: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\\\'OES_texture_half_float\\\\' ).' );\\n\\t\\t\\treturn this.extensions.get( 'OES_texture_half_float' );\\n\\n\\t\\t},\\n\\t\\tsupportsStandardDerivatives: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\\\'OES_standard_derivatives\\\\' ).' );\\n\\t\\t\\treturn this.extensions.get( 'OES_standard_derivatives' );\\n\\n\\t\\t},\\n\\t\\tsupportsCompressedTextureS3TC: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\\\'WEBGL_compressed_texture_s3tc\\\\' ).' );\\n\\t\\t\\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\\n\\n\\t\\t},\\n\\t\\tsupportsCompressedTexturePVRTC: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\\\'WEBGL_compressed_texture_pvrtc\\\\' ).' );\\n\\t\\t\\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\\n\\n\\t\\t},\\n\\t\\tsupportsBlendMinMax: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\\\'EXT_blend_minmax\\\\' ).' );\\n\\t\\t\\treturn this.extensions.get( 'EXT_blend_minmax' );\\n\\n\\t\\t},\\n\\t\\tsupportsVertexTextures: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );\\n\\t\\t\\treturn this.capabilities.vertexTextures;\\n\\n\\t\\t},\\n\\t\\tsupportsInstancedArrays: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\\\'ANGLE_instanced_arrays\\\\' ).' );\\n\\t\\t\\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\\n\\n\\t\\t},\\n\\t\\tenableScissorTest: function ( boolean ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\\n\\t\\t\\tthis.setScissorTest( boolean );\\n\\n\\t\\t},\\n\\t\\tinitMaterial: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\\n\\n\\t\\t},\\n\\t\\taddPrePlugin: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\\n\\n\\t\\t},\\n\\t\\taddPostPlugin: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\\n\\n\\t\\t},\\n\\t\\tupdateShadowMap: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperties( WebGLRenderer.prototype, {\\n\\n\\t\\tshadowMapEnabled: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this.shadowMap.enabled;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\\n\\t\\t\\t\\tthis.shadowMap.enabled = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowMapType: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this.shadowMap.type;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\\n\\t\\t\\t\\tthis.shadowMap.type = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowMapCullFace: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this.shadowMap.cullFace;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );\\n\\t\\t\\t\\tthis.shadowMap.cullFace = value;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} );\\n\\n\\tObject.defineProperties( WebGLShadowMap.prototype, {\\n\\n\\t\\tcullFace: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this.renderReverseSided ? CullFaceFront : CullFaceBack;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( cullFace ) {\\n\\n\\t\\t\\t\\tvar value = ( cullFace !== CullFaceBack );\\n\\t\\t\\t\\tconsole.warn( \\\"WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to \\\" + value + \\\".\\\" );\\n\\t\\t\\t\\tthis.renderReverseSided = value;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tObject.defineProperties( WebGLRenderTarget.prototype, {\\n\\n\\t\\twrapS: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\\n\\t\\t\\t\\treturn this.texture.wrapS;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\\n\\t\\t\\t\\tthis.texture.wrapS = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\twrapT: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\\n\\t\\t\\t\\treturn this.texture.wrapT;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\\n\\t\\t\\t\\tthis.texture.wrapT = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tmagFilter: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\\n\\t\\t\\t\\treturn this.texture.magFilter;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\\n\\t\\t\\t\\tthis.texture.magFilter = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tminFilter: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\\n\\t\\t\\t\\treturn this.texture.minFilter;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\\n\\t\\t\\t\\tthis.texture.minFilter = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tanisotropy: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\\n\\t\\t\\t\\treturn this.texture.anisotropy;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\\n\\t\\t\\t\\tthis.texture.anisotropy = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\toffset: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\\n\\t\\t\\t\\treturn this.texture.offset;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\\n\\t\\t\\t\\tthis.texture.offset = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\trepeat: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\\n\\t\\t\\t\\treturn this.texture.repeat;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\\n\\t\\t\\t\\tthis.texture.repeat = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tformat: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\\n\\t\\t\\t\\treturn this.texture.format;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\\n\\t\\t\\t\\tthis.texture.format = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\ttype: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\\n\\t\\t\\t\\treturn this.texture.type;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\\n\\t\\t\\t\\tthis.texture.type = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tgenerateMipmaps: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\\n\\t\\t\\t\\treturn this.texture.generateMipmaps;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\\n\\t\\t\\t\\tthis.texture.generateMipmaps = value;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tObject.assign( WebVRManager.prototype, {\\n\\n\\t\\tgetStandingMatrix: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebVRManager: .getStandingMatrix() has been removed.' );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperties( WebVRManager.prototype, {\\n\\n\\t\\tstanding: {\\n\\t\\t\\tset: function ( /* value */ ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebVRManager: .standing has been removed.' );\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tAudio.prototype.load = function ( file ) {\\n\\n\\t\\tconsole.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );\\n\\t\\tvar scope = this;\\n\\t\\tvar audioLoader = new AudioLoader();\\n\\t\\taudioLoader.load( file, function ( buffer ) {\\n\\n\\t\\t\\tscope.setBuffer( buffer );\\n\\n\\t\\t} );\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tAudioAnalyser.prototype.getData = function () {\\n\\n\\t\\tconsole.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\\n\\t\\treturn this.getFrequencyData();\\n\\n\\t};\\n\\n\\t//\\n\\n\\tCubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {\\n\\n\\t\\tconsole.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );\\n\\t\\treturn this.update( renderer, scene );\\n\\n\\t};\\n\\n\\t//\\n\\n\\tvar GeometryUtils = {\\n\\n\\t\\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\\n\\t\\t\\tvar matrix;\\n\\n\\t\\t\\tif ( geometry2.isMesh ) {\\n\\n\\t\\t\\t\\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\\n\\n\\t\\t\\t\\tmatrix = geometry2.matrix;\\n\\t\\t\\t\\tgeometry2 = geometry2.geometry;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\\n\\n\\t\\t},\\n\\n\\t\\tcenter: function ( geometry ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\\n\\t\\t\\treturn geometry.center();\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tvar ImageUtils = {\\n\\n\\t\\tcrossOrigin: undefined,\\n\\n\\t\\tloadTexture: function ( url, mapping, onLoad, onError ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\\n\\n\\t\\t\\tvar loader = new TextureLoader();\\n\\t\\t\\tloader.setCrossOrigin( this.crossOrigin );\\n\\n\\t\\t\\tvar texture = loader.load( url, onLoad, undefined, onError );\\n\\n\\t\\t\\tif ( mapping ) texture.mapping = mapping;\\n\\n\\t\\t\\treturn texture;\\n\\n\\t\\t},\\n\\n\\t\\tloadTextureCube: function ( urls, mapping, onLoad, onError ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\\n\\n\\t\\t\\tvar loader = new CubeTextureLoader();\\n\\t\\t\\tloader.setCrossOrigin( this.crossOrigin );\\n\\n\\t\\t\\tvar texture = loader.load( urls, onLoad, undefined, onError );\\n\\n\\t\\t\\tif ( mapping ) texture.mapping = mapping;\\n\\n\\t\\t\\treturn texture;\\n\\n\\t\\t},\\n\\n\\t\\tloadCompressedTexture: function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\\n\\n\\t\\t},\\n\\n\\t\\tloadCompressedTextureCube: function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t//\\n\\n\\tfunction Projector() {\\n\\n\\t\\tconsole.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\\n\\n\\t\\tthis.projectVector = function ( vector, camera ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\\n\\t\\t\\tvector.project( camera );\\n\\n\\t\\t};\\n\\n\\t\\tthis.unprojectVector = function ( vector, camera ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\\n\\t\\t\\tvector.unproject( camera );\\n\\n\\t\\t};\\n\\n\\t\\tthis.pickingRay = function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t//\\n\\n\\tfunction CanvasRenderer() {\\n\\n\\t\\tconsole.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\\n\\n\\t\\tthis.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\\n\\t\\tthis.clear = function () {};\\n\\t\\tthis.render = function () {};\\n\\t\\tthis.setClearColor = function () {};\\n\\t\\tthis.setSize = function () {};\\n\\n\\t}\\n\\n\\texports.WebGLRenderTargetCube = WebGLRenderTargetCube;\\n\\texports.WebGLRenderTarget = WebGLRenderTarget;\\n\\texports.WebGLRenderer = WebGLRenderer;\\n\\texports.ShaderLib = ShaderLib;\\n\\texports.UniformsLib = UniformsLib;\\n\\texports.UniformsUtils = UniformsUtils;\\n\\texports.ShaderChunk = ShaderChunk;\\n\\texports.FogExp2 = FogExp2;\\n\\texports.Fog = Fog;\\n\\texports.Scene = Scene;\\n\\texports.LensFlare = LensFlare;\\n\\texports.Sprite = Sprite;\\n\\texports.LOD = LOD;\\n\\texports.SkinnedMesh = SkinnedMesh;\\n\\texports.Skeleton = Skeleton;\\n\\texports.Bone = Bone;\\n\\texports.Mesh = Mesh;\\n\\texports.LineSegments = LineSegments;\\n\\texports.LineLoop = LineLoop;\\n\\texports.Line = Line;\\n\\texports.Points = Points;\\n\\texports.Group = Group;\\n\\texports.VideoTexture = VideoTexture;\\n\\texports.DataTexture = DataTexture;\\n\\texports.CompressedTexture = CompressedTexture;\\n\\texports.CubeTexture = CubeTexture;\\n\\texports.CanvasTexture = CanvasTexture;\\n\\texports.DepthTexture = DepthTexture;\\n\\texports.Texture = Texture;\\n\\texports.CompressedTextureLoader = CompressedTextureLoader;\\n\\texports.DataTextureLoader = DataTextureLoader;\\n\\texports.CubeTextureLoader = CubeTextureLoader;\\n\\texports.TextureLoader = TextureLoader;\\n\\texports.ObjectLoader = ObjectLoader;\\n\\texports.MaterialLoader = MaterialLoader;\\n\\texports.BufferGeometryLoader = BufferGeometryLoader;\\n\\texports.DefaultLoadingManager = DefaultLoadingManager;\\n\\texports.LoadingManager = LoadingManager;\\n\\texports.JSONLoader = JSONLoader;\\n\\texports.ImageLoader = ImageLoader;\\n\\texports.ImageBitmapLoader = ImageBitmapLoader;\\n\\texports.FontLoader = FontLoader;\\n\\texports.FileLoader = FileLoader;\\n\\texports.Loader = Loader;\\n\\texports.LoaderUtils = LoaderUtils;\\n\\texports.Cache = Cache;\\n\\texports.AudioLoader = AudioLoader;\\n\\texports.SpotLightShadow = SpotLightShadow;\\n\\texports.SpotLight = SpotLight;\\n\\texports.PointLight = PointLight;\\n\\texports.RectAreaLight = RectAreaLight;\\n\\texports.HemisphereLight = HemisphereLight;\\n\\texports.DirectionalLightShadow = DirectionalLightShadow;\\n\\texports.DirectionalLight = DirectionalLight;\\n\\texports.AmbientLight = AmbientLight;\\n\\texports.LightShadow = LightShadow;\\n\\texports.Light = Light;\\n\\texports.StereoCamera = StereoCamera;\\n\\texports.PerspectiveCamera = PerspectiveCamera;\\n\\texports.OrthographicCamera = OrthographicCamera;\\n\\texports.CubeCamera = CubeCamera;\\n\\texports.ArrayCamera = ArrayCamera;\\n\\texports.Camera = Camera;\\n\\texports.AudioListener = AudioListener;\\n\\texports.PositionalAudio = PositionalAudio;\\n\\texports.AudioContext = AudioContext;\\n\\texports.AudioAnalyser = AudioAnalyser;\\n\\texports.Audio = Audio;\\n\\texports.VectorKeyframeTrack = VectorKeyframeTrack;\\n\\texports.StringKeyframeTrack = StringKeyframeTrack;\\n\\texports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;\\n\\texports.NumberKeyframeTrack = NumberKeyframeTrack;\\n\\texports.ColorKeyframeTrack = ColorKeyframeTrack;\\n\\texports.BooleanKeyframeTrack = BooleanKeyframeTrack;\\n\\texports.PropertyMixer = PropertyMixer;\\n\\texports.PropertyBinding = PropertyBinding;\\n\\texports.KeyframeTrack = KeyframeTrack;\\n\\texports.AnimationUtils = AnimationUtils;\\n\\texports.AnimationObjectGroup = AnimationObjectGroup;\\n\\texports.AnimationMixer = AnimationMixer;\\n\\texports.AnimationClip = AnimationClip;\\n\\texports.Uniform = Uniform;\\n\\texports.InstancedBufferGeometry = InstancedBufferGeometry;\\n\\texports.BufferGeometry = BufferGeometry;\\n\\texports.Geometry = Geometry;\\n\\texports.InterleavedBufferAttribute = InterleavedBufferAttribute;\\n\\texports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;\\n\\texports.InterleavedBuffer = InterleavedBuffer;\\n\\texports.InstancedBufferAttribute = InstancedBufferAttribute;\\n\\texports.Face3 = Face3;\\n\\texports.Object3D = Object3D;\\n\\texports.Raycaster = Raycaster;\\n\\texports.Layers = Layers;\\n\\texports.EventDispatcher = EventDispatcher;\\n\\texports.Clock = Clock;\\n\\texports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;\\n\\texports.LinearInterpolant = LinearInterpolant;\\n\\texports.DiscreteInterpolant = DiscreteInterpolant;\\n\\texports.CubicInterpolant = CubicInterpolant;\\n\\texports.Interpolant = Interpolant;\\n\\texports.Triangle = Triangle;\\n\\texports.Math = _Math;\\n\\texports.Spherical = Spherical;\\n\\texports.Cylindrical = Cylindrical;\\n\\texports.Plane = Plane;\\n\\texports.Frustum = Frustum;\\n\\texports.Sphere = Sphere;\\n\\texports.Ray = Ray;\\n\\texports.Matrix4 = Matrix4;\\n\\texports.Matrix3 = Matrix3;\\n\\texports.Box3 = Box3;\\n\\texports.Box2 = Box2;\\n\\texports.Line3 = Line3;\\n\\texports.Euler = Euler;\\n\\texports.Vector4 = Vector4;\\n\\texports.Vector3 = Vector3;\\n\\texports.Vector2 = Vector2;\\n\\texports.Quaternion = Quaternion;\\n\\texports.Color = Color;\\n\\texports.ImmediateRenderObject = ImmediateRenderObject;\\n\\texports.VertexNormalsHelper = VertexNormalsHelper;\\n\\texports.SpotLightHelper = SpotLightHelper;\\n\\texports.SkeletonHelper = SkeletonHelper;\\n\\texports.PointLightHelper = PointLightHelper;\\n\\texports.RectAreaLightHelper = RectAreaLightHelper;\\n\\texports.HemisphereLightHelper = HemisphereLightHelper;\\n\\texports.GridHelper = GridHelper;\\n\\texports.PolarGridHelper = PolarGridHelper;\\n\\texports.FaceNormalsHelper = FaceNormalsHelper;\\n\\texports.DirectionalLightHelper = DirectionalLightHelper;\\n\\texports.CameraHelper = CameraHelper;\\n\\texports.BoxHelper = BoxHelper;\\n\\texports.Box3Helper = Box3Helper;\\n\\texports.PlaneHelper = PlaneHelper;\\n\\texports.ArrowHelper = ArrowHelper;\\n\\texports.AxesHelper = AxesHelper;\\n\\texports.Shape = Shape;\\n\\texports.Path = Path;\\n\\texports.ShapePath = ShapePath;\\n\\texports.Font = Font;\\n\\texports.CurvePath = CurvePath;\\n\\texports.Curve = Curve;\\n\\texports.ShapeUtils = ShapeUtils;\\n\\texports.SceneUtils = SceneUtils;\\n\\texports.WebGLUtils = WebGLUtils;\\n\\texports.WireframeGeometry = WireframeGeometry;\\n\\texports.ParametricGeometry = ParametricGeometry;\\n\\texports.ParametricBufferGeometry = ParametricBufferGeometry;\\n\\texports.TetrahedronGeometry = TetrahedronGeometry;\\n\\texports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;\\n\\texports.OctahedronGeometry = OctahedronGeometry;\\n\\texports.OctahedronBufferGeometry = OctahedronBufferGeometry;\\n\\texports.IcosahedronGeometry = IcosahedronGeometry;\\n\\texports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;\\n\\texports.DodecahedronGeometry = DodecahedronGeometry;\\n\\texports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;\\n\\texports.PolyhedronGeometry = PolyhedronGeometry;\\n\\texports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;\\n\\texports.TubeGeometry = TubeGeometry;\\n\\texports.TubeBufferGeometry = TubeBufferGeometry;\\n\\texports.TorusKnotGeometry = TorusKnotGeometry;\\n\\texports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;\\n\\texports.TorusGeometry = TorusGeometry;\\n\\texports.TorusBufferGeometry = TorusBufferGeometry;\\n\\texports.TextGeometry = TextGeometry;\\n\\texports.TextBufferGeometry = TextBufferGeometry;\\n\\texports.SphereGeometry = SphereGeometry;\\n\\texports.SphereBufferGeometry = SphereBufferGeometry;\\n\\texports.RingGeometry = RingGeometry;\\n\\texports.RingBufferGeometry = RingBufferGeometry;\\n\\texports.PlaneGeometry = PlaneGeometry;\\n\\texports.PlaneBufferGeometry = PlaneBufferGeometry;\\n\\texports.LatheGeometry = LatheGeometry;\\n\\texports.LatheBufferGeometry = LatheBufferGeometry;\\n\\texports.ShapeGeometry = ShapeGeometry;\\n\\texports.ShapeBufferGeometry = ShapeBufferGeometry;\\n\\texports.ExtrudeGeometry = ExtrudeGeometry;\\n\\texports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;\\n\\texports.EdgesGeometry = EdgesGeometry;\\n\\texports.ConeGeometry = ConeGeometry;\\n\\texports.ConeBufferGeometry = ConeBufferGeometry;\\n\\texports.CylinderGeometry = CylinderGeometry;\\n\\texports.CylinderBufferGeometry = CylinderBufferGeometry;\\n\\texports.CircleGeometry = CircleGeometry;\\n\\texports.CircleBufferGeometry = CircleBufferGeometry;\\n\\texports.BoxGeometry = BoxGeometry;\\n\\texports.BoxBufferGeometry = BoxBufferGeometry;\\n\\texports.ShadowMaterial = ShadowMaterial;\\n\\texports.SpriteMaterial = SpriteMaterial;\\n\\texports.RawShaderMaterial = RawShaderMaterial;\\n\\texports.ShaderMaterial = ShaderMaterial;\\n\\texports.PointsMaterial = PointsMaterial;\\n\\texports.MeshPhysicalMaterial = MeshPhysicalMaterial;\\n\\texports.MeshStandardMaterial = MeshStandardMaterial;\\n\\texports.MeshPhongMaterial = MeshPhongMaterial;\\n\\texports.MeshToonMaterial = MeshToonMaterial;\\n\\texports.MeshNormalMaterial = MeshNormalMaterial;\\n\\texports.MeshLambertMaterial = MeshLambertMaterial;\\n\\texports.MeshDepthMaterial = MeshDepthMaterial;\\n\\texports.MeshDistanceMaterial = MeshDistanceMaterial;\\n\\texports.MeshBasicMaterial = MeshBasicMaterial;\\n\\texports.LineDashedMaterial = LineDashedMaterial;\\n\\texports.LineBasicMaterial = LineBasicMaterial;\\n\\texports.Material = Material;\\n\\texports.Float64BufferAttribute = Float64BufferAttribute;\\n\\texports.Float32BufferAttribute = Float32BufferAttribute;\\n\\texports.Uint32BufferAttribute = Uint32BufferAttribute;\\n\\texports.Int32BufferAttribute = Int32BufferAttribute;\\n\\texports.Uint16BufferAttribute = Uint16BufferAttribute;\\n\\texports.Int16BufferAttribute = Int16BufferAttribute;\\n\\texports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;\\n\\texports.Uint8BufferAttribute = Uint8BufferAttribute;\\n\\texports.Int8BufferAttribute = Int8BufferAttribute;\\n\\texports.BufferAttribute = BufferAttribute;\\n\\texports.ArcCurve = ArcCurve;\\n\\texports.CatmullRomCurve3 = CatmullRomCurve3;\\n\\texports.CubicBezierCurve = CubicBezierCurve;\\n\\texports.CubicBezierCurve3 = CubicBezierCurve3;\\n\\texports.EllipseCurve = EllipseCurve;\\n\\texports.LineCurve = LineCurve;\\n\\texports.LineCurve3 = LineCurve3;\\n\\texports.QuadraticBezierCurve = QuadraticBezierCurve;\\n\\texports.QuadraticBezierCurve3 = QuadraticBezierCurve3;\\n\\texports.SplineCurve = SplineCurve;\\n\\texports.REVISION = REVISION;\\n\\texports.MOUSE = MOUSE;\\n\\texports.CullFaceNone = CullFaceNone;\\n\\texports.CullFaceBack = CullFaceBack;\\n\\texports.CullFaceFront = CullFaceFront;\\n\\texports.CullFaceFrontBack = CullFaceFrontBack;\\n\\texports.FrontFaceDirectionCW = FrontFaceDirectionCW;\\n\\texports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;\\n\\texports.BasicShadowMap = BasicShadowMap;\\n\\texports.PCFShadowMap = PCFShadowMap;\\n\\texports.PCFSoftShadowMap = PCFSoftShadowMap;\\n\\texports.FrontSide = FrontSide;\\n\\texports.BackSide = BackSide;\\n\\texports.DoubleSide = DoubleSide;\\n\\texports.FlatShading = FlatShading;\\n\\texports.SmoothShading = SmoothShading;\\n\\texports.NoColors = NoColors;\\n\\texports.FaceColors = FaceColors;\\n\\texports.VertexColors = VertexColors;\\n\\texports.NoBlending = NoBlending;\\n\\texports.NormalBlending = NormalBlending;\\n\\texports.AdditiveBlending = AdditiveBlending;\\n\\texports.SubtractiveBlending = SubtractiveBlending;\\n\\texports.MultiplyBlending = MultiplyBlending;\\n\\texports.CustomBlending = CustomBlending;\\n\\texports.AddEquation = AddEquation;\\n\\texports.SubtractEquation = SubtractEquation;\\n\\texports.ReverseSubtractEquation = ReverseSubtractEquation;\\n\\texports.MinEquation = MinEquation;\\n\\texports.MaxEquation = MaxEquation;\\n\\texports.ZeroFactor = ZeroFactor;\\n\\texports.OneFactor = OneFactor;\\n\\texports.SrcColorFactor = SrcColorFactor;\\n\\texports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;\\n\\texports.SrcAlphaFactor = SrcAlphaFactor;\\n\\texports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;\\n\\texports.DstAlphaFactor = DstAlphaFactor;\\n\\texports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;\\n\\texports.DstColorFactor = DstColorFactor;\\n\\texports.OneMinusDstColorFactor = OneMinusDstColorFactor;\\n\\texports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;\\n\\texports.NeverDepth = NeverDepth;\\n\\texports.AlwaysDepth = AlwaysDepth;\\n\\texports.LessDepth = LessDepth;\\n\\texports.LessEqualDepth = LessEqualDepth;\\n\\texports.EqualDepth = EqualDepth;\\n\\texports.GreaterEqualDepth = GreaterEqualDepth;\\n\\texports.GreaterDepth = GreaterDepth;\\n\\texports.NotEqualDepth = NotEqualDepth;\\n\\texports.MultiplyOperation = MultiplyOperation;\\n\\texports.MixOperation = MixOperation;\\n\\texports.AddOperation = AddOperation;\\n\\texports.NoToneMapping = NoToneMapping;\\n\\texports.LinearToneMapping = LinearToneMapping;\\n\\texports.ReinhardToneMapping = ReinhardToneMapping;\\n\\texports.Uncharted2ToneMapping = Uncharted2ToneMapping;\\n\\texports.CineonToneMapping = CineonToneMapping;\\n\\texports.UVMapping = UVMapping;\\n\\texports.CubeReflectionMapping = CubeReflectionMapping;\\n\\texports.CubeRefractionMapping = CubeRefractionMapping;\\n\\texports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;\\n\\texports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;\\n\\texports.SphericalReflectionMapping = SphericalReflectionMapping;\\n\\texports.CubeUVReflectionMapping = CubeUVReflectionMapping;\\n\\texports.CubeUVRefractionMapping = CubeUVRefractionMapping;\\n\\texports.RepeatWrapping = RepeatWrapping;\\n\\texports.ClampToEdgeWrapping = ClampToEdgeWrapping;\\n\\texports.MirroredRepeatWrapping = MirroredRepeatWrapping;\\n\\texports.NearestFilter = NearestFilter;\\n\\texports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;\\n\\texports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;\\n\\texports.LinearFilter = LinearFilter;\\n\\texports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;\\n\\texports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;\\n\\texports.UnsignedByteType = UnsignedByteType;\\n\\texports.ByteType = ByteType;\\n\\texports.ShortType = ShortType;\\n\\texports.UnsignedShortType = UnsignedShortType;\\n\\texports.IntType = IntType;\\n\\texports.UnsignedIntType = UnsignedIntType;\\n\\texports.FloatType = FloatType;\\n\\texports.HalfFloatType = HalfFloatType;\\n\\texports.UnsignedShort4444Type = UnsignedShort4444Type;\\n\\texports.UnsignedShort5551Type = UnsignedShort5551Type;\\n\\texports.UnsignedShort565Type = UnsignedShort565Type;\\n\\texports.UnsignedInt248Type = UnsignedInt248Type;\\n\\texports.AlphaFormat = AlphaFormat;\\n\\texports.RGBFormat = RGBFormat;\\n\\texports.RGBAFormat = RGBAFormat;\\n\\texports.LuminanceFormat = LuminanceFormat;\\n\\texports.LuminanceAlphaFormat = LuminanceAlphaFormat;\\n\\texports.RGBEFormat = RGBEFormat;\\n\\texports.DepthFormat = DepthFormat;\\n\\texports.DepthStencilFormat = DepthStencilFormat;\\n\\texports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;\\n\\texports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;\\n\\texports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;\\n\\texports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;\\n\\texports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;\\n\\texports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;\\n\\texports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;\\n\\texports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;\\n\\texports.RGB_ETC1_Format = RGB_ETC1_Format;\\n\\texports.LoopOnce = LoopOnce;\\n\\texports.LoopRepeat = LoopRepeat;\\n\\texports.LoopPingPong = LoopPingPong;\\n\\texports.InterpolateDiscrete = InterpolateDiscrete;\\n\\texports.InterpolateLinear = InterpolateLinear;\\n\\texports.InterpolateSmooth = InterpolateSmooth;\\n\\texports.ZeroCurvatureEnding = ZeroCurvatureEnding;\\n\\texports.ZeroSlopeEnding = ZeroSlopeEnding;\\n\\texports.WrapAroundEnding = WrapAroundEnding;\\n\\texports.TrianglesDrawMode = TrianglesDrawMode;\\n\\texports.TriangleStripDrawMode = TriangleStripDrawMode;\\n\\texports.TriangleFanDrawMode = TriangleFanDrawMode;\\n\\texports.LinearEncoding = LinearEncoding;\\n\\texports.sRGBEncoding = sRGBEncoding;\\n\\texports.GammaEncoding = GammaEncoding;\\n\\texports.RGBEEncoding = RGBEEncoding;\\n\\texports.LogLuvEncoding = LogLuvEncoding;\\n\\texports.RGBM7Encoding = RGBM7Encoding;\\n\\texports.RGBM16Encoding = RGBM16Encoding;\\n\\texports.RGBDEncoding = RGBDEncoding;\\n\\texports.BasicDepthPacking = BasicDepthPacking;\\n\\texports.RGBADepthPacking = RGBADepthPacking;\\n\\texports.CubeGeometry = BoxGeometry;\\n\\texports.Face4 = Face4;\\n\\texports.LineStrip = LineStrip;\\n\\texports.LinePieces = LinePieces;\\n\\texports.MeshFaceMaterial = MeshFaceMaterial;\\n\\texports.MultiMaterial = MultiMaterial;\\n\\texports.PointCloud = PointCloud;\\n\\texports.Particle = Particle;\\n\\texports.ParticleSystem = ParticleSystem;\\n\\texports.PointCloudMaterial = PointCloudMaterial;\\n\\texports.ParticleBasicMaterial = ParticleBasicMaterial;\\n\\texports.ParticleSystemMaterial = ParticleSystemMaterial;\\n\\texports.Vertex = Vertex;\\n\\texports.DynamicBufferAttribute = DynamicBufferAttribute;\\n\\texports.Int8Attribute = Int8Attribute;\\n\\texports.Uint8Attribute = Uint8Attribute;\\n\\texports.Uint8ClampedAttribute = Uint8ClampedAttribute;\\n\\texports.Int16Attribute = Int16Attribute;\\n\\texports.Uint16Attribute = Uint16Attribute;\\n\\texports.Int32Attribute = Int32Attribute;\\n\\texports.Uint32Attribute = Uint32Attribute;\\n\\texports.Float32Attribute = Float32Attribute;\\n\\texports.Float64Attribute = Float64Attribute;\\n\\texports.ClosedSplineCurve3 = ClosedSplineCurve3;\\n\\texports.SplineCurve3 = SplineCurve3;\\n\\texports.Spline = Spline;\\n\\texports.AxisHelper = AxisHelper;\\n\\texports.BoundingBoxHelper = BoundingBoxHelper;\\n\\texports.EdgesHelper = EdgesHelper;\\n\\texports.WireframeHelper = WireframeHelper;\\n\\texports.XHRLoader = XHRLoader;\\n\\texports.BinaryTextureLoader = BinaryTextureLoader;\\n\\texports.GeometryUtils = GeometryUtils;\\n\\texports.ImageUtils = ImageUtils;\\n\\texports.Projector = Projector;\\n\\texports.CanvasRenderer = CanvasRenderer;\\n\\n\\tObject.defineProperty(exports, '__esModule', { value: true });\\n\\n})));\\n\"","require(\"!!/Users/matt/code/self_driving_car/dash/node_modules/script-loader/addScript.js\")(require(\"!!/Users/matt/code/self_driving_car/dash/node_modules/raw-loader/index.js!/Users/matt/code/self_driving_car/dash/vendor/three.js\"))","import THREE from \"script-loader!../vendor/three.js\";\nimport Utils from \"script-loader!../js/Utils.js\";\nimport PathPlanner from \"../js/autonomy/path-planning/PathPlanner.js\";\nimport LanePath from \"../js/autonomy/LanePath.js\";\nimport StaticObstacle from \"../js/autonomy/StaticObstacle.js\";\nimport DynamicObstacle from \"../js/autonomy/DynamicObstacle.js\";\n\nfunction init() {\n  let pathPlanner;\n  try {\n    pathPlanner = new PathPlanner();\n  } catch (e) {\n    console.log('Error initializing path planner:');\n    console.log(e);\n\n    self.postMessage({ error: true });\n\n    return;\n  }\n\n  self.onmessage = function(event) {\n    const { config, vehiclePose, vehicleStation, lanePath, startTime, staticObstacles, dynamicObstacles, reset } = event.data;\n\n    LanePath.hydrate(lanePath);\n    staticObstacles.forEach(o => StaticObstacle.hydrate(o));\n    dynamicObstacles.forEach(o => DynamicObstacle.hydrate(o));\n\n    if (reset) pathPlanner.reset();\n\n    pathPlanner.config = config;\n\n    try {\n      const { path, fromVehicleSegment, fromVehicleParams, latticeStartStation, dynamicObstacleGrid } = pathPlanner.plan(vehiclePose, vehicleStation, lanePath, startTime, staticObstacles, dynamicObstacles);\n\n      self.postMessage({ path, fromVehicleSegment, fromVehicleParams, vehiclePose, vehicleStation, latticeStartStation, config, dynamicObstacleGrid });\n    } catch (error) {\n      console.log('PathPlannerWorker error');\n      console.log(error);\n    }\n  };\n}\n\nif (typeof(window) === 'undefined') {\n  init();\n} else {\n  window.dash_initPathPlannerWorker = init;\n}\n"],"sourceRoot":""}