function dash_initPathPlannerWorker(){!function(t){var c={};function X(x){if(c[x])return c[x].exports;var F=c[x]={i:x,l:!1,exports:{}};return t[x].call(F.exports,F,F.exports,X),F.l=!0,F.exports}X.m=t,X.c=c,X.d=function(t,c,x){X.o(t,c)||Object.defineProperty(t,c,{configurable:!1,enumerable:!0,get:x})},X.r=function(t){Object.defineProperty(t,"__esModule",{value:!0})},X.n=function(t){var c=t&&t.__esModule?function(){return t.default}:function(){return t};return X.d(c,"a",c),c},X.o=function(t,c){return Object.prototype.hasOwnProperty.call(t,c)},X.p="",X(X.s=13)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Car; });\nclass Car {\n  constructor(x = 0, y = 0, rotation = 0) {\n    this.setPose(x, y, rotation);\n  }\n\n  static getFrontAxlePosition(pos, rot) {\n    return THREE.Vector2.fromAngle(rot).multiplyScalar(Car.WHEEL_BASE).add(pos);\n  }\n\n  static getFakeAxlePosition(pos, rot) {\n    return Car.frontToRearAxlePosition(pos, rot);\n  }\n\n  static centerToRearAxlePosition(pos, rot) {\n    return THREE.Vector2.fromAngle(rot).multiplyScalar(Car.REAR_AXLE_POS).add(pos);\n  }\n\n  static frontToRearAxlePosition(pos, rot) {\n    return THREE.Vector2.fromAngle(rot).multiplyScalar(-Car.WHEEL_BASE).add(pos);\n  }\n\n  get pose() {\n    return { pos: this.rearAxlePosition.clone(), rot: this.rotation, velocity: this.velocity, curv: this.curvature, dCurv: this.dCurv, ddCurv: this.ddCurv };\n  }\n\n  get curvature() {\n    return Math.tan(this.wheelAngle) / Car.WHEEL_BASE;\n  }\n\n  get rearAxlePosition() {\n    const { x, y } = this.position;\n    const rot = this.rotation;\n    return new THREE.Vector2(x + Math.cos(rot) * Car.REAR_AXLE_POS, y + Math.sin(rot) * Car.REAR_AXLE_POS);\n  }\n\n  get frontAxlePosition() {\n    const { x, y } = this.position;\n    const rot = this.rotation;\n    return new THREE.Vector2(x + Math.cos(rot) * Car.FRONT_AXLE_POS, y + Math.sin(rot) * Car.FRONT_AXLE_POS);\n  }\n\n  setPose(x, y, rotation) {\n    // Translate so that x and y become the center of the vehicle (instead of the center of the rear axle)\n    x -= Car.REAR_AXLE_POS * Math.cos(rotation);\n    y -= Car.REAR_AXLE_POS * Math.sin(rotation);\n\n    this.position = new THREE.Vector2(x, y);\n    this.rotation = Math.wrapAngle(rotation);\n    this.velocity = 0;\n    this.acceleration = 0;\n    this.wheelAngle = 0;\n    this.wheelAngularVelocity = 0;\n    this.dCurv = 0; // derivative with respect to arc length\n    this.ddCurv = 0; // derivative with respect to arc length\n  }\n\n  step(dt) {\n    const curvPrev = this.curvature;\n    const dCurvPrev = this.dCurv;\n\n    const drag = (0.5 * Car.DRAG_COEFF * Car.FRONTAL_AREA * Car.DENSITY_OF_AIR * Math.abs(this.velocity) + Car.ROLL_RESIST) * -this.velocity;\n    this.velocity += (this.acceleration + drag / Car.MASS) * dt;\n\n    const velocitySq = this.velocity * this.velocity;\n    const maxWheelAngle = Math.clamp(Math.atan(Car.MAX_LATERAL_ACCEL * Car.WHEEL_BASE / velocitySq), 0.07, Car.MAX_WHEEL_ANGLE);\n    this.wheelAngle = Math.clamp(Math.wrapAngle(this.wheelAngle + this.wheelAngularVelocity * dt), -maxWheelAngle, maxWheelAngle);\n\n    const angularVelocity = this.velocity * this.curvature;\n    this.rotation = Math.wrapAngle(this.rotation + angularVelocity * dt);\n\n    const dist = this.velocity * dt;\n    this.position = THREE.Vector2.fromAngle(this.rotation).multiplyScalar(dist).add(this.position);\n\n    this.dCurv = dist > 0.1 ? (this.curvature - curvPrev) / dist : 0;\n    this.ddCurv = dist > 0.1 ? (this.dCurv - dCurvPrev) / dist : 0;\n  }\n\n  update(controls, dt) {\n    const gas = Math.clamp(controls.gas, -1, +1);\n    const brake = Math.clamp(controls.brake, 0, 1);\n    const steer = Math.clamp(controls.steer, -1, +1);\n\n    if (brake > 0) {\n      this.acceleration = -Math.sign(this.velocity) * Car.MAX_BRAKE_DECEL * brake;\n      const newVelocity = this.velocity + this.acceleration * dt;\n\n      // If applying the braking deceleration at the next step would cause the velocity\n      // to change directions, then just set the car as stopped.\n      if (Math.sign(newVelocity) != Math.sign(this.velocity)) {\n        this.velocity = 0;\n        this.acceleration = 0;\n      }\n    } else {\n      this.acceleration = Car.MAX_GAS_ACCEL * gas;\n    }\n\n    if (steer != 0) {\n      this.wheelAngularVelocity = steer * Car.MAX_STEER_SPEED;\n    } else {\n      this.wheelAngularVelocity = Math.clamp(-this.wheelAngle / Car.MAX_WHEEL_ANGLE * this.velocity * this.velocity * dt, -Car.MAX_STEER_SPEED, Car.MAX_STEER_SPEED);\n    }\n  }\n}\n\nCar.HALF_CAR_LENGTH = 2.5; // meters\nCar.HALF_CAR_WIDTH = 1; // meters\nCar.HALF_WHEEL_LENGTH = 0.38; // meters\nCar.HALF_WHEEL_WIDTH = 0.12; // meters\nCar.MAX_WHEEL_ANGLE = 32 / 180 * Math.PI; // radians\nCar.MASS = 1600; // kg\nCar.DRAG_COEFF = 0.7;\nCar.DENSITY_OF_AIR = 1.8580608; // (kg/m^3)\nCar.FRONTAL_AREA = 1.85; // m^2\nCar.ROLL_RESIST = 0;\nCar.MAX_STEER_SPEED = 0.8;//1.2; // Radians per second\nCar.MAX_GAS_ACCEL = 3.5; // m / s^2\nCar.MAX_BRAKE_DECEL = 6.5; // m / s^2\nCar.WHEEL_LATERAL_POS = 0.843; // meters\nCar.FRONT_AXLE_POS = 1.6; // meters\nCar.REAR_AXLE_POS = -1.43; // meters\nCar.WHEEL_BASE = Car.FRONT_AXLE_POS - Car.REAR_AXLE_POS; // meters\nCar.MAX_LATERAL_ACCEL = 9.81; // m / s^2\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9waHlzaWNzL0Nhci5qcz8yYzBlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUIsdUJBQXVCO0FBQ3ZCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUIseUNBQXlDO0FBQ3pDLGdCQUFnQjtBQUNoQjtBQUNBLCtCQUErQjtBQUMvQix3QkFBd0I7QUFDeEI7QUFDQSwwQkFBMEIsTUFBTTtBQUNoQyx3QkFBd0I7QUFDeEIsMEJBQTBCO0FBQzFCLDhCQUE4QjtBQUM5Qix5QkFBeUI7QUFDekIsMEJBQTBCO0FBQzFCLHdEQUF3RDtBQUN4RCw2QkFBNkIiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGNsYXNzIENhciB7XG4gIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgcm90YXRpb24gPSAwKSB7XG4gICAgdGhpcy5zZXRQb3NlKHgsIHksIHJvdGF0aW9uKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRGcm9udEF4bGVQb3NpdGlvbihwb3MsIHJvdCkge1xuICAgIHJldHVybiBUSFJFRS5WZWN0b3IyLmZyb21BbmdsZShyb3QpLm11bHRpcGx5U2NhbGFyKENhci5XSEVFTF9CQVNFKS5hZGQocG9zKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRGYWtlQXhsZVBvc2l0aW9uKHBvcywgcm90KSB7XG4gICAgcmV0dXJuIENhci5mcm9udFRvUmVhckF4bGVQb3NpdGlvbihwb3MsIHJvdCk7XG4gIH1cblxuICBzdGF0aWMgY2VudGVyVG9SZWFyQXhsZVBvc2l0aW9uKHBvcywgcm90KSB7XG4gICAgcmV0dXJuIFRIUkVFLlZlY3RvcjIuZnJvbUFuZ2xlKHJvdCkubXVsdGlwbHlTY2FsYXIoQ2FyLlJFQVJfQVhMRV9QT1MpLmFkZChwb3MpO1xuICB9XG5cbiAgc3RhdGljIGZyb250VG9SZWFyQXhsZVBvc2l0aW9uKHBvcywgcm90KSB7XG4gICAgcmV0dXJuIFRIUkVFLlZlY3RvcjIuZnJvbUFuZ2xlKHJvdCkubXVsdGlwbHlTY2FsYXIoLUNhci5XSEVFTF9CQVNFKS5hZGQocG9zKTtcbiAgfVxuXG4gIGdldCBwb3NlKCkge1xuICAgIHJldHVybiB7IHBvczogdGhpcy5yZWFyQXhsZVBvc2l0aW9uLmNsb25lKCksIHJvdDogdGhpcy5yb3RhdGlvbiwgdmVsb2NpdHk6IHRoaXMudmVsb2NpdHksIGN1cnY6IHRoaXMuY3VydmF0dXJlLCBkQ3VydjogdGhpcy5kQ3VydiwgZGRDdXJ2OiB0aGlzLmRkQ3VydiB9O1xuICB9XG5cbiAgZ2V0IGN1cnZhdHVyZSgpIHtcbiAgICByZXR1cm4gTWF0aC50YW4odGhpcy53aGVlbEFuZ2xlKSAvIENhci5XSEVFTF9CQVNFO1xuICB9XG5cbiAgZ2V0IHJlYXJBeGxlUG9zaXRpb24oKSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLnBvc2l0aW9uO1xuICAgIGNvbnN0IHJvdCA9IHRoaXMucm90YXRpb247XG4gICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKHggKyBNYXRoLmNvcyhyb3QpICogQ2FyLlJFQVJfQVhMRV9QT1MsIHkgKyBNYXRoLnNpbihyb3QpICogQ2FyLlJFQVJfQVhMRV9QT1MpO1xuICB9XG5cbiAgZ2V0IGZyb250QXhsZVBvc2l0aW9uKCkge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy5wb3NpdGlvbjtcbiAgICBjb25zdCByb3QgPSB0aGlzLnJvdGF0aW9uO1xuICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMih4ICsgTWF0aC5jb3Mocm90KSAqIENhci5GUk9OVF9BWExFX1BPUywgeSArIE1hdGguc2luKHJvdCkgKiBDYXIuRlJPTlRfQVhMRV9QT1MpO1xuICB9XG5cbiAgc2V0UG9zZSh4LCB5LCByb3RhdGlvbikge1xuICAgIC8vIFRyYW5zbGF0ZSBzbyB0aGF0IHggYW5kIHkgYmVjb21lIHRoZSBjZW50ZXIgb2YgdGhlIHZlaGljbGUgKGluc3RlYWQgb2YgdGhlIGNlbnRlciBvZiB0aGUgcmVhciBheGxlKVxuICAgIHggLT0gQ2FyLlJFQVJfQVhMRV9QT1MgKiBNYXRoLmNvcyhyb3RhdGlvbik7XG4gICAgeSAtPSBDYXIuUkVBUl9BWExFX1BPUyAqIE1hdGguc2luKHJvdGF0aW9uKTtcblxuICAgIHRoaXMucG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMih4LCB5KTtcbiAgICB0aGlzLnJvdGF0aW9uID0gTWF0aC53cmFwQW5nbGUocm90YXRpb24pO1xuICAgIHRoaXMudmVsb2NpdHkgPSAwO1xuICAgIHRoaXMuYWNjZWxlcmF0aW9uID0gMDtcbiAgICB0aGlzLndoZWVsQW5nbGUgPSAwO1xuICAgIHRoaXMud2hlZWxBbmd1bGFyVmVsb2NpdHkgPSAwO1xuICAgIHRoaXMuZEN1cnYgPSAwOyAvLyBkZXJpdmF0aXZlIHdpdGggcmVzcGVjdCB0byBhcmMgbGVuZ3RoXG4gICAgdGhpcy5kZEN1cnYgPSAwOyAvLyBkZXJpdmF0aXZlIHdpdGggcmVzcGVjdCB0byBhcmMgbGVuZ3RoXG4gIH1cblxuICBzdGVwKGR0KSB7XG4gICAgY29uc3QgY3VydlByZXYgPSB0aGlzLmN1cnZhdHVyZTtcbiAgICBjb25zdCBkQ3VydlByZXYgPSB0aGlzLmRDdXJ2O1xuXG4gICAgY29uc3QgZHJhZyA9ICgwLjUgKiBDYXIuRFJBR19DT0VGRiAqIENhci5GUk9OVEFMX0FSRUEgKiBDYXIuREVOU0lUWV9PRl9BSVIgKiBNYXRoLmFicyh0aGlzLnZlbG9jaXR5KSArIENhci5ST0xMX1JFU0lTVCkgKiAtdGhpcy52ZWxvY2l0eTtcbiAgICB0aGlzLnZlbG9jaXR5ICs9ICh0aGlzLmFjY2VsZXJhdGlvbiArIGRyYWcgLyBDYXIuTUFTUykgKiBkdDtcblxuICAgIGNvbnN0IHZlbG9jaXR5U3EgPSB0aGlzLnZlbG9jaXR5ICogdGhpcy52ZWxvY2l0eTtcbiAgICBjb25zdCBtYXhXaGVlbEFuZ2xlID0gTWF0aC5jbGFtcChNYXRoLmF0YW4oQ2FyLk1BWF9MQVRFUkFMX0FDQ0VMICogQ2FyLldIRUVMX0JBU0UgLyB2ZWxvY2l0eVNxKSwgMC4wNywgQ2FyLk1BWF9XSEVFTF9BTkdMRSk7XG4gICAgdGhpcy53aGVlbEFuZ2xlID0gTWF0aC5jbGFtcChNYXRoLndyYXBBbmdsZSh0aGlzLndoZWVsQW5nbGUgKyB0aGlzLndoZWVsQW5ndWxhclZlbG9jaXR5ICogZHQpLCAtbWF4V2hlZWxBbmdsZSwgbWF4V2hlZWxBbmdsZSk7XG5cbiAgICBjb25zdCBhbmd1bGFyVmVsb2NpdHkgPSB0aGlzLnZlbG9jaXR5ICogdGhpcy5jdXJ2YXR1cmU7XG4gICAgdGhpcy5yb3RhdGlvbiA9IE1hdGgud3JhcEFuZ2xlKHRoaXMucm90YXRpb24gKyBhbmd1bGFyVmVsb2NpdHkgKiBkdCk7XG5cbiAgICBjb25zdCBkaXN0ID0gdGhpcy52ZWxvY2l0eSAqIGR0O1xuICAgIHRoaXMucG9zaXRpb24gPSBUSFJFRS5WZWN0b3IyLmZyb21BbmdsZSh0aGlzLnJvdGF0aW9uKS5tdWx0aXBseVNjYWxhcihkaXN0KS5hZGQodGhpcy5wb3NpdGlvbik7XG5cbiAgICB0aGlzLmRDdXJ2ID0gZGlzdCA+IDAuMSA/ICh0aGlzLmN1cnZhdHVyZSAtIGN1cnZQcmV2KSAvIGRpc3QgOiAwO1xuICAgIHRoaXMuZGRDdXJ2ID0gZGlzdCA+IDAuMSA/ICh0aGlzLmRDdXJ2IC0gZEN1cnZQcmV2KSAvIGRpc3QgOiAwO1xuICB9XG5cbiAgdXBkYXRlKGNvbnRyb2xzLCBkdCkge1xuICAgIGNvbnN0IGdhcyA9IE1hdGguY2xhbXAoY29udHJvbHMuZ2FzLCAtMSwgKzEpO1xuICAgIGNvbnN0IGJyYWtlID0gTWF0aC5jbGFtcChjb250cm9scy5icmFrZSwgMCwgMSk7XG4gICAgY29uc3Qgc3RlZXIgPSBNYXRoLmNsYW1wKGNvbnRyb2xzLnN0ZWVyLCAtMSwgKzEpO1xuXG4gICAgaWYgKGJyYWtlID4gMCkge1xuICAgICAgdGhpcy5hY2NlbGVyYXRpb24gPSAtTWF0aC5zaWduKHRoaXMudmVsb2NpdHkpICogQ2FyLk1BWF9CUkFLRV9ERUNFTCAqIGJyYWtlO1xuICAgICAgY29uc3QgbmV3VmVsb2NpdHkgPSB0aGlzLnZlbG9jaXR5ICsgdGhpcy5hY2NlbGVyYXRpb24gKiBkdDtcblxuICAgICAgLy8gSWYgYXBwbHlpbmcgdGhlIGJyYWtpbmcgZGVjZWxlcmF0aW9uIGF0IHRoZSBuZXh0IHN0ZXAgd291bGQgY2F1c2UgdGhlIHZlbG9jaXR5XG4gICAgICAvLyB0byBjaGFuZ2UgZGlyZWN0aW9ucywgdGhlbiBqdXN0IHNldCB0aGUgY2FyIGFzIHN0b3BwZWQuXG4gICAgICBpZiAoTWF0aC5zaWduKG5ld1ZlbG9jaXR5KSAhPSBNYXRoLnNpZ24odGhpcy52ZWxvY2l0eSkpIHtcbiAgICAgICAgdGhpcy52ZWxvY2l0eSA9IDA7XG4gICAgICAgIHRoaXMuYWNjZWxlcmF0aW9uID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hY2NlbGVyYXRpb24gPSBDYXIuTUFYX0dBU19BQ0NFTCAqIGdhcztcbiAgICB9XG5cbiAgICBpZiAoc3RlZXIgIT0gMCkge1xuICAgICAgdGhpcy53aGVlbEFuZ3VsYXJWZWxvY2l0eSA9IHN0ZWVyICogQ2FyLk1BWF9TVEVFUl9TUEVFRDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aGVlbEFuZ3VsYXJWZWxvY2l0eSA9IE1hdGguY2xhbXAoLXRoaXMud2hlZWxBbmdsZSAvIENhci5NQVhfV0hFRUxfQU5HTEUgKiB0aGlzLnZlbG9jaXR5ICogdGhpcy52ZWxvY2l0eSAqIGR0LCAtQ2FyLk1BWF9TVEVFUl9TUEVFRCwgQ2FyLk1BWF9TVEVFUl9TUEVFRCk7XG4gICAgfVxuICB9XG59XG5cbkNhci5IQUxGX0NBUl9MRU5HVEggPSAyLjU7IC8vIG1ldGVyc1xuQ2FyLkhBTEZfQ0FSX1dJRFRIID0gMTsgLy8gbWV0ZXJzXG5DYXIuSEFMRl9XSEVFTF9MRU5HVEggPSAwLjM4OyAvLyBtZXRlcnNcbkNhci5IQUxGX1dIRUVMX1dJRFRIID0gMC4xMjsgLy8gbWV0ZXJzXG5DYXIuTUFYX1dIRUVMX0FOR0xFID0gMzIgLyAxODAgKiBNYXRoLlBJOyAvLyByYWRpYW5zXG5DYXIuTUFTUyA9IDE2MDA7IC8vIGtnXG5DYXIuRFJBR19DT0VGRiA9IDAuNztcbkNhci5ERU5TSVRZX09GX0FJUiA9IDEuODU4MDYwODsgLy8gKGtnL21eMylcbkNhci5GUk9OVEFMX0FSRUEgPSAxLjg1OyAvLyBtXjJcbkNhci5ST0xMX1JFU0lTVCA9IDA7XG5DYXIuTUFYX1NURUVSX1NQRUVEID0gMC44Oy8vMS4yOyAvLyBSYWRpYW5zIHBlciBzZWNvbmRcbkNhci5NQVhfR0FTX0FDQ0VMID0gMy41OyAvLyBtIC8gc14yXG5DYXIuTUFYX0JSQUtFX0RFQ0VMID0gNi41OyAvLyBtIC8gc14yXG5DYXIuV0hFRUxfTEFURVJBTF9QT1MgPSAwLjg0MzsgLy8gbWV0ZXJzXG5DYXIuRlJPTlRfQVhMRV9QT1MgPSAxLjY7IC8vIG1ldGVyc1xuQ2FyLlJFQVJfQVhMRV9QT1MgPSAtMS40MzsgLy8gbWV0ZXJzXG5DYXIuV0hFRUxfQkFTRSA9IENhci5GUk9OVF9BWExFX1BPUyAtIENhci5SRUFSX0FYTEVfUE9TOyAvLyBtZXRlcnNcbkNhci5NQVhfTEFURVJBTF9BQ0NFTCA9IDkuODE7IC8vIG0gLyBzXjJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return StaticObstacle; });\nclass StaticObstacle {\n  static hydrate(obj) {\n    Object.setPrototypeOf(obj, StaticObstacle.prototype);\n    Object.setPrototypeOf(obj.pos, THREE.Vector2.prototype);\n  }\n\n  static fromJSON(json) {\n    return new StaticObstacle(new THREE.Vector2(json.p[0], json.p[1]), json.r, json.w, json.h);\n  }\n\n  constructor(pos, rot, width, height) {\n    this.pos = pos;\n    this.rot = rot;\n    this.width = width;\n    this.height = height;\n\n    this.updateVertices();\n  }\n\n  toJSON() {\n    const trunc = n => +n.toFixed(5);\n\n    return {\n      p: [trunc(this.pos.x), trunc(this.pos.y)],\n      r: trunc(this.rot),\n      w: trunc(this.width),\n      h: trunc(this.height)\n    };\n  }\n\n  updateVertices() {\n    this.vertices = [];\n\n    const cosRot = Math.cos(this.rot);\n    const sinRot = Math.sin(this.rot);\n    const halfWidth = this.width / 2;\n    const halfHeight = this.height / 2;\n\n    const hWcR = halfWidth * cosRot;\n    const hWsR = halfWidth * sinRot;\n    const hHcR = halfHeight * cosRot;\n    const hHsR = halfHeight * sinRot;\n\n    const v1 = [-hWcR - hHsR + this.pos.x, -hWsR + hHcR + this.pos.y];\n    const v2 = [-hWcR + hHsR + this.pos.x, -hWsR - hHcR + this.pos.y];\n    const v3 = [hWcR + hHsR + this.pos.x, hWsR - hHcR + this.pos.y];\n    const v4 = [hWcR - hHsR + this.pos.x, hWsR + hHcR + this.pos.y];\n\n    this.vertices = [\n      v1[0], v1[1],\n      v2[0], v2[1],\n      v3[0], v3[1],\n      v3[0], v3[1],\n      v4[0], v4[1],\n      v1[0], v1[1]\n    ];\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9TdGF0aWNPYnN0YWNsZS5qcz84OTA2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0aWNPYnN0YWNsZSB7XG4gIHN0YXRpYyBoeWRyYXRlKG9iaikge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihvYmosIFN0YXRpY09ic3RhY2xlLnByb3RvdHlwZSk7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG9iai5wb3MsIFRIUkVFLlZlY3RvcjIucHJvdG90eXBlKTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgcmV0dXJuIG5ldyBTdGF0aWNPYnN0YWNsZShuZXcgVEhSRUUuVmVjdG9yMihqc29uLnBbMF0sIGpzb24ucFsxXSksIGpzb24uciwganNvbi53LCBqc29uLmgpO1xuICB9XG5cbiAgY29uc3RydWN0b3IocG9zLCByb3QsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnBvcyA9IHBvcztcbiAgICB0aGlzLnJvdCA9IHJvdDtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICB0aGlzLnVwZGF0ZVZlcnRpY2VzKCk7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgY29uc3QgdHJ1bmMgPSBuID0+ICtuLnRvRml4ZWQoNSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcDogW3RydW5jKHRoaXMucG9zLngpLCB0cnVuYyh0aGlzLnBvcy55KV0sXG4gICAgICByOiB0cnVuYyh0aGlzLnJvdCksXG4gICAgICB3OiB0cnVuYyh0aGlzLndpZHRoKSxcbiAgICAgIGg6IHRydW5jKHRoaXMuaGVpZ2h0KVxuICAgIH07XG4gIH1cblxuICB1cGRhdGVWZXJ0aWNlcygpIHtcbiAgICB0aGlzLnZlcnRpY2VzID0gW107XG5cbiAgICBjb25zdCBjb3NSb3QgPSBNYXRoLmNvcyh0aGlzLnJvdCk7XG4gICAgY29uc3Qgc2luUm90ID0gTWF0aC5zaW4odGhpcy5yb3QpO1xuICAgIGNvbnN0IGhhbGZXaWR0aCA9IHRoaXMud2lkdGggLyAyO1xuICAgIGNvbnN0IGhhbGZIZWlnaHQgPSB0aGlzLmhlaWdodCAvIDI7XG5cbiAgICBjb25zdCBoV2NSID0gaGFsZldpZHRoICogY29zUm90O1xuICAgIGNvbnN0IGhXc1IgPSBoYWxmV2lkdGggKiBzaW5Sb3Q7XG4gICAgY29uc3QgaEhjUiA9IGhhbGZIZWlnaHQgKiBjb3NSb3Q7XG4gICAgY29uc3QgaEhzUiA9IGhhbGZIZWlnaHQgKiBzaW5Sb3Q7XG5cbiAgICBjb25zdCB2MSA9IFstaFdjUiAtIGhIc1IgKyB0aGlzLnBvcy54LCAtaFdzUiArIGhIY1IgKyB0aGlzLnBvcy55XTtcbiAgICBjb25zdCB2MiA9IFstaFdjUiArIGhIc1IgKyB0aGlzLnBvcy54LCAtaFdzUiAtIGhIY1IgKyB0aGlzLnBvcy55XTtcbiAgICBjb25zdCB2MyA9IFtoV2NSICsgaEhzUiArIHRoaXMucG9zLngsIGhXc1IgLSBoSGNSICsgdGhpcy5wb3MueV07XG4gICAgY29uc3QgdjQgPSBbaFdjUiAtIGhIc1IgKyB0aGlzLnBvcy54LCBoV3NSICsgaEhjUiArIHRoaXMucG9zLnldO1xuXG4gICAgdGhpcy52ZXJ0aWNlcyA9IFtcbiAgICAgIHYxWzBdLCB2MVsxXSxcbiAgICAgIHYyWzBdLCB2MlsxXSxcbiAgICAgIHYzWzBdLCB2M1sxXSxcbiAgICAgIHYzWzBdLCB2M1sxXSxcbiAgICAgIHY0WzBdLCB2NFsxXSxcbiAgICAgIHYxWzBdLCB2MVsxXVxuICAgIF07XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CubicPath; });\nconst SIMPSONS_INTERVALS = 8;\nconst NEWTON_ITERATIONS = 16;\nconst RELAXATION_ITERATIONS = 32;\nconst CONVERGENCE_ERROR = 0.01;\n\nconst jacobian = new THREE.Matrix3();\nconst invJacobian = new THREE.Matrix3();\n\n// Alternate reference implementation: https://github.com/ApolloAuto/apollo/blob/master/modules/planning/math/spiral_curve/cubic_spiral_curve.cc\nclass CubicPath {\n  constructor(start, end, params = null) {\n    this.start = Object.assign({}, start);\n    this.end = Object.assign({}, end);\n\n    if (start.pos) {\n      this.start.x = start.pos.x;\n      this.start.y = start.pos.y\n    }\n\n    if (end.pos) {\n      this.end.x = end.pos.x;\n      this.end.y = end.pos.y\n    }\n\n    const diffX = this.end.x - this.start.x;\n    const diffY = this.end.y - this.start.y;\n    const sinRot = Math.sin(this.start.rot);\n    const cosRot = Math.cos(this.start.rot);\n\n    this.goal = {\n      x: cosRot * diffX + sinRot * diffY,\n      y: -sinRot * diffX + cosRot * diffY,\n      rot: Math.wrapAngle(this.end.rot - this.start.rot),\n      curv: this.end.curv\n    };\n\n    if (params)\n      this.params = Object.assign({}, params, { p0: this.start.curv, p3: this.end.curv });\n    else\n      this.guessInitialParams();\n\n    this.converged = false;\n  }\n\n  guessInitialParams() {\n    const originalGoal = this.goal;\n    const dStartCurv = this.start.curv / RELAXATION_ITERATIONS;\n    const dGoalY = originalGoal.y / RELAXATION_ITERATIONS;\n    const dGoalRot = originalGoal.rot / RELAXATION_ITERATIONS;\n    const dGoalCurv = originalGoal.curv / RELAXATION_ITERATIONS;\n\n    this.goal = {\n      x: originalGoal.x,\n      y: 0,\n      rot: 0,\n      curv: 0\n    };\n\n    this.params = {\n      p0: 0,\n      p1: 0,\n      p2: 0,\n      p3: 0,\n      sG: originalGoal.x\n    };\n\n    for (let i = 0; i < RELAXATION_ITERATIONS; i++) {\n      this.params.p0 += dStartCurv;\n      this.params.p3 += dGoalCurv;\n      this.goal.y += dGoalY;\n      this.goal.rot += dGoalRot;\n      this.goal.curv += dGoalCurv;\n\n      this.iterate();\n    }\n\n    this.goal = originalGoal;\n  }\n\n  optimize() {\n    for (let i = 0; i < NEWTON_ITERATIONS; i++) {\n      if (this.iterate()) {\n        this.converged = true;\n        return true;\n      }\n    }\n\n    this.converged = false;\n    return false;\n  }\n\n  iterate() {\n    const { p0, p1, p2, p3, sG } = this.params;\n\n    const ds = sG / SIMPSONS_INTERVALS;\n    const sG_2 = sG * sG;\n    const sG_3 = sG_2 * sG;\n\n    let dX_p1 = 0;\n    let dX_p2 = 0;\n    let dX_sG = 0;\n    let dY_p1 = 0;\n    let dY_p2 = 0;\n    let dY_sG = 0;\n    let guessX = 0;\n    let guessY = 0;\n\n    let theta, cosTheta, sinTheta, dT_p1, dT_p2, dT_sG;\n\n    for (let i = 0, s = 0; i <= SIMPSONS_INTERVALS; i++, s += ds) {\n      const coeff = i == 0 || i == SIMPSONS_INTERVALS ? 1 : i % 2 == 0 ? 2 : 4;\n\n      const a = p0;\n      const b = (-5.5 * p0 + 9 * p1 - 4.5 * p2 + p3) / sG;\n      const c = (9 * p0 - 22.5 * p1 + 18 * p2 - 4.5 * p3) / sG_2;\n      const d = (-4.5 * (p0 - 3 * p1 + 3 * p2 - p3)) / sG_3;\n\n      theta = (((d * s / 4 + c / 3) * s + b / 2) * s + a) * s;\n      cosTheta = Math.cos(theta);\n      sinTheta = Math.sin(theta);\n\n      const s_sG = s / sG;\n      dT_p1 = ((3.375 * s_sG - 7.5) * s_sG + 4.5) * s_sG * s;\n      dT_p2 = ((-3.375 * s_sG + 6) * s_sG - 2.25) * s_sG * s;\n      dT_sG = ((3.375 * (p0 - 3 * p1 + 3 * p2 - p3) * s_sG - 3 * (2 * p0 - 5 * p1 + 4 * p2 - p3)) * s_sG + 0.25 * (11 * p0 - 18 * p1 + 9 * p2 - 2 * p3)) * s_sG * s_sG;\n\n      dX_p1 -= coeff * sinTheta * dT_p1;\n      dX_p2 -= coeff * sinTheta * dT_p2;\n      dX_sG -= coeff * sinTheta * dT_sG;\n\n      dY_p1 += coeff * cosTheta * dT_p1;\n      dY_p2 += coeff * cosTheta * dT_p2;\n      dY_sG += coeff * cosTheta * dT_sG;\n\n      guessX += coeff * cosTheta;\n      guessY += coeff * sinTheta;\n    }\n\n    // After the Simpson\'s integration loop, `theta`, `cosTheta`, `sinTheta`,\n    // `dT_p1`, `dT_p2`, and `dT_sG` hold the appropriate values for `sG`.\n\n    const hOver3 = sG / SIMPSONS_INTERVALS / 3;\n\n    const deltaX = this.goal.x - guessX * hOver3;\n    const deltaY = this.goal.y - guessY * hOver3;\n    const deltaRot = Math.wrapAngle(this.goal.rot - theta);\n\n    if (Math.abs(deltaX) + Math.abs(deltaY) + Math.abs(deltaRot) < CONVERGENCE_ERROR)\n      return true;\n\n    jacobian.set(\n      dX_p1 * hOver3, dX_p2 * hOver3, cosTheta + dX_sG * hOver3,\n      dY_p1 * hOver3, dY_p2 * hOver3, sinTheta + dY_sG * hOver3,\n      dT_p1, dT_p2, dT_sG\n    );\n\n    const [m11, m21, m31, m12, m22, m32, m13, m23, m33] = invJacobian.getInverse(jacobian).elements;\n\n    this.params.p1 += m11 * deltaX + m12 * deltaY + m13 * deltaRot;\n    this.params.p2 += m21 * deltaX + m22 * deltaY + m23 * deltaRot;\n    this.params.sG += m31 * deltaX + m32 * deltaY + m33 * deltaRot;\n\n    return false;\n  }\n\n  buildPath(num) {\n    const { p0, p1, p2, p3, sG } = this.params;\n\n    const sG_2 = sG * sG;\n    const sG_3 = sG_2 * sG;\n\n    const a = p0;\n    const b = (-5.5 * p0 + 9 * p1 - 4.5 * p2 + p3) / sG;\n    const c = (9 * p0 - 22.5 * p1 + 18 * p2 - 4.5 * p3) / sG_2;\n    const d = (-4.5 * (p0 - 3 * p1 + 3 * p2 - p3)) / sG_3;\n\n    const path = [{ pos: new THREE.Vector2(this.start.x, this.start.y), rot: this.start.rot, curv: this.start.curv }];\n    const ds = sG / (num - 1);\n    let s = ds;\n    let dx = 0;\n    let dy = 0;\n    let prevCosRot = Math.cos(path[0].rot);\n    let prevSinRot = Math.sin(path[0].rot);\n\n    for (let i = 1; i < num - 1; i++) {\n      const rot = (((d * s / 4 + c / 3) * s + b / 2) * s + a) * s + this.start.rot;\n      const curv = ((d * s + c) * s + b) * s + a;\n      const cosRot = Math.cos(rot);\n      const sinRot = Math.sin(rot);\n\n      dx = dx * (i - 1) / i + (cosRot + prevCosRot) / (2 * i);\n      dy = dy * (i - 1) / i + (sinRot + prevSinRot) / (2 * i);\n\n      path.push({ pos: new THREE.Vector2(s * dx + this.start.x, s * dy + this.start.y), rot: rot, curv: curv });\n\n      s += ds;\n      prevCosRot = cosRot;\n      prevSinRot = sinRot;\n    }\n\n    path.push({ pos: new THREE.Vector2(this.end.x, this.end.y), rot: this.end.rot, curv: this.end.curv });\n\n    return path;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL0N1YmljUGF0aC5qcz85NDBjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsK0JBQStCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsV0FBVyx5Q0FBeUM7QUFDeEY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHFCQUFxQjs7QUFFaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCLHlCQUF5QjtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxxQkFBcUI7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGlHQUFpRztBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGFBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsNkZBQTZGOztBQUU5RztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLHlGQUF5Rjs7QUFFeEc7QUFDQTtBQUNBIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBTSU1QU09OU19JTlRFUlZBTFMgPSA4O1xuY29uc3QgTkVXVE9OX0lURVJBVElPTlMgPSAxNjtcbmNvbnN0IFJFTEFYQVRJT05fSVRFUkFUSU9OUyA9IDMyO1xuY29uc3QgQ09OVkVSR0VOQ0VfRVJST1IgPSAwLjAxO1xuXG5jb25zdCBqYWNvYmlhbiA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XG5jb25zdCBpbnZKYWNvYmlhbiA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XG5cbi8vIEFsdGVybmF0ZSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9BcG9sbG9BdXRvL2Fwb2xsby9ibG9iL21hc3Rlci9tb2R1bGVzL3BsYW5uaW5nL21hdGgvc3BpcmFsX2N1cnZlL2N1YmljX3NwaXJhbF9jdXJ2ZS5jY1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ3ViaWNQYXRoIHtcbiAgY29uc3RydWN0b3Ioc3RhcnQsIGVuZCwgcGFyYW1zID0gbnVsbCkge1xuICAgIHRoaXMuc3RhcnQgPSBPYmplY3QuYXNzaWduKHt9LCBzdGFydCk7XG4gICAgdGhpcy5lbmQgPSBPYmplY3QuYXNzaWduKHt9LCBlbmQpO1xuXG4gICAgaWYgKHN0YXJ0LnBvcykge1xuICAgICAgdGhpcy5zdGFydC54ID0gc3RhcnQucG9zLng7XG4gICAgICB0aGlzLnN0YXJ0LnkgPSBzdGFydC5wb3MueVxuICAgIH1cblxuICAgIGlmIChlbmQucG9zKSB7XG4gICAgICB0aGlzLmVuZC54ID0gZW5kLnBvcy54O1xuICAgICAgdGhpcy5lbmQueSA9IGVuZC5wb3MueVxuICAgIH1cblxuICAgIGNvbnN0IGRpZmZYID0gdGhpcy5lbmQueCAtIHRoaXMuc3RhcnQueDtcbiAgICBjb25zdCBkaWZmWSA9IHRoaXMuZW5kLnkgLSB0aGlzLnN0YXJ0Lnk7XG4gICAgY29uc3Qgc2luUm90ID0gTWF0aC5zaW4odGhpcy5zdGFydC5yb3QpO1xuICAgIGNvbnN0IGNvc1JvdCA9IE1hdGguY29zKHRoaXMuc3RhcnQucm90KTtcblxuICAgIHRoaXMuZ29hbCA9IHtcbiAgICAgIHg6IGNvc1JvdCAqIGRpZmZYICsgc2luUm90ICogZGlmZlksXG4gICAgICB5OiAtc2luUm90ICogZGlmZlggKyBjb3NSb3QgKiBkaWZmWSxcbiAgICAgIHJvdDogTWF0aC53cmFwQW5nbGUodGhpcy5lbmQucm90IC0gdGhpcy5zdGFydC5yb3QpLFxuICAgICAgY3VydjogdGhpcy5lbmQuY3VydlxuICAgIH07XG5cbiAgICBpZiAocGFyYW1zKVxuICAgICAgdGhpcy5wYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMsIHsgcDA6IHRoaXMuc3RhcnQuY3VydiwgcDM6IHRoaXMuZW5kLmN1cnYgfSk7XG4gICAgZWxzZVxuICAgICAgdGhpcy5ndWVzc0luaXRpYWxQYXJhbXMoKTtcblxuICAgIHRoaXMuY29udmVyZ2VkID0gZmFsc2U7XG4gIH1cblxuICBndWVzc0luaXRpYWxQYXJhbXMoKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxHb2FsID0gdGhpcy5nb2FsO1xuICAgIGNvbnN0IGRTdGFydEN1cnYgPSB0aGlzLnN0YXJ0LmN1cnYgLyBSRUxBWEFUSU9OX0lURVJBVElPTlM7XG4gICAgY29uc3QgZEdvYWxZID0gb3JpZ2luYWxHb2FsLnkgLyBSRUxBWEFUSU9OX0lURVJBVElPTlM7XG4gICAgY29uc3QgZEdvYWxSb3QgPSBvcmlnaW5hbEdvYWwucm90IC8gUkVMQVhBVElPTl9JVEVSQVRJT05TO1xuICAgIGNvbnN0IGRHb2FsQ3VydiA9IG9yaWdpbmFsR29hbC5jdXJ2IC8gUkVMQVhBVElPTl9JVEVSQVRJT05TO1xuXG4gICAgdGhpcy5nb2FsID0ge1xuICAgICAgeDogb3JpZ2luYWxHb2FsLngsXG4gICAgICB5OiAwLFxuICAgICAgcm90OiAwLFxuICAgICAgY3VydjogMFxuICAgIH07XG5cbiAgICB0aGlzLnBhcmFtcyA9IHtcbiAgICAgIHAwOiAwLFxuICAgICAgcDE6IDAsXG4gICAgICBwMjogMCxcbiAgICAgIHAzOiAwLFxuICAgICAgc0c6IG9yaWdpbmFsR29hbC54XG4gICAgfTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgUkVMQVhBVElPTl9JVEVSQVRJT05TOyBpKyspIHtcbiAgICAgIHRoaXMucGFyYW1zLnAwICs9IGRTdGFydEN1cnY7XG4gICAgICB0aGlzLnBhcmFtcy5wMyArPSBkR29hbEN1cnY7XG4gICAgICB0aGlzLmdvYWwueSArPSBkR29hbFk7XG4gICAgICB0aGlzLmdvYWwucm90ICs9IGRHb2FsUm90O1xuICAgICAgdGhpcy5nb2FsLmN1cnYgKz0gZEdvYWxDdXJ2O1xuXG4gICAgICB0aGlzLml0ZXJhdGUoKTtcbiAgICB9XG5cbiAgICB0aGlzLmdvYWwgPSBvcmlnaW5hbEdvYWw7XG4gIH1cblxuICBvcHRpbWl6ZSgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE5FV1RPTl9JVEVSQVRJT05TOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLml0ZXJhdGUoKSkge1xuICAgICAgICB0aGlzLmNvbnZlcmdlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY29udmVyZ2VkID0gZmFsc2U7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaXRlcmF0ZSgpIHtcbiAgICBjb25zdCB7IHAwLCBwMSwgcDIsIHAzLCBzRyB9ID0gdGhpcy5wYXJhbXM7XG5cbiAgICBjb25zdCBkcyA9IHNHIC8gU0lNUFNPTlNfSU5URVJWQUxTO1xuICAgIGNvbnN0IHNHXzIgPSBzRyAqIHNHO1xuICAgIGNvbnN0IHNHXzMgPSBzR18yICogc0c7XG5cbiAgICBsZXQgZFhfcDEgPSAwO1xuICAgIGxldCBkWF9wMiA9IDA7XG4gICAgbGV0IGRYX3NHID0gMDtcbiAgICBsZXQgZFlfcDEgPSAwO1xuICAgIGxldCBkWV9wMiA9IDA7XG4gICAgbGV0IGRZX3NHID0gMDtcbiAgICBsZXQgZ3Vlc3NYID0gMDtcbiAgICBsZXQgZ3Vlc3NZID0gMDtcblxuICAgIGxldCB0aGV0YSwgY29zVGhldGEsIHNpblRoZXRhLCBkVF9wMSwgZFRfcDIsIGRUX3NHO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIHMgPSAwOyBpIDw9IFNJTVBTT05TX0lOVEVSVkFMUzsgaSsrLCBzICs9IGRzKSB7XG4gICAgICBjb25zdCBjb2VmZiA9IGkgPT0gMCB8fCBpID09IFNJTVBTT05TX0lOVEVSVkFMUyA/IDEgOiBpICUgMiA9PSAwID8gMiA6IDQ7XG5cbiAgICAgIGNvbnN0IGEgPSBwMDtcbiAgICAgIGNvbnN0IGIgPSAoLTUuNSAqIHAwICsgOSAqIHAxIC0gNC41ICogcDIgKyBwMykgLyBzRztcbiAgICAgIGNvbnN0IGMgPSAoOSAqIHAwIC0gMjIuNSAqIHAxICsgMTggKiBwMiAtIDQuNSAqIHAzKSAvIHNHXzI7XG4gICAgICBjb25zdCBkID0gKC00LjUgKiAocDAgLSAzICogcDEgKyAzICogcDIgLSBwMykpIC8gc0dfMztcblxuICAgICAgdGhldGEgPSAoKChkICogcyAvIDQgKyBjIC8gMykgKiBzICsgYiAvIDIpICogcyArIGEpICogcztcbiAgICAgIGNvc1RoZXRhID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgc2luVGhldGEgPSBNYXRoLnNpbih0aGV0YSk7XG5cbiAgICAgIGNvbnN0IHNfc0cgPSBzIC8gc0c7XG4gICAgICBkVF9wMSA9ICgoMy4zNzUgKiBzX3NHIC0gNy41KSAqIHNfc0cgKyA0LjUpICogc19zRyAqIHM7XG4gICAgICBkVF9wMiA9ICgoLTMuMzc1ICogc19zRyArIDYpICogc19zRyAtIDIuMjUpICogc19zRyAqIHM7XG4gICAgICBkVF9zRyA9ICgoMy4zNzUgKiAocDAgLSAzICogcDEgKyAzICogcDIgLSBwMykgKiBzX3NHIC0gMyAqICgyICogcDAgLSA1ICogcDEgKyA0ICogcDIgLSBwMykpICogc19zRyArIDAuMjUgKiAoMTEgKiBwMCAtIDE4ICogcDEgKyA5ICogcDIgLSAyICogcDMpKSAqIHNfc0cgKiBzX3NHO1xuXG4gICAgICBkWF9wMSAtPSBjb2VmZiAqIHNpblRoZXRhICogZFRfcDE7XG4gICAgICBkWF9wMiAtPSBjb2VmZiAqIHNpblRoZXRhICogZFRfcDI7XG4gICAgICBkWF9zRyAtPSBjb2VmZiAqIHNpblRoZXRhICogZFRfc0c7XG5cbiAgICAgIGRZX3AxICs9IGNvZWZmICogY29zVGhldGEgKiBkVF9wMTtcbiAgICAgIGRZX3AyICs9IGNvZWZmICogY29zVGhldGEgKiBkVF9wMjtcbiAgICAgIGRZX3NHICs9IGNvZWZmICogY29zVGhldGEgKiBkVF9zRztcblxuICAgICAgZ3Vlc3NYICs9IGNvZWZmICogY29zVGhldGE7XG4gICAgICBndWVzc1kgKz0gY29lZmYgKiBzaW5UaGV0YTtcbiAgICB9XG5cbiAgICAvLyBBZnRlciB0aGUgU2ltcHNvbidzIGludGVncmF0aW9uIGxvb3AsIGB0aGV0YWAsIGBjb3NUaGV0YWAsIGBzaW5UaGV0YWAsXG4gICAgLy8gYGRUX3AxYCwgYGRUX3AyYCwgYW5kIGBkVF9zR2AgaG9sZCB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzIGZvciBgc0dgLlxuXG4gICAgY29uc3QgaE92ZXIzID0gc0cgLyBTSU1QU09OU19JTlRFUlZBTFMgLyAzO1xuXG4gICAgY29uc3QgZGVsdGFYID0gdGhpcy5nb2FsLnggLSBndWVzc1ggKiBoT3ZlcjM7XG4gICAgY29uc3QgZGVsdGFZID0gdGhpcy5nb2FsLnkgLSBndWVzc1kgKiBoT3ZlcjM7XG4gICAgY29uc3QgZGVsdGFSb3QgPSBNYXRoLndyYXBBbmdsZSh0aGlzLmdvYWwucm90IC0gdGhldGEpO1xuXG4gICAgaWYgKE1hdGguYWJzKGRlbHRhWCkgKyBNYXRoLmFicyhkZWx0YVkpICsgTWF0aC5hYnMoZGVsdGFSb3QpIDwgQ09OVkVSR0VOQ0VfRVJST1IpXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGphY29iaWFuLnNldChcbiAgICAgIGRYX3AxICogaE92ZXIzLCBkWF9wMiAqIGhPdmVyMywgY29zVGhldGEgKyBkWF9zRyAqIGhPdmVyMyxcbiAgICAgIGRZX3AxICogaE92ZXIzLCBkWV9wMiAqIGhPdmVyMywgc2luVGhldGEgKyBkWV9zRyAqIGhPdmVyMyxcbiAgICAgIGRUX3AxLCBkVF9wMiwgZFRfc0dcbiAgICApO1xuXG4gICAgY29uc3QgW20xMSwgbTIxLCBtMzEsIG0xMiwgbTIyLCBtMzIsIG0xMywgbTIzLCBtMzNdID0gaW52SmFjb2JpYW4uZ2V0SW52ZXJzZShqYWNvYmlhbikuZWxlbWVudHM7XG5cbiAgICB0aGlzLnBhcmFtcy5wMSArPSBtMTEgKiBkZWx0YVggKyBtMTIgKiBkZWx0YVkgKyBtMTMgKiBkZWx0YVJvdDtcbiAgICB0aGlzLnBhcmFtcy5wMiArPSBtMjEgKiBkZWx0YVggKyBtMjIgKiBkZWx0YVkgKyBtMjMgKiBkZWx0YVJvdDtcbiAgICB0aGlzLnBhcmFtcy5zRyArPSBtMzEgKiBkZWx0YVggKyBtMzIgKiBkZWx0YVkgKyBtMzMgKiBkZWx0YVJvdDtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGJ1aWxkUGF0aChudW0pIHtcbiAgICBjb25zdCB7IHAwLCBwMSwgcDIsIHAzLCBzRyB9ID0gdGhpcy5wYXJhbXM7XG5cbiAgICBjb25zdCBzR18yID0gc0cgKiBzRztcbiAgICBjb25zdCBzR18zID0gc0dfMiAqIHNHO1xuXG4gICAgY29uc3QgYSA9IHAwO1xuICAgIGNvbnN0IGIgPSAoLTUuNSAqIHAwICsgOSAqIHAxIC0gNC41ICogcDIgKyBwMykgLyBzRztcbiAgICBjb25zdCBjID0gKDkgKiBwMCAtIDIyLjUgKiBwMSArIDE4ICogcDIgLSA0LjUgKiBwMykgLyBzR18yO1xuICAgIGNvbnN0IGQgPSAoLTQuNSAqIChwMCAtIDMgKiBwMSArIDMgKiBwMiAtIHAzKSkgLyBzR18zO1xuXG4gICAgY29uc3QgcGF0aCA9IFt7IHBvczogbmV3IFRIUkVFLlZlY3RvcjIodGhpcy5zdGFydC54LCB0aGlzLnN0YXJ0LnkpLCByb3Q6IHRoaXMuc3RhcnQucm90LCBjdXJ2OiB0aGlzLnN0YXJ0LmN1cnYgfV07XG4gICAgY29uc3QgZHMgPSBzRyAvIChudW0gLSAxKTtcbiAgICBsZXQgcyA9IGRzO1xuICAgIGxldCBkeCA9IDA7XG4gICAgbGV0IGR5ID0gMDtcbiAgICBsZXQgcHJldkNvc1JvdCA9IE1hdGguY29zKHBhdGhbMF0ucm90KTtcbiAgICBsZXQgcHJldlNpblJvdCA9IE1hdGguc2luKHBhdGhbMF0ucm90KTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbnVtIC0gMTsgaSsrKSB7XG4gICAgICBjb25zdCByb3QgPSAoKChkICogcyAvIDQgKyBjIC8gMykgKiBzICsgYiAvIDIpICogcyArIGEpICogcyArIHRoaXMuc3RhcnQucm90O1xuICAgICAgY29uc3QgY3VydiA9ICgoZCAqIHMgKyBjKSAqIHMgKyBiKSAqIHMgKyBhO1xuICAgICAgY29uc3QgY29zUm90ID0gTWF0aC5jb3Mocm90KTtcbiAgICAgIGNvbnN0IHNpblJvdCA9IE1hdGguc2luKHJvdCk7XG5cbiAgICAgIGR4ID0gZHggKiAoaSAtIDEpIC8gaSArIChjb3NSb3QgKyBwcmV2Q29zUm90KSAvICgyICogaSk7XG4gICAgICBkeSA9IGR5ICogKGkgLSAxKSAvIGkgKyAoc2luUm90ICsgcHJldlNpblJvdCkgLyAoMiAqIGkpO1xuXG4gICAgICBwYXRoLnB1c2goeyBwb3M6IG5ldyBUSFJFRS5WZWN0b3IyKHMgKiBkeCArIHRoaXMuc3RhcnQueCwgcyAqIGR5ICsgdGhpcy5zdGFydC55KSwgcm90OiByb3QsIGN1cnY6IGN1cnYgfSk7XG5cbiAgICAgIHMgKz0gZHM7XG4gICAgICBwcmV2Q29zUm90ID0gY29zUm90O1xuICAgICAgcHJldlNpblJvdCA9IHNpblJvdDtcbiAgICB9XG5cbiAgICBwYXRoLnB1c2goeyBwb3M6IG5ldyBUSFJFRS5WZWN0b3IyKHRoaXMuZW5kLngsIHRoaXMuZW5kLnkpLCByb3Q6IHRoaXMuZW5kLnJvdCwgY3VydjogdGhpcy5lbmQuY3VydiB9KTtcblxuICAgIHJldHVybiBwYXRoO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LanePath; });\nconst halfLaneWidth = 3.7;\n\nconst centerlineGeometry = new THREE.Geometry();\nconst leftBoundaryGeometry = new THREE.Geometry();\nconst rightBoundaryGeometry = new THREE.Geometry();\n\nclass LanePath {\n  static hydrate(obj) {\n    Object.setPrototypeOf(obj, LanePath.prototype);\n  }\n\n  constructor() {\n    this.anchors = [];\n    this.centerlines = [];\n    this.sampleLengths = [];\n    this.arcLengths = [];\n    this.leftBoundaries = [];\n    this.rightBoundaries = [];\n  }\n\n  get centerline() {\n    return [].concat(...this.centerlines);\n  }\n\n  get leftBoundary() {\n    return [].concat(...this.leftBoundaries);\n  }\n\n  get rightBoundary() {\n    return [].concat(...this.rightBoundaries);\n  }\n\n  get arcLength() {\n    return this.arcLengths.reduce((sum, l) => sum + l, 0);\n  }\n\n  sampleStations(startStation, num, interval) {\n    const samples = [];\n    let anchorIndex = 0;\n    let sampleIndex = 0;\n    let totalLength = 0;\n    let nextStation = startStation;\n\n    while (totalLength + this.arcLengths[anchorIndex] < nextStation) {\n      totalLength += this.arcLengths[anchorIndex];\n\n      if (++anchorIndex >= this.arcLengths.length)\n        return samples;\n    }\n\n    for (let i = 0; i < num; i++) {\n      let length = this.sampleLengths[anchorIndex][sampleIndex];\n      while (totalLength + length < nextStation) {\n        totalLength += length;\n\n        if (++sampleIndex >= this.sampleLengths[anchorIndex].length) {\n          sampleIndex = 0;\n\n          if (++anchorIndex >= this.sampleLengths.length)\n            return samples;\n        }\n\n        length = this.sampleLengths[anchorIndex][sampleIndex];\n      }\n\n      const [p0, p1, p2, p3] = this.anchorsForSplineIndex(anchorIndex);\n      const weight = (sampleIndex + (nextStation - totalLength) / length) / this.sampleLengths[anchorIndex].length;\n      const pos = catmullRomVec(weight, p0, p1, p2, p3);\n      const tangent = tangentAt(weight, p0, p1, p2, p3);\n      const rot = Math.atan2(tangent.y, tangent.x);\n      const curv = curvatureAt(weight, p0, p1, p2, p3);\n\n      samples.push({ pos, rot, curv });\n      nextStation += interval;\n    }\n\n    return samples;\n  }\n\n  stationLatitudeFromPosition(position, aroundAnchorIndex = null) {\n    const [anchorIndex, sampleIndex, sampleStation, prevSampleStation] = this._findClosestSample(position, aroundAnchorIndex);\n\n    if (anchorIndex === undefined) return [0, 0, 0];\n\n    let prevPoint;\n    let nextPoint;\n    let prevStation;\n    let nextStation;\n\n    if (anchorIndex == 0 && sampleIndex == 0) {\n      prevPoint = this.centerlines[anchorIndex][sampleIndex];\n      nextPoint = this.centerlines[anchorIndex][sampleIndex + 1];\n      prevStation = 0;\n      nextStation = this.sampleLengths[anchorIndex][sampleIndex];\n    } else if (anchorIndex == this.centerlines.length - 1 && sampleIndex == this.centerlines[anchorIndex].length - 1) {\n      prevPoint = this.centerlines[anchorIndex][sampleIndex - 1];\n      nextPoint = this.centerlines[anchorIndex][sampleIndex];\n      prevStation = prevSampleStation;\n      nextStation = sampleStation;\n    } else {\n      prevPoint = sampleIndex == 0 ? this.centerlines[anchorIndex - 1][this.centerlines[anchorIndex - 1].length - 1] : this.centerlines[anchorIndex][sampleIndex - 1];\n      nextPoint = sampleIndex == this.centerlines[anchorIndex].length - 1 ? this.centerlines[anchorIndex + 1][0] : this.centerlines[anchorIndex][sampleIndex + 1];\n\n      const possibleNext = this.centerlines[anchorIndex][sampleIndex];\n      const possibleProgress = position.clone().sub(prevPoint).dot(possibleNext.clone().sub(prevPoint)) / prevPoint.distanceToSquared(possibleNext);\n\n      if (possibleProgress < 1) {\n        nextPoint = possibleNext;\n        prevStation = prevSampleStation;\n        nextStation = sampleStation;\n      } else {\n        prevPoint = possibleNext;\n        prevStation = sampleStation;\n        nextStation = sampleStation + this.sampleLengths[anchorIndex][sampleIndex];\n      }\n    }\n\n    const progress = Math.clamp(position.clone().sub(prevPoint).dot(nextPoint.clone().sub(prevPoint)) / prevPoint.distanceToSquared(nextPoint), 0, 1);\n    const projectedPosition = nextPoint.clone().sub(prevPoint).multiplyScalar(progress).add(prevPoint);\n\n    const station = prevStation + (nextStation - prevStation) * progress;\n    const latitude = Math.sign((nextPoint.x - prevPoint.x) * (position.y - prevPoint.y) - (nextPoint.y - prevPoint.y) * (position.x - prevPoint.x)) * position.distanceTo(projectedPosition);\n\n    return [station, latitude, anchorIndex];\n  }\n\n  _findClosestSample(position, aroundAnchorIndex = null) {\n    let closest = Number.POSITIVE_INFINITY;\n    let bestAnchorIndex;\n    let bestSampleIndex;\n    let bestStation;\n    let bestPrevStation;\n\n    let currStation = 0;\n    let prevStation = 0;\n\n    let startAnchorIndex = 0;\n    let endAnchorIndex = this.centerlines.length - 1;\n\n    if (aroundAnchorIndex !== null) {\n      startAnchorIndex = Math.max(0, aroundAnchorIndex - 2);\n      endAnchorIndex = Math.min(this.centerlines.length - 1, aroundAnchorIndex + 2);\n    }\n\n    if (startAnchorIndex > 0) {\n      for (let anchorIndex = 0; anchorIndex < startAnchorIndex; anchorIndex++) {\n        currStation += this.arcLengths[anchorIndex];\n      }\n\n      prevStation = currStation - this.sampleLengths[startAnchorIndex - 1][this.sampleLengths[startAnchorIndex - 1].length - 1];\n    }\n\n    for (let anchorIndex = startAnchorIndex; anchorIndex <= endAnchorIndex; anchorIndex++) {\n      const centerline = this.centerlines[anchorIndex];\n      for (let sampleIndex = 0; sampleIndex < centerline.length; sampleIndex++) {\n        const distSq = position.distanceToSquared(centerline[sampleIndex]);\n        if (distSq < closest) {\n          closest = distSq;\n          bestAnchorIndex = anchorIndex;\n          bestSampleIndex = sampleIndex;\n          bestStation = currStation;\n          bestPrevStation = prevStation;\n        }\n\n        prevStation = currStation;\n        currStation += this.sampleLengths[anchorIndex][sampleIndex];\n      }\n    }\n\n    return [bestAnchorIndex, bestSampleIndex, bestStation, bestPrevStation];\n  }\n\n  addAnchor(position, resample = true) {\n    const index = this.anchors.push(position) - 1;\n\n    if (resample) {\n      for (let i = index - 2; i < index; i++)\n        this.resample(i);\n    }\n  }\n\n  updateAnchor(index, position) {\n    this.anchors[index] = position;\n\n    for (let i = index - 2; i <= index + 1; i++)\n      this.resample(i);\n  }\n\n  removeAnchor(index) {\n    if (index < 0 || index >= this.anchors.length) return;\n\n    this.anchors.splice(index, 1);\n\n    const segmentIndex = index < this.anchors.length ? index : index - 1;\n    this.centerlines.splice(segmentIndex, 1);\n    this.sampleLengths.splice(segmentIndex, 1);\n    this.leftBoundaries.splice(segmentIndex, 1);\n    this.rightBoundaries.splice(segmentIndex, 1);\n    this.arcLengths.splice(segmentIndex, 1);\n\n    for (let i = segmentIndex - 2; i <= segmentIndex; i++)\n      this.resample(i);\n  }\n\n  resample(index) {\n    if (index < 0 || index > this.anchors.length - 2) return;\n\n    const [p0, p1, p2, p3] = this.anchorsForSplineIndex(index);\n    const points = [];\n    const lengths = [];\n    const leftBoundary = [];\n    const rightBoundary = [];\n    let prevPoint = null;\n\n    const pointsPerSegment = Math.max(10, Math.ceil(p1.distanceTo(p2) / 1));\n    const numPoints = index == this.anchors.length - 2 ? pointsPerSegment + 1 : pointsPerSegment;\n\n    for (let i = 0; i < numPoints; i++) {\n      const t = i / pointsPerSegment;\n      const point = catmullRomVec(t, p0, p1, p2, p3);\n      points.push(point);\n\n      if (prevPoint != null)\n        lengths.push(prevPoint.distanceTo(point));\n      prevPoint = point;\n\n      const tangent = tangentAt(t, p0, p1, p2, p3);\n      const normal = new THREE.Vector2(-tangent.y, tangent.x);\n\n      leftBoundary.push(normal.clone().multiplyScalar(-halfLaneWidth).add(point));\n      rightBoundary.push(normal.clone().multiplyScalar(halfLaneWidth).add(point));\n    }\n\n    lengths.push(prevPoint.distanceTo(p2));\n\n    this.centerlines[index] = points;\n    this.sampleLengths[index] = lengths;\n    this.leftBoundaries[index] = leftBoundary;\n    this.rightBoundaries[index] = rightBoundary;\n    this.arcLengths[index] = lengths.reduce((sum, l) => sum + l, 0);\n  }\n\n  resampleAll() {\n    for (let i = 0; i < this.anchors.length; i++)\n      this.resample(i);\n  }\n\n  anchorsForSplineIndex(index) {\n    let p;\n    if (index == 0)\n      p = [this.anchors[0]].concat(this.anchors.slice(0, 3));\n    else\n      p = this.anchors.slice(index - 1, index + 3);\n\n    if (p[3] === undefined)\n      p[3] = p[2];\n\n    return p;\n  }\n}\n\nfunction catmullRom(t, p0, p1, p2, p3) {\n  const v0 = (p2 - p0) * 0.5;\n  const v1 = (p3 - p1) * 0.5;\n  const t2 = t * t;\n  const t3 = t * t2;\n  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n}\n\nfunction catmullRomVec(t, p0, p1, p2, p3) {\n  return new THREE.Vector2(catmullRom(t, p0.x, p1.x, p2.x, p3.x), catmullRom(t, p0.y, p1.y, p2.y, p3.y));\n}\n\nfunction tangentAt(t, p0, p1, p2, p3) {\n  const delta = 0.0001;\n  let t1 = t - delta;\n  let t2 = t + delta;\n\n  if (t1 < 0) t1 = 0;\n  if (t2 > 1) t2 = 1;\n\n  const prev = catmullRomVec(t1, p0, p1, p2, p3);\n  const next = catmullRomVec(t2, p0, p1, p2, p3);\n\n  return next.sub(prev).normalize();\n}\n\nfunction curvatureAt(t2, p0, p1, p2, p3) {\n  const delta = 0.0001;\n\n  // If we\'re estimating curvature at one of the endpoints of the spline,\n  // slightly shift it inwards to avoid infinite curvature.\n  if (t2 == 0) t2 = delta;\n  if (t2 == 1) t2 = 1 - delta;\n\n  let t1 = t2 - delta;\n  let t3 = t2 + delta;\n\n  if (t1 < 0) t1 = 0;\n  if (t3 > 1) t3 = 1;\n\n  const pt1 = catmullRomVec(t1, p0, p1, p2, p3);\n  const pt2 = catmullRomVec(t2, p0, p1, p2, p3);\n  const pt3 = catmullRomVec(t3, p0, p1, p2, p3);\n\n  return (Math.atan2(pt3.y - pt2.y, pt3.x - pt2.x) - Math.atan2(pt2.y - pt1.y, pt2.x - pt1.x)) / pt2.distanceTo(pt1);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9MYW5lUGF0aC5qcz8wZmE0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsZ0NBQWdDO0FBQy9EO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0Q0FBNEMsK0JBQStCO0FBQzNFO0FBQ0EsK0JBQStCLGlDQUFpQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixXQUFXO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsbUJBQW1CO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBoYWxmTGFuZVdpZHRoID0gMy43O1xuXG5jb25zdCBjZW50ZXJsaW5lR2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbmNvbnN0IGxlZnRCb3VuZGFyeUdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5jb25zdCByaWdodEJvdW5kYXJ5R2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGFuZVBhdGgge1xuICBzdGF0aWMgaHlkcmF0ZShvYmopIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yob2JqLCBMYW5lUGF0aC5wcm90b3R5cGUpO1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5hbmNob3JzID0gW107XG4gICAgdGhpcy5jZW50ZXJsaW5lcyA9IFtdO1xuICAgIHRoaXMuc2FtcGxlTGVuZ3RocyA9IFtdO1xuICAgIHRoaXMuYXJjTGVuZ3RocyA9IFtdO1xuICAgIHRoaXMubGVmdEJvdW5kYXJpZXMgPSBbXTtcbiAgICB0aGlzLnJpZ2h0Qm91bmRhcmllcyA9IFtdO1xuICB9XG5cbiAgZ2V0IGNlbnRlcmxpbmUoKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdCguLi50aGlzLmNlbnRlcmxpbmVzKTtcbiAgfVxuXG4gIGdldCBsZWZ0Qm91bmRhcnkoKSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdCguLi50aGlzLmxlZnRCb3VuZGFyaWVzKTtcbiAgfVxuXG4gIGdldCByaWdodEJvdW5kYXJ5KCkge1xuICAgIHJldHVybiBbXS5jb25jYXQoLi4udGhpcy5yaWdodEJvdW5kYXJpZXMpO1xuICB9XG5cbiAgZ2V0IGFyY0xlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5hcmNMZW5ndGhzLnJlZHVjZSgoc3VtLCBsKSA9PiBzdW0gKyBsLCAwKTtcbiAgfVxuXG4gIHNhbXBsZVN0YXRpb25zKHN0YXJ0U3RhdGlvbiwgbnVtLCBpbnRlcnZhbCkge1xuICAgIGNvbnN0IHNhbXBsZXMgPSBbXTtcbiAgICBsZXQgYW5jaG9ySW5kZXggPSAwO1xuICAgIGxldCBzYW1wbGVJbmRleCA9IDA7XG4gICAgbGV0IHRvdGFsTGVuZ3RoID0gMDtcbiAgICBsZXQgbmV4dFN0YXRpb24gPSBzdGFydFN0YXRpb247XG5cbiAgICB3aGlsZSAodG90YWxMZW5ndGggKyB0aGlzLmFyY0xlbmd0aHNbYW5jaG9ySW5kZXhdIDwgbmV4dFN0YXRpb24pIHtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IHRoaXMuYXJjTGVuZ3Roc1thbmNob3JJbmRleF07XG5cbiAgICAgIGlmICgrK2FuY2hvckluZGV4ID49IHRoaXMuYXJjTGVuZ3Rocy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBzYW1wbGVzO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICAgIGxldCBsZW5ndGggPSB0aGlzLnNhbXBsZUxlbmd0aHNbYW5jaG9ySW5kZXhdW3NhbXBsZUluZGV4XTtcbiAgICAgIHdoaWxlICh0b3RhbExlbmd0aCArIGxlbmd0aCA8IG5leHRTdGF0aW9uKSB7XG4gICAgICAgIHRvdGFsTGVuZ3RoICs9IGxlbmd0aDtcblxuICAgICAgICBpZiAoKytzYW1wbGVJbmRleCA+PSB0aGlzLnNhbXBsZUxlbmd0aHNbYW5jaG9ySW5kZXhdLmxlbmd0aCkge1xuICAgICAgICAgIHNhbXBsZUluZGV4ID0gMDtcblxuICAgICAgICAgIGlmICgrK2FuY2hvckluZGV4ID49IHRoaXMuc2FtcGxlTGVuZ3Rocy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gc2FtcGxlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGxlbmd0aCA9IHRoaXMuc2FtcGxlTGVuZ3Roc1thbmNob3JJbmRleF1bc2FtcGxlSW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBbcDAsIHAxLCBwMiwgcDNdID0gdGhpcy5hbmNob3JzRm9yU3BsaW5lSW5kZXgoYW5jaG9ySW5kZXgpO1xuICAgICAgY29uc3Qgd2VpZ2h0ID0gKHNhbXBsZUluZGV4ICsgKG5leHRTdGF0aW9uIC0gdG90YWxMZW5ndGgpIC8gbGVuZ3RoKSAvIHRoaXMuc2FtcGxlTGVuZ3Roc1thbmNob3JJbmRleF0ubGVuZ3RoO1xuICAgICAgY29uc3QgcG9zID0gY2F0bXVsbFJvbVZlYyh3ZWlnaHQsIHAwLCBwMSwgcDIsIHAzKTtcbiAgICAgIGNvbnN0IHRhbmdlbnQgPSB0YW5nZW50QXQod2VpZ2h0LCBwMCwgcDEsIHAyLCBwMyk7XG4gICAgICBjb25zdCByb3QgPSBNYXRoLmF0YW4yKHRhbmdlbnQueSwgdGFuZ2VudC54KTtcbiAgICAgIGNvbnN0IGN1cnYgPSBjdXJ2YXR1cmVBdCh3ZWlnaHQsIHAwLCBwMSwgcDIsIHAzKTtcblxuICAgICAgc2FtcGxlcy5wdXNoKHsgcG9zLCByb3QsIGN1cnYgfSk7XG4gICAgICBuZXh0U3RhdGlvbiArPSBpbnRlcnZhbDtcbiAgICB9XG5cbiAgICByZXR1cm4gc2FtcGxlcztcbiAgfVxuXG4gIHN0YXRpb25MYXRpdHVkZUZyb21Qb3NpdGlvbihwb3NpdGlvbiwgYXJvdW5kQW5jaG9ySW5kZXggPSBudWxsKSB7XG4gICAgY29uc3QgW2FuY2hvckluZGV4LCBzYW1wbGVJbmRleCwgc2FtcGxlU3RhdGlvbiwgcHJldlNhbXBsZVN0YXRpb25dID0gdGhpcy5fZmluZENsb3Nlc3RTYW1wbGUocG9zaXRpb24sIGFyb3VuZEFuY2hvckluZGV4KTtcblxuICAgIGlmIChhbmNob3JJbmRleCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gWzAsIDAsIDBdO1xuXG4gICAgbGV0IHByZXZQb2ludDtcbiAgICBsZXQgbmV4dFBvaW50O1xuICAgIGxldCBwcmV2U3RhdGlvbjtcbiAgICBsZXQgbmV4dFN0YXRpb247XG5cbiAgICBpZiAoYW5jaG9ySW5kZXggPT0gMCAmJiBzYW1wbGVJbmRleCA9PSAwKSB7XG4gICAgICBwcmV2UG9pbnQgPSB0aGlzLmNlbnRlcmxpbmVzW2FuY2hvckluZGV4XVtzYW1wbGVJbmRleF07XG4gICAgICBuZXh0UG9pbnQgPSB0aGlzLmNlbnRlcmxpbmVzW2FuY2hvckluZGV4XVtzYW1wbGVJbmRleCArIDFdO1xuICAgICAgcHJldlN0YXRpb24gPSAwO1xuICAgICAgbmV4dFN0YXRpb24gPSB0aGlzLnNhbXBsZUxlbmd0aHNbYW5jaG9ySW5kZXhdW3NhbXBsZUluZGV4XTtcbiAgICB9IGVsc2UgaWYgKGFuY2hvckluZGV4ID09IHRoaXMuY2VudGVybGluZXMubGVuZ3RoIC0gMSAmJiBzYW1wbGVJbmRleCA9PSB0aGlzLmNlbnRlcmxpbmVzW2FuY2hvckluZGV4XS5sZW5ndGggLSAxKSB7XG4gICAgICBwcmV2UG9pbnQgPSB0aGlzLmNlbnRlcmxpbmVzW2FuY2hvckluZGV4XVtzYW1wbGVJbmRleCAtIDFdO1xuICAgICAgbmV4dFBvaW50ID0gdGhpcy5jZW50ZXJsaW5lc1thbmNob3JJbmRleF1bc2FtcGxlSW5kZXhdO1xuICAgICAgcHJldlN0YXRpb24gPSBwcmV2U2FtcGxlU3RhdGlvbjtcbiAgICAgIG5leHRTdGF0aW9uID0gc2FtcGxlU3RhdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldlBvaW50ID0gc2FtcGxlSW5kZXggPT0gMCA/IHRoaXMuY2VudGVybGluZXNbYW5jaG9ySW5kZXggLSAxXVt0aGlzLmNlbnRlcmxpbmVzW2FuY2hvckluZGV4IC0gMV0ubGVuZ3RoIC0gMV0gOiB0aGlzLmNlbnRlcmxpbmVzW2FuY2hvckluZGV4XVtzYW1wbGVJbmRleCAtIDFdO1xuICAgICAgbmV4dFBvaW50ID0gc2FtcGxlSW5kZXggPT0gdGhpcy5jZW50ZXJsaW5lc1thbmNob3JJbmRleF0ubGVuZ3RoIC0gMSA/IHRoaXMuY2VudGVybGluZXNbYW5jaG9ySW5kZXggKyAxXVswXSA6IHRoaXMuY2VudGVybGluZXNbYW5jaG9ySW5kZXhdW3NhbXBsZUluZGV4ICsgMV07XG5cbiAgICAgIGNvbnN0IHBvc3NpYmxlTmV4dCA9IHRoaXMuY2VudGVybGluZXNbYW5jaG9ySW5kZXhdW3NhbXBsZUluZGV4XTtcbiAgICAgIGNvbnN0IHBvc3NpYmxlUHJvZ3Jlc3MgPSBwb3NpdGlvbi5jbG9uZSgpLnN1YihwcmV2UG9pbnQpLmRvdChwb3NzaWJsZU5leHQuY2xvbmUoKS5zdWIocHJldlBvaW50KSkgLyBwcmV2UG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQocG9zc2libGVOZXh0KTtcblxuICAgICAgaWYgKHBvc3NpYmxlUHJvZ3Jlc3MgPCAxKSB7XG4gICAgICAgIG5leHRQb2ludCA9IHBvc3NpYmxlTmV4dDtcbiAgICAgICAgcHJldlN0YXRpb24gPSBwcmV2U2FtcGxlU3RhdGlvbjtcbiAgICAgICAgbmV4dFN0YXRpb24gPSBzYW1wbGVTdGF0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldlBvaW50ID0gcG9zc2libGVOZXh0O1xuICAgICAgICBwcmV2U3RhdGlvbiA9IHNhbXBsZVN0YXRpb247XG4gICAgICAgIG5leHRTdGF0aW9uID0gc2FtcGxlU3RhdGlvbiArIHRoaXMuc2FtcGxlTGVuZ3Roc1thbmNob3JJbmRleF1bc2FtcGxlSW5kZXhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5jbGFtcChwb3NpdGlvbi5jbG9uZSgpLnN1YihwcmV2UG9pbnQpLmRvdChuZXh0UG9pbnQuY2xvbmUoKS5zdWIocHJldlBvaW50KSkgLyBwcmV2UG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQobmV4dFBvaW50KSwgMCwgMSk7XG4gICAgY29uc3QgcHJvamVjdGVkUG9zaXRpb24gPSBuZXh0UG9pbnQuY2xvbmUoKS5zdWIocHJldlBvaW50KS5tdWx0aXBseVNjYWxhcihwcm9ncmVzcykuYWRkKHByZXZQb2ludCk7XG5cbiAgICBjb25zdCBzdGF0aW9uID0gcHJldlN0YXRpb24gKyAobmV4dFN0YXRpb24gLSBwcmV2U3RhdGlvbikgKiBwcm9ncmVzcztcbiAgICBjb25zdCBsYXRpdHVkZSA9IE1hdGguc2lnbigobmV4dFBvaW50LnggLSBwcmV2UG9pbnQueCkgKiAocG9zaXRpb24ueSAtIHByZXZQb2ludC55KSAtIChuZXh0UG9pbnQueSAtIHByZXZQb2ludC55KSAqIChwb3NpdGlvbi54IC0gcHJldlBvaW50LngpKSAqIHBvc2l0aW9uLmRpc3RhbmNlVG8ocHJvamVjdGVkUG9zaXRpb24pO1xuXG4gICAgcmV0dXJuIFtzdGF0aW9uLCBsYXRpdHVkZSwgYW5jaG9ySW5kZXhdO1xuICB9XG5cbiAgX2ZpbmRDbG9zZXN0U2FtcGxlKHBvc2l0aW9uLCBhcm91bmRBbmNob3JJbmRleCA9IG51bGwpIHtcbiAgICBsZXQgY2xvc2VzdCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgYmVzdEFuY2hvckluZGV4O1xuICAgIGxldCBiZXN0U2FtcGxlSW5kZXg7XG4gICAgbGV0IGJlc3RTdGF0aW9uO1xuICAgIGxldCBiZXN0UHJldlN0YXRpb247XG5cbiAgICBsZXQgY3VyclN0YXRpb24gPSAwO1xuICAgIGxldCBwcmV2U3RhdGlvbiA9IDA7XG5cbiAgICBsZXQgc3RhcnRBbmNob3JJbmRleCA9IDA7XG4gICAgbGV0IGVuZEFuY2hvckluZGV4ID0gdGhpcy5jZW50ZXJsaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgaWYgKGFyb3VuZEFuY2hvckluZGV4ICE9PSBudWxsKSB7XG4gICAgICBzdGFydEFuY2hvckluZGV4ID0gTWF0aC5tYXgoMCwgYXJvdW5kQW5jaG9ySW5kZXggLSAyKTtcbiAgICAgIGVuZEFuY2hvckluZGV4ID0gTWF0aC5taW4odGhpcy5jZW50ZXJsaW5lcy5sZW5ndGggLSAxLCBhcm91bmRBbmNob3JJbmRleCArIDIpO1xuICAgIH1cblxuICAgIGlmIChzdGFydEFuY2hvckluZGV4ID4gMCkge1xuICAgICAgZm9yIChsZXQgYW5jaG9ySW5kZXggPSAwOyBhbmNob3JJbmRleCA8IHN0YXJ0QW5jaG9ySW5kZXg7IGFuY2hvckluZGV4KyspIHtcbiAgICAgICAgY3VyclN0YXRpb24gKz0gdGhpcy5hcmNMZW5ndGhzW2FuY2hvckluZGV4XTtcbiAgICAgIH1cblxuICAgICAgcHJldlN0YXRpb24gPSBjdXJyU3RhdGlvbiAtIHRoaXMuc2FtcGxlTGVuZ3Roc1tzdGFydEFuY2hvckluZGV4IC0gMV1bdGhpcy5zYW1wbGVMZW5ndGhzW3N0YXJ0QW5jaG9ySW5kZXggLSAxXS5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBhbmNob3JJbmRleCA9IHN0YXJ0QW5jaG9ySW5kZXg7IGFuY2hvckluZGV4IDw9IGVuZEFuY2hvckluZGV4OyBhbmNob3JJbmRleCsrKSB7XG4gICAgICBjb25zdCBjZW50ZXJsaW5lID0gdGhpcy5jZW50ZXJsaW5lc1thbmNob3JJbmRleF07XG4gICAgICBmb3IgKGxldCBzYW1wbGVJbmRleCA9IDA7IHNhbXBsZUluZGV4IDwgY2VudGVybGluZS5sZW5ndGg7IHNhbXBsZUluZGV4KyspIHtcbiAgICAgICAgY29uc3QgZGlzdFNxID0gcG9zaXRpb24uZGlzdGFuY2VUb1NxdWFyZWQoY2VudGVybGluZVtzYW1wbGVJbmRleF0pO1xuICAgICAgICBpZiAoZGlzdFNxIDwgY2xvc2VzdCkge1xuICAgICAgICAgIGNsb3Nlc3QgPSBkaXN0U3E7XG4gICAgICAgICAgYmVzdEFuY2hvckluZGV4ID0gYW5jaG9ySW5kZXg7XG4gICAgICAgICAgYmVzdFNhbXBsZUluZGV4ID0gc2FtcGxlSW5kZXg7XG4gICAgICAgICAgYmVzdFN0YXRpb24gPSBjdXJyU3RhdGlvbjtcbiAgICAgICAgICBiZXN0UHJldlN0YXRpb24gPSBwcmV2U3RhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZTdGF0aW9uID0gY3VyclN0YXRpb247XG4gICAgICAgIGN1cnJTdGF0aW9uICs9IHRoaXMuc2FtcGxlTGVuZ3Roc1thbmNob3JJbmRleF1bc2FtcGxlSW5kZXhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbYmVzdEFuY2hvckluZGV4LCBiZXN0U2FtcGxlSW5kZXgsIGJlc3RTdGF0aW9uLCBiZXN0UHJldlN0YXRpb25dO1xuICB9XG5cbiAgYWRkQW5jaG9yKHBvc2l0aW9uLCByZXNhbXBsZSA9IHRydWUpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuYW5jaG9ycy5wdXNoKHBvc2l0aW9uKSAtIDE7XG5cbiAgICBpZiAocmVzYW1wbGUpIHtcbiAgICAgIGZvciAobGV0IGkgPSBpbmRleCAtIDI7IGkgPCBpbmRleDsgaSsrKVxuICAgICAgICB0aGlzLnJlc2FtcGxlKGkpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUFuY2hvcihpbmRleCwgcG9zaXRpb24pIHtcbiAgICB0aGlzLmFuY2hvcnNbaW5kZXhdID0gcG9zaXRpb247XG5cbiAgICBmb3IgKGxldCBpID0gaW5kZXggLSAyOyBpIDw9IGluZGV4ICsgMTsgaSsrKVxuICAgICAgdGhpcy5yZXNhbXBsZShpKTtcbiAgfVxuXG4gIHJlbW92ZUFuY2hvcihpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5hbmNob3JzLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgdGhpcy5hbmNob3JzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICBjb25zdCBzZWdtZW50SW5kZXggPSBpbmRleCA8IHRoaXMuYW5jaG9ycy5sZW5ndGggPyBpbmRleCA6IGluZGV4IC0gMTtcbiAgICB0aGlzLmNlbnRlcmxpbmVzLnNwbGljZShzZWdtZW50SW5kZXgsIDEpO1xuICAgIHRoaXMuc2FtcGxlTGVuZ3Rocy5zcGxpY2Uoc2VnbWVudEluZGV4LCAxKTtcbiAgICB0aGlzLmxlZnRCb3VuZGFyaWVzLnNwbGljZShzZWdtZW50SW5kZXgsIDEpO1xuICAgIHRoaXMucmlnaHRCb3VuZGFyaWVzLnNwbGljZShzZWdtZW50SW5kZXgsIDEpO1xuICAgIHRoaXMuYXJjTGVuZ3Rocy5zcGxpY2Uoc2VnbWVudEluZGV4LCAxKTtcblxuICAgIGZvciAobGV0IGkgPSBzZWdtZW50SW5kZXggLSAyOyBpIDw9IHNlZ21lbnRJbmRleDsgaSsrKVxuICAgICAgdGhpcy5yZXNhbXBsZShpKTtcbiAgfVxuXG4gIHJlc2FtcGxlKGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRoaXMuYW5jaG9ycy5sZW5ndGggLSAyKSByZXR1cm47XG5cbiAgICBjb25zdCBbcDAsIHAxLCBwMiwgcDNdID0gdGhpcy5hbmNob3JzRm9yU3BsaW5lSW5kZXgoaW5kZXgpO1xuICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgIGNvbnN0IGxlbmd0aHMgPSBbXTtcbiAgICBjb25zdCBsZWZ0Qm91bmRhcnkgPSBbXTtcbiAgICBjb25zdCByaWdodEJvdW5kYXJ5ID0gW107XG4gICAgbGV0IHByZXZQb2ludCA9IG51bGw7XG5cbiAgICBjb25zdCBwb2ludHNQZXJTZWdtZW50ID0gTWF0aC5tYXgoMTAsIE1hdGguY2VpbChwMS5kaXN0YW5jZVRvKHAyKSAvIDEpKTtcbiAgICBjb25zdCBudW1Qb2ludHMgPSBpbmRleCA9PSB0aGlzLmFuY2hvcnMubGVuZ3RoIC0gMiA/IHBvaW50c1BlclNlZ21lbnQgKyAxIDogcG9pbnRzUGVyU2VnbWVudDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUG9pbnRzOyBpKyspIHtcbiAgICAgIGNvbnN0IHQgPSBpIC8gcG9pbnRzUGVyU2VnbWVudDtcbiAgICAgIGNvbnN0IHBvaW50ID0gY2F0bXVsbFJvbVZlYyh0LCBwMCwgcDEsIHAyLCBwMyk7XG4gICAgICBwb2ludHMucHVzaChwb2ludCk7XG5cbiAgICAgIGlmIChwcmV2UG9pbnQgIT0gbnVsbClcbiAgICAgICAgbGVuZ3Rocy5wdXNoKHByZXZQb2ludC5kaXN0YW5jZVRvKHBvaW50KSk7XG4gICAgICBwcmV2UG9pbnQgPSBwb2ludDtcblxuICAgICAgY29uc3QgdGFuZ2VudCA9IHRhbmdlbnRBdCh0LCBwMCwgcDEsIHAyLCBwMyk7XG4gICAgICBjb25zdCBub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMigtdGFuZ2VudC55LCB0YW5nZW50LngpO1xuXG4gICAgICBsZWZ0Qm91bmRhcnkucHVzaChub3JtYWwuY2xvbmUoKS5tdWx0aXBseVNjYWxhcigtaGFsZkxhbmVXaWR0aCkuYWRkKHBvaW50KSk7XG4gICAgICByaWdodEJvdW5kYXJ5LnB1c2gobm9ybWFsLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoaGFsZkxhbmVXaWR0aCkuYWRkKHBvaW50KSk7XG4gICAgfVxuXG4gICAgbGVuZ3Rocy5wdXNoKHByZXZQb2ludC5kaXN0YW5jZVRvKHAyKSk7XG5cbiAgICB0aGlzLmNlbnRlcmxpbmVzW2luZGV4XSA9IHBvaW50cztcbiAgICB0aGlzLnNhbXBsZUxlbmd0aHNbaW5kZXhdID0gbGVuZ3RocztcbiAgICB0aGlzLmxlZnRCb3VuZGFyaWVzW2luZGV4XSA9IGxlZnRCb3VuZGFyeTtcbiAgICB0aGlzLnJpZ2h0Qm91bmRhcmllc1tpbmRleF0gPSByaWdodEJvdW5kYXJ5O1xuICAgIHRoaXMuYXJjTGVuZ3Roc1tpbmRleF0gPSBsZW5ndGhzLnJlZHVjZSgoc3VtLCBsKSA9PiBzdW0gKyBsLCAwKTtcbiAgfVxuXG4gIHJlc2FtcGxlQWxsKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hbmNob3JzLmxlbmd0aDsgaSsrKVxuICAgICAgdGhpcy5yZXNhbXBsZShpKTtcbiAgfVxuXG4gIGFuY2hvcnNGb3JTcGxpbmVJbmRleChpbmRleCkge1xuICAgIGxldCBwO1xuICAgIGlmIChpbmRleCA9PSAwKVxuICAgICAgcCA9IFt0aGlzLmFuY2hvcnNbMF1dLmNvbmNhdCh0aGlzLmFuY2hvcnMuc2xpY2UoMCwgMykpO1xuICAgIGVsc2VcbiAgICAgIHAgPSB0aGlzLmFuY2hvcnMuc2xpY2UoaW5kZXggLSAxLCBpbmRleCArIDMpO1xuXG4gICAgaWYgKHBbM10gPT09IHVuZGVmaW5lZClcbiAgICAgIHBbM10gPSBwWzJdO1xuXG4gICAgcmV0dXJuIHA7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2F0bXVsbFJvbSh0LCBwMCwgcDEsIHAyLCBwMykge1xuICBjb25zdCB2MCA9IChwMiAtIHAwKSAqIDAuNTtcbiAgY29uc3QgdjEgPSAocDMgLSBwMSkgKiAwLjU7XG4gIGNvbnN0IHQyID0gdCAqIHQ7XG4gIGNvbnN0IHQzID0gdCAqIHQyO1xuICByZXR1cm4gKDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEpICogdDMgKyAoLTMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxKSAqIHQyICsgdjAgKiB0ICsgcDE7XG59XG5cbmZ1bmN0aW9uIGNhdG11bGxSb21WZWModCwgcDAsIHAxLCBwMiwgcDMpIHtcbiAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKGNhdG11bGxSb20odCwgcDAueCwgcDEueCwgcDIueCwgcDMueCksIGNhdG11bGxSb20odCwgcDAueSwgcDEueSwgcDIueSwgcDMueSkpO1xufVxuXG5mdW5jdGlvbiB0YW5nZW50QXQodCwgcDAsIHAxLCBwMiwgcDMpIHtcbiAgY29uc3QgZGVsdGEgPSAwLjAwMDE7XG4gIGxldCB0MSA9IHQgLSBkZWx0YTtcbiAgbGV0IHQyID0gdCArIGRlbHRhO1xuXG4gIGlmICh0MSA8IDApIHQxID0gMDtcbiAgaWYgKHQyID4gMSkgdDIgPSAxO1xuXG4gIGNvbnN0IHByZXYgPSBjYXRtdWxsUm9tVmVjKHQxLCBwMCwgcDEsIHAyLCBwMyk7XG4gIGNvbnN0IG5leHQgPSBjYXRtdWxsUm9tVmVjKHQyLCBwMCwgcDEsIHAyLCBwMyk7XG5cbiAgcmV0dXJuIG5leHQuc3ViKHByZXYpLm5vcm1hbGl6ZSgpO1xufVxuXG5mdW5jdGlvbiBjdXJ2YXR1cmVBdCh0MiwgcDAsIHAxLCBwMiwgcDMpIHtcbiAgY29uc3QgZGVsdGEgPSAwLjAwMDE7XG5cbiAgLy8gSWYgd2UncmUgZXN0aW1hdGluZyBjdXJ2YXR1cmUgYXQgb25lIG9mIHRoZSBlbmRwb2ludHMgb2YgdGhlIHNwbGluZSxcbiAgLy8gc2xpZ2h0bHkgc2hpZnQgaXQgaW53YXJkcyB0byBhdm9pZCBpbmZpbml0ZSBjdXJ2YXR1cmUuXG4gIGlmICh0MiA9PSAwKSB0MiA9IGRlbHRhO1xuICBpZiAodDIgPT0gMSkgdDIgPSAxIC0gZGVsdGE7XG5cbiAgbGV0IHQxID0gdDIgLSBkZWx0YTtcbiAgbGV0IHQzID0gdDIgKyBkZWx0YTtcblxuICBpZiAodDEgPCAwKSB0MSA9IDA7XG4gIGlmICh0MyA+IDEpIHQzID0gMTtcblxuICBjb25zdCBwdDEgPSBjYXRtdWxsUm9tVmVjKHQxLCBwMCwgcDEsIHAyLCBwMyk7XG4gIGNvbnN0IHB0MiA9IGNhdG11bGxSb21WZWModDIsIHAwLCBwMSwgcDIsIHAzKTtcbiAgY29uc3QgcHQzID0gY2F0bXVsbFJvbVZlYyh0MywgcDAsIHAxLCBwMiwgcDMpO1xuXG4gIHJldHVybiAoTWF0aC5hdGFuMihwdDMueSAtIHB0Mi55LCBwdDMueCAtIHB0Mi54KSAtIE1hdGguYXRhbjIocHQyLnkgLSBwdDEueSwgcHQyLnggLSBwdDEueCkpIC8gcHQyLmRpc3RhbmNlVG8ocHQxKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return DynamicObstacle; });\n// Half width and half height\nconst VEHICLE_SIZE = { w: 2.5, h: 1 };\nconst CYCLIST_SIZE = { w: 1.2, h: 0.6 };\nconst PEDESTRIAN_SIZE = { w: 0.6, h: 0.6 };\n\nclass DynamicObstacle {\n  static hydrate(obj) {\n    Object.setPrototypeOf(obj, DynamicObstacle.prototype);\n    Object.setPrototypeOf(obj.startPos, THREE.Vector2.prototype);\n    Object.setPrototypeOf(obj.velocity, THREE.Vector2.prototype);\n  }\n\n  constructor(type, startPos, velocity, parallel) {\n    this.type = type;\n    this.startPos = startPos;\n    this.velocity = velocity;\n    this.parallel = parallel;\n\n    switch (type) {\n        case 'cyclist':\n          this.size = Object.assign({}, CYCLIST_SIZE);\n          break;\n\n        case 'pedestrian':\n          this.size = Object.assign({}, PEDESTRIAN_SIZE);\n          break;\n\n        default:\n          this.size = Object.assign({}, VEHICLE_SIZE);\n    }\n\n    if (!parallel)\n      [this.size.w, this.size.h] = [this.size.h, this.size.w];\n  }\n\n  positionAtTime(time) {\n    return this.velocity.clone().multiplyScalar(time).add(this.startPos);\n  }\n\n  positionsInTimeRange(startTime, endTime, numFrames) {\n    const dt = (endTime - startTime) / numFrames;\n    const positions = [];\n    let time = startTime;\n\n    for (let i = 0; i <= numFrames; i++) {\n      positions.push(this.positionAtTime(time));\n      time += dt;\n    }\n\n    return positions;\n  }\n\n  verticesInTimeRange(startTime, endTime, config) {\n    const positions = this.positionsInTimeRange(startTime, endTime, config.numDynamicSubframes);\n    const vertices = [];\n\n    // Hazard dilation (drawn behind, z = 0.75)\n    const hazardHalfWidth = this.size.w + config.dynamicHazardDilationS + config.collisionDilationS;\n    const hazardHalfHeight = this.size.h + config.dynamicHazardDilationL + config.collisionDilationL;\n\n    positions.forEach(p => {\n      const v1 = [-hazardHalfWidth + p.x, hazardHalfHeight + p.y];\n      const v2 = [hazardHalfWidth + p.x, hazardHalfHeight + p.y];\n      const v3 = [hazardHalfWidth + p.x, -hazardHalfHeight + p.y];\n      const v4 = [-hazardHalfWidth + p.x, -hazardHalfHeight + p.y];\n\n      vertices.push(\n        v1[0], v1[1], 0.75,\n        v2[0], v2[1], 0.75,\n        v3[0], v3[1], 0.75,\n        v3[0], v3[1], 0.75,\n        v4[0], v4[1], 0.75,\n        v1[0], v1[1], 0.75\n      );\n    });\n    \n    // Collision dilation (drawn in front, z = 0.25)\n    const collisionHalfWidth = this.size.w + config.collisionDilationS;\n    const collisionHalfHeight = this.size.h + config.collisionDilationL;\n\n    positions.forEach(p => {\n      const v1 = [-collisionHalfWidth + p.x, collisionHalfHeight + p.y];\n      const v2 = [collisionHalfWidth + p.x, collisionHalfHeight + p.y];\n      const v3 = [collisionHalfWidth + p.x, -collisionHalfHeight + p.y];\n      const v4 = [-collisionHalfWidth + p.x, -collisionHalfHeight + p.y];\n\n      vertices.push(\n        v1[0], v1[1], 0.25,\n        v2[0], v2[1], 0.25,\n        v3[0], v3[1], 0.25,\n        v3[0], v3[1], 0.25,\n        v4[0], v4[1], 0.25,\n        v1[0], v1[1], 0.25\n      );\n    });\n\n    return vertices;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9EeW5hbWljT2JzdGFjbGUuanM/MmU3MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0Esc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0Qix5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEhhbGYgd2lkdGggYW5kIGhhbGYgaGVpZ2h0XG5jb25zdCBWRUhJQ0xFX1NJWkUgPSB7IHc6IDIuNSwgaDogMSB9O1xuY29uc3QgQ1lDTElTVF9TSVpFID0geyB3OiAxLjIsIGg6IDAuNiB9O1xuY29uc3QgUEVERVNUUklBTl9TSVpFID0geyB3OiAwLjYsIGg6IDAuNiB9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEeW5hbWljT2JzdGFjbGUge1xuICBzdGF0aWMgaHlkcmF0ZShvYmopIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yob2JqLCBEeW5hbWljT2JzdGFjbGUucHJvdG90eXBlKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yob2JqLnN0YXJ0UG9zLCBUSFJFRS5WZWN0b3IyLnByb3RvdHlwZSk7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG9iai52ZWxvY2l0eSwgVEhSRUUuVmVjdG9yMi5wcm90b3R5cGUpO1xuICB9XG5cbiAgY29uc3RydWN0b3IodHlwZSwgc3RhcnRQb3MsIHZlbG9jaXR5LCBwYXJhbGxlbCkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5zdGFydFBvcyA9IHN0YXJ0UG9zO1xuICAgIHRoaXMudmVsb2NpdHkgPSB2ZWxvY2l0eTtcbiAgICB0aGlzLnBhcmFsbGVsID0gcGFyYWxsZWw7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnY3ljbGlzdCc6XG4gICAgICAgICAgdGhpcy5zaXplID0gT2JqZWN0LmFzc2lnbih7fSwgQ1lDTElTVF9TSVpFKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdwZWRlc3RyaWFuJzpcbiAgICAgICAgICB0aGlzLnNpemUgPSBPYmplY3QuYXNzaWduKHt9LCBQRURFU1RSSUFOX1NJWkUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhpcy5zaXplID0gT2JqZWN0LmFzc2lnbih7fSwgVkVISUNMRV9TSVpFKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFsbGVsKVxuICAgICAgW3RoaXMuc2l6ZS53LCB0aGlzLnNpemUuaF0gPSBbdGhpcy5zaXplLmgsIHRoaXMuc2l6ZS53XTtcbiAgfVxuXG4gIHBvc2l0aW9uQXRUaW1lKHRpbWUpIHtcbiAgICByZXR1cm4gdGhpcy52ZWxvY2l0eS5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKHRpbWUpLmFkZCh0aGlzLnN0YXJ0UG9zKTtcbiAgfVxuXG4gIHBvc2l0aW9uc0luVGltZVJhbmdlKHN0YXJ0VGltZSwgZW5kVGltZSwgbnVtRnJhbWVzKSB7XG4gICAgY29uc3QgZHQgPSAoZW5kVGltZSAtIHN0YXJ0VGltZSkgLyBudW1GcmFtZXM7XG4gICAgY29uc3QgcG9zaXRpb25zID0gW107XG4gICAgbGV0IHRpbWUgPSBzdGFydFRpbWU7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBudW1GcmFtZXM7IGkrKykge1xuICAgICAgcG9zaXRpb25zLnB1c2godGhpcy5wb3NpdGlvbkF0VGltZSh0aW1lKSk7XG4gICAgICB0aW1lICs9IGR0O1xuICAgIH1cblxuICAgIHJldHVybiBwb3NpdGlvbnM7XG4gIH1cblxuICB2ZXJ0aWNlc0luVGltZVJhbmdlKHN0YXJ0VGltZSwgZW5kVGltZSwgY29uZmlnKSB7XG4gICAgY29uc3QgcG9zaXRpb25zID0gdGhpcy5wb3NpdGlvbnNJblRpbWVSYW5nZShzdGFydFRpbWUsIGVuZFRpbWUsIGNvbmZpZy5udW1EeW5hbWljU3ViZnJhbWVzKTtcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IFtdO1xuXG4gICAgLy8gSGF6YXJkIGRpbGF0aW9uIChkcmF3biBiZWhpbmQsIHogPSAwLjc1KVxuICAgIGNvbnN0IGhhemFyZEhhbGZXaWR0aCA9IHRoaXMuc2l6ZS53ICsgY29uZmlnLmR5bmFtaWNIYXphcmREaWxhdGlvblMgKyBjb25maWcuY29sbGlzaW9uRGlsYXRpb25TO1xuICAgIGNvbnN0IGhhemFyZEhhbGZIZWlnaHQgPSB0aGlzLnNpemUuaCArIGNvbmZpZy5keW5hbWljSGF6YXJkRGlsYXRpb25MICsgY29uZmlnLmNvbGxpc2lvbkRpbGF0aW9uTDtcblxuICAgIHBvc2l0aW9ucy5mb3JFYWNoKHAgPT4ge1xuICAgICAgY29uc3QgdjEgPSBbLWhhemFyZEhhbGZXaWR0aCArIHAueCwgaGF6YXJkSGFsZkhlaWdodCArIHAueV07XG4gICAgICBjb25zdCB2MiA9IFtoYXphcmRIYWxmV2lkdGggKyBwLngsIGhhemFyZEhhbGZIZWlnaHQgKyBwLnldO1xuICAgICAgY29uc3QgdjMgPSBbaGF6YXJkSGFsZldpZHRoICsgcC54LCAtaGF6YXJkSGFsZkhlaWdodCArIHAueV07XG4gICAgICBjb25zdCB2NCA9IFstaGF6YXJkSGFsZldpZHRoICsgcC54LCAtaGF6YXJkSGFsZkhlaWdodCArIHAueV07XG5cbiAgICAgIHZlcnRpY2VzLnB1c2goXG4gICAgICAgIHYxWzBdLCB2MVsxXSwgMC43NSxcbiAgICAgICAgdjJbMF0sIHYyWzFdLCAwLjc1LFxuICAgICAgICB2M1swXSwgdjNbMV0sIDAuNzUsXG4gICAgICAgIHYzWzBdLCB2M1sxXSwgMC43NSxcbiAgICAgICAgdjRbMF0sIHY0WzFdLCAwLjc1LFxuICAgICAgICB2MVswXSwgdjFbMV0sIDAuNzVcbiAgICAgICk7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gQ29sbGlzaW9uIGRpbGF0aW9uIChkcmF3biBpbiBmcm9udCwgeiA9IDAuMjUpXG4gICAgY29uc3QgY29sbGlzaW9uSGFsZldpZHRoID0gdGhpcy5zaXplLncgKyBjb25maWcuY29sbGlzaW9uRGlsYXRpb25TO1xuICAgIGNvbnN0IGNvbGxpc2lvbkhhbGZIZWlnaHQgPSB0aGlzLnNpemUuaCArIGNvbmZpZy5jb2xsaXNpb25EaWxhdGlvbkw7XG5cbiAgICBwb3NpdGlvbnMuZm9yRWFjaChwID0+IHtcbiAgICAgIGNvbnN0IHYxID0gWy1jb2xsaXNpb25IYWxmV2lkdGggKyBwLngsIGNvbGxpc2lvbkhhbGZIZWlnaHQgKyBwLnldO1xuICAgICAgY29uc3QgdjIgPSBbY29sbGlzaW9uSGFsZldpZHRoICsgcC54LCBjb2xsaXNpb25IYWxmSGVpZ2h0ICsgcC55XTtcbiAgICAgIGNvbnN0IHYzID0gW2NvbGxpc2lvbkhhbGZXaWR0aCArIHAueCwgLWNvbGxpc2lvbkhhbGZIZWlnaHQgKyBwLnldO1xuICAgICAgY29uc3QgdjQgPSBbLWNvbGxpc2lvbkhhbGZXaWR0aCArIHAueCwgLWNvbGxpc2lvbkhhbGZIZWlnaHQgKyBwLnldO1xuXG4gICAgICB2ZXJ0aWNlcy5wdXNoKFxuICAgICAgICB2MVswXSwgdjFbMV0sIDAuMjUsXG4gICAgICAgIHYyWzBdLCB2MlsxXSwgMC4yNSxcbiAgICAgICAgdjNbMF0sIHYzWzFdLCAwLjI1LFxuICAgICAgICB2M1swXSwgdjNbMV0sIDAuMjUsXG4gICAgICAgIHY0WzBdLCB2NFsxXSwgMC4yNSxcbiAgICAgICAgdjFbMF0sIHYxWzFdLCAwLjI1XG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHZlcnRpY2VzO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return GPGPU; });\n/* Partially adapted from https://github.com/turbo/js/blob/master/turbo.js\n *\n * Turbo.js License:\n * Copyright (c) 2016 minxomat\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nconst vertexShaderCode = `#version 300 es\nin vec2 position;\nin vec2 texture;\nout vec2 kernelPosition;\n\nvoid main(void) {\n  kernelPosition = texture;\n  gl_Position = vec4(position.xy, 0.0, 1.0);\n}\n`;\n\nconst fragmentShaderHeader = `#version 300 es\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp sampler2DArray;\nprecision highp sampler3D;\nprecision highp samplerCube;\n\nin vec2 kernelPosition;\nout vec4 kernelOut;\nuniform ivec2 kernelSize;\n`;\n\nclass GPGPU {\n  static alloc(size, stride) {\n    if (!Number.isInteger(stride) || stride < 1 || stride > 4)\n      throw new Error(\"Data stride must be an integer between 1 and 4.\");\n\n    // Find the smallest perfect square greater than or equal to size\n    const squareSize = Math.pow(Math.ceil(Math.sqrt(size)), 2);\n\n    const data = new Float32Array(squareSize * stride);\n    data.gpgpuSize = size;\n    data.gpgpuStride = stride;\n    return data;\n  }\n\n  constructor(configs, shared = {}) {\n    this._setUpGL();\n\n    this.outputTextures = {};\n    this.sharedTextures = {};\n\n    this.programs = configs.map(c => this._prepareProgram(c));\n\n    for (const name in shared) {\n      const options = shared[name];\n      const { width, height, channels, data } = options;\n      this.sharedTextures[name] = this._createTexture(data, width, height, channels, options);\n    }\n  }\n\n  updateSharedTextures(shared) {\n    this.sharedTextures = {};\n\n    for (const name in shared) {\n      const options = shared[name];\n      const { width, height, channels, data } = options;\n      if (this.sharedTextures[name]) this.gl.deleteTexture(this.sharedTextures[name]);\n      this.sharedTextures[name] = this._createTexture(data, width, height, channels, options);\n    }\n  }\n\n  updateProgram(programOrProgramIndex, config) {\n    const program = typeof(programOrProgramIndex) == 'number' ? this.programs[programOrProgramIndex] : programOrProgramIndex;\n\n    if (!program)\n      throw new Error(`Program with index ${programOrProgramIndex} does not exist.`);\n\n    if (config.inputs)\n      throw new Error('The `updateProgram` function cannot be used to update inputs. Use `updateProgramInputs` instead.');\n\n    if (config.meta)\n      program.meta = Object.assign(program.meta, config.meta);\n\n    if (config.width !== undefined && config.height !== undefined)\n      this.updateProgramSize(program, config.width, config.height);\n\n    if (typeof(config.uniforms) == 'object')\n      this.updateProgramUniforms(program, config.uniforms);\n  }\n\n  updateProgramInputs(programIndex, inputs) {\n    const program = this.programs[programIndex];\n\n    if (!program)\n      throw new Error(`Program with index ${programIndex} does not exist.`);\n\n    if (program.inputTextures.length != inputs.length)\n      throw new Error(`You must provide the same number of inputs as when the program was set up: got ${inputs.length} but expected ${program.inputTextures.length}.`);\n\n    const previousInputWidth = program.inputWidth;\n    const previousInputHeight = program.inputHeight;\n\n    const config = program.config;\n\n    if (config.width === undefined || config.height === undefined) {\n      program.inputWidth = undefined;\n      program.inputHeight = undefined;\n      program.inputDataSize = undefined;\n    }\n\n    this._prepareProgramInputs(program, inputs);\n\n    if (program.inputWidth != previousInputWidth || program.inputHeight != previousInputHeight) {\n      this.gl.useProgram(program.glProgram);\n      this.gl.uniform2i(program.kernelSizeLocation, program.inputWidth, program.inputHeight);\n      this._prepareProgramOutput(program);\n    }\n  }\n\n  updateProgramSize(programOrProgramIndex, width, height) {\n    const program = typeof(programOrProgramIndex) == 'number' ? this.programs[programOrProgramIndex] : programOrProgramIndex;\n\n    if (!program)\n      throw new Error(`Program with index ${programOrProgramIndex} does not exist.`);\n\n    if (program.inputTextures.length != 0)\n      throw new Error(`Size can only be updated on programs with no inputs.`);\n\n    if (width == program.inputWidth && height == program.inputHeight) return;\n\n    program.inputWidth = width;\n    program.inputHeight = height;\n    program.inputDataSize = width * height;\n\n    this.gl.useProgram(program.glProgram);\n    this.gl.uniform2i(program.kernelSizeLocation, program.inputWidth, program.inputHeight);\n    this._prepareProgramOutput(program);\n  }\n\n  updateProgramUniforms(programOrProgramIndex, uniforms) {\n    const program = typeof(programOrProgramIndex) == 'number' ? this.programs[programOrProgramIndex] : programOrProgramIndex;\n    this.gl.useProgram(program.glProgram);\n\n    if (!program)\n      throw new Error(`Program with index ${programOrProgramIndex} does not exist.`);\n\n    for (const uniformName in uniforms) {\n      const value = uniforms[uniformName];\n      let uniform;\n\n      if (uniform = program.uniforms[uniformName]) {\n        this._setUniform(uniform.type, uniform.location, value)\n      } else if (uniform = program.uniformTextures[uniformName]) {\n        if (typeof(value) != 'object' || value.type != 'texture')\n          throw new Error(`Expected texture type for uniform ${uniformName}.`);\n\n        const { width, height, channels, data } = uniform;\n        if (program.uniformTextures[uniformName].texture) this.gl.deleteTexture(program.uniformTextures[uniformName].texture);\n        program.uniformTextures[uniformName].texture = this._createTexture(data, width, height, channels, uniform);\n      } else {\n        throw new Error(`The uniform ${uniformName} does not exist in this program.`);\n      }\n    }\n  }\n\n  run() {\n    const outputs = [];\n\n    for (const program of this.programs) {\n      this.gl.useProgram(program.glProgram);\n      this.gl.viewport(0, 0, program.inputWidth, program.inputHeight);\n      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, program.frameBuffer);\n\n      for (const [index, inputTexture] of program.inputTextures.entries()) {\n        this.gl.activeTexture(this.gl.TEXTURE0 + index);\n        this.gl.bindTexture(this.gl.TEXTURE_2D, inputTexture);\n      }\n\n      for (const uniformName in program.uniformTextures) {\n        const uniformTexture = program.uniformTextures[uniformName];\n        this.gl.activeTexture(this.gl.TEXTURE0 + uniformTexture.index);\n        this.gl.bindTexture(uniformTexture.target, uniformTexture.texture || this.sharedTextures[uniformTexture.name] || this.outputTextures[uniformTexture.name]);\n      }\n\n      if (typeof(program.draw) == 'function') {\n        program.draw(this, program);\n      } else {\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.textureBuffer);\n        this.gl.enableVertexAttribArray(program.textureLocation);\n        this.gl.vertexAttribPointer(program.textureLocation, 2, this.gl.FLOAT, false, 0, 0);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);\n        this.gl.enableVertexAttribArray(program.positionLocation);\n        this.gl.vertexAttribPointer(program.positionLocation, 2, this.gl.FLOAT, false, 0, 0);\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n        if (program.drawProxy) {\n          const draw = (() => this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_SHORT, 0)).bind(this);\n          program.drawProxy(this, program, draw);\n        } else {\n          this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_SHORT, 0);\n        }\n      }\n\n      if (program.output && program.output.name && !program.output.read) {\n        outputs.push(null);\n      } else {\n        const output = new Float32Array(program.inputWidth * program.inputHeight * 4);\n        this.gl.readPixels(0, 0, program.inputWidth, program.inputHeight, this.gl.RGBA, this.gl.FLOAT, output);\n        outputs.push(output.subarray(0, program.inputDataSize * 4));\n      }\n    }\n\n    return outputs;\n  }\n\n  _setUpGL() {\n    let canvas;\n\n    if (self.document)\n      canvas = document.createElement('canvas');\n    else if (self.OffscreenCanvas)\n      canvas = new OffscreenCanvas(0, 0);\n    else\n      throw new Error('Could not create a canvas.');\n\n    const attr = { alpha: false, antialias: false };\n    this.gl = canvas.getContext(\"webgl2\", attr) || canvas.getContext(\"experimental-webgl2\", attr);\n\n    if (!this.gl)\n      throw new Error(\"Unable to initialize WebGL2. Your browser may not support it.\");\n\n    if (!this.gl.getExtension('EXT_color_buffer_float'))\n      throw new Error('Required WebGL extension EXT_color_buffer_float not supported.');\n\n    if (!this.gl.getExtension('OES_texture_float_linear'))\n      throw new Error('Required WebGL extension OES_texture_float_linear not supported.');\n\n    this.positionBuffer = this._newBuffer([-1, -1, 1, -1, 1, 1, -1, 1]);\n    this.textureBuffer = this._newBuffer([0, 0, 1, 0, 1, 1, 0, 1]);\n    this.indexBuffer = this._newBuffer([1, 2, 0, 3, 0, 2], Uint16Array, this.gl.ELEMENT_ARRAY_BUFFER);\n  }\n\n  _prepareProgram(config) {\n    const program = { config };\n\n    program.draw = config.draw;\n    program.drawProxy = config.drawProxy;\n    program.meta = Object.assign({}, config.meta);\n\n    if (config.width && config.height) {\n      program.inputWidth = config.width;\n      program.inputHeight = config.height;\n      program.inputDataSize = config.width * config.height;\n    }\n\n    program.output = config.output;\n\n    const kernel = config.kernel;\n\n    if (typeof(kernel) != 'string' || kernel.length == 0)\n      throw new Error(\"Kernel code cannot be empty.\");\n\n    const inputs = config.inputs || [];\n    const uniforms = config.uniforms || {};\n\n    this._prepareProgramInputs(program, inputs);\n\n    let fragmentShaderConfig = \"\";\n    \n    for (const index in inputs)\n      fragmentShaderConfig += `uniform sampler2D _input${index};\\n`;\n\n    if (program.inputWidth === undefined || program.inputHeight === undefined)\n      throw new Error(\"Unknown kernel size. You must provide either an input or the `width` and `height` parameters in the kernel config.\");\n\n    program.uniformTextures = {};\n    program.uniforms = {};\n\n    for (const uniformName in uniforms) {\n      const uniform = uniforms[uniformName];\n\n      if (typeof(uniform) == 'number') {\n        program.uniforms[uniformName] = {\n          type: 'float',\n          value: uniform\n        };\n        fragmentShaderConfig += `uniform float ${uniformName};\\n`;\n      } else if (Array.isArray(uniform)) {\n        if (uniform.length < 2 || uniform.length > 4)\n          throw new Error(`Array uniforms can only have lengths of 2, 3, or 4 elements (corresponding to vec2, vec3, and vec4).`);\n\n        const type = ['vec2', 'vec3', 'vec4'][uniform.length - 2];\n        program.uniforms[uniformName] = {\n          type: type,\n          value: uniform\n        };\n        fragmentShaderConfig += `uniform ${type} ${uniformName};\\n`;\n      } else {\n        const { type, width, height, channels, data, value, length, name } = uniform;\n\n        if (type == 'texture' || type == 'outputTexture' || type == 'sharedTexture') {\n          let target, type;\n\n          if (uniform.textureType == '3D') {\n            target = this.gl.TEXTURE_3D;\n            type = 'sampler3D';\n          } else if (uniform.textureType == '2DArray') {\n            target = this.gl.TEXTURE_2D_ARRAY;\n            type = 'sampler2DArray';\n          } else {\n            target = this.gl.TEXTURE_2D;\n            type = 'sampler2D';\n          }\n\n          if (type == 'texture') {\n            program.uniformTextures[uniformName] = { target, texture: data ? this._createTexture(data, width, height, channels, uniform) : null };\n          } else {\n            program.uniformTextures[uniformName] = { target, texture: null, name: name || uniformName };\n          }\n\n          fragmentShaderConfig += `uniform ${type} ${uniformName};\\n`;\n        } else {\n          program.uniforms[uniformName] = { type, value };\n          if (length !== undefined)\n            fragmentShaderConfig += `uniform ${type} ${uniformName}[${length}];\\n`;\n          else\n            fragmentShaderConfig += `uniform ${type} ${uniformName};\\n`;\n        }\n      }\n    }\n\n    const vertexShader = this.gl.createShader(this.gl.VERTEX_SHADER);\n    this.gl.shaderSource(vertexShader, config.vertexShader || vertexShaderCode);\n    this.gl.compileShader(vertexShader);\n\n    if (!this.gl.getShaderParameter(vertexShader, this.gl.COMPILE_STATUS)) {\n      throw new Error(\n        \"Could not build vertex shader (fatal).\\n\" + \"\\n\" +\n        \"--- CODE DUMP ---\\n\" + (config.vertexShader || vertexShaderCode) + \"\\n\\n\" +\n        \"--- ERROR LOG ---\\n\" + this.gl.getShaderInfoLog(vertexShader)\n      );\n    }\n\n    const fragmentShaderMain = `\nvoid main() {\n  kernelOut = vec4(kernel(${[...Array(inputs.length).keys()].map(i => `texture(_input${i}, kernelPosition)`).join(', ')}));\n}\n    `;\n\n    const fragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);\n    const fragmentShaderSource = fragmentShaderHeader + fragmentShaderConfig + kernel + fragmentShaderMain;\n    this.gl.shaderSource(fragmentShader, fragmentShaderSource);\n    this.gl.compileShader(fragmentShader);\n\n    if (!this.gl.getShaderParameter(fragmentShader, this.gl.COMPILE_STATUS)) {\n      const source = fragmentShaderSource.split('\\n');\n      let dbgMsg = \"ERROR: Could not build shader (fatal).\\n\\n------------------ KERNEL CODE DUMP ------------------\\n\"\n\n      for (let l = 0; l < source.length; l++)\n        dbgMsg += `${l + 1}> ${source[l]}\\n`;\n\n      dbgMsg += \"\\n--------------------- ERROR  LOG ---------------------\\n\" + this.gl.getShaderInfoLog(fragmentShader);\n\n      throw new Error(dbgMsg);\n    }\n\n    program.glProgram = this.gl.createProgram();\n    this.gl.attachShader(program.glProgram, vertexShader);\n    this.gl.attachShader(program.glProgram, fragmentShader);\n    this.gl.linkProgram(program.glProgram);\n    this.gl.useProgram(program.glProgram);\n\n    if (!this.gl.getProgramParameter(program.glProgram, this.gl.LINK_STATUS))\n      throw new Error('Failed to link GLSL program code.');\n\n    let textureIndex = 0;\n\n    for (const input of program.inputTextures) {\n      const location = this.gl.getUniformLocation(program.glProgram, `_input${textureIndex}`);\n      this.gl.uniform1i(location, textureIndex);\n      textureIndex++;\n    }\n\n    for (const uniformName in program.uniformTextures) {\n      program.uniformTextures[uniformName].index = textureIndex;\n      const location = this.gl.getUniformLocation(program.glProgram, uniformName);\n      this.gl.uniform1i(location, textureIndex);\n      textureIndex++;\n    }\n\n    for (const uniformName in program.uniforms) {\n      const { type, value } = program.uniforms[uniformName];\n      const location = program.uniforms[uniformName].location = this.gl.getUniformLocation(program.glProgram, uniformName);\n\n      if (value !== undefined)\n        this._setUniform(type, location, value);\n\n      delete program.uniforms[uniformName].value;\n    }\n\n    program.kernelSizeLocation = this.gl.getUniformLocation(program.glProgram, 'kernelSize');\n    this.gl.uniform2i(program.kernelSizeLocation, program.inputWidth, program.inputHeight);\n\n    program.positionLocation = this.gl.getAttribLocation(program.glProgram, 'position');\n    program.textureLocation = this.gl.getAttribLocation(program.glProgram, 'texture');\n\n    program.frameBuffer = this.gl.createFramebuffer();\n    this._prepareProgramOutput(program);\n\n    return program;\n  }\n\n  _prepareProgramInputs(program, inputs) {\n    if (program.inputTextures)\n      program.inputTextures.forEach(t => this.gl.deleteTexture(t));\n\n    program.inputTextures = [];\n\n    for (const [index, data] of inputs.entries()) {\n      if (data.gpgpuSize === undefined || data.gpgpuStride === undefined)\n        throw new Error('GPGPU inputs must be created by the `alloc` function.');\n\n      const size = Math.sqrt(data.length / data.gpgpuStride);\n      if (size <= 0 || size % 1 != 0)\n        throw new Error('GPGPU input size is expected to be a perfect square.');\n\n      if (program.inputWidth === undefined || program.inputHeight === undefined) {\n        program.inputWidth = size;\n        program.inputHeight = size;\n        program.inputDataSize = data.gpgpuSize;\n      } else if (size != program.inputWidth || size != program.inputHeight) {\n        throw new Error(`All GPGPU inputs must be of the same size. Received ${data.gpgpuSize} (internal ${size * size}) but expected ${program.inputDataSize} (internal ${program.inputWidth * program.inputHeight}).`);\n      }\n\n      program.inputTextures.push(this._createTexture(data, size, size, data.gpgpuStride));\n    }\n  }\n\n  _prepareProgramOutput(program) {\n    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, program.frameBuffer);\n\n    const outputTexture = this._createTexture(null, program.inputWidth, program.inputHeight, 4, program.output);\n\n    if (program.output && program.output.textureType !== '3D' && program.output.textureType !== '2DArray') {\n      this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, outputTexture, 0);\n      const frameBufferStatus = (this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER) == this.gl.FRAMEBUFFER_COMPLETE);\n      if (!frameBufferStatus)\n        throw new Error('Error attaching float texture to framebuffer. Your device is probably incompatible.');\n    }\n\n    if (program.outputTexture !== undefined)\n      this.gl.deleteTexture(program.outputTexture);\n    program.outputTexture = outputTexture;\n\n    if (program.output && program.output.name)\n      this.outputTextures[program.output.name] = outputTexture;\n  }\n\n  _setUniform(type, location, value) {\n    switch (type) {\n      case 'int': this.gl.uniform1i(location, value); break;\n      case 'float': Array.isArray(value) ? this.gl.uniform1fv(location, value) : this.gl.uniform1f(location, value); break;\n      case 'vec2': this.gl.uniform2fv(location, value); break;\n      case 'vec3': this.gl.uniform3fv(location, value); break;\n      case 'vec4': this.gl.uniform4fv(location, value); break;\n      case 'mat3': this.gl.uniformMatrix3fv(location, value); break;\n      default: throw new Error(`Unknown uniform type ${type}.`);\n    }\n  }\n\n  _newBuffer(data, klass, target) {\n    const buf = this.gl.createBuffer();\n\n    this.gl.bindBuffer((target || this.gl.ARRAY_BUFFER), buf);\n    this.gl.bufferData((target || this.gl.ARRAY_BUFFER), new (klass || Float32Array)(data), this.gl.STATIC_DRAW);\n\n    return buf;\n  }\n\n  _createTexture(data, width, height, channels, options = {}) {\n    const texture = this.gl.createTexture();\n\n    let internalFormat, format;\n\n    switch (channels) {\n      case 1:\n        internalFormat = this.gl.R32F;\n        format = this.gl.RED;\n        break;\n      case 2:\n        internalFormat = this.gl.RG32F;\n        format = this.gl.RG;\n        break;\n      case 3:\n        internalFormat = this.gl.RGB32F;\n        format = this.gl.RGB;\n        break;\n      case 4:\n        internalFormat = this.gl.RGBA32F;\n        format = this.gl.RGBA;\n        break;\n      default:\n        throw(\"Texture channels must between 1 and 4.\");\n    }\n\n    const target = options.textureType == '3D' ? this.gl.TEXTURE_3D : options.textureType == '2DArray' ? this.gl.TEXTURE_2D_ARRAY : this.gl.TEXTURE_2D;\n\n    this.gl.bindTexture(target, texture);\n    this.gl.texParameteri(target, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\n    this.gl.texParameteri(target, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\n    this.gl.texParameteri(target, this.gl.TEXTURE_WRAP_R, this.gl.CLAMP_TO_EDGE);\n    this.gl.texParameteri(target, this.gl.TEXTURE_MIN_FILTER, options.filter == 'linear' ? this.gl.LINEAR : this.gl.NEAREST);\n    this.gl.texParameteri(target, this.gl.TEXTURE_MAG_FILTER, options.filter == 'linear' ? this.gl.LINEAR : this.gl.NEAREST);\n\n    if (options.textureType == '3D' || options.textureType == '2DArray') {\n      this.gl.texImage3D(target, 0, internalFormat, width, height, options.depth, 0, format, this.gl.FLOAT, data);\n    } else {\n      this.gl.texImage2D(target, 0, internalFormat, width, height, 0, format, this.gl.FLOAT, data);\n    }\n\n    this.gl.bindTexture(target, null);\n\n    return texture;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9HUEdQVS5qcz80NDJhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxnQ0FBZ0M7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsc0JBQXNCOztBQUVsRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxhQUFhOztBQUV6RDtBQUNBLHdHQUF3RyxjQUFjLGdCQUFnQiw2QkFBNkI7O0FBRW5LO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxzQkFBc0I7O0FBRWxFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxzQkFBc0I7O0FBRWxFO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUM1RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDREQUE0RDtBQUM1RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBQYXJ0aWFsbHkgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS90dXJiby9qcy9ibG9iL21hc3Rlci90dXJiby5qc1xuICpcbiAqIFR1cmJvLmpzIExpY2Vuc2U6XG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgbWlueG9tYXRcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5cbmNvbnN0IHZlcnRleFNoYWRlckNvZGUgPSBgI3ZlcnNpb24gMzAwIGVzXG5pbiB2ZWMyIHBvc2l0aW9uO1xuaW4gdmVjMiB0ZXh0dXJlO1xub3V0IHZlYzIga2VybmVsUG9zaXRpb247XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIGtlcm5lbFBvc2l0aW9uID0gdGV4dHVyZTtcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLnh5LCAwLjAsIDEuMCk7XG59XG5gO1xuXG5jb25zdCBmcmFnbWVudFNoYWRlckhlYWRlciA9IGAjdmVyc2lvbiAzMDAgZXNcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcbnByZWNpc2lvbiBoaWdocCBpbnQ7XG5wcmVjaXNpb24gaGlnaHAgc2FtcGxlcjJEO1xucHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIyREFycmF5O1xucHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIzRDtcbnByZWNpc2lvbiBoaWdocCBzYW1wbGVyQ3ViZTtcblxuaW4gdmVjMiBrZXJuZWxQb3NpdGlvbjtcbm91dCB2ZWM0IGtlcm5lbE91dDtcbnVuaWZvcm0gaXZlYzIga2VybmVsU2l6ZTtcbmA7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEdQR1BVIHtcbiAgc3RhdGljIGFsbG9jKHNpemUsIHN0cmlkZSkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihzdHJpZGUpIHx8IHN0cmlkZSA8IDEgfHwgc3RyaWRlID4gNClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgc3RyaWRlIG11c3QgYmUgYW4gaW50ZWdlciBiZXR3ZWVuIDEgYW5kIDQuXCIpO1xuXG4gICAgLy8gRmluZCB0aGUgc21hbGxlc3QgcGVyZmVjdCBzcXVhcmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHNpemVcbiAgICBjb25zdCBzcXVhcmVTaXplID0gTWF0aC5wb3coTWF0aC5jZWlsKE1hdGguc3FydChzaXplKSksIDIpO1xuXG4gICAgY29uc3QgZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoc3F1YXJlU2l6ZSAqIHN0cmlkZSk7XG4gICAgZGF0YS5ncGdwdVNpemUgPSBzaXplO1xuICAgIGRhdGEuZ3BncHVTdHJpZGUgPSBzdHJpZGU7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihjb25maWdzLCBzaGFyZWQgPSB7fSkge1xuICAgIHRoaXMuX3NldFVwR0woKTtcblxuICAgIHRoaXMub3V0cHV0VGV4dHVyZXMgPSB7fTtcbiAgICB0aGlzLnNoYXJlZFRleHR1cmVzID0ge307XG5cbiAgICB0aGlzLnByb2dyYW1zID0gY29uZmlncy5tYXAoYyA9PiB0aGlzLl9wcmVwYXJlUHJvZ3JhbShjKSk7XG5cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gc2hhcmVkKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gc2hhcmVkW25hbWVdO1xuICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBjaGFubmVscywgZGF0YSB9ID0gb3B0aW9ucztcbiAgICAgIHRoaXMuc2hhcmVkVGV4dHVyZXNbbmFtZV0gPSB0aGlzLl9jcmVhdGVUZXh0dXJlKGRhdGEsIHdpZHRoLCBoZWlnaHQsIGNoYW5uZWxzLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVTaGFyZWRUZXh0dXJlcyhzaGFyZWQpIHtcbiAgICB0aGlzLnNoYXJlZFRleHR1cmVzID0ge307XG5cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gc2hhcmVkKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gc2hhcmVkW25hbWVdO1xuICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBjaGFubmVscywgZGF0YSB9ID0gb3B0aW9ucztcbiAgICAgIGlmICh0aGlzLnNoYXJlZFRleHR1cmVzW25hbWVdKSB0aGlzLmdsLmRlbGV0ZVRleHR1cmUodGhpcy5zaGFyZWRUZXh0dXJlc1tuYW1lXSk7XG4gICAgICB0aGlzLnNoYXJlZFRleHR1cmVzW25hbWVdID0gdGhpcy5fY3JlYXRlVGV4dHVyZShkYXRhLCB3aWR0aCwgaGVpZ2h0LCBjaGFubmVscywgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlUHJvZ3JhbShwcm9ncmFtT3JQcm9ncmFtSW5kZXgsIGNvbmZpZykge1xuICAgIGNvbnN0IHByb2dyYW0gPSB0eXBlb2YocHJvZ3JhbU9yUHJvZ3JhbUluZGV4KSA9PSAnbnVtYmVyJyA/IHRoaXMucHJvZ3JhbXNbcHJvZ3JhbU9yUHJvZ3JhbUluZGV4XSA6IHByb2dyYW1PclByb2dyYW1JbmRleDtcblxuICAgIGlmICghcHJvZ3JhbSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvZ3JhbSB3aXRoIGluZGV4ICR7cHJvZ3JhbU9yUHJvZ3JhbUluZGV4fSBkb2VzIG5vdCBleGlzdC5gKTtcblxuICAgIGlmIChjb25maWcuaW5wdXRzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYHVwZGF0ZVByb2dyYW1gIGZ1bmN0aW9uIGNhbm5vdCBiZSB1c2VkIHRvIHVwZGF0ZSBpbnB1dHMuIFVzZSBgdXBkYXRlUHJvZ3JhbUlucHV0c2AgaW5zdGVhZC4nKTtcblxuICAgIGlmIChjb25maWcubWV0YSlcbiAgICAgIHByb2dyYW0ubWV0YSA9IE9iamVjdC5hc3NpZ24ocHJvZ3JhbS5tZXRhLCBjb25maWcubWV0YSk7XG5cbiAgICBpZiAoY29uZmlnLndpZHRoICE9PSB1bmRlZmluZWQgJiYgY29uZmlnLmhlaWdodCAhPT0gdW5kZWZpbmVkKVxuICAgICAgdGhpcy51cGRhdGVQcm9ncmFtU2l6ZShwcm9ncmFtLCBjb25maWcud2lkdGgsIGNvbmZpZy5oZWlnaHQpO1xuXG4gICAgaWYgKHR5cGVvZihjb25maWcudW5pZm9ybXMpID09ICdvYmplY3QnKVxuICAgICAgdGhpcy51cGRhdGVQcm9ncmFtVW5pZm9ybXMocHJvZ3JhbSwgY29uZmlnLnVuaWZvcm1zKTtcbiAgfVxuXG4gIHVwZGF0ZVByb2dyYW1JbnB1dHMocHJvZ3JhbUluZGV4LCBpbnB1dHMpIHtcbiAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5wcm9ncmFtc1twcm9ncmFtSW5kZXhdO1xuXG4gICAgaWYgKCFwcm9ncmFtKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9ncmFtIHdpdGggaW5kZXggJHtwcm9ncmFtSW5kZXh9IGRvZXMgbm90IGV4aXN0LmApO1xuXG4gICAgaWYgKHByb2dyYW0uaW5wdXRUZXh0dXJlcy5sZW5ndGggIT0gaW5wdXRzLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IG11c3QgcHJvdmlkZSB0aGUgc2FtZSBudW1iZXIgb2YgaW5wdXRzIGFzIHdoZW4gdGhlIHByb2dyYW0gd2FzIHNldCB1cDogZ290ICR7aW5wdXRzLmxlbmd0aH0gYnV0IGV4cGVjdGVkICR7cHJvZ3JhbS5pbnB1dFRleHR1cmVzLmxlbmd0aH0uYCk7XG5cbiAgICBjb25zdCBwcmV2aW91c0lucHV0V2lkdGggPSBwcm9ncmFtLmlucHV0V2lkdGg7XG4gICAgY29uc3QgcHJldmlvdXNJbnB1dEhlaWdodCA9IHByb2dyYW0uaW5wdXRIZWlnaHQ7XG5cbiAgICBjb25zdCBjb25maWcgPSBwcm9ncmFtLmNvbmZpZztcblxuICAgIGlmIChjb25maWcud2lkdGggPT09IHVuZGVmaW5lZCB8fCBjb25maWcuaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHByb2dyYW0uaW5wdXRXaWR0aCA9IHVuZGVmaW5lZDtcbiAgICAgIHByb2dyYW0uaW5wdXRIZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICBwcm9ncmFtLmlucHV0RGF0YVNpemUgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJlcGFyZVByb2dyYW1JbnB1dHMocHJvZ3JhbSwgaW5wdXRzKTtcblxuICAgIGlmIChwcm9ncmFtLmlucHV0V2lkdGggIT0gcHJldmlvdXNJbnB1dFdpZHRoIHx8IHByb2dyYW0uaW5wdXRIZWlnaHQgIT0gcHJldmlvdXNJbnB1dEhlaWdodCkge1xuICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKHByb2dyYW0uZ2xQcm9ncmFtKTtcbiAgICAgIHRoaXMuZ2wudW5pZm9ybTJpKHByb2dyYW0ua2VybmVsU2l6ZUxvY2F0aW9uLCBwcm9ncmFtLmlucHV0V2lkdGgsIHByb2dyYW0uaW5wdXRIZWlnaHQpO1xuICAgICAgdGhpcy5fcHJlcGFyZVByb2dyYW1PdXRwdXQocHJvZ3JhbSk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlUHJvZ3JhbVNpemUocHJvZ3JhbU9yUHJvZ3JhbUluZGV4LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IHR5cGVvZihwcm9ncmFtT3JQcm9ncmFtSW5kZXgpID09ICdudW1iZXInID8gdGhpcy5wcm9ncmFtc1twcm9ncmFtT3JQcm9ncmFtSW5kZXhdIDogcHJvZ3JhbU9yUHJvZ3JhbUluZGV4O1xuXG4gICAgaWYgKCFwcm9ncmFtKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9ncmFtIHdpdGggaW5kZXggJHtwcm9ncmFtT3JQcm9ncmFtSW5kZXh9IGRvZXMgbm90IGV4aXN0LmApO1xuXG4gICAgaWYgKHByb2dyYW0uaW5wdXRUZXh0dXJlcy5sZW5ndGggIT0gMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU2l6ZSBjYW4gb25seSBiZSB1cGRhdGVkIG9uIHByb2dyYW1zIHdpdGggbm8gaW5wdXRzLmApO1xuXG4gICAgaWYgKHdpZHRoID09IHByb2dyYW0uaW5wdXRXaWR0aCAmJiBoZWlnaHQgPT0gcHJvZ3JhbS5pbnB1dEhlaWdodCkgcmV0dXJuO1xuXG4gICAgcHJvZ3JhbS5pbnB1dFdpZHRoID0gd2lkdGg7XG4gICAgcHJvZ3JhbS5pbnB1dEhlaWdodCA9IGhlaWdodDtcbiAgICBwcm9ncmFtLmlucHV0RGF0YVNpemUgPSB3aWR0aCAqIGhlaWdodDtcblxuICAgIHRoaXMuZ2wudXNlUHJvZ3JhbShwcm9ncmFtLmdsUHJvZ3JhbSk7XG4gICAgdGhpcy5nbC51bmlmb3JtMmkocHJvZ3JhbS5rZXJuZWxTaXplTG9jYXRpb24sIHByb2dyYW0uaW5wdXRXaWR0aCwgcHJvZ3JhbS5pbnB1dEhlaWdodCk7XG4gICAgdGhpcy5fcHJlcGFyZVByb2dyYW1PdXRwdXQocHJvZ3JhbSk7XG4gIH1cblxuICB1cGRhdGVQcm9ncmFtVW5pZm9ybXMocHJvZ3JhbU9yUHJvZ3JhbUluZGV4LCB1bmlmb3Jtcykge1xuICAgIGNvbnN0IHByb2dyYW0gPSB0eXBlb2YocHJvZ3JhbU9yUHJvZ3JhbUluZGV4KSA9PSAnbnVtYmVyJyA/IHRoaXMucHJvZ3JhbXNbcHJvZ3JhbU9yUHJvZ3JhbUluZGV4XSA6IHByb2dyYW1PclByb2dyYW1JbmRleDtcbiAgICB0aGlzLmdsLnVzZVByb2dyYW0ocHJvZ3JhbS5nbFByb2dyYW0pO1xuXG4gICAgaWYgKCFwcm9ncmFtKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQcm9ncmFtIHdpdGggaW5kZXggJHtwcm9ncmFtT3JQcm9ncmFtSW5kZXh9IGRvZXMgbm90IGV4aXN0LmApO1xuXG4gICAgZm9yIChjb25zdCB1bmlmb3JtTmFtZSBpbiB1bmlmb3Jtcykge1xuICAgICAgY29uc3QgdmFsdWUgPSB1bmlmb3Jtc1t1bmlmb3JtTmFtZV07XG4gICAgICBsZXQgdW5pZm9ybTtcblxuICAgICAgaWYgKHVuaWZvcm0gPSBwcm9ncmFtLnVuaWZvcm1zW3VuaWZvcm1OYW1lXSkge1xuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKHVuaWZvcm0udHlwZSwgdW5pZm9ybS5sb2NhdGlvbiwgdmFsdWUpXG4gICAgICB9IGVsc2UgaWYgKHVuaWZvcm0gPSBwcm9ncmFtLnVuaWZvcm1UZXh0dXJlc1t1bmlmb3JtTmFtZV0pIHtcbiAgICAgICAgaWYgKHR5cGVvZih2YWx1ZSkgIT0gJ29iamVjdCcgfHwgdmFsdWUudHlwZSAhPSAndGV4dHVyZScpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCB0ZXh0dXJlIHR5cGUgZm9yIHVuaWZvcm0gJHt1bmlmb3JtTmFtZX0uYCk7XG5cbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBjaGFubmVscywgZGF0YSB9ID0gdW5pZm9ybTtcbiAgICAgICAgaWYgKHByb2dyYW0udW5pZm9ybVRleHR1cmVzW3VuaWZvcm1OYW1lXS50ZXh0dXJlKSB0aGlzLmdsLmRlbGV0ZVRleHR1cmUocHJvZ3JhbS51bmlmb3JtVGV4dHVyZXNbdW5pZm9ybU5hbWVdLnRleHR1cmUpO1xuICAgICAgICBwcm9ncmFtLnVuaWZvcm1UZXh0dXJlc1t1bmlmb3JtTmFtZV0udGV4dHVyZSA9IHRoaXMuX2NyZWF0ZVRleHR1cmUoZGF0YSwgd2lkdGgsIGhlaWdodCwgY2hhbm5lbHMsIHVuaWZvcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgdW5pZm9ybSAke3VuaWZvcm1OYW1lfSBkb2VzIG5vdCBleGlzdCBpbiB0aGlzIHByb2dyYW0uYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcnVuKCkge1xuICAgIGNvbnN0IG91dHB1dHMgPSBbXTtcblxuICAgIGZvciAoY29uc3QgcHJvZ3JhbSBvZiB0aGlzLnByb2dyYW1zKSB7XG4gICAgICB0aGlzLmdsLnVzZVByb2dyYW0ocHJvZ3JhbS5nbFByb2dyYW0pO1xuICAgICAgdGhpcy5nbC52aWV3cG9ydCgwLCAwLCBwcm9ncmFtLmlucHV0V2lkdGgsIHByb2dyYW0uaW5wdXRIZWlnaHQpO1xuICAgICAgdGhpcy5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5nbC5GUkFNRUJVRkZFUiwgcHJvZ3JhbS5mcmFtZUJ1ZmZlcik7XG5cbiAgICAgIGZvciAoY29uc3QgW2luZGV4LCBpbnB1dFRleHR1cmVdIG9mIHByb2dyYW0uaW5wdXRUZXh0dXJlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgdGhpcy5nbC5hY3RpdmVUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRTAgKyBpbmRleCk7XG4gICAgICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCBpbnB1dFRleHR1cmUpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IHVuaWZvcm1OYW1lIGluIHByb2dyYW0udW5pZm9ybVRleHR1cmVzKSB7XG4gICAgICAgIGNvbnN0IHVuaWZvcm1UZXh0dXJlID0gcHJvZ3JhbS51bmlmb3JtVGV4dHVyZXNbdW5pZm9ybU5hbWVdO1xuICAgICAgICB0aGlzLmdsLmFjdGl2ZVRleHR1cmUodGhpcy5nbC5URVhUVVJFMCArIHVuaWZvcm1UZXh0dXJlLmluZGV4KTtcbiAgICAgICAgdGhpcy5nbC5iaW5kVGV4dHVyZSh1bmlmb3JtVGV4dHVyZS50YXJnZXQsIHVuaWZvcm1UZXh0dXJlLnRleHR1cmUgfHwgdGhpcy5zaGFyZWRUZXh0dXJlc1t1bmlmb3JtVGV4dHVyZS5uYW1lXSB8fCB0aGlzLm91dHB1dFRleHR1cmVzW3VuaWZvcm1UZXh0dXJlLm5hbWVdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZihwcm9ncmFtLmRyYXcpID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvZ3JhbS5kcmF3KHRoaXMsIHByb2dyYW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLnRleHR1cmVCdWZmZXIpO1xuICAgICAgICB0aGlzLmdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHByb2dyYW0udGV4dHVyZUxvY2F0aW9uKTtcbiAgICAgICAgdGhpcy5nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHByb2dyYW0udGV4dHVyZUxvY2F0aW9uLCAyLCB0aGlzLmdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgdGhpcy5wb3NpdGlvbkJ1ZmZlcik7XG4gICAgICAgIHRoaXMuZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocHJvZ3JhbS5wb3NpdGlvbkxvY2F0aW9uKTtcbiAgICAgICAgdGhpcy5nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHByb2dyYW0ucG9zaXRpb25Mb2NhdGlvbiwgMiwgdGhpcy5nbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgICAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgdGhpcy5pbmRleEJ1ZmZlcik7XG5cbiAgICAgICAgaWYgKHByb2dyYW0uZHJhd1Byb3h5KSB7XG4gICAgICAgICAgY29uc3QgZHJhdyA9ICgoKSA9PiB0aGlzLmdsLmRyYXdFbGVtZW50cyh0aGlzLmdsLlRSSUFOR0xFUywgNiwgdGhpcy5nbC5VTlNJR05FRF9TSE9SVCwgMCkpLmJpbmQodGhpcyk7XG4gICAgICAgICAgcHJvZ3JhbS5kcmF3UHJveHkodGhpcywgcHJvZ3JhbSwgZHJhdyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5nbC5kcmF3RWxlbWVudHModGhpcy5nbC5UUklBTkdMRVMsIDYsIHRoaXMuZ2wuVU5TSUdORURfU0hPUlQsIDApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9ncmFtLm91dHB1dCAmJiBwcm9ncmFtLm91dHB1dC5uYW1lICYmICFwcm9ncmFtLm91dHB1dC5yZWFkKSB7XG4gICAgICAgIG91dHB1dHMucHVzaChudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IG5ldyBGbG9hdDMyQXJyYXkocHJvZ3JhbS5pbnB1dFdpZHRoICogcHJvZ3JhbS5pbnB1dEhlaWdodCAqIDQpO1xuICAgICAgICB0aGlzLmdsLnJlYWRQaXhlbHMoMCwgMCwgcHJvZ3JhbS5pbnB1dFdpZHRoLCBwcm9ncmFtLmlucHV0SGVpZ2h0LCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuRkxPQVQsIG91dHB1dCk7XG4gICAgICAgIG91dHB1dHMucHVzaChvdXRwdXQuc3ViYXJyYXkoMCwgcHJvZ3JhbS5pbnB1dERhdGFTaXplICogNCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXRzO1xuICB9XG5cbiAgX3NldFVwR0woKSB7XG4gICAgbGV0IGNhbnZhcztcblxuICAgIGlmIChzZWxmLmRvY3VtZW50KVxuICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgZWxzZSBpZiAoc2VsZi5PZmZzY3JlZW5DYW52YXMpXG4gICAgICBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKDAsIDApO1xuICAgIGVsc2VcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGNyZWF0ZSBhIGNhbnZhcy4nKTtcblxuICAgIGNvbnN0IGF0dHIgPSB7IGFscGhhOiBmYWxzZSwgYW50aWFsaWFzOiBmYWxzZSB9O1xuICAgIHRoaXMuZ2wgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsMlwiLCBhdHRyKSB8fCBjYW52YXMuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbDJcIiwgYXR0cik7XG5cbiAgICBpZiAoIXRoaXMuZ2wpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gaW5pdGlhbGl6ZSBXZWJHTDIuIFlvdXIgYnJvd3NlciBtYXkgbm90IHN1cHBvcnQgaXQuXCIpO1xuXG4gICAgaWYgKCF0aGlzLmdsLmdldEV4dGVuc2lvbignRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1aXJlZCBXZWJHTCBleHRlbnNpb24gRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCBub3Qgc3VwcG9ydGVkLicpO1xuXG4gICAgaWYgKCF0aGlzLmdsLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmVkIFdlYkdMIGV4dGVuc2lvbiBPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXIgbm90IHN1cHBvcnRlZC4nKTtcblxuICAgIHRoaXMucG9zaXRpb25CdWZmZXIgPSB0aGlzLl9uZXdCdWZmZXIoWy0xLCAtMSwgMSwgLTEsIDEsIDEsIC0xLCAxXSk7XG4gICAgdGhpcy50ZXh0dXJlQnVmZmVyID0gdGhpcy5fbmV3QnVmZmVyKFswLCAwLCAxLCAwLCAxLCAxLCAwLCAxXSk7XG4gICAgdGhpcy5pbmRleEJ1ZmZlciA9IHRoaXMuX25ld0J1ZmZlcihbMSwgMiwgMCwgMywgMCwgMl0sIFVpbnQxNkFycmF5LCB0aGlzLmdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSKTtcbiAgfVxuXG4gIF9wcmVwYXJlUHJvZ3JhbShjb25maWcpIHtcbiAgICBjb25zdCBwcm9ncmFtID0geyBjb25maWcgfTtcblxuICAgIHByb2dyYW0uZHJhdyA9IGNvbmZpZy5kcmF3O1xuICAgIHByb2dyYW0uZHJhd1Byb3h5ID0gY29uZmlnLmRyYXdQcm94eTtcbiAgICBwcm9ncmFtLm1ldGEgPSBPYmplY3QuYXNzaWduKHt9LCBjb25maWcubWV0YSk7XG5cbiAgICBpZiAoY29uZmlnLndpZHRoICYmIGNvbmZpZy5oZWlnaHQpIHtcbiAgICAgIHByb2dyYW0uaW5wdXRXaWR0aCA9IGNvbmZpZy53aWR0aDtcbiAgICAgIHByb2dyYW0uaW5wdXRIZWlnaHQgPSBjb25maWcuaGVpZ2h0O1xuICAgICAgcHJvZ3JhbS5pbnB1dERhdGFTaXplID0gY29uZmlnLndpZHRoICogY29uZmlnLmhlaWdodDtcbiAgICB9XG5cbiAgICBwcm9ncmFtLm91dHB1dCA9IGNvbmZpZy5vdXRwdXQ7XG5cbiAgICBjb25zdCBrZXJuZWwgPSBjb25maWcua2VybmVsO1xuXG4gICAgaWYgKHR5cGVvZihrZXJuZWwpICE9ICdzdHJpbmcnIHx8IGtlcm5lbC5sZW5ndGggPT0gMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIktlcm5lbCBjb2RlIGNhbm5vdCBiZSBlbXB0eS5cIik7XG5cbiAgICBjb25zdCBpbnB1dHMgPSBjb25maWcuaW5wdXRzIHx8IFtdO1xuICAgIGNvbnN0IHVuaWZvcm1zID0gY29uZmlnLnVuaWZvcm1zIHx8IHt9O1xuXG4gICAgdGhpcy5fcHJlcGFyZVByb2dyYW1JbnB1dHMocHJvZ3JhbSwgaW5wdXRzKTtcblxuICAgIGxldCBmcmFnbWVudFNoYWRlckNvbmZpZyA9IFwiXCI7XG4gICAgXG4gICAgZm9yIChjb25zdCBpbmRleCBpbiBpbnB1dHMpXG4gICAgICBmcmFnbWVudFNoYWRlckNvbmZpZyArPSBgdW5pZm9ybSBzYW1wbGVyMkQgX2lucHV0JHtpbmRleH07XFxuYDtcblxuICAgIGlmIChwcm9ncmFtLmlucHV0V2lkdGggPT09IHVuZGVmaW5lZCB8fCBwcm9ncmFtLmlucHV0SGVpZ2h0ID09PSB1bmRlZmluZWQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGtlcm5lbCBzaXplLiBZb3UgbXVzdCBwcm92aWRlIGVpdGhlciBhbiBpbnB1dCBvciB0aGUgYHdpZHRoYCBhbmQgYGhlaWdodGAgcGFyYW1ldGVycyBpbiB0aGUga2VybmVsIGNvbmZpZy5cIik7XG5cbiAgICBwcm9ncmFtLnVuaWZvcm1UZXh0dXJlcyA9IHt9O1xuICAgIHByb2dyYW0udW5pZm9ybXMgPSB7fTtcblxuICAgIGZvciAoY29uc3QgdW5pZm9ybU5hbWUgaW4gdW5pZm9ybXMpIHtcbiAgICAgIGNvbnN0IHVuaWZvcm0gPSB1bmlmb3Jtc1t1bmlmb3JtTmFtZV07XG5cbiAgICAgIGlmICh0eXBlb2YodW5pZm9ybSkgPT0gJ251bWJlcicpIHtcbiAgICAgICAgcHJvZ3JhbS51bmlmb3Jtc1t1bmlmb3JtTmFtZV0gPSB7XG4gICAgICAgICAgdHlwZTogJ2Zsb2F0JyxcbiAgICAgICAgICB2YWx1ZTogdW5pZm9ybVxuICAgICAgICB9O1xuICAgICAgICBmcmFnbWVudFNoYWRlckNvbmZpZyArPSBgdW5pZm9ybSBmbG9hdCAke3VuaWZvcm1OYW1lfTtcXG5gO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHVuaWZvcm0pKSB7XG4gICAgICAgIGlmICh1bmlmb3JtLmxlbmd0aCA8IDIgfHwgdW5pZm9ybS5sZW5ndGggPiA0KVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXJyYXkgdW5pZm9ybXMgY2FuIG9ubHkgaGF2ZSBsZW5ndGhzIG9mIDIsIDMsIG9yIDQgZWxlbWVudHMgKGNvcnJlc3BvbmRpbmcgdG8gdmVjMiwgdmVjMywgYW5kIHZlYzQpLmApO1xuXG4gICAgICAgIGNvbnN0IHR5cGUgPSBbJ3ZlYzInLCAndmVjMycsICd2ZWM0J11bdW5pZm9ybS5sZW5ndGggLSAyXTtcbiAgICAgICAgcHJvZ3JhbS51bmlmb3Jtc1t1bmlmb3JtTmFtZV0gPSB7XG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICB2YWx1ZTogdW5pZm9ybVxuICAgICAgICB9O1xuICAgICAgICBmcmFnbWVudFNoYWRlckNvbmZpZyArPSBgdW5pZm9ybSAke3R5cGV9ICR7dW5pZm9ybU5hbWV9O1xcbmA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7IHR5cGUsIHdpZHRoLCBoZWlnaHQsIGNoYW5uZWxzLCBkYXRhLCB2YWx1ZSwgbGVuZ3RoLCBuYW1lIH0gPSB1bmlmb3JtO1xuXG4gICAgICAgIGlmICh0eXBlID09ICd0ZXh0dXJlJyB8fCB0eXBlID09ICdvdXRwdXRUZXh0dXJlJyB8fCB0eXBlID09ICdzaGFyZWRUZXh0dXJlJykge1xuICAgICAgICAgIGxldCB0YXJnZXQsIHR5cGU7XG5cbiAgICAgICAgICBpZiAodW5pZm9ybS50ZXh0dXJlVHlwZSA9PSAnM0QnKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLmdsLlRFWFRVUkVfM0Q7XG4gICAgICAgICAgICB0eXBlID0gJ3NhbXBsZXIzRCc7XG4gICAgICAgICAgfSBlbHNlIGlmICh1bmlmb3JtLnRleHR1cmVUeXBlID09ICcyREFycmF5Jykge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5nbC5URVhUVVJFXzJEX0FSUkFZO1xuICAgICAgICAgICAgdHlwZSA9ICdzYW1wbGVyMkRBcnJheSc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXMuZ2wuVEVYVFVSRV8yRDtcbiAgICAgICAgICAgIHR5cGUgPSAnc2FtcGxlcjJEJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZSA9PSAndGV4dHVyZScpIHtcbiAgICAgICAgICAgIHByb2dyYW0udW5pZm9ybVRleHR1cmVzW3VuaWZvcm1OYW1lXSA9IHsgdGFyZ2V0LCB0ZXh0dXJlOiBkYXRhID8gdGhpcy5fY3JlYXRlVGV4dHVyZShkYXRhLCB3aWR0aCwgaGVpZ2h0LCBjaGFubmVscywgdW5pZm9ybSkgOiBudWxsIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb2dyYW0udW5pZm9ybVRleHR1cmVzW3VuaWZvcm1OYW1lXSA9IHsgdGFyZ2V0LCB0ZXh0dXJlOiBudWxsLCBuYW1lOiBuYW1lIHx8IHVuaWZvcm1OYW1lIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZnJhZ21lbnRTaGFkZXJDb25maWcgKz0gYHVuaWZvcm0gJHt0eXBlfSAke3VuaWZvcm1OYW1lfTtcXG5gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb2dyYW0udW5pZm9ybXNbdW5pZm9ybU5hbWVdID0geyB0eXBlLCB2YWx1ZSB9O1xuICAgICAgICAgIGlmIChsZW5ndGggIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyQ29uZmlnICs9IGB1bmlmb3JtICR7dHlwZX0gJHt1bmlmb3JtTmFtZX1bJHtsZW5ndGh9XTtcXG5gO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZyYWdtZW50U2hhZGVyQ29uZmlnICs9IGB1bmlmb3JtICR7dHlwZX0gJHt1bmlmb3JtTmFtZX07XFxuYDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHZlcnRleFNoYWRlciA9IHRoaXMuZ2wuY3JlYXRlU2hhZGVyKHRoaXMuZ2wuVkVSVEVYX1NIQURFUik7XG4gICAgdGhpcy5nbC5zaGFkZXJTb3VyY2UodmVydGV4U2hhZGVyLCBjb25maWcudmVydGV4U2hhZGVyIHx8IHZlcnRleFNoYWRlckNvZGUpO1xuICAgIHRoaXMuZ2wuY29tcGlsZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuXG4gICAgaWYgKCF0aGlzLmdsLmdldFNoYWRlclBhcmFtZXRlcih2ZXJ0ZXhTaGFkZXIsIHRoaXMuZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ291bGQgbm90IGJ1aWxkIHZlcnRleCBzaGFkZXIgKGZhdGFsKS5cXG5cIiArIFwiXFxuXCIgK1xuICAgICAgICBcIi0tLSBDT0RFIERVTVAgLS0tXFxuXCIgKyAoY29uZmlnLnZlcnRleFNoYWRlciB8fCB2ZXJ0ZXhTaGFkZXJDb2RlKSArIFwiXFxuXFxuXCIgK1xuICAgICAgICBcIi0tLSBFUlJPUiBMT0cgLS0tXFxuXCIgKyB0aGlzLmdsLmdldFNoYWRlckluZm9Mb2codmVydGV4U2hhZGVyKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBmcmFnbWVudFNoYWRlck1haW4gPSBgXG52b2lkIG1haW4oKSB7XG4gIGtlcm5lbE91dCA9IHZlYzQoa2VybmVsKCR7Wy4uLkFycmF5KGlucHV0cy5sZW5ndGgpLmtleXMoKV0ubWFwKGkgPT4gYHRleHR1cmUoX2lucHV0JHtpfSwga2VybmVsUG9zaXRpb24pYCkuam9pbignLCAnKX0pKTtcbn1cbiAgICBgO1xuXG4gICAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmdsLmNyZWF0ZVNoYWRlcih0aGlzLmdsLkZSQUdNRU5UX1NIQURFUik7XG4gICAgY29uc3QgZnJhZ21lbnRTaGFkZXJTb3VyY2UgPSBmcmFnbWVudFNoYWRlckhlYWRlciArIGZyYWdtZW50U2hhZGVyQ29uZmlnICsga2VybmVsICsgZnJhZ21lbnRTaGFkZXJNYWluO1xuICAgIHRoaXMuZ2wuc2hhZGVyU291cmNlKGZyYWdtZW50U2hhZGVyLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7XG4gICAgdGhpcy5nbC5jb21waWxlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcblxuICAgIGlmICghdGhpcy5nbC5nZXRTaGFkZXJQYXJhbWV0ZXIoZnJhZ21lbnRTaGFkZXIsIHRoaXMuZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBmcmFnbWVudFNoYWRlclNvdXJjZS5zcGxpdCgnXFxuJyk7XG4gICAgICBsZXQgZGJnTXNnID0gXCJFUlJPUjogQ291bGQgbm90IGJ1aWxkIHNoYWRlciAoZmF0YWwpLlxcblxcbi0tLS0tLS0tLS0tLS0tLS0tLSBLRVJORUwgQ09ERSBEVU1QIC0tLS0tLS0tLS0tLS0tLS0tLVxcblwiXG5cbiAgICAgIGZvciAobGV0IGwgPSAwOyBsIDwgc291cmNlLmxlbmd0aDsgbCsrKVxuICAgICAgICBkYmdNc2cgKz0gYCR7bCArIDF9PiAke3NvdXJjZVtsXX1cXG5gO1xuXG4gICAgICBkYmdNc2cgKz0gXCJcXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVJST1IgIExPRyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cIiArIHRoaXMuZ2wuZ2V0U2hhZGVySW5mb0xvZyhmcmFnbWVudFNoYWRlcik7XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihkYmdNc2cpO1xuICAgIH1cblxuICAgIHByb2dyYW0uZ2xQcm9ncmFtID0gdGhpcy5nbC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgdGhpcy5nbC5hdHRhY2hTaGFkZXIocHJvZ3JhbS5nbFByb2dyYW0sIHZlcnRleFNoYWRlcik7XG4gICAgdGhpcy5nbC5hdHRhY2hTaGFkZXIocHJvZ3JhbS5nbFByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcbiAgICB0aGlzLmdsLmxpbmtQcm9ncmFtKHByb2dyYW0uZ2xQcm9ncmFtKTtcbiAgICB0aGlzLmdsLnVzZVByb2dyYW0ocHJvZ3JhbS5nbFByb2dyYW0pO1xuXG4gICAgaWYgKCF0aGlzLmdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbS5nbFByb2dyYW0sIHRoaXMuZ2wuTElOS19TVEFUVVMpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gbGluayBHTFNMIHByb2dyYW0gY29kZS4nKTtcblxuICAgIGxldCB0ZXh0dXJlSW5kZXggPSAwO1xuXG4gICAgZm9yIChjb25zdCBpbnB1dCBvZiBwcm9ncmFtLmlucHV0VGV4dHVyZXMpIHtcbiAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbS5nbFByb2dyYW0sIGBfaW5wdXQke3RleHR1cmVJbmRleH1gKTtcbiAgICAgIHRoaXMuZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB0ZXh0dXJlSW5kZXgpO1xuICAgICAgdGV4dHVyZUluZGV4Kys7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB1bmlmb3JtTmFtZSBpbiBwcm9ncmFtLnVuaWZvcm1UZXh0dXJlcykge1xuICAgICAgcHJvZ3JhbS51bmlmb3JtVGV4dHVyZXNbdW5pZm9ybU5hbWVdLmluZGV4ID0gdGV4dHVyZUluZGV4O1xuICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLmdsUHJvZ3JhbSwgdW5pZm9ybU5hbWUpO1xuICAgICAgdGhpcy5nbC51bmlmb3JtMWkobG9jYXRpb24sIHRleHR1cmVJbmRleCk7XG4gICAgICB0ZXh0dXJlSW5kZXgrKztcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHVuaWZvcm1OYW1lIGluIHByb2dyYW0udW5pZm9ybXMpIHtcbiAgICAgIGNvbnN0IHsgdHlwZSwgdmFsdWUgfSA9IHByb2dyYW0udW5pZm9ybXNbdW5pZm9ybU5hbWVdO1xuICAgICAgY29uc3QgbG9jYXRpb24gPSBwcm9ncmFtLnVuaWZvcm1zW3VuaWZvcm1OYW1lXS5sb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0uZ2xQcm9ncmFtLCB1bmlmb3JtTmFtZSk7XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB0aGlzLl9zZXRVbmlmb3JtKHR5cGUsIGxvY2F0aW9uLCB2YWx1ZSk7XG5cbiAgICAgIGRlbGV0ZSBwcm9ncmFtLnVuaWZvcm1zW3VuaWZvcm1OYW1lXS52YWx1ZTtcbiAgICB9XG5cbiAgICBwcm9ncmFtLmtlcm5lbFNpemVMb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0uZ2xQcm9ncmFtLCAna2VybmVsU2l6ZScpO1xuICAgIHRoaXMuZ2wudW5pZm9ybTJpKHByb2dyYW0ua2VybmVsU2l6ZUxvY2F0aW9uLCBwcm9ncmFtLmlucHV0V2lkdGgsIHByb2dyYW0uaW5wdXRIZWlnaHQpO1xuXG4gICAgcHJvZ3JhbS5wb3NpdGlvbkxvY2F0aW9uID0gdGhpcy5nbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLmdsUHJvZ3JhbSwgJ3Bvc2l0aW9uJyk7XG4gICAgcHJvZ3JhbS50ZXh0dXJlTG9jYXRpb24gPSB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0uZ2xQcm9ncmFtLCAndGV4dHVyZScpO1xuXG4gICAgcHJvZ3JhbS5mcmFtZUJ1ZmZlciA9IHRoaXMuZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICB0aGlzLl9wcmVwYXJlUHJvZ3JhbU91dHB1dChwcm9ncmFtKTtcblxuICAgIHJldHVybiBwcm9ncmFtO1xuICB9XG5cbiAgX3ByZXBhcmVQcm9ncmFtSW5wdXRzKHByb2dyYW0sIGlucHV0cykge1xuICAgIGlmIChwcm9ncmFtLmlucHV0VGV4dHVyZXMpXG4gICAgICBwcm9ncmFtLmlucHV0VGV4dHVyZXMuZm9yRWFjaCh0ID0+IHRoaXMuZ2wuZGVsZXRlVGV4dHVyZSh0KSk7XG5cbiAgICBwcm9ncmFtLmlucHV0VGV4dHVyZXMgPSBbXTtcblxuICAgIGZvciAoY29uc3QgW2luZGV4LCBkYXRhXSBvZiBpbnB1dHMuZW50cmllcygpKSB7XG4gICAgICBpZiAoZGF0YS5ncGdwdVNpemUgPT09IHVuZGVmaW5lZCB8fCBkYXRhLmdwZ3B1U3RyaWRlID09PSB1bmRlZmluZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignR1BHUFUgaW5wdXRzIG11c3QgYmUgY3JlYXRlZCBieSB0aGUgYGFsbG9jYCBmdW5jdGlvbi4nKTtcblxuICAgICAgY29uc3Qgc2l6ZSA9IE1hdGguc3FydChkYXRhLmxlbmd0aCAvIGRhdGEuZ3BncHVTdHJpZGUpO1xuICAgICAgaWYgKHNpemUgPD0gMCB8fCBzaXplICUgMSAhPSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dQR1BVIGlucHV0IHNpemUgaXMgZXhwZWN0ZWQgdG8gYmUgYSBwZXJmZWN0IHNxdWFyZS4nKTtcblxuICAgICAgaWYgKHByb2dyYW0uaW5wdXRXaWR0aCA9PT0gdW5kZWZpbmVkIHx8IHByb2dyYW0uaW5wdXRIZWlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9ncmFtLmlucHV0V2lkdGggPSBzaXplO1xuICAgICAgICBwcm9ncmFtLmlucHV0SGVpZ2h0ID0gc2l6ZTtcbiAgICAgICAgcHJvZ3JhbS5pbnB1dERhdGFTaXplID0gZGF0YS5ncGdwdVNpemU7XG4gICAgICB9IGVsc2UgaWYgKHNpemUgIT0gcHJvZ3JhbS5pbnB1dFdpZHRoIHx8IHNpemUgIT0gcHJvZ3JhbS5pbnB1dEhlaWdodCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFsbCBHUEdQVSBpbnB1dHMgbXVzdCBiZSBvZiB0aGUgc2FtZSBzaXplLiBSZWNlaXZlZCAke2RhdGEuZ3BncHVTaXplfSAoaW50ZXJuYWwgJHtzaXplICogc2l6ZX0pIGJ1dCBleHBlY3RlZCAke3Byb2dyYW0uaW5wdXREYXRhU2l6ZX0gKGludGVybmFsICR7cHJvZ3JhbS5pbnB1dFdpZHRoICogcHJvZ3JhbS5pbnB1dEhlaWdodH0pLmApO1xuICAgICAgfVxuXG4gICAgICBwcm9ncmFtLmlucHV0VGV4dHVyZXMucHVzaCh0aGlzLl9jcmVhdGVUZXh0dXJlKGRhdGEsIHNpemUsIHNpemUsIGRhdGEuZ3BncHVTdHJpZGUpKTtcbiAgICB9XG4gIH1cblxuICBfcHJlcGFyZVByb2dyYW1PdXRwdXQocHJvZ3JhbSkge1xuICAgIHRoaXMuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuZ2wuRlJBTUVCVUZGRVIsIHByb2dyYW0uZnJhbWVCdWZmZXIpO1xuXG4gICAgY29uc3Qgb3V0cHV0VGV4dHVyZSA9IHRoaXMuX2NyZWF0ZVRleHR1cmUobnVsbCwgcHJvZ3JhbS5pbnB1dFdpZHRoLCBwcm9ncmFtLmlucHV0SGVpZ2h0LCA0LCBwcm9ncmFtLm91dHB1dCk7XG5cbiAgICBpZiAocHJvZ3JhbS5vdXRwdXQgJiYgcHJvZ3JhbS5vdXRwdXQudGV4dHVyZVR5cGUgIT09ICczRCcgJiYgcHJvZ3JhbS5vdXRwdXQudGV4dHVyZVR5cGUgIT09ICcyREFycmF5Jykge1xuICAgICAgdGhpcy5nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCh0aGlzLmdsLkZSQU1FQlVGRkVSLCB0aGlzLmdsLkNPTE9SX0FUVEFDSE1FTlQwLCB0aGlzLmdsLlRFWFRVUkVfMkQsIG91dHB1dFRleHR1cmUsIDApO1xuICAgICAgY29uc3QgZnJhbWVCdWZmZXJTdGF0dXMgPSAodGhpcy5nbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKHRoaXMuZ2wuRlJBTUVCVUZGRVIpID09IHRoaXMuZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUpO1xuICAgICAgaWYgKCFmcmFtZUJ1ZmZlclN0YXR1cylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBhdHRhY2hpbmcgZmxvYXQgdGV4dHVyZSB0byBmcmFtZWJ1ZmZlci4gWW91ciBkZXZpY2UgaXMgcHJvYmFibHkgaW5jb21wYXRpYmxlLicpO1xuICAgIH1cblxuICAgIGlmIChwcm9ncmFtLm91dHB1dFRleHR1cmUgIT09IHVuZGVmaW5lZClcbiAgICAgIHRoaXMuZ2wuZGVsZXRlVGV4dHVyZShwcm9ncmFtLm91dHB1dFRleHR1cmUpO1xuICAgIHByb2dyYW0ub3V0cHV0VGV4dHVyZSA9IG91dHB1dFRleHR1cmU7XG5cbiAgICBpZiAocHJvZ3JhbS5vdXRwdXQgJiYgcHJvZ3JhbS5vdXRwdXQubmFtZSlcbiAgICAgIHRoaXMub3V0cHV0VGV4dHVyZXNbcHJvZ3JhbS5vdXRwdXQubmFtZV0gPSBvdXRwdXRUZXh0dXJlO1xuICB9XG5cbiAgX3NldFVuaWZvcm0odHlwZSwgbG9jYXRpb24sIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdpbnQnOiB0aGlzLmdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdmFsdWUpOyBicmVhaztcbiAgICAgIGNhc2UgJ2Zsb2F0JzogQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB0aGlzLmdsLnVuaWZvcm0xZnYobG9jYXRpb24sIHZhbHVlKSA6IHRoaXMuZ2wudW5pZm9ybTFmKGxvY2F0aW9uLCB2YWx1ZSk7IGJyZWFrO1xuICAgICAgY2FzZSAndmVjMic6IHRoaXMuZ2wudW5pZm9ybTJmdihsb2NhdGlvbiwgdmFsdWUpOyBicmVhaztcbiAgICAgIGNhc2UgJ3ZlYzMnOiB0aGlzLmdsLnVuaWZvcm0zZnYobG9jYXRpb24sIHZhbHVlKTsgYnJlYWs7XG4gICAgICBjYXNlICd2ZWM0JzogdGhpcy5nbC51bmlmb3JtNGZ2KGxvY2F0aW9uLCB2YWx1ZSk7IGJyZWFrO1xuICAgICAgY2FzZSAnbWF0Myc6IHRoaXMuZ2wudW5pZm9ybU1hdHJpeDNmdihsb2NhdGlvbiwgdmFsdWUpOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcihgVW5rbm93biB1bmlmb3JtIHR5cGUgJHt0eXBlfS5gKTtcbiAgICB9XG4gIH1cblxuICBfbmV3QnVmZmVyKGRhdGEsIGtsYXNzLCB0YXJnZXQpIHtcbiAgICBjb25zdCBidWYgPSB0aGlzLmdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gICAgdGhpcy5nbC5iaW5kQnVmZmVyKCh0YXJnZXQgfHwgdGhpcy5nbC5BUlJBWV9CVUZGRVIpLCBidWYpO1xuICAgIHRoaXMuZ2wuYnVmZmVyRGF0YSgodGFyZ2V0IHx8IHRoaXMuZ2wuQVJSQVlfQlVGRkVSKSwgbmV3IChrbGFzcyB8fCBGbG9hdDMyQXJyYXkpKGRhdGEpLCB0aGlzLmdsLlNUQVRJQ19EUkFXKTtcblxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICBfY3JlYXRlVGV4dHVyZShkYXRhLCB3aWR0aCwgaGVpZ2h0LCBjaGFubmVscywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgdGV4dHVyZSA9IHRoaXMuZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG4gICAgbGV0IGludGVybmFsRm9ybWF0LCBmb3JtYXQ7XG5cbiAgICBzd2l0Y2ggKGNoYW5uZWxzKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGludGVybmFsRm9ybWF0ID0gdGhpcy5nbC5SMzJGO1xuICAgICAgICBmb3JtYXQgPSB0aGlzLmdsLlJFRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGludGVybmFsRm9ybWF0ID0gdGhpcy5nbC5SRzMyRjtcbiAgICAgICAgZm9ybWF0ID0gdGhpcy5nbC5SRztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGludGVybmFsRm9ybWF0ID0gdGhpcy5nbC5SR0IzMkY7XG4gICAgICAgIGZvcm1hdCA9IHRoaXMuZ2wuUkdCO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgaW50ZXJuYWxGb3JtYXQgPSB0aGlzLmdsLlJHQkEzMkY7XG4gICAgICAgIGZvcm1hdCA9IHRoaXMuZ2wuUkdCQTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyhcIlRleHR1cmUgY2hhbm5lbHMgbXVzdCBiZXR3ZWVuIDEgYW5kIDQuXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldCA9IG9wdGlvbnMudGV4dHVyZVR5cGUgPT0gJzNEJyA/IHRoaXMuZ2wuVEVYVFVSRV8zRCA6IG9wdGlvbnMudGV4dHVyZVR5cGUgPT0gJzJEQXJyYXknID8gdGhpcy5nbC5URVhUVVJFXzJEX0FSUkFZIDogdGhpcy5nbC5URVhUVVJFXzJEO1xuXG4gICAgdGhpcy5nbC5iaW5kVGV4dHVyZSh0YXJnZXQsIHRleHR1cmUpO1xuICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIHRoaXMuZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMuZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgdGhpcy5nbC5URVhUVVJFX1dSQVBfVCwgdGhpcy5nbC5DTEFNUF9UT19FREdFKTtcbiAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCB0aGlzLmdsLlRFWFRVUkVfV1JBUF9SLCB0aGlzLmdsLkNMQU1QX1RPX0VER0UpO1xuICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIHRoaXMuZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBvcHRpb25zLmZpbHRlciA9PSAnbGluZWFyJyA/IHRoaXMuZ2wuTElORUFSIDogdGhpcy5nbC5ORUFSRVNUKTtcbiAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCB0aGlzLmdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgb3B0aW9ucy5maWx0ZXIgPT0gJ2xpbmVhcicgPyB0aGlzLmdsLkxJTkVBUiA6IHRoaXMuZ2wuTkVBUkVTVCk7XG5cbiAgICBpZiAob3B0aW9ucy50ZXh0dXJlVHlwZSA9PSAnM0QnIHx8IG9wdGlvbnMudGV4dHVyZVR5cGUgPT0gJzJEQXJyYXknKSB7XG4gICAgICB0aGlzLmdsLnRleEltYWdlM0QodGFyZ2V0LCAwLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucy5kZXB0aCwgMCwgZm9ybWF0LCB0aGlzLmdsLkZMT0FULCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRhcmdldCwgMCwgaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIGZvcm1hdCwgdGhpcy5nbC5GTE9BVCwgZGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5nbC5iaW5kVGV4dHVyZSh0YXJnZXQsIG51bGwpO1xuXG4gICAgcmV0dXJuIHRleHR1cmU7XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXTERNAL MODULE: ./js/GPGPU.js\nvar GPGPU = __webpack_require__(5);\n\n// EXTERNAL MODULE: ./js/physics/Car.js\nvar Car = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./js/autonomy/path-planning/CubicPath.js\nvar CubicPath = __webpack_require__(2);\n\n// CONCATENATED MODULE: ./js/autonomy/path-planning/QuinticPath.js\nclass QuinticPath {\n  constructor(start, end, params) {\n    this.start = Object.assign({}, start);\n    this.end = Object.assign({}, end);\n\n    if (start.pos) {\n      this.start.x = start.pos.x;\n      this.start.y = start.pos.y\n    }\n\n    if (end.pos) {\n      this.end.x = end.pos.x;\n      this.end.y = end.pos.y\n    }\n\n    const diffX = this.end.x - this.start.x;\n    const diffY = this.end.y - this.start.y;\n    const sinRot = Math.sin(this.start.rot);\n    const cosRot = Math.cos(this.start.rot);\n\n    this.goal = {\n      x: cosRot * diffX + sinRot * diffY,\n      y: -sinRot * diffX + cosRot * diffY,\n      rot: Math.wrapAngle(this.end.rot - this.start.rot),\n      curv: this.end.curv\n    };\n\n    this.params = Object.assign({}, params, { p0: this.start.curv, p1: this.start.dCurv || 0, p2: this.start.ddCurv || 0, p5: this.end.curv });\n  }\n\n  buildPath(num) {\n    const { p0, p1, p2, p3, p4, p5, sG } = this.params;\n\n    const sG_2 = sG * sG;\n    const sG_3 = sG_2 * sG;\n\n    const a = p0;\n    const b = p1;\n    const c = p2 / 2.0;\n    const d = (-71.875 * p0 + 81.0 * p3 - 10.125 * p4 + p5 - 21.25 * p1 * sG - 2.75 * p2 * sG_2) / sG_3;\n    const e = (166.5 * p0 - 202.5 * p3 + 40.5 * p4 - 4.5 * p5 + 45.0 * p1 * sG + 4.5 * p2 * sG_2) / (sG_2 * sG_2);\n    const f = (-95.625 * p0 + 121.5 * p3 - 30.375 * p4 + 4.5 * p5 - 24.75 * p1 * sG - 2.25 * p2 * sG_2) / (sG_2 * sG_3);\n\n    const path = [{ pos: new THREE.Vector2(this.start.x, this.start.y), rot: this.start.rot, curv: this.start.curv }];\n    const ds = sG / (num - 1);\n    let s = ds;\n    let dx = 0;\n    let dy = 0;\n    let prevCosRot = Math.cos(path[0].rot);\n    let prevSinRot = Math.sin(path[0].rot);\n\n    for (let i = 1; i < num - 1; i++) {\n      const rot = (((((f * s / 6.0 + e / 5.0) * s + d / 4.0) * s + c / 3.0) * s + b / 2.0) * s + a) * s + this.start.rot;\n      const curv = ((((f * s + e) * s + d) * s + c) * s + b) * s + a;\n      const cosRot = Math.cos(rot);\n      const sinRot = Math.sin(rot);\n\n      dx = dx * (i - 1) / i + (cosRot + prevCosRot) / (2 * i);\n      dy = dy * (i - 1) / i + (sinRot + prevSinRot) / (2 * i);\n\n      path.push({ pos: new THREE.Vector2(s * dx + this.start.x, s * dy + this.start.y), rot: rot, curv: curv });\n\n      s += ds;\n      prevCosRot = cosRot;\n      prevSinRot = sinRot;\n    }\n\n    path.push({ pos: new THREE.Vector2(this.end.x, this.end.y), rot: this.end.rot, curv: this.end.curv });\n\n    return path;\n  }\n}\n\n// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/xyObstacleGrid.js\nconst OBSTACLE_VERTEX_SHADER = `#version 300 es\nuniform mat3 xform;\nin vec2 position;\n\nvoid main(void) {\n  gl_Position = vec4((xform * vec3(position, 1)).xy, 0, 1);\n}\n`;\n\nconst OBSTACLE_KERNEL = `\n  vec4 kernel() {\n    return vec4(1, 0, 0, 1);\n  }\n`;\n\nlet obstacleVertices;\nlet obstacleXform;\n\n// Draw obstacle triangles to XY-space obstacle grid\n/* harmony default export */ var xyObstacleGrid = ({\n  setUp() {\n    return {\n      kernel: OBSTACLE_KERNEL,\n      vertexShader: OBSTACLE_VERTEX_SHADER,\n      output: { name: 'xyObstacleGrid' },\n      draw: (gpgpu, program) => {\n        const gl = gpgpu.gl;\n\n        gl.clearColor(0, 0, 0, 0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        if (obstacleVertices.length > 0) {\n          const buf = gl.createBuffer();\n\n          gl.bindBuffer(gl.ARRAY_BUFFER, buf);\n          gl.bufferData(gl.ARRAY_BUFFER, obstacleVertices, gl.STATIC_DRAW);\n          gl.enableVertexAttribArray(program.positionLocation);\n          gl.vertexAttribPointer(program.positionLocation, 2, gl.FLOAT, false, 0, 0);\n\n          const xformLocation = gl.getUniformLocation(program.glProgram, 'xform');\n          gl.uniformMatrix3fv(xformLocation, false, obstacleXform.elements);\n\n          gl.drawArrays(gl.TRIANGLES, 0, obstacleVertices.length / 2);\n\n          gl.deleteBuffer(buf);\n        }\n      }\n    };\n  },\n\n  update(config, xyWidth, xyHeight, xyCenterPoint, vehicleXform, obstacles) {\n    obstacleVertices = new Float32Array(Array.prototype.concat.apply([], obstacles.map(o => o.vertices)));\n\n    const translate = new THREE.Matrix3();\n    translate.set(\n      1, 0, -xyCenterPoint.x,\n      0, 1, -xyCenterPoint.y,\n      0, 0, 1\n    );\n\n    const scale = new THREE.Matrix3();\n    scale.set(\n      2 / (xyWidth * config.xyGridCellSize), 0, 0,\n      0, 2 / (xyHeight * config.xyGridCellSize), 0,\n      0, 0, 1\n    );\n\n    obstacleXform = scale.multiply(translate).multiply(vehicleXform);\n\n    return {\n      width: xyWidth,\n      height: xyHeight\n    }\n  }\n});\n\n// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/slObstacleGrid.js\nconst SL_OBSTACLE_KERNEL = `\n\nvec4 kernel() {\n  float centerlineWidth = float(textureSize(centerline, 0).x);\n\n  vec2 sl = (kernelPosition - 0.5) * vec2(kernelSize) * vec2(slGridCellSize) + slCenterPoint;\n  float centerlineCoord = sl.x / centerlineStationInterval / centerlineWidth * (centerlineWidth - 1.0) / centerlineWidth + (0.5 / centerlineWidth);\n  if (centerlineCoord < 0.0 || centerlineCoord > 1.0) return vec4(0);\n\n  vec3 centerlineSample = texture(centerline, vec2(centerlineCoord, 0)).xyz;\n  float perpindicular = centerlineSample.z + radians(90.0);\n  vec2 xy = centerlineSample.xy + sl.yy * vec2(cos(perpindicular), sin(perpindicular));\n\n  vec2 xyTexCoords = (xy - xyCenterPoint) / vec2(textureSize(xyObstacleGrid, 0)) / vec2(xyGridCellSize) + 0.5;\n  return texture(xyObstacleGrid, xyTexCoords);\n}\n\n`;\n\n// Convert XY-space obstacle grid to SL-space obstacle grid\n/* harmony default export */ var slObstacleGrid = ({\n  setUp() {\n    return {\n      kernel: SL_OBSTACLE_KERNEL,\n      output: { name: 'slObstacleGrid' },\n      uniforms: {\n        xyObstacleGrid: { type: 'outputTexture' },\n        slGridCellSize: { type: 'float' },\n        xyGridCellSize: { type: 'float' },\n        slCenterPoint: { type: 'vec2' },\n        xyCenterPoint: { type: 'vec2' },\n        centerlineStationInterval: { type: 'float' },\n        centerline: { type: 'sharedTexture' }\n      }\n    }\n  },\n\n  update(config, slWidth, slHeight, slCenterPoint, xyCenterPoint) {\n    return {\n      width: slWidth,\n      height: slHeight,\n      uniforms: {\n        slGridCellSize: config.slGridCellSize,\n        xyGridCellSize: config.xyGridCellSize,\n        slCenterPoint: [slCenterPoint.x, slCenterPoint.y],\n        xyCenterPoint: [xyCenterPoint.x, xyCenterPoint.y],\n        centerlineStationInterval: config.centerlineStationInterval\n      }\n    }\n  }\n});\n\n// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/slObstacleGridDilation.js\nconst SL_OBSTACLE_DILATION_KERNEL = `\n\n// TODO: test performance of returning early if non-zero pixel found\nvec4 kernel() {\n  float val = 0.0;\n\n  for (int d = 0; d <= collisionDilation; d++) {\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(d)).r);\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(-d)).r);\n  }\n\n  for (int d = collisionDilation + 1; d <= collisionDilation + hazardDilation; d++) {\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(d)).r * 0.5);\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(-d)).r * 0.5);\n  }\n\n  val = max(val, step(0.1, val) * 0.5);\n\n  return vec4(val, 0, 0, 1);\n}\n\n`;\n\n/* harmony default export */ var slObstacleGridDilation = ({\n  setUp() {\n    return [\n      { // SL-space obstacle grid S dilation\n        kernel: SL_OBSTACLE_DILATION_KERNEL,\n        output: { name: 'slObstacleGridStationDilated' },\n        uniforms: {\n          slObstacleGrid: { type: 'outputTexture' },\n          delta: { type: 'vec2' },\n          collisionDilation: { type: 'int' },\n          hazardDilation: { type: 'int' }\n        }\n      },\n      { // SL-space obstacle grid L dilation\n        kernel: SL_OBSTACLE_DILATION_KERNEL,\n        output: { name: 'slObstacleGridDilated' },\n        uniforms: {\n          slObstacleGrid: { type: 'outputTexture', name: 'slObstacleGridStationDilated' },\n          delta: { type: 'vec2' },\n          collisionDilation: { type: 'int' },\n          hazardDilation: { type: 'int' }\n        }\n      }\n    ];\n  },\n\n  update(config, slWidth, slHeight) {\n    return [\n      { // SL-space obstacle grid S dilation\n        width: slWidth,\n        height: slHeight,\n        uniforms: {\n          delta: [1 / slWidth, 0],\n          collisionDilation: Math.ceil(config.collisionDilationS / config.slGridCellSize),\n          hazardDilation: Math.ceil(config.hazardDilationS / config.slGridCellSize)\n        }\n      },\n      { // SL-space obstacle grid L dilation\n        width: slWidth,\n        height: slHeight,\n        uniforms: {\n          delta: [0, 1 / slHeight],\n          collisionDilation: Math.ceil(config.collisionDilationL / config.slGridCellSize),\n          hazardDilation: Math.ceil(config.hazardDilationL / config.slGridCellSize)\n        }\n      }\n    ];\n  }\n});\n\n// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/slDynamicObstacleGrid.js\nconst DYNAMIC_OBSTACLE_VERTEX_SHADER = `#version 300 es\nuniform mat3 xform;\nin vec3 position;\nout float color;\n\nvoid main(void) {\n  gl_Position = vec4((xform * vec3(position.xy, 1)).xy, position.z, 1);\n\n  // The z coordinate is 0.25 for collision zone and 0.75 for hazard zone,\n  // so that the collision zone is drawn on top.\n  // Convert this to 1.0 for collision zone, 0.5 for hazard zone\n  color = (1.0 - step(0.5, position.z)) * 0.5 + 0.5;\n}\n`;\n\nconst DYNAMIC_OBSTACLE_KERNEL = `\n  in float color;\n\n  vec4 kernel() {\n    return vec4(color, 0, 0, 1);\n  }\n`;\n\nlet slDynamicObstacleGrid_obstacleVertices;\nlet slDynamicObstacleGrid_obstacleXform;\nconst numDynamicFrames = 20;\n\n// Draw dynamic obstacle triangles to SL-space obstacle grid\n/* harmony default export */ var slDynamicObstacleGrid = ({\n  setUp() {\n    return {\n      kernel: DYNAMIC_OBSTACLE_KERNEL,\n      vertexShader: DYNAMIC_OBSTACLE_VERTEX_SHADER,\n      output: { name: 'slDynamicObstacleGrid', textureType: '2DArray', depth: numDynamicFrames },\n      draw: (gpgpu, program) => {\n        const gl = gpgpu.gl;\n\n        gl.enable(gl.DEPTH_TEST);\n\n        const renderbuffer = gl.createRenderbuffer();\n        gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);\n        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, program.inputWidth, program.inputHeight);\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);\n\n        for (let frame = 0; frame < numDynamicFrames; frame++) {\n          gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, program.outputTexture, 0, frame);\n          const frameBufferStatus = (gl.checkFramebufferStatus(gl.FRAMEBUFFER) == gl.FRAMEBUFFER_COMPLETE);\n          if (!frameBufferStatus)\n            throw new Error('Error attaching float texture to framebuffer. Your device is probably incompatible.');\n\n          gl.clearColor(0, 0, 0, 0);\n          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n          if (slDynamicObstacleGrid_obstacleVertices[frame].length > 0) {\n            const buf = gl.createBuffer();\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, buf);\n            gl.bufferData(gl.ARRAY_BUFFER, slDynamicObstacleGrid_obstacleVertices[frame], gl.STATIC_DRAW);\n            gl.enableVertexAttribArray(program.positionLocation);\n            gl.vertexAttribPointer(program.positionLocation, 3, gl.FLOAT, false, 0, 0);\n\n            const xformLocation = gl.getUniformLocation(program.glProgram, 'xform');\n            gl.uniformMatrix3fv(xformLocation, false, slDynamicObstacleGrid_obstacleXform.elements);\n\n            gl.drawArrays(gl.TRIANGLES, 0, slDynamicObstacleGrid_obstacleVertices[frame].length / 3);\n\n            if (frame == 0) {\n              const obstacleGrid = new Float32Array(program.inputWidth * program.inputHeight * 4);\n              gl.readPixels(0, 0, program.inputWidth, program.inputHeight, gl.RGBA, gl.FLOAT, obstacleGrid);\n              gpgpu._dynamicObstacleGrid = obstacleGrid;\n            }\n\n            gl.deleteBuffer(buf);\n          }\n        }\n\n        gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n        gl.deleteRenderbuffer(renderbuffer);\n        gl.disable(gl.DEPTH_TEST);\n      }\n    };\n  },\n\n  update(config, slWidth, slHeight, slCenterPoint, vehicleStation, startTime, dynamicFrameTime, dynamicObstacles) {\n    slDynamicObstacleGrid_obstacleVertices = [];\n\n    let time = startTime;\n    for (let frame = 0; frame < numDynamicFrames; frame++) {\n      const vertices = Array.prototype.concat.apply([], dynamicObstacles.map(o => o.verticesInTimeRange(time, time + dynamicFrameTime, config)));\n      slDynamicObstacleGrid_obstacleVertices.push(new Float32Array(vertices));\n      time += dynamicFrameTime;\n    }\n\n    const translate = new THREE.Matrix3();\n    translate.set(\n      1, 0, -slCenterPoint.x - vehicleStation,\n      0, 1, -slCenterPoint.y,\n      0, 0, 1\n    );\n\n    const scale = new THREE.Matrix3();\n    scale.set(\n      2 / (slWidth * config.slGridCellSize), 0, 0,\n      0, 2 / (slHeight * config.slGridCellSize), 0,\n      0, 0, 1\n    );\n\n    slDynamicObstacleGrid_obstacleXform = scale.multiply(translate);\n\n    return {\n      width: slWidth,\n      height: slHeight\n    }\n  }\n});\n\n// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/xyslMap.js\nconst XYSL_MAP_KERNEL = `\n\nvec4 kernel() {\n  vec2 xy = (kernelPosition - 0.5) * vec2(kernelSize) * vec2(xyGridCellSize) + xyCenterPoint;\n\n  int numSamples = textureSize(centerline, 0).x;\n  int closest = 0;\n  float closestDist = distance(xy, texelFetch(centerline, ivec2(0, 0), 0).xy);\n  for (int i = 1; i < numSamples; i++) {\n    float dist = distance(xy, texelFetch(centerline, ivec2(i, 0), 0).xy);\n    if (dist < closestDist) {\n      closestDist = dist;\n      closest = i;\n    }\n  }\n\n  vec2 closestPos = texelFetch(centerline, ivec2(closest, 0), 0).xy;\n  vec2 prev, next;\n  int prevIndex, nextIndex;\n\n  if (closest == 0) {\n    prevIndex = 0;\n    nextIndex = 1;\n    prev = closestPos;\n    next = texelFetch(centerline, ivec2(1, 0), 0).xy;\n  } else if (closest == numSamples - 1) {\n    prevIndex = closest - 1;\n    nextIndex = closest;\n    prev = texelFetch(centerline, ivec2(prevIndex, 0), 0).xy;\n    next = closestPos;\n  } else {\n    vec2 before = texelFetch(centerline, ivec2(closest - 1, 0), 0).xy;\n    vec2 after = texelFetch(centerline, ivec2(closest + 1, 0), 0).xy;\n\n    if (distance(before, xy) < distance(after, xy)) {\n      prevIndex = closest - 1;\n      nextIndex = closest;\n      prev = before;\n      next = closestPos;\n    } else {\n      prevIndex = closest;\n      nextIndex = closest + 1;\n      prev = closestPos;\n      next = after;\n    }\n  }\n\n  float dist = distance(prev, next);\n  float progress = clamp(dot(xy - prev, next - prev) / dist / dist, 0.0, 1.0);\n  vec2 projectedPos = (next - prev) * vec2(progress) + prev;\n\n  return vec4(\n    (float(prevIndex) + progress) * centerlineStationInterval,\n    sign(determinant(mat2(next - prev, xy - prev))) * distance(xy, projectedPos),\n    0,\n    0\n  );\n}\n\n`;\n\n// Build XY-SL map\n/* harmony default export */ var xyslMap = ({\n  setUp() {\n    return {\n      kernel: XYSL_MAP_KERNEL,\n      output: { name: 'xyslMap', filter: 'linear' },\n      uniforms: {\n        centerline: { type: 'sharedTexture' },\n        xyCenterPoint: { type: 'vec2' },\n        xyGridCellSize: { type: 'float'},\n        centerlineStationInterval: { type: 'float'}\n      }\n    };\n  },\n\n  update(config, xyWidth, xyHeight, xyCenterPoint) {\n    return {\n      width: xyWidth,\n      height: xyHeight,\n      uniforms: {\n        xyCenterPoint: [xyCenterPoint.x, xyCenterPoint.y],\n        xyGridCellSize: config.xyGridCellSize,\n        centerlineStationInterval: config.centerlineStationInterval\n      }\n    };\n  }\n});\n\n// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/optimizeCubicPaths.js\n// Config:\n// num stations\n// num latitudes\n// station connectivity\n// latitude connectivity\n//\n// Shared:\n// lattice\n\nconst OPTIMIZE_CUBIC_SHARED = `\n\nconst int NEWTON_ITERATIONS = 16;\nconst int RELAXATION_ITERATIONS = 16;\nconst float CONVERGENCE_ERROR = 0.01;\n\n// These two consts must stay in sync.\nconst int SIMPSONS_INTERVALS = 8;\n//const float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\nconst float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float TWO_PI = PI + PI;\n\nconst float RELAXATION_ITERATIONS_F = float(RELAXATION_ITERATIONS);\nconst float SIMPSONS_INTERVALS_F = float(SIMPSONS_INTERVALS);\n\nfloat wrapAngle(float angle) {\n  angle = mod(angle, TWO_PI);\n  if (angle <= -PI) return angle + TWO_PI;\n  else if (angle > PI) return angle - TWO_PI;\n  return angle;\n}\n\nvec4 iterate(vec4 goal, float p0, float p1, float p2, float p3, float sG) {\n  float ds = sG / SIMPSONS_INTERVALS_F;\n  float sG_2 = sG * sG;\n  float sG_3 = sG_2 * sG;\n\n  vec3 dX_p = vec3(0.0);\n  vec3 dY_p = vec3(0.0);\n  vec2 guess = vec2(0.0);\n  float s = 0.0;\n\n  float theta, cosTheta, sinTheta;\n  vec3 dT_p;\n\n  for (int i = 0; i <= SIMPSONS_INTERVALS; i++) {\n    float coeff = SIMPSONS_COEFFS[i];\n\n    float a = p0;\n    float b = (-5.5 * p0 + 9.0 * p1 - 4.5 * p2 + p3) / sG;\n    float c = (9.0 * p0 - 22.5 * p1 + 18.0 * p2 - 4.5 * p3) / sG_2;\n    float d = (-4.5 * (p0 - 3.0 * p1 + 3.0 * p2 - p3)) / sG_3;\n\n    theta = (((d * s / 4.0 + c / 3.0) * s + b / 2.0) * s + a) * s;\n    cosTheta = cos(theta);\n    sinTheta = sin(theta);\n\n    float s_sG = s / sG;\n\n    dT_p = vec3(\n      // p1\n      ((3.375 * s_sG - 7.5) * s_sG + 4.5) * s_sG * s,\n\n      // p2\n      ((-3.375 * s_sG + 6.0) * s_sG - 2.25) * s_sG * s,\n\n      // sG\n      ((3.375 * (p0 - 3.0 * p1 + 3.0 * p2 - p3) * s_sG - 3.0 * (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3)) * s_sG + 0.25 * (11.0 * p0 - 18.0 * p1 + 9.0 * p2 - 2.0 * p3)) * s_sG * s_sG\n    );\n\n    dX_p -= coeff * sinTheta * dT_p;\n    dY_p += coeff * cosTheta * dT_p;\n\n    guess += coeff * vec2(cosTheta, sinTheta);\n\n    s += ds;\n  }\n\n  float hOver3 = sG / SIMPSONS_INTERVALS_F / 3.0;\n\n  vec3 delta;\n  delta.xy = goal.xy - guess * hOver3;\n  delta.z = wrapAngle(goal.z - theta);\n\n  if (abs(delta.x) + abs(delta.y) + abs(delta.z) < CONVERGENCE_ERROR)\n    return vec4(p1, p2, sG, 1.0);\n\n  dX_p.xyz *= hOver3;\n  dY_p.xyz *= hOver3;\n  dX_p.z += cosTheta;\n  dY_p.z += sinTheta;\n\n  mat3 invJacobian = inverse(transpose(mat3(dX_p, dY_p, dT_p)));\n\n  vec3 deltaP = invJacobian * delta;\n  vec4 params = vec4(p1, p2, sG, 0.0);\n  params.xyz += deltaP;\n\n  return params;\n}\n\n/* Input:\n *   start: (vec4)\n *     x: x position,\n *     y: y position,\n *     z: theta rotation,\n *     w: k curvature\n *   end: (vec4)\n *     x: x position,\n *     y: y position,\n *     z: theta rotation,\n *     w: k curvature\n *\n * Output: (vec4)\n *   x: p1,\n *   y: p2,\n *   z: sG,\n *   w: 1 if converged, 0 if not\n */\n\nvec4 optimize(vec4 start, vec4 end) {\n  // Translate and rotate start and end so that start is at the origin\n  float sinRot = sin(start.z);\n  float cosRot = cos(start.z);\n\n  vec4 diff = end - start;\n  vec4 goal;\n  goal.xy = mat2(cosRot, -sinRot, sinRot, cosRot) * diff.xy;\n  goal.z = wrapAngle(diff.z);\n  goal.w = end.w;\n\n  vec4 originalGoal = goal;\n  vec4 dGoal;\n  dGoal.x = 0.0;\n  dGoal.yzw = goal.yzw / RELAXATION_ITERATIONS_F;\n  float dK0 = start.w / RELAXATION_ITERATIONS_F;\n\n  // Relax the goal to (x, 0, 0, 0)\n  goal.yzw = vec3(0, 0, 0);\n\n  // Relax the params to (0, 0, 0, 0, goal.x)\n  float p0 = 0.0;\n  float p1 = 0.0;\n  float p2 = 0.0;\n  float p3 = 0.0;\n  float sG = goal.x;\n\n  if (sG < 0.1) return vec4(0.0);\n\n  for (int i = 0; i < RELAXATION_ITERATIONS; i++) {\n    p0 += dK0;\n    p3 += dGoal.w;\n    goal += dGoal;\n    \n    vec4 result = iterate(goal, p0, p1, p2, p3, sG);\n    p1 = result.x;\n    p2 = result.y;\n    sG = result.z;\n  }\n\n  goal = originalGoal;\n\n  for (int i = 0; i < NEWTON_ITERATIONS; i++) {\n    vec4 result = iterate(goal, p0, p1, p2, p3, sG);\n    if (result.w == 1.0) {\n      result.w = step(0.0, result.z);\n      return result;\n    }\n\n    p1 = result.x;\n    p2 = result.y;\n    sG = result.z;\n  }\n\n  return vec4(p1, p2, sG, 0.0);\n}\n\n`;\n\nconst OPTIMIZE_CUBIC_KERNEL = OPTIMIZE_CUBIC_SHARED + `\n\n// width: station * latitude index\n// height: station_conn * lattice_conn\n//\n// lattice:\n// width: latitudes\n// height: stations\n\nvec4 kernel() {\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\n\n  int endStation = indexes.x / numLatitudes;\n  int endLatitude = int(mod(float(indexes.x), float(numLatitudes)));\n\n  int startStation = endStation - stationConnectivity + indexes.y / latitudeConnectivity;\n  int startLatitude = endLatitude - latitudeConnectivity / 2 + int(mod(float(indexes.y), float(latitudeConnectivity)));\n\n  if (startStation < 0 || startStation >= numStations || startLatitude < 0 || startLatitude >= numLatitudes)\n    return vec4(0.0);\n\n  vec4 start = texelFetch(lattice, ivec2(startLatitude, startStation), 0);\n  vec4 end = texelFetch(lattice, ivec2(endLatitude, endStation), 0);\n\n  return optimize(start, end);\n}\n\n`;\n\nconst OPTIMIZE_CUBIC_FROM_VEHICLE_KERNEL = OPTIMIZE_CUBIC_SHARED + `\n\nvec4 kernel() {\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\n\n  vec4 start = vec4(0, 0, 0, curvVehicle);\n  vec4 end = texelFetch(lattice, indexes, 0);\n\n  return optimize(start, end);\n}\n\n`;\n\n/* harmony default export */ var optimizeCubicPaths = ({\n  setUp() {\n    return [\n      { // Cubic paths between lattice nodes\n        kernel: OPTIMIZE_CUBIC_KERNEL,\n        output: { name: 'cubicPaths', read: true },\n        uniforms: {\n          lattice: { type: 'sharedTexture' },\n          numStations: { type: 'int' },\n          numLatitudes: { type: 'int' },\n          stationConnectivity: { type: 'int' },\n          latitudeConnectivity: { type: 'int' }\n        }\n      },\n      { // Cubic paths from vehicle to lattice nodes\n        kernel: OPTIMIZE_CUBIC_FROM_VEHICLE_KERNEL,\n        output: { name: 'cubicPathsFromVehicle', read: true },\n        uniforms: {\n          lattice: { type: 'sharedTexture' },\n          curvVehicle: { type: 'float' }\n        }\n      }\n    ]\n  },\n\n  update(config, pose) {\n    return [\n      { // Cubic paths between lattice nodes\n        width: config.lattice.numStations * config.lattice.numLatitudes,\n        height: config.lattice.stationConnectivity * config.lattice.latitudeConnectivity,\n        uniforms: {\n          numStations: config.lattice.numStations,\n          numLatitudes: config.lattice.numLatitudes,\n          stationConnectivity: config.lattice.stationConnectivity,\n          latitudeConnectivity: config.lattice.latitudeConnectivity,\n        }\n      },\n      { // Cubic paths from vehicle to lattice nodes\n        width: config.lattice.numLatitudes,\n        height: config.lattice.stationConnectivity,\n        uniforms: {\n          curvVehicle: pose.curv\n        }\n      }\n    ];\n  }\n});\n\n// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/optimizeQuinticPaths.js\nconst OPTIMIZE_KERNEL = `\n\nconst int NEWTON_ITERATIONS = 32;\nconst int RELAXATION_ITERATIONS = 32;\nconst float CONVERGENCE_ERROR = 0.01;\n\n// These two consts must stay in sync.\nconst int SIMPSONS_INTERVALS = 8;\nconst float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float TWO_PI = PI + PI;\n\nconst float RELAXATION_ITERATIONS_F = float(RELAXATION_ITERATIONS);\nconst float SIMPSONS_INTERVALS_F = float(SIMPSONS_INTERVALS);\n\nfloat wrapAngle(float angle) {\n  angle = mod(angle, TWO_PI);\n  if (angle <= -PI) return angle + TWO_PI;\n  else if (angle > PI) return angle - TWO_PI;\n  return angle;\n}\n\nvec4 iterate(vec4 goal, float p0, float p1, float p2, float p3, float p4, float p5, float sG) {\n  float ds = sG / SIMPSONS_INTERVALS_F;\n  float sG_2 = sG * sG;\n  float sG_3 = sG_2 * sG;\n\n  vec3 dX_p = vec3(0.0);\n  vec3 dY_p = vec3(0.0);\n  vec2 guess = vec2(0.0);\n  float s = 0.0;\n\n  float theta, cosTheta, sinTheta;\n  vec3 dT_p;\n\n  for (int i = 0; i <= SIMPSONS_INTERVALS; i++) {\n    float coeff = SIMPSONS_COEFFS[i];\n\n    float a = p0;\n    float b = p1;\n    float c = p2 / 2.0;\n    float d = (-71.875 * p0 + 81.0 * p3 - 10.125 * p4 + p5 - 21.25 * p1 * sG - 2.75 * p2 * sG_2) / sG_3;\n    float e = (166.5 * p0 - 202.5 * p3 + 40.5 * p4 - 4.5 * p5 + 45.0 * p1 * sG + 4.5 * p2 * sG_2) / (sG_2 * sG_2);\n    float f = (-95.625 * p0 + 121.5 * p3 - 30.375 * p4 + 4.5 * p5 - 24.75 * p1 * sG - 2.25 * p2 * sG_2) / (sG_2 * sG_3);\n\n    theta = (((((f * s / 6.0 + e / 5.0) * s + d / 4.0) * s + c / 3.0) * s + b / 2.0) * s + a) * s;\n    cosTheta = cos(theta);\n    sinTheta = sin(theta);\n\n    float s_2 = s * s;\n    float s_sG = s / sG;\n    float s_sG_2 = s_sG * s_sG;\n    float s_sG_3 = s_sG_2 * s_sG;\n    float s_sG_4 = s_sG_3 * s_sG;\n    float s_sG_5 = s_sG_4 * s_sG;\n\n    dT_p = vec3(\n      // p3\n      ((20.25 * s_sG - 40.5) * s_sG + 20.25) * s_sG_3 * s,\n\n      // p4\n      ((-5.0625 * s_sG + 8.1) * s_sG - 2.53125) * s_sG_3 * s,\n\n      // sG\n      (53.90625 * p0 - 60.75 * p3 + 7.59375 * p4 - 0.75 * p5) * s_sG_4 + 10.625 * p1 * s * s_sG_3 + 0.6875 * p2 * s_2 * s_sG_2 + (-133.2 * p0 + 162.0 * p3 - 32.4 * p4 + 3.6 * p5) * s_sG_5 + (-27.0) * p1 * s * s_sG_4 - 1.8 * p2 * s_2 * s_sG_3 + (79.6875 * p0 - 101.25 * p3 + 25.3125 * p4 - 3.75 * p5) * s_sG_5 * s_sG + 16.5 * p1 * s * s_sG_5 + 1.125 * p2 * s_2 * s_sG_4\n    );\n\n    dX_p -= coeff * sinTheta * dT_p;\n    dY_p += coeff * cosTheta * dT_p;\n\n    guess += coeff * vec2(cosTheta, sinTheta);\n\n    s += ds;\n  }\n\n  float hOver3 = sG / SIMPSONS_INTERVALS_F / 3.0;\n\n  vec3 delta;\n  delta.xy = goal.xy - guess * hOver3;\n  delta.z = wrapAngle(goal.z - theta);\n\n  if (abs(delta.x) + abs(delta.y) + abs(delta.z) < CONVERGENCE_ERROR)\n    return vec4(p3, p4, sG, 1.0);\n\n  dX_p.xyz *= hOver3;\n  dY_p.xyz *= hOver3;\n  dX_p.z += cosTheta;\n  dY_p.z += sinTheta;\n\n  mat3 invJacobian = inverse(transpose(mat3(dX_p, dY_p, dT_p)));\n\n  vec3 deltaP = invJacobian * delta;\n  vec4 params = vec4(p3, p4, sG, 0.0);\n  params.xyz += deltaP;\n\n  return params;\n}\n\nvec4 optimize(vec4 start, vec4 end) {\n  // Translate and rotate start and end so that start is at the origin\n  float sinRot = sin(start.z);\n  float cosRot = cos(start.z);\n\n  vec4 diff = end - start;\n  vec4 goal;\n  goal.xy = mat2(cosRot, -sinRot, sinRot, cosRot) * diff.xy;\n  goal.z = wrapAngle(diff.z);\n  goal.w = end.w;\n\n  vec4 originalGoal = goal;\n  vec4 dGoal;\n  dGoal.x = 0.0;\n  dGoal.yzw = goal.yzw / RELAXATION_ITERATIONS_F;\n  float d_K0 = start.w / RELAXATION_ITERATIONS_F;\n  float d_dK0 = dCurvVehicle / RELAXATION_ITERATIONS_F;\n  float d_ddK0 = ddCurvVehicle / RELAXATION_ITERATIONS_F;\n\n  // Relax the goal to (x, 0, 0, 0)\n  goal.yzw = vec3(0, 0, 0);\n\n  // Relax the params to (0, 0, 0, 0, goal.x)\n  float p0 = 0.0;\n  float p1 = 0.0;\n  float p2 = 0.0;\n  float p3 = 0.0;\n  float p4 = 0.0;\n  float p5 = 0.0;\n  float sG = goal.x;\n\n  if (sG < 0.1) return vec4(0.0);\n\n  for (int i = 0; i < RELAXATION_ITERATIONS; i++) {\n    p0 += d_K0;\n    p1 += d_dK0;\n    p2 += d_ddK0;\n    p5 += dGoal.w;\n    goal += dGoal;\n    \n    vec4 result = iterate(goal, p0, p1, p2, p3, p4, p5, sG);\n    p3 = result.x;\n    p4 = result.y;\n    sG = result.z;\n  }\n\n  goal = originalGoal;\n\n  for (int i = 0; i < NEWTON_ITERATIONS; i++) {\n    vec4 result = iterate(goal, p0, p1, p2, p3, p4, p5, sG);\n    if (result.w == 1.0) {\n      result.w = step(0.0, result.z);\n      return result;\n    }\n\n    p3 = result.x;\n    p4 = result.y;\n    sG = result.z;\n  }\n\n  return vec4(p3, p4, sG, 0.0);\n}\n\nvec4 kernel() {\n  ivec2 latticeIndexes = ivec2(kernelPosition * vec2(kernelSize));\n\n  vec4 start = vec4(0, 0, 0, curvVehicle);\n  vec4 end = texelFetch(lattice, latticeIndexes, 0);\n\n  return optimize(start, end);\n}\n\n`;\n\n// Quintic spiral path optimizer\n//   * Start of paths is the vehicle pose\n//     * x-pos, y-pos, and rotation aren't needed, since the lattice origin is the vehicle pose\n//     * So assume position and rotation are 0\n//   * Ends of paths are all latitudes within the first (stationConnectivity) stations\n/* harmony default export */ var optimizeQuinticPaths = ({\n  setUp() {\n    return {\n      kernel: OPTIMIZE_KERNEL,\n      output: { name: 'quinticPathsFromVehicle', read: true },\n      uniforms: {\n        lattice: { type: 'sharedTexture' },\n        curvVehicle: { type: 'float' },\n        dCurvVehicle: { type: 'float' },\n        ddCurvVehicle: { type: 'float' }\n      }\n    };\n  },\n\n  update(config, pose) {\n    return {\n      width: config.lattice.numLatitudes,\n      height: config.lattice.stationConnectivity,\n      uniforms: {\n        curvVehicle: pose.curv,\n        dCurvVehicle: pose.dCurv,\n        ddCurvVehicle: pose.ddCurv\n      }\n    };\n  }\n});\n\n// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/graphSearchShared.js\nconst SHARED_SHADER = `\n\nconst float smallV = 0.01;\nvec4 pathSamples[128];\nfloat pathSampleCurvRates[128];\n\nfloat calculateAcceleration(int index, float initialVelocitySq, float distance) {\n  if (index <= 4) {\n    // [aMaxHard, aMinHard, aMaxSoft, aMinSoft, 0]\n    return accelerationProfiles[index];\n  } else {\n    float finalVelocity = finalVelocityProfiles[index - 5];\n    if (distance < 0.001) return 0.0;\n    return clamp((finalVelocity * finalVelocity - initialVelocitySq) / (2.0 * distance), accelerationProfiles[1], accelerationProfiles[0]);\n  }\n}\n\nvec2 xy2sl(vec4 xytk) {\n  vec2 xy = xytk.xy + rearAxleToCenter * vec2(cos(xytk.z), sin(xytk.z));\n  vec2 xyTexCoords = (xy - xyCenterPoint) / vec2(textureSize(xyslMap, 0)) / vec2(xyGridCellSize) + 0.5;\n  return texture(xyslMap, xyTexCoords).xy;\n}\n\nfloat sampleStaticCost(vec4 xytk) {\n  vec2 sl = xy2sl(xytk);\n  vec2 slTexCoords = (sl - slCenterPoint) / vec2(textureSize(slObstacleGrid, 0)) / vec2(slGridCellSize) + 0.5;\n  float obstacleCost = texture(slObstacleGrid, slTexCoords).r;\n\n  if (obstacleCost >= 0.75) return -1.0; // Infinite cost\n\n  obstacleCost = step(0.25, obstacleCost) * obstacleHazardCost;\n\n  float absLatitude = abs(sl.y);\n  if (absLatitude >= laneShoulderLatitude) return -1.0;\n\n  float laneCost = abs(absLatitude - laneCenterLatitude) * laneCostSlope + step(0.0, -sl.y * sign(lanePreference)) * lanePreferenceDiscount;\n\n  return obstacleCost + laneCost;\n}\n\nfloat sampleDynamicCost(vec4 xytk, float time, float velocity, float acceleration) {\n  vec2 sl = xy2sl(xytk);\n  vec2 slTexCoords = (sl - slCenterPoint) / vec2(textureSize(slDynamicObstacleGrid, 0).xy) / vec2(slGridCellSize) + 0.5;\n  float dynamicFrame = floor(time / dynamicFrameTime);\n\n  float obstacleCost = texture(slDynamicObstacleGrid, vec3(slTexCoords, dynamicFrame)).r;\n\n  if (obstacleCost > 0.75) return -1.0; // Infinite cost\n\n  return step(0.25, obstacleCost) * obstacleHazardCost;\n}\n\nfloat calculateAverageStaticCost(int numSamples) {\n  float averageStaticCost = 0.0;\n\n  for (int i = 0; i < numSamples; i++) {\n    float cost = sampleStaticCost(pathSamples[i]);\n\n    if (cost < 0.0) return cost;\n\n    averageStaticCost += cost;\n  }\n\n  averageStaticCost /= float(numSamples);\n\n  return averageStaticCost;\n}\n\nfloat calculateAverageDynamicCost(int numSamples, float pathLength, float initialTime, float initialVelocity, float acceleration, float abandonThreshold) {\n  float s = 0.0;\n  float ds = pathLength / float(numSamples - 1);\n  float averageDynamicCost = 0.0;\n  float maxVelocity = 0.0;\n  float maxLateralAcceleration = 0.0;\n  float numSamples_f = float(numSamples);\n\n  for (int i = 0; i < numSamples; i++) {\n    vec4 pathSample = pathSamples[i]; // vec4(x-pos, y-pos, theta (rotation), kappa (curvature))\n\n    float velocitySq = 2.0 * acceleration * s + initialVelocity * initialVelocity;\n    float velocity = max(smallV, sqrt(max(0.0, velocitySq)));\n    maxVelocity = max(maxVelocity, velocity);\n    maxLateralAcceleration = max(maxLateralAcceleration, abs(pathSample.w * velocity * velocity));\n\n    float time = 2.0 * s / (initialVelocity + velocity) + initialTime;\n\n    float dCurv = pathSampleCurvRates[i] * velocity;\n    if (dCurv > dCurvatureMax) return -1.0;\n\n    float cost = sampleDynamicCost(pathSample, time, velocity, acceleration);\n    if (cost < 0.0) return cost;\n\n    averageDynamicCost += cost;\n    if (averageDynamicCost / numSamples_f >= abandonThreshold) return -1.0;\n\n    s += ds;\n  }\n\n  averageDynamicCost /= numSamples_f;\n\n  // Apply speeding penality if any velocity along the trajectory is over the speed limit\n  averageDynamicCost += step(speedLimit, maxVelocity) * speedLimitPenalty;\n\n  // Apply hard acceleration/deceleration penalties if the acceleration/deceleration exceeds the soft limits\n  averageDynamicCost += step(accelerationProfiles[2] + 0.0001, acceleration) * hardAccelerationPenalty;\n  averageDynamicCost += (1.0 - step(accelerationProfiles[3], acceleration)) * hardDecelerationPenalty;\n\n  // Penalize lateral acceleration\n  averageDynamicCost += step(softLateralAccelerationLimit, maxLateralAcceleration) * softLateralAccelerationPenalty;\n  averageDynamicCost += linearLateralAccelerationPenalty * maxLateralAcceleration;\n\n  return averageDynamicCost;\n}\n\nvec3 calculateAVT(int accelerationIndex, float initialVelocity, float initialTime, float pathLength) {\n  float initialVelocitySq = initialVelocity * initialVelocity;\n  float acceleration = calculateAcceleration(accelerationIndex, initialVelocitySq, pathLength);\n\n  float finalVelocitySq = 2.0 * acceleration * pathLength + initialVelocitySq;\n  float finalVelocity = max(smallV, sqrt(max(0.0, finalVelocitySq)));\n\n  float finalTime = initialTime;\n\n  if (acceleration == 0.0) {\n    finalTime += pathLength / finalVelocity;\n  } else if (finalVelocitySq <= 0.0) { // Calculate final time if the vehicle stops before the end of the trajectory\n    float distanceLeft = pathLength - (smallV * smallV - initialVelocitySq) / (2.0 * acceleration);\n    finalTime += (finalVelocity - initialVelocity) / acceleration + distanceLeft / smallV;\n  } else {\n    finalTime += 2.0 * pathLength / (finalVelocity + initialVelocity);\n  }\n\n  return vec3(acceleration, finalVelocity, finalTime);\n}\n\n`;\n\nconst SAMPLE_CUBIC_PATH_FN = `\n\nint sampleCubicPath(vec4 start, vec4 end, vec4 cubicPathParams) {\n  float p0 = start.w;\n  float p1 = cubicPathParams.x;\n  float p2 = cubicPathParams.y;\n  float p3 = end.w;\n  float sG = cubicPathParams.z;\n\n  if (sG <= 0.0) return 0;\n\n  int numSamples = int(ceil(sG / pathSamplingStep)) + 1;\n\n  float sG_2 = sG * sG;\n  float sG_3 = sG_2 * sG;\n\n  float a = p0;\n  float b = (-5.5 * p0 + 9.0 * p1 - 4.5 * p2 + p3) / sG;\n  float c = (9.0 * p0 - 22.5 * p1 + 18.0 * p2 - 4.5 * p3) / sG_2;\n  float d = (-4.5 * (p0 - 3.0 * p1 + 3.0 * p2 - p3)) / sG_3;\n\n  pathSamples[0] = start;\n\n  float ds = sG / float(numSamples - 1);\n  float s = ds;\n  vec2 dxy = vec2(0);\n  vec2 prevCosSin = vec2(cos(start.z), sin(start.z));\n\n  for (int i = 1; i < numSamples; i++) {\n    float rot = (((d * s / 4.0 + c / 3.0) * s + b / 2.0) * s + a) * s + start.z;\n    float curv = ((d * s + c) * s + b) * s + a;\n\n    vec2 cosSin = vec2(cos(rot), sin(rot));\n    dxy = dxy * vec2(float(i - 1) / float(i)) + (cosSin + prevCosSin) / vec2(2 * i);\n\n    pathSamples[i] = vec4(dxy * vec2(s) + start.xy, rot, curv);\n    pathSampleCurvRates[i] = b + s * (2.0 * c + 3.0 * d * s);\n\n    s += ds;\n    prevCosSin = cosSin;\n  }\n\n  return numSamples;\n}\n\n`;\n\nconst SAMPLE_QUINTIC_PATH_FN = `\n\nint sampleQuinticPath(vec4 start, vec4 end, vec4 quinticPathParams) {\n  float p0 = start.w;\n  float p1 = dCurvVehicle;\n  float p2 = ddCurvVehicle;\n  float p3 = quinticPathParams.x;\n  float p4 = quinticPathParams.y;\n  float p5 = end.w;\n  float sG = quinticPathParams.z;\n\n  if (sG <= 0.0) return 0;\n\n  int numSamples = int(ceil(sG / pathSamplingStep)) + 1;\n\n  float sG_2 = sG * sG;\n  float sG_3 = sG_2 * sG;\n\n  float a = p0;\n  float b = p1;\n  float c = p2 / 2.0;\n  float d = (-71.875 * p0 + 81.0 * p3 - 10.125 * p4 + p5 - 21.25 * p1 * sG - 2.75 * p2 * sG_2) / sG_3;\n  float e = (166.5 * p0 - 202.5 * p3 + 40.5 * p4 - 4.5 * p5 + 45.0 * p1 * sG + 4.5 * p2 * sG_2) / (sG_2 * sG_2);\n  float f = (-95.625 * p0 + 121.5 * p3 - 30.375 * p4 + 4.5 * p5 - 24.75 * p1 * sG - 2.25 * p2 * sG_2) / (sG_2 * sG_3);\n\n  pathSamples[0] = start;\n\n  float ds = sG / float(numSamples - 1);\n  float s = ds;\n  vec2 dxy = vec2(0);\n  vec2 prevCosSin = vec2(cos(start.z), sin(start.z));\n\n  for (int i = 1; i < numSamples; i++) {\n    float rot = (((((f * s / 6.0 + e / 5.0) * s + d / 4.0) * s + c / 3.0) * s + b / 2.0) * s + a) * s + start.z;\n    float curv = ((((f * s + e) * s + d) * s + c) * s + b) * s + a;\n\n    vec2 cosSin = vec2(cos(rot), sin(rot));\n    dxy = dxy * vec2(float(i - 1) / float(i)) + (cosSin + prevCosSin) / vec2(2 * i);\n\n    pathSamples[i] = vec4(dxy * vec2(s) + start.xy, rot, curv);\n    pathSampleCurvRates[i] = b + s * (2.0 * c + s * (3.0 * d + s * (4.0 * e + 5.0 * f * s)));\n\n    s += ds;\n    prevCosSin = cosSin;\n  }\n\n  return numSamples;\n}\n\n`;\n\nconst NUM_ACCELERATION_PROFILES = 8;\nconst NUM_VELOCITY_RANGES = 4;\nconst NUM_TIME_RANGES = 2;\n\nconst SHARED_UNIFORMS = {\n  xyslMap: { type: 'outputTexture' },\n  slObstacleGrid: { type: 'outputTexture', name: 'slObstacleGridDilated' },\n  slDynamicObstacleGrid: { type: 'outputTexture', name: 'slDynamicObstacleGrid', textureType: '2DArray' },\n  accelerationProfiles: { type: 'float', length: 5 },\n  finalVelocityProfiles: { type: 'float', length: 3 },\n  xyCenterPoint: { type: 'vec2' },\n  xyGridCellSize: { type: 'float' },\n  slCenterPoint: { type: 'vec2' },\n  slGridCellSize: { type: 'float'},\n  laneCenterLatitude: { type: 'float'},\n  laneShoulderLatitude: { type: 'float'},\n  laneCostSlope: { type: 'float'},\n  lanePreference: { type: 'float' },\n  lanePreferenceDiscount: { type: 'float' },\n  obstacleHazardCost: { type: 'float' },\n  speedLimit: { type: 'float' },\n  speedLimitPenalty: { type: 'float' },\n  hardAccelerationPenalty: { type: 'float' },\n  hardDecelerationPenalty: { type: 'float' },\n  softLateralAccelerationLimit: { type: 'float' },\n  softLateralAccelerationPenalty: { type: 'float' },\n  linearLateralAccelerationPenalty: { type: 'float' },\n  dCurvatureMax: { type: 'float' },\n  pathSamplingStep: { type: 'float' },\n  rearAxleToCenter: { type: 'float' },\n  dynamicFrameTime: { type: 'float' }\n};\n\nfunction buildUniformValues(config, xyCenterPoint, slCenterPoint, dynamicFrameTime) {\n  return {\n    accelerationProfiles: [3.5, -6.5, 2.0, -3.0, 0],\n    finalVelocityProfiles: [0.999 * config.speedLimit, 1.0, 0.01],\n    xyCenterPoint: [xyCenterPoint.x, xyCenterPoint.y],\n    xyGridCellSize: config.xyGridCellSize,\n    slCenterPoint: [slCenterPoint.x, slCenterPoint.y],\n    slGridCellSize: config.slGridCellSize,\n    laneCenterLatitude: config.laneCenterLatitude,\n    laneShoulderLatitude: config.laneShoulderLatitude,\n    laneCostSlope: config.laneCostSlope,\n    lanePreference: config.lanePreference,\n    lanePreferenceDiscount: config.lanePreferenceDiscount,\n    obstacleHazardCost: config.obstacleHazardCost,\n    speedLimit: config.speedLimit,\n    speedLimitPenalty: config.speedLimitPenalty,\n    hardAccelerationPenalty: config.hardAccelerationPenalty,\n    hardDecelerationPenalty: config.hardDecelerationPenalty,\n    softLateralAccelerationLimit: config.softLateralAccelerationLimit,\n    softLateralAccelerationPenalty: config.softLateralAccelerationPenalty,\n    linearLateralAccelerationPenalty: config.linearLateralAccelerationPenalty,\n    dCurvatureMax: config.dCurvatureMax,\n    pathSamplingStep: config.pathSamplingStep,\n    rearAxleToCenter: config.rearAxleToCenter,\n    dynamicFrameTime: dynamicFrameTime\n  };\n}\n\n\n\n// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/pathFromVehicleCosts.js\n\n\nfunction fromVehiclePathCostsKernel(pathType) {\n  return SHARED_SHADER + (pathType == 'cubic' ? SAMPLE_CUBIC_PATH_FN : SAMPLE_QUINTIC_PATH_FN) +\n\n`\n\n/* Calculate cost of a {cubic|quintic} path from vehicle to (stationConnectivity * numLatitudes * numAccelerations) nodes\n *   width: numLatitudes\n *   height: station * numAccelerations\n */\nvec4 kernel() {\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\n\n  int latitude = indexes.x;\n  int station = indexes.y / numAccelerations;\n  int accelerationIndex = int(mod(float(indexes.y), float(numAccelerations)));\n\n  vec4 pathStart = vec4(0, 0, 0, curvVehicle);\n  vec4 pathEnd = texelFetch(lattice, ivec2(latitude, station), 0);\n\n  vec4 pathParams = texelFetch(pathsFromVehicle, ivec2(latitude, station), 0);\n\n  // If the path didn't converge\n  if (pathParams.w == 0.0) return vec4(-1);\n\n  int numSamples = ${pathType == 'cubic' ? 'sampleCubicPath' : 'sampleQuinticPath'}(pathStart, pathEnd, pathParams);\n  float pathLength = pathParams.z;\n\n  if (numSamples < 2) return vec4(-1);\n\n  float averageStaticCost = calculateAverageStaticCost(numSamples);\n  if (averageStaticCost < 0.0) return vec4(-1);\n\n  int slIndex = station * kernelSize.x + latitude;\n  float hysteresisAdjustment = (slIndex == firstLatticePoint || slIndex == secondLatticePoint) ?  0.0 : hysteresisDiscount;\n  averageStaticCost += hysteresisAdjustment;\n\n  vec3 avt = calculateAVT(accelerationIndex, velocityVehicle, 0.0, pathLength);\n  float acceleration = avt.x;\n  float finalVelocity = avt.y;\n  float finalTime = avt.z;\n\n  float averageDynamicCost = calculateAverageDynamicCost(numSamples, pathLength, 0.0, velocityVehicle, acceleration, 1.0 / 0.0);\n  if (averageDynamicCost < 0.0) return vec4(-1);\n\n  averageDynamicCost += accelerationChangePenalty;\n\n  // The cost of a trajectory is the average sample cost scaled by the path length\n  float totalCost = (averageStaticCost + averageDynamicCost + ${pathType == 'cubic' ? '(cubicPathPenalty * velocityVehicle * velocityVehicle)' : '0.0'}) * pathLength;\n  ${pathType != 'cubic' ? 'totalCost = -1.0;' : ''}\n\n  return vec4(totalCost, finalVelocity, finalTime, ${pathType == 'cubic' ? '-2' : '-1'});\n}\n\n`;\n}\n\n/* harmony default export */ var pathFromVehicleCosts = ({\n  setUp() {\n    return [\n      {\n        kernel: fromVehiclePathCostsKernel('cubic'),\n        output: { name: 'cubicPathFromVehicleCosts' },\n        uniforms: Object.assign({}, SHARED_UNIFORMS, {\n          lattice: { type: 'sharedTexture' },\n          pathsFromVehicle: { type: 'outputTexture', name: 'cubicPathsFromVehicle' },\n          firstLatticePoint: { type: 'int' },\n          secondLatticePoint: { type: 'int' },\n          velocityVehicle: { type: 'float' },\n          curvVehicle: { type: 'float' },\n          numAccelerations: { type: 'int' },\n          cubicPathPenalty: { type: 'float' },\n          hysteresisDiscount: { type: 'float' },\n          accelerationChangePenalty: { type: 'float' }\n        })\n      },\n      {\n        kernel: fromVehiclePathCostsKernel('quintic'),\n        output: { name: 'quinticPathFromVehicleCosts' },\n        uniforms: Object.assign({}, SHARED_UNIFORMS, {\n          lattice: { type: 'sharedTexture' },\n          pathsFromVehicle: { type: 'outputTexture', name: 'quinticPathsFromVehicle' },\n          firstLatticePoint: { type: 'int' },\n          secondLatticePoint: { type: 'int' },\n          velocityVehicle: { type: 'float' },\n          curvVehicle: { type: 'float' },\n          dCurvVehicle: { type: 'float' },\n          ddCurvVehicle: { type: 'float' },\n          numAccelerations: { type: 'int' },\n          hysteresisDiscount: { type: 'float' },\n          accelerationChangePenalty: { type: 'float' }\n        })\n      }\n    ];\n  },\n\n  update(config, pose, xyCenterPoint, slCenterPoint, firstLatticePoint, secondLatticePoint, dynamicFrameTime) {\n    return [\n      {\n        width: config.lattice.numLatitudes,\n        height: config.lattice.stationConnectivity * NUM_ACCELERATION_PROFILES,\n        uniforms: Object.assign({}, buildUniformValues(config, xyCenterPoint, slCenterPoint, dynamicFrameTime), {\n          firstLatticePoint: firstLatticePoint,\n          secondLatticePoint: secondLatticePoint,\n          velocityVehicle: pose.velocity,\n          curvVehicle: pose.curv,\n          numAccelerations: NUM_ACCELERATION_PROFILES,\n          cubicPathPenalty: config.cubicPathPenalty,\n          hysteresisDiscount: config.hysteresisDiscount,\n          accelerationChangePenalty: config.accelerationChangePenalty\n        })\n      },\n      {\n        width: config.lattice.numLatitudes,\n        height: config.lattice.stationConnectivity * NUM_ACCELERATION_PROFILES,\n        uniforms: Object.assign({}, buildUniformValues(config, xyCenterPoint, slCenterPoint, dynamicFrameTime), {\n          firstLatticePoint: firstLatticePoint,\n          secondLatticePoint: secondLatticePoint,\n          velocityVehicle: pose.velocity,\n          curvVehicle: pose.curv,\n          dCurvVehicle: pose.dCurv,\n          ddCurvVehicle: pose.ddCurv,\n          numAccelerations: NUM_ACCELERATION_PROFILES,\n          hysteresisDiscount: config.hysteresisDiscount,\n          accelerationChangePenalty: config.accelerationChangePenalty\n        })\n      }\n    ];\n  }\n});\n\n// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/graphSearch.js\n/* State Lattice Cost Map\n * \n * 5-dimensional node: station, latitude, acceleration profile, velocity, time\n *\n * A draw call per station s\n *   * Input to kernel: latitude l, acceleration profile a, velocity range v, time range t\n *   * Find all SL vertices that can connect to this node\n *   * For each of those vertices, check if any terminate in this specific velocity and time range\n *     * Based on initial velocity, initial time, and acceleration\n *     * Each connected SL vertex should have a * v * t nodes that could possibly terminate at this node\n *   * For all valid edges, find the one with the lowest cost\n *\n * Input:\n *   * 2D texture array cost map\n *     * Height: num of latitudes (~20)\n *     * Width: num of acceleration profiles * num of time ranges * num of velocity ranges (8 * 2 * 4 = ~64)\n *       * A flattened 3D array:\n *         d1: acceleration\n *         d2: velocity\n *         d3: time\n *     * Layer: num of stations (~10)\n *   \n * Output:\n *   * 2D texture slice of the next station in the input 2D texture array cost map\n *\n * Cost Map Elements:\n *   * Traversal cost so far\n *   * Ending velocity\n *   * Ending time\n *   * Index of parent node\n *\n * Since one cubic path can be shared between multiple trajectories, they need to be pre-optimized.\n *\n * Quintic Paths:\n *   Stations 0 through (numStations - 1) correspond to the stations on the lattice; however,\n *   a new station (station -1) will be used to signifiy the single vehicle pose node. Either\n *   a cubic path or quintic path can be used to connect this single node to the lattice\n *   (depending on vehicle velocity). At station -1, latitude 0 will correspond to a cubic path,\n *   and latitude 1 will correspond to a quintic path. All other latitudes will be skipped.\n */\n\n\n\nconst SOLVE_STATION_KERNEL =\n  SHARED_SHADER +\n  SAMPLE_CUBIC_PATH_FN +\n  SAMPLE_QUINTIC_PATH_FN +\n\n`\n\nvec4 kernel() {\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\n\n  int latitude = indexes.y;\n\n  int numPerTime = numAccelerations * numVelocities;\n  int timeIndex = indexes.x / numPerTime;\n  indexes.x -= timeIndex * numPerTime;\n  int velocityIndex = indexes.x / numAccelerations;\n  int accelerationIndex = int(mod(float(indexes.x), float(numAccelerations)));\n\n  int minLatitude = max(latitude - latitudeConnectivity / 2, 0);\n  int maxLatitude = min(latitude + latitudeConnectivity / 2, numLatitudes - 1);\n\n  int slIndex = station * numLatitudes + latitude;\n\n  vec4 pathEnd = texelFetch(lattice, ivec2(latitude, station), 0);\n\n  float minVelocity = velocityRanges[velocityIndex];\n  float maxVelocity = velocityRanges[velocityIndex + 1];\n\n  float minTime = timeRanges[timeIndex];\n  float maxTime = timeRanges[timeIndex + 1];\n\n  vec4 bestTrajectory = vec4(-1); // -1 means infinite cost\n  float bestTerminalCost = 1.0 / 0.0;\n\n  float hysteresisAdjustment = (slIndex == firstLatticePoint || slIndex == secondLatticePoint) ?  0.0 : hysteresisDiscount;\n\n  for (int prevStation = max(station - stationConnectivity, 0); prevStation < station; prevStation++) {\n    int stationConnectivityIndex = prevStation - station + stationConnectivity;\n\n    for (int prevLatitude = minLatitude; prevLatitude <= maxLatitude; prevLatitude++) {\n      int latitudeConnectivityIndex = prevLatitude - latitude + latitudeConnectivity / 2;\n      int connectivityIndex = stationConnectivityIndex * latitudeConnectivity + latitudeConnectivityIndex;\n\n      vec4 pathStart = texelFetch(lattice, ivec2(prevLatitude, prevStation), 0);\n      vec4 cubicPathParams = texelFetch(cubicPaths, ivec2(slIndex, connectivityIndex), 0);\n\n      // If the path didn't converge\n      if (cubicPathParams.w == 0.0) continue;\n\n      int numSamples = sampleCubicPath(pathStart, pathEnd, cubicPathParams);\n      float pathLength = cubicPathParams.z;\n\n      if (numSamples < 2) continue;\n\n      float averageStaticCost = calculateAverageStaticCost(numSamples);\n      if (averageStaticCost < 0.0) continue;\n\n      averageStaticCost += hysteresisAdjustment;\n\n      if (averageStaticCost * pathLength >= bestTerminalCost) continue;\n\n      for (int prevVelocity = 0; prevVelocity < numVelocities; prevVelocity++) {\n        for (int prevTime = 0; prevTime < numTimes; prevTime++) {\n          for (int prevAccel = 0; prevAccel < numAccelerations; prevAccel++) {\n            int avtIndex = prevTime * numPerTime + prevVelocity * numAccelerations + prevAccel;\n\n            // Cost table entry:\n            //   x: cost so far\n            //   y: end velocity\n            //   z: end time\n            //   w: parent index\n            vec4 costTableEntry = texelFetch(costTable, ivec3(avtIndex, prevLatitude, prevStation), 0);\n\n            // If cost entry is infinity\n            if (costTableEntry.x < 0.0 || averageStaticCost * pathLength + costTableEntry.x >= bestTerminalCost) continue;\n\n            vec3 avt = calculateAVT(accelerationIndex, costTableEntry.y, costTableEntry.z, pathLength);\n            float acceleration = avt.x;\n            float finalVelocity = avt.y;\n            float finalTime = avt.z;\n\n            if (averageStaticCost * pathLength + costTableEntry.x + extraTimePenalty * finalTime >= bestTerminalCost) continue;\n\n            // If the calculated final velocity does not match this fragment's velocity range, then skip this trajectory\n            if (finalVelocity < minVelocity || finalVelocity >= maxVelocity) continue;\n\n            // If the calculated final time does not match this fragment's time range, then skip this trajectory\n            if (finalTime < minTime || finalTime >= maxTime) continue;\n\n            float abandonThreshold = (bestTerminalCost - extraTimePenalty * finalTime - costTableEntry.x) / pathLength - averageStaticCost;\n            float averageDynamicCost = calculateAverageDynamicCost(numSamples, pathLength, costTableEntry.z, costTableEntry.y, acceleration, abandonThreshold);\n            if (averageDynamicCost < 0.0) continue;\n\n            if (accelerationIndex != prevAccel)\n              averageDynamicCost += accelerationChangePenalty;\n\n            // The cost of a trajectory is the average sample cost scaled by the path length\n            float totalCost = (averageStaticCost + averageDynamicCost) * pathLength + costTableEntry.x;\n\n            float terminalCost = totalCost + extraTimePenalty * finalTime;\n            if (terminalCost >= bestTerminalCost) continue;\n            bestTerminalCost = terminalCost;\n\n            int incomingIndex = avtIndex + numPerTime * numTimes * (prevLatitude + numLatitudes * prevStation);\n            bestTrajectory = vec4(totalCost, finalVelocity, finalTime, incomingIndex);\n          }\n        }\n      }\n    }\n  }\n\n  if (station < stationConnectivity) {\n    ivec2 slaIndex = ivec2(latitude, station * numAccelerations + accelerationIndex);\n\n    vec4 costTableEntry = texelFetch(cubicPathFromVehicleCosts, slaIndex, 0);\n    float terminalCost;\n\n    if (costTableEntry.x >= 0.0) {\n      terminalCost = costTableEntry.x + extraTimePenalty * costTableEntry.z;\n\n      if (terminalCost < bestTerminalCost) {\n        bestTerminalCost = terminalCost;\n        bestTrajectory = costTableEntry;\n      }\n    }\n\n    costTableEntry = texelFetch(quinticPathFromVehicleCosts, slaIndex, 0);\n\n    if (costTableEntry.x >= 0.0) {\n      terminalCost = costTableEntry.x + extraTimePenalty * costTableEntry.z;\n\n      if (terminalCost < bestTerminalCost) {\n        bestTerminalCost = terminalCost;\n        bestTrajectory = costTableEntry;\n      }\n    }\n  }\n\n  return bestTrajectory;\n}\n\n`;\n\n/* harmony default export */ var graphSearch = ({\n  setUp() {\n    return {\n      kernel: SOLVE_STATION_KERNEL,\n      output: { name: 'graphSearch' },\n      uniforms: Object.assign({}, SHARED_UNIFORMS, {\n        lattice: { type: 'sharedTexture' },\n        costTable: { type: 'sharedTexture', textureType: '2DArray' },\n        cubicPaths: { type: 'outputTexture' },\n        cubicPathFromVehicleCosts: { type: 'outputTexture' },\n        quinticPathFromVehicleCosts: { type: 'outputTexture' },\n        firstLatticePoint: { type: 'int' },\n        secondLatticePoint: { type: 'int' },\n        velocityVehicle: { type: 'float' },\n        curvVehicle: { type: 'float' },\n        dCurvVehicle: { type: 'float' },\n        ddCurvVehicle: { type: 'float' },\n        extraTimePenalty: { type: 'float' },\n        hysteresisDiscount: { type: 'float' },\n        accelerationChangePenalty: { type: 'float' },\n        numStations: { type: 'int' },\n        numLatitudes: { type: 'int' },\n        numAccelerations: { type: 'int' },\n        numVelocities: { type: 'int' },\n        numTimes: { type: 'int' },\n        stationConnectivity: { type: 'int' },\n        latitudeConnectivity: { type: 'int' },\n        velocityRanges: { type: 'float', length: NUM_VELOCITY_RANGES + 1 },\n        timeRanges: { type: 'float', length: NUM_TIME_RANGES + 1 },\n        station: { type: 'int' } // Updated in `drawProxy`\n      }),\n      drawProxy: (gpgpu, program, draw) => {\n        const width = NUM_ACCELERATION_PROFILES * NUM_VELOCITY_RANGES * NUM_TIME_RANGES;\n        const height = program.meta.lattice.numLatitudes;\n        const costTable = new Float32Array(width * height * program.meta.lattice.numStations * 4);\n\n        for (let s = 0; s < program.meta.lattice.numStations; s++) {\n          gpgpu.updateProgramUniforms(program, { station: s });\n          draw();\n\n          gpgpu.gl.readPixels(0, 0, width, height, gpgpu.gl.RGBA, gpgpu.gl.FLOAT, costTable, s * width * height * 4);\n\n          gpgpu.gl.bindTexture(gpgpu.gl.TEXTURE_2D_ARRAY, gpgpu.sharedTextures.costTable);\n          gpgpu.gl.copyTexSubImage3D(gpgpu.gl.TEXTURE_2D_ARRAY, 0, 0, 0, s, 0, 0, width, height);\n        }\n\n        gpgpu._graphSearchCostTable = costTable;\n      }\n    };\n  },\n\n  update(config, pose, xyCenterPoint, slCenterPoint, firstLatticePoint, secondLatticePoint, dynamicFrameTime) {\n    return {\n      width: NUM_ACCELERATION_PROFILES * NUM_VELOCITY_RANGES * NUM_TIME_RANGES,\n      height: config.lattice.numLatitudes,\n      meta: {\n        lattice: config.lattice\n      },\n      uniforms: Object.assign({}, buildUniformValues(config, xyCenterPoint, slCenterPoint, dynamicFrameTime), {\n        firstLatticePoint: firstLatticePoint,\n        secondLatticePoint: secondLatticePoint,\n        velocityVehicle: pose.velocity,\n        curvVehicle: pose.curv,\n        dCurvVehicle: pose.dCurv,\n        ddCurvVehicle: pose.ddCurv,\n        extraTimePenalty: config.extraTimePenalty,\n        hysteresisDiscount: config.hysteresisDiscount,\n        accelerationChangePenalty: config.accelerationChangePenalty,\n        numStations: config.lattice.numStations,\n        numLatitudes: config.lattice.numLatitudes,\n        numAccelerations: NUM_ACCELERATION_PROFILES,\n        numVelocities: NUM_VELOCITY_RANGES,\n        numTimes: NUM_TIME_RANGES,\n        stationConnectivity: config.lattice.stationConnectivity,\n        latitudeConnectivity: config.lattice.latitudeConnectivity,\n        velocityRanges: [0, config.speedLimit / 3, config.speedLimit * 2 / 3, config.speedLimit, 1000000],\n        timeRanges: [0, 10, 1000000]\n      })\n    };\n  }\n});\n\n// CONCATENATED MODULE: ./js/autonomy/path-planning/gpgpu-programs/xyObstacleCostGrid.js\nconst XY_OBSTACLE_COST_KERNEL = `\n\nvec4 kernel() {\n  vec2 xy = (kernelPosition - 0.5) * vec2(kernelSize) * vec2(xyGridCellSize) + xyCenterPoint;\n\n  vec2 xyTexCoords = (xy - xyCenterPoint) / vec2(textureSize(xyslMap, 0)) / vec2(xyGridCellSize) + 0.5;\n  vec2 sl = texture(xyslMap, xyTexCoords).xy;\n\n  vec2 slTexCoords = (sl - slCenterPoint) / vec2(textureSize(slObstacleGrid, 0)) / vec2(slGridCellSize) + 0.5;\n  return texture(slObstacleGrid, slTexCoords);\n}\n\n`;\n\n// Build XY obstacle costs using XYSL map\n/* harmony default export */ var xyObstacleCostGrid = ({\n  setUp() {\n    return {\n      kernel: XY_OBSTACLE_COST_KERNEL,\n      output: { name: 'xyObstacleCostGrid', read: true },\n      uniforms: {\n        xyslMap: { type: 'outputTexture' },\n        slObstacleGrid: { type: 'outputTexture', name: 'slObstacleGridDilated' },\n        xyCenterPoint: { type: 'vec2' },\n        xyGridCellSize: { type: 'float'},\n        slCenterPoint: { type: 'vec2' },\n        slGridCellSize: { type: 'float'}\n      }\n    };\n  },\n\n  update(config, xyWidth, xyHeight, xyCenterPoint, slCenterPoint) {\n    return {\n      width: xyWidth,\n      height: xyHeight,\n      uniforms: {\n        xyCenterPoint: [xyCenterPoint.x, xyCenterPoint.y],\n        xyGridCellSize: config.xyGridCellSize,\n        slCenterPoint: [slCenterPoint.x, slCenterPoint.y],\n        slGridCellSize: config.slGridCellSize\n      }\n    };\n  }\n});\n\n// CONCATENATED MODULE: ./js/autonomy/path-planning/PathPlanner.js\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return PathPlanner_PathPlanner; });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst PathPlanner_NUM_ACCELERATION_PROFILES = 8;\nconst PathPlanner_NUM_VELOCITY_RANGES = 4;\nconst PathPlanner_NUM_TIME_RANGES = 2;\n\n/* Obstacle cost map:\n *\n * 1. Rasterize triangles from polygonal obstacles into XY-space occupancy grid\n * 2. Convert occupancy grid to SL-space\n *    * Width is spatial horizon of the state lattice\n *    * Height is lane width\n *    * Resolution should be higher than XY-grid\n *    * Get XY position from centerline texture\n *    * Lookup XY in XY occupancy grid (nearest)\n * 3. Dilate SL-space grid using two passes (along station, then along latitude)\n *    * collision area: half car size + 0.3m\n *    * high cost area: 1 meter\n * 4. Convert back to XY-space using XYSL map\n */\n\nclass PathPlanner_PathPlanner {\n  constructor() {\n    this.previousStartStation = null;\n    this.previousFirstLatticePoint = -1;\n    this.previousSecondLatticePoint = -1;\n    this.previousFirstAcceleration = -1;\n    this.previousSecondLatticePoint = -1;\n\n    let start = performance.now();\n    const programs = [\n      xyObstacleGrid.setUp(),\n      slObstacleGrid.setUp(),\n      ...slObstacleGridDilation.setUp(),\n      slDynamicObstacleGrid.setUp(),\n      xyslMap.setUp(),\n      ...optimizeCubicPaths.setUp(),\n      optimizeQuinticPaths.setUp(),\n      ...pathFromVehicleCosts.setUp(),\n      graphSearch.setUp(),\n    ].map(p => Object.assign({}, p, { width: 1, height: 1 }));\n\n    this.gpgpu = new GPGPU[\"a\" /* default */](programs);\n  }\n\n  reset() {\n    this.previousStartStation = null;\n    this.previousFirstLatticePoint = -1;\n    this.previousSecondLatticePoint = -1;\n    this.previousFirstAcceleration = -1;\n    this.previousSecondLatticePoint = -1;\n  }\n\n  plan(vehiclePose, vehicleStation, lanePath, startTime, staticObstacles, dynamicObstacles) {\n    const latticeStationInterval = this._latticeStationInterval();\n\n    const centerlineRaw = lanePath.sampleStations(vehicleStation, Math.ceil((this.config.spatialHorizon + latticeStationInterval) / this.config.centerlineStationInterval) + 1, this.config.centerlineStationInterval);\n\n    // Transform all centerline points into vehicle frame\n    const vehicleXform = vehicleTransform(vehiclePose);\n    const centerline = centerlineRaw.map(c => { return { pos: c.pos.clone().applyMatrix3(vehicleXform), rot: c.rot - vehiclePose.rot, curv: c.curv } });\n\n    const centerlineData = new Float32Array(centerline.length * 3);\n    const maxPoint = new THREE.Vector2(0, 0);\n    const minPoint = new THREE.Vector2(0, 0);\n\n    for (let i = 0; i < centerline.length; i++) {\n      const sample = centerline[i];\n      const pos = sample.pos;\n      centerlineData[i * 3 + 0] = pos.x;\n      centerlineData[i * 3 + 1] = pos.y;\n      centerlineData[i * 3 + 2] = sample.rot;\n\n      maxPoint.max(pos);\n      minPoint.min(pos);\n    }\n\n    const diff = maxPoint.clone().sub(minPoint);\n    const xyCenterPoint = minPoint.clone().add(maxPoint).divideScalar(2);\n\n    // Sizes of the xy grids (in pixels, not meters)\n    const xyWidth = Math.ceil((diff.x + this.config.gridMargin * 2) / this.config.xyGridCellSize);\n    const xyHeight = Math.ceil((diff.y + this.config.gridMargin * 2) / this.config.xyGridCellSize);\n\n    const stationWidth = this.config.spatialHorizon + latticeStationInterval * 2;\n    const slCenterPoint = new THREE.Vector2(this.config.spatialHorizon / 2, 0);\n\n    // Sizes of the sl grids (in pixels, not meters)\n    const slWidth = Math.ceil(stationWidth / this.config.slGridCellSize);\n    const slHeight = Math.ceil((this.config.roadWidth + this.config.gridMargin * 2) / this.config.slGridCellSize);\n\n    let startStation;\n\n    if (this.previousStartStation === null || vehicleStation + latticeStationInterval / 2 > this.previousStartStation) {\n      startStation = (this.previousStartStation === null ? vehicleStation : this.previousStartStation) + latticeStationInterval;\n      this.previousStartStation = startStation;\n      this.previousFirstLatticePoint -= this.config.lattice.numLatitudes;\n      this.previousSecondLatticePoint -= this.config.lattice.numLatitudes;\n    } else {\n      startStation = this.previousStartStation;\n    }\n\n    const lattice = this._buildLattice(lanePath, startStation, vehiclePose.rot, vehicleXform);\n\n    const temporalHorizon = this.config.spatialHorizon / this.config.speedLimit;\n    const dynamicFrameTime = temporalHorizon / this.config.numDynamicFrames;\n\n    for (const [i, p] of [\n      xyObstacleGrid.update(this.config, xyWidth, xyHeight, xyCenterPoint, vehicleXform, staticObstacles),\n      slObstacleGrid.update(this.config, slWidth, slHeight, slCenterPoint, xyCenterPoint),\n      ...slObstacleGridDilation.update(this.config, slWidth, slHeight),\n      slDynamicObstacleGrid.update(this.config, slWidth, slHeight, slCenterPoint, vehicleStation, startTime, dynamicFrameTime, dynamicObstacles),\n      xyslMap.update(this.config, xyWidth, xyHeight, xyCenterPoint),\n      ...optimizeCubicPaths.update(this.config, vehiclePose),\n      optimizeQuinticPaths.update(this.config, vehiclePose),\n      ...pathFromVehicleCosts.update(this.config, vehiclePose, xyCenterPoint, slCenterPoint, this.previousFirstLatticePoint, this.previousSecondLatticePoint, dynamicFrameTime),\n      graphSearch.update(this.config, vehiclePose, xyCenterPoint, slCenterPoint, this.previousFirstLatticePoint, this.previousSecondLatticePoint, dynamicFrameTime)\n    ].entries()) {\n      this.gpgpu.updateProgram(i, p);\n    }\n\n    this.gpgpu.updateSharedTextures({\n      centerline: {\n        width: centerline.length,\n        height: 1,\n        channels: 3,\n        filter: 'linear',\n        data: centerlineData\n      },\n      costTable: {\n        width: PathPlanner_NUM_ACCELERATION_PROFILES * PathPlanner_NUM_VELOCITY_RANGES * PathPlanner_NUM_TIME_RANGES,\n        height: this.config.lattice.numLatitudes,\n        depth: this.config.lattice.numStations,\n        channels: 4,\n        textureType: '2DArray'\n      },\n      lattice: {\n        width: this.config.lattice.numLatitudes,\n        height: this.config.lattice.numStations,\n        channels: 4,\n        data: lattice\n      }\n    });\n\n    this.gpgpu._graphSearchCostTable = null;\n    this.gpgpu._dynamicObstacleGrid = null;\n\n    let start = performance.now();\n    const outputs = this.gpgpu.run();\n    const costTable = this.gpgpu._graphSearchCostTable;\n    const cubicPathParams = outputs[6];\n    const cubicPathFromVehicleParams = outputs[7];\n    const quinticPathFromVehicleParams = outputs[8];\n\n    let bestEntry = [Number.POSITIVE_INFINITY];\n    let bestEntryIndex;\n    const numEntries = costTable.length / 4;\n\n    for (let i = 0; i < numEntries; i++) {\n      const entryUnpacked = this._unpackCostTableIndex(i);\n      const entry = [\n        costTable[i * 4],\n        costTable[i * 4 + 1],\n        costTable[i * 4 + 2],\n        costTable[i * 4 + 3]\n      ];\n\n      if (entry[0] < 0) continue;\n\n      entry[0] += this._terminalCost(entryUnpacked, entry);\n\n      if (entry[0] < bestEntry[0]) {\n        bestEntryIndex = i;\n        bestEntry = entry;\n      }\n    }\n\n    const inverseVehicleXform = (new THREE.Matrix3()).getInverse(vehicleXform);\n    let bestTrajectory = null;\n    let fromVehicleSegment = null;\n    let fromVehicleParams = null;\n    let firstLatticePoint = -1;\n    let firstAcceleration = -1;\n    let secondLatticePoint = -1;\n    let secondAcceleration = -1;\n\n    if (isFinite(bestEntry[0])) {\n      [bestTrajectory, fromVehicleSegment, fromVehicleParams, firstLatticePoint, firstAcceleration, secondLatticePoint, secondAcceleration] = this._reconstructTrajectory(\n        bestEntryIndex,\n        costTable,\n        cubicPathParams,\n        cubicPathFromVehicleParams,\n        quinticPathFromVehicleParams,\n        vehiclePose,\n        lattice\n      );\n\n      fromVehicleSegment.forEach(p => {\n        p.pos = p.pos.applyMatrix3(inverseVehicleXform);\n        p.rot += vehiclePose.rot;\n      });\n\n      bestTrajectory.forEach(p => {\n        p.pos = p.pos.applyMatrix3(inverseVehicleXform);\n        p.rot += vehiclePose.rot;\n      });\n    }\n\n    this.previousFirstLatticePoint = firstLatticePoint;\n    this.previousFirstAcceleration = firstAcceleration;\n    this.previousSecondLatticePoint = secondLatticePoint;\n    this.previousSecondAcceleration = secondAcceleration;\n\n    return {\n      path: bestTrajectory,\n      fromVehicleSegment: fromVehicleSegment,\n      fromVehicleParams: fromVehicleParams,\n      latticeStartStation: this.previousStartStation,\n      dynamicObstacleGrid: { data: this.gpgpu._dynamicObstacleGrid, width: slWidth, height: slHeight }\n    };\n  }\n\n  _buildLattice(lanePath, startStation, vehicleRot, vehicleXform) {\n    const centerline = lanePath.sampleStations(startStation, this.config.lattice.numStations, this._latticeStationInterval());\n    const offset = Math.floor(this.config.lattice.numLatitudes / 2);\n    const lattice = new Float32Array(this.config.lattice.numStations * this.config.lattice.numLatitudes * 4);\n    let index = 0;\n\n    for (let s = 0; s < centerline.length; s++) {\n      const sample = centerline[s];\n\n      for (let l = 0; l < this.config.lattice.numLatitudes; l++) {\n        const latitude = (l - offset) / offset * this.config.roadWidth / 2;\n        const rot = sample.rot - vehicleRot;\n        const pos = THREE.Vector2.fromAngle(rot + Math.PI / 2).multiplyScalar(latitude).add(sample.pos.clone().applyMatrix3(vehicleXform));\n        const curv = sample.curv == 0 ? 0 : 1 / (1 / sample.curv - latitude);\n\n        lattice[index++] = pos.x;\n        lattice[index++] = pos.y;\n        lattice[index++] = rot;\n        lattice[index++] = curv;\n      }\n    }\n\n    return lattice;\n  }\n\n  _latticeStationInterval() {\n    return this.config.spatialHorizon / this.config.lattice.numStations;\n  }\n\n  _terminalCost([stationIndex, latitudeIndex, timeIndex, velocityIndex, accelerationIndex], [cost, finalVelocity, finalTime, incomingIndex]) {\n    // Only consider vertices that reach the end of the spatial or temporal horizon\n    if (stationIndex != this.config.lattice.numStations - 1 && finalVelocity > 0.05)\n      return Number.POSITIVE_INFINITY;\n\n    const station = (this.config.spatialHorizon / this.config.lattice.numStations) * (stationIndex + 1);\n\n    return station * -this.config.stationReachDiscount + finalTime * this.config.extraTimePenalty;\n  }\n\n  _unpackCostTableIndex(index) {\n    if (index < 0) return [-1, index + 2, null, null, null];\n\n    const numPerTime = PathPlanner_NUM_ACCELERATION_PROFILES * PathPlanner_NUM_VELOCITY_RANGES;\n    const numPerLatitude = numPerTime * PathPlanner_NUM_TIME_RANGES;\n    const numPerStation = this.config.lattice.numLatitudes * numPerLatitude;\n\n    const stationIndex = Math.floor(index / numPerStation);\n    index -= stationIndex * numPerStation;\n\n    const latitudeIndex = Math.floor(index / numPerLatitude);\n    index -= latitudeIndex * numPerLatitude;\n\n    const timeIndex = Math.floor(index / numPerTime);\n    index -= timeIndex * numPerTime;\n\n    const velocityIndex = Math.floor(index / PathPlanner_NUM_ACCELERATION_PROFILES);\n    const accelerationIndex = index % PathPlanner_NUM_ACCELERATION_PROFILES;\n\n    return [stationIndex, latitudeIndex, timeIndex, velocityIndex, accelerationIndex];\n  }\n\n  _reconstructTrajectory(index, costTable, cubicPathParams, cubicPathFromVehicleParams, quinticPathFromVehicleParams, vehiclePose, lattice) {\n    let unpacked = this._unpackCostTableIndex(index);\n    unpacked.push(costTable[index * 4 + 1]);\n    const nodes = [unpacked];\n\n    let count = 0;\n    while (unpacked[0] >= 0 && count++ < 100) {\n      index = costTable[index * 4 + 3];\n      unpacked = this._unpackCostTableIndex(index);\n\n      const finalVelocity = unpacked[0] >= 0 ? costTable[index * 4 + 1] : vehiclePose.velocity;\n      unpacked.push(finalVelocity);\n\n      nodes.unshift(unpacked);\n    }\n    if (count >= 100) throw new Error('Infinite loop encountered while reconstructing trajectory.');\n\n    const points = [];\n    let fromVehicleSegment = [];\n    let fromVehicleParams = null;\n\n    for (let i = 0; i < nodes.length - 1; i++) {\n      const [prevStation, prevLatitude, _pt, _pv, _pa, prevVelocity] = nodes[i];\n      const [station, latitude, _t, _v, _a, velocity] = nodes[i + 1];\n\n      let length;\n      let pathBuilder;\n\n      if (prevStation < 0) {\n        const start = {\n          pos: new THREE.Vector2(0, 0),\n          rot: 0,\n          curv: vehiclePose.curv\n        };\n\n        const endIndex = (station * this.config.lattice.numLatitudes + latitude) * 4;\n        const end = {\n          pos: new THREE.Vector2(lattice[endIndex], lattice[endIndex + 1]),\n          rot: lattice[endIndex + 2],\n          curv: lattice[endIndex + 3]\n        };\n\n        if (prevLatitude == 0) { // Cubic path from vehicle to lattice node\n          length = cubicPathFromVehicleParams[endIndex + 2];\n\n          const params = {\n            p1: cubicPathFromVehicleParams[endIndex],\n            p2: cubicPathFromVehicleParams[endIndex + 1],\n            sG: length\n          };\n\n          pathBuilder = new CubicPath[\"a\" /* default */](start, end, params);\n\n          fromVehicleParams = { type: 'cubic', params: params };\n        } else { // Quintic path from vehicle to lattice node\n          length = quinticPathFromVehicleParams[endIndex + 2];\n\n          const params = {\n            p3: quinticPathFromVehicleParams[endIndex],\n            p4: quinticPathFromVehicleParams[endIndex + 1],\n            sG: length\n          };\n\n          pathBuilder = new QuinticPath(start, end, params);\n\n          fromVehicleParams = { type: 'quintic', params: params };\n        }\n      } else {\n        const startIndex = (prevStation * this.config.lattice.numLatitudes + prevLatitude) * 4;\n        const endIndex = (station * this.config.lattice.numLatitudes + latitude) * 4;\n\n        const start = {\n          pos: new THREE.Vector2(lattice[startIndex], lattice[startIndex + 1]),\n          rot: lattice[startIndex + 2],\n          curv: lattice[startIndex + 3]\n        };\n\n        const end = {\n          pos: new THREE.Vector2(lattice[endIndex], lattice[endIndex + 1]),\n          rot: lattice[endIndex + 2],\n          curv: lattice[endIndex + 3]\n        };\n\n        const slIndex = station * this.config.lattice.numLatitudes + latitude;\n        const connectivityIndex = (prevStation - station + this.config.lattice.stationConnectivity) * this.config.lattice.latitudeConnectivity + prevLatitude - latitude + Math.floor(this.config.lattice.latitudeConnectivity / 2);\n        const cubicPathIndex = (connectivityIndex * this.config.lattice.numStations * this.config.lattice.numLatitudes + slIndex) * 4;\n\n        length = cubicPathParams[cubicPathIndex + 2];\n\n        pathBuilder = new CubicPath[\"a\" /* default */](start, end, {\n          p1: cubicPathParams[cubicPathIndex],\n          p2: cubicPathParams[cubicPathIndex + 1],\n          sG: length\n        });\n      }\n\n      const path = pathBuilder.buildPath(Math.ceil(length / 0.25));\n\n      const prevVelocitySq = prevVelocity * prevVelocity;\n      const accel = (velocity * velocity - prevVelocitySq) / 2 / length;\n      const ds = length / (path.length - 1);\n      let s = 0;\n\n      for (let p = 0; p < path.length; p++) {\n        path[p].velocity = Math.sqrt(2 * accel * s + prevVelocitySq);\n        path[p].acceleration = accel;\n        s += ds;\n      }\n\n      if (prevStation < 0) {\n        fromVehicleSegment = path;\n      } else {\n        if (i > 0) path.shift();\n        points.push(...path);\n      }\n    }\n\n    let firstLatticePoint = null\n    let firstAcceleration = null;\n    let secondLatticePoint = null;\n    let secondAcceleration = null;\n\n    if (nodes.length >= 2) {\n      firstLatticePoint = nodes[1][0] * this.config.lattice.numLatitudes + nodes[1][1];\n      firstAcceleration = nodes[1][4];\n    }\n\n    if (nodes.length >= 3) {\n      secondLatticePoint = nodes[2][0] * this.config.lattice.numLatitudes + nodes[2][1];\n      secondAcceleration = nodes[2][4];\n    }\n\n    return [points, fromVehicleSegment, fromVehicleParams, firstLatticePoint, firstAcceleration, secondLatticePoint, secondAcceleration];\n  }\n}\n\nfunction vehicleTransform({ pos, rot }) {\n  const translate = new THREE.Matrix3();\n  translate.set(\n    1, 0, -pos.x,\n    0, 1, -pos.y,\n    0, 0, 1\n  );\n\n  const cosRot = Math.cos(rot);\n  const sinRot = Math.sin(rot);\n\n  const rotate = new THREE.Matrix3();\n  rotate.set(\n    cosRot, sinRot, 0,\n    -sinRot, cosRot, 0,\n    0, 0, 1\n  );\n\n  return rotate.multiply(translate);\n}\n\nfunction obstacleTransform(vehicleXform, xyCenterPoint, width, height) {\n  const translate = new THREE.Matrix3();\n  translate.set(\n    1, 0, -xyCenterPoint.x,\n    0, 1, -xyCenterPoint.y,\n    0, 0, 1\n  );\n\n  const scale = new THREE.Matrix3();\n  scale.set(\n    2 / width, 0, 0,\n    0, 2 / height, 0,\n    0, 0, 1\n  );\n\n  return scale.multiply(translate).multiply(vehicleXform);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL1F1aW50aWNQYXRoLmpzPzhjNjUiLCJ3ZWJwYWNrOi8vLy4vanMvYXV0b25vbXkvcGF0aC1wbGFubmluZy9ncGdwdS1wcm9ncmFtcy94eU9ic3RhY2xlR3JpZC5qcz9kNzhjIiwid2VicGFjazovLy8uL2pzL2F1dG9ub215L3BhdGgtcGxhbm5pbmcvZ3BncHUtcHJvZ3JhbXMvc2xPYnN0YWNsZUdyaWQuanM/ZTU0YiIsIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL2dwZ3B1LXByb2dyYW1zL3NsT2JzdGFjbGVHcmlkRGlsYXRpb24uanM/MTc0OSIsIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL2dwZ3B1LXByb2dyYW1zL3NsRHluYW1pY09ic3RhY2xlR3JpZC5qcz82YzBlIiwid2VicGFjazovLy8uL2pzL2F1dG9ub215L3BhdGgtcGxhbm5pbmcvZ3BncHUtcHJvZ3JhbXMveHlzbE1hcC5qcz81YmE5Iiwid2VicGFjazovLy8uL2pzL2F1dG9ub215L3BhdGgtcGxhbm5pbmcvZ3BncHUtcHJvZ3JhbXMvb3B0aW1pemVDdWJpY1BhdGhzLmpzPzE1M2QiLCJ3ZWJwYWNrOi8vLy4vanMvYXV0b25vbXkvcGF0aC1wbGFubmluZy9ncGdwdS1wcm9ncmFtcy9vcHRpbWl6ZVF1aW50aWNQYXRocy5qcz9jMDVkIiwid2VicGFjazovLy8uL2pzL2F1dG9ub215L3BhdGgtcGxhbm5pbmcvZ3BncHUtcHJvZ3JhbXMvZ3JhcGhTZWFyY2hTaGFyZWQuanM/MjA1MiIsIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL2dwZ3B1LXByb2dyYW1zL3BhdGhGcm9tVmVoaWNsZUNvc3RzLmpzP2U1MGMiLCJ3ZWJwYWNrOi8vLy4vanMvYXV0b25vbXkvcGF0aC1wbGFubmluZy9ncGdwdS1wcm9ncmFtcy9ncmFwaFNlYXJjaC5qcz80Yzg4Iiwid2VicGFjazovLy8uL2pzL2F1dG9ub215L3BhdGgtcGxhbm5pbmcvZ3BncHUtcHJvZ3JhbXMveHlPYnN0YWNsZUNvc3RHcmlkLmpzP2M5NzQiLCJ3ZWJwYWNrOi8vLy4vanMvYXV0b25vbXkvcGF0aC1wbGFubmluZy9QYXRoUGxhbm5lci5qcz9kMzI2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBLGlDQUFpQztBQUNqQywrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsV0FBVyxnR0FBZ0c7QUFDN0k7O0FBRUE7QUFDQSxXQUFXLDZCQUE2Qjs7QUFFeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGlHQUFpRztBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGFBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsNkZBQTZGOztBQUU5RztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLHlGQUF5Rjs7QUFFeEc7QUFDQTtBQUNBOzs7QUN2RUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlCQUF5QjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBjbGFzcyBRdWludGljUGF0aCB7XG4gIGNvbnN0cnVjdG9yKHN0YXJ0LCBlbmQsIHBhcmFtcykge1xuICAgIHRoaXMuc3RhcnQgPSBPYmplY3QuYXNzaWduKHt9LCBzdGFydCk7XG4gICAgdGhpcy5lbmQgPSBPYmplY3QuYXNzaWduKHt9LCBlbmQpO1xuXG4gICAgaWYgKHN0YXJ0LnBvcykge1xuICAgICAgdGhpcy5zdGFydC54ID0gc3RhcnQucG9zLng7XG4gICAgICB0aGlzLnN0YXJ0LnkgPSBzdGFydC5wb3MueVxuICAgIH1cblxuICAgIGlmIChlbmQucG9zKSB7XG4gICAgICB0aGlzLmVuZC54ID0gZW5kLnBvcy54O1xuICAgICAgdGhpcy5lbmQueSA9IGVuZC5wb3MueVxuICAgIH1cblxuICAgIGNvbnN0IGRpZmZYID0gdGhpcy5lbmQueCAtIHRoaXMuc3RhcnQueDtcbiAgICBjb25zdCBkaWZmWSA9IHRoaXMuZW5kLnkgLSB0aGlzLnN0YXJ0Lnk7XG4gICAgY29uc3Qgc2luUm90ID0gTWF0aC5zaW4odGhpcy5zdGFydC5yb3QpO1xuICAgIGNvbnN0IGNvc1JvdCA9IE1hdGguY29zKHRoaXMuc3RhcnQucm90KTtcblxuICAgIHRoaXMuZ29hbCA9IHtcbiAgICAgIHg6IGNvc1JvdCAqIGRpZmZYICsgc2luUm90ICogZGlmZlksXG4gICAgICB5OiAtc2luUm90ICogZGlmZlggKyBjb3NSb3QgKiBkaWZmWSxcbiAgICAgIHJvdDogTWF0aC53cmFwQW5nbGUodGhpcy5lbmQucm90IC0gdGhpcy5zdGFydC5yb3QpLFxuICAgICAgY3VydjogdGhpcy5lbmQuY3VydlxuICAgIH07XG5cbiAgICB0aGlzLnBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcywgeyBwMDogdGhpcy5zdGFydC5jdXJ2LCBwMTogdGhpcy5zdGFydC5kQ3VydiB8fCAwLCBwMjogdGhpcy5zdGFydC5kZEN1cnYgfHwgMCwgcDU6IHRoaXMuZW5kLmN1cnYgfSk7XG4gIH1cblxuICBidWlsZFBhdGgobnVtKSB7XG4gICAgY29uc3QgeyBwMCwgcDEsIHAyLCBwMywgcDQsIHA1LCBzRyB9ID0gdGhpcy5wYXJhbXM7XG5cbiAgICBjb25zdCBzR18yID0gc0cgKiBzRztcbiAgICBjb25zdCBzR18zID0gc0dfMiAqIHNHO1xuXG4gICAgY29uc3QgYSA9IHAwO1xuICAgIGNvbnN0IGIgPSBwMTtcbiAgICBjb25zdCBjID0gcDIgLyAyLjA7XG4gICAgY29uc3QgZCA9ICgtNzEuODc1ICogcDAgKyA4MS4wICogcDMgLSAxMC4xMjUgKiBwNCArIHA1IC0gMjEuMjUgKiBwMSAqIHNHIC0gMi43NSAqIHAyICogc0dfMikgLyBzR18zO1xuICAgIGNvbnN0IGUgPSAoMTY2LjUgKiBwMCAtIDIwMi41ICogcDMgKyA0MC41ICogcDQgLSA0LjUgKiBwNSArIDQ1LjAgKiBwMSAqIHNHICsgNC41ICogcDIgKiBzR18yKSAvIChzR18yICogc0dfMik7XG4gICAgY29uc3QgZiA9ICgtOTUuNjI1ICogcDAgKyAxMjEuNSAqIHAzIC0gMzAuMzc1ICogcDQgKyA0LjUgKiBwNSAtIDI0Ljc1ICogcDEgKiBzRyAtIDIuMjUgKiBwMiAqIHNHXzIpIC8gKHNHXzIgKiBzR18zKTtcblxuICAgIGNvbnN0IHBhdGggPSBbeyBwb3M6IG5ldyBUSFJFRS5WZWN0b3IyKHRoaXMuc3RhcnQueCwgdGhpcy5zdGFydC55KSwgcm90OiB0aGlzLnN0YXJ0LnJvdCwgY3VydjogdGhpcy5zdGFydC5jdXJ2IH1dO1xuICAgIGNvbnN0IGRzID0gc0cgLyAobnVtIC0gMSk7XG4gICAgbGV0IHMgPSBkcztcbiAgICBsZXQgZHggPSAwO1xuICAgIGxldCBkeSA9IDA7XG4gICAgbGV0IHByZXZDb3NSb3QgPSBNYXRoLmNvcyhwYXRoWzBdLnJvdCk7XG4gICAgbGV0IHByZXZTaW5Sb3QgPSBNYXRoLnNpbihwYXRoWzBdLnJvdCk7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG51bSAtIDE7IGkrKykge1xuICAgICAgY29uc3Qgcm90ID0gKCgoKChmICogcyAvIDYuMCArIGUgLyA1LjApICogcyArIGQgLyA0LjApICogcyArIGMgLyAzLjApICogcyArIGIgLyAyLjApICogcyArIGEpICogcyArIHRoaXMuc3RhcnQucm90O1xuICAgICAgY29uc3QgY3VydiA9ICgoKChmICogcyArIGUpICogcyArIGQpICogcyArIGMpICogcyArIGIpICogcyArIGE7XG4gICAgICBjb25zdCBjb3NSb3QgPSBNYXRoLmNvcyhyb3QpO1xuICAgICAgY29uc3Qgc2luUm90ID0gTWF0aC5zaW4ocm90KTtcblxuICAgICAgZHggPSBkeCAqIChpIC0gMSkgLyBpICsgKGNvc1JvdCArIHByZXZDb3NSb3QpIC8gKDIgKiBpKTtcbiAgICAgIGR5ID0gZHkgKiAoaSAtIDEpIC8gaSArIChzaW5Sb3QgKyBwcmV2U2luUm90KSAvICgyICogaSk7XG5cbiAgICAgIHBhdGgucHVzaCh7IHBvczogbmV3IFRIUkVFLlZlY3RvcjIocyAqIGR4ICsgdGhpcy5zdGFydC54LCBzICogZHkgKyB0aGlzLnN0YXJ0LnkpLCByb3Q6IHJvdCwgY3VydjogY3VydiB9KTtcblxuICAgICAgcyArPSBkcztcbiAgICAgIHByZXZDb3NSb3QgPSBjb3NSb3Q7XG4gICAgICBwcmV2U2luUm90ID0gc2luUm90O1xuICAgIH1cblxuICAgIHBhdGgucHVzaCh7IHBvczogbmV3IFRIUkVFLlZlY3RvcjIodGhpcy5lbmQueCwgdGhpcy5lbmQueSksIHJvdDogdGhpcy5lbmQucm90LCBjdXJ2OiB0aGlzLmVuZC5jdXJ2IH0pO1xuXG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbn1cbiIsImNvbnN0IE9CU1RBQ0xFX1ZFUlRFWF9TSEFERVIgPSBgI3ZlcnNpb24gMzAwIGVzXG51bmlmb3JtIG1hdDMgeGZvcm07XG5pbiB2ZWMyIHBvc2l0aW9uO1xuXG52b2lkIG1haW4odm9pZCkge1xuICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHhmb3JtICogdmVjMyhwb3NpdGlvbiwgMSkpLnh5LCAwLCAxKTtcbn1cbmA7XG5cbmNvbnN0IE9CU1RBQ0xFX0tFUk5FTCA9IGBcbiAgdmVjNCBrZXJuZWwoKSB7XG4gICAgcmV0dXJuIHZlYzQoMSwgMCwgMCwgMSk7XG4gIH1cbmA7XG5cbmxldCBvYnN0YWNsZVZlcnRpY2VzO1xubGV0IG9ic3RhY2xlWGZvcm07XG5cbi8vIERyYXcgb2JzdGFjbGUgdHJpYW5nbGVzIHRvIFhZLXNwYWNlIG9ic3RhY2xlIGdyaWRcbmV4cG9ydCBkZWZhdWx0IHtcbiAgc2V0VXAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtlcm5lbDogT0JTVEFDTEVfS0VSTkVMLFxuICAgICAgdmVydGV4U2hhZGVyOiBPQlNUQUNMRV9WRVJURVhfU0hBREVSLFxuICAgICAgb3V0cHV0OiB7IG5hbWU6ICd4eU9ic3RhY2xlR3JpZCcgfSxcbiAgICAgIGRyYXc6IChncGdwdSwgcHJvZ3JhbSkgPT4ge1xuICAgICAgICBjb25zdCBnbCA9IGdwZ3B1LmdsO1xuXG4gICAgICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMCk7XG4gICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuXG4gICAgICAgIGlmIChvYnN0YWNsZVZlcnRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBidWYgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblxuICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWYpO1xuICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBvYnN0YWNsZVZlcnRpY2VzLCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocHJvZ3JhbS5wb3NpdGlvbkxvY2F0aW9uKTtcbiAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHByb2dyYW0ucG9zaXRpb25Mb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcblxuICAgICAgICAgIGNvbnN0IHhmb3JtTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbS5nbFByb2dyYW0sICd4Zm9ybScpO1xuICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYoeGZvcm1Mb2NhdGlvbiwgZmFsc2UsIG9ic3RhY2xlWGZvcm0uZWxlbWVudHMpO1xuXG4gICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIG9ic3RhY2xlVmVydGljZXMubGVuZ3RoIC8gMik7XG5cbiAgICAgICAgICBnbC5kZWxldGVCdWZmZXIoYnVmKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sXG5cbiAgdXBkYXRlKGNvbmZpZywgeHlXaWR0aCwgeHlIZWlnaHQsIHh5Q2VudGVyUG9pbnQsIHZlaGljbGVYZm9ybSwgb2JzdGFjbGVzKSB7XG4gICAgb2JzdGFjbGVWZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgb2JzdGFjbGVzLm1hcChvID0+IG8udmVydGljZXMpKSk7XG5cbiAgICBjb25zdCB0cmFuc2xhdGUgPSBuZXcgVEhSRUUuTWF0cml4MygpO1xuICAgIHRyYW5zbGF0ZS5zZXQoXG4gICAgICAxLCAwLCAteHlDZW50ZXJQb2ludC54LFxuICAgICAgMCwgMSwgLXh5Q2VudGVyUG9pbnQueSxcbiAgICAgIDAsIDAsIDFcbiAgICApO1xuXG4gICAgY29uc3Qgc2NhbGUgPSBuZXcgVEhSRUUuTWF0cml4MygpO1xuICAgIHNjYWxlLnNldChcbiAgICAgIDIgLyAoeHlXaWR0aCAqIGNvbmZpZy54eUdyaWRDZWxsU2l6ZSksIDAsIDAsXG4gICAgICAwLCAyIC8gKHh5SGVpZ2h0ICogY29uZmlnLnh5R3JpZENlbGxTaXplKSwgMCxcbiAgICAgIDAsIDAsIDFcbiAgICApO1xuXG4gICAgb2JzdGFjbGVYZm9ybSA9IHNjYWxlLm11bHRpcGx5KHRyYW5zbGF0ZSkubXVsdGlwbHkodmVoaWNsZVhmb3JtKTtcblxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogeHlXaWR0aCxcbiAgICAgIGhlaWdodDogeHlIZWlnaHRcbiAgICB9XG4gIH1cbn1cbiIsImNvbnN0IFNMX09CU1RBQ0xFX0tFUk5FTCA9IGBcblxudmVjNCBrZXJuZWwoKSB7XG4gIGZsb2F0IGNlbnRlcmxpbmVXaWR0aCA9IGZsb2F0KHRleHR1cmVTaXplKGNlbnRlcmxpbmUsIDApLngpO1xuXG4gIHZlYzIgc2wgPSAoa2VybmVsUG9zaXRpb24gLSAwLjUpICogdmVjMihrZXJuZWxTaXplKSAqIHZlYzIoc2xHcmlkQ2VsbFNpemUpICsgc2xDZW50ZXJQb2ludDtcbiAgZmxvYXQgY2VudGVybGluZUNvb3JkID0gc2wueCAvIGNlbnRlcmxpbmVTdGF0aW9uSW50ZXJ2YWwgLyBjZW50ZXJsaW5lV2lkdGggKiAoY2VudGVybGluZVdpZHRoIC0gMS4wKSAvIGNlbnRlcmxpbmVXaWR0aCArICgwLjUgLyBjZW50ZXJsaW5lV2lkdGgpO1xuICBpZiAoY2VudGVybGluZUNvb3JkIDwgMC4wIHx8IGNlbnRlcmxpbmVDb29yZCA+IDEuMCkgcmV0dXJuIHZlYzQoMCk7XG5cbiAgdmVjMyBjZW50ZXJsaW5lU2FtcGxlID0gdGV4dHVyZShjZW50ZXJsaW5lLCB2ZWMyKGNlbnRlcmxpbmVDb29yZCwgMCkpLnh5ejtcbiAgZmxvYXQgcGVycGluZGljdWxhciA9IGNlbnRlcmxpbmVTYW1wbGUueiArIHJhZGlhbnMoOTAuMCk7XG4gIHZlYzIgeHkgPSBjZW50ZXJsaW5lU2FtcGxlLnh5ICsgc2wueXkgKiB2ZWMyKGNvcyhwZXJwaW5kaWN1bGFyKSwgc2luKHBlcnBpbmRpY3VsYXIpKTtcblxuICB2ZWMyIHh5VGV4Q29vcmRzID0gKHh5IC0geHlDZW50ZXJQb2ludCkgLyB2ZWMyKHRleHR1cmVTaXplKHh5T2JzdGFjbGVHcmlkLCAwKSkgLyB2ZWMyKHh5R3JpZENlbGxTaXplKSArIDAuNTtcbiAgcmV0dXJuIHRleHR1cmUoeHlPYnN0YWNsZUdyaWQsIHh5VGV4Q29vcmRzKTtcbn1cblxuYDtcblxuLy8gQ29udmVydCBYWS1zcGFjZSBvYnN0YWNsZSBncmlkIHRvIFNMLXNwYWNlIG9ic3RhY2xlIGdyaWRcbmV4cG9ydCBkZWZhdWx0IHtcbiAgc2V0VXAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtlcm5lbDogU0xfT0JTVEFDTEVfS0VSTkVMLFxuICAgICAgb3V0cHV0OiB7IG5hbWU6ICdzbE9ic3RhY2xlR3JpZCcgfSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIHh5T2JzdGFjbGVHcmlkOiB7IHR5cGU6ICdvdXRwdXRUZXh0dXJlJyB9LFxuICAgICAgICBzbEdyaWRDZWxsU2l6ZTogeyB0eXBlOiAnZmxvYXQnIH0sXG4gICAgICAgIHh5R3JpZENlbGxTaXplOiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgICAgICAgc2xDZW50ZXJQb2ludDogeyB0eXBlOiAndmVjMicgfSxcbiAgICAgICAgeHlDZW50ZXJQb2ludDogeyB0eXBlOiAndmVjMicgfSxcbiAgICAgICAgY2VudGVybGluZVN0YXRpb25JbnRlcnZhbDogeyB0eXBlOiAnZmxvYXQnIH0sXG4gICAgICAgIGNlbnRlcmxpbmU6IHsgdHlwZTogJ3NoYXJlZFRleHR1cmUnIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdXBkYXRlKGNvbmZpZywgc2xXaWR0aCwgc2xIZWlnaHQsIHNsQ2VudGVyUG9pbnQsIHh5Q2VudGVyUG9pbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHNsV2lkdGgsXG4gICAgICBoZWlnaHQ6IHNsSGVpZ2h0LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgc2xHcmlkQ2VsbFNpemU6IGNvbmZpZy5zbEdyaWRDZWxsU2l6ZSxcbiAgICAgICAgeHlHcmlkQ2VsbFNpemU6IGNvbmZpZy54eUdyaWRDZWxsU2l6ZSxcbiAgICAgICAgc2xDZW50ZXJQb2ludDogW3NsQ2VudGVyUG9pbnQueCwgc2xDZW50ZXJQb2ludC55XSxcbiAgICAgICAgeHlDZW50ZXJQb2ludDogW3h5Q2VudGVyUG9pbnQueCwgeHlDZW50ZXJQb2ludC55XSxcbiAgICAgICAgY2VudGVybGluZVN0YXRpb25JbnRlcnZhbDogY29uZmlnLmNlbnRlcmxpbmVTdGF0aW9uSW50ZXJ2YWxcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsImNvbnN0IFNMX09CU1RBQ0xFX0RJTEFUSU9OX0tFUk5FTCA9IGBcblxuLy8gVE9ETzogdGVzdCBwZXJmb3JtYW5jZSBvZiByZXR1cm5pbmcgZWFybHkgaWYgbm9uLXplcm8gcGl4ZWwgZm91bmRcbnZlYzQga2VybmVsKCkge1xuICBmbG9hdCB2YWwgPSAwLjA7XG5cbiAgZm9yIChpbnQgZCA9IDA7IGQgPD0gY29sbGlzaW9uRGlsYXRpb247IGQrKykge1xuICAgIHZhbCA9IG1heCh2YWwsIHRleHR1cmUoc2xPYnN0YWNsZUdyaWQsIGtlcm5lbFBvc2l0aW9uICsgZGVsdGEgKiB2ZWMyKGQpKS5yKTtcbiAgICB2YWwgPSBtYXgodmFsLCB0ZXh0dXJlKHNsT2JzdGFjbGVHcmlkLCBrZXJuZWxQb3NpdGlvbiArIGRlbHRhICogdmVjMigtZCkpLnIpO1xuICB9XG5cbiAgZm9yIChpbnQgZCA9IGNvbGxpc2lvbkRpbGF0aW9uICsgMTsgZCA8PSBjb2xsaXNpb25EaWxhdGlvbiArIGhhemFyZERpbGF0aW9uOyBkKyspIHtcbiAgICB2YWwgPSBtYXgodmFsLCB0ZXh0dXJlKHNsT2JzdGFjbGVHcmlkLCBrZXJuZWxQb3NpdGlvbiArIGRlbHRhICogdmVjMihkKSkuciAqIDAuNSk7XG4gICAgdmFsID0gbWF4KHZhbCwgdGV4dHVyZShzbE9ic3RhY2xlR3JpZCwga2VybmVsUG9zaXRpb24gKyBkZWx0YSAqIHZlYzIoLWQpKS5yICogMC41KTtcbiAgfVxuXG4gIHZhbCA9IG1heCh2YWwsIHN0ZXAoMC4xLCB2YWwpICogMC41KTtcblxuICByZXR1cm4gdmVjNCh2YWwsIDAsIDAsIDEpO1xufVxuXG5gO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHNldFVwKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7IC8vIFNMLXNwYWNlIG9ic3RhY2xlIGdyaWQgUyBkaWxhdGlvblxuICAgICAgICBrZXJuZWw6IFNMX09CU1RBQ0xFX0RJTEFUSU9OX0tFUk5FTCxcbiAgICAgICAgb3V0cHV0OiB7IG5hbWU6ICdzbE9ic3RhY2xlR3JpZFN0YXRpb25EaWxhdGVkJyB9LFxuICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgIHNsT2JzdGFjbGVHcmlkOiB7IHR5cGU6ICdvdXRwdXRUZXh0dXJlJyB9LFxuICAgICAgICAgIGRlbHRhOiB7IHR5cGU6ICd2ZWMyJyB9LFxuICAgICAgICAgIGNvbGxpc2lvbkRpbGF0aW9uOiB7IHR5cGU6ICdpbnQnIH0sXG4gICAgICAgICAgaGF6YXJkRGlsYXRpb246IHsgdHlwZTogJ2ludCcgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgeyAvLyBTTC1zcGFjZSBvYnN0YWNsZSBncmlkIEwgZGlsYXRpb25cbiAgICAgICAga2VybmVsOiBTTF9PQlNUQUNMRV9ESUxBVElPTl9LRVJORUwsXG4gICAgICAgIG91dHB1dDogeyBuYW1lOiAnc2xPYnN0YWNsZUdyaWREaWxhdGVkJyB9LFxuICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgIHNsT2JzdGFjbGVHcmlkOiB7IHR5cGU6ICdvdXRwdXRUZXh0dXJlJywgbmFtZTogJ3NsT2JzdGFjbGVHcmlkU3RhdGlvbkRpbGF0ZWQnIH0sXG4gICAgICAgICAgZGVsdGE6IHsgdHlwZTogJ3ZlYzInIH0sXG4gICAgICAgICAgY29sbGlzaW9uRGlsYXRpb246IHsgdHlwZTogJ2ludCcgfSxcbiAgICAgICAgICBoYXphcmREaWxhdGlvbjogeyB0eXBlOiAnaW50JyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdO1xuICB9LFxuXG4gIHVwZGF0ZShjb25maWcsIHNsV2lkdGgsIHNsSGVpZ2h0KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHsgLy8gU0wtc3BhY2Ugb2JzdGFjbGUgZ3JpZCBTIGRpbGF0aW9uXG4gICAgICAgIHdpZHRoOiBzbFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IHNsSGVpZ2h0LFxuICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgIGRlbHRhOiBbMSAvIHNsV2lkdGgsIDBdLFxuICAgICAgICAgIGNvbGxpc2lvbkRpbGF0aW9uOiBNYXRoLmNlaWwoY29uZmlnLmNvbGxpc2lvbkRpbGF0aW9uUyAvIGNvbmZpZy5zbEdyaWRDZWxsU2l6ZSksXG4gICAgICAgICAgaGF6YXJkRGlsYXRpb246IE1hdGguY2VpbChjb25maWcuaGF6YXJkRGlsYXRpb25TIC8gY29uZmlnLnNsR3JpZENlbGxTaXplKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgeyAvLyBTTC1zcGFjZSBvYnN0YWNsZSBncmlkIEwgZGlsYXRpb25cbiAgICAgICAgd2lkdGg6IHNsV2lkdGgsXG4gICAgICAgIGhlaWdodDogc2xIZWlnaHQsXG4gICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgZGVsdGE6IFswLCAxIC8gc2xIZWlnaHRdLFxuICAgICAgICAgIGNvbGxpc2lvbkRpbGF0aW9uOiBNYXRoLmNlaWwoY29uZmlnLmNvbGxpc2lvbkRpbGF0aW9uTCAvIGNvbmZpZy5zbEdyaWRDZWxsU2l6ZSksXG4gICAgICAgICAgaGF6YXJkRGlsYXRpb246IE1hdGguY2VpbChjb25maWcuaGF6YXJkRGlsYXRpb25MIC8gY29uZmlnLnNsR3JpZENlbGxTaXplKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgXTtcbiAgfVxufVxuIiwiY29uc3QgRFlOQU1JQ19PQlNUQUNMRV9WRVJURVhfU0hBREVSID0gYCN2ZXJzaW9uIDMwMCBlc1xudW5pZm9ybSBtYXQzIHhmb3JtO1xuaW4gdmVjMyBwb3NpdGlvbjtcbm91dCBmbG9hdCBjb2xvcjtcblxudm9pZCBtYWluKHZvaWQpIHtcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KCh4Zm9ybSAqIHZlYzMocG9zaXRpb24ueHksIDEpKS54eSwgcG9zaXRpb24ueiwgMSk7XG5cbiAgLy8gVGhlIHogY29vcmRpbmF0ZSBpcyAwLjI1IGZvciBjb2xsaXNpb24gem9uZSBhbmQgMC43NSBmb3IgaGF6YXJkIHpvbmUsXG4gIC8vIHNvIHRoYXQgdGhlIGNvbGxpc2lvbiB6b25lIGlzIGRyYXduIG9uIHRvcC5cbiAgLy8gQ29udmVydCB0aGlzIHRvIDEuMCBmb3IgY29sbGlzaW9uIHpvbmUsIDAuNSBmb3IgaGF6YXJkIHpvbmVcbiAgY29sb3IgPSAoMS4wIC0gc3RlcCgwLjUsIHBvc2l0aW9uLnopKSAqIDAuNSArIDAuNTtcbn1cbmA7XG5cbmNvbnN0IERZTkFNSUNfT0JTVEFDTEVfS0VSTkVMID0gYFxuICBpbiBmbG9hdCBjb2xvcjtcblxuICB2ZWM0IGtlcm5lbCgpIHtcbiAgICByZXR1cm4gdmVjNChjb2xvciwgMCwgMCwgMSk7XG4gIH1cbmA7XG5cbmxldCBvYnN0YWNsZVZlcnRpY2VzO1xubGV0IG9ic3RhY2xlWGZvcm07XG5jb25zdCBudW1EeW5hbWljRnJhbWVzID0gMjA7XG5cbi8vIERyYXcgZHluYW1pYyBvYnN0YWNsZSB0cmlhbmdsZXMgdG8gU0wtc3BhY2Ugb2JzdGFjbGUgZ3JpZFxuZXhwb3J0IGRlZmF1bHQge1xuICBzZXRVcCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2VybmVsOiBEWU5BTUlDX09CU1RBQ0xFX0tFUk5FTCxcbiAgICAgIHZlcnRleFNoYWRlcjogRFlOQU1JQ19PQlNUQUNMRV9WRVJURVhfU0hBREVSLFxuICAgICAgb3V0cHV0OiB7IG5hbWU6ICdzbER5bmFtaWNPYnN0YWNsZUdyaWQnLCB0ZXh0dXJlVHlwZTogJzJEQXJyYXknLCBkZXB0aDogbnVtRHluYW1pY0ZyYW1lcyB9LFxuICAgICAgZHJhdzogKGdwZ3B1LCBwcm9ncmFtKSA9PiB7XG4gICAgICAgIGNvbnN0IGdsID0gZ3BncHUuZ2w7XG5cbiAgICAgICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xuXG4gICAgICAgIGNvbnN0IHJlbmRlcmJ1ZmZlciA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuICAgICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyKTtcbiAgICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIGdsLkRFUFRIX0NPTVBPTkVOVDE2LCBwcm9ncmFtLmlucHV0V2lkdGgsIHByb2dyYW0uaW5wdXRIZWlnaHQpO1xuICAgICAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfQVRUQUNITUVOVCwgZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIpO1xuXG4gICAgICAgIGZvciAobGV0IGZyYW1lID0gMDsgZnJhbWUgPCBudW1EeW5hbWljRnJhbWVzOyBmcmFtZSsrKSB7XG4gICAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlTGF5ZXIoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBwcm9ncmFtLm91dHB1dFRleHR1cmUsIDAsIGZyYW1lKTtcbiAgICAgICAgICBjb25zdCBmcmFtZUJ1ZmZlclN0YXR1cyA9IChnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKSA9PSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURSk7XG4gICAgICAgICAgaWYgKCFmcmFtZUJ1ZmZlclN0YXR1cylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgYXR0YWNoaW5nIGZsb2F0IHRleHR1cmUgdG8gZnJhbWVidWZmZXIuIFlvdXIgZGV2aWNlIGlzIHByb2JhYmx5IGluY29tcGF0aWJsZS4nKTtcblxuICAgICAgICAgIGdsLmNsZWFyQ29sb3IoMCwgMCwgMCwgMCk7XG4gICAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQpO1xuXG4gICAgICAgICAgaWYgKG9ic3RhY2xlVmVydGljZXNbZnJhbWVdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmKTtcbiAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBvYnN0YWNsZVZlcnRpY2VzW2ZyYW1lXSwgZ2wuU1RBVElDX0RSQVcpO1xuICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocHJvZ3JhbS5wb3NpdGlvbkxvY2F0aW9uKTtcbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocHJvZ3JhbS5wb3NpdGlvbkxvY2F0aW9uLCAzLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuXG4gICAgICAgICAgICBjb25zdCB4Zm9ybUxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0uZ2xQcm9ncmFtLCAneGZvcm0nKTtcbiAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYoeGZvcm1Mb2NhdGlvbiwgZmFsc2UsIG9ic3RhY2xlWGZvcm0uZWxlbWVudHMpO1xuXG4gICAgICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgb2JzdGFjbGVWZXJ0aWNlc1tmcmFtZV0ubGVuZ3RoIC8gMyk7XG5cbiAgICAgICAgICAgIGlmIChmcmFtZSA9PSAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG9ic3RhY2xlR3JpZCA9IG5ldyBGbG9hdDMyQXJyYXkocHJvZ3JhbS5pbnB1dFdpZHRoICogcHJvZ3JhbS5pbnB1dEhlaWdodCAqIDQpO1xuICAgICAgICAgICAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIHByb2dyYW0uaW5wdXRXaWR0aCwgcHJvZ3JhbS5pbnB1dEhlaWdodCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG9ic3RhY2xlR3JpZCk7XG4gICAgICAgICAgICAgIGdwZ3B1Ll9keW5hbWljT2JzdGFjbGVHcmlkID0gb2JzdGFjbGVHcmlkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbC5kZWxldGVCdWZmZXIoYnVmKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgbnVsbCk7XG4gICAgICAgIGdsLmRlbGV0ZVJlbmRlcmJ1ZmZlcihyZW5kZXJidWZmZXIpO1xuICAgICAgICBnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG5cbiAgdXBkYXRlKGNvbmZpZywgc2xXaWR0aCwgc2xIZWlnaHQsIHNsQ2VudGVyUG9pbnQsIHZlaGljbGVTdGF0aW9uLCBzdGFydFRpbWUsIGR5bmFtaWNGcmFtZVRpbWUsIGR5bmFtaWNPYnN0YWNsZXMpIHtcbiAgICBvYnN0YWNsZVZlcnRpY2VzID0gW107XG5cbiAgICBsZXQgdGltZSA9IHN0YXJ0VGltZTtcbiAgICBmb3IgKGxldCBmcmFtZSA9IDA7IGZyYW1lIDwgbnVtRHluYW1pY0ZyYW1lczsgZnJhbWUrKykge1xuICAgICAgY29uc3QgdmVydGljZXMgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBkeW5hbWljT2JzdGFjbGVzLm1hcChvID0+IG8udmVydGljZXNJblRpbWVSYW5nZSh0aW1lLCB0aW1lICsgZHluYW1pY0ZyYW1lVGltZSwgY29uZmlnKSkpO1xuICAgICAgb2JzdGFjbGVWZXJ0aWNlcy5wdXNoKG5ldyBGbG9hdDMyQXJyYXkodmVydGljZXMpKTtcbiAgICAgIHRpbWUgKz0gZHluYW1pY0ZyYW1lVGltZTtcbiAgICB9XG5cbiAgICBjb25zdCB0cmFuc2xhdGUgPSBuZXcgVEhSRUUuTWF0cml4MygpO1xuICAgIHRyYW5zbGF0ZS5zZXQoXG4gICAgICAxLCAwLCAtc2xDZW50ZXJQb2ludC54IC0gdmVoaWNsZVN0YXRpb24sXG4gICAgICAwLCAxLCAtc2xDZW50ZXJQb2ludC55LFxuICAgICAgMCwgMCwgMVxuICAgICk7XG5cbiAgICBjb25zdCBzY2FsZSA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XG4gICAgc2NhbGUuc2V0KFxuICAgICAgMiAvIChzbFdpZHRoICogY29uZmlnLnNsR3JpZENlbGxTaXplKSwgMCwgMCxcbiAgICAgIDAsIDIgLyAoc2xIZWlnaHQgKiBjb25maWcuc2xHcmlkQ2VsbFNpemUpLCAwLFxuICAgICAgMCwgMCwgMVxuICAgICk7XG5cbiAgICBvYnN0YWNsZVhmb3JtID0gc2NhbGUubXVsdGlwbHkodHJhbnNsYXRlKTtcblxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogc2xXaWR0aCxcbiAgICAgIGhlaWdodDogc2xIZWlnaHRcbiAgICB9XG4gIH1cbn1cbiIsImNvbnN0IFhZU0xfTUFQX0tFUk5FTCA9IGBcblxudmVjNCBrZXJuZWwoKSB7XG4gIHZlYzIgeHkgPSAoa2VybmVsUG9zaXRpb24gLSAwLjUpICogdmVjMihrZXJuZWxTaXplKSAqIHZlYzIoeHlHcmlkQ2VsbFNpemUpICsgeHlDZW50ZXJQb2ludDtcblxuICBpbnQgbnVtU2FtcGxlcyA9IHRleHR1cmVTaXplKGNlbnRlcmxpbmUsIDApLng7XG4gIGludCBjbG9zZXN0ID0gMDtcbiAgZmxvYXQgY2xvc2VzdERpc3QgPSBkaXN0YW5jZSh4eSwgdGV4ZWxGZXRjaChjZW50ZXJsaW5lLCBpdmVjMigwLCAwKSwgMCkueHkpO1xuICBmb3IgKGludCBpID0gMTsgaSA8IG51bVNhbXBsZXM7IGkrKykge1xuICAgIGZsb2F0IGRpc3QgPSBkaXN0YW5jZSh4eSwgdGV4ZWxGZXRjaChjZW50ZXJsaW5lLCBpdmVjMihpLCAwKSwgMCkueHkpO1xuICAgIGlmIChkaXN0IDwgY2xvc2VzdERpc3QpIHtcbiAgICAgIGNsb3Nlc3REaXN0ID0gZGlzdDtcbiAgICAgIGNsb3Nlc3QgPSBpO1xuICAgIH1cbiAgfVxuXG4gIHZlYzIgY2xvc2VzdFBvcyA9IHRleGVsRmV0Y2goY2VudGVybGluZSwgaXZlYzIoY2xvc2VzdCwgMCksIDApLnh5O1xuICB2ZWMyIHByZXYsIG5leHQ7XG4gIGludCBwcmV2SW5kZXgsIG5leHRJbmRleDtcblxuICBpZiAoY2xvc2VzdCA9PSAwKSB7XG4gICAgcHJldkluZGV4ID0gMDtcbiAgICBuZXh0SW5kZXggPSAxO1xuICAgIHByZXYgPSBjbG9zZXN0UG9zO1xuICAgIG5leHQgPSB0ZXhlbEZldGNoKGNlbnRlcmxpbmUsIGl2ZWMyKDEsIDApLCAwKS54eTtcbiAgfSBlbHNlIGlmIChjbG9zZXN0ID09IG51bVNhbXBsZXMgLSAxKSB7XG4gICAgcHJldkluZGV4ID0gY2xvc2VzdCAtIDE7XG4gICAgbmV4dEluZGV4ID0gY2xvc2VzdDtcbiAgICBwcmV2ID0gdGV4ZWxGZXRjaChjZW50ZXJsaW5lLCBpdmVjMihwcmV2SW5kZXgsIDApLCAwKS54eTtcbiAgICBuZXh0ID0gY2xvc2VzdFBvcztcbiAgfSBlbHNlIHtcbiAgICB2ZWMyIGJlZm9yZSA9IHRleGVsRmV0Y2goY2VudGVybGluZSwgaXZlYzIoY2xvc2VzdCAtIDEsIDApLCAwKS54eTtcbiAgICB2ZWMyIGFmdGVyID0gdGV4ZWxGZXRjaChjZW50ZXJsaW5lLCBpdmVjMihjbG9zZXN0ICsgMSwgMCksIDApLnh5O1xuXG4gICAgaWYgKGRpc3RhbmNlKGJlZm9yZSwgeHkpIDwgZGlzdGFuY2UoYWZ0ZXIsIHh5KSkge1xuICAgICAgcHJldkluZGV4ID0gY2xvc2VzdCAtIDE7XG4gICAgICBuZXh0SW5kZXggPSBjbG9zZXN0O1xuICAgICAgcHJldiA9IGJlZm9yZTtcbiAgICAgIG5leHQgPSBjbG9zZXN0UG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmV2SW5kZXggPSBjbG9zZXN0O1xuICAgICAgbmV4dEluZGV4ID0gY2xvc2VzdCArIDE7XG4gICAgICBwcmV2ID0gY2xvc2VzdFBvcztcbiAgICAgIG5leHQgPSBhZnRlcjtcbiAgICB9XG4gIH1cblxuICBmbG9hdCBkaXN0ID0gZGlzdGFuY2UocHJldiwgbmV4dCk7XG4gIGZsb2F0IHByb2dyZXNzID0gY2xhbXAoZG90KHh5IC0gcHJldiwgbmV4dCAtIHByZXYpIC8gZGlzdCAvIGRpc3QsIDAuMCwgMS4wKTtcbiAgdmVjMiBwcm9qZWN0ZWRQb3MgPSAobmV4dCAtIHByZXYpICogdmVjMihwcm9ncmVzcykgKyBwcmV2O1xuXG4gIHJldHVybiB2ZWM0KFxuICAgIChmbG9hdChwcmV2SW5kZXgpICsgcHJvZ3Jlc3MpICogY2VudGVybGluZVN0YXRpb25JbnRlcnZhbCxcbiAgICBzaWduKGRldGVybWluYW50KG1hdDIobmV4dCAtIHByZXYsIHh5IC0gcHJldikpKSAqIGRpc3RhbmNlKHh5LCBwcm9qZWN0ZWRQb3MpLFxuICAgIDAsXG4gICAgMFxuICApO1xufVxuXG5gO1xuXG4vLyBCdWlsZCBYWS1TTCBtYXBcbmV4cG9ydCBkZWZhdWx0IHtcbiAgc2V0VXAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtlcm5lbDogWFlTTF9NQVBfS0VSTkVMLFxuICAgICAgb3V0cHV0OiB7IG5hbWU6ICd4eXNsTWFwJywgZmlsdGVyOiAnbGluZWFyJyB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgY2VudGVybGluZTogeyB0eXBlOiAnc2hhcmVkVGV4dHVyZScgfSxcbiAgICAgICAgeHlDZW50ZXJQb2ludDogeyB0eXBlOiAndmVjMicgfSxcbiAgICAgICAgeHlHcmlkQ2VsbFNpemU6IHsgdHlwZTogJ2Zsb2F0J30sXG4gICAgICAgIGNlbnRlcmxpbmVTdGF0aW9uSW50ZXJ2YWw6IHsgdHlwZTogJ2Zsb2F0J31cbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG4gIHVwZGF0ZShjb25maWcsIHh5V2lkdGgsIHh5SGVpZ2h0LCB4eUNlbnRlclBvaW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB4eVdpZHRoLFxuICAgICAgaGVpZ2h0OiB4eUhlaWdodCxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIHh5Q2VudGVyUG9pbnQ6IFt4eUNlbnRlclBvaW50LngsIHh5Q2VudGVyUG9pbnQueV0sXG4gICAgICAgIHh5R3JpZENlbGxTaXplOiBjb25maWcueHlHcmlkQ2VsbFNpemUsXG4gICAgICAgIGNlbnRlcmxpbmVTdGF0aW9uSW50ZXJ2YWw6IGNvbmZpZy5jZW50ZXJsaW5lU3RhdGlvbkludGVydmFsXG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuIiwiLy8gQ29uZmlnOlxuLy8gbnVtIHN0YXRpb25zXG4vLyBudW0gbGF0aXR1ZGVzXG4vLyBzdGF0aW9uIGNvbm5lY3Rpdml0eVxuLy8gbGF0aXR1ZGUgY29ubmVjdGl2aXR5XG4vL1xuLy8gU2hhcmVkOlxuLy8gbGF0dGljZVxuXG5jb25zdCBPUFRJTUlaRV9DVUJJQ19TSEFSRUQgPSBgXG5cbmNvbnN0IGludCBORVdUT05fSVRFUkFUSU9OUyA9IDE2O1xuY29uc3QgaW50IFJFTEFYQVRJT05fSVRFUkFUSU9OUyA9IDE2O1xuY29uc3QgZmxvYXQgQ09OVkVSR0VOQ0VfRVJST1IgPSAwLjAxO1xuXG4vLyBUaGVzZSB0d28gY29uc3RzIG11c3Qgc3RheSBpbiBzeW5jLlxuY29uc3QgaW50IFNJTVBTT05TX0lOVEVSVkFMUyA9IDg7XG4vL2NvbnN0IGZsb2F0IFNJTVBTT05TX0NPRUZGU1tTSU1QU09OU19JTlRFUlZBTFMgKyAxXSA9IGZsb2F0W10oMS4wLCA0LjAsIDIuMCwgNC4wLCAyLjAsIDQuMCwgMi4wLCA0LjAsIDIuMCwgNC4wLCAyLjAsIDQuMCwgMi4wLCA0LjAsIDIuMCwgNC4wLCAxLjApO1xuY29uc3QgZmxvYXQgU0lNUFNPTlNfQ09FRkZTW1NJTVBTT05TX0lOVEVSVkFMUyArIDFdID0gZmxvYXRbXSgxLjAsIDQuMCwgMi4wLCA0LjAsIDIuMCwgNC4wLCAyLjAsIDQuMCwgMS4wKTtcblxuY29uc3QgZmxvYXQgUEkgPSAzLjE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0MzM4MzI3OTU7XG5jb25zdCBmbG9hdCBUV09fUEkgPSBQSSArIFBJO1xuXG5jb25zdCBmbG9hdCBSRUxBWEFUSU9OX0lURVJBVElPTlNfRiA9IGZsb2F0KFJFTEFYQVRJT05fSVRFUkFUSU9OUyk7XG5jb25zdCBmbG9hdCBTSU1QU09OU19JTlRFUlZBTFNfRiA9IGZsb2F0KFNJTVBTT05TX0lOVEVSVkFMUyk7XG5cbmZsb2F0IHdyYXBBbmdsZShmbG9hdCBhbmdsZSkge1xuICBhbmdsZSA9IG1vZChhbmdsZSwgVFdPX1BJKTtcbiAgaWYgKGFuZ2xlIDw9IC1QSSkgcmV0dXJuIGFuZ2xlICsgVFdPX1BJO1xuICBlbHNlIGlmIChhbmdsZSA+IFBJKSByZXR1cm4gYW5nbGUgLSBUV09fUEk7XG4gIHJldHVybiBhbmdsZTtcbn1cblxudmVjNCBpdGVyYXRlKHZlYzQgZ29hbCwgZmxvYXQgcDAsIGZsb2F0IHAxLCBmbG9hdCBwMiwgZmxvYXQgcDMsIGZsb2F0IHNHKSB7XG4gIGZsb2F0IGRzID0gc0cgLyBTSU1QU09OU19JTlRFUlZBTFNfRjtcbiAgZmxvYXQgc0dfMiA9IHNHICogc0c7XG4gIGZsb2F0IHNHXzMgPSBzR18yICogc0c7XG5cbiAgdmVjMyBkWF9wID0gdmVjMygwLjApO1xuICB2ZWMzIGRZX3AgPSB2ZWMzKDAuMCk7XG4gIHZlYzIgZ3Vlc3MgPSB2ZWMyKDAuMCk7XG4gIGZsb2F0IHMgPSAwLjA7XG5cbiAgZmxvYXQgdGhldGEsIGNvc1RoZXRhLCBzaW5UaGV0YTtcbiAgdmVjMyBkVF9wO1xuXG4gIGZvciAoaW50IGkgPSAwOyBpIDw9IFNJTVBTT05TX0lOVEVSVkFMUzsgaSsrKSB7XG4gICAgZmxvYXQgY29lZmYgPSBTSU1QU09OU19DT0VGRlNbaV07XG5cbiAgICBmbG9hdCBhID0gcDA7XG4gICAgZmxvYXQgYiA9ICgtNS41ICogcDAgKyA5LjAgKiBwMSAtIDQuNSAqIHAyICsgcDMpIC8gc0c7XG4gICAgZmxvYXQgYyA9ICg5LjAgKiBwMCAtIDIyLjUgKiBwMSArIDE4LjAgKiBwMiAtIDQuNSAqIHAzKSAvIHNHXzI7XG4gICAgZmxvYXQgZCA9ICgtNC41ICogKHAwIC0gMy4wICogcDEgKyAzLjAgKiBwMiAtIHAzKSkgLyBzR18zO1xuXG4gICAgdGhldGEgPSAoKChkICogcyAvIDQuMCArIGMgLyAzLjApICogcyArIGIgLyAyLjApICogcyArIGEpICogcztcbiAgICBjb3NUaGV0YSA9IGNvcyh0aGV0YSk7XG4gICAgc2luVGhldGEgPSBzaW4odGhldGEpO1xuXG4gICAgZmxvYXQgc19zRyA9IHMgLyBzRztcblxuICAgIGRUX3AgPSB2ZWMzKFxuICAgICAgLy8gcDFcbiAgICAgICgoMy4zNzUgKiBzX3NHIC0gNy41KSAqIHNfc0cgKyA0LjUpICogc19zRyAqIHMsXG5cbiAgICAgIC8vIHAyXG4gICAgICAoKC0zLjM3NSAqIHNfc0cgKyA2LjApICogc19zRyAtIDIuMjUpICogc19zRyAqIHMsXG5cbiAgICAgIC8vIHNHXG4gICAgICAoKDMuMzc1ICogKHAwIC0gMy4wICogcDEgKyAzLjAgKiBwMiAtIHAzKSAqIHNfc0cgLSAzLjAgKiAoMi4wICogcDAgLSA1LjAgKiBwMSArIDQuMCAqIHAyIC0gcDMpKSAqIHNfc0cgKyAwLjI1ICogKDExLjAgKiBwMCAtIDE4LjAgKiBwMSArIDkuMCAqIHAyIC0gMi4wICogcDMpKSAqIHNfc0cgKiBzX3NHXG4gICAgKTtcblxuICAgIGRYX3AgLT0gY29lZmYgKiBzaW5UaGV0YSAqIGRUX3A7XG4gICAgZFlfcCArPSBjb2VmZiAqIGNvc1RoZXRhICogZFRfcDtcblxuICAgIGd1ZXNzICs9IGNvZWZmICogdmVjMihjb3NUaGV0YSwgc2luVGhldGEpO1xuXG4gICAgcyArPSBkcztcbiAgfVxuXG4gIGZsb2F0IGhPdmVyMyA9IHNHIC8gU0lNUFNPTlNfSU5URVJWQUxTX0YgLyAzLjA7XG5cbiAgdmVjMyBkZWx0YTtcbiAgZGVsdGEueHkgPSBnb2FsLnh5IC0gZ3Vlc3MgKiBoT3ZlcjM7XG4gIGRlbHRhLnogPSB3cmFwQW5nbGUoZ29hbC56IC0gdGhldGEpO1xuXG4gIGlmIChhYnMoZGVsdGEueCkgKyBhYnMoZGVsdGEueSkgKyBhYnMoZGVsdGEueikgPCBDT05WRVJHRU5DRV9FUlJPUilcbiAgICByZXR1cm4gdmVjNChwMSwgcDIsIHNHLCAxLjApO1xuXG4gIGRYX3AueHl6ICo9IGhPdmVyMztcbiAgZFlfcC54eXogKj0gaE92ZXIzO1xuICBkWF9wLnogKz0gY29zVGhldGE7XG4gIGRZX3AueiArPSBzaW5UaGV0YTtcblxuICBtYXQzIGludkphY29iaWFuID0gaW52ZXJzZSh0cmFuc3Bvc2UobWF0MyhkWF9wLCBkWV9wLCBkVF9wKSkpO1xuXG4gIHZlYzMgZGVsdGFQID0gaW52SmFjb2JpYW4gKiBkZWx0YTtcbiAgdmVjNCBwYXJhbXMgPSB2ZWM0KHAxLCBwMiwgc0csIDAuMCk7XG4gIHBhcmFtcy54eXogKz0gZGVsdGFQO1xuXG4gIHJldHVybiBwYXJhbXM7XG59XG5cbi8qIElucHV0OlxuICogICBzdGFydDogKHZlYzQpXG4gKiAgICAgeDogeCBwb3NpdGlvbixcbiAqICAgICB5OiB5IHBvc2l0aW9uLFxuICogICAgIHo6IHRoZXRhIHJvdGF0aW9uLFxuICogICAgIHc6IGsgY3VydmF0dXJlXG4gKiAgIGVuZDogKHZlYzQpXG4gKiAgICAgeDogeCBwb3NpdGlvbixcbiAqICAgICB5OiB5IHBvc2l0aW9uLFxuICogICAgIHo6IHRoZXRhIHJvdGF0aW9uLFxuICogICAgIHc6IGsgY3VydmF0dXJlXG4gKlxuICogT3V0cHV0OiAodmVjNClcbiAqICAgeDogcDEsXG4gKiAgIHk6IHAyLFxuICogICB6OiBzRyxcbiAqICAgdzogMSBpZiBjb252ZXJnZWQsIDAgaWYgbm90XG4gKi9cblxudmVjNCBvcHRpbWl6ZSh2ZWM0IHN0YXJ0LCB2ZWM0IGVuZCkge1xuICAvLyBUcmFuc2xhdGUgYW5kIHJvdGF0ZSBzdGFydCBhbmQgZW5kIHNvIHRoYXQgc3RhcnQgaXMgYXQgdGhlIG9yaWdpblxuICBmbG9hdCBzaW5Sb3QgPSBzaW4oc3RhcnQueik7XG4gIGZsb2F0IGNvc1JvdCA9IGNvcyhzdGFydC56KTtcblxuICB2ZWM0IGRpZmYgPSBlbmQgLSBzdGFydDtcbiAgdmVjNCBnb2FsO1xuICBnb2FsLnh5ID0gbWF0Mihjb3NSb3QsIC1zaW5Sb3QsIHNpblJvdCwgY29zUm90KSAqIGRpZmYueHk7XG4gIGdvYWwueiA9IHdyYXBBbmdsZShkaWZmLnopO1xuICBnb2FsLncgPSBlbmQudztcblxuICB2ZWM0IG9yaWdpbmFsR29hbCA9IGdvYWw7XG4gIHZlYzQgZEdvYWw7XG4gIGRHb2FsLnggPSAwLjA7XG4gIGRHb2FsLnl6dyA9IGdvYWwueXp3IC8gUkVMQVhBVElPTl9JVEVSQVRJT05TX0Y7XG4gIGZsb2F0IGRLMCA9IHN0YXJ0LncgLyBSRUxBWEFUSU9OX0lURVJBVElPTlNfRjtcblxuICAvLyBSZWxheCB0aGUgZ29hbCB0byAoeCwgMCwgMCwgMClcbiAgZ29hbC55encgPSB2ZWMzKDAsIDAsIDApO1xuXG4gIC8vIFJlbGF4IHRoZSBwYXJhbXMgdG8gKDAsIDAsIDAsIDAsIGdvYWwueClcbiAgZmxvYXQgcDAgPSAwLjA7XG4gIGZsb2F0IHAxID0gMC4wO1xuICBmbG9hdCBwMiA9IDAuMDtcbiAgZmxvYXQgcDMgPSAwLjA7XG4gIGZsb2F0IHNHID0gZ29hbC54O1xuXG4gIGlmIChzRyA8IDAuMSkgcmV0dXJuIHZlYzQoMC4wKTtcblxuICBmb3IgKGludCBpID0gMDsgaSA8IFJFTEFYQVRJT05fSVRFUkFUSU9OUzsgaSsrKSB7XG4gICAgcDAgKz0gZEswO1xuICAgIHAzICs9IGRHb2FsLnc7XG4gICAgZ29hbCArPSBkR29hbDtcbiAgICBcbiAgICB2ZWM0IHJlc3VsdCA9IGl0ZXJhdGUoZ29hbCwgcDAsIHAxLCBwMiwgcDMsIHNHKTtcbiAgICBwMSA9IHJlc3VsdC54O1xuICAgIHAyID0gcmVzdWx0Lnk7XG4gICAgc0cgPSByZXN1bHQuejtcbiAgfVxuXG4gIGdvYWwgPSBvcmlnaW5hbEdvYWw7XG5cbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBORVdUT05fSVRFUkFUSU9OUzsgaSsrKSB7XG4gICAgdmVjNCByZXN1bHQgPSBpdGVyYXRlKGdvYWwsIHAwLCBwMSwgcDIsIHAzLCBzRyk7XG4gICAgaWYgKHJlc3VsdC53ID09IDEuMCkge1xuICAgICAgcmVzdWx0LncgPSBzdGVwKDAuMCwgcmVzdWx0LnopO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwMSA9IHJlc3VsdC54O1xuICAgIHAyID0gcmVzdWx0Lnk7XG4gICAgc0cgPSByZXN1bHQuejtcbiAgfVxuXG4gIHJldHVybiB2ZWM0KHAxLCBwMiwgc0csIDAuMCk7XG59XG5cbmA7XG5cbmNvbnN0IE9QVElNSVpFX0NVQklDX0tFUk5FTCA9IE9QVElNSVpFX0NVQklDX1NIQVJFRCArIGBcblxuLy8gd2lkdGg6IHN0YXRpb24gKiBsYXRpdHVkZSBpbmRleFxuLy8gaGVpZ2h0OiBzdGF0aW9uX2Nvbm4gKiBsYXR0aWNlX2Nvbm5cbi8vXG4vLyBsYXR0aWNlOlxuLy8gd2lkdGg6IGxhdGl0dWRlc1xuLy8gaGVpZ2h0OiBzdGF0aW9uc1xuXG52ZWM0IGtlcm5lbCgpIHtcbiAgaXZlYzIgaW5kZXhlcyA9IGl2ZWMyKGtlcm5lbFBvc2l0aW9uICogdmVjMihrZXJuZWxTaXplKSk7XG5cbiAgaW50IGVuZFN0YXRpb24gPSBpbmRleGVzLnggLyBudW1MYXRpdHVkZXM7XG4gIGludCBlbmRMYXRpdHVkZSA9IGludChtb2QoZmxvYXQoaW5kZXhlcy54KSwgZmxvYXQobnVtTGF0aXR1ZGVzKSkpO1xuXG4gIGludCBzdGFydFN0YXRpb24gPSBlbmRTdGF0aW9uIC0gc3RhdGlvbkNvbm5lY3Rpdml0eSArIGluZGV4ZXMueSAvIGxhdGl0dWRlQ29ubmVjdGl2aXR5O1xuICBpbnQgc3RhcnRMYXRpdHVkZSA9IGVuZExhdGl0dWRlIC0gbGF0aXR1ZGVDb25uZWN0aXZpdHkgLyAyICsgaW50KG1vZChmbG9hdChpbmRleGVzLnkpLCBmbG9hdChsYXRpdHVkZUNvbm5lY3Rpdml0eSkpKTtcblxuICBpZiAoc3RhcnRTdGF0aW9uIDwgMCB8fCBzdGFydFN0YXRpb24gPj0gbnVtU3RhdGlvbnMgfHwgc3RhcnRMYXRpdHVkZSA8IDAgfHwgc3RhcnRMYXRpdHVkZSA+PSBudW1MYXRpdHVkZXMpXG4gICAgcmV0dXJuIHZlYzQoMC4wKTtcblxuICB2ZWM0IHN0YXJ0ID0gdGV4ZWxGZXRjaChsYXR0aWNlLCBpdmVjMihzdGFydExhdGl0dWRlLCBzdGFydFN0YXRpb24pLCAwKTtcbiAgdmVjNCBlbmQgPSB0ZXhlbEZldGNoKGxhdHRpY2UsIGl2ZWMyKGVuZExhdGl0dWRlLCBlbmRTdGF0aW9uKSwgMCk7XG5cbiAgcmV0dXJuIG9wdGltaXplKHN0YXJ0LCBlbmQpO1xufVxuXG5gO1xuXG5jb25zdCBPUFRJTUlaRV9DVUJJQ19GUk9NX1ZFSElDTEVfS0VSTkVMID0gT1BUSU1JWkVfQ1VCSUNfU0hBUkVEICsgYFxuXG52ZWM0IGtlcm5lbCgpIHtcbiAgaXZlYzIgaW5kZXhlcyA9IGl2ZWMyKGtlcm5lbFBvc2l0aW9uICogdmVjMihrZXJuZWxTaXplKSk7XG5cbiAgdmVjNCBzdGFydCA9IHZlYzQoMCwgMCwgMCwgY3VydlZlaGljbGUpO1xuICB2ZWM0IGVuZCA9IHRleGVsRmV0Y2gobGF0dGljZSwgaW5kZXhlcywgMCk7XG5cbiAgcmV0dXJuIG9wdGltaXplKHN0YXJ0LCBlbmQpO1xufVxuXG5gO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHNldFVwKCkge1xuICAgIHJldHVybiBbXG4gICAgICB7IC8vIEN1YmljIHBhdGhzIGJldHdlZW4gbGF0dGljZSBub2Rlc1xuICAgICAgICBrZXJuZWw6IE9QVElNSVpFX0NVQklDX0tFUk5FTCxcbiAgICAgICAgb3V0cHV0OiB7IG5hbWU6ICdjdWJpY1BhdGhzJywgcmVhZDogdHJ1ZSB9LFxuICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgIGxhdHRpY2U6IHsgdHlwZTogJ3NoYXJlZFRleHR1cmUnIH0sXG4gICAgICAgICAgbnVtU3RhdGlvbnM6IHsgdHlwZTogJ2ludCcgfSxcbiAgICAgICAgICBudW1MYXRpdHVkZXM6IHsgdHlwZTogJ2ludCcgfSxcbiAgICAgICAgICBzdGF0aW9uQ29ubmVjdGl2aXR5OiB7IHR5cGU6ICdpbnQnIH0sXG4gICAgICAgICAgbGF0aXR1ZGVDb25uZWN0aXZpdHk6IHsgdHlwZTogJ2ludCcgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgeyAvLyBDdWJpYyBwYXRocyBmcm9tIHZlaGljbGUgdG8gbGF0dGljZSBub2Rlc1xuICAgICAgICBrZXJuZWw6IE9QVElNSVpFX0NVQklDX0ZST01fVkVISUNMRV9LRVJORUwsXG4gICAgICAgIG91dHB1dDogeyBuYW1lOiAnY3ViaWNQYXRoc0Zyb21WZWhpY2xlJywgcmVhZDogdHJ1ZSB9LFxuICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgIGxhdHRpY2U6IHsgdHlwZTogJ3NoYXJlZFRleHR1cmUnIH0sXG4gICAgICAgICAgY3VydlZlaGljbGU6IHsgdHlwZTogJ2Zsb2F0JyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdXG4gIH0sXG5cbiAgdXBkYXRlKGNvbmZpZywgcG9zZSkge1xuICAgIHJldHVybiBbXG4gICAgICB7IC8vIEN1YmljIHBhdGhzIGJldHdlZW4gbGF0dGljZSBub2Rlc1xuICAgICAgICB3aWR0aDogY29uZmlnLmxhdHRpY2UubnVtU3RhdGlvbnMgKiBjb25maWcubGF0dGljZS5udW1MYXRpdHVkZXMsXG4gICAgICAgIGhlaWdodDogY29uZmlnLmxhdHRpY2Uuc3RhdGlvbkNvbm5lY3Rpdml0eSAqIGNvbmZpZy5sYXR0aWNlLmxhdGl0dWRlQ29ubmVjdGl2aXR5LFxuICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgIG51bVN0YXRpb25zOiBjb25maWcubGF0dGljZS5udW1TdGF0aW9ucyxcbiAgICAgICAgICBudW1MYXRpdHVkZXM6IGNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyxcbiAgICAgICAgICBzdGF0aW9uQ29ubmVjdGl2aXR5OiBjb25maWcubGF0dGljZS5zdGF0aW9uQ29ubmVjdGl2aXR5LFxuICAgICAgICAgIGxhdGl0dWRlQ29ubmVjdGl2aXR5OiBjb25maWcubGF0dGljZS5sYXRpdHVkZUNvbm5lY3Rpdml0eSxcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHsgLy8gQ3ViaWMgcGF0aHMgZnJvbSB2ZWhpY2xlIHRvIGxhdHRpY2Ugbm9kZXNcbiAgICAgICAgd2lkdGg6IGNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyxcbiAgICAgICAgaGVpZ2h0OiBjb25maWcubGF0dGljZS5zdGF0aW9uQ29ubmVjdGl2aXR5LFxuICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgIGN1cnZWZWhpY2xlOiBwb3NlLmN1cnZcbiAgICAgICAgfVxuICAgICAgfVxuICAgIF07XG4gIH1cbn1cbiIsImNvbnN0IE9QVElNSVpFX0tFUk5FTCA9IGBcblxuY29uc3QgaW50IE5FV1RPTl9JVEVSQVRJT05TID0gMzI7XG5jb25zdCBpbnQgUkVMQVhBVElPTl9JVEVSQVRJT05TID0gMzI7XG5jb25zdCBmbG9hdCBDT05WRVJHRU5DRV9FUlJPUiA9IDAuMDE7XG5cbi8vIFRoZXNlIHR3byBjb25zdHMgbXVzdCBzdGF5IGluIHN5bmMuXG5jb25zdCBpbnQgU0lNUFNPTlNfSU5URVJWQUxTID0gODtcbmNvbnN0IGZsb2F0IFNJTVBTT05TX0NPRUZGU1tTSU1QU09OU19JTlRFUlZBTFMgKyAxXSA9IGZsb2F0W10oMS4wLCA0LjAsIDIuMCwgNC4wLCAyLjAsIDQuMCwgMi4wLCA0LjAsIDEuMCk7XG5cbmNvbnN0IGZsb2F0IFBJID0gMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1O1xuY29uc3QgZmxvYXQgVFdPX1BJID0gUEkgKyBQSTtcblxuY29uc3QgZmxvYXQgUkVMQVhBVElPTl9JVEVSQVRJT05TX0YgPSBmbG9hdChSRUxBWEFUSU9OX0lURVJBVElPTlMpO1xuY29uc3QgZmxvYXQgU0lNUFNPTlNfSU5URVJWQUxTX0YgPSBmbG9hdChTSU1QU09OU19JTlRFUlZBTFMpO1xuXG5mbG9hdCB3cmFwQW5nbGUoZmxvYXQgYW5nbGUpIHtcbiAgYW5nbGUgPSBtb2QoYW5nbGUsIFRXT19QSSk7XG4gIGlmIChhbmdsZSA8PSAtUEkpIHJldHVybiBhbmdsZSArIFRXT19QSTtcbiAgZWxzZSBpZiAoYW5nbGUgPiBQSSkgcmV0dXJuIGFuZ2xlIC0gVFdPX1BJO1xuICByZXR1cm4gYW5nbGU7XG59XG5cbnZlYzQgaXRlcmF0ZSh2ZWM0IGdvYWwsIGZsb2F0IHAwLCBmbG9hdCBwMSwgZmxvYXQgcDIsIGZsb2F0IHAzLCBmbG9hdCBwNCwgZmxvYXQgcDUsIGZsb2F0IHNHKSB7XG4gIGZsb2F0IGRzID0gc0cgLyBTSU1QU09OU19JTlRFUlZBTFNfRjtcbiAgZmxvYXQgc0dfMiA9IHNHICogc0c7XG4gIGZsb2F0IHNHXzMgPSBzR18yICogc0c7XG5cbiAgdmVjMyBkWF9wID0gdmVjMygwLjApO1xuICB2ZWMzIGRZX3AgPSB2ZWMzKDAuMCk7XG4gIHZlYzIgZ3Vlc3MgPSB2ZWMyKDAuMCk7XG4gIGZsb2F0IHMgPSAwLjA7XG5cbiAgZmxvYXQgdGhldGEsIGNvc1RoZXRhLCBzaW5UaGV0YTtcbiAgdmVjMyBkVF9wO1xuXG4gIGZvciAoaW50IGkgPSAwOyBpIDw9IFNJTVBTT05TX0lOVEVSVkFMUzsgaSsrKSB7XG4gICAgZmxvYXQgY29lZmYgPSBTSU1QU09OU19DT0VGRlNbaV07XG5cbiAgICBmbG9hdCBhID0gcDA7XG4gICAgZmxvYXQgYiA9IHAxO1xuICAgIGZsb2F0IGMgPSBwMiAvIDIuMDtcbiAgICBmbG9hdCBkID0gKC03MS44NzUgKiBwMCArIDgxLjAgKiBwMyAtIDEwLjEyNSAqIHA0ICsgcDUgLSAyMS4yNSAqIHAxICogc0cgLSAyLjc1ICogcDIgKiBzR18yKSAvIHNHXzM7XG4gICAgZmxvYXQgZSA9ICgxNjYuNSAqIHAwIC0gMjAyLjUgKiBwMyArIDQwLjUgKiBwNCAtIDQuNSAqIHA1ICsgNDUuMCAqIHAxICogc0cgKyA0LjUgKiBwMiAqIHNHXzIpIC8gKHNHXzIgKiBzR18yKTtcbiAgICBmbG9hdCBmID0gKC05NS42MjUgKiBwMCArIDEyMS41ICogcDMgLSAzMC4zNzUgKiBwNCArIDQuNSAqIHA1IC0gMjQuNzUgKiBwMSAqIHNHIC0gMi4yNSAqIHAyICogc0dfMikgLyAoc0dfMiAqIHNHXzMpO1xuXG4gICAgdGhldGEgPSAoKCgoKGYgKiBzIC8gNi4wICsgZSAvIDUuMCkgKiBzICsgZCAvIDQuMCkgKiBzICsgYyAvIDMuMCkgKiBzICsgYiAvIDIuMCkgKiBzICsgYSkgKiBzO1xuICAgIGNvc1RoZXRhID0gY29zKHRoZXRhKTtcbiAgICBzaW5UaGV0YSA9IHNpbih0aGV0YSk7XG5cbiAgICBmbG9hdCBzXzIgPSBzICogcztcbiAgICBmbG9hdCBzX3NHID0gcyAvIHNHO1xuICAgIGZsb2F0IHNfc0dfMiA9IHNfc0cgKiBzX3NHO1xuICAgIGZsb2F0IHNfc0dfMyA9IHNfc0dfMiAqIHNfc0c7XG4gICAgZmxvYXQgc19zR180ID0gc19zR18zICogc19zRztcbiAgICBmbG9hdCBzX3NHXzUgPSBzX3NHXzQgKiBzX3NHO1xuXG4gICAgZFRfcCA9IHZlYzMoXG4gICAgICAvLyBwM1xuICAgICAgKCgyMC4yNSAqIHNfc0cgLSA0MC41KSAqIHNfc0cgKyAyMC4yNSkgKiBzX3NHXzMgKiBzLFxuXG4gICAgICAvLyBwNFxuICAgICAgKCgtNS4wNjI1ICogc19zRyArIDguMSkgKiBzX3NHIC0gMi41MzEyNSkgKiBzX3NHXzMgKiBzLFxuXG4gICAgICAvLyBzR1xuICAgICAgKDUzLjkwNjI1ICogcDAgLSA2MC43NSAqIHAzICsgNy41OTM3NSAqIHA0IC0gMC43NSAqIHA1KSAqIHNfc0dfNCArIDEwLjYyNSAqIHAxICogcyAqIHNfc0dfMyArIDAuNjg3NSAqIHAyICogc18yICogc19zR18yICsgKC0xMzMuMiAqIHAwICsgMTYyLjAgKiBwMyAtIDMyLjQgKiBwNCArIDMuNiAqIHA1KSAqIHNfc0dfNSArICgtMjcuMCkgKiBwMSAqIHMgKiBzX3NHXzQgLSAxLjggKiBwMiAqIHNfMiAqIHNfc0dfMyArICg3OS42ODc1ICogcDAgLSAxMDEuMjUgKiBwMyArIDI1LjMxMjUgKiBwNCAtIDMuNzUgKiBwNSkgKiBzX3NHXzUgKiBzX3NHICsgMTYuNSAqIHAxICogcyAqIHNfc0dfNSArIDEuMTI1ICogcDIgKiBzXzIgKiBzX3NHXzRcbiAgICApO1xuXG4gICAgZFhfcCAtPSBjb2VmZiAqIHNpblRoZXRhICogZFRfcDtcbiAgICBkWV9wICs9IGNvZWZmICogY29zVGhldGEgKiBkVF9wO1xuXG4gICAgZ3Vlc3MgKz0gY29lZmYgKiB2ZWMyKGNvc1RoZXRhLCBzaW5UaGV0YSk7XG5cbiAgICBzICs9IGRzO1xuICB9XG5cbiAgZmxvYXQgaE92ZXIzID0gc0cgLyBTSU1QU09OU19JTlRFUlZBTFNfRiAvIDMuMDtcblxuICB2ZWMzIGRlbHRhO1xuICBkZWx0YS54eSA9IGdvYWwueHkgLSBndWVzcyAqIGhPdmVyMztcbiAgZGVsdGEueiA9IHdyYXBBbmdsZShnb2FsLnogLSB0aGV0YSk7XG5cbiAgaWYgKGFicyhkZWx0YS54KSArIGFicyhkZWx0YS55KSArIGFicyhkZWx0YS56KSA8IENPTlZFUkdFTkNFX0VSUk9SKVxuICAgIHJldHVybiB2ZWM0KHAzLCBwNCwgc0csIDEuMCk7XG5cbiAgZFhfcC54eXogKj0gaE92ZXIzO1xuICBkWV9wLnh5eiAqPSBoT3ZlcjM7XG4gIGRYX3AueiArPSBjb3NUaGV0YTtcbiAgZFlfcC56ICs9IHNpblRoZXRhO1xuXG4gIG1hdDMgaW52SmFjb2JpYW4gPSBpbnZlcnNlKHRyYW5zcG9zZShtYXQzKGRYX3AsIGRZX3AsIGRUX3ApKSk7XG5cbiAgdmVjMyBkZWx0YVAgPSBpbnZKYWNvYmlhbiAqIGRlbHRhO1xuICB2ZWM0IHBhcmFtcyA9IHZlYzQocDMsIHA0LCBzRywgMC4wKTtcbiAgcGFyYW1zLnh5eiArPSBkZWx0YVA7XG5cbiAgcmV0dXJuIHBhcmFtcztcbn1cblxudmVjNCBvcHRpbWl6ZSh2ZWM0IHN0YXJ0LCB2ZWM0IGVuZCkge1xuICAvLyBUcmFuc2xhdGUgYW5kIHJvdGF0ZSBzdGFydCBhbmQgZW5kIHNvIHRoYXQgc3RhcnQgaXMgYXQgdGhlIG9yaWdpblxuICBmbG9hdCBzaW5Sb3QgPSBzaW4oc3RhcnQueik7XG4gIGZsb2F0IGNvc1JvdCA9IGNvcyhzdGFydC56KTtcblxuICB2ZWM0IGRpZmYgPSBlbmQgLSBzdGFydDtcbiAgdmVjNCBnb2FsO1xuICBnb2FsLnh5ID0gbWF0Mihjb3NSb3QsIC1zaW5Sb3QsIHNpblJvdCwgY29zUm90KSAqIGRpZmYueHk7XG4gIGdvYWwueiA9IHdyYXBBbmdsZShkaWZmLnopO1xuICBnb2FsLncgPSBlbmQudztcblxuICB2ZWM0IG9yaWdpbmFsR29hbCA9IGdvYWw7XG4gIHZlYzQgZEdvYWw7XG4gIGRHb2FsLnggPSAwLjA7XG4gIGRHb2FsLnl6dyA9IGdvYWwueXp3IC8gUkVMQVhBVElPTl9JVEVSQVRJT05TX0Y7XG4gIGZsb2F0IGRfSzAgPSBzdGFydC53IC8gUkVMQVhBVElPTl9JVEVSQVRJT05TX0Y7XG4gIGZsb2F0IGRfZEswID0gZEN1cnZWZWhpY2xlIC8gUkVMQVhBVElPTl9JVEVSQVRJT05TX0Y7XG4gIGZsb2F0IGRfZGRLMCA9IGRkQ3VydlZlaGljbGUgLyBSRUxBWEFUSU9OX0lURVJBVElPTlNfRjtcblxuICAvLyBSZWxheCB0aGUgZ29hbCB0byAoeCwgMCwgMCwgMClcbiAgZ29hbC55encgPSB2ZWMzKDAsIDAsIDApO1xuXG4gIC8vIFJlbGF4IHRoZSBwYXJhbXMgdG8gKDAsIDAsIDAsIDAsIGdvYWwueClcbiAgZmxvYXQgcDAgPSAwLjA7XG4gIGZsb2F0IHAxID0gMC4wO1xuICBmbG9hdCBwMiA9IDAuMDtcbiAgZmxvYXQgcDMgPSAwLjA7XG4gIGZsb2F0IHA0ID0gMC4wO1xuICBmbG9hdCBwNSA9IDAuMDtcbiAgZmxvYXQgc0cgPSBnb2FsLng7XG5cbiAgaWYgKHNHIDwgMC4xKSByZXR1cm4gdmVjNCgwLjApO1xuXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgUkVMQVhBVElPTl9JVEVSQVRJT05TOyBpKyspIHtcbiAgICBwMCArPSBkX0swO1xuICAgIHAxICs9IGRfZEswO1xuICAgIHAyICs9IGRfZGRLMDtcbiAgICBwNSArPSBkR29hbC53O1xuICAgIGdvYWwgKz0gZEdvYWw7XG4gICAgXG4gICAgdmVjNCByZXN1bHQgPSBpdGVyYXRlKGdvYWwsIHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUsIHNHKTtcbiAgICBwMyA9IHJlc3VsdC54O1xuICAgIHA0ID0gcmVzdWx0Lnk7XG4gICAgc0cgPSByZXN1bHQuejtcbiAgfVxuXG4gIGdvYWwgPSBvcmlnaW5hbEdvYWw7XG5cbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBORVdUT05fSVRFUkFUSU9OUzsgaSsrKSB7XG4gICAgdmVjNCByZXN1bHQgPSBpdGVyYXRlKGdvYWwsIHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUsIHNHKTtcbiAgICBpZiAocmVzdWx0LncgPT0gMS4wKSB7XG4gICAgICByZXN1bHQudyA9IHN0ZXAoMC4wLCByZXN1bHQueik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHAzID0gcmVzdWx0Lng7XG4gICAgcDQgPSByZXN1bHQueTtcbiAgICBzRyA9IHJlc3VsdC56O1xuICB9XG5cbiAgcmV0dXJuIHZlYzQocDMsIHA0LCBzRywgMC4wKTtcbn1cblxudmVjNCBrZXJuZWwoKSB7XG4gIGl2ZWMyIGxhdHRpY2VJbmRleGVzID0gaXZlYzIoa2VybmVsUG9zaXRpb24gKiB2ZWMyKGtlcm5lbFNpemUpKTtcblxuICB2ZWM0IHN0YXJ0ID0gdmVjNCgwLCAwLCAwLCBjdXJ2VmVoaWNsZSk7XG4gIHZlYzQgZW5kID0gdGV4ZWxGZXRjaChsYXR0aWNlLCBsYXR0aWNlSW5kZXhlcywgMCk7XG5cbiAgcmV0dXJuIG9wdGltaXplKHN0YXJ0LCBlbmQpO1xufVxuXG5gO1xuXG4vLyBRdWludGljIHNwaXJhbCBwYXRoIG9wdGltaXplclxuLy8gICAqIFN0YXJ0IG9mIHBhdGhzIGlzIHRoZSB2ZWhpY2xlIHBvc2Vcbi8vICAgICAqIHgtcG9zLCB5LXBvcywgYW5kIHJvdGF0aW9uIGFyZW4ndCBuZWVkZWQsIHNpbmNlIHRoZSBsYXR0aWNlIG9yaWdpbiBpcyB0aGUgdmVoaWNsZSBwb3NlXG4vLyAgICAgKiBTbyBhc3N1bWUgcG9zaXRpb24gYW5kIHJvdGF0aW9uIGFyZSAwXG4vLyAgICogRW5kcyBvZiBwYXRocyBhcmUgYWxsIGxhdGl0dWRlcyB3aXRoaW4gdGhlIGZpcnN0IChzdGF0aW9uQ29ubmVjdGl2aXR5KSBzdGF0aW9uc1xuZXhwb3J0IGRlZmF1bHQge1xuICBzZXRVcCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2VybmVsOiBPUFRJTUlaRV9LRVJORUwsXG4gICAgICBvdXRwdXQ6IHsgbmFtZTogJ3F1aW50aWNQYXRoc0Zyb21WZWhpY2xlJywgcmVhZDogdHJ1ZSB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgbGF0dGljZTogeyB0eXBlOiAnc2hhcmVkVGV4dHVyZScgfSxcbiAgICAgICAgY3VydlZlaGljbGU6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICAgICAgICBkQ3VydlZlaGljbGU6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICAgICAgICBkZEN1cnZWZWhpY2xlOiB7IHR5cGU6ICdmbG9hdCcgfVxuICAgICAgfVxuICAgIH07XG4gIH0sXG5cbiAgdXBkYXRlKGNvbmZpZywgcG9zZSkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzLFxuICAgICAgaGVpZ2h0OiBjb25maWcubGF0dGljZS5zdGF0aW9uQ29ubmVjdGl2aXR5LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgY3VydlZlaGljbGU6IHBvc2UuY3VydixcbiAgICAgICAgZEN1cnZWZWhpY2xlOiBwb3NlLmRDdXJ2LFxuICAgICAgICBkZEN1cnZWZWhpY2xlOiBwb3NlLmRkQ3VydlxuICAgICAgfVxuICAgIH07XG4gIH1cbn1cbiIsImNvbnN0IFNIQVJFRF9TSEFERVIgPSBgXG5cbmNvbnN0IGZsb2F0IHNtYWxsViA9IDAuMDE7XG52ZWM0IHBhdGhTYW1wbGVzWzEyOF07XG5mbG9hdCBwYXRoU2FtcGxlQ3VydlJhdGVzWzEyOF07XG5cbmZsb2F0IGNhbGN1bGF0ZUFjY2VsZXJhdGlvbihpbnQgaW5kZXgsIGZsb2F0IGluaXRpYWxWZWxvY2l0eVNxLCBmbG9hdCBkaXN0YW5jZSkge1xuICBpZiAoaW5kZXggPD0gNCkge1xuICAgIC8vIFthTWF4SGFyZCwgYU1pbkhhcmQsIGFNYXhTb2Z0LCBhTWluU29mdCwgMF1cbiAgICByZXR1cm4gYWNjZWxlcmF0aW9uUHJvZmlsZXNbaW5kZXhdO1xuICB9IGVsc2Uge1xuICAgIGZsb2F0IGZpbmFsVmVsb2NpdHkgPSBmaW5hbFZlbG9jaXR5UHJvZmlsZXNbaW5kZXggLSA1XTtcbiAgICBpZiAoZGlzdGFuY2UgPCAwLjAwMSkgcmV0dXJuIDAuMDtcbiAgICByZXR1cm4gY2xhbXAoKGZpbmFsVmVsb2NpdHkgKiBmaW5hbFZlbG9jaXR5IC0gaW5pdGlhbFZlbG9jaXR5U3EpIC8gKDIuMCAqIGRpc3RhbmNlKSwgYWNjZWxlcmF0aW9uUHJvZmlsZXNbMV0sIGFjY2VsZXJhdGlvblByb2ZpbGVzWzBdKTtcbiAgfVxufVxuXG52ZWMyIHh5MnNsKHZlYzQgeHl0aykge1xuICB2ZWMyIHh5ID0geHl0ay54eSArIHJlYXJBeGxlVG9DZW50ZXIgKiB2ZWMyKGNvcyh4eXRrLnopLCBzaW4oeHl0ay56KSk7XG4gIHZlYzIgeHlUZXhDb29yZHMgPSAoeHkgLSB4eUNlbnRlclBvaW50KSAvIHZlYzIodGV4dHVyZVNpemUoeHlzbE1hcCwgMCkpIC8gdmVjMih4eUdyaWRDZWxsU2l6ZSkgKyAwLjU7XG4gIHJldHVybiB0ZXh0dXJlKHh5c2xNYXAsIHh5VGV4Q29vcmRzKS54eTtcbn1cblxuZmxvYXQgc2FtcGxlU3RhdGljQ29zdCh2ZWM0IHh5dGspIHtcbiAgdmVjMiBzbCA9IHh5MnNsKHh5dGspO1xuICB2ZWMyIHNsVGV4Q29vcmRzID0gKHNsIC0gc2xDZW50ZXJQb2ludCkgLyB2ZWMyKHRleHR1cmVTaXplKHNsT2JzdGFjbGVHcmlkLCAwKSkgLyB2ZWMyKHNsR3JpZENlbGxTaXplKSArIDAuNTtcbiAgZmxvYXQgb2JzdGFjbGVDb3N0ID0gdGV4dHVyZShzbE9ic3RhY2xlR3JpZCwgc2xUZXhDb29yZHMpLnI7XG5cbiAgaWYgKG9ic3RhY2xlQ29zdCA+PSAwLjc1KSByZXR1cm4gLTEuMDsgLy8gSW5maW5pdGUgY29zdFxuXG4gIG9ic3RhY2xlQ29zdCA9IHN0ZXAoMC4yNSwgb2JzdGFjbGVDb3N0KSAqIG9ic3RhY2xlSGF6YXJkQ29zdDtcblxuICBmbG9hdCBhYnNMYXRpdHVkZSA9IGFicyhzbC55KTtcbiAgaWYgKGFic0xhdGl0dWRlID49IGxhbmVTaG91bGRlckxhdGl0dWRlKSByZXR1cm4gLTEuMDtcblxuICBmbG9hdCBsYW5lQ29zdCA9IGFicyhhYnNMYXRpdHVkZSAtIGxhbmVDZW50ZXJMYXRpdHVkZSkgKiBsYW5lQ29zdFNsb3BlICsgc3RlcCgwLjAsIC1zbC55ICogc2lnbihsYW5lUHJlZmVyZW5jZSkpICogbGFuZVByZWZlcmVuY2VEaXNjb3VudDtcblxuICByZXR1cm4gb2JzdGFjbGVDb3N0ICsgbGFuZUNvc3Q7XG59XG5cbmZsb2F0IHNhbXBsZUR5bmFtaWNDb3N0KHZlYzQgeHl0aywgZmxvYXQgdGltZSwgZmxvYXQgdmVsb2NpdHksIGZsb2F0IGFjY2VsZXJhdGlvbikge1xuICB2ZWMyIHNsID0geHkyc2woeHl0ayk7XG4gIHZlYzIgc2xUZXhDb29yZHMgPSAoc2wgLSBzbENlbnRlclBvaW50KSAvIHZlYzIodGV4dHVyZVNpemUoc2xEeW5hbWljT2JzdGFjbGVHcmlkLCAwKS54eSkgLyB2ZWMyKHNsR3JpZENlbGxTaXplKSArIDAuNTtcbiAgZmxvYXQgZHluYW1pY0ZyYW1lID0gZmxvb3IodGltZSAvIGR5bmFtaWNGcmFtZVRpbWUpO1xuXG4gIGZsb2F0IG9ic3RhY2xlQ29zdCA9IHRleHR1cmUoc2xEeW5hbWljT2JzdGFjbGVHcmlkLCB2ZWMzKHNsVGV4Q29vcmRzLCBkeW5hbWljRnJhbWUpKS5yO1xuXG4gIGlmIChvYnN0YWNsZUNvc3QgPiAwLjc1KSByZXR1cm4gLTEuMDsgLy8gSW5maW5pdGUgY29zdFxuXG4gIHJldHVybiBzdGVwKDAuMjUsIG9ic3RhY2xlQ29zdCkgKiBvYnN0YWNsZUhhemFyZENvc3Q7XG59XG5cbmZsb2F0IGNhbGN1bGF0ZUF2ZXJhZ2VTdGF0aWNDb3N0KGludCBudW1TYW1wbGVzKSB7XG4gIGZsb2F0IGF2ZXJhZ2VTdGF0aWNDb3N0ID0gMC4wO1xuXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgbnVtU2FtcGxlczsgaSsrKSB7XG4gICAgZmxvYXQgY29zdCA9IHNhbXBsZVN0YXRpY0Nvc3QocGF0aFNhbXBsZXNbaV0pO1xuXG4gICAgaWYgKGNvc3QgPCAwLjApIHJldHVybiBjb3N0O1xuXG4gICAgYXZlcmFnZVN0YXRpY0Nvc3QgKz0gY29zdDtcbiAgfVxuXG4gIGF2ZXJhZ2VTdGF0aWNDb3N0IC89IGZsb2F0KG51bVNhbXBsZXMpO1xuXG4gIHJldHVybiBhdmVyYWdlU3RhdGljQ29zdDtcbn1cblxuZmxvYXQgY2FsY3VsYXRlQXZlcmFnZUR5bmFtaWNDb3N0KGludCBudW1TYW1wbGVzLCBmbG9hdCBwYXRoTGVuZ3RoLCBmbG9hdCBpbml0aWFsVGltZSwgZmxvYXQgaW5pdGlhbFZlbG9jaXR5LCBmbG9hdCBhY2NlbGVyYXRpb24sIGZsb2F0IGFiYW5kb25UaHJlc2hvbGQpIHtcbiAgZmxvYXQgcyA9IDAuMDtcbiAgZmxvYXQgZHMgPSBwYXRoTGVuZ3RoIC8gZmxvYXQobnVtU2FtcGxlcyAtIDEpO1xuICBmbG9hdCBhdmVyYWdlRHluYW1pY0Nvc3QgPSAwLjA7XG4gIGZsb2F0IG1heFZlbG9jaXR5ID0gMC4wO1xuICBmbG9hdCBtYXhMYXRlcmFsQWNjZWxlcmF0aW9uID0gMC4wO1xuICBmbG9hdCBudW1TYW1wbGVzX2YgPSBmbG9hdChudW1TYW1wbGVzKTtcblxuICBmb3IgKGludCBpID0gMDsgaSA8IG51bVNhbXBsZXM7IGkrKykge1xuICAgIHZlYzQgcGF0aFNhbXBsZSA9IHBhdGhTYW1wbGVzW2ldOyAvLyB2ZWM0KHgtcG9zLCB5LXBvcywgdGhldGEgKHJvdGF0aW9uKSwga2FwcGEgKGN1cnZhdHVyZSkpXG5cbiAgICBmbG9hdCB2ZWxvY2l0eVNxID0gMi4wICogYWNjZWxlcmF0aW9uICogcyArIGluaXRpYWxWZWxvY2l0eSAqIGluaXRpYWxWZWxvY2l0eTtcbiAgICBmbG9hdCB2ZWxvY2l0eSA9IG1heChzbWFsbFYsIHNxcnQobWF4KDAuMCwgdmVsb2NpdHlTcSkpKTtcbiAgICBtYXhWZWxvY2l0eSA9IG1heChtYXhWZWxvY2l0eSwgdmVsb2NpdHkpO1xuICAgIG1heExhdGVyYWxBY2NlbGVyYXRpb24gPSBtYXgobWF4TGF0ZXJhbEFjY2VsZXJhdGlvbiwgYWJzKHBhdGhTYW1wbGUudyAqIHZlbG9jaXR5ICogdmVsb2NpdHkpKTtcblxuICAgIGZsb2F0IHRpbWUgPSAyLjAgKiBzIC8gKGluaXRpYWxWZWxvY2l0eSArIHZlbG9jaXR5KSArIGluaXRpYWxUaW1lO1xuXG4gICAgZmxvYXQgZEN1cnYgPSBwYXRoU2FtcGxlQ3VydlJhdGVzW2ldICogdmVsb2NpdHk7XG4gICAgaWYgKGRDdXJ2ID4gZEN1cnZhdHVyZU1heCkgcmV0dXJuIC0xLjA7XG5cbiAgICBmbG9hdCBjb3N0ID0gc2FtcGxlRHluYW1pY0Nvc3QocGF0aFNhbXBsZSwgdGltZSwgdmVsb2NpdHksIGFjY2VsZXJhdGlvbik7XG4gICAgaWYgKGNvc3QgPCAwLjApIHJldHVybiBjb3N0O1xuXG4gICAgYXZlcmFnZUR5bmFtaWNDb3N0ICs9IGNvc3Q7XG4gICAgaWYgKGF2ZXJhZ2VEeW5hbWljQ29zdCAvIG51bVNhbXBsZXNfZiA+PSBhYmFuZG9uVGhyZXNob2xkKSByZXR1cm4gLTEuMDtcblxuICAgIHMgKz0gZHM7XG4gIH1cblxuICBhdmVyYWdlRHluYW1pY0Nvc3QgLz0gbnVtU2FtcGxlc19mO1xuXG4gIC8vIEFwcGx5IHNwZWVkaW5nIHBlbmFsaXR5IGlmIGFueSB2ZWxvY2l0eSBhbG9uZyB0aGUgdHJhamVjdG9yeSBpcyBvdmVyIHRoZSBzcGVlZCBsaW1pdFxuICBhdmVyYWdlRHluYW1pY0Nvc3QgKz0gc3RlcChzcGVlZExpbWl0LCBtYXhWZWxvY2l0eSkgKiBzcGVlZExpbWl0UGVuYWx0eTtcblxuICAvLyBBcHBseSBoYXJkIGFjY2VsZXJhdGlvbi9kZWNlbGVyYXRpb24gcGVuYWx0aWVzIGlmIHRoZSBhY2NlbGVyYXRpb24vZGVjZWxlcmF0aW9uIGV4Y2VlZHMgdGhlIHNvZnQgbGltaXRzXG4gIGF2ZXJhZ2VEeW5hbWljQ29zdCArPSBzdGVwKGFjY2VsZXJhdGlvblByb2ZpbGVzWzJdICsgMC4wMDAxLCBhY2NlbGVyYXRpb24pICogaGFyZEFjY2VsZXJhdGlvblBlbmFsdHk7XG4gIGF2ZXJhZ2VEeW5hbWljQ29zdCArPSAoMS4wIC0gc3RlcChhY2NlbGVyYXRpb25Qcm9maWxlc1szXSwgYWNjZWxlcmF0aW9uKSkgKiBoYXJkRGVjZWxlcmF0aW9uUGVuYWx0eTtcblxuICAvLyBQZW5hbGl6ZSBsYXRlcmFsIGFjY2VsZXJhdGlvblxuICBhdmVyYWdlRHluYW1pY0Nvc3QgKz0gc3RlcChzb2Z0TGF0ZXJhbEFjY2VsZXJhdGlvbkxpbWl0LCBtYXhMYXRlcmFsQWNjZWxlcmF0aW9uKSAqIHNvZnRMYXRlcmFsQWNjZWxlcmF0aW9uUGVuYWx0eTtcbiAgYXZlcmFnZUR5bmFtaWNDb3N0ICs9IGxpbmVhckxhdGVyYWxBY2NlbGVyYXRpb25QZW5hbHR5ICogbWF4TGF0ZXJhbEFjY2VsZXJhdGlvbjtcblxuICByZXR1cm4gYXZlcmFnZUR5bmFtaWNDb3N0O1xufVxuXG52ZWMzIGNhbGN1bGF0ZUFWVChpbnQgYWNjZWxlcmF0aW9uSW5kZXgsIGZsb2F0IGluaXRpYWxWZWxvY2l0eSwgZmxvYXQgaW5pdGlhbFRpbWUsIGZsb2F0IHBhdGhMZW5ndGgpIHtcbiAgZmxvYXQgaW5pdGlhbFZlbG9jaXR5U3EgPSBpbml0aWFsVmVsb2NpdHkgKiBpbml0aWFsVmVsb2NpdHk7XG4gIGZsb2F0IGFjY2VsZXJhdGlvbiA9IGNhbGN1bGF0ZUFjY2VsZXJhdGlvbihhY2NlbGVyYXRpb25JbmRleCwgaW5pdGlhbFZlbG9jaXR5U3EsIHBhdGhMZW5ndGgpO1xuXG4gIGZsb2F0IGZpbmFsVmVsb2NpdHlTcSA9IDIuMCAqIGFjY2VsZXJhdGlvbiAqIHBhdGhMZW5ndGggKyBpbml0aWFsVmVsb2NpdHlTcTtcbiAgZmxvYXQgZmluYWxWZWxvY2l0eSA9IG1heChzbWFsbFYsIHNxcnQobWF4KDAuMCwgZmluYWxWZWxvY2l0eVNxKSkpO1xuXG4gIGZsb2F0IGZpbmFsVGltZSA9IGluaXRpYWxUaW1lO1xuXG4gIGlmIChhY2NlbGVyYXRpb24gPT0gMC4wKSB7XG4gICAgZmluYWxUaW1lICs9IHBhdGhMZW5ndGggLyBmaW5hbFZlbG9jaXR5O1xuICB9IGVsc2UgaWYgKGZpbmFsVmVsb2NpdHlTcSA8PSAwLjApIHsgLy8gQ2FsY3VsYXRlIGZpbmFsIHRpbWUgaWYgdGhlIHZlaGljbGUgc3RvcHMgYmVmb3JlIHRoZSBlbmQgb2YgdGhlIHRyYWplY3RvcnlcbiAgICBmbG9hdCBkaXN0YW5jZUxlZnQgPSBwYXRoTGVuZ3RoIC0gKHNtYWxsViAqIHNtYWxsViAtIGluaXRpYWxWZWxvY2l0eVNxKSAvICgyLjAgKiBhY2NlbGVyYXRpb24pO1xuICAgIGZpbmFsVGltZSArPSAoZmluYWxWZWxvY2l0eSAtIGluaXRpYWxWZWxvY2l0eSkgLyBhY2NlbGVyYXRpb24gKyBkaXN0YW5jZUxlZnQgLyBzbWFsbFY7XG4gIH0gZWxzZSB7XG4gICAgZmluYWxUaW1lICs9IDIuMCAqIHBhdGhMZW5ndGggLyAoZmluYWxWZWxvY2l0eSArIGluaXRpYWxWZWxvY2l0eSk7XG4gIH1cblxuICByZXR1cm4gdmVjMyhhY2NlbGVyYXRpb24sIGZpbmFsVmVsb2NpdHksIGZpbmFsVGltZSk7XG59XG5cbmA7XG5cbmNvbnN0IFNBTVBMRV9DVUJJQ19QQVRIX0ZOID0gYFxuXG5pbnQgc2FtcGxlQ3ViaWNQYXRoKHZlYzQgc3RhcnQsIHZlYzQgZW5kLCB2ZWM0IGN1YmljUGF0aFBhcmFtcykge1xuICBmbG9hdCBwMCA9IHN0YXJ0Lnc7XG4gIGZsb2F0IHAxID0gY3ViaWNQYXRoUGFyYW1zLng7XG4gIGZsb2F0IHAyID0gY3ViaWNQYXRoUGFyYW1zLnk7XG4gIGZsb2F0IHAzID0gZW5kLnc7XG4gIGZsb2F0IHNHID0gY3ViaWNQYXRoUGFyYW1zLno7XG5cbiAgaWYgKHNHIDw9IDAuMCkgcmV0dXJuIDA7XG5cbiAgaW50IG51bVNhbXBsZXMgPSBpbnQoY2VpbChzRyAvIHBhdGhTYW1wbGluZ1N0ZXApKSArIDE7XG5cbiAgZmxvYXQgc0dfMiA9IHNHICogc0c7XG4gIGZsb2F0IHNHXzMgPSBzR18yICogc0c7XG5cbiAgZmxvYXQgYSA9IHAwO1xuICBmbG9hdCBiID0gKC01LjUgKiBwMCArIDkuMCAqIHAxIC0gNC41ICogcDIgKyBwMykgLyBzRztcbiAgZmxvYXQgYyA9ICg5LjAgKiBwMCAtIDIyLjUgKiBwMSArIDE4LjAgKiBwMiAtIDQuNSAqIHAzKSAvIHNHXzI7XG4gIGZsb2F0IGQgPSAoLTQuNSAqIChwMCAtIDMuMCAqIHAxICsgMy4wICogcDIgLSBwMykpIC8gc0dfMztcblxuICBwYXRoU2FtcGxlc1swXSA9IHN0YXJ0O1xuXG4gIGZsb2F0IGRzID0gc0cgLyBmbG9hdChudW1TYW1wbGVzIC0gMSk7XG4gIGZsb2F0IHMgPSBkcztcbiAgdmVjMiBkeHkgPSB2ZWMyKDApO1xuICB2ZWMyIHByZXZDb3NTaW4gPSB2ZWMyKGNvcyhzdGFydC56KSwgc2luKHN0YXJ0LnopKTtcblxuICBmb3IgKGludCBpID0gMTsgaSA8IG51bVNhbXBsZXM7IGkrKykge1xuICAgIGZsb2F0IHJvdCA9ICgoKGQgKiBzIC8gNC4wICsgYyAvIDMuMCkgKiBzICsgYiAvIDIuMCkgKiBzICsgYSkgKiBzICsgc3RhcnQuejtcbiAgICBmbG9hdCBjdXJ2ID0gKChkICogcyArIGMpICogcyArIGIpICogcyArIGE7XG5cbiAgICB2ZWMyIGNvc1NpbiA9IHZlYzIoY29zKHJvdCksIHNpbihyb3QpKTtcbiAgICBkeHkgPSBkeHkgKiB2ZWMyKGZsb2F0KGkgLSAxKSAvIGZsb2F0KGkpKSArIChjb3NTaW4gKyBwcmV2Q29zU2luKSAvIHZlYzIoMiAqIGkpO1xuXG4gICAgcGF0aFNhbXBsZXNbaV0gPSB2ZWM0KGR4eSAqIHZlYzIocykgKyBzdGFydC54eSwgcm90LCBjdXJ2KTtcbiAgICBwYXRoU2FtcGxlQ3VydlJhdGVzW2ldID0gYiArIHMgKiAoMi4wICogYyArIDMuMCAqIGQgKiBzKTtcblxuICAgIHMgKz0gZHM7XG4gICAgcHJldkNvc1NpbiA9IGNvc1NpbjtcbiAgfVxuXG4gIHJldHVybiBudW1TYW1wbGVzO1xufVxuXG5gO1xuXG5jb25zdCBTQU1QTEVfUVVJTlRJQ19QQVRIX0ZOID0gYFxuXG5pbnQgc2FtcGxlUXVpbnRpY1BhdGgodmVjNCBzdGFydCwgdmVjNCBlbmQsIHZlYzQgcXVpbnRpY1BhdGhQYXJhbXMpIHtcbiAgZmxvYXQgcDAgPSBzdGFydC53O1xuICBmbG9hdCBwMSA9IGRDdXJ2VmVoaWNsZTtcbiAgZmxvYXQgcDIgPSBkZEN1cnZWZWhpY2xlO1xuICBmbG9hdCBwMyA9IHF1aW50aWNQYXRoUGFyYW1zLng7XG4gIGZsb2F0IHA0ID0gcXVpbnRpY1BhdGhQYXJhbXMueTtcbiAgZmxvYXQgcDUgPSBlbmQudztcbiAgZmxvYXQgc0cgPSBxdWludGljUGF0aFBhcmFtcy56O1xuXG4gIGlmIChzRyA8PSAwLjApIHJldHVybiAwO1xuXG4gIGludCBudW1TYW1wbGVzID0gaW50KGNlaWwoc0cgLyBwYXRoU2FtcGxpbmdTdGVwKSkgKyAxO1xuXG4gIGZsb2F0IHNHXzIgPSBzRyAqIHNHO1xuICBmbG9hdCBzR18zID0gc0dfMiAqIHNHO1xuXG4gIGZsb2F0IGEgPSBwMDtcbiAgZmxvYXQgYiA9IHAxO1xuICBmbG9hdCBjID0gcDIgLyAyLjA7XG4gIGZsb2F0IGQgPSAoLTcxLjg3NSAqIHAwICsgODEuMCAqIHAzIC0gMTAuMTI1ICogcDQgKyBwNSAtIDIxLjI1ICogcDEgKiBzRyAtIDIuNzUgKiBwMiAqIHNHXzIpIC8gc0dfMztcbiAgZmxvYXQgZSA9ICgxNjYuNSAqIHAwIC0gMjAyLjUgKiBwMyArIDQwLjUgKiBwNCAtIDQuNSAqIHA1ICsgNDUuMCAqIHAxICogc0cgKyA0LjUgKiBwMiAqIHNHXzIpIC8gKHNHXzIgKiBzR18yKTtcbiAgZmxvYXQgZiA9ICgtOTUuNjI1ICogcDAgKyAxMjEuNSAqIHAzIC0gMzAuMzc1ICogcDQgKyA0LjUgKiBwNSAtIDI0Ljc1ICogcDEgKiBzRyAtIDIuMjUgKiBwMiAqIHNHXzIpIC8gKHNHXzIgKiBzR18zKTtcblxuICBwYXRoU2FtcGxlc1swXSA9IHN0YXJ0O1xuXG4gIGZsb2F0IGRzID0gc0cgLyBmbG9hdChudW1TYW1wbGVzIC0gMSk7XG4gIGZsb2F0IHMgPSBkcztcbiAgdmVjMiBkeHkgPSB2ZWMyKDApO1xuICB2ZWMyIHByZXZDb3NTaW4gPSB2ZWMyKGNvcyhzdGFydC56KSwgc2luKHN0YXJ0LnopKTtcblxuICBmb3IgKGludCBpID0gMTsgaSA8IG51bVNhbXBsZXM7IGkrKykge1xuICAgIGZsb2F0IHJvdCA9ICgoKCgoZiAqIHMgLyA2LjAgKyBlIC8gNS4wKSAqIHMgKyBkIC8gNC4wKSAqIHMgKyBjIC8gMy4wKSAqIHMgKyBiIC8gMi4wKSAqIHMgKyBhKSAqIHMgKyBzdGFydC56O1xuICAgIGZsb2F0IGN1cnYgPSAoKCgoZiAqIHMgKyBlKSAqIHMgKyBkKSAqIHMgKyBjKSAqIHMgKyBiKSAqIHMgKyBhO1xuXG4gICAgdmVjMiBjb3NTaW4gPSB2ZWMyKGNvcyhyb3QpLCBzaW4ocm90KSk7XG4gICAgZHh5ID0gZHh5ICogdmVjMihmbG9hdChpIC0gMSkgLyBmbG9hdChpKSkgKyAoY29zU2luICsgcHJldkNvc1NpbikgLyB2ZWMyKDIgKiBpKTtcblxuICAgIHBhdGhTYW1wbGVzW2ldID0gdmVjNChkeHkgKiB2ZWMyKHMpICsgc3RhcnQueHksIHJvdCwgY3Vydik7XG4gICAgcGF0aFNhbXBsZUN1cnZSYXRlc1tpXSA9IGIgKyBzICogKDIuMCAqIGMgKyBzICogKDMuMCAqIGQgKyBzICogKDQuMCAqIGUgKyA1LjAgKiBmICogcykpKTtcblxuICAgIHMgKz0gZHM7XG4gICAgcHJldkNvc1NpbiA9IGNvc1NpbjtcbiAgfVxuXG4gIHJldHVybiBudW1TYW1wbGVzO1xufVxuXG5gO1xuXG5jb25zdCBOVU1fQUNDRUxFUkFUSU9OX1BST0ZJTEVTID0gODtcbmNvbnN0IE5VTV9WRUxPQ0lUWV9SQU5HRVMgPSA0O1xuY29uc3QgTlVNX1RJTUVfUkFOR0VTID0gMjtcblxuY29uc3QgU0hBUkVEX1VOSUZPUk1TID0ge1xuICB4eXNsTWFwOiB7IHR5cGU6ICdvdXRwdXRUZXh0dXJlJyB9LFxuICBzbE9ic3RhY2xlR3JpZDogeyB0eXBlOiAnb3V0cHV0VGV4dHVyZScsIG5hbWU6ICdzbE9ic3RhY2xlR3JpZERpbGF0ZWQnIH0sXG4gIHNsRHluYW1pY09ic3RhY2xlR3JpZDogeyB0eXBlOiAnb3V0cHV0VGV4dHVyZScsIG5hbWU6ICdzbER5bmFtaWNPYnN0YWNsZUdyaWQnLCB0ZXh0dXJlVHlwZTogJzJEQXJyYXknIH0sXG4gIGFjY2VsZXJhdGlvblByb2ZpbGVzOiB7IHR5cGU6ICdmbG9hdCcsIGxlbmd0aDogNSB9LFxuICBmaW5hbFZlbG9jaXR5UHJvZmlsZXM6IHsgdHlwZTogJ2Zsb2F0JywgbGVuZ3RoOiAzIH0sXG4gIHh5Q2VudGVyUG9pbnQ6IHsgdHlwZTogJ3ZlYzInIH0sXG4gIHh5R3JpZENlbGxTaXplOiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgc2xDZW50ZXJQb2ludDogeyB0eXBlOiAndmVjMicgfSxcbiAgc2xHcmlkQ2VsbFNpemU6IHsgdHlwZTogJ2Zsb2F0J30sXG4gIGxhbmVDZW50ZXJMYXRpdHVkZTogeyB0eXBlOiAnZmxvYXQnfSxcbiAgbGFuZVNob3VsZGVyTGF0aXR1ZGU6IHsgdHlwZTogJ2Zsb2F0J30sXG4gIGxhbmVDb3N0U2xvcGU6IHsgdHlwZTogJ2Zsb2F0J30sXG4gIGxhbmVQcmVmZXJlbmNlOiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgbGFuZVByZWZlcmVuY2VEaXNjb3VudDogeyB0eXBlOiAnZmxvYXQnIH0sXG4gIG9ic3RhY2xlSGF6YXJkQ29zdDogeyB0eXBlOiAnZmxvYXQnIH0sXG4gIHNwZWVkTGltaXQ6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICBzcGVlZExpbWl0UGVuYWx0eTogeyB0eXBlOiAnZmxvYXQnIH0sXG4gIGhhcmRBY2NlbGVyYXRpb25QZW5hbHR5OiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgaGFyZERlY2VsZXJhdGlvblBlbmFsdHk6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICBzb2Z0TGF0ZXJhbEFjY2VsZXJhdGlvbkxpbWl0OiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgc29mdExhdGVyYWxBY2NlbGVyYXRpb25QZW5hbHR5OiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgbGluZWFyTGF0ZXJhbEFjY2VsZXJhdGlvblBlbmFsdHk6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICBkQ3VydmF0dXJlTWF4OiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgcGF0aFNhbXBsaW5nU3RlcDogeyB0eXBlOiAnZmxvYXQnIH0sXG4gIHJlYXJBeGxlVG9DZW50ZXI6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICBkeW5hbWljRnJhbWVUaW1lOiB7IHR5cGU6ICdmbG9hdCcgfVxufTtcblxuZnVuY3Rpb24gYnVpbGRVbmlmb3JtVmFsdWVzKGNvbmZpZywgeHlDZW50ZXJQb2ludCwgc2xDZW50ZXJQb2ludCwgZHluYW1pY0ZyYW1lVGltZSkge1xuICByZXR1cm4ge1xuICAgIGFjY2VsZXJhdGlvblByb2ZpbGVzOiBbMy41LCAtNi41LCAyLjAsIC0zLjAsIDBdLFxuICAgIGZpbmFsVmVsb2NpdHlQcm9maWxlczogWzAuOTk5ICogY29uZmlnLnNwZWVkTGltaXQsIDEuMCwgMC4wMV0sXG4gICAgeHlDZW50ZXJQb2ludDogW3h5Q2VudGVyUG9pbnQueCwgeHlDZW50ZXJQb2ludC55XSxcbiAgICB4eUdyaWRDZWxsU2l6ZTogY29uZmlnLnh5R3JpZENlbGxTaXplLFxuICAgIHNsQ2VudGVyUG9pbnQ6IFtzbENlbnRlclBvaW50LngsIHNsQ2VudGVyUG9pbnQueV0sXG4gICAgc2xHcmlkQ2VsbFNpemU6IGNvbmZpZy5zbEdyaWRDZWxsU2l6ZSxcbiAgICBsYW5lQ2VudGVyTGF0aXR1ZGU6IGNvbmZpZy5sYW5lQ2VudGVyTGF0aXR1ZGUsXG4gICAgbGFuZVNob3VsZGVyTGF0aXR1ZGU6IGNvbmZpZy5sYW5lU2hvdWxkZXJMYXRpdHVkZSxcbiAgICBsYW5lQ29zdFNsb3BlOiBjb25maWcubGFuZUNvc3RTbG9wZSxcbiAgICBsYW5lUHJlZmVyZW5jZTogY29uZmlnLmxhbmVQcmVmZXJlbmNlLFxuICAgIGxhbmVQcmVmZXJlbmNlRGlzY291bnQ6IGNvbmZpZy5sYW5lUHJlZmVyZW5jZURpc2NvdW50LFxuICAgIG9ic3RhY2xlSGF6YXJkQ29zdDogY29uZmlnLm9ic3RhY2xlSGF6YXJkQ29zdCxcbiAgICBzcGVlZExpbWl0OiBjb25maWcuc3BlZWRMaW1pdCxcbiAgICBzcGVlZExpbWl0UGVuYWx0eTogY29uZmlnLnNwZWVkTGltaXRQZW5hbHR5LFxuICAgIGhhcmRBY2NlbGVyYXRpb25QZW5hbHR5OiBjb25maWcuaGFyZEFjY2VsZXJhdGlvblBlbmFsdHksXG4gICAgaGFyZERlY2VsZXJhdGlvblBlbmFsdHk6IGNvbmZpZy5oYXJkRGVjZWxlcmF0aW9uUGVuYWx0eSxcbiAgICBzb2Z0TGF0ZXJhbEFjY2VsZXJhdGlvbkxpbWl0OiBjb25maWcuc29mdExhdGVyYWxBY2NlbGVyYXRpb25MaW1pdCxcbiAgICBzb2Z0TGF0ZXJhbEFjY2VsZXJhdGlvblBlbmFsdHk6IGNvbmZpZy5zb2Z0TGF0ZXJhbEFjY2VsZXJhdGlvblBlbmFsdHksXG4gICAgbGluZWFyTGF0ZXJhbEFjY2VsZXJhdGlvblBlbmFsdHk6IGNvbmZpZy5saW5lYXJMYXRlcmFsQWNjZWxlcmF0aW9uUGVuYWx0eSxcbiAgICBkQ3VydmF0dXJlTWF4OiBjb25maWcuZEN1cnZhdHVyZU1heCxcbiAgICBwYXRoU2FtcGxpbmdTdGVwOiBjb25maWcucGF0aFNhbXBsaW5nU3RlcCxcbiAgICByZWFyQXhsZVRvQ2VudGVyOiBjb25maWcucmVhckF4bGVUb0NlbnRlcixcbiAgICBkeW5hbWljRnJhbWVUaW1lOiBkeW5hbWljRnJhbWVUaW1lXG4gIH07XG59XG5cbmV4cG9ydCB7XG4gIFNIQVJFRF9TSEFERVIsXG4gIFNBTVBMRV9DVUJJQ19QQVRIX0ZOLFxuICBTQU1QTEVfUVVJTlRJQ19QQVRIX0ZOLFxuXG4gIE5VTV9BQ0NFTEVSQVRJT05fUFJPRklMRVMsXG4gIE5VTV9WRUxPQ0lUWV9SQU5HRVMsXG4gIE5VTV9USU1FX1JBTkdFUyxcblxuICBTSEFSRURfVU5JRk9STVMsXG4gIGJ1aWxkVW5pZm9ybVZhbHVlc1xufVxuIiwiaW1wb3J0IHsgU0hBUkVEX1NIQURFUiwgU0FNUExFX0NVQklDX1BBVEhfRk4sIFNBTVBMRV9RVUlOVElDX1BBVEhfRk4sIE5VTV9BQ0NFTEVSQVRJT05fUFJPRklMRVMsIFNIQVJFRF9VTklGT1JNUywgYnVpbGRVbmlmb3JtVmFsdWVzIH0gZnJvbSBcIi4vZ3JhcGhTZWFyY2hTaGFyZWQuanNcIjtcblxuZnVuY3Rpb24gZnJvbVZlaGljbGVQYXRoQ29zdHNLZXJuZWwocGF0aFR5cGUpIHtcbiAgcmV0dXJuIFNIQVJFRF9TSEFERVIgKyAocGF0aFR5cGUgPT0gJ2N1YmljJyA/IFNBTVBMRV9DVUJJQ19QQVRIX0ZOIDogU0FNUExFX1FVSU5USUNfUEFUSF9GTikgK1xuXG5gXG5cbi8qIENhbGN1bGF0ZSBjb3N0IG9mIGEge2N1YmljfHF1aW50aWN9IHBhdGggZnJvbSB2ZWhpY2xlIHRvIChzdGF0aW9uQ29ubmVjdGl2aXR5ICogbnVtTGF0aXR1ZGVzICogbnVtQWNjZWxlcmF0aW9ucykgbm9kZXNcbiAqICAgd2lkdGg6IG51bUxhdGl0dWRlc1xuICogICBoZWlnaHQ6IHN0YXRpb24gKiBudW1BY2NlbGVyYXRpb25zXG4gKi9cbnZlYzQga2VybmVsKCkge1xuICBpdmVjMiBpbmRleGVzID0gaXZlYzIoa2VybmVsUG9zaXRpb24gKiB2ZWMyKGtlcm5lbFNpemUpKTtcblxuICBpbnQgbGF0aXR1ZGUgPSBpbmRleGVzLng7XG4gIGludCBzdGF0aW9uID0gaW5kZXhlcy55IC8gbnVtQWNjZWxlcmF0aW9ucztcbiAgaW50IGFjY2VsZXJhdGlvbkluZGV4ID0gaW50KG1vZChmbG9hdChpbmRleGVzLnkpLCBmbG9hdChudW1BY2NlbGVyYXRpb25zKSkpO1xuXG4gIHZlYzQgcGF0aFN0YXJ0ID0gdmVjNCgwLCAwLCAwLCBjdXJ2VmVoaWNsZSk7XG4gIHZlYzQgcGF0aEVuZCA9IHRleGVsRmV0Y2gobGF0dGljZSwgaXZlYzIobGF0aXR1ZGUsIHN0YXRpb24pLCAwKTtcblxuICB2ZWM0IHBhdGhQYXJhbXMgPSB0ZXhlbEZldGNoKHBhdGhzRnJvbVZlaGljbGUsIGl2ZWMyKGxhdGl0dWRlLCBzdGF0aW9uKSwgMCk7XG5cbiAgLy8gSWYgdGhlIHBhdGggZGlkbid0IGNvbnZlcmdlXG4gIGlmIChwYXRoUGFyYW1zLncgPT0gMC4wKSByZXR1cm4gdmVjNCgtMSk7XG5cbiAgaW50IG51bVNhbXBsZXMgPSAke3BhdGhUeXBlID09ICdjdWJpYycgPyAnc2FtcGxlQ3ViaWNQYXRoJyA6ICdzYW1wbGVRdWludGljUGF0aCd9KHBhdGhTdGFydCwgcGF0aEVuZCwgcGF0aFBhcmFtcyk7XG4gIGZsb2F0IHBhdGhMZW5ndGggPSBwYXRoUGFyYW1zLno7XG5cbiAgaWYgKG51bVNhbXBsZXMgPCAyKSByZXR1cm4gdmVjNCgtMSk7XG5cbiAgZmxvYXQgYXZlcmFnZVN0YXRpY0Nvc3QgPSBjYWxjdWxhdGVBdmVyYWdlU3RhdGljQ29zdChudW1TYW1wbGVzKTtcbiAgaWYgKGF2ZXJhZ2VTdGF0aWNDb3N0IDwgMC4wKSByZXR1cm4gdmVjNCgtMSk7XG5cbiAgaW50IHNsSW5kZXggPSBzdGF0aW9uICoga2VybmVsU2l6ZS54ICsgbGF0aXR1ZGU7XG4gIGZsb2F0IGh5c3RlcmVzaXNBZGp1c3RtZW50ID0gKHNsSW5kZXggPT0gZmlyc3RMYXR0aWNlUG9pbnQgfHwgc2xJbmRleCA9PSBzZWNvbmRMYXR0aWNlUG9pbnQpID8gIDAuMCA6IGh5c3RlcmVzaXNEaXNjb3VudDtcbiAgYXZlcmFnZVN0YXRpY0Nvc3QgKz0gaHlzdGVyZXNpc0FkanVzdG1lbnQ7XG5cbiAgdmVjMyBhdnQgPSBjYWxjdWxhdGVBVlQoYWNjZWxlcmF0aW9uSW5kZXgsIHZlbG9jaXR5VmVoaWNsZSwgMC4wLCBwYXRoTGVuZ3RoKTtcbiAgZmxvYXQgYWNjZWxlcmF0aW9uID0gYXZ0Lng7XG4gIGZsb2F0IGZpbmFsVmVsb2NpdHkgPSBhdnQueTtcbiAgZmxvYXQgZmluYWxUaW1lID0gYXZ0Lno7XG5cbiAgZmxvYXQgYXZlcmFnZUR5bmFtaWNDb3N0ID0gY2FsY3VsYXRlQXZlcmFnZUR5bmFtaWNDb3N0KG51bVNhbXBsZXMsIHBhdGhMZW5ndGgsIDAuMCwgdmVsb2NpdHlWZWhpY2xlLCBhY2NlbGVyYXRpb24sIDEuMCAvIDAuMCk7XG4gIGlmIChhdmVyYWdlRHluYW1pY0Nvc3QgPCAwLjApIHJldHVybiB2ZWM0KC0xKTtcblxuICBhdmVyYWdlRHluYW1pY0Nvc3QgKz0gYWNjZWxlcmF0aW9uQ2hhbmdlUGVuYWx0eTtcblxuICAvLyBUaGUgY29zdCBvZiBhIHRyYWplY3RvcnkgaXMgdGhlIGF2ZXJhZ2Ugc2FtcGxlIGNvc3Qgc2NhbGVkIGJ5IHRoZSBwYXRoIGxlbmd0aFxuICBmbG9hdCB0b3RhbENvc3QgPSAoYXZlcmFnZVN0YXRpY0Nvc3QgKyBhdmVyYWdlRHluYW1pY0Nvc3QgKyAke3BhdGhUeXBlID09ICdjdWJpYycgPyAnKGN1YmljUGF0aFBlbmFsdHkgKiB2ZWxvY2l0eVZlaGljbGUgKiB2ZWxvY2l0eVZlaGljbGUpJyA6ICcwLjAnfSkgKiBwYXRoTGVuZ3RoO1xuICAke3BhdGhUeXBlICE9ICdjdWJpYycgPyAndG90YWxDb3N0ID0gLTEuMDsnIDogJyd9XG5cbiAgcmV0dXJuIHZlYzQodG90YWxDb3N0LCBmaW5hbFZlbG9jaXR5LCBmaW5hbFRpbWUsICR7cGF0aFR5cGUgPT0gJ2N1YmljJyA/ICctMicgOiAnLTEnfSk7XG59XG5cbmA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc2V0VXAoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAga2VybmVsOiBmcm9tVmVoaWNsZVBhdGhDb3N0c0tlcm5lbCgnY3ViaWMnKSxcbiAgICAgICAgb3V0cHV0OiB7IG5hbWU6ICdjdWJpY1BhdGhGcm9tVmVoaWNsZUNvc3RzJyB9LFxuICAgICAgICB1bmlmb3JtczogT2JqZWN0LmFzc2lnbih7fSwgU0hBUkVEX1VOSUZPUk1TLCB7XG4gICAgICAgICAgbGF0dGljZTogeyB0eXBlOiAnc2hhcmVkVGV4dHVyZScgfSxcbiAgICAgICAgICBwYXRoc0Zyb21WZWhpY2xlOiB7IHR5cGU6ICdvdXRwdXRUZXh0dXJlJywgbmFtZTogJ2N1YmljUGF0aHNGcm9tVmVoaWNsZScgfSxcbiAgICAgICAgICBmaXJzdExhdHRpY2VQb2ludDogeyB0eXBlOiAnaW50JyB9LFxuICAgICAgICAgIHNlY29uZExhdHRpY2VQb2ludDogeyB0eXBlOiAnaW50JyB9LFxuICAgICAgICAgIHZlbG9jaXR5VmVoaWNsZTogeyB0eXBlOiAnZmxvYXQnIH0sXG4gICAgICAgICAgY3VydlZlaGljbGU6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICAgICAgICAgIG51bUFjY2VsZXJhdGlvbnM6IHsgdHlwZTogJ2ludCcgfSxcbiAgICAgICAgICBjdWJpY1BhdGhQZW5hbHR5OiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgICAgICAgICBoeXN0ZXJlc2lzRGlzY291bnQ6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICAgICAgICAgIGFjY2VsZXJhdGlvbkNoYW5nZVBlbmFsdHk6IHsgdHlwZTogJ2Zsb2F0JyB9XG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXJuZWw6IGZyb21WZWhpY2xlUGF0aENvc3RzS2VybmVsKCdxdWludGljJyksXG4gICAgICAgIG91dHB1dDogeyBuYW1lOiAncXVpbnRpY1BhdGhGcm9tVmVoaWNsZUNvc3RzJyB9LFxuICAgICAgICB1bmlmb3JtczogT2JqZWN0LmFzc2lnbih7fSwgU0hBUkVEX1VOSUZPUk1TLCB7XG4gICAgICAgICAgbGF0dGljZTogeyB0eXBlOiAnc2hhcmVkVGV4dHVyZScgfSxcbiAgICAgICAgICBwYXRoc0Zyb21WZWhpY2xlOiB7IHR5cGU6ICdvdXRwdXRUZXh0dXJlJywgbmFtZTogJ3F1aW50aWNQYXRoc0Zyb21WZWhpY2xlJyB9LFxuICAgICAgICAgIGZpcnN0TGF0dGljZVBvaW50OiB7IHR5cGU6ICdpbnQnIH0sXG4gICAgICAgICAgc2Vjb25kTGF0dGljZVBvaW50OiB7IHR5cGU6ICdpbnQnIH0sXG4gICAgICAgICAgdmVsb2NpdHlWZWhpY2xlOiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgICAgICAgICBjdXJ2VmVoaWNsZTogeyB0eXBlOiAnZmxvYXQnIH0sXG4gICAgICAgICAgZEN1cnZWZWhpY2xlOiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgICAgICAgICBkZEN1cnZWZWhpY2xlOiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgICAgICAgICBudW1BY2NlbGVyYXRpb25zOiB7IHR5cGU6ICdpbnQnIH0sXG4gICAgICAgICAgaHlzdGVyZXNpc0Rpc2NvdW50OiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgICAgICAgICBhY2NlbGVyYXRpb25DaGFuZ2VQZW5hbHR5OiB7IHR5cGU6ICdmbG9hdCcgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIF07XG4gIH0sXG5cbiAgdXBkYXRlKGNvbmZpZywgcG9zZSwgeHlDZW50ZXJQb2ludCwgc2xDZW50ZXJQb2ludCwgZmlyc3RMYXR0aWNlUG9pbnQsIHNlY29uZExhdHRpY2VQb2ludCwgZHluYW1pY0ZyYW1lVGltZSkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHdpZHRoOiBjb25maWcubGF0dGljZS5udW1MYXRpdHVkZXMsXG4gICAgICAgIGhlaWdodDogY29uZmlnLmxhdHRpY2Uuc3RhdGlvbkNvbm5lY3Rpdml0eSAqIE5VTV9BQ0NFTEVSQVRJT05fUFJPRklMRVMsXG4gICAgICAgIHVuaWZvcm1zOiBPYmplY3QuYXNzaWduKHt9LCBidWlsZFVuaWZvcm1WYWx1ZXMoY29uZmlnLCB4eUNlbnRlclBvaW50LCBzbENlbnRlclBvaW50LCBkeW5hbWljRnJhbWVUaW1lKSwge1xuICAgICAgICAgIGZpcnN0TGF0dGljZVBvaW50OiBmaXJzdExhdHRpY2VQb2ludCxcbiAgICAgICAgICBzZWNvbmRMYXR0aWNlUG9pbnQ6IHNlY29uZExhdHRpY2VQb2ludCxcbiAgICAgICAgICB2ZWxvY2l0eVZlaGljbGU6IHBvc2UudmVsb2NpdHksXG4gICAgICAgICAgY3VydlZlaGljbGU6IHBvc2UuY3VydixcbiAgICAgICAgICBudW1BY2NlbGVyYXRpb25zOiBOVU1fQUNDRUxFUkFUSU9OX1BST0ZJTEVTLFxuICAgICAgICAgIGN1YmljUGF0aFBlbmFsdHk6IGNvbmZpZy5jdWJpY1BhdGhQZW5hbHR5LFxuICAgICAgICAgIGh5c3RlcmVzaXNEaXNjb3VudDogY29uZmlnLmh5c3RlcmVzaXNEaXNjb3VudCxcbiAgICAgICAgICBhY2NlbGVyYXRpb25DaGFuZ2VQZW5hbHR5OiBjb25maWcuYWNjZWxlcmF0aW9uQ2hhbmdlUGVuYWx0eVxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgd2lkdGg6IGNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyxcbiAgICAgICAgaGVpZ2h0OiBjb25maWcubGF0dGljZS5zdGF0aW9uQ29ubmVjdGl2aXR5ICogTlVNX0FDQ0VMRVJBVElPTl9QUk9GSUxFUyxcbiAgICAgICAgdW5pZm9ybXM6IE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkVW5pZm9ybVZhbHVlcyhjb25maWcsIHh5Q2VudGVyUG9pbnQsIHNsQ2VudGVyUG9pbnQsIGR5bmFtaWNGcmFtZVRpbWUpLCB7XG4gICAgICAgICAgZmlyc3RMYXR0aWNlUG9pbnQ6IGZpcnN0TGF0dGljZVBvaW50LFxuICAgICAgICAgIHNlY29uZExhdHRpY2VQb2ludDogc2Vjb25kTGF0dGljZVBvaW50LFxuICAgICAgICAgIHZlbG9jaXR5VmVoaWNsZTogcG9zZS52ZWxvY2l0eSxcbiAgICAgICAgICBjdXJ2VmVoaWNsZTogcG9zZS5jdXJ2LFxuICAgICAgICAgIGRDdXJ2VmVoaWNsZTogcG9zZS5kQ3VydixcbiAgICAgICAgICBkZEN1cnZWZWhpY2xlOiBwb3NlLmRkQ3VydixcbiAgICAgICAgICBudW1BY2NlbGVyYXRpb25zOiBOVU1fQUNDRUxFUkFUSU9OX1BST0ZJTEVTLFxuICAgICAgICAgIGh5c3RlcmVzaXNEaXNjb3VudDogY29uZmlnLmh5c3RlcmVzaXNEaXNjb3VudCxcbiAgICAgICAgICBhY2NlbGVyYXRpb25DaGFuZ2VQZW5hbHR5OiBjb25maWcuYWNjZWxlcmF0aW9uQ2hhbmdlUGVuYWx0eVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIF07XG4gIH1cbn1cbiIsIi8qIFN0YXRlIExhdHRpY2UgQ29zdCBNYXBcbiAqIFxuICogNS1kaW1lbnNpb25hbCBub2RlOiBzdGF0aW9uLCBsYXRpdHVkZSwgYWNjZWxlcmF0aW9uIHByb2ZpbGUsIHZlbG9jaXR5LCB0aW1lXG4gKlxuICogQSBkcmF3IGNhbGwgcGVyIHN0YXRpb24gc1xuICogICAqIElucHV0IHRvIGtlcm5lbDogbGF0aXR1ZGUgbCwgYWNjZWxlcmF0aW9uIHByb2ZpbGUgYSwgdmVsb2NpdHkgcmFuZ2UgdiwgdGltZSByYW5nZSB0XG4gKiAgICogRmluZCBhbGwgU0wgdmVydGljZXMgdGhhdCBjYW4gY29ubmVjdCB0byB0aGlzIG5vZGVcbiAqICAgKiBGb3IgZWFjaCBvZiB0aG9zZSB2ZXJ0aWNlcywgY2hlY2sgaWYgYW55IHRlcm1pbmF0ZSBpbiB0aGlzIHNwZWNpZmljIHZlbG9jaXR5IGFuZCB0aW1lIHJhbmdlXG4gKiAgICAgKiBCYXNlZCBvbiBpbml0aWFsIHZlbG9jaXR5LCBpbml0aWFsIHRpbWUsIGFuZCBhY2NlbGVyYXRpb25cbiAqICAgICAqIEVhY2ggY29ubmVjdGVkIFNMIHZlcnRleCBzaG91bGQgaGF2ZSBhICogdiAqIHQgbm9kZXMgdGhhdCBjb3VsZCBwb3NzaWJseSB0ZXJtaW5hdGUgYXQgdGhpcyBub2RlXG4gKiAgICogRm9yIGFsbCB2YWxpZCBlZGdlcywgZmluZCB0aGUgb25lIHdpdGggdGhlIGxvd2VzdCBjb3N0XG4gKlxuICogSW5wdXQ6XG4gKiAgICogMkQgdGV4dHVyZSBhcnJheSBjb3N0IG1hcFxuICogICAgICogSGVpZ2h0OiBudW0gb2YgbGF0aXR1ZGVzICh+MjApXG4gKiAgICAgKiBXaWR0aDogbnVtIG9mIGFjY2VsZXJhdGlvbiBwcm9maWxlcyAqIG51bSBvZiB0aW1lIHJhbmdlcyAqIG51bSBvZiB2ZWxvY2l0eSByYW5nZXMgKDggKiAyICogNCA9IH42NClcbiAqICAgICAgICogQSBmbGF0dGVuZWQgM0QgYXJyYXk6XG4gKiAgICAgICAgIGQxOiBhY2NlbGVyYXRpb25cbiAqICAgICAgICAgZDI6IHZlbG9jaXR5XG4gKiAgICAgICAgIGQzOiB0aW1lXG4gKiAgICAgKiBMYXllcjogbnVtIG9mIHN0YXRpb25zICh+MTApXG4gKiAgIFxuICogT3V0cHV0OlxuICogICAqIDJEIHRleHR1cmUgc2xpY2Ugb2YgdGhlIG5leHQgc3RhdGlvbiBpbiB0aGUgaW5wdXQgMkQgdGV4dHVyZSBhcnJheSBjb3N0IG1hcFxuICpcbiAqIENvc3QgTWFwIEVsZW1lbnRzOlxuICogICAqIFRyYXZlcnNhbCBjb3N0IHNvIGZhclxuICogICAqIEVuZGluZyB2ZWxvY2l0eVxuICogICAqIEVuZGluZyB0aW1lXG4gKiAgICogSW5kZXggb2YgcGFyZW50IG5vZGVcbiAqXG4gKiBTaW5jZSBvbmUgY3ViaWMgcGF0aCBjYW4gYmUgc2hhcmVkIGJldHdlZW4gbXVsdGlwbGUgdHJhamVjdG9yaWVzLCB0aGV5IG5lZWQgdG8gYmUgcHJlLW9wdGltaXplZC5cbiAqXG4gKiBRdWludGljIFBhdGhzOlxuICogICBTdGF0aW9ucyAwIHRocm91Z2ggKG51bVN0YXRpb25zIC0gMSkgY29ycmVzcG9uZCB0byB0aGUgc3RhdGlvbnMgb24gdGhlIGxhdHRpY2U7IGhvd2V2ZXIsXG4gKiAgIGEgbmV3IHN0YXRpb24gKHN0YXRpb24gLTEpIHdpbGwgYmUgdXNlZCB0byBzaWduaWZpeSB0aGUgc2luZ2xlIHZlaGljbGUgcG9zZSBub2RlLiBFaXRoZXJcbiAqICAgYSBjdWJpYyBwYXRoIG9yIHF1aW50aWMgcGF0aCBjYW4gYmUgdXNlZCB0byBjb25uZWN0IHRoaXMgc2luZ2xlIG5vZGUgdG8gdGhlIGxhdHRpY2VcbiAqICAgKGRlcGVuZGluZyBvbiB2ZWhpY2xlIHZlbG9jaXR5KS4gQXQgc3RhdGlvbiAtMSwgbGF0aXR1ZGUgMCB3aWxsIGNvcnJlc3BvbmQgdG8gYSBjdWJpYyBwYXRoLFxuICogICBhbmQgbGF0aXR1ZGUgMSB3aWxsIGNvcnJlc3BvbmQgdG8gYSBxdWludGljIHBhdGguIEFsbCBvdGhlciBsYXRpdHVkZXMgd2lsbCBiZSBza2lwcGVkLlxuICovXG5cbmltcG9ydCB7IFNIQVJFRF9TSEFERVIsIFNBTVBMRV9DVUJJQ19QQVRIX0ZOLCBTQU1QTEVfUVVJTlRJQ19QQVRIX0ZOLCBOVU1fQUNDRUxFUkFUSU9OX1BST0ZJTEVTLCBOVU1fVkVMT0NJVFlfUkFOR0VTLCBOVU1fVElNRV9SQU5HRVMsIFNIQVJFRF9VTklGT1JNUywgYnVpbGRVbmlmb3JtVmFsdWVzIH0gZnJvbSBcIi4vZ3JhcGhTZWFyY2hTaGFyZWQuanNcIjtcblxuY29uc3QgU09MVkVfU1RBVElPTl9LRVJORUwgPVxuICBTSEFSRURfU0hBREVSICtcbiAgU0FNUExFX0NVQklDX1BBVEhfRk4gK1xuICBTQU1QTEVfUVVJTlRJQ19QQVRIX0ZOICtcblxuYFxuXG52ZWM0IGtlcm5lbCgpIHtcbiAgaXZlYzIgaW5kZXhlcyA9IGl2ZWMyKGtlcm5lbFBvc2l0aW9uICogdmVjMihrZXJuZWxTaXplKSk7XG5cbiAgaW50IGxhdGl0dWRlID0gaW5kZXhlcy55O1xuXG4gIGludCBudW1QZXJUaW1lID0gbnVtQWNjZWxlcmF0aW9ucyAqIG51bVZlbG9jaXRpZXM7XG4gIGludCB0aW1lSW5kZXggPSBpbmRleGVzLnggLyBudW1QZXJUaW1lO1xuICBpbmRleGVzLnggLT0gdGltZUluZGV4ICogbnVtUGVyVGltZTtcbiAgaW50IHZlbG9jaXR5SW5kZXggPSBpbmRleGVzLnggLyBudW1BY2NlbGVyYXRpb25zO1xuICBpbnQgYWNjZWxlcmF0aW9uSW5kZXggPSBpbnQobW9kKGZsb2F0KGluZGV4ZXMueCksIGZsb2F0KG51bUFjY2VsZXJhdGlvbnMpKSk7XG5cbiAgaW50IG1pbkxhdGl0dWRlID0gbWF4KGxhdGl0dWRlIC0gbGF0aXR1ZGVDb25uZWN0aXZpdHkgLyAyLCAwKTtcbiAgaW50IG1heExhdGl0dWRlID0gbWluKGxhdGl0dWRlICsgbGF0aXR1ZGVDb25uZWN0aXZpdHkgLyAyLCBudW1MYXRpdHVkZXMgLSAxKTtcblxuICBpbnQgc2xJbmRleCA9IHN0YXRpb24gKiBudW1MYXRpdHVkZXMgKyBsYXRpdHVkZTtcblxuICB2ZWM0IHBhdGhFbmQgPSB0ZXhlbEZldGNoKGxhdHRpY2UsIGl2ZWMyKGxhdGl0dWRlLCBzdGF0aW9uKSwgMCk7XG5cbiAgZmxvYXQgbWluVmVsb2NpdHkgPSB2ZWxvY2l0eVJhbmdlc1t2ZWxvY2l0eUluZGV4XTtcbiAgZmxvYXQgbWF4VmVsb2NpdHkgPSB2ZWxvY2l0eVJhbmdlc1t2ZWxvY2l0eUluZGV4ICsgMV07XG5cbiAgZmxvYXQgbWluVGltZSA9IHRpbWVSYW5nZXNbdGltZUluZGV4XTtcbiAgZmxvYXQgbWF4VGltZSA9IHRpbWVSYW5nZXNbdGltZUluZGV4ICsgMV07XG5cbiAgdmVjNCBiZXN0VHJhamVjdG9yeSA9IHZlYzQoLTEpOyAvLyAtMSBtZWFucyBpbmZpbml0ZSBjb3N0XG4gIGZsb2F0IGJlc3RUZXJtaW5hbENvc3QgPSAxLjAgLyAwLjA7XG5cbiAgZmxvYXQgaHlzdGVyZXNpc0FkanVzdG1lbnQgPSAoc2xJbmRleCA9PSBmaXJzdExhdHRpY2VQb2ludCB8fCBzbEluZGV4ID09IHNlY29uZExhdHRpY2VQb2ludCkgPyAgMC4wIDogaHlzdGVyZXNpc0Rpc2NvdW50O1xuXG4gIGZvciAoaW50IHByZXZTdGF0aW9uID0gbWF4KHN0YXRpb24gLSBzdGF0aW9uQ29ubmVjdGl2aXR5LCAwKTsgcHJldlN0YXRpb24gPCBzdGF0aW9uOyBwcmV2U3RhdGlvbisrKSB7XG4gICAgaW50IHN0YXRpb25Db25uZWN0aXZpdHlJbmRleCA9IHByZXZTdGF0aW9uIC0gc3RhdGlvbiArIHN0YXRpb25Db25uZWN0aXZpdHk7XG5cbiAgICBmb3IgKGludCBwcmV2TGF0aXR1ZGUgPSBtaW5MYXRpdHVkZTsgcHJldkxhdGl0dWRlIDw9IG1heExhdGl0dWRlOyBwcmV2TGF0aXR1ZGUrKykge1xuICAgICAgaW50IGxhdGl0dWRlQ29ubmVjdGl2aXR5SW5kZXggPSBwcmV2TGF0aXR1ZGUgLSBsYXRpdHVkZSArIGxhdGl0dWRlQ29ubmVjdGl2aXR5IC8gMjtcbiAgICAgIGludCBjb25uZWN0aXZpdHlJbmRleCA9IHN0YXRpb25Db25uZWN0aXZpdHlJbmRleCAqIGxhdGl0dWRlQ29ubmVjdGl2aXR5ICsgbGF0aXR1ZGVDb25uZWN0aXZpdHlJbmRleDtcblxuICAgICAgdmVjNCBwYXRoU3RhcnQgPSB0ZXhlbEZldGNoKGxhdHRpY2UsIGl2ZWMyKHByZXZMYXRpdHVkZSwgcHJldlN0YXRpb24pLCAwKTtcbiAgICAgIHZlYzQgY3ViaWNQYXRoUGFyYW1zID0gdGV4ZWxGZXRjaChjdWJpY1BhdGhzLCBpdmVjMihzbEluZGV4LCBjb25uZWN0aXZpdHlJbmRleCksIDApO1xuXG4gICAgICAvLyBJZiB0aGUgcGF0aCBkaWRuJ3QgY29udmVyZ2VcbiAgICAgIGlmIChjdWJpY1BhdGhQYXJhbXMudyA9PSAwLjApIGNvbnRpbnVlO1xuXG4gICAgICBpbnQgbnVtU2FtcGxlcyA9IHNhbXBsZUN1YmljUGF0aChwYXRoU3RhcnQsIHBhdGhFbmQsIGN1YmljUGF0aFBhcmFtcyk7XG4gICAgICBmbG9hdCBwYXRoTGVuZ3RoID0gY3ViaWNQYXRoUGFyYW1zLno7XG5cbiAgICAgIGlmIChudW1TYW1wbGVzIDwgMikgY29udGludWU7XG5cbiAgICAgIGZsb2F0IGF2ZXJhZ2VTdGF0aWNDb3N0ID0gY2FsY3VsYXRlQXZlcmFnZVN0YXRpY0Nvc3QobnVtU2FtcGxlcyk7XG4gICAgICBpZiAoYXZlcmFnZVN0YXRpY0Nvc3QgPCAwLjApIGNvbnRpbnVlO1xuXG4gICAgICBhdmVyYWdlU3RhdGljQ29zdCArPSBoeXN0ZXJlc2lzQWRqdXN0bWVudDtcblxuICAgICAgaWYgKGF2ZXJhZ2VTdGF0aWNDb3N0ICogcGF0aExlbmd0aCA+PSBiZXN0VGVybWluYWxDb3N0KSBjb250aW51ZTtcblxuICAgICAgZm9yIChpbnQgcHJldlZlbG9jaXR5ID0gMDsgcHJldlZlbG9jaXR5IDwgbnVtVmVsb2NpdGllczsgcHJldlZlbG9jaXR5KyspIHtcbiAgICAgICAgZm9yIChpbnQgcHJldlRpbWUgPSAwOyBwcmV2VGltZSA8IG51bVRpbWVzOyBwcmV2VGltZSsrKSB7XG4gICAgICAgICAgZm9yIChpbnQgcHJldkFjY2VsID0gMDsgcHJldkFjY2VsIDwgbnVtQWNjZWxlcmF0aW9uczsgcHJldkFjY2VsKyspIHtcbiAgICAgICAgICAgIGludCBhdnRJbmRleCA9IHByZXZUaW1lICogbnVtUGVyVGltZSArIHByZXZWZWxvY2l0eSAqIG51bUFjY2VsZXJhdGlvbnMgKyBwcmV2QWNjZWw7XG5cbiAgICAgICAgICAgIC8vIENvc3QgdGFibGUgZW50cnk6XG4gICAgICAgICAgICAvLyAgIHg6IGNvc3Qgc28gZmFyXG4gICAgICAgICAgICAvLyAgIHk6IGVuZCB2ZWxvY2l0eVxuICAgICAgICAgICAgLy8gICB6OiBlbmQgdGltZVxuICAgICAgICAgICAgLy8gICB3OiBwYXJlbnQgaW5kZXhcbiAgICAgICAgICAgIHZlYzQgY29zdFRhYmxlRW50cnkgPSB0ZXhlbEZldGNoKGNvc3RUYWJsZSwgaXZlYzMoYXZ0SW5kZXgsIHByZXZMYXRpdHVkZSwgcHJldlN0YXRpb24pLCAwKTtcblxuICAgICAgICAgICAgLy8gSWYgY29zdCBlbnRyeSBpcyBpbmZpbml0eVxuICAgICAgICAgICAgaWYgKGNvc3RUYWJsZUVudHJ5LnggPCAwLjAgfHwgYXZlcmFnZVN0YXRpY0Nvc3QgKiBwYXRoTGVuZ3RoICsgY29zdFRhYmxlRW50cnkueCA+PSBiZXN0VGVybWluYWxDb3N0KSBjb250aW51ZTtcblxuICAgICAgICAgICAgdmVjMyBhdnQgPSBjYWxjdWxhdGVBVlQoYWNjZWxlcmF0aW9uSW5kZXgsIGNvc3RUYWJsZUVudHJ5LnksIGNvc3RUYWJsZUVudHJ5LnosIHBhdGhMZW5ndGgpO1xuICAgICAgICAgICAgZmxvYXQgYWNjZWxlcmF0aW9uID0gYXZ0Lng7XG4gICAgICAgICAgICBmbG9hdCBmaW5hbFZlbG9jaXR5ID0gYXZ0Lnk7XG4gICAgICAgICAgICBmbG9hdCBmaW5hbFRpbWUgPSBhdnQuejtcblxuICAgICAgICAgICAgaWYgKGF2ZXJhZ2VTdGF0aWNDb3N0ICogcGF0aExlbmd0aCArIGNvc3RUYWJsZUVudHJ5LnggKyBleHRyYVRpbWVQZW5hbHR5ICogZmluYWxUaW1lID49IGJlc3RUZXJtaW5hbENvc3QpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgY2FsY3VsYXRlZCBmaW5hbCB2ZWxvY2l0eSBkb2VzIG5vdCBtYXRjaCB0aGlzIGZyYWdtZW50J3MgdmVsb2NpdHkgcmFuZ2UsIHRoZW4gc2tpcCB0aGlzIHRyYWplY3RvcnlcbiAgICAgICAgICAgIGlmIChmaW5hbFZlbG9jaXR5IDwgbWluVmVsb2NpdHkgfHwgZmluYWxWZWxvY2l0eSA+PSBtYXhWZWxvY2l0eSkgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBjYWxjdWxhdGVkIGZpbmFsIHRpbWUgZG9lcyBub3QgbWF0Y2ggdGhpcyBmcmFnbWVudCdzIHRpbWUgcmFuZ2UsIHRoZW4gc2tpcCB0aGlzIHRyYWplY3RvcnlcbiAgICAgICAgICAgIGlmIChmaW5hbFRpbWUgPCBtaW5UaW1lIHx8IGZpbmFsVGltZSA+PSBtYXhUaW1lKSBjb250aW51ZTtcblxuICAgICAgICAgICAgZmxvYXQgYWJhbmRvblRocmVzaG9sZCA9IChiZXN0VGVybWluYWxDb3N0IC0gZXh0cmFUaW1lUGVuYWx0eSAqIGZpbmFsVGltZSAtIGNvc3RUYWJsZUVudHJ5LngpIC8gcGF0aExlbmd0aCAtIGF2ZXJhZ2VTdGF0aWNDb3N0O1xuICAgICAgICAgICAgZmxvYXQgYXZlcmFnZUR5bmFtaWNDb3N0ID0gY2FsY3VsYXRlQXZlcmFnZUR5bmFtaWNDb3N0KG51bVNhbXBsZXMsIHBhdGhMZW5ndGgsIGNvc3RUYWJsZUVudHJ5LnosIGNvc3RUYWJsZUVudHJ5LnksIGFjY2VsZXJhdGlvbiwgYWJhbmRvblRocmVzaG9sZCk7XG4gICAgICAgICAgICBpZiAoYXZlcmFnZUR5bmFtaWNDb3N0IDwgMC4wKSBjb250aW51ZTtcblxuICAgICAgICAgICAgaWYgKGFjY2VsZXJhdGlvbkluZGV4ICE9IHByZXZBY2NlbClcbiAgICAgICAgICAgICAgYXZlcmFnZUR5bmFtaWNDb3N0ICs9IGFjY2VsZXJhdGlvbkNoYW5nZVBlbmFsdHk7XG5cbiAgICAgICAgICAgIC8vIFRoZSBjb3N0IG9mIGEgdHJhamVjdG9yeSBpcyB0aGUgYXZlcmFnZSBzYW1wbGUgY29zdCBzY2FsZWQgYnkgdGhlIHBhdGggbGVuZ3RoXG4gICAgICAgICAgICBmbG9hdCB0b3RhbENvc3QgPSAoYXZlcmFnZVN0YXRpY0Nvc3QgKyBhdmVyYWdlRHluYW1pY0Nvc3QpICogcGF0aExlbmd0aCArIGNvc3RUYWJsZUVudHJ5Lng7XG5cbiAgICAgICAgICAgIGZsb2F0IHRlcm1pbmFsQ29zdCA9IHRvdGFsQ29zdCArIGV4dHJhVGltZVBlbmFsdHkgKiBmaW5hbFRpbWU7XG4gICAgICAgICAgICBpZiAodGVybWluYWxDb3N0ID49IGJlc3RUZXJtaW5hbENvc3QpIGNvbnRpbnVlO1xuICAgICAgICAgICAgYmVzdFRlcm1pbmFsQ29zdCA9IHRlcm1pbmFsQ29zdDtcblxuICAgICAgICAgICAgaW50IGluY29taW5nSW5kZXggPSBhdnRJbmRleCArIG51bVBlclRpbWUgKiBudW1UaW1lcyAqIChwcmV2TGF0aXR1ZGUgKyBudW1MYXRpdHVkZXMgKiBwcmV2U3RhdGlvbik7XG4gICAgICAgICAgICBiZXN0VHJhamVjdG9yeSA9IHZlYzQodG90YWxDb3N0LCBmaW5hbFZlbG9jaXR5LCBmaW5hbFRpbWUsIGluY29taW5nSW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0aW9uIDwgc3RhdGlvbkNvbm5lY3Rpdml0eSkge1xuICAgIGl2ZWMyIHNsYUluZGV4ID0gaXZlYzIobGF0aXR1ZGUsIHN0YXRpb24gKiBudW1BY2NlbGVyYXRpb25zICsgYWNjZWxlcmF0aW9uSW5kZXgpO1xuXG4gICAgdmVjNCBjb3N0VGFibGVFbnRyeSA9IHRleGVsRmV0Y2goY3ViaWNQYXRoRnJvbVZlaGljbGVDb3N0cywgc2xhSW5kZXgsIDApO1xuICAgIGZsb2F0IHRlcm1pbmFsQ29zdDtcblxuICAgIGlmIChjb3N0VGFibGVFbnRyeS54ID49IDAuMCkge1xuICAgICAgdGVybWluYWxDb3N0ID0gY29zdFRhYmxlRW50cnkueCArIGV4dHJhVGltZVBlbmFsdHkgKiBjb3N0VGFibGVFbnRyeS56O1xuXG4gICAgICBpZiAodGVybWluYWxDb3N0IDwgYmVzdFRlcm1pbmFsQ29zdCkge1xuICAgICAgICBiZXN0VGVybWluYWxDb3N0ID0gdGVybWluYWxDb3N0O1xuICAgICAgICBiZXN0VHJhamVjdG9yeSA9IGNvc3RUYWJsZUVudHJ5O1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvc3RUYWJsZUVudHJ5ID0gdGV4ZWxGZXRjaChxdWludGljUGF0aEZyb21WZWhpY2xlQ29zdHMsIHNsYUluZGV4LCAwKTtcblxuICAgIGlmIChjb3N0VGFibGVFbnRyeS54ID49IDAuMCkge1xuICAgICAgdGVybWluYWxDb3N0ID0gY29zdFRhYmxlRW50cnkueCArIGV4dHJhVGltZVBlbmFsdHkgKiBjb3N0VGFibGVFbnRyeS56O1xuXG4gICAgICBpZiAodGVybWluYWxDb3N0IDwgYmVzdFRlcm1pbmFsQ29zdCkge1xuICAgICAgICBiZXN0VGVybWluYWxDb3N0ID0gdGVybWluYWxDb3N0O1xuICAgICAgICBiZXN0VHJhamVjdG9yeSA9IGNvc3RUYWJsZUVudHJ5O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBiZXN0VHJhamVjdG9yeTtcbn1cblxuYDtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBzZXRVcCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2VybmVsOiBTT0xWRV9TVEFUSU9OX0tFUk5FTCxcbiAgICAgIG91dHB1dDogeyBuYW1lOiAnZ3JhcGhTZWFyY2gnIH0sXG4gICAgICB1bmlmb3JtczogT2JqZWN0LmFzc2lnbih7fSwgU0hBUkVEX1VOSUZPUk1TLCB7XG4gICAgICAgIGxhdHRpY2U6IHsgdHlwZTogJ3NoYXJlZFRleHR1cmUnIH0sXG4gICAgICAgIGNvc3RUYWJsZTogeyB0eXBlOiAnc2hhcmVkVGV4dHVyZScsIHRleHR1cmVUeXBlOiAnMkRBcnJheScgfSxcbiAgICAgICAgY3ViaWNQYXRoczogeyB0eXBlOiAnb3V0cHV0VGV4dHVyZScgfSxcbiAgICAgICAgY3ViaWNQYXRoRnJvbVZlaGljbGVDb3N0czogeyB0eXBlOiAnb3V0cHV0VGV4dHVyZScgfSxcbiAgICAgICAgcXVpbnRpY1BhdGhGcm9tVmVoaWNsZUNvc3RzOiB7IHR5cGU6ICdvdXRwdXRUZXh0dXJlJyB9LFxuICAgICAgICBmaXJzdExhdHRpY2VQb2ludDogeyB0eXBlOiAnaW50JyB9LFxuICAgICAgICBzZWNvbmRMYXR0aWNlUG9pbnQ6IHsgdHlwZTogJ2ludCcgfSxcbiAgICAgICAgdmVsb2NpdHlWZWhpY2xlOiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgICAgICAgY3VydlZlaGljbGU6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICAgICAgICBkQ3VydlZlaGljbGU6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICAgICAgICBkZEN1cnZWZWhpY2xlOiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgICAgICAgZXh0cmFUaW1lUGVuYWx0eTogeyB0eXBlOiAnZmxvYXQnIH0sXG4gICAgICAgIGh5c3RlcmVzaXNEaXNjb3VudDogeyB0eXBlOiAnZmxvYXQnIH0sXG4gICAgICAgIGFjY2VsZXJhdGlvbkNoYW5nZVBlbmFsdHk6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICAgICAgICBudW1TdGF0aW9uczogeyB0eXBlOiAnaW50JyB9LFxuICAgICAgICBudW1MYXRpdHVkZXM6IHsgdHlwZTogJ2ludCcgfSxcbiAgICAgICAgbnVtQWNjZWxlcmF0aW9uczogeyB0eXBlOiAnaW50JyB9LFxuICAgICAgICBudW1WZWxvY2l0aWVzOiB7IHR5cGU6ICdpbnQnIH0sXG4gICAgICAgIG51bVRpbWVzOiB7IHR5cGU6ICdpbnQnIH0sXG4gICAgICAgIHN0YXRpb25Db25uZWN0aXZpdHk6IHsgdHlwZTogJ2ludCcgfSxcbiAgICAgICAgbGF0aXR1ZGVDb25uZWN0aXZpdHk6IHsgdHlwZTogJ2ludCcgfSxcbiAgICAgICAgdmVsb2NpdHlSYW5nZXM6IHsgdHlwZTogJ2Zsb2F0JywgbGVuZ3RoOiBOVU1fVkVMT0NJVFlfUkFOR0VTICsgMSB9LFxuICAgICAgICB0aW1lUmFuZ2VzOiB7IHR5cGU6ICdmbG9hdCcsIGxlbmd0aDogTlVNX1RJTUVfUkFOR0VTICsgMSB9LFxuICAgICAgICBzdGF0aW9uOiB7IHR5cGU6ICdpbnQnIH0gLy8gVXBkYXRlZCBpbiBgZHJhd1Byb3h5YFxuICAgICAgfSksXG4gICAgICBkcmF3UHJveHk6IChncGdwdSwgcHJvZ3JhbSwgZHJhdykgPT4ge1xuICAgICAgICBjb25zdCB3aWR0aCA9IE5VTV9BQ0NFTEVSQVRJT05fUFJPRklMRVMgKiBOVU1fVkVMT0NJVFlfUkFOR0VTICogTlVNX1RJTUVfUkFOR0VTO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBwcm9ncmFtLm1ldGEubGF0dGljZS5udW1MYXRpdHVkZXM7XG4gICAgICAgIGNvbnN0IGNvc3RUYWJsZSA9IG5ldyBGbG9hdDMyQXJyYXkod2lkdGggKiBoZWlnaHQgKiBwcm9ncmFtLm1ldGEubGF0dGljZS5udW1TdGF0aW9ucyAqIDQpO1xuXG4gICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgcHJvZ3JhbS5tZXRhLmxhdHRpY2UubnVtU3RhdGlvbnM7IHMrKykge1xuICAgICAgICAgIGdwZ3B1LnVwZGF0ZVByb2dyYW1Vbmlmb3Jtcyhwcm9ncmFtLCB7IHN0YXRpb246IHMgfSk7XG4gICAgICAgICAgZHJhdygpO1xuXG4gICAgICAgICAgZ3BncHUuZ2wucmVhZFBpeGVscygwLCAwLCB3aWR0aCwgaGVpZ2h0LCBncGdwdS5nbC5SR0JBLCBncGdwdS5nbC5GTE9BVCwgY29zdFRhYmxlLCBzICogd2lkdGggKiBoZWlnaHQgKiA0KTtcblxuICAgICAgICAgIGdwZ3B1LmdsLmJpbmRUZXh0dXJlKGdwZ3B1LmdsLlRFWFRVUkVfMkRfQVJSQVksIGdwZ3B1LnNoYXJlZFRleHR1cmVzLmNvc3RUYWJsZSk7XG4gICAgICAgICAgZ3BncHUuZ2wuY29weVRleFN1YkltYWdlM0QoZ3BncHUuZ2wuVEVYVFVSRV8yRF9BUlJBWSwgMCwgMCwgMCwgcywgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBncGdwdS5fZ3JhcGhTZWFyY2hDb3N0VGFibGUgPSBjb3N0VGFibGU7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcblxuICB1cGRhdGUoY29uZmlnLCBwb3NlLCB4eUNlbnRlclBvaW50LCBzbENlbnRlclBvaW50LCBmaXJzdExhdHRpY2VQb2ludCwgc2Vjb25kTGF0dGljZVBvaW50LCBkeW5hbWljRnJhbWVUaW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBOVU1fQUNDRUxFUkFUSU9OX1BST0ZJTEVTICogTlVNX1ZFTE9DSVRZX1JBTkdFUyAqIE5VTV9USU1FX1JBTkdFUyxcbiAgICAgIGhlaWdodDogY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzLFxuICAgICAgbWV0YToge1xuICAgICAgICBsYXR0aWNlOiBjb25maWcubGF0dGljZVxuICAgICAgfSxcbiAgICAgIHVuaWZvcm1zOiBPYmplY3QuYXNzaWduKHt9LCBidWlsZFVuaWZvcm1WYWx1ZXMoY29uZmlnLCB4eUNlbnRlclBvaW50LCBzbENlbnRlclBvaW50LCBkeW5hbWljRnJhbWVUaW1lKSwge1xuICAgICAgICBmaXJzdExhdHRpY2VQb2ludDogZmlyc3RMYXR0aWNlUG9pbnQsXG4gICAgICAgIHNlY29uZExhdHRpY2VQb2ludDogc2Vjb25kTGF0dGljZVBvaW50LFxuICAgICAgICB2ZWxvY2l0eVZlaGljbGU6IHBvc2UudmVsb2NpdHksXG4gICAgICAgIGN1cnZWZWhpY2xlOiBwb3NlLmN1cnYsXG4gICAgICAgIGRDdXJ2VmVoaWNsZTogcG9zZS5kQ3VydixcbiAgICAgICAgZGRDdXJ2VmVoaWNsZTogcG9zZS5kZEN1cnYsXG4gICAgICAgIGV4dHJhVGltZVBlbmFsdHk6IGNvbmZpZy5leHRyYVRpbWVQZW5hbHR5LFxuICAgICAgICBoeXN0ZXJlc2lzRGlzY291bnQ6IGNvbmZpZy5oeXN0ZXJlc2lzRGlzY291bnQsXG4gICAgICAgIGFjY2VsZXJhdGlvbkNoYW5nZVBlbmFsdHk6IGNvbmZpZy5hY2NlbGVyYXRpb25DaGFuZ2VQZW5hbHR5LFxuICAgICAgICBudW1TdGF0aW9uczogY29uZmlnLmxhdHRpY2UubnVtU3RhdGlvbnMsXG4gICAgICAgIG51bUxhdGl0dWRlczogY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzLFxuICAgICAgICBudW1BY2NlbGVyYXRpb25zOiBOVU1fQUNDRUxFUkFUSU9OX1BST0ZJTEVTLFxuICAgICAgICBudW1WZWxvY2l0aWVzOiBOVU1fVkVMT0NJVFlfUkFOR0VTLFxuICAgICAgICBudW1UaW1lczogTlVNX1RJTUVfUkFOR0VTLFxuICAgICAgICBzdGF0aW9uQ29ubmVjdGl2aXR5OiBjb25maWcubGF0dGljZS5zdGF0aW9uQ29ubmVjdGl2aXR5LFxuICAgICAgICBsYXRpdHVkZUNvbm5lY3Rpdml0eTogY29uZmlnLmxhdHRpY2UubGF0aXR1ZGVDb25uZWN0aXZpdHksXG4gICAgICAgIHZlbG9jaXR5UmFuZ2VzOiBbMCwgY29uZmlnLnNwZWVkTGltaXQgLyAzLCBjb25maWcuc3BlZWRMaW1pdCAqIDIgLyAzLCBjb25maWcuc3BlZWRMaW1pdCwgMTAwMDAwMF0sXG4gICAgICAgIHRpbWVSYW5nZXM6IFswLCAxMCwgMTAwMDAwMF1cbiAgICAgIH0pXG4gICAgfTtcbiAgfVxufVxuIiwiY29uc3QgWFlfT0JTVEFDTEVfQ09TVF9LRVJORUwgPSBgXG5cbnZlYzQga2VybmVsKCkge1xuICB2ZWMyIHh5ID0gKGtlcm5lbFBvc2l0aW9uIC0gMC41KSAqIHZlYzIoa2VybmVsU2l6ZSkgKiB2ZWMyKHh5R3JpZENlbGxTaXplKSArIHh5Q2VudGVyUG9pbnQ7XG5cbiAgdmVjMiB4eVRleENvb3JkcyA9ICh4eSAtIHh5Q2VudGVyUG9pbnQpIC8gdmVjMih0ZXh0dXJlU2l6ZSh4eXNsTWFwLCAwKSkgLyB2ZWMyKHh5R3JpZENlbGxTaXplKSArIDAuNTtcbiAgdmVjMiBzbCA9IHRleHR1cmUoeHlzbE1hcCwgeHlUZXhDb29yZHMpLnh5O1xuXG4gIHZlYzIgc2xUZXhDb29yZHMgPSAoc2wgLSBzbENlbnRlclBvaW50KSAvIHZlYzIodGV4dHVyZVNpemUoc2xPYnN0YWNsZUdyaWQsIDApKSAvIHZlYzIoc2xHcmlkQ2VsbFNpemUpICsgMC41O1xuICByZXR1cm4gdGV4dHVyZShzbE9ic3RhY2xlR3JpZCwgc2xUZXhDb29yZHMpO1xufVxuXG5gO1xuXG4vLyBCdWlsZCBYWSBvYnN0YWNsZSBjb3N0cyB1c2luZyBYWVNMIG1hcFxuZXhwb3J0IGRlZmF1bHQge1xuICBzZXRVcCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2VybmVsOiBYWV9PQlNUQUNMRV9DT1NUX0tFUk5FTCxcbiAgICAgIG91dHB1dDogeyBuYW1lOiAneHlPYnN0YWNsZUNvc3RHcmlkJywgcmVhZDogdHJ1ZSB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgeHlzbE1hcDogeyB0eXBlOiAnb3V0cHV0VGV4dHVyZScgfSxcbiAgICAgICAgc2xPYnN0YWNsZUdyaWQ6IHsgdHlwZTogJ291dHB1dFRleHR1cmUnLCBuYW1lOiAnc2xPYnN0YWNsZUdyaWREaWxhdGVkJyB9LFxuICAgICAgICB4eUNlbnRlclBvaW50OiB7IHR5cGU6ICd2ZWMyJyB9LFxuICAgICAgICB4eUdyaWRDZWxsU2l6ZTogeyB0eXBlOiAnZmxvYXQnfSxcbiAgICAgICAgc2xDZW50ZXJQb2ludDogeyB0eXBlOiAndmVjMicgfSxcbiAgICAgICAgc2xHcmlkQ2VsbFNpemU6IHsgdHlwZTogJ2Zsb2F0J31cbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG4gIHVwZGF0ZShjb25maWcsIHh5V2lkdGgsIHh5SGVpZ2h0LCB4eUNlbnRlclBvaW50LCBzbENlbnRlclBvaW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB4eVdpZHRoLFxuICAgICAgaGVpZ2h0OiB4eUhlaWdodCxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIHh5Q2VudGVyUG9pbnQ6IFt4eUNlbnRlclBvaW50LngsIHh5Q2VudGVyUG9pbnQueV0sXG4gICAgICAgIHh5R3JpZENlbGxTaXplOiBjb25maWcueHlHcmlkQ2VsbFNpemUsXG4gICAgICAgIHNsQ2VudGVyUG9pbnQ6IFtzbENlbnRlclBvaW50LngsIHNsQ2VudGVyUG9pbnQueV0sXG4gICAgICAgIHNsR3JpZENlbGxTaXplOiBjb25maWcuc2xHcmlkQ2VsbFNpemVcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG4iLCJpbXBvcnQgR1BHUFUgZnJvbSBcIi4uLy4uL0dQR1BVLmpzXCI7XG5pbXBvcnQgQ2FyIGZyb20gXCIuLi8uLi9waHlzaWNzL0Nhci5qc1wiO1xuaW1wb3J0IEN1YmljUGF0aCBmcm9tIFwiLi9DdWJpY1BhdGguanNcIjtcbmltcG9ydCBRdWludGljUGF0aCBmcm9tIFwiLi9RdWludGljUGF0aC5qc1wiO1xuaW1wb3J0IHh5T2JzdGFjbGVHcmlkIGZyb20gXCIuL2dwZ3B1LXByb2dyYW1zL3h5T2JzdGFjbGVHcmlkLmpzXCI7XG5pbXBvcnQgc2xPYnN0YWNsZUdyaWQgZnJvbSBcIi4vZ3BncHUtcHJvZ3JhbXMvc2xPYnN0YWNsZUdyaWQuanNcIjtcbmltcG9ydCBzbE9ic3RhY2xlR3JpZERpbGF0aW9uIGZyb20gXCIuL2dwZ3B1LXByb2dyYW1zL3NsT2JzdGFjbGVHcmlkRGlsYXRpb24uanNcIjtcbmltcG9ydCBzbER5bmFtaWNPYnN0YWNsZUdyaWQgZnJvbSBcIi4vZ3BncHUtcHJvZ3JhbXMvc2xEeW5hbWljT2JzdGFjbGVHcmlkLmpzXCI7XG5pbXBvcnQgeHlzbE1hcCBmcm9tIFwiLi9ncGdwdS1wcm9ncmFtcy94eXNsTWFwLmpzXCI7XG5pbXBvcnQgb3B0aW1pemVDdWJpY1BhdGhzIGZyb20gXCIuL2dwZ3B1LXByb2dyYW1zL29wdGltaXplQ3ViaWNQYXRocy5qc1wiO1xuaW1wb3J0IG9wdGltaXplUXVpbnRpY1BhdGhzIGZyb20gXCIuL2dwZ3B1LXByb2dyYW1zL29wdGltaXplUXVpbnRpY1BhdGhzLmpzXCI7XG5pbXBvcnQgcGF0aEZyb21WZWhpY2xlQ29zdHMgZnJvbSBcIi4vZ3BncHUtcHJvZ3JhbXMvcGF0aEZyb21WZWhpY2xlQ29zdHMuanNcIjtcbmltcG9ydCBncmFwaFNlYXJjaCBmcm9tIFwiLi9ncGdwdS1wcm9ncmFtcy9ncmFwaFNlYXJjaC5qc1wiO1xuaW1wb3J0IHh5T2JzdGFjbGVDb3N0R3JpZCBmcm9tIFwiLi9ncGdwdS1wcm9ncmFtcy94eU9ic3RhY2xlQ29zdEdyaWQuanNcIjtcblxuY29uc3QgTlVNX0FDQ0VMRVJBVElPTl9QUk9GSUxFUyA9IDg7XG5jb25zdCBOVU1fVkVMT0NJVFlfUkFOR0VTID0gNDtcbmNvbnN0IE5VTV9USU1FX1JBTkdFUyA9IDI7XG5cbi8qIE9ic3RhY2xlIGNvc3QgbWFwOlxuICpcbiAqIDEuIFJhc3Rlcml6ZSB0cmlhbmdsZXMgZnJvbSBwb2x5Z29uYWwgb2JzdGFjbGVzIGludG8gWFktc3BhY2Ugb2NjdXBhbmN5IGdyaWRcbiAqIDIuIENvbnZlcnQgb2NjdXBhbmN5IGdyaWQgdG8gU0wtc3BhY2VcbiAqICAgICogV2lkdGggaXMgc3BhdGlhbCBob3Jpem9uIG9mIHRoZSBzdGF0ZSBsYXR0aWNlXG4gKiAgICAqIEhlaWdodCBpcyBsYW5lIHdpZHRoXG4gKiAgICAqIFJlc29sdXRpb24gc2hvdWxkIGJlIGhpZ2hlciB0aGFuIFhZLWdyaWRcbiAqICAgICogR2V0IFhZIHBvc2l0aW9uIGZyb20gY2VudGVybGluZSB0ZXh0dXJlXG4gKiAgICAqIExvb2t1cCBYWSBpbiBYWSBvY2N1cGFuY3kgZ3JpZCAobmVhcmVzdClcbiAqIDMuIERpbGF0ZSBTTC1zcGFjZSBncmlkIHVzaW5nIHR3byBwYXNzZXMgKGFsb25nIHN0YXRpb24sIHRoZW4gYWxvbmcgbGF0aXR1ZGUpXG4gKiAgICAqIGNvbGxpc2lvbiBhcmVhOiBoYWxmIGNhciBzaXplICsgMC4zbVxuICogICAgKiBoaWdoIGNvc3QgYXJlYTogMSBtZXRlclxuICogNC4gQ29udmVydCBiYWNrIHRvIFhZLXNwYWNlIHVzaW5nIFhZU0wgbWFwXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGF0aFBsYW5uZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnByZXZpb3VzU3RhcnRTdGF0aW9uID0gbnVsbDtcbiAgICB0aGlzLnByZXZpb3VzRmlyc3RMYXR0aWNlUG9pbnQgPSAtMTtcbiAgICB0aGlzLnByZXZpb3VzU2Vjb25kTGF0dGljZVBvaW50ID0gLTE7XG4gICAgdGhpcy5wcmV2aW91c0ZpcnN0QWNjZWxlcmF0aW9uID0gLTE7XG4gICAgdGhpcy5wcmV2aW91c1NlY29uZExhdHRpY2VQb2ludCA9IC0xO1xuXG4gICAgbGV0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3QgcHJvZ3JhbXMgPSBbXG4gICAgICB4eU9ic3RhY2xlR3JpZC5zZXRVcCgpLFxuICAgICAgc2xPYnN0YWNsZUdyaWQuc2V0VXAoKSxcbiAgICAgIC4uLnNsT2JzdGFjbGVHcmlkRGlsYXRpb24uc2V0VXAoKSxcbiAgICAgIHNsRHluYW1pY09ic3RhY2xlR3JpZC5zZXRVcCgpLFxuICAgICAgeHlzbE1hcC5zZXRVcCgpLFxuICAgICAgLi4ub3B0aW1pemVDdWJpY1BhdGhzLnNldFVwKCksXG4gICAgICBvcHRpbWl6ZVF1aW50aWNQYXRocy5zZXRVcCgpLFxuICAgICAgLi4ucGF0aEZyb21WZWhpY2xlQ29zdHMuc2V0VXAoKSxcbiAgICAgIGdyYXBoU2VhcmNoLnNldFVwKCksXG4gICAgXS5tYXAocCA9PiBPYmplY3QuYXNzaWduKHt9LCBwLCB7IHdpZHRoOiAxLCBoZWlnaHQ6IDEgfSkpO1xuXG4gICAgdGhpcy5ncGdwdSA9IG5ldyBHUEdQVShwcm9ncmFtcyk7XG4gIH1cblxuICByZXNldCgpIHtcbiAgICB0aGlzLnByZXZpb3VzU3RhcnRTdGF0aW9uID0gbnVsbDtcbiAgICB0aGlzLnByZXZpb3VzRmlyc3RMYXR0aWNlUG9pbnQgPSAtMTtcbiAgICB0aGlzLnByZXZpb3VzU2Vjb25kTGF0dGljZVBvaW50ID0gLTE7XG4gICAgdGhpcy5wcmV2aW91c0ZpcnN0QWNjZWxlcmF0aW9uID0gLTE7XG4gICAgdGhpcy5wcmV2aW91c1NlY29uZExhdHRpY2VQb2ludCA9IC0xO1xuICB9XG5cbiAgcGxhbih2ZWhpY2xlUG9zZSwgdmVoaWNsZVN0YXRpb24sIGxhbmVQYXRoLCBzdGFydFRpbWUsIHN0YXRpY09ic3RhY2xlcywgZHluYW1pY09ic3RhY2xlcykge1xuICAgIGNvbnN0IGxhdHRpY2VTdGF0aW9uSW50ZXJ2YWwgPSB0aGlzLl9sYXR0aWNlU3RhdGlvbkludGVydmFsKCk7XG5cbiAgICBjb25zdCBjZW50ZXJsaW5lUmF3ID0gbGFuZVBhdGguc2FtcGxlU3RhdGlvbnModmVoaWNsZVN0YXRpb24sIE1hdGguY2VpbCgodGhpcy5jb25maWcuc3BhdGlhbEhvcml6b24gKyBsYXR0aWNlU3RhdGlvbkludGVydmFsKSAvIHRoaXMuY29uZmlnLmNlbnRlcmxpbmVTdGF0aW9uSW50ZXJ2YWwpICsgMSwgdGhpcy5jb25maWcuY2VudGVybGluZVN0YXRpb25JbnRlcnZhbCk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gYWxsIGNlbnRlcmxpbmUgcG9pbnRzIGludG8gdmVoaWNsZSBmcmFtZVxuICAgIGNvbnN0IHZlaGljbGVYZm9ybSA9IHZlaGljbGVUcmFuc2Zvcm0odmVoaWNsZVBvc2UpO1xuICAgIGNvbnN0IGNlbnRlcmxpbmUgPSBjZW50ZXJsaW5lUmF3Lm1hcChjID0+IHsgcmV0dXJuIHsgcG9zOiBjLnBvcy5jbG9uZSgpLmFwcGx5TWF0cml4Myh2ZWhpY2xlWGZvcm0pLCByb3Q6IGMucm90IC0gdmVoaWNsZVBvc2Uucm90LCBjdXJ2OiBjLmN1cnYgfSB9KTtcblxuICAgIGNvbnN0IGNlbnRlcmxpbmVEYXRhID0gbmV3IEZsb2F0MzJBcnJheShjZW50ZXJsaW5lLmxlbmd0aCAqIDMpO1xuICAgIGNvbnN0IG1heFBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjIoMCwgMCk7XG4gICAgY29uc3QgbWluUG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMigwLCAwKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2VudGVybGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc2FtcGxlID0gY2VudGVybGluZVtpXTtcbiAgICAgIGNvbnN0IHBvcyA9IHNhbXBsZS5wb3M7XG4gICAgICBjZW50ZXJsaW5lRGF0YVtpICogMyArIDBdID0gcG9zLng7XG4gICAgICBjZW50ZXJsaW5lRGF0YVtpICogMyArIDFdID0gcG9zLnk7XG4gICAgICBjZW50ZXJsaW5lRGF0YVtpICogMyArIDJdID0gc2FtcGxlLnJvdDtcblxuICAgICAgbWF4UG9pbnQubWF4KHBvcyk7XG4gICAgICBtaW5Qb2ludC5taW4ocG9zKTtcbiAgICB9XG5cbiAgICBjb25zdCBkaWZmID0gbWF4UG9pbnQuY2xvbmUoKS5zdWIobWluUG9pbnQpO1xuICAgIGNvbnN0IHh5Q2VudGVyUG9pbnQgPSBtaW5Qb2ludC5jbG9uZSgpLmFkZChtYXhQb2ludCkuZGl2aWRlU2NhbGFyKDIpO1xuXG4gICAgLy8gU2l6ZXMgb2YgdGhlIHh5IGdyaWRzIChpbiBwaXhlbHMsIG5vdCBtZXRlcnMpXG4gICAgY29uc3QgeHlXaWR0aCA9IE1hdGguY2VpbCgoZGlmZi54ICsgdGhpcy5jb25maWcuZ3JpZE1hcmdpbiAqIDIpIC8gdGhpcy5jb25maWcueHlHcmlkQ2VsbFNpemUpO1xuICAgIGNvbnN0IHh5SGVpZ2h0ID0gTWF0aC5jZWlsKChkaWZmLnkgKyB0aGlzLmNvbmZpZy5ncmlkTWFyZ2luICogMikgLyB0aGlzLmNvbmZpZy54eUdyaWRDZWxsU2l6ZSk7XG5cbiAgICBjb25zdCBzdGF0aW9uV2lkdGggPSB0aGlzLmNvbmZpZy5zcGF0aWFsSG9yaXpvbiArIGxhdHRpY2VTdGF0aW9uSW50ZXJ2YWwgKiAyO1xuICAgIGNvbnN0IHNsQ2VudGVyUG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMih0aGlzLmNvbmZpZy5zcGF0aWFsSG9yaXpvbiAvIDIsIDApO1xuXG4gICAgLy8gU2l6ZXMgb2YgdGhlIHNsIGdyaWRzIChpbiBwaXhlbHMsIG5vdCBtZXRlcnMpXG4gICAgY29uc3Qgc2xXaWR0aCA9IE1hdGguY2VpbChzdGF0aW9uV2lkdGggLyB0aGlzLmNvbmZpZy5zbEdyaWRDZWxsU2l6ZSk7XG4gICAgY29uc3Qgc2xIZWlnaHQgPSBNYXRoLmNlaWwoKHRoaXMuY29uZmlnLnJvYWRXaWR0aCArIHRoaXMuY29uZmlnLmdyaWRNYXJnaW4gKiAyKSAvIHRoaXMuY29uZmlnLnNsR3JpZENlbGxTaXplKTtcblxuICAgIGxldCBzdGFydFN0YXRpb247XG5cbiAgICBpZiAodGhpcy5wcmV2aW91c1N0YXJ0U3RhdGlvbiA9PT0gbnVsbCB8fCB2ZWhpY2xlU3RhdGlvbiArIGxhdHRpY2VTdGF0aW9uSW50ZXJ2YWwgLyAyID4gdGhpcy5wcmV2aW91c1N0YXJ0U3RhdGlvbikge1xuICAgICAgc3RhcnRTdGF0aW9uID0gKHRoaXMucHJldmlvdXNTdGFydFN0YXRpb24gPT09IG51bGwgPyB2ZWhpY2xlU3RhdGlvbiA6IHRoaXMucHJldmlvdXNTdGFydFN0YXRpb24pICsgbGF0dGljZVN0YXRpb25JbnRlcnZhbDtcbiAgICAgIHRoaXMucHJldmlvdXNTdGFydFN0YXRpb24gPSBzdGFydFN0YXRpb247XG4gICAgICB0aGlzLnByZXZpb3VzRmlyc3RMYXR0aWNlUG9pbnQgLT0gdGhpcy5jb25maWcubGF0dGljZS5udW1MYXRpdHVkZXM7XG4gICAgICB0aGlzLnByZXZpb3VzU2Vjb25kTGF0dGljZVBvaW50IC09IHRoaXMuY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFN0YXRpb24gPSB0aGlzLnByZXZpb3VzU3RhcnRTdGF0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IGxhdHRpY2UgPSB0aGlzLl9idWlsZExhdHRpY2UobGFuZVBhdGgsIHN0YXJ0U3RhdGlvbiwgdmVoaWNsZVBvc2Uucm90LCB2ZWhpY2xlWGZvcm0pO1xuXG4gICAgY29uc3QgdGVtcG9yYWxIb3Jpem9uID0gdGhpcy5jb25maWcuc3BhdGlhbEhvcml6b24gLyB0aGlzLmNvbmZpZy5zcGVlZExpbWl0O1xuICAgIGNvbnN0IGR5bmFtaWNGcmFtZVRpbWUgPSB0ZW1wb3JhbEhvcml6b24gLyB0aGlzLmNvbmZpZy5udW1EeW5hbWljRnJhbWVzO1xuXG4gICAgZm9yIChjb25zdCBbaSwgcF0gb2YgW1xuICAgICAgeHlPYnN0YWNsZUdyaWQudXBkYXRlKHRoaXMuY29uZmlnLCB4eVdpZHRoLCB4eUhlaWdodCwgeHlDZW50ZXJQb2ludCwgdmVoaWNsZVhmb3JtLCBzdGF0aWNPYnN0YWNsZXMpLFxuICAgICAgc2xPYnN0YWNsZUdyaWQudXBkYXRlKHRoaXMuY29uZmlnLCBzbFdpZHRoLCBzbEhlaWdodCwgc2xDZW50ZXJQb2ludCwgeHlDZW50ZXJQb2ludCksXG4gICAgICAuLi5zbE9ic3RhY2xlR3JpZERpbGF0aW9uLnVwZGF0ZSh0aGlzLmNvbmZpZywgc2xXaWR0aCwgc2xIZWlnaHQpLFxuICAgICAgc2xEeW5hbWljT2JzdGFjbGVHcmlkLnVwZGF0ZSh0aGlzLmNvbmZpZywgc2xXaWR0aCwgc2xIZWlnaHQsIHNsQ2VudGVyUG9pbnQsIHZlaGljbGVTdGF0aW9uLCBzdGFydFRpbWUsIGR5bmFtaWNGcmFtZVRpbWUsIGR5bmFtaWNPYnN0YWNsZXMpLFxuICAgICAgeHlzbE1hcC51cGRhdGUodGhpcy5jb25maWcsIHh5V2lkdGgsIHh5SGVpZ2h0LCB4eUNlbnRlclBvaW50KSxcbiAgICAgIC4uLm9wdGltaXplQ3ViaWNQYXRocy51cGRhdGUodGhpcy5jb25maWcsIHZlaGljbGVQb3NlKSxcbiAgICAgIG9wdGltaXplUXVpbnRpY1BhdGhzLnVwZGF0ZSh0aGlzLmNvbmZpZywgdmVoaWNsZVBvc2UpLFxuICAgICAgLi4ucGF0aEZyb21WZWhpY2xlQ29zdHMudXBkYXRlKHRoaXMuY29uZmlnLCB2ZWhpY2xlUG9zZSwgeHlDZW50ZXJQb2ludCwgc2xDZW50ZXJQb2ludCwgdGhpcy5wcmV2aW91c0ZpcnN0TGF0dGljZVBvaW50LCB0aGlzLnByZXZpb3VzU2Vjb25kTGF0dGljZVBvaW50LCBkeW5hbWljRnJhbWVUaW1lKSxcbiAgICAgIGdyYXBoU2VhcmNoLnVwZGF0ZSh0aGlzLmNvbmZpZywgdmVoaWNsZVBvc2UsIHh5Q2VudGVyUG9pbnQsIHNsQ2VudGVyUG9pbnQsIHRoaXMucHJldmlvdXNGaXJzdExhdHRpY2VQb2ludCwgdGhpcy5wcmV2aW91c1NlY29uZExhdHRpY2VQb2ludCwgZHluYW1pY0ZyYW1lVGltZSlcbiAgICBdLmVudHJpZXMoKSkge1xuICAgICAgdGhpcy5ncGdwdS51cGRhdGVQcm9ncmFtKGksIHApO1xuICAgIH1cblxuICAgIHRoaXMuZ3BncHUudXBkYXRlU2hhcmVkVGV4dHVyZXMoe1xuICAgICAgY2VudGVybGluZToge1xuICAgICAgICB3aWR0aDogY2VudGVybGluZS5sZW5ndGgsXG4gICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgY2hhbm5lbHM6IDMsXG4gICAgICAgIGZpbHRlcjogJ2xpbmVhcicsXG4gICAgICAgIGRhdGE6IGNlbnRlcmxpbmVEYXRhXG4gICAgICB9LFxuICAgICAgY29zdFRhYmxlOiB7XG4gICAgICAgIHdpZHRoOiBOVU1fQUNDRUxFUkFUSU9OX1BST0ZJTEVTICogTlVNX1ZFTE9DSVRZX1JBTkdFUyAqIE5VTV9USU1FX1JBTkdFUyxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyxcbiAgICAgICAgZGVwdGg6IHRoaXMuY29uZmlnLmxhdHRpY2UubnVtU3RhdGlvbnMsXG4gICAgICAgIGNoYW5uZWxzOiA0LFxuICAgICAgICB0ZXh0dXJlVHlwZTogJzJEQXJyYXknXG4gICAgICB9LFxuICAgICAgbGF0dGljZToge1xuICAgICAgICB3aWR0aDogdGhpcy5jb25maWcubGF0dGljZS5udW1MYXRpdHVkZXMsXG4gICAgICAgIGhlaWdodDogdGhpcy5jb25maWcubGF0dGljZS5udW1TdGF0aW9ucyxcbiAgICAgICAgY2hhbm5lbHM6IDQsXG4gICAgICAgIGRhdGE6IGxhdHRpY2VcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuZ3BncHUuX2dyYXBoU2VhcmNoQ29zdFRhYmxlID0gbnVsbDtcbiAgICB0aGlzLmdwZ3B1Ll9keW5hbWljT2JzdGFjbGVHcmlkID0gbnVsbDtcblxuICAgIGxldCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IG91dHB1dHMgPSB0aGlzLmdwZ3B1LnJ1bigpO1xuICAgIGNvbnN0IGNvc3RUYWJsZSA9IHRoaXMuZ3BncHUuX2dyYXBoU2VhcmNoQ29zdFRhYmxlO1xuICAgIGNvbnN0IGN1YmljUGF0aFBhcmFtcyA9IG91dHB1dHNbNl07XG4gICAgY29uc3QgY3ViaWNQYXRoRnJvbVZlaGljbGVQYXJhbXMgPSBvdXRwdXRzWzddO1xuICAgIGNvbnN0IHF1aW50aWNQYXRoRnJvbVZlaGljbGVQYXJhbXMgPSBvdXRwdXRzWzhdO1xuXG4gICAgbGV0IGJlc3RFbnRyeSA9IFtOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldO1xuICAgIGxldCBiZXN0RW50cnlJbmRleDtcbiAgICBjb25zdCBudW1FbnRyaWVzID0gY29zdFRhYmxlLmxlbmd0aCAvIDQ7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUVudHJpZXM7IGkrKykge1xuICAgICAgY29uc3QgZW50cnlVbnBhY2tlZCA9IHRoaXMuX3VucGFja0Nvc3RUYWJsZUluZGV4KGkpO1xuICAgICAgY29uc3QgZW50cnkgPSBbXG4gICAgICAgIGNvc3RUYWJsZVtpICogNF0sXG4gICAgICAgIGNvc3RUYWJsZVtpICogNCArIDFdLFxuICAgICAgICBjb3N0VGFibGVbaSAqIDQgKyAyXSxcbiAgICAgICAgY29zdFRhYmxlW2kgKiA0ICsgM11cbiAgICAgIF07XG5cbiAgICAgIGlmIChlbnRyeVswXSA8IDApIGNvbnRpbnVlO1xuXG4gICAgICBlbnRyeVswXSArPSB0aGlzLl90ZXJtaW5hbENvc3QoZW50cnlVbnBhY2tlZCwgZW50cnkpO1xuXG4gICAgICBpZiAoZW50cnlbMF0gPCBiZXN0RW50cnlbMF0pIHtcbiAgICAgICAgYmVzdEVudHJ5SW5kZXggPSBpO1xuICAgICAgICBiZXN0RW50cnkgPSBlbnRyeTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpbnZlcnNlVmVoaWNsZVhmb3JtID0gKG5ldyBUSFJFRS5NYXRyaXgzKCkpLmdldEludmVyc2UodmVoaWNsZVhmb3JtKTtcbiAgICBsZXQgYmVzdFRyYWplY3RvcnkgPSBudWxsO1xuICAgIGxldCBmcm9tVmVoaWNsZVNlZ21lbnQgPSBudWxsO1xuICAgIGxldCBmcm9tVmVoaWNsZVBhcmFtcyA9IG51bGw7XG4gICAgbGV0IGZpcnN0TGF0dGljZVBvaW50ID0gLTE7XG4gICAgbGV0IGZpcnN0QWNjZWxlcmF0aW9uID0gLTE7XG4gICAgbGV0IHNlY29uZExhdHRpY2VQb2ludCA9IC0xO1xuICAgIGxldCBzZWNvbmRBY2NlbGVyYXRpb24gPSAtMTtcblxuICAgIGlmIChpc0Zpbml0ZShiZXN0RW50cnlbMF0pKSB7XG4gICAgICBbYmVzdFRyYWplY3RvcnksIGZyb21WZWhpY2xlU2VnbWVudCwgZnJvbVZlaGljbGVQYXJhbXMsIGZpcnN0TGF0dGljZVBvaW50LCBmaXJzdEFjY2VsZXJhdGlvbiwgc2Vjb25kTGF0dGljZVBvaW50LCBzZWNvbmRBY2NlbGVyYXRpb25dID0gdGhpcy5fcmVjb25zdHJ1Y3RUcmFqZWN0b3J5KFxuICAgICAgICBiZXN0RW50cnlJbmRleCxcbiAgICAgICAgY29zdFRhYmxlLFxuICAgICAgICBjdWJpY1BhdGhQYXJhbXMsXG4gICAgICAgIGN1YmljUGF0aEZyb21WZWhpY2xlUGFyYW1zLFxuICAgICAgICBxdWludGljUGF0aEZyb21WZWhpY2xlUGFyYW1zLFxuICAgICAgICB2ZWhpY2xlUG9zZSxcbiAgICAgICAgbGF0dGljZVxuICAgICAgKTtcblxuICAgICAgZnJvbVZlaGljbGVTZWdtZW50LmZvckVhY2gocCA9PiB7XG4gICAgICAgIHAucG9zID0gcC5wb3MuYXBwbHlNYXRyaXgzKGludmVyc2VWZWhpY2xlWGZvcm0pO1xuICAgICAgICBwLnJvdCArPSB2ZWhpY2xlUG9zZS5yb3Q7XG4gICAgICB9KTtcblxuICAgICAgYmVzdFRyYWplY3RvcnkuZm9yRWFjaChwID0+IHtcbiAgICAgICAgcC5wb3MgPSBwLnBvcy5hcHBseU1hdHJpeDMoaW52ZXJzZVZlaGljbGVYZm9ybSk7XG4gICAgICAgIHAucm90ICs9IHZlaGljbGVQb3NlLnJvdDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMucHJldmlvdXNGaXJzdExhdHRpY2VQb2ludCA9IGZpcnN0TGF0dGljZVBvaW50O1xuICAgIHRoaXMucHJldmlvdXNGaXJzdEFjY2VsZXJhdGlvbiA9IGZpcnN0QWNjZWxlcmF0aW9uO1xuICAgIHRoaXMucHJldmlvdXNTZWNvbmRMYXR0aWNlUG9pbnQgPSBzZWNvbmRMYXR0aWNlUG9pbnQ7XG4gICAgdGhpcy5wcmV2aW91c1NlY29uZEFjY2VsZXJhdGlvbiA9IHNlY29uZEFjY2VsZXJhdGlvbjtcblxuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBiZXN0VHJhamVjdG9yeSxcbiAgICAgIGZyb21WZWhpY2xlU2VnbWVudDogZnJvbVZlaGljbGVTZWdtZW50LFxuICAgICAgZnJvbVZlaGljbGVQYXJhbXM6IGZyb21WZWhpY2xlUGFyYW1zLFxuICAgICAgbGF0dGljZVN0YXJ0U3RhdGlvbjogdGhpcy5wcmV2aW91c1N0YXJ0U3RhdGlvbixcbiAgICAgIGR5bmFtaWNPYnN0YWNsZUdyaWQ6IHsgZGF0YTogdGhpcy5ncGdwdS5fZHluYW1pY09ic3RhY2xlR3JpZCwgd2lkdGg6IHNsV2lkdGgsIGhlaWdodDogc2xIZWlnaHQgfVxuICAgIH07XG4gIH1cblxuICBfYnVpbGRMYXR0aWNlKGxhbmVQYXRoLCBzdGFydFN0YXRpb24sIHZlaGljbGVSb3QsIHZlaGljbGVYZm9ybSkge1xuICAgIGNvbnN0IGNlbnRlcmxpbmUgPSBsYW5lUGF0aC5zYW1wbGVTdGF0aW9ucyhzdGFydFN0YXRpb24sIHRoaXMuY29uZmlnLmxhdHRpY2UubnVtU3RhdGlvbnMsIHRoaXMuX2xhdHRpY2VTdGF0aW9uSW50ZXJ2YWwoKSk7XG4gICAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5mbG9vcih0aGlzLmNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyAvIDIpO1xuICAgIGNvbnN0IGxhdHRpY2UgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuY29uZmlnLmxhdHRpY2UubnVtU3RhdGlvbnMgKiB0aGlzLmNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyAqIDQpO1xuICAgIGxldCBpbmRleCA9IDA7XG5cbiAgICBmb3IgKGxldCBzID0gMDsgcyA8IGNlbnRlcmxpbmUubGVuZ3RoOyBzKyspIHtcbiAgICAgIGNvbnN0IHNhbXBsZSA9IGNlbnRlcmxpbmVbc107XG5cbiAgICAgIGZvciAobGV0IGwgPSAwOyBsIDwgdGhpcy5jb25maWcubGF0dGljZS5udW1MYXRpdHVkZXM7IGwrKykge1xuICAgICAgICBjb25zdCBsYXRpdHVkZSA9IChsIC0gb2Zmc2V0KSAvIG9mZnNldCAqIHRoaXMuY29uZmlnLnJvYWRXaWR0aCAvIDI7XG4gICAgICAgIGNvbnN0IHJvdCA9IHNhbXBsZS5yb3QgLSB2ZWhpY2xlUm90O1xuICAgICAgICBjb25zdCBwb3MgPSBUSFJFRS5WZWN0b3IyLmZyb21BbmdsZShyb3QgKyBNYXRoLlBJIC8gMikubXVsdGlwbHlTY2FsYXIobGF0aXR1ZGUpLmFkZChzYW1wbGUucG9zLmNsb25lKCkuYXBwbHlNYXRyaXgzKHZlaGljbGVYZm9ybSkpO1xuICAgICAgICBjb25zdCBjdXJ2ID0gc2FtcGxlLmN1cnYgPT0gMCA/IDAgOiAxIC8gKDEgLyBzYW1wbGUuY3VydiAtIGxhdGl0dWRlKTtcblxuICAgICAgICBsYXR0aWNlW2luZGV4KytdID0gcG9zLng7XG4gICAgICAgIGxhdHRpY2VbaW5kZXgrK10gPSBwb3MueTtcbiAgICAgICAgbGF0dGljZVtpbmRleCsrXSA9IHJvdDtcbiAgICAgICAgbGF0dGljZVtpbmRleCsrXSA9IGN1cnY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhdHRpY2U7XG4gIH1cblxuICBfbGF0dGljZVN0YXRpb25JbnRlcnZhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuc3BhdGlhbEhvcml6b24gLyB0aGlzLmNvbmZpZy5sYXR0aWNlLm51bVN0YXRpb25zO1xuICB9XG5cbiAgX3Rlcm1pbmFsQ29zdChbc3RhdGlvbkluZGV4LCBsYXRpdHVkZUluZGV4LCB0aW1lSW5kZXgsIHZlbG9jaXR5SW5kZXgsIGFjY2VsZXJhdGlvbkluZGV4XSwgW2Nvc3QsIGZpbmFsVmVsb2NpdHksIGZpbmFsVGltZSwgaW5jb21pbmdJbmRleF0pIHtcbiAgICAvLyBPbmx5IGNvbnNpZGVyIHZlcnRpY2VzIHRoYXQgcmVhY2ggdGhlIGVuZCBvZiB0aGUgc3BhdGlhbCBvciB0ZW1wb3JhbCBob3Jpem9uXG4gICAgaWYgKHN0YXRpb25JbmRleCAhPSB0aGlzLmNvbmZpZy5sYXR0aWNlLm51bVN0YXRpb25zIC0gMSAmJiBmaW5hbFZlbG9jaXR5ID4gMC4wNSlcbiAgICAgIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cbiAgICBjb25zdCBzdGF0aW9uID0gKHRoaXMuY29uZmlnLnNwYXRpYWxIb3Jpem9uIC8gdGhpcy5jb25maWcubGF0dGljZS5udW1TdGF0aW9ucykgKiAoc3RhdGlvbkluZGV4ICsgMSk7XG5cbiAgICByZXR1cm4gc3RhdGlvbiAqIC10aGlzLmNvbmZpZy5zdGF0aW9uUmVhY2hEaXNjb3VudCArIGZpbmFsVGltZSAqIHRoaXMuY29uZmlnLmV4dHJhVGltZVBlbmFsdHk7XG4gIH1cblxuICBfdW5wYWNrQ29zdFRhYmxlSW5kZXgoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwKSByZXR1cm4gWy0xLCBpbmRleCArIDIsIG51bGwsIG51bGwsIG51bGxdO1xuXG4gICAgY29uc3QgbnVtUGVyVGltZSA9IE5VTV9BQ0NFTEVSQVRJT05fUFJPRklMRVMgKiBOVU1fVkVMT0NJVFlfUkFOR0VTO1xuICAgIGNvbnN0IG51bVBlckxhdGl0dWRlID0gbnVtUGVyVGltZSAqIE5VTV9USU1FX1JBTkdFUztcbiAgICBjb25zdCBudW1QZXJTdGF0aW9uID0gdGhpcy5jb25maWcubGF0dGljZS5udW1MYXRpdHVkZXMgKiBudW1QZXJMYXRpdHVkZTtcblxuICAgIGNvbnN0IHN0YXRpb25JbmRleCA9IE1hdGguZmxvb3IoaW5kZXggLyBudW1QZXJTdGF0aW9uKTtcbiAgICBpbmRleCAtPSBzdGF0aW9uSW5kZXggKiBudW1QZXJTdGF0aW9uO1xuXG4gICAgY29uc3QgbGF0aXR1ZGVJbmRleCA9IE1hdGguZmxvb3IoaW5kZXggLyBudW1QZXJMYXRpdHVkZSk7XG4gICAgaW5kZXggLT0gbGF0aXR1ZGVJbmRleCAqIG51bVBlckxhdGl0dWRlO1xuXG4gICAgY29uc3QgdGltZUluZGV4ID0gTWF0aC5mbG9vcihpbmRleCAvIG51bVBlclRpbWUpO1xuICAgIGluZGV4IC09IHRpbWVJbmRleCAqIG51bVBlclRpbWU7XG5cbiAgICBjb25zdCB2ZWxvY2l0eUluZGV4ID0gTWF0aC5mbG9vcihpbmRleCAvIE5VTV9BQ0NFTEVSQVRJT05fUFJPRklMRVMpO1xuICAgIGNvbnN0IGFjY2VsZXJhdGlvbkluZGV4ID0gaW5kZXggJSBOVU1fQUNDRUxFUkFUSU9OX1BST0ZJTEVTO1xuXG4gICAgcmV0dXJuIFtzdGF0aW9uSW5kZXgsIGxhdGl0dWRlSW5kZXgsIHRpbWVJbmRleCwgdmVsb2NpdHlJbmRleCwgYWNjZWxlcmF0aW9uSW5kZXhdO1xuICB9XG5cbiAgX3JlY29uc3RydWN0VHJhamVjdG9yeShpbmRleCwgY29zdFRhYmxlLCBjdWJpY1BhdGhQYXJhbXMsIGN1YmljUGF0aEZyb21WZWhpY2xlUGFyYW1zLCBxdWludGljUGF0aEZyb21WZWhpY2xlUGFyYW1zLCB2ZWhpY2xlUG9zZSwgbGF0dGljZSkge1xuICAgIGxldCB1bnBhY2tlZCA9IHRoaXMuX3VucGFja0Nvc3RUYWJsZUluZGV4KGluZGV4KTtcbiAgICB1bnBhY2tlZC5wdXNoKGNvc3RUYWJsZVtpbmRleCAqIDQgKyAxXSk7XG4gICAgY29uc3Qgbm9kZXMgPSBbdW5wYWNrZWRdO1xuXG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICB3aGlsZSAodW5wYWNrZWRbMF0gPj0gMCAmJiBjb3VudCsrIDwgMTAwKSB7XG4gICAgICBpbmRleCA9IGNvc3RUYWJsZVtpbmRleCAqIDQgKyAzXTtcbiAgICAgIHVucGFja2VkID0gdGhpcy5fdW5wYWNrQ29zdFRhYmxlSW5kZXgoaW5kZXgpO1xuXG4gICAgICBjb25zdCBmaW5hbFZlbG9jaXR5ID0gdW5wYWNrZWRbMF0gPj0gMCA/IGNvc3RUYWJsZVtpbmRleCAqIDQgKyAxXSA6IHZlaGljbGVQb3NlLnZlbG9jaXR5O1xuICAgICAgdW5wYWNrZWQucHVzaChmaW5hbFZlbG9jaXR5KTtcblxuICAgICAgbm9kZXMudW5zaGlmdCh1bnBhY2tlZCk7XG4gICAgfVxuICAgIGlmIChjb3VudCA+PSAxMDApIHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgbG9vcCBlbmNvdW50ZXJlZCB3aGlsZSByZWNvbnN0cnVjdGluZyB0cmFqZWN0b3J5LicpO1xuXG4gICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgbGV0IGZyb21WZWhpY2xlU2VnbWVudCA9IFtdO1xuICAgIGxldCBmcm9tVmVoaWNsZVBhcmFtcyA9IG51bGw7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgY29uc3QgW3ByZXZTdGF0aW9uLCBwcmV2TGF0aXR1ZGUsIF9wdCwgX3B2LCBfcGEsIHByZXZWZWxvY2l0eV0gPSBub2Rlc1tpXTtcbiAgICAgIGNvbnN0IFtzdGF0aW9uLCBsYXRpdHVkZSwgX3QsIF92LCBfYSwgdmVsb2NpdHldID0gbm9kZXNbaSArIDFdO1xuXG4gICAgICBsZXQgbGVuZ3RoO1xuICAgICAgbGV0IHBhdGhCdWlsZGVyO1xuXG4gICAgICBpZiAocHJldlN0YXRpb24gPCAwKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0ge1xuICAgICAgICAgIHBvczogbmV3IFRIUkVFLlZlY3RvcjIoMCwgMCksXG4gICAgICAgICAgcm90OiAwLFxuICAgICAgICAgIGN1cnY6IHZlaGljbGVQb3NlLmN1cnZcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBlbmRJbmRleCA9IChzdGF0aW9uICogdGhpcy5jb25maWcubGF0dGljZS5udW1MYXRpdHVkZXMgKyBsYXRpdHVkZSkgKiA0O1xuICAgICAgICBjb25zdCBlbmQgPSB7XG4gICAgICAgICAgcG9zOiBuZXcgVEhSRUUuVmVjdG9yMihsYXR0aWNlW2VuZEluZGV4XSwgbGF0dGljZVtlbmRJbmRleCArIDFdKSxcbiAgICAgICAgICByb3Q6IGxhdHRpY2VbZW5kSW5kZXggKyAyXSxcbiAgICAgICAgICBjdXJ2OiBsYXR0aWNlW2VuZEluZGV4ICsgM11cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocHJldkxhdGl0dWRlID09IDApIHsgLy8gQ3ViaWMgcGF0aCBmcm9tIHZlaGljbGUgdG8gbGF0dGljZSBub2RlXG4gICAgICAgICAgbGVuZ3RoID0gY3ViaWNQYXRoRnJvbVZlaGljbGVQYXJhbXNbZW5kSW5kZXggKyAyXTtcblxuICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgIHAxOiBjdWJpY1BhdGhGcm9tVmVoaWNsZVBhcmFtc1tlbmRJbmRleF0sXG4gICAgICAgICAgICBwMjogY3ViaWNQYXRoRnJvbVZlaGljbGVQYXJhbXNbZW5kSW5kZXggKyAxXSxcbiAgICAgICAgICAgIHNHOiBsZW5ndGhcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcGF0aEJ1aWxkZXIgPSBuZXcgQ3ViaWNQYXRoKHN0YXJ0LCBlbmQsIHBhcmFtcyk7XG5cbiAgICAgICAgICBmcm9tVmVoaWNsZVBhcmFtcyA9IHsgdHlwZTogJ2N1YmljJywgcGFyYW1zOiBwYXJhbXMgfTtcbiAgICAgICAgfSBlbHNlIHsgLy8gUXVpbnRpYyBwYXRoIGZyb20gdmVoaWNsZSB0byBsYXR0aWNlIG5vZGVcbiAgICAgICAgICBsZW5ndGggPSBxdWludGljUGF0aEZyb21WZWhpY2xlUGFyYW1zW2VuZEluZGV4ICsgMl07XG5cbiAgICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICBwMzogcXVpbnRpY1BhdGhGcm9tVmVoaWNsZVBhcmFtc1tlbmRJbmRleF0sXG4gICAgICAgICAgICBwNDogcXVpbnRpY1BhdGhGcm9tVmVoaWNsZVBhcmFtc1tlbmRJbmRleCArIDFdLFxuICAgICAgICAgICAgc0c6IGxlbmd0aFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBwYXRoQnVpbGRlciA9IG5ldyBRdWludGljUGF0aChzdGFydCwgZW5kLCBwYXJhbXMpO1xuXG4gICAgICAgICAgZnJvbVZlaGljbGVQYXJhbXMgPSB7IHR5cGU6ICdxdWludGljJywgcGFyYW1zOiBwYXJhbXMgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IChwcmV2U3RhdGlvbiAqIHRoaXMuY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzICsgcHJldkxhdGl0dWRlKSAqIDQ7XG4gICAgICAgIGNvbnN0IGVuZEluZGV4ID0gKHN0YXRpb24gKiB0aGlzLmNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyArIGxhdGl0dWRlKSAqIDQ7XG5cbiAgICAgICAgY29uc3Qgc3RhcnQgPSB7XG4gICAgICAgICAgcG9zOiBuZXcgVEhSRUUuVmVjdG9yMihsYXR0aWNlW3N0YXJ0SW5kZXhdLCBsYXR0aWNlW3N0YXJ0SW5kZXggKyAxXSksXG4gICAgICAgICAgcm90OiBsYXR0aWNlW3N0YXJ0SW5kZXggKyAyXSxcbiAgICAgICAgICBjdXJ2OiBsYXR0aWNlW3N0YXJ0SW5kZXggKyAzXVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGVuZCA9IHtcbiAgICAgICAgICBwb3M6IG5ldyBUSFJFRS5WZWN0b3IyKGxhdHRpY2VbZW5kSW5kZXhdLCBsYXR0aWNlW2VuZEluZGV4ICsgMV0pLFxuICAgICAgICAgIHJvdDogbGF0dGljZVtlbmRJbmRleCArIDJdLFxuICAgICAgICAgIGN1cnY6IGxhdHRpY2VbZW5kSW5kZXggKyAzXVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHNsSW5kZXggPSBzdGF0aW9uICogdGhpcy5jb25maWcubGF0dGljZS5udW1MYXRpdHVkZXMgKyBsYXRpdHVkZTtcbiAgICAgICAgY29uc3QgY29ubmVjdGl2aXR5SW5kZXggPSAocHJldlN0YXRpb24gLSBzdGF0aW9uICsgdGhpcy5jb25maWcubGF0dGljZS5zdGF0aW9uQ29ubmVjdGl2aXR5KSAqIHRoaXMuY29uZmlnLmxhdHRpY2UubGF0aXR1ZGVDb25uZWN0aXZpdHkgKyBwcmV2TGF0aXR1ZGUgLSBsYXRpdHVkZSArIE1hdGguZmxvb3IodGhpcy5jb25maWcubGF0dGljZS5sYXRpdHVkZUNvbm5lY3Rpdml0eSAvIDIpO1xuICAgICAgICBjb25zdCBjdWJpY1BhdGhJbmRleCA9IChjb25uZWN0aXZpdHlJbmRleCAqIHRoaXMuY29uZmlnLmxhdHRpY2UubnVtU3RhdGlvbnMgKiB0aGlzLmNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyArIHNsSW5kZXgpICogNDtcblxuICAgICAgICBsZW5ndGggPSBjdWJpY1BhdGhQYXJhbXNbY3ViaWNQYXRoSW5kZXggKyAyXTtcblxuICAgICAgICBwYXRoQnVpbGRlciA9IG5ldyBDdWJpY1BhdGgoc3RhcnQsIGVuZCwge1xuICAgICAgICAgIHAxOiBjdWJpY1BhdGhQYXJhbXNbY3ViaWNQYXRoSW5kZXhdLFxuICAgICAgICAgIHAyOiBjdWJpY1BhdGhQYXJhbXNbY3ViaWNQYXRoSW5kZXggKyAxXSxcbiAgICAgICAgICBzRzogbGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXRoID0gcGF0aEJ1aWxkZXIuYnVpbGRQYXRoKE1hdGguY2VpbChsZW5ndGggLyAwLjI1KSk7XG5cbiAgICAgIGNvbnN0IHByZXZWZWxvY2l0eVNxID0gcHJldlZlbG9jaXR5ICogcHJldlZlbG9jaXR5O1xuICAgICAgY29uc3QgYWNjZWwgPSAodmVsb2NpdHkgKiB2ZWxvY2l0eSAtIHByZXZWZWxvY2l0eVNxKSAvIDIgLyBsZW5ndGg7XG4gICAgICBjb25zdCBkcyA9IGxlbmd0aCAvIChwYXRoLmxlbmd0aCAtIDEpO1xuICAgICAgbGV0IHMgPSAwO1xuXG4gICAgICBmb3IgKGxldCBwID0gMDsgcCA8IHBhdGgubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgcGF0aFtwXS52ZWxvY2l0eSA9IE1hdGguc3FydCgyICogYWNjZWwgKiBzICsgcHJldlZlbG9jaXR5U3EpO1xuICAgICAgICBwYXRoW3BdLmFjY2VsZXJhdGlvbiA9IGFjY2VsO1xuICAgICAgICBzICs9IGRzO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJldlN0YXRpb24gPCAwKSB7XG4gICAgICAgIGZyb21WZWhpY2xlU2VnbWVudCA9IHBhdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaSA+IDApIHBhdGguc2hpZnQoKTtcbiAgICAgICAgcG9pbnRzLnB1c2goLi4ucGF0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGZpcnN0TGF0dGljZVBvaW50ID0gbnVsbFxuICAgIGxldCBmaXJzdEFjY2VsZXJhdGlvbiA9IG51bGw7XG4gICAgbGV0IHNlY29uZExhdHRpY2VQb2ludCA9IG51bGw7XG4gICAgbGV0IHNlY29uZEFjY2VsZXJhdGlvbiA9IG51bGw7XG5cbiAgICBpZiAobm9kZXMubGVuZ3RoID49IDIpIHtcbiAgICAgIGZpcnN0TGF0dGljZVBvaW50ID0gbm9kZXNbMV1bMF0gKiB0aGlzLmNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyArIG5vZGVzWzFdWzFdO1xuICAgICAgZmlyc3RBY2NlbGVyYXRpb24gPSBub2Rlc1sxXVs0XTtcbiAgICB9XG5cbiAgICBpZiAobm9kZXMubGVuZ3RoID49IDMpIHtcbiAgICAgIHNlY29uZExhdHRpY2VQb2ludCA9IG5vZGVzWzJdWzBdICogdGhpcy5jb25maWcubGF0dGljZS5udW1MYXRpdHVkZXMgKyBub2Rlc1syXVsxXTtcbiAgICAgIHNlY29uZEFjY2VsZXJhdGlvbiA9IG5vZGVzWzJdWzRdO1xuICAgIH1cblxuICAgIHJldHVybiBbcG9pbnRzLCBmcm9tVmVoaWNsZVNlZ21lbnQsIGZyb21WZWhpY2xlUGFyYW1zLCBmaXJzdExhdHRpY2VQb2ludCwgZmlyc3RBY2NlbGVyYXRpb24sIHNlY29uZExhdHRpY2VQb2ludCwgc2Vjb25kQWNjZWxlcmF0aW9uXTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2ZWhpY2xlVHJhbnNmb3JtKHsgcG9zLCByb3QgfSkge1xuICBjb25zdCB0cmFuc2xhdGUgPSBuZXcgVEhSRUUuTWF0cml4MygpO1xuICB0cmFuc2xhdGUuc2V0KFxuICAgIDEsIDAsIC1wb3MueCxcbiAgICAwLCAxLCAtcG9zLnksXG4gICAgMCwgMCwgMVxuICApO1xuXG4gIGNvbnN0IGNvc1JvdCA9IE1hdGguY29zKHJvdCk7XG4gIGNvbnN0IHNpblJvdCA9IE1hdGguc2luKHJvdCk7XG5cbiAgY29uc3Qgcm90YXRlID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcbiAgcm90YXRlLnNldChcbiAgICBjb3NSb3QsIHNpblJvdCwgMCxcbiAgICAtc2luUm90LCBjb3NSb3QsIDAsXG4gICAgMCwgMCwgMVxuICApO1xuXG4gIHJldHVybiByb3RhdGUubXVsdGlwbHkodHJhbnNsYXRlKTtcbn1cblxuZnVuY3Rpb24gb2JzdGFjbGVUcmFuc2Zvcm0odmVoaWNsZVhmb3JtLCB4eUNlbnRlclBvaW50LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGNvbnN0IHRyYW5zbGF0ZSA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XG4gIHRyYW5zbGF0ZS5zZXQoXG4gICAgMSwgMCwgLXh5Q2VudGVyUG9pbnQueCxcbiAgICAwLCAxLCAteHlDZW50ZXJQb2ludC55LFxuICAgIDAsIDAsIDFcbiAgKTtcblxuICBjb25zdCBzY2FsZSA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XG4gIHNjYWxlLnNldChcbiAgICAyIC8gd2lkdGgsIDAsIDAsXG4gICAgMCwgMiAvIGhlaWdodCwgMCxcbiAgICAwLCAwLCAxXG4gICk7XG5cbiAgcmV0dXJuIHNjYWxlLm11bHRpcGx5KHRyYW5zbGF0ZSkubXVsdGlwbHkodmVoaWNsZVhmb3JtKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6\n")},function(module,exports){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nmodule.exports = function(src) {\n\tfunction log(error) {\n\t\t(typeof console !== "undefined")\n\t\t&& (console.error || console.log)("[Script Loader]", error);\n\t}\n\n\t// Check for IE =< 8\n\tfunction isIE() {\n\t\treturn typeof attachEvent !== "undefined" && typeof addEventListener === "undefined";\n\t}\n\n\ttry {\n\t\tif (typeof execScript !== "undefined" && isIE()) {\n\t\t\texecScript(src);\n\t\t} else if (typeof eval !== "undefined") {\n\t\t\teval.call(null, src);\n\t\t} else {\n\t\t\tlog("EvalError: No eval function available");\n\t\t}\n\t} catch (error) {\n\t\tlog(error);\n\t}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanM/ZjJiNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBIiwiZmlsZSI6IjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzcmMpIHtcblx0ZnVuY3Rpb24gbG9nKGVycm9yKSB7XG5cdFx0KHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKVxuXHRcdCYmIChjb25zb2xlLmVycm9yIHx8IGNvbnNvbGUubG9nKShcIltTY3JpcHQgTG9hZGVyXVwiLCBlcnJvcik7XG5cdH1cblxuXHQvLyBDaGVjayBmb3IgSUUgPTwgOFxuXHRmdW5jdGlvbiBpc0lFKCkge1xuXHRcdHJldHVybiB0eXBlb2YgYXR0YWNoRXZlbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgPT09IFwidW5kZWZpbmVkXCI7XG5cdH1cblxuXHR0cnkge1xuXHRcdGlmICh0eXBlb2YgZXhlY1NjcmlwdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpc0lFKCkpIHtcblx0XHRcdGV4ZWNTY3JpcHQoc3JjKTtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBldmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRldmFsLmNhbGwobnVsbCwgc3JjKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bG9nKFwiRXZhbEVycm9yOiBObyBldmFsIGZ1bmN0aW9uIGF2YWlsYWJsZVwiKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0bG9nKGVycm9yKTtcblx0fVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7\n')},,function(module,exports){eval('module.exports = "Math.clamp = (number, min, max) => Math.max(min, Math.min(number, max));\\n\\nMath.wrapAngle = (angle) => {\\n  angle = angle % (Math.PI * 2);\\n  if (angle <= -Math.PI) return angle + Math.PI * 2;\\n  else if (angle > Math.PI) return angle - Math.PI * 2;\\n  else return angle;\\n}\\n\\nTHREE.Vector2.fromAngle = (angle) => new THREE.Vector2(Math.cos(angle), Math.sin(angle));\\n\\nTHREE.Curve.prototype.getCurvatureAt = function(u) {\\n  let t2 = this.getUtoTmapping(u);\\n\\n  const delta = 0.0001;\\n  let t1 = t2 - delta;\\n  let t3 = t2 + delta;\\n\\n  if (t1 < 0) {\\n    t1 = 0;\\n    t2 = delta;\\n    t3 = 2 * delta;\\n  }\\n\\n  if (t3 > 1) {\\n    t3 = 1;\\n    t2 = 1 - delta;\\n    t1 = 1 - 2 * delta;\\n  }\\n\\n  const p1 = this.getPoint(t1);\\n  const p2 = this.getPoint(t2);\\n  const p3 = this.getPoint(t3);\\n\\n  return (Math.atan2(p3.y - p2.y, p3.x - p2.x) - Math.atan2(p2.y - p1.y, p2.x - p1.x)) / p2.distanceTo(p1);\\n};\\n"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9VdGlscy5qcz83NTllIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDBGQUEwRixpQ0FBaUMsa0NBQWtDLHNEQUFzRCx5REFBeUQsc0JBQXNCLEdBQUcsNkZBQTZGLHdEQUF3RCxvQ0FBb0MsMkJBQTJCLHdCQUF3Qix3QkFBd0IsbUJBQW1CLGFBQWEsaUJBQWlCLHFCQUFxQixLQUFLLG1CQUFtQixhQUFhLHFCQUFxQix5QkFBeUIsS0FBSyxtQ0FBbUMsaUNBQWlDLGlDQUFpQywrR0FBK0csSUFBSSIsImZpbGUiOiI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBcIk1hdGguY2xhbXAgPSAobnVtYmVyLCBtaW4sIG1heCkgPT4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihudW1iZXIsIG1heCkpO1xcblxcbk1hdGgud3JhcEFuZ2xlID0gKGFuZ2xlKSA9PiB7XFxuICBhbmdsZSA9IGFuZ2xlICUgKE1hdGguUEkgKiAyKTtcXG4gIGlmIChhbmdsZSA8PSAtTWF0aC5QSSkgcmV0dXJuIGFuZ2xlICsgTWF0aC5QSSAqIDI7XFxuICBlbHNlIGlmIChhbmdsZSA+IE1hdGguUEkpIHJldHVybiBhbmdsZSAtIE1hdGguUEkgKiAyO1xcbiAgZWxzZSByZXR1cm4gYW5nbGU7XFxufVxcblxcblRIUkVFLlZlY3RvcjIuZnJvbUFuZ2xlID0gKGFuZ2xlKSA9PiBuZXcgVEhSRUUuVmVjdG9yMihNYXRoLmNvcyhhbmdsZSksIE1hdGguc2luKGFuZ2xlKSk7XFxuXFxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldEN1cnZhdHVyZUF0ID0gZnVuY3Rpb24odSkge1xcbiAgbGV0IHQyID0gdGhpcy5nZXRVdG9UbWFwcGluZyh1KTtcXG5cXG4gIGNvbnN0IGRlbHRhID0gMC4wMDAxO1xcbiAgbGV0IHQxID0gdDIgLSBkZWx0YTtcXG4gIGxldCB0MyA9IHQyICsgZGVsdGE7XFxuXFxuICBpZiAodDEgPCAwKSB7XFxuICAgIHQxID0gMDtcXG4gICAgdDIgPSBkZWx0YTtcXG4gICAgdDMgPSAyICogZGVsdGE7XFxuICB9XFxuXFxuICBpZiAodDMgPiAxKSB7XFxuICAgIHQzID0gMTtcXG4gICAgdDIgPSAxIC0gZGVsdGE7XFxuICAgIHQxID0gMSAtIDIgKiBkZWx0YTtcXG4gIH1cXG5cXG4gIGNvbnN0IHAxID0gdGhpcy5nZXRQb2ludCh0MSk7XFxuICBjb25zdCBwMiA9IHRoaXMuZ2V0UG9pbnQodDIpO1xcbiAgY29uc3QgcDMgPSB0aGlzLmdldFBvaW50KHQzKTtcXG5cXG4gIHJldHVybiAoTWF0aC5hdGFuMihwMy55IC0gcDIueSwgcDMueCAtIHAyLngpIC0gTWF0aC5hdGFuMihwMi55IC0gcDEueSwgcDIueCAtIHAxLngpKSAvIHAyLmRpc3RhbmNlVG8ocDEpO1xcbn07XFxuXCIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9\n')},function(module,exports,__webpack_require__){eval("__webpack_require__(7)(__webpack_require__(9))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9VdGlscy5qcz9mNjk1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjEwLmpzIiwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhL1VzZXJzL21hdHQvY29kZS9zZWxmX2RyaXZpbmdfY2FyL2Rhc2gvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9Vc2Vycy9tYXR0L2NvZGUvc2VsZl9kcml2aW5nX2Nhci9kYXNoL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS9Vc2Vycy9tYXR0L2NvZGUvc2VsZl9kcml2aW5nX2Nhci9kYXNoL2pzL1V0aWxzLmpzXCIpKSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///10\n")},function(module,exports){eval("module.exports = \"(function (global, factory) {\\n\\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\\n\\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\\n\\t(factory((global.THREE = {})));\\n}(this, (function (exports) { 'use strict';\\n\\n\\t// Polyfills\\n\\n\\tif ( Number.EPSILON === undefined ) {\\n\\n\\t\\tNumber.EPSILON = Math.pow( 2, - 52 );\\n\\n\\t}\\n\\n\\tif ( Number.isInteger === undefined ) {\\n\\n\\t\\t// Missing in IE\\n\\t\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\\n\\n\\t\\tNumber.isInteger = function ( value ) {\\n\\n\\t\\t\\treturn typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t//\\n\\n\\tif ( Math.sign === undefined ) {\\n\\n\\t\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\\n\\n\\t\\tMath.sign = function ( x ) {\\n\\n\\t\\t\\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\tif ( 'name' in Function.prototype === false ) {\\n\\n\\t\\t// Missing in IE\\n\\t\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\\n\\n\\t\\tObject.defineProperty( Function.prototype, 'name', {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this.toString().match( /^\\\\s*function\\\\s*([^\\\\(\\\\s]*)/ )[ 1 ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t} );\\n\\n\\t}\\n\\n\\tif ( Object.assign === undefined ) {\\n\\n\\t\\t// Missing in IE\\n\\t\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\\n\\n\\t\\t( function () {\\n\\n\\t\\t\\tObject.assign = function ( target ) {\\n\\n\\t\\t\\t\\tif ( target === undefined || target === null ) {\\n\\n\\t\\t\\t\\t\\tthrow new TypeError( 'Cannot convert undefined or null to object' );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar output = Object( target );\\n\\n\\t\\t\\t\\tfor ( var index = 1; index < arguments.length; index ++ ) {\\n\\n\\t\\t\\t\\t\\tvar source = arguments[ index ];\\n\\n\\t\\t\\t\\t\\tif ( source !== undefined && source !== null ) {\\n\\n\\t\\t\\t\\t\\t\\tfor ( var nextKey in source ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\toutput[ nextKey ] = source[ nextKey ];\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn output;\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )();\\n\\n\\t}\\n\\n\\t/**\\n\\t * https://github.com/mrdoob/eventdispatcher.js/\\n\\t */\\n\\n\\tfunction EventDispatcher() {}\\n\\n\\tObject.assign( EventDispatcher.prototype, {\\n\\n\\t\\taddEventListener: function ( type, listener ) {\\n\\n\\t\\t\\tif ( this._listeners === undefined ) this._listeners = {};\\n\\n\\t\\t\\tvar listeners = this._listeners;\\n\\n\\t\\t\\tif ( listeners[ type ] === undefined ) {\\n\\n\\t\\t\\t\\tlisteners[ type ] = [];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\\n\\n\\t\\t\\t\\tlisteners[ type ].push( listener );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\thasEventListener: function ( type, listener ) {\\n\\n\\t\\t\\tif ( this._listeners === undefined ) return false;\\n\\n\\t\\t\\tvar listeners = this._listeners;\\n\\n\\t\\t\\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\\n\\n\\t\\t},\\n\\n\\t\\tremoveEventListener: function ( type, listener ) {\\n\\n\\t\\t\\tif ( this._listeners === undefined ) return;\\n\\n\\t\\t\\tvar listeners = this._listeners;\\n\\t\\t\\tvar listenerArray = listeners[ type ];\\n\\n\\t\\t\\tif ( listenerArray !== undefined ) {\\n\\n\\t\\t\\t\\tvar index = listenerArray.indexOf( listener );\\n\\n\\t\\t\\t\\tif ( index !== - 1 ) {\\n\\n\\t\\t\\t\\t\\tlistenerArray.splice( index, 1 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tdispatchEvent: function ( event ) {\\n\\n\\t\\t\\tif ( this._listeners === undefined ) return;\\n\\n\\t\\t\\tvar listeners = this._listeners;\\n\\t\\t\\tvar listenerArray = listeners[ event.type ];\\n\\n\\t\\t\\tif ( listenerArray !== undefined ) {\\n\\n\\t\\t\\t\\tevent.target = this;\\n\\n\\t\\t\\t\\tvar array = listenerArray.slice( 0 );\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tarray[ i ].call( this, event );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tvar REVISION = '89';\\n\\tvar MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\\n\\tvar CullFaceNone = 0;\\n\\tvar CullFaceBack = 1;\\n\\tvar CullFaceFront = 2;\\n\\tvar CullFaceFrontBack = 3;\\n\\tvar FrontFaceDirectionCW = 0;\\n\\tvar FrontFaceDirectionCCW = 1;\\n\\tvar BasicShadowMap = 0;\\n\\tvar PCFShadowMap = 1;\\n\\tvar PCFSoftShadowMap = 2;\\n\\tvar FrontSide = 0;\\n\\tvar BackSide = 1;\\n\\tvar DoubleSide = 2;\\n\\tvar FlatShading = 1;\\n\\tvar SmoothShading = 2;\\n\\tvar NoColors = 0;\\n\\tvar FaceColors = 1;\\n\\tvar VertexColors = 2;\\n\\tvar NoBlending = 0;\\n\\tvar NormalBlending = 1;\\n\\tvar AdditiveBlending = 2;\\n\\tvar SubtractiveBlending = 3;\\n\\tvar MultiplyBlending = 4;\\n\\tvar CustomBlending = 5;\\n\\tvar AddEquation = 100;\\n\\tvar SubtractEquation = 101;\\n\\tvar ReverseSubtractEquation = 102;\\n\\tvar MinEquation = 103;\\n\\tvar MaxEquation = 104;\\n\\tvar ZeroFactor = 200;\\n\\tvar OneFactor = 201;\\n\\tvar SrcColorFactor = 202;\\n\\tvar OneMinusSrcColorFactor = 203;\\n\\tvar SrcAlphaFactor = 204;\\n\\tvar OneMinusSrcAlphaFactor = 205;\\n\\tvar DstAlphaFactor = 206;\\n\\tvar OneMinusDstAlphaFactor = 207;\\n\\tvar DstColorFactor = 208;\\n\\tvar OneMinusDstColorFactor = 209;\\n\\tvar SrcAlphaSaturateFactor = 210;\\n\\tvar NeverDepth = 0;\\n\\tvar AlwaysDepth = 1;\\n\\tvar LessDepth = 2;\\n\\tvar LessEqualDepth = 3;\\n\\tvar EqualDepth = 4;\\n\\tvar GreaterEqualDepth = 5;\\n\\tvar GreaterDepth = 6;\\n\\tvar NotEqualDepth = 7;\\n\\tvar MultiplyOperation = 0;\\n\\tvar MixOperation = 1;\\n\\tvar AddOperation = 2;\\n\\tvar NoToneMapping = 0;\\n\\tvar LinearToneMapping = 1;\\n\\tvar ReinhardToneMapping = 2;\\n\\tvar Uncharted2ToneMapping = 3;\\n\\tvar CineonToneMapping = 4;\\n\\tvar UVMapping = 300;\\n\\tvar CubeReflectionMapping = 301;\\n\\tvar CubeRefractionMapping = 302;\\n\\tvar EquirectangularReflectionMapping = 303;\\n\\tvar EquirectangularRefractionMapping = 304;\\n\\tvar SphericalReflectionMapping = 305;\\n\\tvar CubeUVReflectionMapping = 306;\\n\\tvar CubeUVRefractionMapping = 307;\\n\\tvar RepeatWrapping = 1000;\\n\\tvar ClampToEdgeWrapping = 1001;\\n\\tvar MirroredRepeatWrapping = 1002;\\n\\tvar NearestFilter = 1003;\\n\\tvar NearestMipMapNearestFilter = 1004;\\n\\tvar NearestMipMapLinearFilter = 1005;\\n\\tvar LinearFilter = 1006;\\n\\tvar LinearMipMapNearestFilter = 1007;\\n\\tvar LinearMipMapLinearFilter = 1008;\\n\\tvar UnsignedByteType = 1009;\\n\\tvar ByteType = 1010;\\n\\tvar ShortType = 1011;\\n\\tvar UnsignedShortType = 1012;\\n\\tvar IntType = 1013;\\n\\tvar UnsignedIntType = 1014;\\n\\tvar FloatType = 1015;\\n\\tvar HalfFloatType = 1016;\\n\\tvar UnsignedShort4444Type = 1017;\\n\\tvar UnsignedShort5551Type = 1018;\\n\\tvar UnsignedShort565Type = 1019;\\n\\tvar UnsignedInt248Type = 1020;\\n\\tvar AlphaFormat = 1021;\\n\\tvar RGBFormat = 1022;\\n\\tvar RGBAFormat = 1023;\\n\\tvar LuminanceFormat = 1024;\\n\\tvar LuminanceAlphaFormat = 1025;\\n\\tvar RGBEFormat = RGBAFormat;\\n\\tvar DepthFormat = 1026;\\n\\tvar DepthStencilFormat = 1027;\\n\\tvar RGB_S3TC_DXT1_Format = 2001;\\n\\tvar RGBA_S3TC_DXT1_Format = 2002;\\n\\tvar RGBA_S3TC_DXT3_Format = 2003;\\n\\tvar RGBA_S3TC_DXT5_Format = 2004;\\n\\tvar RGB_PVRTC_4BPPV1_Format = 2100;\\n\\tvar RGB_PVRTC_2BPPV1_Format = 2101;\\n\\tvar RGBA_PVRTC_4BPPV1_Format = 2102;\\n\\tvar RGBA_PVRTC_2BPPV1_Format = 2103;\\n\\tvar RGB_ETC1_Format = 2151;\\n\\tvar LoopOnce = 2200;\\n\\tvar LoopRepeat = 2201;\\n\\tvar LoopPingPong = 2202;\\n\\tvar InterpolateDiscrete = 2300;\\n\\tvar InterpolateLinear = 2301;\\n\\tvar InterpolateSmooth = 2302;\\n\\tvar ZeroCurvatureEnding = 2400;\\n\\tvar ZeroSlopeEnding = 2401;\\n\\tvar WrapAroundEnding = 2402;\\n\\tvar TrianglesDrawMode = 0;\\n\\tvar TriangleStripDrawMode = 1;\\n\\tvar TriangleFanDrawMode = 2;\\n\\tvar LinearEncoding = 3000;\\n\\tvar sRGBEncoding = 3001;\\n\\tvar GammaEncoding = 3007;\\n\\tvar RGBEEncoding = 3002;\\n\\tvar LogLuvEncoding = 3003;\\n\\tvar RGBM7Encoding = 3004;\\n\\tvar RGBM16Encoding = 3005;\\n\\tvar RGBDEncoding = 3006;\\n\\tvar BasicDepthPacking = 3200;\\n\\tvar RGBADepthPacking = 3201;\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tvar _Math = {\\n\\n\\t\\tDEG2RAD: Math.PI / 180,\\n\\t\\tRAD2DEG: 180 / Math.PI,\\n\\n\\t\\tgenerateUUID: ( function () {\\n\\n\\t\\t\\t// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\\n\\n\\t\\t\\tvar lut = [];\\n\\n\\t\\t\\tfor ( var i = 0; i < 256; i ++ ) {\\n\\n\\t\\t\\t\\tlut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 ).toUpperCase();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn function () {\\n\\n\\t\\t\\t\\tvar d0 = Math.random() * 0xffffffff | 0;\\n\\t\\t\\t\\tvar d1 = Math.random() * 0xffffffff | 0;\\n\\t\\t\\t\\tvar d2 = Math.random() * 0xffffffff | 0;\\n\\t\\t\\t\\tvar d3 = Math.random() * 0xffffffff | 0;\\n\\t\\t\\t\\treturn lut[ d0 & 0xff ] + lut[ d0 >> 8 & 0xff ] + lut[ d0 >> 16 & 0xff ] + lut[ d0 >> 24 & 0xff ] + '-' +\\n\\t\\t\\t\\t\\tlut[ d1 & 0xff ] + lut[ d1 >> 8 & 0xff ] + '-' + lut[ d1 >> 16 & 0x0f | 0x40 ] + lut[ d1 >> 24 & 0xff ] + '-' +\\n\\t\\t\\t\\t\\tlut[ d2 & 0x3f | 0x80 ] + lut[ d2 >> 8 & 0xff ] + '-' + lut[ d2 >> 16 & 0xff ] + lut[ d2 >> 24 & 0xff ] +\\n\\t\\t\\t\\t\\tlut[ d3 & 0xff ] + lut[ d3 >> 8 & 0xff ] + lut[ d3 >> 16 & 0xff ] + lut[ d3 >> 24 & 0xff ];\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )(),\\n\\n\\t\\tclamp: function ( value, min, max ) {\\n\\n\\t\\t\\treturn Math.max( min, Math.min( max, value ) );\\n\\n\\t\\t},\\n\\n\\t\\t// compute euclidian modulo of m % n\\n\\t\\t// https://en.wikipedia.org/wiki/Modulo_operation\\n\\n\\t\\teuclideanModulo: function ( n, m ) {\\n\\n\\t\\t\\treturn ( ( n % m ) + m ) % m;\\n\\n\\t\\t},\\n\\n\\t\\t// Linear mapping from range <a1, a2> to range <b1, b2>\\n\\n\\t\\tmapLinear: function ( x, a1, a2, b1, b2 ) {\\n\\n\\t\\t\\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\\n\\n\\t\\t},\\n\\n\\t\\t// https://en.wikipedia.org/wiki/Linear_interpolation\\n\\n\\t\\tlerp: function ( x, y, t ) {\\n\\n\\t\\t\\treturn ( 1 - t ) * x + t * y;\\n\\n\\t\\t},\\n\\n\\t\\t// http://en.wikipedia.org/wiki/Smoothstep\\n\\n\\t\\tsmoothstep: function ( x, min, max ) {\\n\\n\\t\\t\\tif ( x <= min ) return 0;\\n\\t\\t\\tif ( x >= max ) return 1;\\n\\n\\t\\t\\tx = ( x - min ) / ( max - min );\\n\\n\\t\\t\\treturn x * x * ( 3 - 2 * x );\\n\\n\\t\\t},\\n\\n\\t\\tsmootherstep: function ( x, min, max ) {\\n\\n\\t\\t\\tif ( x <= min ) return 0;\\n\\t\\t\\tif ( x >= max ) return 1;\\n\\n\\t\\t\\tx = ( x - min ) / ( max - min );\\n\\n\\t\\t\\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\\n\\n\\t\\t},\\n\\n\\t\\t// Random integer from <low, high> interval\\n\\n\\t\\trandInt: function ( low, high ) {\\n\\n\\t\\t\\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\\n\\n\\t\\t},\\n\\n\\t\\t// Random float from <low, high> interval\\n\\n\\t\\trandFloat: function ( low, high ) {\\n\\n\\t\\t\\treturn low + Math.random() * ( high - low );\\n\\n\\t\\t},\\n\\n\\t\\t// Random float from <-range/2, range/2> interval\\n\\n\\t\\trandFloatSpread: function ( range ) {\\n\\n\\t\\t\\treturn range * ( 0.5 - Math.random() );\\n\\n\\t\\t},\\n\\n\\t\\tdegToRad: function ( degrees ) {\\n\\n\\t\\t\\treturn degrees * _Math.DEG2RAD;\\n\\n\\t\\t},\\n\\n\\t\\tradToDeg: function ( radians ) {\\n\\n\\t\\t\\treturn radians * _Math.RAD2DEG;\\n\\n\\t\\t},\\n\\n\\t\\tisPowerOfTwo: function ( value ) {\\n\\n\\t\\t\\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\\n\\n\\t\\t},\\n\\n\\t\\tceilPowerOfTwo: function ( value ) {\\n\\n\\t\\t\\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\\n\\n\\t\\t},\\n\\n\\t\\tfloorPowerOfTwo: function ( value ) {\\n\\n\\t\\t\\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author philogb / http://blog.thejit.org/\\n\\t * @author egraether / http://egraether.com/\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t */\\n\\n\\tfunction Vector2( x, y ) {\\n\\n\\t\\tthis.x = x || 0;\\n\\t\\tthis.y = y || 0;\\n\\n\\t}\\n\\n\\tObject.defineProperties( Vector2.prototype, {\\n\\n\\t\\t\\\"width\\\": {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this.x;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis.x = value;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t\\\"height\\\": {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this.y;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis.y = value;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( Vector2.prototype, {\\n\\n\\t\\tisVector2: true,\\n\\n\\t\\tset: function ( x, y ) {\\n\\n\\t\\t\\tthis.x = x;\\n\\t\\t\\tthis.y = y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetScalar: function ( scalar ) {\\n\\n\\t\\t\\tthis.x = scalar;\\n\\t\\t\\tthis.y = scalar;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetX: function ( x ) {\\n\\n\\t\\t\\tthis.x = x;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetY: function ( y ) {\\n\\n\\t\\t\\tthis.y = y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetComponent: function ( index, value ) {\\n\\n\\t\\t\\tswitch ( index ) {\\n\\n\\t\\t\\t\\tcase 0: this.x = value; break;\\n\\t\\t\\t\\tcase 1: this.y = value; break;\\n\\t\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetComponent: function ( index ) {\\n\\n\\t\\t\\tswitch ( index ) {\\n\\n\\t\\t\\t\\tcase 0: return this.x;\\n\\t\\t\\t\\tcase 1: return this.y;\\n\\t\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.x, this.y );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( v ) {\\n\\n\\t\\t\\tthis.x = v.x;\\n\\t\\t\\tthis.y = v.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tadd: function ( v, w ) {\\n\\n\\t\\t\\tif ( w !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.addVectors( v, w );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x += v.x;\\n\\t\\t\\tthis.y += v.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddScalar: function ( s ) {\\n\\n\\t\\t\\tthis.x += s;\\n\\t\\t\\tthis.y += s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddVectors: function ( a, b ) {\\n\\n\\t\\t\\tthis.x = a.x + b.x;\\n\\t\\t\\tthis.y = a.y + b.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddScaledVector: function ( v, s ) {\\n\\n\\t\\t\\tthis.x += v.x * s;\\n\\t\\t\\tthis.y += v.y * s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsub: function ( v, w ) {\\n\\n\\t\\t\\tif ( w !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.subVectors( v, w );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x -= v.x;\\n\\t\\t\\tthis.y -= v.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsubScalar: function ( s ) {\\n\\n\\t\\t\\tthis.x -= s;\\n\\t\\t\\tthis.y -= s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsubVectors: function ( a, b ) {\\n\\n\\t\\t\\tthis.x = a.x - b.x;\\n\\t\\t\\tthis.y = a.y - b.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiply: function ( v ) {\\n\\n\\t\\t\\tthis.x *= v.x;\\n\\t\\t\\tthis.y *= v.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyScalar: function ( scalar ) {\\n\\n\\t\\t\\tthis.x *= scalar;\\n\\t\\t\\tthis.y *= scalar;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdivide: function ( v ) {\\n\\n\\t\\t\\tthis.x /= v.x;\\n\\t\\t\\tthis.y /= v.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdivideScalar: function ( scalar ) {\\n\\n\\t\\t\\treturn this.multiplyScalar( 1 / scalar );\\n\\n\\t\\t},\\n\\n\\t\\tapplyMatrix3: function ( m ) {\\n\\n\\t\\t\\tvar x = this.x, y = this.y;\\n\\t\\t\\tvar e = m.elements;\\n\\n\\t\\t\\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];\\n\\t\\t\\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmin: function ( v ) {\\n\\n\\t\\t\\tthis.x = Math.min( this.x, v.x );\\n\\t\\t\\tthis.y = Math.min( this.y, v.y );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmax: function ( v ) {\\n\\n\\t\\t\\tthis.x = Math.max( this.x, v.x );\\n\\t\\t\\tthis.y = Math.max( this.y, v.y );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclamp: function ( min, max ) {\\n\\n\\t\\t\\t// assumes min < max, componentwise\\n\\n\\t\\t\\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\\n\\t\\t\\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclampScalar: function () {\\n\\n\\t\\t\\tvar min = new Vector2();\\n\\t\\t\\tvar max = new Vector2();\\n\\n\\t\\t\\treturn function clampScalar( minVal, maxVal ) {\\n\\n\\t\\t\\t\\tmin.set( minVal, minVal );\\n\\t\\t\\t\\tmax.set( maxVal, maxVal );\\n\\n\\t\\t\\t\\treturn this.clamp( min, max );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tclampLength: function ( min, max ) {\\n\\n\\t\\t\\tvar length = this.length();\\n\\n\\t\\t\\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\\n\\n\\t\\t},\\n\\n\\t\\tfloor: function () {\\n\\n\\t\\t\\tthis.x = Math.floor( this.x );\\n\\t\\t\\tthis.y = Math.floor( this.y );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tceil: function () {\\n\\n\\t\\t\\tthis.x = Math.ceil( this.x );\\n\\t\\t\\tthis.y = Math.ceil( this.y );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tround: function () {\\n\\n\\t\\t\\tthis.x = Math.round( this.x );\\n\\t\\t\\tthis.y = Math.round( this.y );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\troundToZero: function () {\\n\\n\\t\\t\\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\\n\\t\\t\\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tnegate: function () {\\n\\n\\t\\t\\tthis.x = - this.x;\\n\\t\\t\\tthis.y = - this.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdot: function ( v ) {\\n\\n\\t\\t\\treturn this.x * v.x + this.y * v.y;\\n\\n\\t\\t},\\n\\n\\t\\tlengthSq: function () {\\n\\n\\t\\t\\treturn this.x * this.x + this.y * this.y;\\n\\n\\t\\t},\\n\\n\\t\\tlength: function () {\\n\\n\\t\\t\\treturn Math.sqrt( this.x * this.x + this.y * this.y );\\n\\n\\t\\t},\\n\\n\\t\\tmanhattanLength: function () {\\n\\n\\t\\t\\treturn Math.abs( this.x ) + Math.abs( this.y );\\n\\n\\t\\t},\\n\\n\\t\\tnormalize: function () {\\n\\n\\t\\t\\treturn this.divideScalar( this.length() || 1 );\\n\\n\\t\\t},\\n\\n\\t\\tangle: function () {\\n\\n\\t\\t\\t// computes the angle in radians with respect to the positive x-axis\\n\\n\\t\\t\\tvar angle = Math.atan2( this.y, this.x );\\n\\n\\t\\t\\tif ( angle < 0 ) angle += 2 * Math.PI;\\n\\n\\t\\t\\treturn angle;\\n\\n\\t\\t},\\n\\n\\t\\tdistanceTo: function ( v ) {\\n\\n\\t\\t\\treturn Math.sqrt( this.distanceToSquared( v ) );\\n\\n\\t\\t},\\n\\n\\t\\tdistanceToSquared: function ( v ) {\\n\\n\\t\\t\\tvar dx = this.x - v.x, dy = this.y - v.y;\\n\\t\\t\\treturn dx * dx + dy * dy;\\n\\n\\t\\t},\\n\\n\\t\\tmanhattanDistanceTo: function ( v ) {\\n\\n\\t\\t\\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\\n\\n\\t\\t},\\n\\n\\t\\tsetLength: function ( length ) {\\n\\n\\t\\t\\treturn this.normalize().multiplyScalar( length );\\n\\n\\t\\t},\\n\\n\\t\\tlerp: function ( v, alpha ) {\\n\\n\\t\\t\\tthis.x += ( v.x - this.x ) * alpha;\\n\\t\\t\\tthis.y += ( v.y - this.y ) * alpha;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tlerpVectors: function ( v1, v2, alpha ) {\\n\\n\\t\\t\\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( v ) {\\n\\n\\t\\t\\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\\n\\n\\t\\t},\\n\\n\\t\\tfromArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tthis.x = array[ offset ];\\n\\t\\t\\tthis.y = array[ offset + 1 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( array === undefined ) array = [];\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tarray[ offset ] = this.x;\\n\\t\\t\\tarray[ offset + 1 ] = this.y;\\n\\n\\t\\t\\treturn array;\\n\\n\\t\\t},\\n\\n\\t\\tfromBufferAttribute: function ( attribute, index, offset ) {\\n\\n\\t\\t\\tif ( offset !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x = attribute.getX( index );\\n\\t\\t\\tthis.y = attribute.getY( index );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\trotateAround: function ( center, angle ) {\\n\\n\\t\\t\\tvar c = Math.cos( angle ), s = Math.sin( angle );\\n\\n\\t\\t\\tvar x = this.x - center.x;\\n\\t\\t\\tvar y = this.y - center.y;\\n\\n\\t\\t\\tthis.x = x * c - y * s + center.x;\\n\\t\\t\\tthis.y = x * s + y * c + center.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author supereggbert / http://www.paulbrunt.co.uk/\\n\\t * @author philogb / http://blog.thejit.org/\\n\\t * @author jordi_ros / http://plattsoft.com\\n\\t * @author D1plo1d / http://github.com/D1plo1d\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author timknip / http://www.floorplanner.com/\\n\\t * @author bhouston / http://clara.io\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction Matrix4() {\\n\\n\\t\\tthis.elements = [\\n\\n\\t\\t\\t1, 0, 0, 0,\\n\\t\\t\\t0, 1, 0, 0,\\n\\t\\t\\t0, 0, 1, 0,\\n\\t\\t\\t0, 0, 0, 1\\n\\n\\t\\t];\\n\\n\\t\\tif ( arguments.length > 0 ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tObject.assign( Matrix4.prototype, {\\n\\n\\t\\tisMatrix4: true,\\n\\n\\t\\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\\n\\t\\t\\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\\n\\t\\t\\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\\n\\t\\t\\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tidentity: function () {\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\t1, 0, 0, 0,\\n\\t\\t\\t\\t0, 1, 0, 0,\\n\\t\\t\\t\\t0, 0, 1, 0,\\n\\t\\t\\t\\t0, 0, 0, 1\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new Matrix4().fromArray( this.elements );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( m ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\t\\t\\tvar me = m.elements;\\n\\n\\t\\t\\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];\\n\\t\\t\\tte[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];\\n\\t\\t\\tte[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];\\n\\t\\t\\tte[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyPosition: function ( m ) {\\n\\n\\t\\t\\tvar te = this.elements, me = m.elements;\\n\\n\\t\\t\\tte[ 12 ] = me[ 12 ];\\n\\t\\t\\tte[ 13 ] = me[ 13 ];\\n\\t\\t\\tte[ 14 ] = me[ 14 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\textractBasis: function ( xAxis, yAxis, zAxis ) {\\n\\n\\t\\t\\txAxis.setFromMatrixColumn( this, 0 );\\n\\t\\t\\tyAxis.setFromMatrixColumn( this, 1 );\\n\\t\\t\\tzAxis.setFromMatrixColumn( this, 2 );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\\n\\n\\t\\t\\tthis.set(\\n\\t\\t\\t\\txAxis.x, yAxis.x, zAxis.x, 0,\\n\\t\\t\\t\\txAxis.y, yAxis.y, zAxis.y, 0,\\n\\t\\t\\t\\txAxis.z, yAxis.z, zAxis.z, 0,\\n\\t\\t\\t\\t0, 0, 0, 1\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\textractRotation: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function extractRotation( m ) {\\n\\n\\t\\t\\t\\tvar te = this.elements;\\n\\t\\t\\t\\tvar me = m.elements;\\n\\n\\t\\t\\t\\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\\n\\t\\t\\t\\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\\n\\t\\t\\t\\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\\n\\n\\t\\t\\t\\tte[ 0 ] = me[ 0 ] * scaleX;\\n\\t\\t\\t\\tte[ 1 ] = me[ 1 ] * scaleX;\\n\\t\\t\\t\\tte[ 2 ] = me[ 2 ] * scaleX;\\n\\n\\t\\t\\t\\tte[ 4 ] = me[ 4 ] * scaleY;\\n\\t\\t\\t\\tte[ 5 ] = me[ 5 ] * scaleY;\\n\\t\\t\\t\\tte[ 6 ] = me[ 6 ] * scaleY;\\n\\n\\t\\t\\t\\tte[ 8 ] = me[ 8 ] * scaleZ;\\n\\t\\t\\t\\tte[ 9 ] = me[ 9 ] * scaleZ;\\n\\t\\t\\t\\tte[ 10 ] = me[ 10 ] * scaleZ;\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tmakeRotationFromEuler: function ( euler ) {\\n\\n\\t\\t\\tif ( ! ( euler && euler.isEuler ) ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tvar x = euler.x, y = euler.y, z = euler.z;\\n\\t\\t\\tvar a = Math.cos( x ), b = Math.sin( x );\\n\\t\\t\\tvar c = Math.cos( y ), d = Math.sin( y );\\n\\t\\t\\tvar e = Math.cos( z ), f = Math.sin( z );\\n\\n\\t\\t\\tif ( euler.order === 'XYZ' ) {\\n\\n\\t\\t\\t\\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\\n\\n\\t\\t\\t\\tte[ 0 ] = c * e;\\n\\t\\t\\t\\tte[ 4 ] = - c * f;\\n\\t\\t\\t\\tte[ 8 ] = d;\\n\\n\\t\\t\\t\\tte[ 1 ] = af + be * d;\\n\\t\\t\\t\\tte[ 5 ] = ae - bf * d;\\n\\t\\t\\t\\tte[ 9 ] = - b * c;\\n\\n\\t\\t\\t\\tte[ 2 ] = bf - ae * d;\\n\\t\\t\\t\\tte[ 6 ] = be + af * d;\\n\\t\\t\\t\\tte[ 10 ] = a * c;\\n\\n\\t\\t\\t} else if ( euler.order === 'YXZ' ) {\\n\\n\\t\\t\\t\\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\\n\\n\\t\\t\\t\\tte[ 0 ] = ce + df * b;\\n\\t\\t\\t\\tte[ 4 ] = de * b - cf;\\n\\t\\t\\t\\tte[ 8 ] = a * d;\\n\\n\\t\\t\\t\\tte[ 1 ] = a * f;\\n\\t\\t\\t\\tte[ 5 ] = a * e;\\n\\t\\t\\t\\tte[ 9 ] = - b;\\n\\n\\t\\t\\t\\tte[ 2 ] = cf * b - de;\\n\\t\\t\\t\\tte[ 6 ] = df + ce * b;\\n\\t\\t\\t\\tte[ 10 ] = a * c;\\n\\n\\t\\t\\t} else if ( euler.order === 'ZXY' ) {\\n\\n\\t\\t\\t\\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\\n\\n\\t\\t\\t\\tte[ 0 ] = ce - df * b;\\n\\t\\t\\t\\tte[ 4 ] = - a * f;\\n\\t\\t\\t\\tte[ 8 ] = de + cf * b;\\n\\n\\t\\t\\t\\tte[ 1 ] = cf + de * b;\\n\\t\\t\\t\\tte[ 5 ] = a * e;\\n\\t\\t\\t\\tte[ 9 ] = df - ce * b;\\n\\n\\t\\t\\t\\tte[ 2 ] = - a * d;\\n\\t\\t\\t\\tte[ 6 ] = b;\\n\\t\\t\\t\\tte[ 10 ] = a * c;\\n\\n\\t\\t\\t} else if ( euler.order === 'ZYX' ) {\\n\\n\\t\\t\\t\\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\\n\\n\\t\\t\\t\\tte[ 0 ] = c * e;\\n\\t\\t\\t\\tte[ 4 ] = be * d - af;\\n\\t\\t\\t\\tte[ 8 ] = ae * d + bf;\\n\\n\\t\\t\\t\\tte[ 1 ] = c * f;\\n\\t\\t\\t\\tte[ 5 ] = bf * d + ae;\\n\\t\\t\\t\\tte[ 9 ] = af * d - be;\\n\\n\\t\\t\\t\\tte[ 2 ] = - d;\\n\\t\\t\\t\\tte[ 6 ] = b * c;\\n\\t\\t\\t\\tte[ 10 ] = a * c;\\n\\n\\t\\t\\t} else if ( euler.order === 'YZX' ) {\\n\\n\\t\\t\\t\\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\\n\\n\\t\\t\\t\\tte[ 0 ] = c * e;\\n\\t\\t\\t\\tte[ 4 ] = bd - ac * f;\\n\\t\\t\\t\\tte[ 8 ] = bc * f + ad;\\n\\n\\t\\t\\t\\tte[ 1 ] = f;\\n\\t\\t\\t\\tte[ 5 ] = a * e;\\n\\t\\t\\t\\tte[ 9 ] = - b * e;\\n\\n\\t\\t\\t\\tte[ 2 ] = - d * e;\\n\\t\\t\\t\\tte[ 6 ] = ad * f + bc;\\n\\t\\t\\t\\tte[ 10 ] = ac - bd * f;\\n\\n\\t\\t\\t} else if ( euler.order === 'XZY' ) {\\n\\n\\t\\t\\t\\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\\n\\n\\t\\t\\t\\tte[ 0 ] = c * e;\\n\\t\\t\\t\\tte[ 4 ] = - f;\\n\\t\\t\\t\\tte[ 8 ] = d * e;\\n\\n\\t\\t\\t\\tte[ 1 ] = ac * f + bd;\\n\\t\\t\\t\\tte[ 5 ] = a * e;\\n\\t\\t\\t\\tte[ 9 ] = ad * f - bc;\\n\\n\\t\\t\\t\\tte[ 2 ] = bc * f - ad;\\n\\t\\t\\t\\tte[ 6 ] = b * e;\\n\\t\\t\\t\\tte[ 10 ] = bd * f + ac;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// last column\\n\\t\\t\\tte[ 3 ] = 0;\\n\\t\\t\\tte[ 7 ] = 0;\\n\\t\\t\\tte[ 11 ] = 0;\\n\\n\\t\\t\\t// bottom row\\n\\t\\t\\tte[ 12 ] = 0;\\n\\t\\t\\tte[ 13 ] = 0;\\n\\t\\t\\tte[ 14 ] = 0;\\n\\t\\t\\tte[ 15 ] = 1;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeRotationFromQuaternion: function ( q ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tvar x = q._x, y = q._y, z = q._z, w = q._w;\\n\\t\\t\\tvar x2 = x + x, y2 = y + y, z2 = z + z;\\n\\t\\t\\tvar xx = x * x2, xy = x * y2, xz = x * z2;\\n\\t\\t\\tvar yy = y * y2, yz = y * z2, zz = z * z2;\\n\\t\\t\\tvar wx = w * x2, wy = w * y2, wz = w * z2;\\n\\n\\t\\t\\tte[ 0 ] = 1 - ( yy + zz );\\n\\t\\t\\tte[ 4 ] = xy - wz;\\n\\t\\t\\tte[ 8 ] = xz + wy;\\n\\n\\t\\t\\tte[ 1 ] = xy + wz;\\n\\t\\t\\tte[ 5 ] = 1 - ( xx + zz );\\n\\t\\t\\tte[ 9 ] = yz - wx;\\n\\n\\t\\t\\tte[ 2 ] = xz - wy;\\n\\t\\t\\tte[ 6 ] = yz + wx;\\n\\t\\t\\tte[ 10 ] = 1 - ( xx + yy );\\n\\n\\t\\t\\t// last column\\n\\t\\t\\tte[ 3 ] = 0;\\n\\t\\t\\tte[ 7 ] = 0;\\n\\t\\t\\tte[ 11 ] = 0;\\n\\n\\t\\t\\t// bottom row\\n\\t\\t\\tte[ 12 ] = 0;\\n\\t\\t\\tte[ 13 ] = 0;\\n\\t\\t\\tte[ 14 ] = 0;\\n\\t\\t\\tte[ 15 ] = 1;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tlookAt: function () {\\n\\n\\t\\t\\tvar x = new Vector3();\\n\\t\\t\\tvar y = new Vector3();\\n\\t\\t\\tvar z = new Vector3();\\n\\n\\t\\t\\treturn function lookAt( eye, target, up ) {\\n\\n\\t\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\t\\tz.subVectors( eye, target );\\n\\n\\t\\t\\t\\tif ( z.lengthSq() === 0 ) {\\n\\n\\t\\t\\t\\t\\t// eye and target are in the same position\\n\\n\\t\\t\\t\\t\\tz.z = 1;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tz.normalize();\\n\\t\\t\\t\\tx.crossVectors( up, z );\\n\\n\\t\\t\\t\\tif ( x.lengthSq() === 0 ) {\\n\\n\\t\\t\\t\\t\\t// up and z are parallel\\n\\n\\t\\t\\t\\t\\tif ( Math.abs( up.z ) === 1 ) {\\n\\n\\t\\t\\t\\t\\t\\tz.x += 0.0001;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tz.z += 0.0001;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tz.normalize();\\n\\t\\t\\t\\t\\tx.crossVectors( up, z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tx.normalize();\\n\\t\\t\\t\\ty.crossVectors( z, x );\\n\\n\\t\\t\\t\\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\\n\\t\\t\\t\\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\\n\\t\\t\\t\\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tmultiply: function ( m, n ) {\\n\\n\\t\\t\\tif ( n !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.multiplyMatrices( m, n );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this.multiplyMatrices( this, m );\\n\\n\\t\\t},\\n\\n\\t\\tpremultiply: function ( m ) {\\n\\n\\t\\t\\treturn this.multiplyMatrices( m, this );\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyMatrices: function ( a, b ) {\\n\\n\\t\\t\\tvar ae = a.elements;\\n\\t\\t\\tvar be = b.elements;\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\\n\\t\\t\\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\\n\\t\\t\\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\\n\\t\\t\\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\\n\\n\\t\\t\\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\\n\\t\\t\\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\\n\\t\\t\\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\\n\\t\\t\\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\\n\\n\\t\\t\\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\\n\\t\\t\\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\\n\\t\\t\\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\\n\\t\\t\\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\\n\\n\\t\\t\\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\\n\\t\\t\\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\\n\\t\\t\\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\\n\\t\\t\\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\\n\\n\\t\\t\\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\\n\\t\\t\\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\\n\\t\\t\\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\\n\\t\\t\\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\\n\\n\\t\\t\\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\\n\\t\\t\\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\\n\\t\\t\\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\\n\\t\\t\\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyScalar: function ( s ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\\n\\t\\t\\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\\n\\t\\t\\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\\n\\t\\t\\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tapplyToBufferAttribute: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function applyToBufferAttribute( attribute ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tv1.x = attribute.getX( i );\\n\\t\\t\\t\\t\\tv1.y = attribute.getY( i );\\n\\t\\t\\t\\t\\tv1.z = attribute.getZ( i );\\n\\n\\t\\t\\t\\t\\tv1.applyMatrix4( this );\\n\\n\\t\\t\\t\\t\\tattribute.setXYZ( i, v1.x, v1.y, v1.z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn attribute;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tdeterminant: function () {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\\n\\t\\t\\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\\n\\t\\t\\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\\n\\t\\t\\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\\n\\n\\t\\t\\t//TODO: make this more efficient\\n\\t\\t\\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\\n\\n\\t\\t\\treturn (\\n\\t\\t\\t\\tn41 * (\\n\\t\\t\\t\\t\\t+ n14 * n23 * n32\\n\\t\\t\\t\\t\\t - n13 * n24 * n32\\n\\t\\t\\t\\t\\t - n14 * n22 * n33\\n\\t\\t\\t\\t\\t + n12 * n24 * n33\\n\\t\\t\\t\\t\\t + n13 * n22 * n34\\n\\t\\t\\t\\t\\t - n12 * n23 * n34\\n\\t\\t\\t\\t) +\\n\\t\\t\\t\\tn42 * (\\n\\t\\t\\t\\t\\t+ n11 * n23 * n34\\n\\t\\t\\t\\t\\t - n11 * n24 * n33\\n\\t\\t\\t\\t\\t + n14 * n21 * n33\\n\\t\\t\\t\\t\\t - n13 * n21 * n34\\n\\t\\t\\t\\t\\t + n13 * n24 * n31\\n\\t\\t\\t\\t\\t - n14 * n23 * n31\\n\\t\\t\\t\\t) +\\n\\t\\t\\t\\tn43 * (\\n\\t\\t\\t\\t\\t+ n11 * n24 * n32\\n\\t\\t\\t\\t\\t - n11 * n22 * n34\\n\\t\\t\\t\\t\\t - n14 * n21 * n32\\n\\t\\t\\t\\t\\t + n12 * n21 * n34\\n\\t\\t\\t\\t\\t + n14 * n22 * n31\\n\\t\\t\\t\\t\\t - n12 * n24 * n31\\n\\t\\t\\t\\t) +\\n\\t\\t\\t\\tn44 * (\\n\\t\\t\\t\\t\\t- n13 * n22 * n31\\n\\t\\t\\t\\t\\t - n11 * n23 * n32\\n\\t\\t\\t\\t\\t + n11 * n22 * n33\\n\\t\\t\\t\\t\\t + n13 * n21 * n32\\n\\t\\t\\t\\t\\t - n12 * n21 * n33\\n\\t\\t\\t\\t\\t + n12 * n23 * n31\\n\\t\\t\\t\\t)\\n\\n\\t\\t\\t);\\n\\n\\t\\t},\\n\\n\\t\\ttranspose: function () {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\t\\t\\tvar tmp;\\n\\n\\t\\t\\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\\n\\t\\t\\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\\n\\t\\t\\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\\n\\n\\t\\t\\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\\n\\t\\t\\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\\n\\t\\t\\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetPosition: function ( v ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tte[ 12 ] = v.x;\\n\\t\\t\\tte[ 13 ] = v.y;\\n\\t\\t\\tte[ 14 ] = v.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetInverse: function ( m, throwOnDegenerate ) {\\n\\n\\t\\t\\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\\n\\t\\t\\tvar te = this.elements,\\n\\t\\t\\t\\tme = m.elements,\\n\\n\\t\\t\\t\\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\\n\\t\\t\\t\\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\\n\\t\\t\\t\\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\\n\\t\\t\\t\\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\\n\\n\\t\\t\\t\\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\\n\\t\\t\\t\\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\\n\\t\\t\\t\\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\\n\\t\\t\\t\\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\\n\\n\\t\\t\\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\\n\\n\\t\\t\\tif ( det === 0 ) {\\n\\n\\t\\t\\t\\tvar msg = \\\"THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0\\\";\\n\\n\\t\\t\\t\\tif ( throwOnDegenerate === true ) {\\n\\n\\t\\t\\t\\t\\tthrow new Error( msg );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tconsole.warn( msg );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn this.identity();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar detInv = 1 / det;\\n\\n\\t\\t\\tte[ 0 ] = t11 * detInv;\\n\\t\\t\\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\\n\\t\\t\\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\\n\\t\\t\\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\\n\\n\\t\\t\\tte[ 4 ] = t12 * detInv;\\n\\t\\t\\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\\n\\t\\t\\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\\n\\t\\t\\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\\n\\n\\t\\t\\tte[ 8 ] = t13 * detInv;\\n\\t\\t\\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\\n\\t\\t\\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\\n\\t\\t\\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\\n\\n\\t\\t\\tte[ 12 ] = t14 * detInv;\\n\\t\\t\\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\\n\\t\\t\\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\\n\\t\\t\\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tscale: function ( v ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\t\\t\\tvar x = v.x, y = v.y, z = v.z;\\n\\n\\t\\t\\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\\n\\t\\t\\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\\n\\t\\t\\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\\n\\t\\t\\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetMaxScaleOnAxis: function () {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\\n\\t\\t\\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\\n\\t\\t\\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\\n\\n\\t\\t\\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\\n\\n\\t\\t},\\n\\n\\t\\tmakeTranslation: function ( x, y, z ) {\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\t1, 0, 0, x,\\n\\t\\t\\t\\t0, 1, 0, y,\\n\\t\\t\\t\\t0, 0, 1, z,\\n\\t\\t\\t\\t0, 0, 0, 1\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeRotationX: function ( theta ) {\\n\\n\\t\\t\\tvar c = Math.cos( theta ), s = Math.sin( theta );\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\t1, 0, 0, 0,\\n\\t\\t\\t\\t0, c, - s, 0,\\n\\t\\t\\t\\t0, s, c, 0,\\n\\t\\t\\t\\t0, 0, 0, 1\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeRotationY: function ( theta ) {\\n\\n\\t\\t\\tvar c = Math.cos( theta ), s = Math.sin( theta );\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\t c, 0, s, 0,\\n\\t\\t\\t\\t 0, 1, 0, 0,\\n\\t\\t\\t\\t- s, 0, c, 0,\\n\\t\\t\\t\\t 0, 0, 0, 1\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeRotationZ: function ( theta ) {\\n\\n\\t\\t\\tvar c = Math.cos( theta ), s = Math.sin( theta );\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\tc, - s, 0, 0,\\n\\t\\t\\t\\ts, c, 0, 0,\\n\\t\\t\\t\\t0, 0, 1, 0,\\n\\t\\t\\t\\t0, 0, 0, 1\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeRotationAxis: function ( axis, angle ) {\\n\\n\\t\\t\\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\\n\\n\\t\\t\\tvar c = Math.cos( angle );\\n\\t\\t\\tvar s = Math.sin( angle );\\n\\t\\t\\tvar t = 1 - c;\\n\\t\\t\\tvar x = axis.x, y = axis.y, z = axis.z;\\n\\t\\t\\tvar tx = t * x, ty = t * y;\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\\n\\t\\t\\t\\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\\n\\t\\t\\t\\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\\n\\t\\t\\t\\t0, 0, 0, 1\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\t return this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeScale: function ( x, y, z ) {\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\tx, 0, 0, 0,\\n\\t\\t\\t\\t0, y, 0, 0,\\n\\t\\t\\t\\t0, 0, z, 0,\\n\\t\\t\\t\\t0, 0, 0, 1\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeShear: function ( x, y, z ) {\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\t1, y, z, 0,\\n\\t\\t\\t\\tx, 1, z, 0,\\n\\t\\t\\t\\tx, y, 1, 0,\\n\\t\\t\\t\\t0, 0, 0, 1\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcompose: function ( position, quaternion, scale ) {\\n\\n\\t\\t\\tthis.makeRotationFromQuaternion( quaternion );\\n\\t\\t\\tthis.scale( scale );\\n\\t\\t\\tthis.setPosition( position );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdecompose: function () {\\n\\n\\t\\t\\tvar vector = new Vector3();\\n\\t\\t\\tvar matrix = new Matrix4();\\n\\n\\t\\t\\treturn function decompose( position, quaternion, scale ) {\\n\\n\\t\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\t\\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\\n\\t\\t\\t\\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\\n\\t\\t\\t\\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\\n\\n\\t\\t\\t\\t// if determine is negative, we need to invert one scale\\n\\t\\t\\t\\tvar det = this.determinant();\\n\\t\\t\\t\\tif ( det < 0 ) sx = - sx;\\n\\n\\t\\t\\t\\tposition.x = te[ 12 ];\\n\\t\\t\\t\\tposition.y = te[ 13 ];\\n\\t\\t\\t\\tposition.z = te[ 14 ];\\n\\n\\t\\t\\t\\t// scale the rotation part\\n\\t\\t\\t\\tmatrix.copy( this );\\n\\n\\t\\t\\t\\tvar invSX = 1 / sx;\\n\\t\\t\\t\\tvar invSY = 1 / sy;\\n\\t\\t\\t\\tvar invSZ = 1 / sz;\\n\\n\\t\\t\\t\\tmatrix.elements[ 0 ] *= invSX;\\n\\t\\t\\t\\tmatrix.elements[ 1 ] *= invSX;\\n\\t\\t\\t\\tmatrix.elements[ 2 ] *= invSX;\\n\\n\\t\\t\\t\\tmatrix.elements[ 4 ] *= invSY;\\n\\t\\t\\t\\tmatrix.elements[ 5 ] *= invSY;\\n\\t\\t\\t\\tmatrix.elements[ 6 ] *= invSY;\\n\\n\\t\\t\\t\\tmatrix.elements[ 8 ] *= invSZ;\\n\\t\\t\\t\\tmatrix.elements[ 9 ] *= invSZ;\\n\\t\\t\\t\\tmatrix.elements[ 10 ] *= invSZ;\\n\\n\\t\\t\\t\\tquaternion.setFromRotationMatrix( matrix );\\n\\n\\t\\t\\t\\tscale.x = sx;\\n\\t\\t\\t\\tscale.y = sy;\\n\\t\\t\\t\\tscale.z = sz;\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tmakePerspective: function ( left, right, top, bottom, near, far ) {\\n\\n\\t\\t\\tif ( far === undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar te = this.elements;\\n\\t\\t\\tvar x = 2 * near / ( right - left );\\n\\t\\t\\tvar y = 2 * near / ( top - bottom );\\n\\n\\t\\t\\tvar a = ( right + left ) / ( right - left );\\n\\t\\t\\tvar b = ( top + bottom ) / ( top - bottom );\\n\\t\\t\\tvar c = - ( far + near ) / ( far - near );\\n\\t\\t\\tvar d = - 2 * far * near / ( far - near );\\n\\n\\t\\t\\tte[ 0 ] = x;\\tte[ 4 ] = 0;\\tte[ 8 ] = a;\\tte[ 12 ] = 0;\\n\\t\\t\\tte[ 1 ] = 0;\\tte[ 5 ] = y;\\tte[ 9 ] = b;\\tte[ 13 ] = 0;\\n\\t\\t\\tte[ 2 ] = 0;\\tte[ 6 ] = 0;\\tte[ 10 ] = c;\\tte[ 14 ] = d;\\n\\t\\t\\tte[ 3 ] = 0;\\tte[ 7 ] = 0;\\tte[ 11 ] = - 1;\\tte[ 15 ] = 0;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\t\\t\\tvar w = 1.0 / ( right - left );\\n\\t\\t\\tvar h = 1.0 / ( top - bottom );\\n\\t\\t\\tvar p = 1.0 / ( far - near );\\n\\n\\t\\t\\tvar x = ( right + left ) * w;\\n\\t\\t\\tvar y = ( top + bottom ) * h;\\n\\t\\t\\tvar z = ( far + near ) * p;\\n\\n\\t\\t\\tte[ 0 ] = 2 * w;\\tte[ 4 ] = 0;\\tte[ 8 ] = 0;\\tte[ 12 ] = - x;\\n\\t\\t\\tte[ 1 ] = 0;\\tte[ 5 ] = 2 * h;\\tte[ 9 ] = 0;\\tte[ 13 ] = - y;\\n\\t\\t\\tte[ 2 ] = 0;\\tte[ 6 ] = 0;\\tte[ 10 ] = - 2 * p;\\tte[ 14 ] = - z;\\n\\t\\t\\tte[ 3 ] = 0;\\tte[ 7 ] = 0;\\tte[ 11 ] = 0;\\tte[ 15 ] = 1;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( matrix ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\t\\t\\tvar me = matrix.elements;\\n\\n\\t\\t\\tfor ( var i = 0; i < 16; i ++ ) {\\n\\n\\t\\t\\t\\tif ( te[ i ] !== me[ i ] ) return false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn true;\\n\\n\\t\\t},\\n\\n\\t\\tfromArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tfor ( var i = 0; i < 16; i ++ ) {\\n\\n\\t\\t\\t\\tthis.elements[ i ] = array[ i + offset ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( array === undefined ) array = [];\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tarray[ offset ] = te[ 0 ];\\n\\t\\t\\tarray[ offset + 1 ] = te[ 1 ];\\n\\t\\t\\tarray[ offset + 2 ] = te[ 2 ];\\n\\t\\t\\tarray[ offset + 3 ] = te[ 3 ];\\n\\n\\t\\t\\tarray[ offset + 4 ] = te[ 4 ];\\n\\t\\t\\tarray[ offset + 5 ] = te[ 5 ];\\n\\t\\t\\tarray[ offset + 6 ] = te[ 6 ];\\n\\t\\t\\tarray[ offset + 7 ] = te[ 7 ];\\n\\n\\t\\t\\tarray[ offset + 8 ] = te[ 8 ];\\n\\t\\t\\tarray[ offset + 9 ] = te[ 9 ];\\n\\t\\t\\tarray[ offset + 10 ] = te[ 10 ];\\n\\t\\t\\tarray[ offset + 11 ] = te[ 11 ];\\n\\n\\t\\t\\tarray[ offset + 12 ] = te[ 12 ];\\n\\t\\t\\tarray[ offset + 13 ] = te[ 13 ];\\n\\t\\t\\tarray[ offset + 14 ] = te[ 14 ];\\n\\t\\t\\tarray[ offset + 15 ] = te[ 15 ];\\n\\n\\t\\t\\treturn array;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t * @author bhouston / http://clara.io\\n\\t */\\n\\n\\tfunction Quaternion( x, y, z, w ) {\\n\\n\\t\\tthis._x = x || 0;\\n\\t\\tthis._y = y || 0;\\n\\t\\tthis._z = z || 0;\\n\\t\\tthis._w = ( w !== undefined ) ? w : 1;\\n\\n\\t}\\n\\n\\tObject.assign( Quaternion, {\\n\\n\\t\\tslerp: function ( qa, qb, qm, t ) {\\n\\n\\t\\t\\treturn qm.copy( qa ).slerp( qb, t );\\n\\n\\t\\t},\\n\\n\\t\\tslerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\\n\\n\\t\\t\\t// fuzz-free, array-based Quaternion SLERP operation\\n\\n\\t\\t\\tvar x0 = src0[ srcOffset0 + 0 ],\\n\\t\\t\\t\\ty0 = src0[ srcOffset0 + 1 ],\\n\\t\\t\\t\\tz0 = src0[ srcOffset0 + 2 ],\\n\\t\\t\\t\\tw0 = src0[ srcOffset0 + 3 ],\\n\\n\\t\\t\\t\\tx1 = src1[ srcOffset1 + 0 ],\\n\\t\\t\\t\\ty1 = src1[ srcOffset1 + 1 ],\\n\\t\\t\\t\\tz1 = src1[ srcOffset1 + 2 ],\\n\\t\\t\\t\\tw1 = src1[ srcOffset1 + 3 ];\\n\\n\\t\\t\\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\\n\\n\\t\\t\\t\\tvar s = 1 - t,\\n\\n\\t\\t\\t\\t\\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\\n\\n\\t\\t\\t\\t\\tdir = ( cos >= 0 ? 1 : - 1 ),\\n\\t\\t\\t\\t\\tsqrSin = 1 - cos * cos;\\n\\n\\t\\t\\t\\t// Skip the Slerp for tiny steps to avoid numeric problems:\\n\\t\\t\\t\\tif ( sqrSin > Number.EPSILON ) {\\n\\n\\t\\t\\t\\t\\tvar sin = Math.sqrt( sqrSin ),\\n\\t\\t\\t\\t\\t\\tlen = Math.atan2( sin, cos * dir );\\n\\n\\t\\t\\t\\t\\ts = Math.sin( s * len ) / sin;\\n\\t\\t\\t\\t\\tt = Math.sin( t * len ) / sin;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar tDir = t * dir;\\n\\n\\t\\t\\t\\tx0 = x0 * s + x1 * tDir;\\n\\t\\t\\t\\ty0 = y0 * s + y1 * tDir;\\n\\t\\t\\t\\tz0 = z0 * s + z1 * tDir;\\n\\t\\t\\t\\tw0 = w0 * s + w1 * tDir;\\n\\n\\t\\t\\t\\t// Normalize in case we just did a lerp:\\n\\t\\t\\t\\tif ( s === 1 - t ) {\\n\\n\\t\\t\\t\\t\\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\\n\\n\\t\\t\\t\\t\\tx0 *= f;\\n\\t\\t\\t\\t\\ty0 *= f;\\n\\t\\t\\t\\t\\tz0 *= f;\\n\\t\\t\\t\\t\\tw0 *= f;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tdst[ dstOffset ] = x0;\\n\\t\\t\\tdst[ dstOffset + 1 ] = y0;\\n\\t\\t\\tdst[ dstOffset + 2 ] = z0;\\n\\t\\t\\tdst[ dstOffset + 3 ] = w0;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperties( Quaternion.prototype, {\\n\\n\\t\\tx: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this._x;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis._x = value;\\n\\t\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\ty: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this._y;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis._y = value;\\n\\t\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tz: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this._z;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis._z = value;\\n\\t\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tw: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this._w;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis._w = value;\\n\\t\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( Quaternion.prototype, {\\n\\n\\t\\tset: function ( x, y, z, w ) {\\n\\n\\t\\t\\tthis._x = x;\\n\\t\\t\\tthis._y = y;\\n\\t\\t\\tthis._z = z;\\n\\t\\t\\tthis._w = w;\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this._x, this._y, this._z, this._w );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( quaternion ) {\\n\\n\\t\\t\\tthis._x = quaternion.x;\\n\\t\\t\\tthis._y = quaternion.y;\\n\\t\\t\\tthis._z = quaternion.z;\\n\\t\\t\\tthis._w = quaternion.w;\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromEuler: function ( euler, update ) {\\n\\n\\t\\t\\tif ( ! ( euler && euler.isEuler ) ) {\\n\\n\\t\\t\\t\\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar x = euler._x, y = euler._y, z = euler._z, order = euler.order;\\n\\n\\t\\t\\t// http://www.mathworks.com/matlabcentral/fileexchange/\\n\\t\\t\\t// \\t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\\n\\t\\t\\t//\\tcontent/SpinCalc.m\\n\\n\\t\\t\\tvar cos = Math.cos;\\n\\t\\t\\tvar sin = Math.sin;\\n\\n\\t\\t\\tvar c1 = cos( x / 2 );\\n\\t\\t\\tvar c2 = cos( y / 2 );\\n\\t\\t\\tvar c3 = cos( z / 2 );\\n\\n\\t\\t\\tvar s1 = sin( x / 2 );\\n\\t\\t\\tvar s2 = sin( y / 2 );\\n\\t\\t\\tvar s3 = sin( z / 2 );\\n\\n\\t\\t\\tif ( order === 'XYZ' ) {\\n\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\\n\\n\\t\\t\\t} else if ( order === 'YXZ' ) {\\n\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\\n\\n\\t\\t\\t} else if ( order === 'ZXY' ) {\\n\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\\n\\n\\t\\t\\t} else if ( order === 'ZYX' ) {\\n\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\\n\\n\\t\\t\\t} else if ( order === 'YZX' ) {\\n\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\\n\\n\\t\\t\\t} else if ( order === 'XZY' ) {\\n\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( update !== false ) this.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromAxisAngle: function ( axis, angle ) {\\n\\n\\t\\t\\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\\n\\n\\t\\t\\t// assumes axis is normalized\\n\\n\\t\\t\\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\\n\\n\\t\\t\\tthis._x = axis.x * s;\\n\\t\\t\\tthis._y = axis.y * s;\\n\\t\\t\\tthis._z = axis.z * s;\\n\\t\\t\\tthis._w = Math.cos( halfAngle );\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromRotationMatrix: function ( m ) {\\n\\n\\t\\t\\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\\n\\n\\t\\t\\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\\n\\n\\t\\t\\tvar te = m.elements,\\n\\n\\t\\t\\t\\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\\n\\t\\t\\t\\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\\n\\t\\t\\t\\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\\n\\n\\t\\t\\t\\ttrace = m11 + m22 + m33,\\n\\t\\t\\t\\ts;\\n\\n\\t\\t\\tif ( trace > 0 ) {\\n\\n\\t\\t\\t\\ts = 0.5 / Math.sqrt( trace + 1.0 );\\n\\n\\t\\t\\t\\tthis._w = 0.25 / s;\\n\\t\\t\\t\\tthis._x = ( m32 - m23 ) * s;\\n\\t\\t\\t\\tthis._y = ( m13 - m31 ) * s;\\n\\t\\t\\t\\tthis._z = ( m21 - m12 ) * s;\\n\\n\\t\\t\\t} else if ( m11 > m22 && m11 > m33 ) {\\n\\n\\t\\t\\t\\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\\n\\n\\t\\t\\t\\tthis._w = ( m32 - m23 ) / s;\\n\\t\\t\\t\\tthis._x = 0.25 * s;\\n\\t\\t\\t\\tthis._y = ( m12 + m21 ) / s;\\n\\t\\t\\t\\tthis._z = ( m13 + m31 ) / s;\\n\\n\\t\\t\\t} else if ( m22 > m33 ) {\\n\\n\\t\\t\\t\\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\\n\\n\\t\\t\\t\\tthis._w = ( m13 - m31 ) / s;\\n\\t\\t\\t\\tthis._x = ( m12 + m21 ) / s;\\n\\t\\t\\t\\tthis._y = 0.25 * s;\\n\\t\\t\\t\\tthis._z = ( m23 + m32 ) / s;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\\n\\n\\t\\t\\t\\tthis._w = ( m21 - m12 ) / s;\\n\\t\\t\\t\\tthis._x = ( m13 + m31 ) / s;\\n\\t\\t\\t\\tthis._y = ( m23 + m32 ) / s;\\n\\t\\t\\t\\tthis._z = 0.25 * s;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromUnitVectors: function () {\\n\\n\\t\\t\\t// assumes direction vectors vFrom and vTo are normalized\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\t\\t\\tvar r;\\n\\n\\t\\t\\tvar EPS = 0.000001;\\n\\n\\t\\t\\treturn function setFromUnitVectors( vFrom, vTo ) {\\n\\n\\t\\t\\t\\tif ( v1 === undefined ) v1 = new Vector3();\\n\\n\\t\\t\\t\\tr = vFrom.dot( vTo ) + 1;\\n\\n\\t\\t\\t\\tif ( r < EPS ) {\\n\\n\\t\\t\\t\\t\\tr = 0;\\n\\n\\t\\t\\t\\t\\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\\n\\n\\t\\t\\t\\t\\t\\tv1.set( - vFrom.y, vFrom.x, 0 );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tv1.set( 0, - vFrom.z, vFrom.y );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tv1.crossVectors( vFrom, vTo );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis._x = v1.x;\\n\\t\\t\\t\\tthis._y = v1.y;\\n\\t\\t\\t\\tthis._z = v1.z;\\n\\t\\t\\t\\tthis._w = r;\\n\\n\\t\\t\\t\\treturn this.normalize();\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tinverse: function () {\\n\\n\\t\\t\\treturn this.conjugate().normalize();\\n\\n\\t\\t},\\n\\n\\t\\tconjugate: function () {\\n\\n\\t\\t\\tthis._x *= - 1;\\n\\t\\t\\tthis._y *= - 1;\\n\\t\\t\\tthis._z *= - 1;\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdot: function ( v ) {\\n\\n\\t\\t\\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\\n\\n\\t\\t},\\n\\n\\t\\tlengthSq: function () {\\n\\n\\t\\t\\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\\n\\n\\t\\t},\\n\\n\\t\\tlength: function () {\\n\\n\\t\\t\\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\\n\\n\\t\\t},\\n\\n\\t\\tnormalize: function () {\\n\\n\\t\\t\\tvar l = this.length();\\n\\n\\t\\t\\tif ( l === 0 ) {\\n\\n\\t\\t\\t\\tthis._x = 0;\\n\\t\\t\\t\\tthis._y = 0;\\n\\t\\t\\t\\tthis._z = 0;\\n\\t\\t\\t\\tthis._w = 1;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tl = 1 / l;\\n\\n\\t\\t\\t\\tthis._x = this._x * l;\\n\\t\\t\\t\\tthis._y = this._y * l;\\n\\t\\t\\t\\tthis._z = this._z * l;\\n\\t\\t\\t\\tthis._w = this._w * l;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiply: function ( q, p ) {\\n\\n\\t\\t\\tif ( p !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.multiplyQuaternions( q, p );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this.multiplyQuaternions( this, q );\\n\\n\\t\\t},\\n\\n\\t\\tpremultiply: function ( q ) {\\n\\n\\t\\t\\treturn this.multiplyQuaternions( q, this );\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyQuaternions: function ( a, b ) {\\n\\n\\t\\t\\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\\n\\n\\t\\t\\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\\n\\t\\t\\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\\n\\n\\t\\t\\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\\n\\t\\t\\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\\n\\t\\t\\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\\n\\t\\t\\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tslerp: function ( qb, t ) {\\n\\n\\t\\t\\tif ( t === 0 ) return this;\\n\\t\\t\\tif ( t === 1 ) return this.copy( qb );\\n\\n\\t\\t\\tvar x = this._x, y = this._y, z = this._z, w = this._w;\\n\\n\\t\\t\\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\\n\\n\\t\\t\\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\\n\\n\\t\\t\\tif ( cosHalfTheta < 0 ) {\\n\\n\\t\\t\\t\\tthis._w = - qb._w;\\n\\t\\t\\t\\tthis._x = - qb._x;\\n\\t\\t\\t\\tthis._y = - qb._y;\\n\\t\\t\\t\\tthis._z = - qb._z;\\n\\n\\t\\t\\t\\tcosHalfTheta = - cosHalfTheta;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.copy( qb );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( cosHalfTheta >= 1.0 ) {\\n\\n\\t\\t\\t\\tthis._w = w;\\n\\t\\t\\t\\tthis._x = x;\\n\\t\\t\\t\\tthis._y = y;\\n\\t\\t\\t\\tthis._z = z;\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\\n\\n\\t\\t\\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\\n\\n\\t\\t\\t\\tthis._w = 0.5 * ( w + this._w );\\n\\t\\t\\t\\tthis._x = 0.5 * ( x + this._x );\\n\\t\\t\\t\\tthis._y = 0.5 * ( y + this._y );\\n\\t\\t\\t\\tthis._z = 0.5 * ( z + this._z );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\\n\\t\\t\\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\\n\\t\\t\\t\\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\\n\\n\\t\\t\\tthis._w = ( w * ratioA + this._w * ratioB );\\n\\t\\t\\tthis._x = ( x * ratioA + this._x * ratioB );\\n\\t\\t\\tthis._y = ( y * ratioA + this._y * ratioB );\\n\\t\\t\\tthis._z = ( z * ratioA + this._z * ratioB );\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( quaternion ) {\\n\\n\\t\\t\\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\\n\\n\\t\\t},\\n\\n\\t\\tfromArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tthis._x = array[ offset ];\\n\\t\\t\\tthis._y = array[ offset + 1 ];\\n\\t\\t\\tthis._z = array[ offset + 2 ];\\n\\t\\t\\tthis._w = array[ offset + 3 ];\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( array === undefined ) array = [];\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tarray[ offset ] = this._x;\\n\\t\\t\\tarray[ offset + 1 ] = this._y;\\n\\t\\t\\tarray[ offset + 2 ] = this._z;\\n\\t\\t\\tarray[ offset + 3 ] = this._w;\\n\\n\\t\\t\\treturn array;\\n\\n\\t\\t},\\n\\n\\t\\tonChange: function ( callback ) {\\n\\n\\t\\t\\tthis.onChangeCallback = callback;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tonChangeCallback: function () {}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author kile / http://kile.stravaganza.org/\\n\\t * @author philogb / http://blog.thejit.org/\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author egraether / http://egraether.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction Vector3( x, y, z ) {\\n\\n\\t\\tthis.x = x || 0;\\n\\t\\tthis.y = y || 0;\\n\\t\\tthis.z = z || 0;\\n\\n\\t}\\n\\n\\tObject.assign( Vector3.prototype, {\\n\\n\\t\\tisVector3: true,\\n\\n\\t\\tset: function ( x, y, z ) {\\n\\n\\t\\t\\tthis.x = x;\\n\\t\\t\\tthis.y = y;\\n\\t\\t\\tthis.z = z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetScalar: function ( scalar ) {\\n\\n\\t\\t\\tthis.x = scalar;\\n\\t\\t\\tthis.y = scalar;\\n\\t\\t\\tthis.z = scalar;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetX: function ( x ) {\\n\\n\\t\\t\\tthis.x = x;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetY: function ( y ) {\\n\\n\\t\\t\\tthis.y = y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetZ: function ( z ) {\\n\\n\\t\\t\\tthis.z = z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetComponent: function ( index, value ) {\\n\\n\\t\\t\\tswitch ( index ) {\\n\\n\\t\\t\\t\\tcase 0: this.x = value; break;\\n\\t\\t\\t\\tcase 1: this.y = value; break;\\n\\t\\t\\t\\tcase 2: this.z = value; break;\\n\\t\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetComponent: function ( index ) {\\n\\n\\t\\t\\tswitch ( index ) {\\n\\n\\t\\t\\t\\tcase 0: return this.x;\\n\\t\\t\\t\\tcase 1: return this.y;\\n\\t\\t\\t\\tcase 2: return this.z;\\n\\t\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.x, this.y, this.z );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( v ) {\\n\\n\\t\\t\\tthis.x = v.x;\\n\\t\\t\\tthis.y = v.y;\\n\\t\\t\\tthis.z = v.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tadd: function ( v, w ) {\\n\\n\\t\\t\\tif ( w !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.addVectors( v, w );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x += v.x;\\n\\t\\t\\tthis.y += v.y;\\n\\t\\t\\tthis.z += v.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddScalar: function ( s ) {\\n\\n\\t\\t\\tthis.x += s;\\n\\t\\t\\tthis.y += s;\\n\\t\\t\\tthis.z += s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddVectors: function ( a, b ) {\\n\\n\\t\\t\\tthis.x = a.x + b.x;\\n\\t\\t\\tthis.y = a.y + b.y;\\n\\t\\t\\tthis.z = a.z + b.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddScaledVector: function ( v, s ) {\\n\\n\\t\\t\\tthis.x += v.x * s;\\n\\t\\t\\tthis.y += v.y * s;\\n\\t\\t\\tthis.z += v.z * s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsub: function ( v, w ) {\\n\\n\\t\\t\\tif ( w !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.subVectors( v, w );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x -= v.x;\\n\\t\\t\\tthis.y -= v.y;\\n\\t\\t\\tthis.z -= v.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsubScalar: function ( s ) {\\n\\n\\t\\t\\tthis.x -= s;\\n\\t\\t\\tthis.y -= s;\\n\\t\\t\\tthis.z -= s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsubVectors: function ( a, b ) {\\n\\n\\t\\t\\tthis.x = a.x - b.x;\\n\\t\\t\\tthis.y = a.y - b.y;\\n\\t\\t\\tthis.z = a.z - b.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiply: function ( v, w ) {\\n\\n\\t\\t\\tif ( w !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.multiplyVectors( v, w );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x *= v.x;\\n\\t\\t\\tthis.y *= v.y;\\n\\t\\t\\tthis.z *= v.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyScalar: function ( scalar ) {\\n\\n\\t\\t\\tthis.x *= scalar;\\n\\t\\t\\tthis.y *= scalar;\\n\\t\\t\\tthis.z *= scalar;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyVectors: function ( a, b ) {\\n\\n\\t\\t\\tthis.x = a.x * b.x;\\n\\t\\t\\tthis.y = a.y * b.y;\\n\\t\\t\\tthis.z = a.z * b.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tapplyEuler: function () {\\n\\n\\t\\t\\tvar quaternion = new Quaternion();\\n\\n\\t\\t\\treturn function applyEuler( euler ) {\\n\\n\\t\\t\\t\\tif ( ! ( euler && euler.isEuler ) ) {\\n\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn this.applyQuaternion( quaternion.setFromEuler( euler ) );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tapplyAxisAngle: function () {\\n\\n\\t\\t\\tvar quaternion = new Quaternion();\\n\\n\\t\\t\\treturn function applyAxisAngle( axis, angle ) {\\n\\n\\t\\t\\t\\treturn this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tapplyMatrix3: function ( m ) {\\n\\n\\t\\t\\tvar x = this.x, y = this.y, z = this.z;\\n\\t\\t\\tvar e = m.elements;\\n\\n\\t\\t\\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\\n\\t\\t\\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\\n\\t\\t\\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tapplyMatrix4: function ( m ) {\\n\\n\\t\\t\\tvar x = this.x, y = this.y, z = this.z;\\n\\t\\t\\tvar e = m.elements;\\n\\n\\t\\t\\tvar w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );\\n\\n\\t\\t\\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;\\n\\t\\t\\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;\\n\\t\\t\\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tapplyQuaternion: function ( q ) {\\n\\n\\t\\t\\tvar x = this.x, y = this.y, z = this.z;\\n\\t\\t\\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\\n\\n\\t\\t\\t// calculate quat * vector\\n\\n\\t\\t\\tvar ix = qw * x + qy * z - qz * y;\\n\\t\\t\\tvar iy = qw * y + qz * x - qx * z;\\n\\t\\t\\tvar iz = qw * z + qx * y - qy * x;\\n\\t\\t\\tvar iw = - qx * x - qy * y - qz * z;\\n\\n\\t\\t\\t// calculate result * inverse quat\\n\\n\\t\\t\\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\\n\\t\\t\\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\\n\\t\\t\\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tproject: function () {\\n\\n\\t\\t\\tvar matrix = new Matrix4();\\n\\n\\t\\t\\treturn function project( camera ) {\\n\\n\\t\\t\\t\\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\\n\\t\\t\\t\\treturn this.applyMatrix4( matrix );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tunproject: function () {\\n\\n\\t\\t\\tvar matrix = new Matrix4();\\n\\n\\t\\t\\treturn function unproject( camera ) {\\n\\n\\t\\t\\t\\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\\n\\t\\t\\t\\treturn this.applyMatrix4( matrix );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttransformDirection: function ( m ) {\\n\\n\\t\\t\\t// input: THREE.Matrix4 affine matrix\\n\\t\\t\\t// vector interpreted as a direction\\n\\n\\t\\t\\tvar x = this.x, y = this.y, z = this.z;\\n\\t\\t\\tvar e = m.elements;\\n\\n\\t\\t\\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\\n\\t\\t\\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\\n\\t\\t\\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\\n\\n\\t\\t\\treturn this.normalize();\\n\\n\\t\\t},\\n\\n\\t\\tdivide: function ( v ) {\\n\\n\\t\\t\\tthis.x /= v.x;\\n\\t\\t\\tthis.y /= v.y;\\n\\t\\t\\tthis.z /= v.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdivideScalar: function ( scalar ) {\\n\\n\\t\\t\\treturn this.multiplyScalar( 1 / scalar );\\n\\n\\t\\t},\\n\\n\\t\\tmin: function ( v ) {\\n\\n\\t\\t\\tthis.x = Math.min( this.x, v.x );\\n\\t\\t\\tthis.y = Math.min( this.y, v.y );\\n\\t\\t\\tthis.z = Math.min( this.z, v.z );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmax: function ( v ) {\\n\\n\\t\\t\\tthis.x = Math.max( this.x, v.x );\\n\\t\\t\\tthis.y = Math.max( this.y, v.y );\\n\\t\\t\\tthis.z = Math.max( this.z, v.z );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclamp: function ( min, max ) {\\n\\n\\t\\t\\t// assumes min < max, componentwise\\n\\n\\t\\t\\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\\n\\t\\t\\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\\n\\t\\t\\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclampScalar: function () {\\n\\n\\t\\t\\tvar min = new Vector3();\\n\\t\\t\\tvar max = new Vector3();\\n\\n\\t\\t\\treturn function clampScalar( minVal, maxVal ) {\\n\\n\\t\\t\\t\\tmin.set( minVal, minVal, minVal );\\n\\t\\t\\t\\tmax.set( maxVal, maxVal, maxVal );\\n\\n\\t\\t\\t\\treturn this.clamp( min, max );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tclampLength: function ( min, max ) {\\n\\n\\t\\t\\tvar length = this.length();\\n\\n\\t\\t\\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\\n\\n\\t\\t},\\n\\n\\t\\tfloor: function () {\\n\\n\\t\\t\\tthis.x = Math.floor( this.x );\\n\\t\\t\\tthis.y = Math.floor( this.y );\\n\\t\\t\\tthis.z = Math.floor( this.z );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tceil: function () {\\n\\n\\t\\t\\tthis.x = Math.ceil( this.x );\\n\\t\\t\\tthis.y = Math.ceil( this.y );\\n\\t\\t\\tthis.z = Math.ceil( this.z );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tround: function () {\\n\\n\\t\\t\\tthis.x = Math.round( this.x );\\n\\t\\t\\tthis.y = Math.round( this.y );\\n\\t\\t\\tthis.z = Math.round( this.z );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\troundToZero: function () {\\n\\n\\t\\t\\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\\n\\t\\t\\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\\n\\t\\t\\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tnegate: function () {\\n\\n\\t\\t\\tthis.x = - this.x;\\n\\t\\t\\tthis.y = - this.y;\\n\\t\\t\\tthis.z = - this.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdot: function ( v ) {\\n\\n\\t\\t\\treturn this.x * v.x + this.y * v.y + this.z * v.z;\\n\\n\\t\\t},\\n\\n\\t\\t// TODO lengthSquared?\\n\\n\\t\\tlengthSq: function () {\\n\\n\\t\\t\\treturn this.x * this.x + this.y * this.y + this.z * this.z;\\n\\n\\t\\t},\\n\\n\\t\\tlength: function () {\\n\\n\\t\\t\\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\\n\\n\\t\\t},\\n\\n\\t\\tmanhattanLength: function () {\\n\\n\\t\\t\\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\\n\\n\\t\\t},\\n\\n\\t\\tnormalize: function () {\\n\\n\\t\\t\\treturn this.divideScalar( this.length() || 1 );\\n\\n\\t\\t},\\n\\n\\t\\tsetLength: function ( length ) {\\n\\n\\t\\t\\treturn this.normalize().multiplyScalar( length );\\n\\n\\t\\t},\\n\\n\\t\\tlerp: function ( v, alpha ) {\\n\\n\\t\\t\\tthis.x += ( v.x - this.x ) * alpha;\\n\\t\\t\\tthis.y += ( v.y - this.y ) * alpha;\\n\\t\\t\\tthis.z += ( v.z - this.z ) * alpha;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tlerpVectors: function ( v1, v2, alpha ) {\\n\\n\\t\\t\\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\\n\\n\\t\\t},\\n\\n\\t\\tcross: function ( v, w ) {\\n\\n\\t\\t\\tif ( w !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.crossVectors( v, w );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this.crossVectors( this, v );\\n\\n\\t\\t},\\n\\n\\t\\tcrossVectors: function ( a, b ) {\\n\\n\\t\\t\\tvar ax = a.x, ay = a.y, az = a.z;\\n\\t\\t\\tvar bx = b.x, by = b.y, bz = b.z;\\n\\n\\t\\t\\tthis.x = ay * bz - az * by;\\n\\t\\t\\tthis.y = az * bx - ax * bz;\\n\\t\\t\\tthis.z = ax * by - ay * bx;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tprojectOnVector: function ( vector ) {\\n\\n\\t\\t\\tvar scalar = vector.dot( this ) / vector.lengthSq();\\n\\n\\t\\t\\treturn this.copy( vector ).multiplyScalar( scalar );\\n\\n\\t\\t},\\n\\n\\t\\tprojectOnPlane: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function projectOnPlane( planeNormal ) {\\n\\n\\t\\t\\t\\tv1.copy( this ).projectOnVector( planeNormal );\\n\\n\\t\\t\\t\\treturn this.sub( v1 );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\treflect: function () {\\n\\n\\t\\t\\t// reflect incident vector off plane orthogonal to normal\\n\\t\\t\\t// normal is assumed to have unit length\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function reflect( normal ) {\\n\\n\\t\\t\\t\\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tangleTo: function ( v ) {\\n\\n\\t\\t\\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\\n\\n\\t\\t\\t// clamp, to handle numerical problems\\n\\n\\t\\t\\treturn Math.acos( _Math.clamp( theta, - 1, 1 ) );\\n\\n\\t\\t},\\n\\n\\t\\tdistanceTo: function ( v ) {\\n\\n\\t\\t\\treturn Math.sqrt( this.distanceToSquared( v ) );\\n\\n\\t\\t},\\n\\n\\t\\tdistanceToSquared: function ( v ) {\\n\\n\\t\\t\\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\\n\\n\\t\\t\\treturn dx * dx + dy * dy + dz * dz;\\n\\n\\t\\t},\\n\\n\\t\\tmanhattanDistanceTo: function ( v ) {\\n\\n\\t\\t\\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\\n\\n\\t\\t},\\n\\n\\t\\tsetFromSpherical: function ( s ) {\\n\\n\\t\\t\\tvar sinPhiRadius = Math.sin( s.phi ) * s.radius;\\n\\n\\t\\t\\tthis.x = sinPhiRadius * Math.sin( s.theta );\\n\\t\\t\\tthis.y = Math.cos( s.phi ) * s.radius;\\n\\t\\t\\tthis.z = sinPhiRadius * Math.cos( s.theta );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromCylindrical: function ( c ) {\\n\\n\\t\\t\\tthis.x = c.radius * Math.sin( c.theta );\\n\\t\\t\\tthis.y = c.y;\\n\\t\\t\\tthis.z = c.radius * Math.cos( c.theta );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromMatrixPosition: function ( m ) {\\n\\n\\t\\t\\tvar e = m.elements;\\n\\n\\t\\t\\tthis.x = e[ 12 ];\\n\\t\\t\\tthis.y = e[ 13 ];\\n\\t\\t\\tthis.z = e[ 14 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromMatrixScale: function ( m ) {\\n\\n\\t\\t\\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\\n\\t\\t\\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\\n\\t\\t\\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\\n\\n\\t\\t\\tthis.x = sx;\\n\\t\\t\\tthis.y = sy;\\n\\t\\t\\tthis.z = sz;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromMatrixColumn: function ( m, index ) {\\n\\n\\t\\t\\treturn this.fromArray( m.elements, index * 4 );\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( v ) {\\n\\n\\t\\t\\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\\n\\n\\t\\t},\\n\\n\\t\\tfromArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tthis.x = array[ offset ];\\n\\t\\t\\tthis.y = array[ offset + 1 ];\\n\\t\\t\\tthis.z = array[ offset + 2 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( array === undefined ) array = [];\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tarray[ offset ] = this.x;\\n\\t\\t\\tarray[ offset + 1 ] = this.y;\\n\\t\\t\\tarray[ offset + 2 ] = this.z;\\n\\n\\t\\t\\treturn array;\\n\\n\\t\\t},\\n\\n\\t\\tfromBufferAttribute: function ( attribute, index, offset ) {\\n\\n\\t\\t\\tif ( offset !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x = attribute.getX( index );\\n\\t\\t\\tthis.y = attribute.getY( index );\\n\\t\\t\\tthis.z = attribute.getZ( index );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t * @author bhouston / http://clara.io\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction Matrix3() {\\n\\n\\t\\tthis.elements = [\\n\\n\\t\\t\\t1, 0, 0,\\n\\t\\t\\t0, 1, 0,\\n\\t\\t\\t0, 0, 1\\n\\n\\t\\t];\\n\\n\\t\\tif ( arguments.length > 0 ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tObject.assign( Matrix3.prototype, {\\n\\n\\t\\tisMatrix3: true,\\n\\n\\t\\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\\n\\t\\t\\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\\n\\t\\t\\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tidentity: function () {\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\t1, 0, 0,\\n\\t\\t\\t\\t0, 1, 0,\\n\\t\\t\\t\\t0, 0, 1\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().fromArray( this.elements );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( m ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\t\\t\\tvar me = m.elements;\\n\\n\\t\\t\\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];\\n\\t\\t\\tte[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];\\n\\t\\t\\tte[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromMatrix4: function ( m ) {\\n\\n\\t\\t\\tvar me = m.elements;\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\tme[ 0 ], me[ 4 ], me[ 8 ],\\n\\t\\t\\t\\tme[ 1 ], me[ 5 ], me[ 9 ],\\n\\t\\t\\t\\tme[ 2 ], me[ 6 ], me[ 10 ]\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tapplyToBufferAttribute: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function applyToBufferAttribute( attribute ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tv1.x = attribute.getX( i );\\n\\t\\t\\t\\t\\tv1.y = attribute.getY( i );\\n\\t\\t\\t\\t\\tv1.z = attribute.getZ( i );\\n\\n\\t\\t\\t\\t\\tv1.applyMatrix3( this );\\n\\n\\t\\t\\t\\t\\tattribute.setXYZ( i, v1.x, v1.y, v1.z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn attribute;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tmultiply: function ( m ) {\\n\\n\\t\\t\\treturn this.multiplyMatrices( this, m );\\n\\n\\t\\t},\\n\\n\\t\\tpremultiply: function ( m ) {\\n\\n\\t\\t\\treturn this.multiplyMatrices( m, this );\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyMatrices: function ( a, b ) {\\n\\n\\t\\t\\tvar ae = a.elements;\\n\\t\\t\\tvar be = b.elements;\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tvar a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];\\n\\t\\t\\tvar a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];\\n\\t\\t\\tvar a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];\\n\\n\\t\\t\\tvar b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];\\n\\t\\t\\tvar b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];\\n\\t\\t\\tvar b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];\\n\\n\\t\\t\\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;\\n\\t\\t\\tte[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;\\n\\t\\t\\tte[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;\\n\\n\\t\\t\\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;\\n\\t\\t\\tte[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;\\n\\t\\t\\tte[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;\\n\\n\\t\\t\\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;\\n\\t\\t\\tte[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;\\n\\t\\t\\tte[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyScalar: function ( s ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\\n\\t\\t\\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\\n\\t\\t\\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdeterminant: function () {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\\n\\t\\t\\t\\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\\n\\t\\t\\t\\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\\n\\n\\t\\t\\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\\n\\n\\t\\t},\\n\\n\\t\\tgetInverse: function ( matrix, throwOnDegenerate ) {\\n\\n\\t\\t\\tif ( matrix && matrix.isMatrix4 ) {\\n\\n\\t\\t\\t\\tconsole.error( \\\"THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.\\\" );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar me = matrix.elements,\\n\\t\\t\\t\\tte = this.elements,\\n\\n\\t\\t\\t\\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\\n\\t\\t\\t\\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\\n\\t\\t\\t\\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\\n\\n\\t\\t\\t\\tt11 = n33 * n22 - n32 * n23,\\n\\t\\t\\t\\tt12 = n32 * n13 - n33 * n12,\\n\\t\\t\\t\\tt13 = n23 * n12 - n22 * n13,\\n\\n\\t\\t\\t\\tdet = n11 * t11 + n21 * t12 + n31 * t13;\\n\\n\\t\\t\\tif ( det === 0 ) {\\n\\n\\t\\t\\t\\tvar msg = \\\"THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0\\\";\\n\\n\\t\\t\\t\\tif ( throwOnDegenerate === true ) {\\n\\n\\t\\t\\t\\t\\tthrow new Error( msg );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tconsole.warn( msg );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn this.identity();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar detInv = 1 / det;\\n\\n\\t\\t\\tte[ 0 ] = t11 * detInv;\\n\\t\\t\\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\\n\\t\\t\\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\\n\\n\\t\\t\\tte[ 3 ] = t12 * detInv;\\n\\t\\t\\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\\n\\t\\t\\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\\n\\n\\t\\t\\tte[ 6 ] = t13 * detInv;\\n\\t\\t\\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\\n\\t\\t\\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttranspose: function () {\\n\\n\\t\\t\\tvar tmp, m = this.elements;\\n\\n\\t\\t\\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\\n\\t\\t\\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\\n\\t\\t\\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetNormalMatrix: function ( matrix4 ) {\\n\\n\\t\\t\\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\\n\\n\\t\\t},\\n\\n\\t\\ttransposeIntoArray: function ( r ) {\\n\\n\\t\\t\\tvar m = this.elements;\\n\\n\\t\\t\\tr[ 0 ] = m[ 0 ];\\n\\t\\t\\tr[ 1 ] = m[ 3 ];\\n\\t\\t\\tr[ 2 ] = m[ 6 ];\\n\\t\\t\\tr[ 3 ] = m[ 1 ];\\n\\t\\t\\tr[ 4 ] = m[ 4 ];\\n\\t\\t\\tr[ 5 ] = m[ 7 ];\\n\\t\\t\\tr[ 6 ] = m[ 2 ];\\n\\t\\t\\tr[ 7 ] = m[ 5 ];\\n\\t\\t\\tr[ 8 ] = m[ 8 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {\\n\\n\\t\\t\\tvar c = Math.cos( rotation );\\n\\t\\t\\tvar s = Math.sin( rotation );\\n\\n\\t\\t\\tthis.set(\\n\\t\\t\\t\\tsx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,\\n\\t\\t\\t\\t- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,\\n\\t\\t\\t\\t0, 0, 1\\n\\t\\t\\t);\\n\\n\\t\\t},\\n\\n\\t\\tscale: function ( sx, sy ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tte[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;\\n\\t\\t\\tte[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\trotate: function ( theta ) {\\n\\n\\t\\t\\tvar c = Math.cos( theta );\\n\\t\\t\\tvar s = Math.sin( theta );\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tvar a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];\\n\\t\\t\\tvar a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];\\n\\n\\t\\t\\tte[ 0 ] = c * a11 + s * a21;\\n\\t\\t\\tte[ 3 ] = c * a12 + s * a22;\\n\\t\\t\\tte[ 6 ] = c * a13 + s * a23;\\n\\n\\t\\t\\tte[ 1 ] = - s * a11 + c * a21;\\n\\t\\t\\tte[ 4 ] = - s * a12 + c * a22;\\n\\t\\t\\tte[ 7 ] = - s * a13 + c * a23;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttranslate: function ( tx, ty ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tte[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];\\n\\t\\t\\tte[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( matrix ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\t\\t\\tvar me = matrix.elements;\\n\\n\\t\\t\\tfor ( var i = 0; i < 9; i ++ ) {\\n\\n\\t\\t\\t\\tif ( te[ i ] !== me[ i ] ) return false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn true;\\n\\n\\t\\t},\\n\\n\\t\\tfromArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tfor ( var i = 0; i < 9; i ++ ) {\\n\\n\\t\\t\\t\\tthis.elements[ i ] = array[ i + offset ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( array === undefined ) array = [];\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tarray[ offset ] = te[ 0 ];\\n\\t\\t\\tarray[ offset + 1 ] = te[ 1 ];\\n\\t\\t\\tarray[ offset + 2 ] = te[ 2 ];\\n\\n\\t\\t\\tarray[ offset + 3 ] = te[ 3 ];\\n\\t\\t\\tarray[ offset + 4 ] = te[ 4 ];\\n\\t\\t\\tarray[ offset + 5 ] = te[ 5 ];\\n\\n\\t\\t\\tarray[ offset + 6 ] = te[ 6 ];\\n\\t\\t\\tarray[ offset + 7 ] = te[ 7 ];\\n\\t\\t\\tarray[ offset + 8 ] = te[ 8 ];\\n\\n\\t\\t\\treturn array;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author szimek / https://github.com/szimek/\\n\\t */\\n\\n\\tvar textureId = 0;\\n\\n\\tfunction Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\\n\\n\\t\\tObject.defineProperty( this, 'id', { value: textureId ++ } );\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\tthis.name = '';\\n\\n\\t\\tthis.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;\\n\\t\\tthis.mipmaps = [];\\n\\n\\t\\tthis.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;\\n\\n\\t\\tthis.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;\\n\\t\\tthis.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;\\n\\n\\t\\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\\n\\t\\tthis.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;\\n\\n\\t\\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\\n\\n\\t\\tthis.format = format !== undefined ? format : RGBAFormat;\\n\\t\\tthis.type = type !== undefined ? type : UnsignedByteType;\\n\\n\\t\\tthis.offset = new Vector2( 0, 0 );\\n\\t\\tthis.repeat = new Vector2( 1, 1 );\\n\\t\\tthis.center = new Vector2( 0, 0 );\\n\\t\\tthis.rotation = 0;\\n\\n\\t\\tthis.matrixAutoUpdate = true;\\n\\t\\tthis.matrix = new Matrix3();\\n\\n\\t\\tthis.generateMipmaps = true;\\n\\t\\tthis.premultiplyAlpha = false;\\n\\t\\tthis.flipY = true;\\n\\t\\tthis.unpackAlignment = 4;\\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\\n\\n\\t\\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\\n\\t\\t//\\n\\t\\t// Also changing the encoding after already used by a Material will not automatically make the Material\\n\\t\\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\\n\\t\\tthis.encoding = encoding !== undefined ? encoding : LinearEncoding;\\n\\n\\t\\tthis.version = 0;\\n\\t\\tthis.onUpdate = null;\\n\\n\\t}\\n\\n\\tTexture.DEFAULT_IMAGE = undefined;\\n\\tTexture.DEFAULT_MAPPING = UVMapping;\\n\\n\\tTexture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\n\\n\\t\\tconstructor: Texture,\\n\\n\\t\\tisTexture: true,\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tthis.name = source.name;\\n\\n\\t\\t\\tthis.image = source.image;\\n\\t\\t\\tthis.mipmaps = source.mipmaps.slice( 0 );\\n\\n\\t\\t\\tthis.mapping = source.mapping;\\n\\n\\t\\t\\tthis.wrapS = source.wrapS;\\n\\t\\t\\tthis.wrapT = source.wrapT;\\n\\n\\t\\t\\tthis.magFilter = source.magFilter;\\n\\t\\t\\tthis.minFilter = source.minFilter;\\n\\n\\t\\t\\tthis.anisotropy = source.anisotropy;\\n\\n\\t\\t\\tthis.format = source.format;\\n\\t\\t\\tthis.type = source.type;\\n\\n\\t\\t\\tthis.offset.copy( source.offset );\\n\\t\\t\\tthis.repeat.copy( source.repeat );\\n\\t\\t\\tthis.center.copy( source.center );\\n\\t\\t\\tthis.rotation = source.rotation;\\n\\n\\t\\t\\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\\n\\t\\t\\tthis.matrix.copy( source.matrix );\\n\\n\\t\\t\\tthis.generateMipmaps = source.generateMipmaps;\\n\\t\\t\\tthis.premultiplyAlpha = source.premultiplyAlpha;\\n\\t\\t\\tthis.flipY = source.flipY;\\n\\t\\t\\tthis.unpackAlignment = source.unpackAlignment;\\n\\t\\t\\tthis.encoding = source.encoding;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( meta ) {\\n\\n\\t\\t\\tvar isRootObject = ( meta === undefined || typeof meta === 'string' );\\n\\n\\t\\t\\tif ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {\\n\\n\\t\\t\\t\\treturn meta.textures[ this.uuid ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction getDataURL( image ) {\\n\\n\\t\\t\\t\\tvar canvas;\\n\\n\\t\\t\\t\\tif ( image instanceof HTMLCanvasElement ) {\\n\\n\\t\\t\\t\\t\\tcanvas = image;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tcanvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\\n\\t\\t\\t\\t\\tcanvas.width = image.width;\\n\\t\\t\\t\\t\\tcanvas.height = image.height;\\n\\n\\t\\t\\t\\t\\tvar context = canvas.getContext( '2d' );\\n\\n\\t\\t\\t\\t\\tif ( image instanceof ImageData ) {\\n\\n\\t\\t\\t\\t\\t\\tcontext.putImageData( image, 0, 0 );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tcontext.drawImage( image, 0, 0, image.width, image.height );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\\n\\n\\t\\t\\t\\t\\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\treturn canvas.toDataURL( 'image/png' );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar output = {\\n\\t\\t\\t\\tmetadata: {\\n\\t\\t\\t\\t\\tversion: 4.5,\\n\\t\\t\\t\\t\\ttype: 'Texture',\\n\\t\\t\\t\\t\\tgenerator: 'Texture.toJSON'\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tuuid: this.uuid,\\n\\t\\t\\t\\tname: this.name,\\n\\n\\t\\t\\t\\tmapping: this.mapping,\\n\\n\\t\\t\\t\\trepeat: [ this.repeat.x, this.repeat.y ],\\n\\t\\t\\t\\toffset: [ this.offset.x, this.offset.y ],\\n\\t\\t\\t\\tcenter: [ this.center.x, this.center.y ],\\n\\t\\t\\t\\trotation: this.rotation,\\n\\n\\t\\t\\t\\twrap: [ this.wrapS, this.wrapT ],\\n\\n\\t\\t\\t\\tminFilter: this.minFilter,\\n\\t\\t\\t\\tmagFilter: this.magFilter,\\n\\t\\t\\t\\tanisotropy: this.anisotropy,\\n\\n\\t\\t\\t\\tflipY: this.flipY\\n\\t\\t\\t};\\n\\n\\t\\t\\tif ( this.image !== undefined ) {\\n\\n\\t\\t\\t\\t// TODO: Move to THREE.Image\\n\\n\\t\\t\\t\\tvar image = this.image;\\n\\n\\t\\t\\t\\tif ( image.uuid === undefined ) {\\n\\n\\t\\t\\t\\t\\timage.uuid = _Math.generateUUID(); // UGH\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {\\n\\n\\t\\t\\t\\t\\tmeta.images[ image.uuid ] = {\\n\\t\\t\\t\\t\\t\\tuuid: image.uuid,\\n\\t\\t\\t\\t\\t\\turl: getDataURL( image )\\n\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\toutput.image = image.uuid;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( ! isRootObject ) {\\n\\n\\t\\t\\t\\tmeta.textures[ this.uuid ] = output;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn output;\\n\\n\\t\\t},\\n\\n\\t\\tdispose: function () {\\n\\n\\t\\t\\tthis.dispatchEvent( { type: 'dispose' } );\\n\\n\\t\\t},\\n\\n\\t\\ttransformUv: function ( uv ) {\\n\\n\\t\\t\\tif ( this.mapping !== UVMapping ) return;\\n\\n\\t\\t\\tuv.applyMatrix3( this.matrix );\\n\\n\\t\\t\\tif ( uv.x < 0 || uv.x > 1 ) {\\n\\n\\t\\t\\t\\tswitch ( this.wrapS ) {\\n\\n\\t\\t\\t\\t\\tcase RepeatWrapping:\\n\\n\\t\\t\\t\\t\\t\\tuv.x = uv.x - Math.floor( uv.x );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase ClampToEdgeWrapping:\\n\\n\\t\\t\\t\\t\\t\\tuv.x = uv.x < 0 ? 0 : 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase MirroredRepeatWrapping:\\n\\n\\t\\t\\t\\t\\t\\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tuv.x = Math.ceil( uv.x ) - uv.x;\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tuv.x = uv.x - Math.floor( uv.x );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( uv.y < 0 || uv.y > 1 ) {\\n\\n\\t\\t\\t\\tswitch ( this.wrapT ) {\\n\\n\\t\\t\\t\\t\\tcase RepeatWrapping:\\n\\n\\t\\t\\t\\t\\t\\tuv.y = uv.y - Math.floor( uv.y );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase ClampToEdgeWrapping:\\n\\n\\t\\t\\t\\t\\t\\tuv.y = uv.y < 0 ? 0 : 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase MirroredRepeatWrapping:\\n\\n\\t\\t\\t\\t\\t\\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tuv.y = Math.ceil( uv.y ) - uv.y;\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tuv.y = uv.y - Math.floor( uv.y );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.flipY ) {\\n\\n\\t\\t\\t\\tuv.y = 1 - uv.y;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperty( Texture.prototype, \\\"needsUpdate\\\", {\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tif ( value === true ) this.version ++;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author supereggbert / http://www.paulbrunt.co.uk/\\n\\t * @author philogb / http://blog.thejit.org/\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author egraether / http://egraether.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction Vector4( x, y, z, w ) {\\n\\n\\t\\tthis.x = x || 0;\\n\\t\\tthis.y = y || 0;\\n\\t\\tthis.z = z || 0;\\n\\t\\tthis.w = ( w !== undefined ) ? w : 1;\\n\\n\\t}\\n\\n\\tObject.assign( Vector4.prototype, {\\n\\n\\t\\tisVector4: true,\\n\\n\\t\\tset: function ( x, y, z, w ) {\\n\\n\\t\\t\\tthis.x = x;\\n\\t\\t\\tthis.y = y;\\n\\t\\t\\tthis.z = z;\\n\\t\\t\\tthis.w = w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetScalar: function ( scalar ) {\\n\\n\\t\\t\\tthis.x = scalar;\\n\\t\\t\\tthis.y = scalar;\\n\\t\\t\\tthis.z = scalar;\\n\\t\\t\\tthis.w = scalar;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetX: function ( x ) {\\n\\n\\t\\t\\tthis.x = x;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetY: function ( y ) {\\n\\n\\t\\t\\tthis.y = y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetZ: function ( z ) {\\n\\n\\t\\t\\tthis.z = z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetW: function ( w ) {\\n\\n\\t\\t\\tthis.w = w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetComponent: function ( index, value ) {\\n\\n\\t\\t\\tswitch ( index ) {\\n\\n\\t\\t\\t\\tcase 0: this.x = value; break;\\n\\t\\t\\t\\tcase 1: this.y = value; break;\\n\\t\\t\\t\\tcase 2: this.z = value; break;\\n\\t\\t\\t\\tcase 3: this.w = value; break;\\n\\t\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetComponent: function ( index ) {\\n\\n\\t\\t\\tswitch ( index ) {\\n\\n\\t\\t\\t\\tcase 0: return this.x;\\n\\t\\t\\t\\tcase 1: return this.y;\\n\\t\\t\\t\\tcase 2: return this.z;\\n\\t\\t\\t\\tcase 3: return this.w;\\n\\t\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.x, this.y, this.z, this.w );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( v ) {\\n\\n\\t\\t\\tthis.x = v.x;\\n\\t\\t\\tthis.y = v.y;\\n\\t\\t\\tthis.z = v.z;\\n\\t\\t\\tthis.w = ( v.w !== undefined ) ? v.w : 1;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tadd: function ( v, w ) {\\n\\n\\t\\t\\tif ( w !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.addVectors( v, w );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x += v.x;\\n\\t\\t\\tthis.y += v.y;\\n\\t\\t\\tthis.z += v.z;\\n\\t\\t\\tthis.w += v.w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddScalar: function ( s ) {\\n\\n\\t\\t\\tthis.x += s;\\n\\t\\t\\tthis.y += s;\\n\\t\\t\\tthis.z += s;\\n\\t\\t\\tthis.w += s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddVectors: function ( a, b ) {\\n\\n\\t\\t\\tthis.x = a.x + b.x;\\n\\t\\t\\tthis.y = a.y + b.y;\\n\\t\\t\\tthis.z = a.z + b.z;\\n\\t\\t\\tthis.w = a.w + b.w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddScaledVector: function ( v, s ) {\\n\\n\\t\\t\\tthis.x += v.x * s;\\n\\t\\t\\tthis.y += v.y * s;\\n\\t\\t\\tthis.z += v.z * s;\\n\\t\\t\\tthis.w += v.w * s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsub: function ( v, w ) {\\n\\n\\t\\t\\tif ( w !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.subVectors( v, w );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x -= v.x;\\n\\t\\t\\tthis.y -= v.y;\\n\\t\\t\\tthis.z -= v.z;\\n\\t\\t\\tthis.w -= v.w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsubScalar: function ( s ) {\\n\\n\\t\\t\\tthis.x -= s;\\n\\t\\t\\tthis.y -= s;\\n\\t\\t\\tthis.z -= s;\\n\\t\\t\\tthis.w -= s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsubVectors: function ( a, b ) {\\n\\n\\t\\t\\tthis.x = a.x - b.x;\\n\\t\\t\\tthis.y = a.y - b.y;\\n\\t\\t\\tthis.z = a.z - b.z;\\n\\t\\t\\tthis.w = a.w - b.w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyScalar: function ( scalar ) {\\n\\n\\t\\t\\tthis.x *= scalar;\\n\\t\\t\\tthis.y *= scalar;\\n\\t\\t\\tthis.z *= scalar;\\n\\t\\t\\tthis.w *= scalar;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tapplyMatrix4: function ( m ) {\\n\\n\\t\\t\\tvar x = this.x, y = this.y, z = this.z, w = this.w;\\n\\t\\t\\tvar e = m.elements;\\n\\n\\t\\t\\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\\n\\t\\t\\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\\n\\t\\t\\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\\n\\t\\t\\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdivideScalar: function ( scalar ) {\\n\\n\\t\\t\\treturn this.multiplyScalar( 1 / scalar );\\n\\n\\t\\t},\\n\\n\\t\\tsetAxisAngleFromQuaternion: function ( q ) {\\n\\n\\t\\t\\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\\n\\n\\t\\t\\t// q is assumed to be normalized\\n\\n\\t\\t\\tthis.w = 2 * Math.acos( q.w );\\n\\n\\t\\t\\tvar s = Math.sqrt( 1 - q.w * q.w );\\n\\n\\t\\t\\tif ( s < 0.0001 ) {\\n\\n\\t\\t\\t\\tthis.x = 1;\\n\\t\\t\\t\\tthis.y = 0;\\n\\t\\t\\t\\tthis.z = 0;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.x = q.x / s;\\n\\t\\t\\t\\tthis.y = q.y / s;\\n\\t\\t\\t\\tthis.z = q.z / s;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetAxisAngleFromRotationMatrix: function ( m ) {\\n\\n\\t\\t\\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\\n\\n\\t\\t\\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\\n\\n\\t\\t\\tvar angle, x, y, z,\\t\\t// variables for result\\n\\t\\t\\t\\tepsilon = 0.01,\\t\\t// margin to allow for rounding errors\\n\\t\\t\\t\\tepsilon2 = 0.1,\\t\\t// margin to distinguish between 0 and 180 degrees\\n\\n\\t\\t\\t\\tte = m.elements,\\n\\n\\t\\t\\t\\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\\n\\t\\t\\t\\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\\n\\t\\t\\t\\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\\n\\n\\t\\t\\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\\n\\t\\t\\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\\n\\t\\t\\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\\n\\n\\t\\t\\t\\t// singularity found\\n\\t\\t\\t\\t// first check for identity matrix which must have +1 for all terms\\n\\t\\t\\t\\t// in leading diagonal and zero in other terms\\n\\n\\t\\t\\t\\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\\n\\t\\t\\t\\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\\n\\t\\t\\t\\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\\n\\t\\t\\t\\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\\n\\n\\t\\t\\t\\t\\t// this singularity is identity matrix so angle = 0\\n\\n\\t\\t\\t\\t\\tthis.set( 1, 0, 0, 0 );\\n\\n\\t\\t\\t\\t\\treturn this; // zero angle, arbitrary axis\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// otherwise this singularity is angle = 180\\n\\n\\t\\t\\t\\tangle = Math.PI;\\n\\n\\t\\t\\t\\tvar xx = ( m11 + 1 ) / 2;\\n\\t\\t\\t\\tvar yy = ( m22 + 1 ) / 2;\\n\\t\\t\\t\\tvar zz = ( m33 + 1 ) / 2;\\n\\t\\t\\t\\tvar xy = ( m12 + m21 ) / 4;\\n\\t\\t\\t\\tvar xz = ( m13 + m31 ) / 4;\\n\\t\\t\\t\\tvar yz = ( m23 + m32 ) / 4;\\n\\n\\t\\t\\t\\tif ( ( xx > yy ) && ( xx > zz ) ) {\\n\\n\\t\\t\\t\\t\\t// m11 is the largest diagonal term\\n\\n\\t\\t\\t\\t\\tif ( xx < epsilon ) {\\n\\n\\t\\t\\t\\t\\t\\tx = 0;\\n\\t\\t\\t\\t\\t\\ty = 0.707106781;\\n\\t\\t\\t\\t\\t\\tz = 0.707106781;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tx = Math.sqrt( xx );\\n\\t\\t\\t\\t\\t\\ty = xy / x;\\n\\t\\t\\t\\t\\t\\tz = xz / x;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( yy > zz ) {\\n\\n\\t\\t\\t\\t\\t// m22 is the largest diagonal term\\n\\n\\t\\t\\t\\t\\tif ( yy < epsilon ) {\\n\\n\\t\\t\\t\\t\\t\\tx = 0.707106781;\\n\\t\\t\\t\\t\\t\\ty = 0;\\n\\t\\t\\t\\t\\t\\tz = 0.707106781;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\ty = Math.sqrt( yy );\\n\\t\\t\\t\\t\\t\\tx = xy / y;\\n\\t\\t\\t\\t\\t\\tz = yz / y;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// m33 is the largest diagonal term so base result on this\\n\\n\\t\\t\\t\\t\\tif ( zz < epsilon ) {\\n\\n\\t\\t\\t\\t\\t\\tx = 0.707106781;\\n\\t\\t\\t\\t\\t\\ty = 0.707106781;\\n\\t\\t\\t\\t\\t\\tz = 0;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tz = Math.sqrt( zz );\\n\\t\\t\\t\\t\\t\\tx = xz / z;\\n\\t\\t\\t\\t\\t\\ty = yz / z;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.set( x, y, z, angle );\\n\\n\\t\\t\\t\\treturn this; // return 180 deg rotation\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// as we have reached here there are no singularities so we can handle normally\\n\\n\\t\\t\\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\\n\\t\\t\\t                   ( m13 - m31 ) * ( m13 - m31 ) +\\n\\t\\t\\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\\n\\n\\t\\t\\tif ( Math.abs( s ) < 0.001 ) s = 1;\\n\\n\\t\\t\\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\\n\\t\\t\\t// caught by singularity test above, but I've left it in just in case\\n\\n\\t\\t\\tthis.x = ( m32 - m23 ) / s;\\n\\t\\t\\tthis.y = ( m13 - m31 ) / s;\\n\\t\\t\\tthis.z = ( m21 - m12 ) / s;\\n\\t\\t\\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmin: function ( v ) {\\n\\n\\t\\t\\tthis.x = Math.min( this.x, v.x );\\n\\t\\t\\tthis.y = Math.min( this.y, v.y );\\n\\t\\t\\tthis.z = Math.min( this.z, v.z );\\n\\t\\t\\tthis.w = Math.min( this.w, v.w );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmax: function ( v ) {\\n\\n\\t\\t\\tthis.x = Math.max( this.x, v.x );\\n\\t\\t\\tthis.y = Math.max( this.y, v.y );\\n\\t\\t\\tthis.z = Math.max( this.z, v.z );\\n\\t\\t\\tthis.w = Math.max( this.w, v.w );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclamp: function ( min, max ) {\\n\\n\\t\\t\\t// assumes min < max, componentwise\\n\\n\\t\\t\\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\\n\\t\\t\\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\\n\\t\\t\\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\\n\\t\\t\\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclampScalar: function () {\\n\\n\\t\\t\\tvar min, max;\\n\\n\\t\\t\\treturn function clampScalar( minVal, maxVal ) {\\n\\n\\t\\t\\t\\tif ( min === undefined ) {\\n\\n\\t\\t\\t\\t\\tmin = new Vector4();\\n\\t\\t\\t\\t\\tmax = new Vector4();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tmin.set( minVal, minVal, minVal, minVal );\\n\\t\\t\\t\\tmax.set( maxVal, maxVal, maxVal, maxVal );\\n\\n\\t\\t\\t\\treturn this.clamp( min, max );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tclampLength: function ( min, max ) {\\n\\n\\t\\t\\tvar length = this.length();\\n\\n\\t\\t\\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\\n\\n\\t\\t},\\n\\n\\t\\tfloor: function () {\\n\\n\\t\\t\\tthis.x = Math.floor( this.x );\\n\\t\\t\\tthis.y = Math.floor( this.y );\\n\\t\\t\\tthis.z = Math.floor( this.z );\\n\\t\\t\\tthis.w = Math.floor( this.w );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tceil: function () {\\n\\n\\t\\t\\tthis.x = Math.ceil( this.x );\\n\\t\\t\\tthis.y = Math.ceil( this.y );\\n\\t\\t\\tthis.z = Math.ceil( this.z );\\n\\t\\t\\tthis.w = Math.ceil( this.w );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tround: function () {\\n\\n\\t\\t\\tthis.x = Math.round( this.x );\\n\\t\\t\\tthis.y = Math.round( this.y );\\n\\t\\t\\tthis.z = Math.round( this.z );\\n\\t\\t\\tthis.w = Math.round( this.w );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\troundToZero: function () {\\n\\n\\t\\t\\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\\n\\t\\t\\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\\n\\t\\t\\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\\n\\t\\t\\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tnegate: function () {\\n\\n\\t\\t\\tthis.x = - this.x;\\n\\t\\t\\tthis.y = - this.y;\\n\\t\\t\\tthis.z = - this.z;\\n\\t\\t\\tthis.w = - this.w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdot: function ( v ) {\\n\\n\\t\\t\\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\\n\\n\\t\\t},\\n\\n\\t\\tlengthSq: function () {\\n\\n\\t\\t\\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\\n\\n\\t\\t},\\n\\n\\t\\tlength: function () {\\n\\n\\t\\t\\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\\n\\n\\t\\t},\\n\\n\\t\\tmanhattanLength: function () {\\n\\n\\t\\t\\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\\n\\n\\t\\t},\\n\\n\\t\\tnormalize: function () {\\n\\n\\t\\t\\treturn this.divideScalar( this.length() || 1 );\\n\\n\\t\\t},\\n\\n\\t\\tsetLength: function ( length ) {\\n\\n\\t\\t\\treturn this.normalize().multiplyScalar( length );\\n\\n\\t\\t},\\n\\n\\t\\tlerp: function ( v, alpha ) {\\n\\n\\t\\t\\tthis.x += ( v.x - this.x ) * alpha;\\n\\t\\t\\tthis.y += ( v.y - this.y ) * alpha;\\n\\t\\t\\tthis.z += ( v.z - this.z ) * alpha;\\n\\t\\t\\tthis.w += ( v.w - this.w ) * alpha;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tlerpVectors: function ( v1, v2, alpha ) {\\n\\n\\t\\t\\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( v ) {\\n\\n\\t\\t\\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\\n\\n\\t\\t},\\n\\n\\t\\tfromArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tthis.x = array[ offset ];\\n\\t\\t\\tthis.y = array[ offset + 1 ];\\n\\t\\t\\tthis.z = array[ offset + 2 ];\\n\\t\\t\\tthis.w = array[ offset + 3 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( array === undefined ) array = [];\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tarray[ offset ] = this.x;\\n\\t\\t\\tarray[ offset + 1 ] = this.y;\\n\\t\\t\\tarray[ offset + 2 ] = this.z;\\n\\t\\t\\tarray[ offset + 3 ] = this.w;\\n\\n\\t\\t\\treturn array;\\n\\n\\t\\t},\\n\\n\\t\\tfromBufferAttribute: function ( attribute, index, offset ) {\\n\\n\\t\\t\\tif ( offset !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x = attribute.getX( index );\\n\\t\\t\\tthis.y = attribute.getY( index );\\n\\t\\t\\tthis.z = attribute.getZ( index );\\n\\t\\t\\tthis.w = attribute.getW( index );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author szimek / https://github.com/szimek/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author Marius Kintel / https://github.com/kintel\\n\\t */\\n\\n\\t/*\\n\\t In options, we can specify:\\n\\t * Texture parameters for an auto-generated target texture\\n\\t * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\\n\\t*/\\n\\tfunction WebGLRenderTarget( width, height, options ) {\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\tthis.width = width;\\n\\t\\tthis.height = height;\\n\\n\\t\\tthis.scissor = new Vector4( 0, 0, width, height );\\n\\t\\tthis.scissorTest = false;\\n\\n\\t\\tthis.viewport = new Vector4( 0, 0, width, height );\\n\\n\\t\\toptions = options || {};\\n\\n\\t\\tif ( options.minFilter === undefined ) options.minFilter = LinearFilter;\\n\\n\\t\\tthis.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\\n\\n\\t\\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\\n\\t\\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\\n\\t\\tthis.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;\\n\\n\\t}\\n\\n\\tWebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\n\\n\\t\\tconstructor: WebGLRenderTarget,\\n\\n\\t\\tisWebGLRenderTarget: true,\\n\\n\\t\\tsetSize: function ( width, height ) {\\n\\n\\t\\t\\tif ( this.width !== width || this.height !== height ) {\\n\\n\\t\\t\\t\\tthis.width = width;\\n\\t\\t\\t\\tthis.height = height;\\n\\n\\t\\t\\t\\tthis.dispose();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.viewport.set( 0, 0, width, height );\\n\\t\\t\\tthis.scissor.set( 0, 0, width, height );\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tthis.width = source.width;\\n\\t\\t\\tthis.height = source.height;\\n\\n\\t\\t\\tthis.viewport.copy( source.viewport );\\n\\n\\t\\t\\tthis.texture = source.texture.clone();\\n\\n\\t\\t\\tthis.depthBuffer = source.depthBuffer;\\n\\t\\t\\tthis.stencilBuffer = source.stencilBuffer;\\n\\t\\t\\tthis.depthTexture = source.depthTexture;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdispose: function () {\\n\\n\\t\\t\\tthis.dispatchEvent( { type: 'dispose' } );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com\\n\\t */\\n\\n\\tfunction WebGLRenderTargetCube( width, height, options ) {\\n\\n\\t\\tWebGLRenderTarget.call( this, width, height, options );\\n\\n\\t\\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\\n\\t\\tthis.activeMipMapLevel = 0;\\n\\n\\t}\\n\\n\\tWebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );\\n\\tWebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;\\n\\n\\tWebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\\n\\n\\t\\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\\n\\n\\t\\tthis.image = { data: data, width: width, height: height };\\n\\n\\t\\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\\n\\t\\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\\n\\n\\t\\tthis.generateMipmaps = false;\\n\\t\\tthis.flipY = false;\\n\\t\\tthis.unpackAlignment = 1;\\n\\n\\t}\\n\\n\\tDataTexture.prototype = Object.create( Texture.prototype );\\n\\tDataTexture.prototype.constructor = DataTexture;\\n\\n\\tDataTexture.prototype.isDataTexture = true;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\\n\\n\\t\\timages = images !== undefined ? images : [];\\n\\t\\tmapping = mapping !== undefined ? mapping : CubeReflectionMapping;\\n\\n\\t\\tTexture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\\n\\n\\t\\tthis.flipY = false;\\n\\n\\t}\\n\\n\\tCubeTexture.prototype = Object.create( Texture.prototype );\\n\\tCubeTexture.prototype.constructor = CubeTexture;\\n\\n\\tCubeTexture.prototype.isCubeTexture = true;\\n\\n\\tObject.defineProperty( CubeTexture.prototype, 'images', {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\treturn this.image;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tthis.image = value;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author tschw\\n\\t *\\n\\t * Uniforms of a program.\\n\\t * Those form a tree structure with a special top-level container for the root,\\n\\t * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.\\n\\t *\\n\\t *\\n\\t * Properties of inner nodes including the top-level container:\\n\\t *\\n\\t * .seq - array of nested uniforms\\n\\t * .map - nested uniforms by name\\n\\t *\\n\\t *\\n\\t * Methods of all nodes except the top-level container:\\n\\t *\\n\\t * .setValue( gl, value, [renderer] )\\n\\t *\\n\\t * \\t\\tuploads a uniform value(s)\\n\\t *  \\tthe 'renderer' parameter is needed for sampler uniforms\\n\\t *\\n\\t *\\n\\t * Static methods of the top-level container (renderer factorizations):\\n\\t *\\n\\t * .upload( gl, seq, values, renderer )\\n\\t *\\n\\t * \\t\\tsets uniforms in 'seq' to 'values[id].value'\\n\\t *\\n\\t * .seqWithValue( seq, values ) : filteredSeq\\n\\t *\\n\\t * \\t\\tfilters 'seq' entries with corresponding entry in values\\n\\t *\\n\\t *\\n\\t * Methods of the top-level container (renderer factorizations):\\n\\t *\\n\\t * .setValue( gl, name, value )\\n\\t *\\n\\t * \\t\\tsets uniform with  name 'name' to 'value'\\n\\t *\\n\\t * .set( gl, obj, prop )\\n\\t *\\n\\t * \\t\\tsets uniform from object and property with same name than uniform\\n\\t *\\n\\t * .setOptional( gl, obj, prop )\\n\\t *\\n\\t * \\t\\tlike .set for an optional property of the object\\n\\t *\\n\\t */\\n\\n\\tvar emptyTexture = new Texture();\\n\\tvar emptyCubeTexture = new CubeTexture();\\n\\n\\t// --- Base for inner nodes (including the root) ---\\n\\n\\tfunction UniformContainer() {\\n\\n\\t\\tthis.seq = [];\\n\\t\\tthis.map = {};\\n\\n\\t}\\n\\n\\t// --- Utilities ---\\n\\n\\t// Array Caches (provide typed arrays for temporary by size)\\n\\n\\tvar arrayCacheF32 = [];\\n\\tvar arrayCacheI32 = [];\\n\\n\\t// Float32Array caches used for uploading Matrix uniforms\\n\\n\\tvar mat4array = new Float32Array( 16 );\\n\\tvar mat3array = new Float32Array( 9 );\\n\\n\\t// Flattening for arrays of vectors and matrices\\n\\n\\tfunction flatten( array, nBlocks, blockSize ) {\\n\\n\\t\\tvar firstElem = array[ 0 ];\\n\\n\\t\\tif ( firstElem <= 0 || firstElem > 0 ) return array;\\n\\t\\t// unoptimized: ! isNaN( firstElem )\\n\\t\\t// see http://jacksondunstan.com/articles/983\\n\\n\\t\\tvar n = nBlocks * blockSize,\\n\\t\\t\\tr = arrayCacheF32[ n ];\\n\\n\\t\\tif ( r === undefined ) {\\n\\n\\t\\t\\tr = new Float32Array( n );\\n\\t\\t\\tarrayCacheF32[ n ] = r;\\n\\n\\t\\t}\\n\\n\\t\\tif ( nBlocks !== 0 ) {\\n\\n\\t\\t\\tfirstElem.toArray( r, 0 );\\n\\n\\t\\t\\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\\n\\n\\t\\t\\t\\toffset += blockSize;\\n\\t\\t\\t\\tarray[ i ].toArray( r, offset );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn r;\\n\\n\\t}\\n\\n\\t// Texture unit allocation\\n\\n\\tfunction allocTexUnits( renderer, n ) {\\n\\n\\t\\tvar r = arrayCacheI32[ n ];\\n\\n\\t\\tif ( r === undefined ) {\\n\\n\\t\\t\\tr = new Int32Array( n );\\n\\t\\t\\tarrayCacheI32[ n ] = r;\\n\\n\\t\\t}\\n\\n\\t\\tfor ( var i = 0; i !== n; ++ i )\\n\\t\\t\\tr[ i ] = renderer.allocTextureUnit();\\n\\n\\t\\treturn r;\\n\\n\\t}\\n\\n\\t// --- Setters ---\\n\\n\\t// Note: Defining these methods externally, because they come in a bunch\\n\\t// and this way their names minify.\\n\\n\\t// Single scalar\\n\\n\\tfunction setValue1f( gl, v ) {\\n\\n\\t\\tgl.uniform1f( this.addr, v );\\n\\n\\t}\\n\\n\\tfunction setValue1i( gl, v ) {\\n\\n\\t\\tgl.uniform1i( this.addr, v );\\n\\n\\t}\\n\\n\\t// Single float vector (from flat array or THREE.VectorN)\\n\\n\\tfunction setValue2fv( gl, v ) {\\n\\n\\t\\tif ( v.x === undefined ) {\\n\\n\\t\\t\\tgl.uniform2fv( this.addr, v );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tgl.uniform2f( this.addr, v.x, v.y );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction setValue3fv( gl, v ) {\\n\\n\\t\\tif ( v.x !== undefined ) {\\n\\n\\t\\t\\tgl.uniform3f( this.addr, v.x, v.y, v.z );\\n\\n\\t\\t} else if ( v.r !== undefined ) {\\n\\n\\t\\t\\tgl.uniform3f( this.addr, v.r, v.g, v.b );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tgl.uniform3fv( this.addr, v );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction setValue4fv( gl, v ) {\\n\\n\\t\\tif ( v.x === undefined ) {\\n\\n\\t\\t\\tgl.uniform4fv( this.addr, v );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// Single matrix (from flat array or MatrixN)\\n\\n\\tfunction setValue2fm( gl, v ) {\\n\\n\\t\\tgl.uniformMatrix2fv( this.addr, false, v.elements || v );\\n\\n\\t}\\n\\n\\tfunction setValue3fm( gl, v ) {\\n\\n\\t\\tif ( v.elements === undefined ) {\\n\\n\\t\\t\\tgl.uniformMatrix3fv( this.addr, false, v );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tmat3array.set( v.elements );\\n\\t\\t\\tgl.uniformMatrix3fv( this.addr, false, mat3array );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction setValue4fm( gl, v ) {\\n\\n\\t\\tif ( v.elements === undefined ) {\\n\\n\\t\\t\\tgl.uniformMatrix4fv( this.addr, false, v );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tmat4array.set( v.elements );\\n\\t\\t\\tgl.uniformMatrix4fv( this.addr, false, mat4array );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// Single texture (2D / Cube)\\n\\n\\tfunction setValueT1( gl, v, renderer ) {\\n\\n\\t\\tvar unit = renderer.allocTextureUnit();\\n\\t\\tgl.uniform1i( this.addr, unit );\\n\\t\\trenderer.setTexture2D( v || emptyTexture, unit );\\n\\n\\t}\\n\\n\\tfunction setValueT6( gl, v, renderer ) {\\n\\n\\t\\tvar unit = renderer.allocTextureUnit();\\n\\t\\tgl.uniform1i( this.addr, unit );\\n\\t\\trenderer.setTextureCube( v || emptyCubeTexture, unit );\\n\\n\\t}\\n\\n\\t// Integer / Boolean vectors or arrays thereof (always flat arrays)\\n\\n\\tfunction setValue2iv( gl, v ) {\\n\\n\\t\\tgl.uniform2iv( this.addr, v );\\n\\n\\t}\\n\\n\\tfunction setValue3iv( gl, v ) {\\n\\n\\t\\tgl.uniform3iv( this.addr, v );\\n\\n\\t}\\n\\n\\tfunction setValue4iv( gl, v ) {\\n\\n\\t\\tgl.uniform4iv( this.addr, v );\\n\\n\\t}\\n\\n\\t// Helper to pick the right setter for the singular case\\n\\n\\tfunction getSingularSetter( type ) {\\n\\n\\t\\tswitch ( type ) {\\n\\n\\t\\t\\tcase 0x1406: return setValue1f; // FLOAT\\n\\t\\t\\tcase 0x8b50: return setValue2fv; // _VEC2\\n\\t\\t\\tcase 0x8b51: return setValue3fv; // _VEC3\\n\\t\\t\\tcase 0x8b52: return setValue4fv; // _VEC4\\n\\n\\t\\t\\tcase 0x8b5a: return setValue2fm; // _MAT2\\n\\t\\t\\tcase 0x8b5b: return setValue3fm; // _MAT3\\n\\t\\t\\tcase 0x8b5c: return setValue4fm; // _MAT4\\n\\n\\t\\t\\tcase 0x8b5e: case 0x8d66: return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES\\n\\t\\t\\tcase 0x8b60: return setValueT6; // SAMPLER_CUBE\\n\\n\\t\\t\\tcase 0x1404: case 0x8b56: return setValue1i; // INT, BOOL\\n\\t\\t\\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\\n\\t\\t\\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\\n\\t\\t\\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// Array of scalars\\n\\n\\tfunction setValue1fv( gl, v ) {\\n\\n\\t\\tgl.uniform1fv( this.addr, v );\\n\\n\\t}\\n\\tfunction setValue1iv( gl, v ) {\\n\\n\\t\\tgl.uniform1iv( this.addr, v );\\n\\n\\t}\\n\\n\\t// Array of vectors (flat or from THREE classes)\\n\\n\\tfunction setValueV2a( gl, v ) {\\n\\n\\t\\tgl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );\\n\\n\\t}\\n\\n\\tfunction setValueV3a( gl, v ) {\\n\\n\\t\\tgl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );\\n\\n\\t}\\n\\n\\tfunction setValueV4a( gl, v ) {\\n\\n\\t\\tgl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );\\n\\n\\t}\\n\\n\\t// Array of matrices (flat or from THREE clases)\\n\\n\\tfunction setValueM2a( gl, v ) {\\n\\n\\t\\tgl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );\\n\\n\\t}\\n\\n\\tfunction setValueM3a( gl, v ) {\\n\\n\\t\\tgl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );\\n\\n\\t}\\n\\n\\tfunction setValueM4a( gl, v ) {\\n\\n\\t\\tgl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );\\n\\n\\t}\\n\\n\\t// Array of textures (2D / Cube)\\n\\n\\tfunction setValueT1a( gl, v, renderer ) {\\n\\n\\t\\tvar n = v.length,\\n\\t\\t\\tunits = allocTexUnits( renderer, n );\\n\\n\\t\\tgl.uniform1iv( this.addr, units );\\n\\n\\t\\tfor ( var i = 0; i !== n; ++ i ) {\\n\\n\\t\\t\\trenderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction setValueT6a( gl, v, renderer ) {\\n\\n\\t\\tvar n = v.length,\\n\\t\\t\\tunits = allocTexUnits( renderer, n );\\n\\n\\t\\tgl.uniform1iv( this.addr, units );\\n\\n\\t\\tfor ( var i = 0; i !== n; ++ i ) {\\n\\n\\t\\t\\trenderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// Helper to pick the right setter for a pure (bottom-level) array\\n\\n\\tfunction getPureArraySetter( type ) {\\n\\n\\t\\tswitch ( type ) {\\n\\n\\t\\t\\tcase 0x1406: return setValue1fv; // FLOAT\\n\\t\\t\\tcase 0x8b50: return setValueV2a; // _VEC2\\n\\t\\t\\tcase 0x8b51: return setValueV3a; // _VEC3\\n\\t\\t\\tcase 0x8b52: return setValueV4a; // _VEC4\\n\\n\\t\\t\\tcase 0x8b5a: return setValueM2a; // _MAT2\\n\\t\\t\\tcase 0x8b5b: return setValueM3a; // _MAT3\\n\\t\\t\\tcase 0x8b5c: return setValueM4a; // _MAT4\\n\\n\\t\\t\\tcase 0x8b5e: return setValueT1a; // SAMPLER_2D\\n\\t\\t\\tcase 0x8b60: return setValueT6a; // SAMPLER_CUBE\\n\\n\\t\\t\\tcase 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL\\n\\t\\t\\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\\n\\t\\t\\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\\n\\t\\t\\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// --- Uniform Classes ---\\n\\n\\tfunction SingleUniform( id, activeInfo, addr ) {\\n\\n\\t\\tthis.id = id;\\n\\t\\tthis.addr = addr;\\n\\t\\tthis.setValue = getSingularSetter( activeInfo.type );\\n\\n\\t\\t// this.path = activeInfo.name; // DEBUG\\n\\n\\t}\\n\\n\\tfunction PureArrayUniform( id, activeInfo, addr ) {\\n\\n\\t\\tthis.id = id;\\n\\t\\tthis.addr = addr;\\n\\t\\tthis.size = activeInfo.size;\\n\\t\\tthis.setValue = getPureArraySetter( activeInfo.type );\\n\\n\\t\\t// this.path = activeInfo.name; // DEBUG\\n\\n\\t}\\n\\n\\tfunction StructuredUniform( id ) {\\n\\n\\t\\tthis.id = id;\\n\\n\\t\\tUniformContainer.call( this ); // mix-in\\n\\n\\t}\\n\\n\\tStructuredUniform.prototype.setValue = function ( gl, value ) {\\n\\n\\t\\t// Note: Don't need an extra 'renderer' parameter, since samplers\\n\\t\\t// are not allowed in structured uniforms.\\n\\n\\t\\tvar seq = this.seq;\\n\\n\\t\\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\\n\\n\\t\\t\\tvar u = seq[ i ];\\n\\t\\t\\tu.setValue( gl, value[ u.id ] );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t// --- Top-level ---\\n\\n\\t// Parser - builds up the property tree from the path strings\\n\\n\\tvar RePathPart = /([\\\\w\\\\d_]+)(\\\\])?(\\\\[|\\\\.)?/g;\\n\\n\\t// extracts\\n\\t// \\t- the identifier (member name or array index)\\n\\t//  - followed by an optional right bracket (found when array index)\\n\\t//  - followed by an optional left bracket or dot (type of subscript)\\n\\t//\\n\\t// Note: These portions can be read in a non-overlapping fashion and\\n\\t// allow straightforward parsing of the hierarchy that WebGL encodes\\n\\t// in the uniform names.\\n\\n\\tfunction addUniform( container, uniformObject ) {\\n\\n\\t\\tcontainer.seq.push( uniformObject );\\n\\t\\tcontainer.map[ uniformObject.id ] = uniformObject;\\n\\n\\t}\\n\\n\\tfunction parseUniform( activeInfo, addr, container ) {\\n\\n\\t\\tvar path = activeInfo.name,\\n\\t\\t\\tpathLength = path.length;\\n\\n\\t\\t// reset RegExp object, because of the early exit of a previous run\\n\\t\\tRePathPart.lastIndex = 0;\\n\\n\\t\\tfor ( ; ; ) {\\n\\n\\t\\t\\tvar match = RePathPart.exec( path ),\\n\\t\\t\\t\\tmatchEnd = RePathPart.lastIndex,\\n\\n\\t\\t\\t\\tid = match[ 1 ],\\n\\t\\t\\t\\tidIsIndex = match[ 2 ] === ']',\\n\\t\\t\\t\\tsubscript = match[ 3 ];\\n\\n\\t\\t\\tif ( idIsIndex ) id = id | 0; // convert to integer\\n\\n\\t\\t\\tif ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {\\n\\n\\t\\t\\t\\t// bare name or \\\"pure\\\" bottom-level array \\\"[0]\\\" suffix\\n\\n\\t\\t\\t\\taddUniform( container, subscript === undefined ?\\n\\t\\t\\t\\t\\tnew SingleUniform( id, activeInfo, addr ) :\\n\\t\\t\\t\\t\\tnew PureArrayUniform( id, activeInfo, addr ) );\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// step into inner node / create it in case it doesn't exist\\n\\n\\t\\t\\t\\tvar map = container.map, next = map[ id ];\\n\\n\\t\\t\\t\\tif ( next === undefined ) {\\n\\n\\t\\t\\t\\t\\tnext = new StructuredUniform( id );\\n\\t\\t\\t\\t\\taddUniform( container, next );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcontainer = next;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// Root Container\\n\\n\\tfunction WebGLUniforms( gl, program, renderer ) {\\n\\n\\t\\tUniformContainer.call( this );\\n\\n\\t\\tthis.renderer = renderer;\\n\\n\\t\\tvar n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\\n\\n\\t\\tfor ( var i = 0; i < n; ++ i ) {\\n\\n\\t\\t\\tvar info = gl.getActiveUniform( program, i ),\\n\\t\\t\\t\\tpath = info.name,\\n\\t\\t\\t\\taddr = gl.getUniformLocation( program, path );\\n\\n\\t\\t\\tparseUniform( info, addr, this );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tWebGLUniforms.prototype.setValue = function ( gl, name, value ) {\\n\\n\\t\\tvar u = this.map[ name ];\\n\\n\\t\\tif ( u !== undefined ) u.setValue( gl, value, this.renderer );\\n\\n\\t};\\n\\n\\tWebGLUniforms.prototype.setOptional = function ( gl, object, name ) {\\n\\n\\t\\tvar v = object[ name ];\\n\\n\\t\\tif ( v !== undefined ) this.setValue( gl, name, v );\\n\\n\\t};\\n\\n\\n\\t// Static interface\\n\\n\\tWebGLUniforms.upload = function ( gl, seq, values, renderer ) {\\n\\n\\t\\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\\n\\n\\t\\t\\tvar u = seq[ i ],\\n\\t\\t\\t\\tv = values[ u.id ];\\n\\n\\t\\t\\tif ( v.needsUpdate !== false ) {\\n\\n\\t\\t\\t\\t// note: always updating when .needsUpdate is undefined\\n\\t\\t\\t\\tu.setValue( gl, v.value, renderer );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tWebGLUniforms.seqWithValue = function ( seq, values ) {\\n\\n\\t\\tvar r = [];\\n\\n\\t\\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\\n\\n\\t\\t\\tvar u = seq[ i ];\\n\\t\\t\\tif ( u.id in values ) r.push( u );\\n\\n\\t\\t}\\n\\n\\t\\treturn r;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tvar ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\\n\\t\\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\\n\\t\\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\\n\\t\\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\\n\\t\\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\\n\\t\\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\\n\\t\\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\\n\\t\\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\\n\\t\\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\\n\\t\\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\\n\\t\\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\\n\\t\\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\\n\\t\\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\\n\\t\\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\\n\\t\\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\\n\\t\\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\\n\\t\\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\\n\\t\\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\\n\\t\\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\\n\\t\\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\\n\\t\\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\\n\\t\\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\\n\\t\\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\\n\\t\\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\\n\\n\\tfunction Color( r, g, b ) {\\n\\n\\t\\tif ( g === undefined && b === undefined ) {\\n\\n\\t\\t\\t// r is THREE.Color, hex or string\\n\\t\\t\\treturn this.set( r );\\n\\n\\t\\t}\\n\\n\\t\\treturn this.setRGB( r, g, b );\\n\\n\\t}\\n\\n\\tObject.assign( Color.prototype, {\\n\\n\\t\\tisColor: true,\\n\\n\\t\\tr: 1, g: 1, b: 1,\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tif ( value && value.isColor ) {\\n\\n\\t\\t\\t\\tthis.copy( value );\\n\\n\\t\\t\\t} else if ( typeof value === 'number' ) {\\n\\n\\t\\t\\t\\tthis.setHex( value );\\n\\n\\t\\t\\t} else if ( typeof value === 'string' ) {\\n\\n\\t\\t\\t\\tthis.setStyle( value );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetScalar: function ( scalar ) {\\n\\n\\t\\t\\tthis.r = scalar;\\n\\t\\t\\tthis.g = scalar;\\n\\t\\t\\tthis.b = scalar;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetHex: function ( hex ) {\\n\\n\\t\\t\\thex = Math.floor( hex );\\n\\n\\t\\t\\tthis.r = ( hex >> 16 & 255 ) / 255;\\n\\t\\t\\tthis.g = ( hex >> 8 & 255 ) / 255;\\n\\t\\t\\tthis.b = ( hex & 255 ) / 255;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetRGB: function ( r, g, b ) {\\n\\n\\t\\t\\tthis.r = r;\\n\\t\\t\\tthis.g = g;\\n\\t\\t\\tthis.b = b;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetHSL: function () {\\n\\n\\t\\t\\tfunction hue2rgb( p, q, t ) {\\n\\n\\t\\t\\t\\tif ( t < 0 ) t += 1;\\n\\t\\t\\t\\tif ( t > 1 ) t -= 1;\\n\\t\\t\\t\\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\\n\\t\\t\\t\\tif ( t < 1 / 2 ) return q;\\n\\t\\t\\t\\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\\n\\t\\t\\t\\treturn p;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn function setHSL( h, s, l ) {\\n\\n\\t\\t\\t\\t// h,s,l ranges are in 0.0 - 1.0\\n\\t\\t\\t\\th = _Math.euclideanModulo( h, 1 );\\n\\t\\t\\t\\ts = _Math.clamp( s, 0, 1 );\\n\\t\\t\\t\\tl = _Math.clamp( l, 0, 1 );\\n\\n\\t\\t\\t\\tif ( s === 0 ) {\\n\\n\\t\\t\\t\\t\\tthis.r = this.g = this.b = l;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\\n\\t\\t\\t\\t\\tvar q = ( 2 * l ) - p;\\n\\n\\t\\t\\t\\t\\tthis.r = hue2rgb( q, p, h + 1 / 3 );\\n\\t\\t\\t\\t\\tthis.g = hue2rgb( q, p, h );\\n\\t\\t\\t\\t\\tthis.b = hue2rgb( q, p, h - 1 / 3 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tsetStyle: function ( style ) {\\n\\n\\t\\t\\tfunction handleAlpha( string ) {\\n\\n\\t\\t\\t\\tif ( string === undefined ) return;\\n\\n\\t\\t\\t\\tif ( parseFloat( string ) < 1 ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\tvar m;\\n\\n\\t\\t\\tif ( m = /^((?:rgb|hsl)a?)\\\\(\\\\s*([^\\\\)]*)\\\\)/.exec( style ) ) {\\n\\n\\t\\t\\t\\t// rgb / hsl\\n\\n\\t\\t\\t\\tvar color;\\n\\t\\t\\t\\tvar name = m[ 1 ];\\n\\t\\t\\t\\tvar components = m[ 2 ];\\n\\n\\t\\t\\t\\tswitch ( name ) {\\n\\n\\t\\t\\t\\t\\tcase 'rgb':\\n\\t\\t\\t\\t\\tcase 'rgba':\\n\\n\\t\\t\\t\\t\\t\\tif ( color = /^(\\\\d+)\\\\s*,\\\\s*(\\\\d+)\\\\s*,\\\\s*(\\\\d+)\\\\s*(,\\\\s*([0-9]*\\\\.?[0-9]+)\\\\s*)?$/.exec( components ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// rgb(255,0,0) rgba(255,0,0,0.5)\\n\\t\\t\\t\\t\\t\\t\\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\\n\\t\\t\\t\\t\\t\\t\\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\\n\\t\\t\\t\\t\\t\\t\\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\\n\\n\\t\\t\\t\\t\\t\\t\\thandleAlpha( color[ 5 ] );\\n\\n\\t\\t\\t\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif ( color = /^(\\\\d+)\\\\%\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\s*(,\\\\s*([0-9]*\\\\.?[0-9]+)\\\\s*)?$/.exec( components ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\\n\\t\\t\\t\\t\\t\\t\\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\\n\\t\\t\\t\\t\\t\\t\\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\\n\\t\\t\\t\\t\\t\\t\\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\\n\\n\\t\\t\\t\\t\\t\\t\\thandleAlpha( color[ 5 ] );\\n\\n\\t\\t\\t\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'hsl':\\n\\t\\t\\t\\t\\tcase 'hsla':\\n\\n\\t\\t\\t\\t\\t\\tif ( color = /^([0-9]*\\\\.?[0-9]+)\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\s*(,\\\\s*([0-9]*\\\\.?[0-9]+)\\\\s*)?$/.exec( components ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\\n\\t\\t\\t\\t\\t\\t\\tvar h = parseFloat( color[ 1 ] ) / 360;\\n\\t\\t\\t\\t\\t\\t\\tvar s = parseInt( color[ 2 ], 10 ) / 100;\\n\\t\\t\\t\\t\\t\\t\\tvar l = parseInt( color[ 3 ], 10 ) / 100;\\n\\n\\t\\t\\t\\t\\t\\t\\thandleAlpha( color[ 5 ] );\\n\\n\\t\\t\\t\\t\\t\\t\\treturn this.setHSL( h, s, l );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( m = /^\\\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\\n\\n\\t\\t\\t\\t// hex color\\n\\n\\t\\t\\t\\tvar hex = m[ 1 ];\\n\\t\\t\\t\\tvar size = hex.length;\\n\\n\\t\\t\\t\\tif ( size === 3 ) {\\n\\n\\t\\t\\t\\t\\t// #ff0\\n\\t\\t\\t\\t\\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\\n\\t\\t\\t\\t\\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\\n\\t\\t\\t\\t\\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\\n\\n\\t\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t\\t} else if ( size === 6 ) {\\n\\n\\t\\t\\t\\t\\t// #ff0000\\n\\t\\t\\t\\t\\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\\n\\t\\t\\t\\t\\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\\n\\t\\t\\t\\t\\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\\n\\n\\t\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( style && style.length > 0 ) {\\n\\n\\t\\t\\t\\t// color keywords\\n\\t\\t\\t\\tvar hex = ColorKeywords[ style ];\\n\\n\\t\\t\\t\\tif ( hex !== undefined ) {\\n\\n\\t\\t\\t\\t\\t// red\\n\\t\\t\\t\\t\\tthis.setHex( hex );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// unknown color\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.Color: Unknown color ' + style );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.r, this.g, this.b );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( color ) {\\n\\n\\t\\t\\tthis.r = color.r;\\n\\t\\t\\tthis.g = color.g;\\n\\t\\t\\tthis.b = color.b;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyGammaToLinear: function ( color, gammaFactor ) {\\n\\n\\t\\t\\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\\n\\n\\t\\t\\tthis.r = Math.pow( color.r, gammaFactor );\\n\\t\\t\\tthis.g = Math.pow( color.g, gammaFactor );\\n\\t\\t\\tthis.b = Math.pow( color.b, gammaFactor );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyLinearToGamma: function ( color, gammaFactor ) {\\n\\n\\t\\t\\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\\n\\n\\t\\t\\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\\n\\n\\t\\t\\tthis.r = Math.pow( color.r, safeInverse );\\n\\t\\t\\tthis.g = Math.pow( color.g, safeInverse );\\n\\t\\t\\tthis.b = Math.pow( color.b, safeInverse );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tconvertGammaToLinear: function () {\\n\\n\\t\\t\\tvar r = this.r, g = this.g, b = this.b;\\n\\n\\t\\t\\tthis.r = r * r;\\n\\t\\t\\tthis.g = g * g;\\n\\t\\t\\tthis.b = b * b;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tconvertLinearToGamma: function () {\\n\\n\\t\\t\\tthis.r = Math.sqrt( this.r );\\n\\t\\t\\tthis.g = Math.sqrt( this.g );\\n\\t\\t\\tthis.b = Math.sqrt( this.b );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetHex: function () {\\n\\n\\t\\t\\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\\n\\n\\t\\t},\\n\\n\\t\\tgetHexString: function () {\\n\\n\\t\\t\\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\\n\\n\\t\\t},\\n\\n\\t\\tgetHSL: function ( optionalTarget ) {\\n\\n\\t\\t\\t// h,s,l ranges are in 0.0 - 1.0\\n\\n\\t\\t\\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\\n\\n\\t\\t\\tvar r = this.r, g = this.g, b = this.b;\\n\\n\\t\\t\\tvar max = Math.max( r, g, b );\\n\\t\\t\\tvar min = Math.min( r, g, b );\\n\\n\\t\\t\\tvar hue, saturation;\\n\\t\\t\\tvar lightness = ( min + max ) / 2.0;\\n\\n\\t\\t\\tif ( min === max ) {\\n\\n\\t\\t\\t\\thue = 0;\\n\\t\\t\\t\\tsaturation = 0;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tvar delta = max - min;\\n\\n\\t\\t\\t\\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\\n\\n\\t\\t\\t\\tswitch ( max ) {\\n\\n\\t\\t\\t\\t\\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\\n\\t\\t\\t\\t\\tcase g: hue = ( b - r ) / delta + 2; break;\\n\\t\\t\\t\\t\\tcase b: hue = ( r - g ) / delta + 4; break;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\thue /= 6;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\thsl.h = hue;\\n\\t\\t\\thsl.s = saturation;\\n\\t\\t\\thsl.l = lightness;\\n\\n\\t\\t\\treturn hsl;\\n\\n\\t\\t},\\n\\n\\t\\tgetStyle: function () {\\n\\n\\t\\t\\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\\n\\n\\t\\t},\\n\\n\\t\\toffsetHSL: function ( h, s, l ) {\\n\\n\\t\\t\\tvar hsl = this.getHSL();\\n\\n\\t\\t\\thsl.h += h; hsl.s += s; hsl.l += l;\\n\\n\\t\\t\\tthis.setHSL( hsl.h, hsl.s, hsl.l );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tadd: function ( color ) {\\n\\n\\t\\t\\tthis.r += color.r;\\n\\t\\t\\tthis.g += color.g;\\n\\t\\t\\tthis.b += color.b;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddColors: function ( color1, color2 ) {\\n\\n\\t\\t\\tthis.r = color1.r + color2.r;\\n\\t\\t\\tthis.g = color1.g + color2.g;\\n\\t\\t\\tthis.b = color1.b + color2.b;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddScalar: function ( s ) {\\n\\n\\t\\t\\tthis.r += s;\\n\\t\\t\\tthis.g += s;\\n\\t\\t\\tthis.b += s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsub: function ( color ) {\\n\\n\\t\\t\\tthis.r = Math.max( 0, this.r - color.r );\\n\\t\\t\\tthis.g = Math.max( 0, this.g - color.g );\\n\\t\\t\\tthis.b = Math.max( 0, this.b - color.b );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiply: function ( color ) {\\n\\n\\t\\t\\tthis.r *= color.r;\\n\\t\\t\\tthis.g *= color.g;\\n\\t\\t\\tthis.b *= color.b;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyScalar: function ( s ) {\\n\\n\\t\\t\\tthis.r *= s;\\n\\t\\t\\tthis.g *= s;\\n\\t\\t\\tthis.b *= s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tlerp: function ( color, alpha ) {\\n\\n\\t\\t\\tthis.r += ( color.r - this.r ) * alpha;\\n\\t\\t\\tthis.g += ( color.g - this.g ) * alpha;\\n\\t\\t\\tthis.b += ( color.b - this.b ) * alpha;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( c ) {\\n\\n\\t\\t\\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\\n\\n\\t\\t},\\n\\n\\t\\tfromArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tthis.r = array[ offset ];\\n\\t\\t\\tthis.g = array[ offset + 1 ];\\n\\t\\t\\tthis.b = array[ offset + 2 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( array === undefined ) array = [];\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tarray[ offset ] = this.r;\\n\\t\\t\\tarray[ offset + 1 ] = this.g;\\n\\t\\t\\tarray[ offset + 2 ] = this.b;\\n\\n\\t\\t\\treturn array;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function () {\\n\\n\\t\\t\\treturn this.getHex();\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * Uniforms library for shared webgl shaders\\n\\t */\\n\\n\\tvar UniformsLib = {\\n\\n\\t\\tcommon: {\\n\\n\\t\\t\\tdiffuse: { value: new Color( 0xeeeeee ) },\\n\\t\\t\\topacity: { value: 1.0 },\\n\\n\\t\\t\\tmap: { value: null },\\n\\t\\t\\tuvTransform: { value: new Matrix3() },\\n\\n\\t\\t\\talphaMap: { value: null },\\n\\n\\t\\t},\\n\\n\\t\\tspecularmap: {\\n\\n\\t\\t\\tspecularMap: { value: null },\\n\\n\\t\\t},\\n\\n\\t\\tenvmap: {\\n\\n\\t\\t\\tenvMap: { value: null },\\n\\t\\t\\tflipEnvMap: { value: - 1 },\\n\\t\\t\\treflectivity: { value: 1.0 },\\n\\t\\t\\trefractionRatio: { value: 0.98 }\\n\\n\\t\\t},\\n\\n\\t\\taomap: {\\n\\n\\t\\t\\taoMap: { value: null },\\n\\t\\t\\taoMapIntensity: { value: 1 }\\n\\n\\t\\t},\\n\\n\\t\\tlightmap: {\\n\\n\\t\\t\\tlightMap: { value: null },\\n\\t\\t\\tlightMapIntensity: { value: 1 }\\n\\n\\t\\t},\\n\\n\\t\\temissivemap: {\\n\\n\\t\\t\\temissiveMap: { value: null }\\n\\n\\t\\t},\\n\\n\\t\\tbumpmap: {\\n\\n\\t\\t\\tbumpMap: { value: null },\\n\\t\\t\\tbumpScale: { value: 1 }\\n\\n\\t\\t},\\n\\n\\t\\tnormalmap: {\\n\\n\\t\\t\\tnormalMap: { value: null },\\n\\t\\t\\tnormalScale: { value: new Vector2( 1, 1 ) }\\n\\n\\t\\t},\\n\\n\\t\\tdisplacementmap: {\\n\\n\\t\\t\\tdisplacementMap: { value: null },\\n\\t\\t\\tdisplacementScale: { value: 1 },\\n\\t\\t\\tdisplacementBias: { value: 0 }\\n\\n\\t\\t},\\n\\n\\t\\troughnessmap: {\\n\\n\\t\\t\\troughnessMap: { value: null }\\n\\n\\t\\t},\\n\\n\\t\\tmetalnessmap: {\\n\\n\\t\\t\\tmetalnessMap: { value: null }\\n\\n\\t\\t},\\n\\n\\t\\tgradientmap: {\\n\\n\\t\\t\\tgradientMap: { value: null }\\n\\n\\t\\t},\\n\\n\\t\\tfog: {\\n\\n\\t\\t\\tfogDensity: { value: 0.00025 },\\n\\t\\t\\tfogNear: { value: 1 },\\n\\t\\t\\tfogFar: { value: 2000 },\\n\\t\\t\\tfogColor: { value: new Color( 0xffffff ) }\\n\\n\\t\\t},\\n\\n\\t\\tlights: {\\n\\n\\t\\t\\tambientLightColor: { value: [] },\\n\\n\\t\\t\\tdirectionalLights: { value: [], properties: {\\n\\t\\t\\t\\tdirection: {},\\n\\t\\t\\t\\tcolor: {},\\n\\n\\t\\t\\t\\tshadow: {},\\n\\t\\t\\t\\tshadowBias: {},\\n\\t\\t\\t\\tshadowRadius: {},\\n\\t\\t\\t\\tshadowMapSize: {}\\n\\t\\t\\t} },\\n\\n\\t\\t\\tdirectionalShadowMap: { value: [] },\\n\\t\\t\\tdirectionalShadowMatrix: { value: [] },\\n\\n\\t\\t\\tspotLights: { value: [], properties: {\\n\\t\\t\\t\\tcolor: {},\\n\\t\\t\\t\\tposition: {},\\n\\t\\t\\t\\tdirection: {},\\n\\t\\t\\t\\tdistance: {},\\n\\t\\t\\t\\tconeCos: {},\\n\\t\\t\\t\\tpenumbraCos: {},\\n\\t\\t\\t\\tdecay: {},\\n\\n\\t\\t\\t\\tshadow: {},\\n\\t\\t\\t\\tshadowBias: {},\\n\\t\\t\\t\\tshadowRadius: {},\\n\\t\\t\\t\\tshadowMapSize: {}\\n\\t\\t\\t} },\\n\\n\\t\\t\\tspotShadowMap: { value: [] },\\n\\t\\t\\tspotShadowMatrix: { value: [] },\\n\\n\\t\\t\\tpointLights: { value: [], properties: {\\n\\t\\t\\t\\tcolor: {},\\n\\t\\t\\t\\tposition: {},\\n\\t\\t\\t\\tdecay: {},\\n\\t\\t\\t\\tdistance: {},\\n\\n\\t\\t\\t\\tshadow: {},\\n\\t\\t\\t\\tshadowBias: {},\\n\\t\\t\\t\\tshadowRadius: {},\\n\\t\\t\\t\\tshadowMapSize: {},\\n\\t\\t\\t\\tshadowCameraNear: {},\\n\\t\\t\\t\\tshadowCameraFar: {}\\n\\t\\t\\t} },\\n\\n\\t\\t\\tpointShadowMap: { value: [] },\\n\\t\\t\\tpointShadowMatrix: { value: [] },\\n\\n\\t\\t\\themisphereLights: { value: [], properties: {\\n\\t\\t\\t\\tdirection: {},\\n\\t\\t\\t\\tskyColor: {},\\n\\t\\t\\t\\tgroundColor: {}\\n\\t\\t\\t} },\\n\\n\\t\\t\\t// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src\\n\\t\\t\\trectAreaLights: { value: [], properties: {\\n\\t\\t\\t\\tcolor: {},\\n\\t\\t\\t\\tposition: {},\\n\\t\\t\\t\\twidth: {},\\n\\t\\t\\t\\theight: {}\\n\\t\\t\\t} }\\n\\n\\t\\t},\\n\\n\\t\\tpoints: {\\n\\n\\t\\t\\tdiffuse: { value: new Color( 0xeeeeee ) },\\n\\t\\t\\topacity: { value: 1.0 },\\n\\t\\t\\tsize: { value: 1.0 },\\n\\t\\t\\tscale: { value: 1.0 },\\n\\t\\t\\tmap: { value: null },\\n\\t\\t\\tuvTransform: { value: new Matrix3() }\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t * Uniform Utilities\\n\\t */\\n\\n\\tvar UniformsUtils = {\\n\\n\\t\\tmerge: function ( uniforms ) {\\n\\n\\t\\t\\tvar merged = {};\\n\\n\\t\\t\\tfor ( var u = 0; u < uniforms.length; u ++ ) {\\n\\n\\t\\t\\t\\tvar tmp = this.clone( uniforms[ u ] );\\n\\n\\t\\t\\t\\tfor ( var p in tmp ) {\\n\\n\\t\\t\\t\\t\\tmerged[ p ] = tmp[ p ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn merged;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function ( uniforms_src ) {\\n\\n\\t\\t\\tvar uniforms_dst = {};\\n\\n\\t\\t\\tfor ( var u in uniforms_src ) {\\n\\n\\t\\t\\t\\tuniforms_dst[ u ] = {};\\n\\n\\t\\t\\t\\tfor ( var p in uniforms_src[ u ] ) {\\n\\n\\t\\t\\t\\t\\tvar parameter_src = uniforms_src[ u ][ p ];\\n\\n\\t\\t\\t\\t\\tif ( parameter_src && ( parameter_src.isColor ||\\n\\t\\t\\t\\t\\t\\tparameter_src.isMatrix3 || parameter_src.isMatrix4 ||\\n\\t\\t\\t\\t\\t\\tparameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||\\n\\t\\t\\t\\t\\t\\tparameter_src.isTexture ) ) {\\n\\n\\t\\t\\t\\t\\t\\tuniforms_dst[ u ][ p ] = parameter_src.clone();\\n\\n\\t\\t\\t\\t\\t} else if ( Array.isArray( parameter_src ) ) {\\n\\n\\t\\t\\t\\t\\t\\tuniforms_dst[ u ][ p ] = parameter_src.slice();\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tuniforms_dst[ u ][ p ] = parameter_src;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn uniforms_dst;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tvar alphamap_fragment = \\\"#ifdef USE_ALPHAMAP\\\\n\\\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\\\n#endif\\\\n\\\";\\n\\n\\tvar alphamap_pars_fragment = \\\"#ifdef USE_ALPHAMAP\\\\n\\\\tuniform sampler2D alphaMap;\\\\n#endif\\\\n\\\";\\n\\n\\tvar alphatest_fragment = \\\"#ifdef ALPHATEST\\\\n\\\\tif ( diffuseColor.a < ALPHATEST ) discard;\\\\n#endif\\\\n\\\";\\n\\n\\tvar aomap_fragment = \\\"#ifdef USE_AOMAP\\\\n\\\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\\\n\\\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\\\n\\\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\\\n\\\\t\\\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\\\n\\\\t\\\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar aomap_pars_fragment = \\\"#ifdef USE_AOMAP\\\\n\\\\tuniform sampler2D aoMap;\\\\n\\\\tuniform float aoMapIntensity;\\\\n#endif\\\";\\n\\n\\tvar begin_vertex = \\\"\\\\nvec3 transformed = vec3( position );\\\\n\\\";\\n\\n\\tvar beginnormal_vertex = \\\"\\\\nvec3 objectNormal = vec3( normal );\\\\n\\\";\\n\\n\\tvar bsdfs = \\\"float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\\\n\\\\tif( decayExponent > 0.0 ) {\\\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\\\n\\\\t\\\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\\\n\\\\t\\\\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\\\n\\\\t\\\\treturn distanceFalloff * maxDistanceCutoffFactor;\\\\n#else\\\\n\\\\t\\\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\\\n#endif\\\\n\\\\t}\\\\n\\\\treturn 1.0;\\\\n}\\\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\\\n\\\\treturn RECIPROCAL_PI * diffuseColor;\\\\n}\\\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\\\n\\\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\\\n\\\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\\\n}\\\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\\\n\\\\tfloat a2 = pow2( alpha );\\\\n\\\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\\\n\\\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\\\n\\\\treturn 1.0 / ( gl * gv );\\\\n}\\\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\\\n\\\\tfloat a2 = pow2( alpha );\\\\n\\\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\\\n\\\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\\\n\\\\treturn 0.5 / max( gv + gl, EPSILON );\\\\n}\\\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\\\n\\\\tfloat a2 = pow2( alpha );\\\\n\\\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\\\n\\\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\\\n}\\\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\\\n\\\\tfloat alpha = pow2( roughness );\\\\n\\\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\\\n\\\\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\\\n\\\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\\\n\\\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\\\n\\\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\\\n\\\\tvec3 F = F_Schlick( specularColor, dotLH );\\\\n\\\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\\\n\\\\tfloat D = D_GGX( alpha, dotNH );\\\\n\\\\treturn F * ( G * D );\\\\n}\\\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\\\n\\\\tconst float LUT_SIZE  = 64.0;\\\\n\\\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\\\n\\\\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\\\\n\\\\tfloat theta = acos( dot( N, V ) );\\\\n\\\\tvec2 uv = vec2(\\\\n\\\\t\\\\tsqrt( saturate( roughness ) ),\\\\n\\\\t\\\\tsaturate( theta / ( 0.5 * PI ) ) );\\\\n\\\\tuv = uv * LUT_SCALE + LUT_BIAS;\\\\n\\\\treturn uv;\\\\n}\\\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\\\n\\\\tfloat l = length( f );\\\\n\\\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\\\n}\\\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\\\n\\\\tfloat x = dot( v1, v2 );\\\\n\\\\tfloat y = abs( x );\\\\n\\\\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\\\\n\\\\tfloat b = 3.45068 + (4.18814 + y) * y;\\\\n\\\\tfloat v = a / b;\\\\n\\\\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\\\\n\\\\treturn cross( v1, v2 ) * theta_sintheta;\\\\n}\\\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\\\n\\\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\\\n\\\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\\\n\\\\tvec3 lightNormal = cross( v1, v2 );\\\\n\\\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\\\n\\\\tvec3 T1, T2;\\\\n\\\\tT1 = normalize( V - N * dot( V, N ) );\\\\n\\\\tT2 = - cross( N, T1 );\\\\n\\\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\\\n\\\\tvec3 coords[ 4 ];\\\\n\\\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\\\n\\\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\\\n\\\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\\\n\\\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\\\n\\\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\\\n\\\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\\\n\\\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\\\n\\\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\\\n\\\\tvec3 vectorFormFactor = vec3( 0.0 );\\\\n\\\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\\\n\\\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\\\n\\\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\\\n\\\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\\\n\\\\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\\\\n\\\\treturn result;\\\\n}\\\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\\\n\\\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\\\n\\\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\\\n\\\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\\\n\\\\tvec4 r = roughness * c0 + c1;\\\\n\\\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\\\n\\\\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\\\n\\\\treturn specularColor * AB.x + AB.y;\\\\n}\\\\nfloat G_BlinnPhong_Implicit( ) {\\\\n\\\\treturn 0.25;\\\\n}\\\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\\\n\\\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\\\n}\\\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\\\n\\\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\\\n\\\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\\\n\\\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\\\n\\\\tvec3 F = F_Schlick( specularColor, dotLH );\\\\n\\\\tfloat G = G_BlinnPhong_Implicit( );\\\\n\\\\tfloat D = D_BlinnPhong( shininess, dotNH );\\\\n\\\\treturn F * ( G * D );\\\\n}\\\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\\\n\\\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\\\n}\\\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\\\n\\\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\\\n}\\\\n\\\";\\n\\n\\tvar bumpmap_pars_fragment = \\\"#ifdef USE_BUMPMAP\\\\n\\\\tuniform sampler2D bumpMap;\\\\n\\\\tuniform float bumpScale;\\\\n\\\\tvec2 dHdxy_fwd() {\\\\n\\\\t\\\\tvec2 dSTdx = dFdx( vUv );\\\\n\\\\t\\\\tvec2 dSTdy = dFdy( vUv );\\\\n\\\\t\\\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\\\n\\\\t\\\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\\\n\\\\t\\\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\\\n\\\\t\\\\treturn vec2( dBx, dBy );\\\\n\\\\t}\\\\n\\\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\\\n\\\\t\\\\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\\\\n\\\\t\\\\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\\\\n\\\\t\\\\tvec3 vN = surf_norm;\\\\n\\\\t\\\\tvec3 R1 = cross( vSigmaY, vN );\\\\n\\\\t\\\\tvec3 R2 = cross( vN, vSigmaX );\\\\n\\\\t\\\\tfloat fDet = dot( vSigmaX, R1 );\\\\n\\\\t\\\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\\\n\\\\t\\\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\\\n\\\\t}\\\\n#endif\\\\n\\\";\\n\\n\\tvar clipping_planes_fragment = \\\"#if NUM_CLIPPING_PLANES > 0\\\\n\\\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\\\\n\\\\t\\\\tvec4 plane = clippingPlanes[ i ];\\\\n\\\\t\\\\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\\\n\\\\t}\\\\n\\\\t\\\\t\\\\n\\\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\\\n\\\\t\\\\tbool clipped = true;\\\\n\\\\t\\\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\\\\n\\\\t\\\\t\\\\tvec4 plane = clippingPlanes[ i ];\\\\n\\\\t\\\\t\\\\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\tif ( clipped ) discard;\\\\n\\\\t\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar clipping_planes_pars_fragment = \\\"#if NUM_CLIPPING_PLANES > 0\\\\n\\\\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\\\n\\\\t\\\\tvarying vec3 vViewPosition;\\\\n\\\\t#endif\\\\n\\\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\\\n#endif\\\\n\\\";\\n\\n\\tvar clipping_planes_pars_vertex = \\\"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\\\n\\\\tvarying vec3 vViewPosition;\\\\n#endif\\\\n\\\";\\n\\n\\tvar clipping_planes_vertex = \\\"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\\\n\\\\tvViewPosition = - mvPosition.xyz;\\\\n#endif\\\\n\\\";\\n\\n\\tvar color_fragment = \\\"#ifdef USE_COLOR\\\\n\\\\tdiffuseColor.rgb *= vColor;\\\\n#endif\\\";\\n\\n\\tvar color_pars_fragment = \\\"#ifdef USE_COLOR\\\\n\\\\tvarying vec3 vColor;\\\\n#endif\\\\n\\\";\\n\\n\\tvar color_pars_vertex = \\\"#ifdef USE_COLOR\\\\n\\\\tvarying vec3 vColor;\\\\n#endif\\\";\\n\\n\\tvar color_vertex = \\\"#ifdef USE_COLOR\\\\n\\\\tvColor.xyz = color.xyz;\\\\n#endif\\\";\\n\\n\\tvar common = \\\"#define PI 3.14159265359\\\\n#define PI2 6.28318530718\\\\n#define PI_HALF 1.5707963267949\\\\n#define RECIPROCAL_PI 0.31830988618\\\\n#define RECIPROCAL_PI2 0.15915494\\\\n#define LOG2 1.442695\\\\n#define EPSILON 1e-6\\\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\\\nfloat pow2( const in float x ) { return x*x; }\\\\nfloat pow3( const in float x ) { return x*x*x; }\\\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\\\nhighp float rand( const in vec2 uv ) {\\\\n\\\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\\\n\\\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\\\n\\\\treturn fract(sin(sn) * c);\\\\n}\\\\nstruct IncidentLight {\\\\n\\\\tvec3 color;\\\\n\\\\tvec3 direction;\\\\n\\\\tbool visible;\\\\n};\\\\nstruct ReflectedLight {\\\\n\\\\tvec3 directDiffuse;\\\\n\\\\tvec3 directSpecular;\\\\n\\\\tvec3 indirectDiffuse;\\\\n\\\\tvec3 indirectSpecular;\\\\n};\\\\nstruct GeometricContext {\\\\n\\\\tvec3 position;\\\\n\\\\tvec3 normal;\\\\n\\\\tvec3 viewDir;\\\\n};\\\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\\\n\\\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\\\n}\\\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\\\n\\\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\\\n}\\\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\\\n\\\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\\\n\\\\treturn - distance * planeNormal + point;\\\\n}\\\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\\\n\\\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\\\n}\\\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\\\n\\\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\\\n}\\\\nmat3 transposeMat3( const in mat3 m ) {\\\\n\\\\tmat3 tmp;\\\\n\\\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\\\n\\\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\\\n\\\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\\\n\\\\treturn tmp;\\\\n}\\\\nfloat linearToRelativeLuminance( const in vec3 color ) {\\\\n\\\\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\\\\n\\\\treturn dot( weights, color.rgb );\\\\n}\\\\n\\\";\\n\\n\\tvar cube_uv_reflection_fragment = \\\"#ifdef ENVMAP_TYPE_CUBE_UV\\\\n#define cubeUV_textureSize (1024.0)\\\\nint getFaceFromDirection(vec3 direction) {\\\\n\\\\tvec3 absDirection = abs(direction);\\\\n\\\\tint face = -1;\\\\n\\\\tif( absDirection.x > absDirection.z ) {\\\\n\\\\t\\\\tif(absDirection.x > absDirection.y )\\\\n\\\\t\\\\t\\\\tface = direction.x > 0.0 ? 0 : 3;\\\\n\\\\t\\\\telse\\\\n\\\\t\\\\t\\\\tface = direction.y > 0.0 ? 1 : 4;\\\\n\\\\t}\\\\n\\\\telse {\\\\n\\\\t\\\\tif(absDirection.z > absDirection.y )\\\\n\\\\t\\\\t\\\\tface = direction.z > 0.0 ? 2 : 5;\\\\n\\\\t\\\\telse\\\\n\\\\t\\\\t\\\\tface = direction.y > 0.0 ? 1 : 4;\\\\n\\\\t}\\\\n\\\\treturn face;\\\\n}\\\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\\\n\\\\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\\\n\\\\tfloat dxRoughness = dFdx(roughness);\\\\n\\\\tfloat dyRoughness = dFdy(roughness);\\\\n\\\\tvec3 dx = dFdx( vec * scale * dxRoughness );\\\\n\\\\tvec3 dy = dFdy( vec * scale * dyRoughness );\\\\n\\\\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\\\n\\\\td = clamp(d, 1.0, cubeUV_rangeClamp);\\\\n\\\\tfloat mipLevel = 0.5 * log2(d);\\\\n\\\\treturn vec2(floor(mipLevel), fract(mipLevel));\\\\n}\\\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\\\n\\\\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\\\n\\\\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\\\n\\\\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\\\n\\\\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\\\n\\\\tfloat powScale = exp2_packed.x * exp2_packed.y;\\\\n\\\\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\\\n\\\\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\\\n\\\\tbool bRes = mipLevel == 0.0;\\\\n\\\\tscale =  bRes && (scale < a) ? a : scale;\\\\n\\\\tvec3 r;\\\\n\\\\tvec2 offset;\\\\n\\\\tint face = getFaceFromDirection(direction);\\\\n\\\\tfloat rcpPowScale = 1.0 / powScale;\\\\n\\\\tif( face == 0) {\\\\n\\\\t\\\\tr = vec3(direction.x, -direction.z, direction.y);\\\\n\\\\t\\\\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\\\n\\\\t\\\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\\\n\\\\t}\\\\n\\\\telse if( face == 1) {\\\\n\\\\t\\\\tr = vec3(direction.y, direction.x, direction.z);\\\\n\\\\t\\\\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\\\n\\\\t\\\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\\\n\\\\t}\\\\n\\\\telse if( face == 2) {\\\\n\\\\t\\\\tr = vec3(direction.z, direction.x, direction.y);\\\\n\\\\t\\\\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\\\n\\\\t\\\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\\\n\\\\t}\\\\n\\\\telse if( face == 3) {\\\\n\\\\t\\\\tr = vec3(direction.x, direction.z, direction.y);\\\\n\\\\t\\\\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\\\n\\\\t\\\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\\\n\\\\t}\\\\n\\\\telse if( face == 4) {\\\\n\\\\t\\\\tr = vec3(direction.y, direction.x, -direction.z);\\\\n\\\\t\\\\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\\\n\\\\t\\\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\\\n\\\\t}\\\\n\\\\telse {\\\\n\\\\t\\\\tr = vec3(direction.z, -direction.x, direction.y);\\\\n\\\\t\\\\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\\\n\\\\t\\\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\\\n\\\\t}\\\\n\\\\tr = normalize(r);\\\\n\\\\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\\\n\\\\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\\\n\\\\tvec2 base = offset + vec2( texelOffset );\\\\n\\\\treturn base + s * ( scale - 2.0 * texelOffset );\\\\n}\\\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\\\n\\\\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\\\n\\\\tfloat r1 = floor(roughnessVal);\\\\n\\\\tfloat r2 = r1 + 1.0;\\\\n\\\\tfloat t = fract(roughnessVal);\\\\n\\\\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\\\n\\\\tfloat s = mipInfo.y;\\\\n\\\\tfloat level0 = mipInfo.x;\\\\n\\\\tfloat level1 = level0 + 1.0;\\\\n\\\\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\\\n\\\\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\\\n\\\\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\\\n\\\\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\\\n\\\\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\\\n\\\\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\\\n\\\\tvec4 result = mix(color10, color20, t);\\\\n\\\\treturn vec4(result.rgb, 1.0);\\\\n}\\\\n#endif\\\\n\\\";\\n\\n\\tvar defaultnormal_vertex = \\\"vec3 transformedNormal = normalMatrix * objectNormal;\\\\n#ifdef FLIP_SIDED\\\\n\\\\ttransformedNormal = - transformedNormal;\\\\n#endif\\\\n\\\";\\n\\n\\tvar displacementmap_pars_vertex = \\\"#ifdef USE_DISPLACEMENTMAP\\\\n\\\\tuniform sampler2D displacementMap;\\\\n\\\\tuniform float displacementScale;\\\\n\\\\tuniform float displacementBias;\\\\n#endif\\\\n\\\";\\n\\n\\tvar displacementmap_vertex = \\\"#ifdef USE_DISPLACEMENTMAP\\\\n\\\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\\\n#endif\\\\n\\\";\\n\\n\\tvar emissivemap_fragment = \\\"#ifdef USE_EMISSIVEMAP\\\\n\\\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\\\n\\\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\\\n\\\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\\\n#endif\\\\n\\\";\\n\\n\\tvar emissivemap_pars_fragment = \\\"#ifdef USE_EMISSIVEMAP\\\\n\\\\tuniform sampler2D emissiveMap;\\\\n#endif\\\\n\\\";\\n\\n\\tvar encodings_fragment = \\\"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\\\n\\\";\\n\\n\\tvar encodings_pars_fragment = \\\"\\\\nvec4 LinearToLinear( in vec4 value ) {\\\\n\\\\treturn value;\\\\n}\\\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\\\n\\\\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\\\n}\\\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\\\n\\\\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\\\n}\\\\nvec4 sRGBToLinear( in vec4 value ) {\\\\n\\\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\\\n}\\\\nvec4 LinearTosRGB( in vec4 value ) {\\\\n\\\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\\\n}\\\\nvec4 RGBEToLinear( in vec4 value ) {\\\\n\\\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\\\n}\\\\nvec4 LinearToRGBE( in vec4 value ) {\\\\n\\\\tfloat maxComponent = max( max( value.r, value.g ), value.b );\\\\n\\\\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\\\n\\\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\\\n}\\\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\\\n\\\\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\\\\n}\\\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\\\n\\\\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\\\\n\\\\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\\\n\\\\tM            = ceil( M * 255.0 ) / 255.0;\\\\n\\\\treturn vec4( value.rgb / ( M * maxRange ), M );\\\\n}\\\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\\\n\\\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\\\n}\\\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\\\n\\\\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\\\\n\\\\tfloat D      = max( maxRange / maxRGB, 1.0 );\\\\n\\\\tD            = min( floor( D ) / 255.0, 1.0 );\\\\n\\\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\\\n}\\\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\\\nvec4 LinearToLogLuv( in vec4 value )  {\\\\n\\\\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\\\n\\\\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\\\n\\\\tvec4 vResult;\\\\n\\\\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\\\n\\\\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\\\n\\\\tvResult.w = fract(Le);\\\\n\\\\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\\\n\\\\treturn vResult;\\\\n}\\\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\\\nvec4 LogLuvToLinear( in vec4 value ) {\\\\n\\\\tfloat Le = value.z * 255.0 + value.w;\\\\n\\\\tvec3 Xp_Y_XYZp;\\\\n\\\\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\\\n\\\\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\\\n\\\\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\\\n\\\\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\\\n\\\\treturn vec4( max(vRGB, 0.0), 1.0 );\\\\n}\\\\n\\\";\\n\\n\\tvar envmap_fragment = \\\"#ifdef USE_ENVMAP\\\\n\\\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\\\n\\\\t\\\\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\\\n\\\\t\\\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\\\n\\\\t\\\\t#ifdef ENVMAP_MODE_REFLECTION\\\\n\\\\t\\\\t\\\\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\\\n\\\\t\\\\t#endif\\\\n\\\\t#else\\\\n\\\\t\\\\tvec3 reflectVec = vReflect;\\\\n\\\\t#endif\\\\n\\\\t#ifdef ENVMAP_TYPE_CUBE\\\\n\\\\t\\\\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\\\n\\\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\\\n\\\\t\\\\tvec2 sampleUV;\\\\n\\\\t\\\\treflectVec = normalize( reflectVec );\\\\n\\\\t\\\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\\\n\\\\t\\\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\\\n\\\\t\\\\tvec4 envColor = texture2D( envMap, sampleUV );\\\\n\\\\t#elif defined( ENVMAP_TYPE_SPHERE )\\\\n\\\\t\\\\treflectVec = normalize( reflectVec );\\\\n\\\\t\\\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\\\n\\\\t\\\\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\\\n\\\\t#else\\\\n\\\\t\\\\tvec4 envColor = vec4( 0.0 );\\\\n\\\\t#endif\\\\n\\\\tenvColor = envMapTexelToLinear( envColor );\\\\n\\\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\\\n\\\\t\\\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\\\n\\\\t#elif defined( ENVMAP_BLENDING_MIX )\\\\n\\\\t\\\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\\\n\\\\t#elif defined( ENVMAP_BLENDING_ADD )\\\\n\\\\t\\\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar envmap_pars_fragment = \\\"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\\\n\\\\tuniform float reflectivity;\\\\n\\\\tuniform float envMapIntensity;\\\\n#endif\\\\n#ifdef USE_ENVMAP\\\\n\\\\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\\\n\\\\t\\\\tvarying vec3 vWorldPosition;\\\\n\\\\t#endif\\\\n\\\\t#ifdef ENVMAP_TYPE_CUBE\\\\n\\\\t\\\\tuniform samplerCube envMap;\\\\n\\\\t#else\\\\n\\\\t\\\\tuniform sampler2D envMap;\\\\n\\\\t#endif\\\\n\\\\tuniform float flipEnvMap;\\\\n\\\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\\\n\\\\t\\\\tuniform float refractionRatio;\\\\n\\\\t#else\\\\n\\\\t\\\\tvarying vec3 vReflect;\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar envmap_pars_vertex = \\\"#ifdef USE_ENVMAP\\\\n\\\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\\\n\\\\t\\\\tvarying vec3 vWorldPosition;\\\\n\\\\t#else\\\\n\\\\t\\\\tvarying vec3 vReflect;\\\\n\\\\t\\\\tuniform float refractionRatio;\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar envmap_vertex = \\\"#ifdef USE_ENVMAP\\\\n\\\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\\\n\\\\t\\\\tvWorldPosition = worldPosition.xyz;\\\\n\\\\t#else\\\\n\\\\t\\\\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\\\n\\\\t\\\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\\\n\\\\t\\\\t#ifdef ENVMAP_MODE_REFLECTION\\\\n\\\\t\\\\t\\\\tvReflect = reflect( cameraToVertex, worldNormal );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\\\n\\\\t\\\\t#endif\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar fog_vertex = \\\"\\\\n#ifdef USE_FOG\\\\nfogDepth = -mvPosition.z;\\\\n#endif\\\";\\n\\n\\tvar fog_pars_vertex = \\\"#ifdef USE_FOG\\\\n  varying float fogDepth;\\\\n#endif\\\\n\\\";\\n\\n\\tvar fog_fragment = \\\"#ifdef USE_FOG\\\\n\\\\t#ifdef FOG_EXP2\\\\n\\\\t\\\\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\\\\n\\\\t#else\\\\n\\\\t\\\\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\\\\n\\\\t#endif\\\\n\\\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\\\n#endif\\\\n\\\";\\n\\n\\tvar fog_pars_fragment = \\\"#ifdef USE_FOG\\\\n\\\\tuniform vec3 fogColor;\\\\n\\\\tvarying float fogDepth;\\\\n\\\\t#ifdef FOG_EXP2\\\\n\\\\t\\\\tuniform float fogDensity;\\\\n\\\\t#else\\\\n\\\\t\\\\tuniform float fogNear;\\\\n\\\\t\\\\tuniform float fogFar;\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar gradientmap_pars_fragment = \\\"#ifdef TOON\\\\n\\\\tuniform sampler2D gradientMap;\\\\n\\\\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\\\n\\\\t\\\\tfloat dotNL = dot( normal, lightDirection );\\\\n\\\\t\\\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\\\n\\\\t\\\\t#ifdef USE_GRADIENTMAP\\\\n\\\\t\\\\t\\\\treturn texture2D( gradientMap, coord ).rgb;\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n#endif\\\\n\\\";\\n\\n\\tvar lightmap_fragment = \\\"#ifdef USE_LIGHTMAP\\\\n\\\\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\\\n#endif\\\\n\\\";\\n\\n\\tvar lightmap_pars_fragment = \\\"#ifdef USE_LIGHTMAP\\\\n\\\\tuniform sampler2D lightMap;\\\\n\\\\tuniform float lightMapIntensity;\\\\n#endif\\\";\\n\\n\\tvar lights_lambert_vertex = \\\"vec3 diffuse = vec3( 1.0 );\\\\nGeometricContext geometry;\\\\ngeometry.position = mvPosition.xyz;\\\\ngeometry.normal = normalize( transformedNormal );\\\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\\\nGeometricContext backGeometry;\\\\nbackGeometry.position = geometry.position;\\\\nbackGeometry.normal = -geometry.normal;\\\\nbackGeometry.viewDir = geometry.viewDir;\\\\nvLightFront = vec3( 0.0 );\\\\n#ifdef DOUBLE_SIDED\\\\n\\\\tvLightBack = vec3( 0.0 );\\\\n#endif\\\\nIncidentLight directLight;\\\\nfloat dotNL;\\\\nvec3 directLightColor_Diffuse;\\\\n#if NUM_POINT_LIGHTS > 0\\\\n\\\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\\\n\\\\t\\\\tdotNL = dot( geometry.normal, directLight.direction );\\\\n\\\\t\\\\tdirectLightColor_Diffuse = PI * directLight.color;\\\\n\\\\t\\\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\t\\\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n#endif\\\\n#if NUM_SPOT_LIGHTS > 0\\\\n\\\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\\\n\\\\t\\\\tdotNL = dot( geometry.normal, directLight.direction );\\\\n\\\\t\\\\tdirectLightColor_Diffuse = PI * directLight.color;\\\\n\\\\t\\\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\t\\\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n#endif\\\\n#if NUM_DIR_LIGHTS > 0\\\\n\\\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\\\n\\\\t\\\\tdotNL = dot( geometry.normal, directLight.direction );\\\\n\\\\t\\\\tdirectLightColor_Diffuse = PI * directLight.color;\\\\n\\\\t\\\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\t\\\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n#endif\\\\n#if NUM_HEMI_LIGHTS > 0\\\\n\\\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\\\n\\\\t\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\t\\\\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n#endif\\\\n\\\";\\n\\n\\tvar lights_pars = \\\"uniform vec3 ambientLightColor;\\\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\\\n\\\\tvec3 irradiance = ambientLightColor;\\\\n\\\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\\\n\\\\t\\\\tirradiance *= PI;\\\\n\\\\t#endif\\\\n\\\\treturn irradiance;\\\\n}\\\\n#if NUM_DIR_LIGHTS > 0\\\\n\\\\tstruct DirectionalLight {\\\\n\\\\t\\\\tvec3 direction;\\\\n\\\\t\\\\tvec3 color;\\\\n\\\\t\\\\tint shadow;\\\\n\\\\t\\\\tfloat shadowBias;\\\\n\\\\t\\\\tfloat shadowRadius;\\\\n\\\\t\\\\tvec2 shadowMapSize;\\\\n\\\\t};\\\\n\\\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\\\n\\\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\\\n\\\\t\\\\tdirectLight.color = directionalLight.color;\\\\n\\\\t\\\\tdirectLight.direction = directionalLight.direction;\\\\n\\\\t\\\\tdirectLight.visible = true;\\\\n\\\\t}\\\\n#endif\\\\n#if NUM_POINT_LIGHTS > 0\\\\n\\\\tstruct PointLight {\\\\n\\\\t\\\\tvec3 position;\\\\n\\\\t\\\\tvec3 color;\\\\n\\\\t\\\\tfloat distance;\\\\n\\\\t\\\\tfloat decay;\\\\n\\\\t\\\\tint shadow;\\\\n\\\\t\\\\tfloat shadowBias;\\\\n\\\\t\\\\tfloat shadowRadius;\\\\n\\\\t\\\\tvec2 shadowMapSize;\\\\n\\\\t\\\\tfloat shadowCameraNear;\\\\n\\\\t\\\\tfloat shadowCameraFar;\\\\n\\\\t};\\\\n\\\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\\\n\\\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\\\n\\\\t\\\\tvec3 lVector = pointLight.position - geometry.position;\\\\n\\\\t\\\\tdirectLight.direction = normalize( lVector );\\\\n\\\\t\\\\tfloat lightDistance = length( lVector );\\\\n\\\\t\\\\tdirectLight.color = pointLight.color;\\\\n\\\\t\\\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\\\n\\\\t\\\\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\\\\n\\\\t}\\\\n#endif\\\\n#if NUM_SPOT_LIGHTS > 0\\\\n\\\\tstruct SpotLight {\\\\n\\\\t\\\\tvec3 position;\\\\n\\\\t\\\\tvec3 direction;\\\\n\\\\t\\\\tvec3 color;\\\\n\\\\t\\\\tfloat distance;\\\\n\\\\t\\\\tfloat decay;\\\\n\\\\t\\\\tfloat coneCos;\\\\n\\\\t\\\\tfloat penumbraCos;\\\\n\\\\t\\\\tint shadow;\\\\n\\\\t\\\\tfloat shadowBias;\\\\n\\\\t\\\\tfloat shadowRadius;\\\\n\\\\t\\\\tvec2 shadowMapSize;\\\\n\\\\t};\\\\n\\\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\\\n\\\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\\\n\\\\t\\\\tvec3 lVector = spotLight.position - geometry.position;\\\\n\\\\t\\\\tdirectLight.direction = normalize( lVector );\\\\n\\\\t\\\\tfloat lightDistance = length( lVector );\\\\n\\\\t\\\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\\\n\\\\t\\\\tif ( angleCos > spotLight.coneCos ) {\\\\n\\\\t\\\\t\\\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\\\n\\\\t\\\\t\\\\tdirectLight.color = spotLight.color;\\\\n\\\\t\\\\t\\\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\\\n\\\\t\\\\t\\\\tdirectLight.visible = true;\\\\n\\\\t\\\\t} else {\\\\n\\\\t\\\\t\\\\tdirectLight.color = vec3( 0.0 );\\\\n\\\\t\\\\t\\\\tdirectLight.visible = false;\\\\n\\\\t\\\\t}\\\\n\\\\t}\\\\n#endif\\\\n#if NUM_RECT_AREA_LIGHTS > 0\\\\n\\\\tstruct RectAreaLight {\\\\n\\\\t\\\\tvec3 color;\\\\n\\\\t\\\\tvec3 position;\\\\n\\\\t\\\\tvec3 halfWidth;\\\\n\\\\t\\\\tvec3 halfHeight;\\\\n\\\\t};\\\\n\\\\tuniform sampler2D ltcMat;\\\\tuniform sampler2D ltcMag;\\\\n\\\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\\\n#endif\\\\n#if NUM_HEMI_LIGHTS > 0\\\\n\\\\tstruct HemisphereLight {\\\\n\\\\t\\\\tvec3 direction;\\\\n\\\\t\\\\tvec3 skyColor;\\\\n\\\\t\\\\tvec3 groundColor;\\\\n\\\\t};\\\\n\\\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\\\n\\\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\\\n\\\\t\\\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\\\n\\\\t\\\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\\\n\\\\t\\\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\\\n\\\\t\\\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\\\n\\\\t\\\\t\\\\tirradiance *= PI;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\treturn irradiance;\\\\n\\\\t}\\\\n#endif\\\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\\\n\\\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\\\n\\\\t\\\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\\\n\\\\t\\\\t#ifdef ENVMAP_TYPE_CUBE\\\\n\\\\t\\\\t\\\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\\\n\\\\t\\\\t\\\\t#ifdef TEXTURE_LOD_EXT\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\\\n\\\\t\\\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\\\n\\\\t\\\\t\\\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\\\n\\\\t\\\\t\\\\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\tvec4 envMapColor = vec4( 0.0 );\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\treturn PI * envMapColor.rgb * envMapIntensity;\\\\n\\\\t}\\\\n\\\\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\\\n\\\\t\\\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\\\n\\\\t\\\\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\\\n\\\\t\\\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\\\n\\\\t}\\\\n\\\\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\\\n\\\\t\\\\t#ifdef ENVMAP_MODE_REFLECTION\\\\n\\\\t\\\\t\\\\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\\\n\\\\t\\\\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\\\n\\\\t\\\\t#ifdef ENVMAP_TYPE_CUBE\\\\n\\\\t\\\\t\\\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\\\n\\\\t\\\\t\\\\t#ifdef TEXTURE_LOD_EXT\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\\\n\\\\t\\\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\\\n\\\\t\\\\t\\\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\\\n\\\\t\\\\t\\\\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\\\n\\\\t\\\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\\\n\\\\t\\\\t\\\\tvec2 sampleUV;\\\\n\\\\t\\\\t\\\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\\\n\\\\t\\\\t\\\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\\\n\\\\t\\\\t\\\\t#ifdef TEXTURE_LOD_EXT\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\\\n\\\\t\\\\t#elif defined( ENVMAP_TYPE_SPHERE )\\\\n\\\\t\\\\t\\\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\\\n\\\\t\\\\t\\\\t#ifdef TEXTURE_LOD_EXT\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\treturn envMapColor.rgb * envMapIntensity;\\\\n\\\\t}\\\\n#endif\\\\n\\\";\\n\\n\\tvar lights_phong_fragment = \\\"BlinnPhongMaterial material;\\\\nmaterial.diffuseColor = diffuseColor.rgb;\\\\nmaterial.specularColor = specular;\\\\nmaterial.specularShininess = shininess;\\\\nmaterial.specularStrength = specularStrength;\\\\n\\\";\\n\\n\\tvar lights_phong_pars_fragment = \\\"varying vec3 vViewPosition;\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\nstruct BlinnPhongMaterial {\\\\n\\\\tvec3\\\\tdiffuseColor;\\\\n\\\\tvec3\\\\tspecularColor;\\\\n\\\\tfloat\\\\tspecularShininess;\\\\n\\\\tfloat\\\\tspecularStrength;\\\\n};\\\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\t#ifdef TOON\\\\n\\\\t\\\\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\\\n\\\\t#else\\\\n\\\\t\\\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\\\n\\\\t\\\\tvec3 irradiance = dotNL * directLight.color;\\\\n\\\\t#endif\\\\n\\\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\\\n\\\\t\\\\tirradiance *= PI;\\\\n\\\\t#endif\\\\n\\\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\\\n\\\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\\\n}\\\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\\\n}\\\\n#define RE_Direct\\\\t\\\\t\\\\t\\\\tRE_Direct_BlinnPhong\\\\n#define RE_IndirectDiffuse\\\\t\\\\tRE_IndirectDiffuse_BlinnPhong\\\\n#define Material_LightProbeLOD( material )\\\\t(0)\\\\n\\\";\\n\\n\\tvar lights_physical_fragment = \\\"PhysicalMaterial material;\\\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\\\n#ifdef STANDARD\\\\n\\\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\\\n#else\\\\n\\\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\\\n\\\\tmaterial.clearCoat = saturate( clearCoat );\\\\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\\\n#endif\\\\n\\\";\\n\\n\\tvar lights_physical_pars_fragment = \\\"struct PhysicalMaterial {\\\\n\\\\tvec3\\\\tdiffuseColor;\\\\n\\\\tfloat\\\\tspecularRoughness;\\\\n\\\\tvec3\\\\tspecularColor;\\\\n\\\\t#ifndef STANDARD\\\\n\\\\t\\\\tfloat clearCoat;\\\\n\\\\t\\\\tfloat clearCoatRoughness;\\\\n\\\\t#endif\\\\n};\\\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\\\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\\\\n\\\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\\\n}\\\\n#if NUM_RECT_AREA_LIGHTS > 0\\\\n\\\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\t\\\\tvec3 normal = geometry.normal;\\\\n\\\\t\\\\tvec3 viewDir = geometry.viewDir;\\\\n\\\\t\\\\tvec3 position = geometry.position;\\\\n\\\\t\\\\tvec3 lightPos = rectAreaLight.position;\\\\n\\\\t\\\\tvec3 halfWidth = rectAreaLight.halfWidth;\\\\n\\\\t\\\\tvec3 halfHeight = rectAreaLight.halfHeight;\\\\n\\\\t\\\\tvec3 lightColor = rectAreaLight.color;\\\\n\\\\t\\\\tfloat roughness = material.specularRoughness;\\\\n\\\\t\\\\tvec3 rectCoords[ 4 ];\\\\n\\\\t\\\\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\\\\t\\\\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\\\\n\\\\t\\\\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\\\\n\\\\t\\\\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\\\\n\\\\t\\\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\\\n\\\\t\\\\tfloat norm = texture2D( ltcMag, uv ).a;\\\\n\\\\t\\\\tvec4 t = texture2D( ltcMat, uv );\\\\n\\\\t\\\\tmat3 mInv = mat3(\\\\n\\\\t\\\\t\\\\tvec3(   1,   0, t.y ),\\\\n\\\\t\\\\t\\\\tvec3(   0, t.z,   0 ),\\\\n\\\\t\\\\t\\\\tvec3( t.w,   0, t.x )\\\\n\\\\t\\\\t);\\\\n\\\\t\\\\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\\\n\\\\t\\\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\\\\n\\\\t}\\\\n#endif\\\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\\\n\\\\tvec3 irradiance = dotNL * directLight.color;\\\\n\\\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\\\n\\\\t\\\\tirradiance *= PI;\\\\n\\\\t#endif\\\\n\\\\t#ifndef STANDARD\\\\n\\\\t\\\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\\\n\\\\t#else\\\\n\\\\t\\\\tfloat clearCoatDHR = 0.0;\\\\n\\\\t#endif\\\\n\\\\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\\\n\\\\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\\\n\\\\t#ifndef STANDARD\\\\n\\\\t\\\\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\\\n\\\\t#endif\\\\n}\\\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\\\n}\\\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\t#ifndef STANDARD\\\\n\\\\t\\\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\\\n\\\\t\\\\tfloat dotNL = dotNV;\\\\n\\\\t\\\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\\\n\\\\t#else\\\\n\\\\t\\\\tfloat clearCoatDHR = 0.0;\\\\n\\\\t#endif\\\\n\\\\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\\\n\\\\t#ifndef STANDARD\\\\n\\\\t\\\\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\\\n\\\\t#endif\\\\n}\\\\n#define RE_Direct\\\\t\\\\t\\\\t\\\\tRE_Direct_Physical\\\\n#define RE_Direct_RectArea\\\\t\\\\tRE_Direct_RectArea_Physical\\\\n#define RE_IndirectDiffuse\\\\t\\\\tRE_IndirectDiffuse_Physical\\\\n#define RE_IndirectSpecular\\\\t\\\\tRE_IndirectSpecular_Physical\\\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\\\n\\\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\\\n}\\\\n\\\";\\n\\n\\tvar lights_template = \\\"\\\\nGeometricContext geometry;\\\\ngeometry.position = - vViewPosition;\\\\ngeometry.normal = normal;\\\\ngeometry.viewDir = normalize( vViewPosition );\\\\nIncidentLight directLight;\\\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\\\n\\\\tPointLight pointLight;\\\\n\\\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tpointLight = pointLights[ i ];\\\\n\\\\t\\\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\\\n\\\\t\\\\t#ifdef USE_SHADOWMAP\\\\n\\\\t\\\\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\tRE_Direct( directLight, geometry, material, reflectedLight );\\\\n\\\\t}\\\\n#endif\\\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\\\n\\\\tSpotLight spotLight;\\\\n\\\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tspotLight = spotLights[ i ];\\\\n\\\\t\\\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\\\n\\\\t\\\\t#ifdef USE_SHADOWMAP\\\\n\\\\t\\\\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\tRE_Direct( directLight, geometry, material, reflectedLight );\\\\n\\\\t}\\\\n#endif\\\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\\\n\\\\tDirectionalLight directionalLight;\\\\n\\\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tdirectionalLight = directionalLights[ i ];\\\\n\\\\t\\\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\\\n\\\\t\\\\t#ifdef USE_SHADOWMAP\\\\n\\\\t\\\\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\tRE_Direct( directLight, geometry, material, reflectedLight );\\\\n\\\\t}\\\\n#endif\\\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\\\n\\\\tRectAreaLight rectAreaLight;\\\\n\\\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\\\n\\\\t\\\\trectAreaLight = rectAreaLights[ i ];\\\\n\\\\t\\\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\\\n\\\\t}\\\\n#endif\\\\n#if defined( RE_IndirectDiffuse )\\\\n\\\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\\\n\\\\t#ifdef USE_LIGHTMAP\\\\n\\\\t\\\\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\\\n\\\\t\\\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\\\n\\\\t\\\\t\\\\tlightMapIrradiance *= PI;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\tirradiance += lightMapIrradiance;\\\\n\\\\t#endif\\\\n\\\\t#if ( NUM_HEMI_LIGHTS > 0 )\\\\n\\\\t\\\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\\\n\\\\t\\\\t\\\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\\\n\\\\t\\\\t}\\\\n\\\\t#endif\\\\n\\\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\\\n\\\\t\\\\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\\\n\\\\t#endif\\\\n\\\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\\\n#endif\\\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\\\n\\\\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\\\n\\\\t#ifndef STANDARD\\\\n\\\\t\\\\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\\\\n\\\\t#else\\\\n\\\\t\\\\tvec3 clearCoatRadiance = vec3( 0.0 );\\\\n\\\\t#endif\\\\n\\\\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\\\\n#endif\\\\n\\\";\\n\\n\\tvar logdepthbuf_fragment = \\\"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\\\n\\\\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\\\\n#endif\\\";\\n\\n\\tvar logdepthbuf_pars_fragment = \\\"#ifdef USE_LOGDEPTHBUF\\\\n\\\\tuniform float logDepthBufFC;\\\\n\\\\t#ifdef USE_LOGDEPTHBUF_EXT\\\\n\\\\t\\\\tvarying float vFragDepth;\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar logdepthbuf_pars_vertex = \\\"#ifdef USE_LOGDEPTHBUF\\\\n\\\\t#ifdef USE_LOGDEPTHBUF_EXT\\\\n\\\\t\\\\tvarying float vFragDepth;\\\\n\\\\t#endif\\\\n\\\\tuniform float logDepthBufFC;\\\\n#endif\\\";\\n\\n\\tvar logdepthbuf_vertex = \\\"#ifdef USE_LOGDEPTHBUF\\\\n\\\\t#ifdef USE_LOGDEPTHBUF_EXT\\\\n\\\\t\\\\tvFragDepth = 1.0 + gl_Position.w;\\\\n\\\\t#else\\\\n\\\\t\\\\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\\\\n\\\\t\\\\tgl_Position.z *= gl_Position.w;\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar map_fragment = \\\"#ifdef USE_MAP\\\\n\\\\tvec4 texelColor = texture2D( map, vUv );\\\\n\\\\ttexelColor = mapTexelToLinear( texelColor );\\\\n\\\\tdiffuseColor *= texelColor;\\\\n#endif\\\\n\\\";\\n\\n\\tvar map_pars_fragment = \\\"#ifdef USE_MAP\\\\n\\\\tuniform sampler2D map;\\\\n#endif\\\\n\\\";\\n\\n\\tvar map_particle_fragment = \\\"#ifdef USE_MAP\\\\n\\\\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\\\n\\\\tvec4 mapTexel = texture2D( map, uv );\\\\n\\\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\\\n#endif\\\\n\\\";\\n\\n\\tvar map_particle_pars_fragment = \\\"#ifdef USE_MAP\\\\n\\\\tuniform mat3 uvTransform;\\\\n\\\\tuniform sampler2D map;\\\\n#endif\\\\n\\\";\\n\\n\\tvar metalnessmap_fragment = \\\"float metalnessFactor = metalness;\\\\n#ifdef USE_METALNESSMAP\\\\n\\\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\\\n\\\\tmetalnessFactor *= texelMetalness.b;\\\\n#endif\\\\n\\\";\\n\\n\\tvar metalnessmap_pars_fragment = \\\"#ifdef USE_METALNESSMAP\\\\n\\\\tuniform sampler2D metalnessMap;\\\\n#endif\\\";\\n\\n\\tvar morphnormal_vertex = \\\"#ifdef USE_MORPHNORMALS\\\\n\\\\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\\\n\\\\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\\\n\\\\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\\\n\\\\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\\\n#endif\\\\n\\\";\\n\\n\\tvar morphtarget_pars_vertex = \\\"#ifdef USE_MORPHTARGETS\\\\n\\\\t#ifndef USE_MORPHNORMALS\\\\n\\\\tuniform float morphTargetInfluences[ 8 ];\\\\n\\\\t#else\\\\n\\\\tuniform float morphTargetInfluences[ 4 ];\\\\n\\\\t#endif\\\\n#endif\\\";\\n\\n\\tvar morphtarget_vertex = \\\"#ifdef USE_MORPHTARGETS\\\\n\\\\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\\\n\\\\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\\\n\\\\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\\\n\\\\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\\\n\\\\t#ifndef USE_MORPHNORMALS\\\\n\\\\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\\\n\\\\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\\\n\\\\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\\\n\\\\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar normal_fragment = \\\"#ifdef FLAT_SHADED\\\\n\\\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\\\n\\\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\\\n\\\\tvec3 normal = normalize( cross( fdx, fdy ) );\\\\n#else\\\\n\\\\tvec3 normal = normalize( vNormal );\\\\n\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\\\n\\\\t#endif\\\\n#endif\\\\n#ifdef USE_NORMALMAP\\\\n\\\\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\\\n#elif defined( USE_BUMPMAP )\\\\n\\\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\\\n#endif\\\\n\\\";\\n\\n\\tvar normalmap_pars_fragment = \\\"#ifdef USE_NORMALMAP\\\\n\\\\tuniform sampler2D normalMap;\\\\n\\\\tuniform vec2 normalScale;\\\\n\\\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\\\n\\\\t\\\\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\\\n\\\\t\\\\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\\\n\\\\t\\\\tvec2 st0 = dFdx( vUv.st );\\\\n\\\\t\\\\tvec2 st1 = dFdy( vUv.st );\\\\n\\\\t\\\\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\\\n\\\\t\\\\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\\\n\\\\t\\\\tvec3 N = normalize( surf_norm );\\\\n\\\\t\\\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\\\n\\\\t\\\\tmapN.xy = normalScale * mapN.xy;\\\\n\\\\t\\\\tmat3 tsn = mat3( S, T, N );\\\\n\\\\t\\\\treturn normalize( tsn * mapN );\\\\n\\\\t}\\\\n#endif\\\\n\\\";\\n\\n\\tvar packing = \\\"vec3 packNormalToRGB( const in vec3 normal ) {\\\\n\\\\treturn normalize( normal ) * 0.5 + 0.5;\\\\n}\\\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\\\n\\\\treturn 2.0 * rgb.xyz - 1.0;\\\\n}\\\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\\\nconst float ShiftRight8 = 1. / 256.;\\\\nvec4 packDepthToRGBA( const in float v ) {\\\\n\\\\tvec4 r = vec4( fract( v * PackFactors ), v );\\\\n\\\\tr.yzw -= r.xyz * ShiftRight8;\\\\treturn r * PackUpscale;\\\\n}\\\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\\\n\\\\treturn dot( v, UnpackFactors );\\\\n}\\\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\\\n\\\\treturn ( viewZ + near ) / ( near - far );\\\\n}\\\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\\\n\\\\treturn linearClipZ * ( near - far ) - near;\\\\n}\\\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\\\n\\\\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\\\n}\\\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\\\n\\\\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\\\n}\\\\n\\\";\\n\\n\\tvar premultiplied_alpha_fragment = \\\"#ifdef PREMULTIPLIED_ALPHA\\\\n\\\\tgl_FragColor.rgb *= gl_FragColor.a;\\\\n#endif\\\\n\\\";\\n\\n\\tvar project_vertex = \\\"vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\\\ngl_Position = projectionMatrix * mvPosition;\\\\n\\\";\\n\\n\\tvar dithering_fragment = \\\"#if defined( DITHERING )\\\\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\\\\n#endif\\\\n\\\";\\n\\n\\tvar dithering_pars_fragment = \\\"#if defined( DITHERING )\\\\n\\\\tvec3 dithering( vec3 color ) {\\\\n\\\\t\\\\tfloat grid_position = rand( gl_FragCoord.xy );\\\\n\\\\t\\\\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\\\n\\\\t\\\\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\\\n\\\\t\\\\treturn color + dither_shift_RGB;\\\\n\\\\t}\\\\n#endif\\\\n\\\";\\n\\n\\tvar roughnessmap_fragment = \\\"float roughnessFactor = roughness;\\\\n#ifdef USE_ROUGHNESSMAP\\\\n\\\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\\\n\\\\troughnessFactor *= texelRoughness.g;\\\\n#endif\\\\n\\\";\\n\\n\\tvar roughnessmap_pars_fragment = \\\"#ifdef USE_ROUGHNESSMAP\\\\n\\\\tuniform sampler2D roughnessMap;\\\\n#endif\\\";\\n\\n\\tvar shadowmap_pars_fragment = \\\"#ifdef USE_SHADOWMAP\\\\n\\\\t#if NUM_DIR_LIGHTS > 0\\\\n\\\\t\\\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\\\n\\\\t\\\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\\\n\\\\t#endif\\\\n\\\\t#if NUM_SPOT_LIGHTS > 0\\\\n\\\\t\\\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\\\n\\\\t\\\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\\\n\\\\t#endif\\\\n\\\\t#if NUM_POINT_LIGHTS > 0\\\\n\\\\t\\\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\\\n\\\\t\\\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\\\n\\\\t#endif\\\\n\\\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\\\n\\\\t\\\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\\\n\\\\t}\\\\n\\\\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\\\n\\\\t\\\\tconst vec2 offset = vec2( 0.0, 1.0 );\\\\n\\\\t\\\\tvec2 texelSize = vec2( 1.0 ) / size;\\\\n\\\\t\\\\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\\\n\\\\t\\\\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\\\n\\\\t\\\\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\\\n\\\\t\\\\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\\\n\\\\t\\\\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\\\n\\\\t\\\\tvec2 f = fract( uv * size + 0.5 );\\\\n\\\\t\\\\tfloat a = mix( lb, lt, f.y );\\\\n\\\\t\\\\tfloat b = mix( rb, rt, f.y );\\\\n\\\\t\\\\tfloat c = mix( a, b, f.x );\\\\n\\\\t\\\\treturn c;\\\\n\\\\t}\\\\n\\\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\\\n\\\\t\\\\tfloat shadow = 1.0;\\\\n\\\\t\\\\tshadowCoord.xyz /= shadowCoord.w;\\\\n\\\\t\\\\tshadowCoord.z += shadowBias;\\\\n\\\\t\\\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\\\n\\\\t\\\\tbool inFrustum = all( inFrustumVec );\\\\n\\\\t\\\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\\\n\\\\t\\\\tbool frustumTest = all( frustumTestVec );\\\\n\\\\t\\\\tif ( frustumTest ) {\\\\n\\\\t\\\\t#if defined( SHADOWMAP_TYPE_PCF )\\\\n\\\\t\\\\t\\\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\\\n\\\\t\\\\t\\\\tfloat dx0 = - texelSize.x * shadowRadius;\\\\n\\\\t\\\\t\\\\tfloat dy0 = - texelSize.y * shadowRadius;\\\\n\\\\t\\\\t\\\\tfloat dx1 = + texelSize.x * shadowRadius;\\\\n\\\\t\\\\t\\\\tfloat dy1 = + texelSize.y * shadowRadius;\\\\n\\\\t\\\\t\\\\tshadow = (\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\\\n\\\\t\\\\t\\\\t) * ( 1.0 / 9.0 );\\\\n\\\\t\\\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\\\n\\\\t\\\\t\\\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\\\n\\\\t\\\\t\\\\tfloat dx0 = - texelSize.x * shadowRadius;\\\\n\\\\t\\\\t\\\\tfloat dy0 = - texelSize.y * shadowRadius;\\\\n\\\\t\\\\t\\\\tfloat dx1 = + texelSize.x * shadowRadius;\\\\n\\\\t\\\\t\\\\tfloat dy1 = + texelSize.y * shadowRadius;\\\\n\\\\t\\\\t\\\\tshadow = (\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\\\n\\\\t\\\\t\\\\t) * ( 1.0 / 9.0 );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\treturn shadow;\\\\n\\\\t}\\\\n\\\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\\\n\\\\t\\\\tvec3 absV = abs( v );\\\\n\\\\t\\\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\\\n\\\\t\\\\tabsV *= scaleToCube;\\\\n\\\\t\\\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\\\n\\\\t\\\\tvec2 planar = v.xy;\\\\n\\\\t\\\\tfloat almostATexel = 1.5 * texelSizeY;\\\\n\\\\t\\\\tfloat almostOne = 1.0 - almostATexel;\\\\n\\\\t\\\\tif ( absV.z >= almostOne ) {\\\\n\\\\t\\\\t\\\\tif ( v.z > 0.0 )\\\\n\\\\t\\\\t\\\\t\\\\tplanar.x = 4.0 - v.x;\\\\n\\\\t\\\\t} else if ( absV.x >= almostOne ) {\\\\n\\\\t\\\\t\\\\tfloat signX = sign( v.x );\\\\n\\\\t\\\\t\\\\tplanar.x = v.z * signX + 2.0 * signX;\\\\n\\\\t\\\\t} else if ( absV.y >= almostOne ) {\\\\n\\\\t\\\\t\\\\tfloat signY = sign( v.y );\\\\n\\\\t\\\\t\\\\tplanar.x = v.x + 2.0 * signY + 2.0;\\\\n\\\\t\\\\t\\\\tplanar.y = v.z * signY - 2.0;\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\\\n\\\\t}\\\\n\\\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\\\n\\\\t\\\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\\\n\\\\t\\\\tvec3 lightToPosition = shadowCoord.xyz;\\\\n\\\\t\\\\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\\\t\\\\tdp += shadowBias;\\\\n\\\\t\\\\tvec3 bd3D = normalize( lightToPosition );\\\\n\\\\t\\\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\\\n\\\\t\\\\t\\\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\\\n\\\\t\\\\t\\\\treturn (\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\\\n\\\\t\\\\t\\\\t) * ( 1.0 / 9.0 );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n#endif\\\\n\\\";\\n\\n\\tvar shadowmap_pars_vertex = \\\"#ifdef USE_SHADOWMAP\\\\n\\\\t#if NUM_DIR_LIGHTS > 0\\\\n\\\\t\\\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\\\n\\\\t\\\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\\\n\\\\t#endif\\\\n\\\\t#if NUM_SPOT_LIGHTS > 0\\\\n\\\\t\\\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\\\n\\\\t\\\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\\\n\\\\t#endif\\\\n\\\\t#if NUM_POINT_LIGHTS > 0\\\\n\\\\t\\\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\\\n\\\\t\\\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar shadowmap_vertex = \\\"#ifdef USE_SHADOWMAP\\\\n\\\\t#if NUM_DIR_LIGHTS > 0\\\\n\\\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\\\n\\\\t}\\\\n\\\\t#endif\\\\n\\\\t#if NUM_SPOT_LIGHTS > 0\\\\n\\\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\\\n\\\\t}\\\\n\\\\t#endif\\\\n\\\\t#if NUM_POINT_LIGHTS > 0\\\\n\\\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\\\n\\\\t}\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar shadowmask_pars_fragment = \\\"float getShadowMask() {\\\\n\\\\tfloat shadow = 1.0;\\\\n\\\\t#ifdef USE_SHADOWMAP\\\\n\\\\t#if NUM_DIR_LIGHTS > 0\\\\n\\\\tDirectionalLight directionalLight;\\\\n\\\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tdirectionalLight = directionalLights[ i ];\\\\n\\\\t\\\\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\\\n\\\\t}\\\\n\\\\t#endif\\\\n\\\\t#if NUM_SPOT_LIGHTS > 0\\\\n\\\\tSpotLight spotLight;\\\\n\\\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tspotLight = spotLights[ i ];\\\\n\\\\t\\\\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\\\n\\\\t}\\\\n\\\\t#endif\\\\n\\\\t#if NUM_POINT_LIGHTS > 0\\\\n\\\\tPointLight pointLight;\\\\n\\\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tpointLight = pointLights[ i ];\\\\n\\\\t\\\\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\\\n\\\\t}\\\\n\\\\t#endif\\\\n\\\\t#endif\\\\n\\\\treturn shadow;\\\\n}\\\\n\\\";\\n\\n\\tvar skinbase_vertex = \\\"#ifdef USE_SKINNING\\\\n\\\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\\\n\\\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\\\n\\\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\\\n\\\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\\\n#endif\\\";\\n\\n\\tvar skinning_pars_vertex = \\\"#ifdef USE_SKINNING\\\\n\\\\tuniform mat4 bindMatrix;\\\\n\\\\tuniform mat4 bindMatrixInverse;\\\\n\\\\t#ifdef BONE_TEXTURE\\\\n\\\\t\\\\tuniform sampler2D boneTexture;\\\\n\\\\t\\\\tuniform int boneTextureSize;\\\\n\\\\t\\\\tmat4 getBoneMatrix( const in float i ) {\\\\n\\\\t\\\\t\\\\tfloat j = i * 4.0;\\\\n\\\\t\\\\t\\\\tfloat x = mod( j, float( boneTextureSize ) );\\\\n\\\\t\\\\t\\\\tfloat y = floor( j / float( boneTextureSize ) );\\\\n\\\\t\\\\t\\\\tfloat dx = 1.0 / float( boneTextureSize );\\\\n\\\\t\\\\t\\\\tfloat dy = 1.0 / float( boneTextureSize );\\\\n\\\\t\\\\t\\\\ty = dy * ( y + 0.5 );\\\\n\\\\t\\\\t\\\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\\\n\\\\t\\\\t\\\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\\\n\\\\t\\\\t\\\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\\\n\\\\t\\\\t\\\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\\\n\\\\t\\\\t\\\\tmat4 bone = mat4( v1, v2, v3, v4 );\\\\n\\\\t\\\\t\\\\treturn bone;\\\\n\\\\t\\\\t}\\\\n\\\\t#else\\\\n\\\\t\\\\tuniform mat4 boneMatrices[ MAX_BONES ];\\\\n\\\\t\\\\tmat4 getBoneMatrix( const in float i ) {\\\\n\\\\t\\\\t\\\\tmat4 bone = boneMatrices[ int(i) ];\\\\n\\\\t\\\\t\\\\treturn bone;\\\\n\\\\t\\\\t}\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar skinning_vertex = \\\"#ifdef USE_SKINNING\\\\n\\\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\\\n\\\\tvec4 skinned = vec4( 0.0 );\\\\n\\\\tskinned += boneMatX * skinVertex * skinWeight.x;\\\\n\\\\tskinned += boneMatY * skinVertex * skinWeight.y;\\\\n\\\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\\\n\\\\tskinned += boneMatW * skinVertex * skinWeight.w;\\\\n\\\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\\\n#endif\\\\n\\\";\\n\\n\\tvar skinnormal_vertex = \\\"#ifdef USE_SKINNING\\\\n\\\\tmat4 skinMatrix = mat4( 0.0 );\\\\n\\\\tskinMatrix += skinWeight.x * boneMatX;\\\\n\\\\tskinMatrix += skinWeight.y * boneMatY;\\\\n\\\\tskinMatrix += skinWeight.z * boneMatZ;\\\\n\\\\tskinMatrix += skinWeight.w * boneMatW;\\\\n\\\\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\\\n\\\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\\\n#endif\\\\n\\\";\\n\\n\\tvar specularmap_fragment = \\\"float specularStrength;\\\\n#ifdef USE_SPECULARMAP\\\\n\\\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\\\n\\\\tspecularStrength = texelSpecular.r;\\\\n#else\\\\n\\\\tspecularStrength = 1.0;\\\\n#endif\\\";\\n\\n\\tvar specularmap_pars_fragment = \\\"#ifdef USE_SPECULARMAP\\\\n\\\\tuniform sampler2D specularMap;\\\\n#endif\\\";\\n\\n\\tvar tonemapping_fragment = \\\"#if defined( TONE_MAPPING )\\\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\\\n#endif\\\\n\\\";\\n\\n\\tvar tonemapping_pars_fragment = \\\"#ifndef saturate\\\\n\\\\t#define saturate(a) clamp( a, 0.0, 1.0 )\\\\n#endif\\\\nuniform float toneMappingExposure;\\\\nuniform float toneMappingWhitePoint;\\\\nvec3 LinearToneMapping( vec3 color ) {\\\\n\\\\treturn toneMappingExposure * color;\\\\n}\\\\nvec3 ReinhardToneMapping( vec3 color ) {\\\\n\\\\tcolor *= toneMappingExposure;\\\\n\\\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\\\n}\\\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\\\n\\\\tcolor *= toneMappingExposure;\\\\n\\\\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\\\n}\\\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\\\n\\\\tcolor *= toneMappingExposure;\\\\n\\\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\\\n\\\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\\\n}\\\\n\\\";\\n\\n\\tvar uv_pars_fragment = \\\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\\\n\\\\tvarying vec2 vUv;\\\\n#endif\\\";\\n\\n\\tvar uv_pars_vertex = \\\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\\\n\\\\tvarying vec2 vUv;\\\\n\\\\tuniform mat3 uvTransform;\\\\n#endif\\\\n\\\";\\n\\n\\tvar uv_vertex = \\\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\\\n\\\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\\\n#endif\\\";\\n\\n\\tvar uv2_pars_fragment = \\\"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\\\n\\\\tvarying vec2 vUv2;\\\\n#endif\\\";\\n\\n\\tvar uv2_pars_vertex = \\\"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\\\n\\\\tattribute vec2 uv2;\\\\n\\\\tvarying vec2 vUv2;\\\\n#endif\\\";\\n\\n\\tvar uv2_vertex = \\\"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\\\n\\\\tvUv2 = uv2;\\\\n#endif\\\";\\n\\n\\tvar worldpos_vertex = \\\"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\\\\n\\\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\\\n#endif\\\\n\\\";\\n\\n\\tvar cube_frag = \\\"uniform samplerCube tCube;\\\\nuniform float tFlip;\\\\nuniform float opacity;\\\\nvarying vec3 vWorldPosition;\\\\nvoid main() {\\\\n\\\\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\\\n\\\\tgl_FragColor.a *= opacity;\\\\n}\\\\n\\\";\\n\\n\\tvar cube_vert = \\\"varying vec3 vWorldPosition;\\\\n#include <common>\\\\nvoid main() {\\\\n\\\\tvWorldPosition = transformDirection( position, modelMatrix );\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\tgl_Position.z = gl_Position.w;\\\\n}\\\\n\\\";\\n\\n\\tvar depth_frag = \\\"#if DEPTH_PACKING == 3200\\\\n\\\\tuniform float opacity;\\\\n#endif\\\\n#include <common>\\\\n#include <packing>\\\\n#include <uv_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( 1.0 );\\\\n\\\\t#if DEPTH_PACKING == 3200\\\\n\\\\t\\\\tdiffuseColor.a = opacity;\\\\n\\\\t#endif\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#if DEPTH_PACKING == 3200\\\\n\\\\t\\\\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\\\\n\\\\t#elif DEPTH_PACKING == 3201\\\\n\\\\t\\\\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\\\n\\\\t#endif\\\\n}\\\\n\\\";\\n\\n\\tvar depth_vert = \\\"#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <displacementmap_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#ifdef USE_DISPLACEMENTMAP\\\\n\\\\t\\\\t#include <beginnormal_vertex>\\\\n\\\\t\\\\t#include <morphnormal_vertex>\\\\n\\\\t\\\\t#include <skinnormal_vertex>\\\\n\\\\t#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <displacementmap_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n}\\\\n\\\";\\n\\n\\tvar distanceRGBA_frag = \\\"#define DISTANCE\\\\nuniform vec3 referencePosition;\\\\nuniform float nearDistance;\\\\nuniform float farDistance;\\\\nvarying vec3 vWorldPosition;\\\\n#include <common>\\\\n#include <packing>\\\\n#include <uv_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main () {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( 1.0 );\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\tfloat dist = length( vWorldPosition - referencePosition );\\\\n\\\\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\\\n\\\\tdist = saturate( dist );\\\\n\\\\tgl_FragColor = packDepthToRGBA( dist );\\\\n}\\\\n\\\";\\n\\n\\tvar distanceRGBA_vert = \\\"#define DISTANCE\\\\nvarying vec3 vWorldPosition;\\\\n#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <displacementmap_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#ifdef USE_DISPLACEMENTMAP\\\\n\\\\t\\\\t#include <beginnormal_vertex>\\\\n\\\\t\\\\t#include <morphnormal_vertex>\\\\n\\\\t\\\\t#include <skinnormal_vertex>\\\\n\\\\t#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <displacementmap_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\tvWorldPosition = worldPosition.xyz;\\\\n}\\\\n\\\";\\n\\n\\tvar equirect_frag = \\\"uniform sampler2D tEquirect;\\\\nvarying vec3 vWorldPosition;\\\\n#include <common>\\\\nvoid main() {\\\\n\\\\tvec3 direction = normalize( vWorldPosition );\\\\n\\\\tvec2 sampleUV;\\\\n\\\\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\\\n\\\\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\\\n\\\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\\\n}\\\\n\\\";\\n\\n\\tvar equirect_vert = \\\"varying vec3 vWorldPosition;\\\\n#include <common>\\\\nvoid main() {\\\\n\\\\tvWorldPosition = transformDirection( position, modelMatrix );\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <project_vertex>\\\\n}\\\\n\\\";\\n\\n\\tvar linedashed_frag = \\\"uniform vec3 diffuse;\\\\nuniform float opacity;\\\\nuniform float dashSize;\\\\nuniform float totalSize;\\\\nvarying float vLineDistance;\\\\n#include <common>\\\\n#include <color_pars_fragment>\\\\n#include <fog_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\\\n\\\\t\\\\tdiscard;\\\\n\\\\t}\\\\n\\\\tvec3 outgoingLight = vec3( 0.0 );\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\toutgoingLight = diffuseColor.rgb;\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n}\\\\n\\\";\\n\\n\\tvar linedashed_vert = \\\"uniform float scale;\\\\nattribute float lineDistance;\\\\nvarying float vLineDistance;\\\\n#include <common>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <color_vertex>\\\\n\\\\tvLineDistance = scale * lineDistance;\\\\n\\\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\\\n\\\\tgl_Position = projectionMatrix * mvPosition;\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\\n\\\";\\n\\n\\tvar meshbasic_frag = \\\"uniform vec3 diffuse;\\\\nuniform float opacity;\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\n#include <common>\\\\n#include <color_pars_fragment>\\\\n#include <uv_pars_fragment>\\\\n#include <uv2_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <aomap_pars_fragment>\\\\n#include <lightmap_pars_fragment>\\\\n#include <envmap_pars_fragment>\\\\n#include <fog_pars_fragment>\\\\n#include <specularmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\t#include <specularmap_fragment>\\\\n\\\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\\\n\\\\t#ifdef USE_LIGHTMAP\\\\n\\\\t\\\\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\\\n\\\\t#else\\\\n\\\\t\\\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\\\n\\\\t#endif\\\\n\\\\t#include <aomap_fragment>\\\\n\\\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\\\n\\\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\\\n\\\\t#include <envmap_fragment>\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n}\\\\n\\\";\\n\\n\\tvar meshbasic_vert = \\\"#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <uv2_pars_vertex>\\\\n#include <envmap_pars_vertex>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <uv2_vertex>\\\\n\\\\t#include <color_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#ifdef USE_ENVMAP\\\\n\\\\t#include <beginnormal_vertex>\\\\n\\\\t#include <morphnormal_vertex>\\\\n\\\\t#include <skinnormal_vertex>\\\\n\\\\t#include <defaultnormal_vertex>\\\\n\\\\t#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\t#include <envmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\\n\\\";\\n\\n\\tvar meshlambert_frag = \\\"uniform vec3 diffuse;\\\\nuniform vec3 emissive;\\\\nuniform float opacity;\\\\nvarying vec3 vLightFront;\\\\n#ifdef DOUBLE_SIDED\\\\n\\\\tvarying vec3 vLightBack;\\\\n#endif\\\\n#include <common>\\\\n#include <packing>\\\\n#include <dithering_pars_fragment>\\\\n#include <color_pars_fragment>\\\\n#include <uv_pars_fragment>\\\\n#include <uv2_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <aomap_pars_fragment>\\\\n#include <lightmap_pars_fragment>\\\\n#include <emissivemap_pars_fragment>\\\\n#include <envmap_pars_fragment>\\\\n#include <bsdfs>\\\\n#include <lights_pars>\\\\n#include <fog_pars_fragment>\\\\n#include <shadowmap_pars_fragment>\\\\n#include <shadowmask_pars_fragment>\\\\n#include <specularmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\\\n\\\\tvec3 totalEmissiveRadiance = emissive;\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\t#include <specularmap_fragment>\\\\n\\\\t#include <emissivemap_fragment>\\\\n\\\\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\\\n\\\\t#include <lightmap_fragment>\\\\n\\\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\\\n\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\\\n\\\\t#else\\\\n\\\\t\\\\treflectedLight.directDiffuse = vLightFront;\\\\n\\\\t#endif\\\\n\\\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\\\n\\\\t#include <aomap_fragment>\\\\n\\\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\\\n\\\\t#include <envmap_fragment>\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <dithering_fragment>\\\\n}\\\\n\\\";\\n\\n\\tvar meshlambert_vert = \\\"#define LAMBERT\\\\nvarying vec3 vLightFront;\\\\n#ifdef DOUBLE_SIDED\\\\n\\\\tvarying vec3 vLightBack;\\\\n#endif\\\\n#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <uv2_pars_vertex>\\\\n#include <envmap_pars_vertex>\\\\n#include <bsdfs>\\\\n#include <lights_pars>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <shadowmap_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <uv2_vertex>\\\\n\\\\t#include <color_vertex>\\\\n\\\\t#include <beginnormal_vertex>\\\\n\\\\t#include <morphnormal_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#include <skinnormal_vertex>\\\\n\\\\t#include <defaultnormal_vertex>\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <envmap_vertex>\\\\n\\\\t#include <lights_lambert_vertex>\\\\n\\\\t#include <shadowmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\\n\\\";\\n\\n\\tvar meshphong_frag = \\\"#define PHONG\\\\nuniform vec3 diffuse;\\\\nuniform vec3 emissive;\\\\nuniform vec3 specular;\\\\nuniform float shininess;\\\\nuniform float opacity;\\\\n#include <common>\\\\n#include <packing>\\\\n#include <dithering_pars_fragment>\\\\n#include <color_pars_fragment>\\\\n#include <uv_pars_fragment>\\\\n#include <uv2_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <aomap_pars_fragment>\\\\n#include <lightmap_pars_fragment>\\\\n#include <emissivemap_pars_fragment>\\\\n#include <envmap_pars_fragment>\\\\n#include <gradientmap_pars_fragment>\\\\n#include <fog_pars_fragment>\\\\n#include <bsdfs>\\\\n#include <lights_pars>\\\\n#include <lights_phong_pars_fragment>\\\\n#include <shadowmap_pars_fragment>\\\\n#include <bumpmap_pars_fragment>\\\\n#include <normalmap_pars_fragment>\\\\n#include <specularmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\\\n\\\\tvec3 totalEmissiveRadiance = emissive;\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\t#include <specularmap_fragment>\\\\n\\\\t#include <normal_fragment>\\\\n\\\\t#include <emissivemap_fragment>\\\\n\\\\t#include <lights_phong_fragment>\\\\n\\\\t#include <lights_template>\\\\n\\\\t#include <aomap_fragment>\\\\n\\\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\\\n\\\\t#include <envmap_fragment>\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <dithering_fragment>\\\\n}\\\\n\\\";\\n\\n\\tvar meshphong_vert = \\\"#define PHONG\\\\nvarying vec3 vViewPosition;\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\n#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <uv2_pars_vertex>\\\\n#include <displacementmap_pars_vertex>\\\\n#include <envmap_pars_vertex>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <shadowmap_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <uv2_vertex>\\\\n\\\\t#include <color_vertex>\\\\n\\\\t#include <beginnormal_vertex>\\\\n\\\\t#include <morphnormal_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#include <skinnormal_vertex>\\\\n\\\\t#include <defaultnormal_vertex>\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvNormal = normalize( transformedNormal );\\\\n#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <displacementmap_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\tvViewPosition = - mvPosition.xyz;\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <envmap_vertex>\\\\n\\\\t#include <shadowmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\\n\\\";\\n\\n\\tvar meshphysical_frag = \\\"#define PHYSICAL\\\\nuniform vec3 diffuse;\\\\nuniform vec3 emissive;\\\\nuniform float roughness;\\\\nuniform float metalness;\\\\nuniform float opacity;\\\\n#ifndef STANDARD\\\\n\\\\tuniform float clearCoat;\\\\n\\\\tuniform float clearCoatRoughness;\\\\n#endif\\\\nvarying vec3 vViewPosition;\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\n#include <common>\\\\n#include <packing>\\\\n#include <dithering_pars_fragment>\\\\n#include <color_pars_fragment>\\\\n#include <uv_pars_fragment>\\\\n#include <uv2_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <aomap_pars_fragment>\\\\n#include <lightmap_pars_fragment>\\\\n#include <emissivemap_pars_fragment>\\\\n#include <envmap_pars_fragment>\\\\n#include <fog_pars_fragment>\\\\n#include <bsdfs>\\\\n#include <cube_uv_reflection_fragment>\\\\n#include <lights_pars>\\\\n#include <lights_physical_pars_fragment>\\\\n#include <shadowmap_pars_fragment>\\\\n#include <bumpmap_pars_fragment>\\\\n#include <normalmap_pars_fragment>\\\\n#include <roughnessmap_pars_fragment>\\\\n#include <metalnessmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\\\n\\\\tvec3 totalEmissiveRadiance = emissive;\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\t#include <roughnessmap_fragment>\\\\n\\\\t#include <metalnessmap_fragment>\\\\n\\\\t#include <normal_fragment>\\\\n\\\\t#include <emissivemap_fragment>\\\\n\\\\t#include <lights_physical_fragment>\\\\n\\\\t#include <lights_template>\\\\n\\\\t#include <aomap_fragment>\\\\n\\\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <dithering_fragment>\\\\n}\\\\n\\\";\\n\\n\\tvar meshphysical_vert = \\\"#define PHYSICAL\\\\nvarying vec3 vViewPosition;\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\n#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <uv2_pars_vertex>\\\\n#include <displacementmap_pars_vertex>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <shadowmap_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <uv2_vertex>\\\\n\\\\t#include <color_vertex>\\\\n\\\\t#include <beginnormal_vertex>\\\\n\\\\t#include <morphnormal_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#include <skinnormal_vertex>\\\\n\\\\t#include <defaultnormal_vertex>\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvNormal = normalize( transformedNormal );\\\\n#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <displacementmap_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\tvViewPosition = - mvPosition.xyz;\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <shadowmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\\n\\\";\\n\\n\\tvar normal_frag = \\\"#define NORMAL\\\\nuniform float opacity;\\\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\\\n\\\\tvarying vec3 vViewPosition;\\\\n#endif\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\n#include <packing>\\\\n#include <uv_pars_fragment>\\\\n#include <bumpmap_pars_fragment>\\\\n#include <normalmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <normal_fragment>\\\\n\\\\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\\\n}\\\\n\\\";\\n\\n\\tvar normal_vert = \\\"#define NORMAL\\\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\\\n\\\\tvarying vec3 vViewPosition;\\\\n#endif\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\n#include <uv_pars_vertex>\\\\n#include <displacementmap_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <beginnormal_vertex>\\\\n\\\\t#include <morphnormal_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#include <skinnormal_vertex>\\\\n\\\\t#include <defaultnormal_vertex>\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvNormal = normalize( transformedNormal );\\\\n#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <displacementmap_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\\\n\\\\tvViewPosition = - mvPosition.xyz;\\\\n#endif\\\\n}\\\\n\\\";\\n\\n\\tvar points_frag = \\\"uniform vec3 diffuse;\\\\nuniform float opacity;\\\\n#include <common>\\\\n#include <packing>\\\\n#include <color_pars_fragment>\\\\n#include <map_particle_pars_fragment>\\\\n#include <fog_pars_fragment>\\\\n#include <shadowmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec3 outgoingLight = vec3( 0.0 );\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <map_particle_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\toutgoingLight = diffuseColor.rgb;\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n}\\\\n\\\";\\n\\n\\tvar points_vert = \\\"uniform float size;\\\\nuniform float scale;\\\\n#include <common>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <shadowmap_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <color_vertex>\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#ifdef USE_SIZEATTENUATION\\\\n\\\\t\\\\tgl_PointSize = size * ( scale / - mvPosition.z );\\\\n\\\\t#else\\\\n\\\\t\\\\tgl_PointSize = size;\\\\n\\\\t#endif\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <shadowmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\\n\\\";\\n\\n\\tvar shadow_frag = \\\"uniform vec3 color;\\\\nuniform float opacity;\\\\n#include <common>\\\\n#include <packing>\\\\n#include <fog_pars_fragment>\\\\n#include <bsdfs>\\\\n#include <lights_pars>\\\\n#include <shadowmap_pars_fragment>\\\\n#include <shadowmask_pars_fragment>\\\\nvoid main() {\\\\n\\\\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\\\n\\\\t#include <fog_fragment>\\\\n}\\\\n\\\";\\n\\n\\tvar shadow_vert = \\\"#include <fog_pars_vertex>\\\\n#include <shadowmap_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <shadowmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\\n\\\";\\n\\n\\tvar ShaderChunk = {\\n\\t\\talphamap_fragment: alphamap_fragment,\\n\\t\\talphamap_pars_fragment: alphamap_pars_fragment,\\n\\t\\talphatest_fragment: alphatest_fragment,\\n\\t\\taomap_fragment: aomap_fragment,\\n\\t\\taomap_pars_fragment: aomap_pars_fragment,\\n\\t\\tbegin_vertex: begin_vertex,\\n\\t\\tbeginnormal_vertex: beginnormal_vertex,\\n\\t\\tbsdfs: bsdfs,\\n\\t\\tbumpmap_pars_fragment: bumpmap_pars_fragment,\\n\\t\\tclipping_planes_fragment: clipping_planes_fragment,\\n\\t\\tclipping_planes_pars_fragment: clipping_planes_pars_fragment,\\n\\t\\tclipping_planes_pars_vertex: clipping_planes_pars_vertex,\\n\\t\\tclipping_planes_vertex: clipping_planes_vertex,\\n\\t\\tcolor_fragment: color_fragment,\\n\\t\\tcolor_pars_fragment: color_pars_fragment,\\n\\t\\tcolor_pars_vertex: color_pars_vertex,\\n\\t\\tcolor_vertex: color_vertex,\\n\\t\\tcommon: common,\\n\\t\\tcube_uv_reflection_fragment: cube_uv_reflection_fragment,\\n\\t\\tdefaultnormal_vertex: defaultnormal_vertex,\\n\\t\\tdisplacementmap_pars_vertex: displacementmap_pars_vertex,\\n\\t\\tdisplacementmap_vertex: displacementmap_vertex,\\n\\t\\temissivemap_fragment: emissivemap_fragment,\\n\\t\\temissivemap_pars_fragment: emissivemap_pars_fragment,\\n\\t\\tencodings_fragment: encodings_fragment,\\n\\t\\tencodings_pars_fragment: encodings_pars_fragment,\\n\\t\\tenvmap_fragment: envmap_fragment,\\n\\t\\tenvmap_pars_fragment: envmap_pars_fragment,\\n\\t\\tenvmap_pars_vertex: envmap_pars_vertex,\\n\\t\\tenvmap_vertex: envmap_vertex,\\n\\t\\tfog_vertex: fog_vertex,\\n\\t\\tfog_pars_vertex: fog_pars_vertex,\\n\\t\\tfog_fragment: fog_fragment,\\n\\t\\tfog_pars_fragment: fog_pars_fragment,\\n\\t\\tgradientmap_pars_fragment: gradientmap_pars_fragment,\\n\\t\\tlightmap_fragment: lightmap_fragment,\\n\\t\\tlightmap_pars_fragment: lightmap_pars_fragment,\\n\\t\\tlights_lambert_vertex: lights_lambert_vertex,\\n\\t\\tlights_pars: lights_pars,\\n\\t\\tlights_phong_fragment: lights_phong_fragment,\\n\\t\\tlights_phong_pars_fragment: lights_phong_pars_fragment,\\n\\t\\tlights_physical_fragment: lights_physical_fragment,\\n\\t\\tlights_physical_pars_fragment: lights_physical_pars_fragment,\\n\\t\\tlights_template: lights_template,\\n\\t\\tlogdepthbuf_fragment: logdepthbuf_fragment,\\n\\t\\tlogdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\\n\\t\\tlogdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\\n\\t\\tlogdepthbuf_vertex: logdepthbuf_vertex,\\n\\t\\tmap_fragment: map_fragment,\\n\\t\\tmap_pars_fragment: map_pars_fragment,\\n\\t\\tmap_particle_fragment: map_particle_fragment,\\n\\t\\tmap_particle_pars_fragment: map_particle_pars_fragment,\\n\\t\\tmetalnessmap_fragment: metalnessmap_fragment,\\n\\t\\tmetalnessmap_pars_fragment: metalnessmap_pars_fragment,\\n\\t\\tmorphnormal_vertex: morphnormal_vertex,\\n\\t\\tmorphtarget_pars_vertex: morphtarget_pars_vertex,\\n\\t\\tmorphtarget_vertex: morphtarget_vertex,\\n\\t\\tnormal_fragment: normal_fragment,\\n\\t\\tnormalmap_pars_fragment: normalmap_pars_fragment,\\n\\t\\tpacking: packing,\\n\\t\\tpremultiplied_alpha_fragment: premultiplied_alpha_fragment,\\n\\t\\tproject_vertex: project_vertex,\\n\\t\\tdithering_fragment: dithering_fragment,\\n\\t\\tdithering_pars_fragment: dithering_pars_fragment,\\n\\t\\troughnessmap_fragment: roughnessmap_fragment,\\n\\t\\troughnessmap_pars_fragment: roughnessmap_pars_fragment,\\n\\t\\tshadowmap_pars_fragment: shadowmap_pars_fragment,\\n\\t\\tshadowmap_pars_vertex: shadowmap_pars_vertex,\\n\\t\\tshadowmap_vertex: shadowmap_vertex,\\n\\t\\tshadowmask_pars_fragment: shadowmask_pars_fragment,\\n\\t\\tskinbase_vertex: skinbase_vertex,\\n\\t\\tskinning_pars_vertex: skinning_pars_vertex,\\n\\t\\tskinning_vertex: skinning_vertex,\\n\\t\\tskinnormal_vertex: skinnormal_vertex,\\n\\t\\tspecularmap_fragment: specularmap_fragment,\\n\\t\\tspecularmap_pars_fragment: specularmap_pars_fragment,\\n\\t\\ttonemapping_fragment: tonemapping_fragment,\\n\\t\\ttonemapping_pars_fragment: tonemapping_pars_fragment,\\n\\t\\tuv_pars_fragment: uv_pars_fragment,\\n\\t\\tuv_pars_vertex: uv_pars_vertex,\\n\\t\\tuv_vertex: uv_vertex,\\n\\t\\tuv2_pars_fragment: uv2_pars_fragment,\\n\\t\\tuv2_pars_vertex: uv2_pars_vertex,\\n\\t\\tuv2_vertex: uv2_vertex,\\n\\t\\tworldpos_vertex: worldpos_vertex,\\n\\n\\t\\tcube_frag: cube_frag,\\n\\t\\tcube_vert: cube_vert,\\n\\t\\tdepth_frag: depth_frag,\\n\\t\\tdepth_vert: depth_vert,\\n\\t\\tdistanceRGBA_frag: distanceRGBA_frag,\\n\\t\\tdistanceRGBA_vert: distanceRGBA_vert,\\n\\t\\tequirect_frag: equirect_frag,\\n\\t\\tequirect_vert: equirect_vert,\\n\\t\\tlinedashed_frag: linedashed_frag,\\n\\t\\tlinedashed_vert: linedashed_vert,\\n\\t\\tmeshbasic_frag: meshbasic_frag,\\n\\t\\tmeshbasic_vert: meshbasic_vert,\\n\\t\\tmeshlambert_frag: meshlambert_frag,\\n\\t\\tmeshlambert_vert: meshlambert_vert,\\n\\t\\tmeshphong_frag: meshphong_frag,\\n\\t\\tmeshphong_vert: meshphong_vert,\\n\\t\\tmeshphysical_frag: meshphysical_frag,\\n\\t\\tmeshphysical_vert: meshphysical_vert,\\n\\t\\tnormal_frag: normal_frag,\\n\\t\\tnormal_vert: normal_vert,\\n\\t\\tpoints_frag: points_frag,\\n\\t\\tpoints_vert: points_vert,\\n\\t\\tshadow_frag: shadow_frag,\\n\\t\\tshadow_vert: shadow_vert\\n\\t};\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t */\\n\\n\\tvar ShaderLib = {\\n\\n\\t\\tbasic: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.common,\\n\\t\\t\\t\\tUniformsLib.specularmap,\\n\\t\\t\\t\\tUniformsLib.envmap,\\n\\t\\t\\t\\tUniformsLib.aomap,\\n\\t\\t\\t\\tUniformsLib.lightmap,\\n\\t\\t\\t\\tUniformsLib.fog\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.meshbasic_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.meshbasic_frag\\n\\n\\t\\t},\\n\\n\\t\\tlambert: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.common,\\n\\t\\t\\t\\tUniformsLib.specularmap,\\n\\t\\t\\t\\tUniformsLib.envmap,\\n\\t\\t\\t\\tUniformsLib.aomap,\\n\\t\\t\\t\\tUniformsLib.lightmap,\\n\\t\\t\\t\\tUniformsLib.emissivemap,\\n\\t\\t\\t\\tUniformsLib.fog,\\n\\t\\t\\t\\tUniformsLib.lights,\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\temissive: { value: new Color( 0x000000 ) }\\n\\t\\t\\t\\t}\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.meshlambert_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.meshlambert_frag\\n\\n\\t\\t},\\n\\n\\t\\tphong: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.common,\\n\\t\\t\\t\\tUniformsLib.specularmap,\\n\\t\\t\\t\\tUniformsLib.envmap,\\n\\t\\t\\t\\tUniformsLib.aomap,\\n\\t\\t\\t\\tUniformsLib.lightmap,\\n\\t\\t\\t\\tUniformsLib.emissivemap,\\n\\t\\t\\t\\tUniformsLib.bumpmap,\\n\\t\\t\\t\\tUniformsLib.normalmap,\\n\\t\\t\\t\\tUniformsLib.displacementmap,\\n\\t\\t\\t\\tUniformsLib.gradientmap,\\n\\t\\t\\t\\tUniformsLib.fog,\\n\\t\\t\\t\\tUniformsLib.lights,\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\temissive: { value: new Color( 0x000000 ) },\\n\\t\\t\\t\\t\\tspecular: { value: new Color( 0x111111 ) },\\n\\t\\t\\t\\t\\tshininess: { value: 30 }\\n\\t\\t\\t\\t}\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.meshphong_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.meshphong_frag\\n\\n\\t\\t},\\n\\n\\t\\tstandard: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.common,\\n\\t\\t\\t\\tUniformsLib.envmap,\\n\\t\\t\\t\\tUniformsLib.aomap,\\n\\t\\t\\t\\tUniformsLib.lightmap,\\n\\t\\t\\t\\tUniformsLib.emissivemap,\\n\\t\\t\\t\\tUniformsLib.bumpmap,\\n\\t\\t\\t\\tUniformsLib.normalmap,\\n\\t\\t\\t\\tUniformsLib.displacementmap,\\n\\t\\t\\t\\tUniformsLib.roughnessmap,\\n\\t\\t\\t\\tUniformsLib.metalnessmap,\\n\\t\\t\\t\\tUniformsLib.fog,\\n\\t\\t\\t\\tUniformsLib.lights,\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\temissive: { value: new Color( 0x000000 ) },\\n\\t\\t\\t\\t\\troughness: { value: 0.5 },\\n\\t\\t\\t\\t\\tmetalness: { value: 0.5 },\\n\\t\\t\\t\\t\\tenvMapIntensity: { value: 1 } // temporary\\n\\t\\t\\t\\t}\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.meshphysical_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.meshphysical_frag\\n\\n\\t\\t},\\n\\n\\t\\tpoints: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.points,\\n\\t\\t\\t\\tUniformsLib.fog\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.points_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.points_frag\\n\\n\\t\\t},\\n\\n\\t\\tdashed: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.common,\\n\\t\\t\\t\\tUniformsLib.fog,\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tscale: { value: 1 },\\n\\t\\t\\t\\t\\tdashSize: { value: 1 },\\n\\t\\t\\t\\t\\ttotalSize: { value: 2 }\\n\\t\\t\\t\\t}\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.linedashed_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.linedashed_frag\\n\\n\\t\\t},\\n\\n\\t\\tdepth: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.common,\\n\\t\\t\\t\\tUniformsLib.displacementmap\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.depth_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.depth_frag\\n\\n\\t\\t},\\n\\n\\t\\tnormal: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.common,\\n\\t\\t\\t\\tUniformsLib.bumpmap,\\n\\t\\t\\t\\tUniformsLib.normalmap,\\n\\t\\t\\t\\tUniformsLib.displacementmap,\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\topacity: { value: 1.0 }\\n\\t\\t\\t\\t}\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.normal_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.normal_frag\\n\\n\\t\\t},\\n\\n\\t\\t/* -------------------------------------------------------------------------\\n\\t\\t//\\tCube map shader\\n\\t\\t ------------------------------------------------------------------------- */\\n\\n\\t\\tcube: {\\n\\n\\t\\t\\tuniforms: {\\n\\t\\t\\t\\ttCube: { value: null },\\n\\t\\t\\t\\ttFlip: { value: - 1 },\\n\\t\\t\\t\\topacity: { value: 1.0 }\\n\\t\\t\\t},\\n\\n\\t\\t\\tvertexShader: ShaderChunk.cube_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.cube_frag\\n\\n\\t\\t},\\n\\n\\t\\tequirect: {\\n\\n\\t\\t\\tuniforms: {\\n\\t\\t\\t\\ttEquirect: { value: null },\\n\\t\\t\\t},\\n\\n\\t\\t\\tvertexShader: ShaderChunk.equirect_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.equirect_frag\\n\\n\\t\\t},\\n\\n\\t\\tdistanceRGBA: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.common,\\n\\t\\t\\t\\tUniformsLib.displacementmap,\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treferencePosition: { value: new Vector3() },\\n\\t\\t\\t\\t\\tnearDistance: { value: 1 },\\n\\t\\t\\t\\t\\tfarDistance: { value: 1000 }\\n\\t\\t\\t\\t}\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.distanceRGBA_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.distanceRGBA_frag\\n\\n\\t\\t},\\n\\n\\t\\tshadow: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.lights,\\n\\t\\t\\t\\tUniformsLib.fog,\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcolor: { value: new Color( 0x00000 ) },\\n\\t\\t\\t\\t\\topacity: { value: 1.0 }\\n\\t\\t\\t\\t},\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.shadow_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.shadow_frag\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tShaderLib.physical = {\\n\\n\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\tShaderLib.standard.uniforms,\\n\\t\\t\\t{\\n\\t\\t\\t\\tclearCoat: { value: 0 },\\n\\t\\t\\t\\tclearCoatRoughness: { value: 0 }\\n\\t\\t\\t}\\n\\t\\t] ),\\n\\n\\t\\tvertexShader: ShaderChunk.meshphysical_vert,\\n\\t\\tfragmentShader: ShaderChunk.meshphysical_frag\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author bhouston / http://clara.io\\n\\t */\\n\\n\\tfunction Box2( min, max ) {\\n\\n\\t\\tthis.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );\\n\\t\\tthis.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );\\n\\n\\t}\\n\\n\\tObject.assign( Box2.prototype, {\\n\\n\\t\\tset: function ( min, max ) {\\n\\n\\t\\t\\tthis.min.copy( min );\\n\\t\\t\\tthis.max.copy( max );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromPoints: function ( points ) {\\n\\n\\t\\t\\tthis.makeEmpty();\\n\\n\\t\\t\\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.expandByPoint( points[ i ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromCenterAndSize: function () {\\n\\n\\t\\t\\tvar v1 = new Vector2();\\n\\n\\t\\t\\treturn function setFromCenterAndSize( center, size ) {\\n\\n\\t\\t\\t\\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\\n\\t\\t\\t\\tthis.min.copy( center ).sub( halfSize );\\n\\t\\t\\t\\tthis.max.copy( center ).add( halfSize );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( box ) {\\n\\n\\t\\t\\tthis.min.copy( box.min );\\n\\t\\t\\tthis.max.copy( box.max );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeEmpty: function () {\\n\\n\\t\\t\\tthis.min.x = this.min.y = + Infinity;\\n\\t\\t\\tthis.max.x = this.max.y = - Infinity;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tisEmpty: function () {\\n\\n\\t\\t\\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\\n\\n\\t\\t\\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\\n\\n\\t\\t},\\n\\n\\t\\tgetCenter: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector2();\\n\\t\\t\\treturn this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\\n\\n\\t\\t},\\n\\n\\t\\tgetSize: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector2();\\n\\t\\t\\treturn this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );\\n\\n\\t\\t},\\n\\n\\t\\texpandByPoint: function ( point ) {\\n\\n\\t\\t\\tthis.min.min( point );\\n\\t\\t\\tthis.max.max( point );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\texpandByVector: function ( vector ) {\\n\\n\\t\\t\\tthis.min.sub( vector );\\n\\t\\t\\tthis.max.add( vector );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\texpandByScalar: function ( scalar ) {\\n\\n\\t\\t\\tthis.min.addScalar( - scalar );\\n\\t\\t\\tthis.max.addScalar( scalar );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcontainsPoint: function ( point ) {\\n\\n\\t\\t\\treturn point.x < this.min.x || point.x > this.max.x ||\\n\\t\\t\\t\\tpoint.y < this.min.y || point.y > this.max.y ? false : true;\\n\\n\\t\\t},\\n\\n\\t\\tcontainsBox: function ( box ) {\\n\\n\\t\\t\\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\\n\\t\\t\\t\\tthis.min.y <= box.min.y && box.max.y <= this.max.y;\\n\\n\\t\\t},\\n\\n\\t\\tgetParameter: function ( point, optionalTarget ) {\\n\\n\\t\\t\\t// This can potentially have a divide by zero if the box\\n\\t\\t\\t// has a size dimension of 0.\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector2();\\n\\n\\t\\t\\treturn result.set(\\n\\t\\t\\t\\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\\n\\t\\t\\t\\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\\n\\t\\t\\t);\\n\\n\\t\\t},\\n\\n\\t\\tintersectsBox: function ( box ) {\\n\\n\\t\\t\\t// using 4 splitting planes to rule out intersections\\n\\n\\t\\t\\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\\n\\t\\t\\t\\tbox.max.y < this.min.y || box.min.y > this.max.y ? false : true;\\n\\n\\t\\t},\\n\\n\\t\\tclampPoint: function ( point, optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector2();\\n\\t\\t\\treturn result.copy( point ).clamp( this.min, this.max );\\n\\n\\t\\t},\\n\\n\\t\\tdistanceToPoint: function () {\\n\\n\\t\\t\\tvar v1 = new Vector2();\\n\\n\\t\\t\\treturn function distanceToPoint( point ) {\\n\\n\\t\\t\\t\\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\\n\\t\\t\\t\\treturn clampedPoint.sub( point ).length();\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tintersect: function ( box ) {\\n\\n\\t\\t\\tthis.min.max( box.min );\\n\\t\\t\\tthis.max.min( box.max );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tunion: function ( box ) {\\n\\n\\t\\t\\tthis.min.min( box.min );\\n\\t\\t\\tthis.max.max( box.max );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttranslate: function ( offset ) {\\n\\n\\t\\t\\tthis.min.add( offset );\\n\\t\\t\\tthis.max.add( offset );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( box ) {\\n\\n\\t\\t\\treturn box.min.equals( this.min ) && box.max.equals( this.max );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction WebGLFlareRenderer( renderer, gl, state, textures, capabilities ) {\\n\\n\\t\\tvar vertexBuffer, elementBuffer;\\n\\t\\tvar shader, program, attributes, uniforms;\\n\\n\\t\\tvar tempTexture, occlusionTexture;\\n\\n\\t\\tfunction init() {\\n\\n\\t\\t\\tvar vertices = new Float32Array( [\\n\\t\\t\\t\\t- 1, - 1, 0, 0,\\n\\t\\t\\t\\t  1, - 1, 1, 0,\\n\\t\\t\\t\\t  1, 1, 1, 1,\\n\\t\\t\\t\\t- 1, 1, 0, 1\\n\\t\\t\\t] );\\n\\n\\t\\t\\tvar faces = new Uint16Array( [\\n\\t\\t\\t\\t0, 1, 2,\\n\\t\\t\\t\\t0, 2, 3\\n\\t\\t\\t] );\\n\\n\\t\\t\\t// buffers\\n\\n\\t\\t\\tvertexBuffer = gl.createBuffer();\\n\\t\\t\\telementBuffer = gl.createBuffer();\\n\\n\\t\\t\\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\\n\\t\\t\\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\\n\\n\\t\\t\\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\\n\\t\\t\\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\\n\\n\\t\\t\\t// textures\\n\\n\\t\\t\\ttempTexture = gl.createTexture();\\n\\t\\t\\tocclusionTexture = gl.createTexture();\\n\\n\\t\\t\\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\\n\\t\\t\\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\\n\\n\\t\\t\\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\\n\\t\\t\\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\\n\\n\\t\\t\\tshader = {\\n\\n\\t\\t\\t\\tvertexShader: [\\n\\n\\t\\t\\t\\t\\t'uniform lowp int renderType;',\\n\\n\\t\\t\\t\\t\\t'uniform vec3 screenPosition;',\\n\\t\\t\\t\\t\\t'uniform vec2 scale;',\\n\\t\\t\\t\\t\\t'uniform float rotation;',\\n\\n\\t\\t\\t\\t\\t'uniform sampler2D occlusionMap;',\\n\\n\\t\\t\\t\\t\\t'attribute vec2 position;',\\n\\t\\t\\t\\t\\t'attribute vec2 uv;',\\n\\n\\t\\t\\t\\t\\t'varying vec2 vUV;',\\n\\t\\t\\t\\t\\t'varying float vVisibility;',\\n\\n\\t\\t\\t\\t\\t'void main() {',\\n\\n\\t\\t\\t\\t\\t'\\tvUV = uv;',\\n\\n\\t\\t\\t\\t\\t'\\tvec2 pos = position;',\\n\\n\\t\\t\\t\\t\\t'\\tif ( renderType == 2 ) {',\\n\\n\\t\\t\\t\\t\\t'\\t\\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );',\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );',\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );',\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );',\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );',\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );',\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );',\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );',\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );',\\n\\n\\t\\t\\t\\t\\t'\\t\\tvVisibility =        visibility.r / 9.0;',\\n\\t\\t\\t\\t\\t'\\t\\tvVisibility *= 1.0 - visibility.g / 9.0;',\\n\\t\\t\\t\\t\\t'\\t\\tvVisibility *=       visibility.b / 9.0;',\\n\\t\\t\\t\\t\\t'\\t\\tvVisibility *= 1.0 - visibility.a / 9.0;',\\n\\n\\t\\t\\t\\t\\t'\\t\\tpos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;',\\n\\t\\t\\t\\t\\t'\\t\\tpos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;',\\n\\n\\t\\t\\t\\t\\t'\\t}',\\n\\n\\t\\t\\t\\t\\t'\\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );',\\n\\n\\t\\t\\t\\t\\t'}'\\n\\n\\t\\t\\t\\t].join( '\\\\n' ),\\n\\n\\t\\t\\t\\tfragmentShader: [\\n\\n\\t\\t\\t\\t\\t'uniform lowp int renderType;',\\n\\n\\t\\t\\t\\t\\t'uniform sampler2D map;',\\n\\t\\t\\t\\t\\t'uniform float opacity;',\\n\\t\\t\\t\\t\\t'uniform vec3 color;',\\n\\n\\t\\t\\t\\t\\t'varying vec2 vUV;',\\n\\t\\t\\t\\t\\t'varying float vVisibility;',\\n\\n\\t\\t\\t\\t\\t'void main() {',\\n\\n\\t\\t\\t\\t\\t// pink square\\n\\n\\t\\t\\t\\t\\t'\\tif ( renderType == 0 ) {',\\n\\n\\t\\t\\t\\t\\t'\\t\\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );',\\n\\n\\t\\t\\t\\t\\t// restore\\n\\n\\t\\t\\t\\t\\t'\\t} else if ( renderType == 1 ) {',\\n\\n\\t\\t\\t\\t\\t'\\t\\tgl_FragColor = texture2D( map, vUV );',\\n\\n\\t\\t\\t\\t\\t// flare\\n\\n\\t\\t\\t\\t\\t'\\t} else {',\\n\\n\\t\\t\\t\\t\\t'\\t\\tvec4 texture = texture2D( map, vUV );',\\n\\t\\t\\t\\t\\t'\\t\\ttexture.a *= opacity * vVisibility;',\\n\\t\\t\\t\\t\\t'\\t\\tgl_FragColor = texture;',\\n\\t\\t\\t\\t\\t'\\t\\tgl_FragColor.rgb *= color;',\\n\\n\\t\\t\\t\\t\\t'\\t}',\\n\\n\\t\\t\\t\\t\\t'}'\\n\\n\\t\\t\\t\\t].join( '\\\\n' )\\n\\n\\t\\t\\t};\\n\\n\\t\\t\\tprogram = createProgram( shader );\\n\\n\\t\\t\\tattributes = {\\n\\t\\t\\t\\tvertex: gl.getAttribLocation( program, 'position' ),\\n\\t\\t\\t\\tuv: gl.getAttribLocation( program, 'uv' )\\n\\t\\t\\t};\\n\\n\\t\\t\\tuniforms = {\\n\\t\\t\\t\\trenderType: gl.getUniformLocation( program, 'renderType' ),\\n\\t\\t\\t\\tmap: gl.getUniformLocation( program, 'map' ),\\n\\t\\t\\t\\tocclusionMap: gl.getUniformLocation( program, 'occlusionMap' ),\\n\\t\\t\\t\\topacity: gl.getUniformLocation( program, 'opacity' ),\\n\\t\\t\\t\\tcolor: gl.getUniformLocation( program, 'color' ),\\n\\t\\t\\t\\tscale: gl.getUniformLocation( program, 'scale' ),\\n\\t\\t\\t\\trotation: gl.getUniformLocation( program, 'rotation' ),\\n\\t\\t\\t\\tscreenPosition: gl.getUniformLocation( program, 'screenPosition' )\\n\\t\\t\\t};\\n\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t * Render lens flares\\n\\t\\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\\n\\t\\t *         reads these back and calculates occlusion.\\n\\t\\t */\\n\\n\\t\\tthis.render = function ( flares, scene, camera, viewport ) {\\n\\n\\t\\t\\tif ( flares.length === 0 ) return;\\n\\n\\t\\t\\tvar tempPosition = new Vector3();\\n\\n\\t\\t\\tvar invAspect = viewport.w / viewport.z,\\n\\t\\t\\t\\thalfViewportWidth = viewport.z * 0.5,\\n\\t\\t\\t\\thalfViewportHeight = viewport.w * 0.5;\\n\\n\\t\\t\\tvar size = 16 / viewport.w,\\n\\t\\t\\t\\tscale = new Vector2( size * invAspect, size );\\n\\n\\t\\t\\tvar screenPosition = new Vector3( 1, 1, 0 ),\\n\\t\\t\\t\\tscreenPositionPixels = new Vector2( 1, 1 );\\n\\n\\t\\t\\tvar validArea = new Box2();\\n\\n\\t\\t\\tvalidArea.min.set( viewport.x, viewport.y );\\n\\t\\t\\tvalidArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );\\n\\n\\t\\t\\tif ( program === undefined ) {\\n\\n\\t\\t\\t\\tinit();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tstate.useProgram( program );\\n\\n\\t\\t\\tstate.initAttributes();\\n\\t\\t\\tstate.enableAttribute( attributes.vertex );\\n\\t\\t\\tstate.enableAttribute( attributes.uv );\\n\\t\\t\\tstate.disableUnusedAttributes();\\n\\n\\t\\t\\t// loop through all lens flares to update their occlusion and positions\\n\\t\\t\\t// setup gl and common used attribs/uniforms\\n\\n\\t\\t\\tgl.uniform1i( uniforms.occlusionMap, 0 );\\n\\t\\t\\tgl.uniform1i( uniforms.map, 1 );\\n\\n\\t\\t\\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\\n\\t\\t\\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\\n\\t\\t\\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\\n\\n\\t\\t\\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\\n\\n\\t\\t\\tstate.disable( gl.CULL_FACE );\\n\\t\\t\\tstate.buffers.depth.setMask( false );\\n\\n\\t\\t\\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tsize = 16 / viewport.w;\\n\\t\\t\\t\\tscale.set( size * invAspect, size );\\n\\n\\t\\t\\t\\t// calc object screen position\\n\\n\\t\\t\\t\\tvar flare = flares[ i ];\\n\\n\\t\\t\\t\\ttempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );\\n\\n\\t\\t\\t\\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\\n\\t\\t\\t\\ttempPosition.applyMatrix4( camera.projectionMatrix );\\n\\n\\t\\t\\t\\t// setup arrays for gl programs\\n\\n\\t\\t\\t\\tscreenPosition.copy( tempPosition );\\n\\n\\t\\t\\t\\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\\n\\n\\t\\t\\t\\tscreenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;\\n\\t\\t\\t\\tscreenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;\\n\\n\\t\\t\\t\\t// screen cull\\n\\n\\t\\t\\t\\tif ( validArea.containsPoint( screenPositionPixels ) === true ) {\\n\\n\\t\\t\\t\\t\\t// save current RGB to temp texture\\n\\n\\t\\t\\t\\t\\tstate.activeTexture( gl.TEXTURE0 );\\n\\t\\t\\t\\t\\tstate.bindTexture( gl.TEXTURE_2D, null );\\n\\t\\t\\t\\t\\tstate.activeTexture( gl.TEXTURE1 );\\n\\t\\t\\t\\t\\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\\n\\t\\t\\t\\t\\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\\n\\n\\n\\t\\t\\t\\t\\t// render pink quad\\n\\n\\t\\t\\t\\t\\tgl.uniform1i( uniforms.renderType, 0 );\\n\\t\\t\\t\\t\\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\\n\\t\\t\\t\\t\\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\\n\\n\\t\\t\\t\\t\\tstate.disable( gl.BLEND );\\n\\t\\t\\t\\t\\tstate.enable( gl.DEPTH_TEST );\\n\\n\\t\\t\\t\\t\\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\\n\\n\\n\\t\\t\\t\\t\\t// copy result to occlusionMap\\n\\n\\t\\t\\t\\t\\tstate.activeTexture( gl.TEXTURE0 );\\n\\t\\t\\t\\t\\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\\n\\t\\t\\t\\t\\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\\n\\n\\n\\t\\t\\t\\t\\t// restore graphics\\n\\n\\t\\t\\t\\t\\tgl.uniform1i( uniforms.renderType, 1 );\\n\\t\\t\\t\\t\\tstate.disable( gl.DEPTH_TEST );\\n\\n\\t\\t\\t\\t\\tstate.activeTexture( gl.TEXTURE1 );\\n\\t\\t\\t\\t\\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\\n\\t\\t\\t\\t\\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\\n\\n\\n\\t\\t\\t\\t\\t// update object positions\\n\\n\\t\\t\\t\\t\\tflare.positionScreen.copy( screenPosition );\\n\\n\\t\\t\\t\\t\\tif ( flare.customUpdateCallback ) {\\n\\n\\t\\t\\t\\t\\t\\tflare.customUpdateCallback( flare );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tflare.updateLensFlares();\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// render flares\\n\\n\\t\\t\\t\\t\\tgl.uniform1i( uniforms.renderType, 2 );\\n\\t\\t\\t\\t\\tstate.enable( gl.BLEND );\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar sprite = flare.lensFlares[ j ];\\n\\n\\t\\t\\t\\t\\t\\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tscreenPosition.x = sprite.x;\\n\\t\\t\\t\\t\\t\\t\\tscreenPosition.y = sprite.y;\\n\\t\\t\\t\\t\\t\\t\\tscreenPosition.z = sprite.z;\\n\\n\\t\\t\\t\\t\\t\\t\\tsize = sprite.size * sprite.scale / viewport.w;\\n\\n\\t\\t\\t\\t\\t\\t\\tscale.x = size * invAspect;\\n\\t\\t\\t\\t\\t\\t\\tscale.y = size;\\n\\n\\t\\t\\t\\t\\t\\t\\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\\n\\t\\t\\t\\t\\t\\t\\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\\n\\t\\t\\t\\t\\t\\t\\tgl.uniform1f( uniforms.rotation, sprite.rotation );\\n\\n\\t\\t\\t\\t\\t\\t\\tgl.uniform1f( uniforms.opacity, sprite.opacity );\\n\\t\\t\\t\\t\\t\\t\\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\\n\\n\\t\\t\\t\\t\\t\\t\\tstate.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\\n\\n\\t\\t\\t\\t\\t\\t\\ttextures.setTexture2D( sprite.texture, 1 );\\n\\n\\t\\t\\t\\t\\t\\t\\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// restore gl\\n\\n\\t\\t\\tstate.enable( gl.CULL_FACE );\\n\\t\\t\\tstate.enable( gl.DEPTH_TEST );\\n\\t\\t\\tstate.buffers.depth.setMask( true );\\n\\n\\t\\t\\tstate.reset();\\n\\n\\t\\t};\\n\\n\\t\\tfunction createProgram( shader ) {\\n\\n\\t\\t\\tvar program = gl.createProgram();\\n\\n\\t\\t\\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\\n\\t\\t\\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\\n\\n\\t\\t\\tvar prefix = 'precision ' + capabilities.precision + ' float;\\\\n';\\n\\n\\t\\t\\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\\n\\t\\t\\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\\n\\n\\t\\t\\tgl.compileShader( fragmentShader );\\n\\t\\t\\tgl.compileShader( vertexShader );\\n\\n\\t\\t\\tgl.attachShader( program, fragmentShader );\\n\\t\\t\\tgl.attachShader( program, vertexShader );\\n\\n\\t\\t\\tgl.linkProgram( program );\\n\\n\\t\\t\\treturn program;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\\n\\n\\t\\tTexture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\\n\\n\\t\\tthis.needsUpdate = true;\\n\\n\\t}\\n\\n\\tCanvasTexture.prototype = Object.create( Texture.prototype );\\n\\tCanvasTexture.prototype.constructor = CanvasTexture;\\n\\n\\t/**\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction WebGLSpriteRenderer( renderer, gl, state, textures, capabilities ) {\\n\\n\\t\\tvar vertexBuffer, elementBuffer;\\n\\t\\tvar program, attributes, uniforms;\\n\\n\\t\\tvar texture;\\n\\n\\t\\t// decompose matrixWorld\\n\\n\\t\\tvar spritePosition = new Vector3();\\n\\t\\tvar spriteRotation = new Quaternion();\\n\\t\\tvar spriteScale = new Vector3();\\n\\n\\t\\tfunction init() {\\n\\n\\t\\t\\tvar vertices = new Float32Array( [\\n\\t\\t\\t\\t- 0.5, - 0.5, 0, 0,\\n\\t\\t\\t\\t  0.5, - 0.5, 1, 0,\\n\\t\\t\\t\\t  0.5, 0.5, 1, 1,\\n\\t\\t\\t\\t- 0.5, 0.5, 0, 1\\n\\t\\t\\t] );\\n\\n\\t\\t\\tvar faces = new Uint16Array( [\\n\\t\\t\\t\\t0, 1, 2,\\n\\t\\t\\t\\t0, 2, 3\\n\\t\\t\\t] );\\n\\n\\t\\t\\tvertexBuffer = gl.createBuffer();\\n\\t\\t\\telementBuffer = gl.createBuffer();\\n\\n\\t\\t\\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\\n\\t\\t\\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\\n\\n\\t\\t\\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\\n\\t\\t\\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\\n\\n\\t\\t\\tprogram = createProgram();\\n\\n\\t\\t\\tattributes = {\\n\\t\\t\\t\\tposition: gl.getAttribLocation( program, 'position' ),\\n\\t\\t\\t\\tuv: gl.getAttribLocation( program, 'uv' )\\n\\t\\t\\t};\\n\\n\\t\\t\\tuniforms = {\\n\\t\\t\\t\\tuvOffset: gl.getUniformLocation( program, 'uvOffset' ),\\n\\t\\t\\t\\tuvScale: gl.getUniformLocation( program, 'uvScale' ),\\n\\n\\t\\t\\t\\trotation: gl.getUniformLocation( program, 'rotation' ),\\n\\t\\t\\t\\tscale: gl.getUniformLocation( program, 'scale' ),\\n\\n\\t\\t\\t\\tcolor: gl.getUniformLocation( program, 'color' ),\\n\\t\\t\\t\\tmap: gl.getUniformLocation( program, 'map' ),\\n\\t\\t\\t\\topacity: gl.getUniformLocation( program, 'opacity' ),\\n\\n\\t\\t\\t\\tmodelViewMatrix: gl.getUniformLocation( program, 'modelViewMatrix' ),\\n\\t\\t\\t\\tprojectionMatrix: gl.getUniformLocation( program, 'projectionMatrix' ),\\n\\n\\t\\t\\t\\tfogType: gl.getUniformLocation( program, 'fogType' ),\\n\\t\\t\\t\\tfogDensity: gl.getUniformLocation( program, 'fogDensity' ),\\n\\t\\t\\t\\tfogNear: gl.getUniformLocation( program, 'fogNear' ),\\n\\t\\t\\t\\tfogFar: gl.getUniformLocation( program, 'fogFar' ),\\n\\t\\t\\t\\tfogColor: gl.getUniformLocation( program, 'fogColor' ),\\n\\t\\t\\t\\tfogDepth: gl.getUniformLocation( program, 'fogDepth' ),\\n\\n\\t\\t\\t\\talphaTest: gl.getUniformLocation( program, 'alphaTest' )\\n\\t\\t\\t};\\n\\n\\t\\t\\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\\n\\t\\t\\tcanvas.width = 8;\\n\\t\\t\\tcanvas.height = 8;\\n\\n\\t\\t\\tvar context = canvas.getContext( '2d' );\\n\\t\\t\\tcontext.fillStyle = 'white';\\n\\t\\t\\tcontext.fillRect( 0, 0, 8, 8 );\\n\\n\\t\\t\\ttexture = new CanvasTexture( canvas );\\n\\n\\t\\t}\\n\\n\\t\\tthis.render = function ( sprites, scene, camera ) {\\n\\n\\t\\t\\tif ( sprites.length === 0 ) return;\\n\\n\\t\\t\\t// setup gl\\n\\n\\t\\t\\tif ( program === undefined ) {\\n\\n\\t\\t\\t\\tinit();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tstate.useProgram( program );\\n\\n\\t\\t\\tstate.initAttributes();\\n\\t\\t\\tstate.enableAttribute( attributes.position );\\n\\t\\t\\tstate.enableAttribute( attributes.uv );\\n\\t\\t\\tstate.disableUnusedAttributes();\\n\\n\\t\\t\\tstate.disable( gl.CULL_FACE );\\n\\t\\t\\tstate.enable( gl.BLEND );\\n\\n\\t\\t\\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\\n\\t\\t\\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\\n\\t\\t\\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\\n\\n\\t\\t\\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\\n\\n\\t\\t\\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\\n\\n\\t\\t\\tstate.activeTexture( gl.TEXTURE0 );\\n\\t\\t\\tgl.uniform1i( uniforms.map, 0 );\\n\\n\\t\\t\\tvar oldFogType = 0;\\n\\t\\t\\tvar sceneFogType = 0;\\n\\t\\t\\tvar fog = scene.fog;\\n\\n\\t\\t\\tif ( fog ) {\\n\\n\\t\\t\\t\\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\\n\\n\\t\\t\\t\\tif ( fog.isFog ) {\\n\\n\\t\\t\\t\\t\\tgl.uniform1f( uniforms.fogNear, fog.near );\\n\\t\\t\\t\\t\\tgl.uniform1f( uniforms.fogFar, fog.far );\\n\\n\\t\\t\\t\\t\\tgl.uniform1i( uniforms.fogType, 1 );\\n\\t\\t\\t\\t\\toldFogType = 1;\\n\\t\\t\\t\\t\\tsceneFogType = 1;\\n\\n\\t\\t\\t\\t} else if ( fog.isFogExp2 ) {\\n\\n\\t\\t\\t\\t\\tgl.uniform1f( uniforms.fogDensity, fog.density );\\n\\n\\t\\t\\t\\t\\tgl.uniform1i( uniforms.fogType, 2 );\\n\\t\\t\\t\\t\\toldFogType = 2;\\n\\t\\t\\t\\t\\tsceneFogType = 2;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tgl.uniform1i( uniforms.fogType, 0 );\\n\\t\\t\\t\\toldFogType = 0;\\n\\t\\t\\t\\tsceneFogType = 0;\\n\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\t// update positions and sort\\n\\n\\t\\t\\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar sprite = sprites[ i ];\\n\\n\\t\\t\\t\\tsprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\\n\\t\\t\\t\\tsprite.z = - sprite.modelViewMatrix.elements[ 14 ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tsprites.sort( painterSortStable );\\n\\n\\t\\t\\t// render all sprites\\n\\n\\t\\t\\tvar scale = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar sprite = sprites[ i ];\\n\\t\\t\\t\\tvar material = sprite.material;\\n\\n\\t\\t\\t\\tif ( material.visible === false ) continue;\\n\\n\\t\\t\\t\\tsprite.onBeforeRender( renderer, scene, camera, undefined, material, undefined );\\n\\n\\t\\t\\t\\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\\n\\t\\t\\t\\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\\n\\n\\t\\t\\t\\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\\n\\n\\t\\t\\t\\tscale[ 0 ] = spriteScale.x;\\n\\t\\t\\t\\tscale[ 1 ] = spriteScale.y;\\n\\n\\t\\t\\t\\tvar fogType = 0;\\n\\n\\t\\t\\t\\tif ( scene.fog && material.fog ) {\\n\\n\\t\\t\\t\\t\\tfogType = sceneFogType;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( oldFogType !== fogType ) {\\n\\n\\t\\t\\t\\t\\tgl.uniform1i( uniforms.fogType, fogType );\\n\\t\\t\\t\\t\\toldFogType = fogType;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( material.map !== null ) {\\n\\n\\t\\t\\t\\t\\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\\n\\t\\t\\t\\t\\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\\n\\t\\t\\t\\t\\tgl.uniform2f( uniforms.uvScale, 1, 1 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgl.uniform1f( uniforms.opacity, material.opacity );\\n\\t\\t\\t\\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\\n\\n\\t\\t\\t\\tgl.uniform1f( uniforms.rotation, material.rotation );\\n\\t\\t\\t\\tgl.uniform2fv( uniforms.scale, scale );\\n\\n\\t\\t\\t\\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\\n\\t\\t\\t\\tstate.buffers.depth.setTest( material.depthTest );\\n\\t\\t\\t\\tstate.buffers.depth.setMask( material.depthWrite );\\n\\t\\t\\t\\tstate.buffers.color.setMask( material.colorWrite );\\n\\n\\t\\t\\t\\ttextures.setTexture2D( material.map || texture, 0 );\\n\\n\\t\\t\\t\\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\\n\\n\\t\\t\\t\\tsprite.onAfterRender( renderer, scene, camera, undefined, material, undefined );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// restore gl\\n\\n\\t\\t\\tstate.enable( gl.CULL_FACE );\\n\\n\\t\\t\\tstate.reset();\\n\\n\\t\\t};\\n\\n\\t\\tfunction createProgram() {\\n\\n\\t\\t\\tvar program = gl.createProgram();\\n\\n\\t\\t\\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\\n\\t\\t\\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\\n\\n\\t\\t\\tgl.shaderSource( vertexShader, [\\n\\n\\t\\t\\t\\t'precision ' + capabilities.precision + ' float;',\\n\\n\\t\\t\\t\\t'#define SHADER_NAME ' + 'SpriteMaterial',\\n\\n\\t\\t\\t\\t'uniform mat4 modelViewMatrix;',\\n\\t\\t\\t\\t'uniform mat4 projectionMatrix;',\\n\\t\\t\\t\\t'uniform float rotation;',\\n\\t\\t\\t\\t'uniform vec2 scale;',\\n\\t\\t\\t\\t'uniform vec2 uvOffset;',\\n\\t\\t\\t\\t'uniform vec2 uvScale;',\\n\\n\\t\\t\\t\\t'attribute vec2 position;',\\n\\t\\t\\t\\t'attribute vec2 uv;',\\n\\n\\t\\t\\t\\t'varying vec2 vUV;',\\n\\t\\t\\t\\t'varying float fogDepth;',\\n\\n\\t\\t\\t\\t'void main() {',\\n\\n\\t\\t\\t\\t'\\tvUV = uvOffset + uv * uvScale;',\\n\\n\\t\\t\\t\\t'\\tvec2 alignedPosition = position * scale;',\\n\\n\\t\\t\\t\\t'\\tvec2 rotatedPosition;',\\n\\t\\t\\t\\t'\\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\\n\\t\\t\\t\\t'\\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\\n\\n\\t\\t\\t\\t'\\tvec4 mvPosition;',\\n\\n\\t\\t\\t\\t'\\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\\n\\t\\t\\t\\t'\\tmvPosition.xy += rotatedPosition;',\\n\\n\\t\\t\\t\\t'\\tgl_Position = projectionMatrix * mvPosition;',\\n\\n\\t\\t\\t\\t'\\tfogDepth = - mvPosition.z;',\\n\\n\\t\\t\\t\\t'}'\\n\\n\\t\\t\\t].join( '\\\\n' ) );\\n\\n\\t\\t\\tgl.shaderSource( fragmentShader, [\\n\\n\\t\\t\\t\\t'precision ' + capabilities.precision + ' float;',\\n\\n\\t\\t\\t\\t'#define SHADER_NAME ' + 'SpriteMaterial',\\n\\n\\t\\t\\t\\t'uniform vec3 color;',\\n\\t\\t\\t\\t'uniform sampler2D map;',\\n\\t\\t\\t\\t'uniform float opacity;',\\n\\n\\t\\t\\t\\t'uniform int fogType;',\\n\\t\\t\\t\\t'uniform vec3 fogColor;',\\n\\t\\t\\t\\t'uniform float fogDensity;',\\n\\t\\t\\t\\t'uniform float fogNear;',\\n\\t\\t\\t\\t'uniform float fogFar;',\\n\\t\\t\\t\\t'uniform float alphaTest;',\\n\\n\\t\\t\\t\\t'varying vec2 vUV;',\\n\\t\\t\\t\\t'varying float fogDepth;',\\n\\n\\t\\t\\t\\t'void main() {',\\n\\n\\t\\t\\t\\t'\\tvec4 texture = texture2D( map, vUV );',\\n\\n\\t\\t\\t\\t'\\tgl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\\n\\n\\t\\t\\t\\t'\\tif ( gl_FragColor.a < alphaTest ) discard;',\\n\\n\\t\\t\\t\\t'\\tif ( fogType > 0 ) {',\\n\\n\\t\\t\\t\\t'\\t\\tfloat fogFactor = 0.0;',\\n\\n\\t\\t\\t\\t'\\t\\tif ( fogType == 1 ) {',\\n\\n\\t\\t\\t\\t'\\t\\t\\tfogFactor = smoothstep( fogNear, fogFar, fogDepth );',\\n\\n\\t\\t\\t\\t'\\t\\t} else {',\\n\\n\\t\\t\\t\\t'\\t\\t\\tconst float LOG2 = 1.442695;',\\n\\t\\t\\t\\t'\\t\\t\\tfogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );',\\n\\t\\t\\t\\t'\\t\\t\\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\\n\\n\\t\\t\\t\\t'\\t\\t}',\\n\\n\\t\\t\\t\\t'\\t\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );',\\n\\n\\t\\t\\t\\t'\\t}',\\n\\n\\t\\t\\t\\t'}'\\n\\n\\t\\t\\t].join( '\\\\n' ) );\\n\\n\\t\\t\\tgl.compileShader( vertexShader );\\n\\t\\t\\tgl.compileShader( fragmentShader );\\n\\n\\t\\t\\tgl.attachShader( program, vertexShader );\\n\\t\\t\\tgl.attachShader( program, fragmentShader );\\n\\n\\t\\t\\tgl.linkProgram( program );\\n\\n\\t\\t\\treturn program;\\n\\n\\t\\t}\\n\\n\\t\\tfunction painterSortStable( a, b ) {\\n\\n\\t\\t\\tif ( a.renderOrder !== b.renderOrder ) {\\n\\n\\t\\t\\t\\treturn a.renderOrder - b.renderOrder;\\n\\n\\t\\t\\t} else if ( a.z !== b.z ) {\\n\\n\\t\\t\\t\\treturn b.z - a.z;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\treturn b.id - a.id;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tvar materialId = 0;\\n\\n\\tfunction Material() {\\n\\n\\t\\tObject.defineProperty( this, 'id', { value: materialId ++ } );\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\tthis.name = '';\\n\\t\\tthis.type = 'Material';\\n\\n\\t\\tthis.fog = true;\\n\\t\\tthis.lights = true;\\n\\n\\t\\tthis.blending = NormalBlending;\\n\\t\\tthis.side = FrontSide;\\n\\t\\tthis.flatShading = false;\\n\\t\\tthis.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors\\n\\n\\t\\tthis.opacity = 1;\\n\\t\\tthis.transparent = false;\\n\\n\\t\\tthis.blendSrc = SrcAlphaFactor;\\n\\t\\tthis.blendDst = OneMinusSrcAlphaFactor;\\n\\t\\tthis.blendEquation = AddEquation;\\n\\t\\tthis.blendSrcAlpha = null;\\n\\t\\tthis.blendDstAlpha = null;\\n\\t\\tthis.blendEquationAlpha = null;\\n\\n\\t\\tthis.depthFunc = LessEqualDepth;\\n\\t\\tthis.depthTest = true;\\n\\t\\tthis.depthWrite = true;\\n\\n\\t\\tthis.clippingPlanes = null;\\n\\t\\tthis.clipIntersection = false;\\n\\t\\tthis.clipShadows = false;\\n\\n\\t\\tthis.colorWrite = true;\\n\\n\\t\\tthis.precision = null; // override the renderer's default precision for this material\\n\\n\\t\\tthis.polygonOffset = false;\\n\\t\\tthis.polygonOffsetFactor = 0;\\n\\t\\tthis.polygonOffsetUnits = 0;\\n\\n\\t\\tthis.dithering = false;\\n\\n\\t\\tthis.alphaTest = 0;\\n\\t\\tthis.premultipliedAlpha = false;\\n\\n\\t\\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\\n\\n\\t\\tthis.visible = true;\\n\\n\\t\\tthis.userData = {};\\n\\n\\t\\tthis.needsUpdate = true;\\n\\n\\t}\\n\\n\\tMaterial.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\n\\n\\t\\tconstructor: Material,\\n\\n\\t\\tisMaterial: true,\\n\\n\\t\\tonBeforeCompile: function () {},\\n\\n\\t\\tsetValues: function ( values ) {\\n\\n\\t\\t\\tif ( values === undefined ) return;\\n\\n\\t\\t\\tfor ( var key in values ) {\\n\\n\\t\\t\\t\\tvar newValue = values[ key ];\\n\\n\\t\\t\\t\\tif ( newValue === undefined ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( \\\"THREE.Material: '\\\" + key + \\\"' parameter is undefined.\\\" );\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// for backward compatability if shading is set in the constructor\\n\\t\\t\\t\\tif ( key === 'shading' ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\\n\\t\\t\\t\\t\\tthis.flatShading = ( newValue === FlatShading ) ? true : false;\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar currentValue = this[ key ];\\n\\n\\t\\t\\t\\tif ( currentValue === undefined ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( \\\"THREE.\\\" + this.type + \\\": '\\\" + key + \\\"' is not a property of this material.\\\" );\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( currentValue && currentValue.isColor ) {\\n\\n\\t\\t\\t\\t\\tcurrentValue.set( newValue );\\n\\n\\t\\t\\t\\t} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {\\n\\n\\t\\t\\t\\t\\tcurrentValue.copy( newValue );\\n\\n\\t\\t\\t\\t} else if ( key === 'overdraw' ) {\\n\\n\\t\\t\\t\\t\\t// ensure overdraw is backwards-compatible with legacy boolean type\\n\\t\\t\\t\\t\\tthis[ key ] = Number( newValue );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthis[ key ] = newValue;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( meta ) {\\n\\n\\t\\t\\tvar isRoot = ( meta === undefined || typeof meta === 'string' );\\n\\n\\t\\t\\tif ( isRoot ) {\\n\\n\\t\\t\\t\\tmeta = {\\n\\t\\t\\t\\t\\ttextures: {},\\n\\t\\t\\t\\t\\timages: {}\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar data = {\\n\\t\\t\\t\\tmetadata: {\\n\\t\\t\\t\\t\\tversion: 4.5,\\n\\t\\t\\t\\t\\ttype: 'Material',\\n\\t\\t\\t\\t\\tgenerator: 'Material.toJSON'\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\t\\t// standard Material serialization\\n\\t\\t\\tdata.uuid = this.uuid;\\n\\t\\t\\tdata.type = this.type;\\n\\n\\t\\t\\tif ( this.name !== '' ) data.name = this.name;\\n\\n\\t\\t\\tif ( this.color && this.color.isColor ) data.color = this.color.getHex();\\n\\n\\t\\t\\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\\n\\t\\t\\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\\n\\n\\t\\t\\tif ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();\\n\\t\\t\\tif ( this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;\\n\\n\\t\\t\\tif ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();\\n\\t\\t\\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\\n\\t\\t\\tif ( this.clearCoat !== undefined ) data.clearCoat = this.clearCoat;\\n\\t\\t\\tif ( this.clearCoatRoughness !== undefined ) data.clearCoatRoughness = this.clearCoatRoughness;\\n\\n\\t\\t\\tif ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;\\n\\t\\t\\tif ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\\n\\t\\t\\tif ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\\n\\t\\t\\tif ( this.bumpMap && this.bumpMap.isTexture ) {\\n\\n\\t\\t\\t\\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\\n\\t\\t\\t\\tdata.bumpScale = this.bumpScale;\\n\\n\\t\\t\\t}\\n\\t\\t\\tif ( this.normalMap && this.normalMap.isTexture ) {\\n\\n\\t\\t\\t\\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\\n\\t\\t\\t\\tdata.normalScale = this.normalScale.toArray();\\n\\n\\t\\t\\t}\\n\\t\\t\\tif ( this.displacementMap && this.displacementMap.isTexture ) {\\n\\n\\t\\t\\t\\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\\n\\t\\t\\t\\tdata.displacementScale = this.displacementScale;\\n\\t\\t\\t\\tdata.displacementBias = this.displacementBias;\\n\\n\\t\\t\\t}\\n\\t\\t\\tif ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\\n\\t\\t\\tif ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\\n\\n\\t\\t\\tif ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\\n\\t\\t\\tif ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\\n\\n\\t\\t\\tif ( this.envMap && this.envMap.isTexture ) {\\n\\n\\t\\t\\t\\tdata.envMap = this.envMap.toJSON( meta ).uuid;\\n\\t\\t\\t\\tdata.reflectivity = this.reflectivity; // Scale behind envMap\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.gradientMap && this.gradientMap.isTexture ) {\\n\\n\\t\\t\\t\\tdata.gradientMap = this.gradientMap.toJSON( meta ).uuid;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.size !== undefined ) data.size = this.size;\\n\\t\\t\\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\\n\\n\\t\\t\\tif ( this.blending !== NormalBlending ) data.blending = this.blending;\\n\\t\\t\\tif ( this.flatShading === true ) data.flatShading = this.flatShading;\\n\\t\\t\\tif ( this.side !== FrontSide ) data.side = this.side;\\n\\t\\t\\tif ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;\\n\\n\\t\\t\\tif ( this.opacity < 1 ) data.opacity = this.opacity;\\n\\t\\t\\tif ( this.transparent === true ) data.transparent = this.transparent;\\n\\n\\t\\t\\tdata.depthFunc = this.depthFunc;\\n\\t\\t\\tdata.depthTest = this.depthTest;\\n\\t\\t\\tdata.depthWrite = this.depthWrite;\\n\\n\\t\\t\\t// rotation (SpriteMaterial)\\n\\t\\t\\tif ( this.rotation !== 0 ) data.rotation = this.rotation;\\n\\n\\t\\t\\tif ( this.linewidth !== 1 ) data.linewidth = this.linewidth;\\n\\t\\t\\tif ( this.dashSize !== undefined ) data.dashSize = this.dashSize;\\n\\t\\t\\tif ( this.gapSize !== undefined ) data.gapSize = this.gapSize;\\n\\t\\t\\tif ( this.scale !== undefined ) data.scale = this.scale;\\n\\n\\t\\t\\tif ( this.dithering === true ) data.dithering = true;\\n\\n\\t\\t\\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\\n\\t\\t\\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\\n\\n\\t\\t\\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\\n\\t\\t\\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\\n\\t\\t\\tif ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;\\n\\t\\t\\tif ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;\\n\\n\\t\\t\\tif ( this.morphTargets === true ) data.morphTargets = true;\\n\\t\\t\\tif ( this.skinning === true ) data.skinning = true;\\n\\n\\t\\t\\tif ( this.visible === false ) data.visible = false;\\n\\t\\t\\tif ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;\\n\\n\\t\\t\\t// TODO: Copied from Object3D.toJSON\\n\\n\\t\\t\\tfunction extractFromCache( cache ) {\\n\\n\\t\\t\\t\\tvar values = [];\\n\\n\\t\\t\\t\\tfor ( var key in cache ) {\\n\\n\\t\\t\\t\\t\\tvar data = cache[ key ];\\n\\t\\t\\t\\t\\tdelete data.metadata;\\n\\t\\t\\t\\t\\tvalues.push( data );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn values;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( isRoot ) {\\n\\n\\t\\t\\t\\tvar textures = extractFromCache( meta.textures );\\n\\t\\t\\t\\tvar images = extractFromCache( meta.images );\\n\\n\\t\\t\\t\\tif ( textures.length > 0 ) data.textures = textures;\\n\\t\\t\\t\\tif ( images.length > 0 ) data.images = images;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tthis.name = source.name;\\n\\n\\t\\t\\tthis.fog = source.fog;\\n\\t\\t\\tthis.lights = source.lights;\\n\\n\\t\\t\\tthis.blending = source.blending;\\n\\t\\t\\tthis.side = source.side;\\n\\t\\t\\tthis.flatShading = source.flatShading;\\n\\t\\t\\tthis.vertexColors = source.vertexColors;\\n\\n\\t\\t\\tthis.opacity = source.opacity;\\n\\t\\t\\tthis.transparent = source.transparent;\\n\\n\\t\\t\\tthis.blendSrc = source.blendSrc;\\n\\t\\t\\tthis.blendDst = source.blendDst;\\n\\t\\t\\tthis.blendEquation = source.blendEquation;\\n\\t\\t\\tthis.blendSrcAlpha = source.blendSrcAlpha;\\n\\t\\t\\tthis.blendDstAlpha = source.blendDstAlpha;\\n\\t\\t\\tthis.blendEquationAlpha = source.blendEquationAlpha;\\n\\n\\t\\t\\tthis.depthFunc = source.depthFunc;\\n\\t\\t\\tthis.depthTest = source.depthTest;\\n\\t\\t\\tthis.depthWrite = source.depthWrite;\\n\\n\\t\\t\\tthis.colorWrite = source.colorWrite;\\n\\n\\t\\t\\tthis.precision = source.precision;\\n\\n\\t\\t\\tthis.polygonOffset = source.polygonOffset;\\n\\t\\t\\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\\n\\t\\t\\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\\n\\n\\t\\t\\tthis.dithering = source.dithering;\\n\\n\\t\\t\\tthis.alphaTest = source.alphaTest;\\n\\t\\t\\tthis.premultipliedAlpha = source.premultipliedAlpha;\\n\\n\\t\\t\\tthis.overdraw = source.overdraw;\\n\\n\\t\\t\\tthis.visible = source.visible;\\n\\t\\t\\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\\n\\n\\t\\t\\tthis.clipShadows = source.clipShadows;\\n\\t\\t\\tthis.clipIntersection = source.clipIntersection;\\n\\n\\t\\t\\tvar srcPlanes = source.clippingPlanes,\\n\\t\\t\\t\\tdstPlanes = null;\\n\\n\\t\\t\\tif ( srcPlanes !== null ) {\\n\\n\\t\\t\\t\\tvar n = srcPlanes.length;\\n\\t\\t\\t\\tdstPlanes = new Array( n );\\n\\n\\t\\t\\t\\tfor ( var i = 0; i !== n; ++ i )\\n\\t\\t\\t\\t\\tdstPlanes[ i ] = srcPlanes[ i ].clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.clippingPlanes = dstPlanes;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdispose: function () {\\n\\n\\t\\t\\tthis.dispatchEvent( { type: 'dispose' } );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author bhouston / https://clara.io\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t *\\n\\t * parameters = {\\n\\t *\\n\\t *  opacity: <float>,\\n\\t *\\n\\t *  map: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  alphaMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  displacementMap: new THREE.Texture( <Image> ),\\n\\t *  displacementScale: <float>,\\n\\t *  displacementBias: <float>,\\n\\t *\\n\\t *  wireframe: <boolean>,\\n\\t *  wireframeLinewidth: <float>\\n\\t * }\\n\\t */\\n\\n\\tfunction MeshDepthMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'MeshDepthMaterial';\\n\\n\\t\\tthis.depthPacking = BasicDepthPacking;\\n\\n\\t\\tthis.skinning = false;\\n\\t\\tthis.morphTargets = false;\\n\\n\\t\\tthis.map = null;\\n\\n\\t\\tthis.alphaMap = null;\\n\\n\\t\\tthis.displacementMap = null;\\n\\t\\tthis.displacementScale = 1;\\n\\t\\tthis.displacementBias = 0;\\n\\n\\t\\tthis.wireframe = false;\\n\\t\\tthis.wireframeLinewidth = 1;\\n\\n\\t\\tthis.fog = false;\\n\\t\\tthis.lights = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tMeshDepthMaterial.prototype = Object.create( Material.prototype );\\n\\tMeshDepthMaterial.prototype.constructor = MeshDepthMaterial;\\n\\n\\tMeshDepthMaterial.prototype.isMeshDepthMaterial = true;\\n\\n\\tMeshDepthMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.depthPacking = source.depthPacking;\\n\\n\\t\\tthis.skinning = source.skinning;\\n\\t\\tthis.morphTargets = source.morphTargets;\\n\\n\\t\\tthis.map = source.map;\\n\\n\\t\\tthis.alphaMap = source.alphaMap;\\n\\n\\t\\tthis.displacementMap = source.displacementMap;\\n\\t\\tthis.displacementScale = source.displacementScale;\\n\\t\\tthis.displacementBias = source.displacementBias;\\n\\n\\t\\tthis.wireframe = source.wireframe;\\n\\t\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t *\\n\\t * parameters = {\\n\\t *\\n\\t *  referencePosition: <float>,\\n\\t *  nearDistance: <float>,\\n\\t *  farDistance: <float>,\\n\\t *\\n\\t *  skinning: <bool>,\\n\\t *  morphTargets: <bool>,\\n\\t *\\n\\t *  map: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  alphaMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  displacementMap: new THREE.Texture( <Image> ),\\n\\t *  displacementScale: <float>,\\n\\t *  displacementBias: <float>\\n\\t *\\n\\t * }\\n\\t */\\n\\n\\tfunction MeshDistanceMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'MeshDistanceMaterial';\\n\\n\\t\\tthis.referencePosition = new Vector3();\\n\\t\\tthis.nearDistance = 1;\\n\\t\\tthis.farDistance = 1000;\\n\\n\\t\\tthis.skinning = false;\\n\\t\\tthis.morphTargets = false;\\n\\n\\t\\tthis.map = null;\\n\\n\\t\\tthis.alphaMap = null;\\n\\n\\t\\tthis.displacementMap = null;\\n\\t\\tthis.displacementScale = 1;\\n\\t\\tthis.displacementBias = 0;\\n\\n\\t\\tthis.fog = false;\\n\\t\\tthis.lights = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tMeshDistanceMaterial.prototype = Object.create( Material.prototype );\\n\\tMeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;\\n\\n\\tMeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;\\n\\n\\tMeshDistanceMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.referencePosition.copy( source.referencePosition );\\n\\t\\tthis.nearDistance = source.nearDistance;\\n\\t\\tthis.farDistance = source.farDistance;\\n\\n\\t\\tthis.skinning = source.skinning;\\n\\t\\tthis.morphTargets = source.morphTargets;\\n\\n\\t\\tthis.map = source.map;\\n\\n\\t\\tthis.alphaMap = source.alphaMap;\\n\\n\\t\\tthis.displacementMap = source.displacementMap;\\n\\t\\tthis.displacementScale = source.displacementScale;\\n\\t\\tthis.displacementBias = source.displacementBias;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author bhouston / http://clara.io\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction Box3( min, max ) {\\n\\n\\t\\tthis.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );\\n\\t\\tthis.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );\\n\\n\\t}\\n\\n\\tObject.assign( Box3.prototype, {\\n\\n\\t\\tisBox3: true,\\n\\n\\t\\tset: function ( min, max ) {\\n\\n\\t\\t\\tthis.min.copy( min );\\n\\t\\t\\tthis.max.copy( max );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromArray: function ( array ) {\\n\\n\\t\\t\\tvar minX = + Infinity;\\n\\t\\t\\tvar minY = + Infinity;\\n\\t\\t\\tvar minZ = + Infinity;\\n\\n\\t\\t\\tvar maxX = - Infinity;\\n\\t\\t\\tvar maxY = - Infinity;\\n\\t\\t\\tvar maxZ = - Infinity;\\n\\n\\t\\t\\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\\n\\n\\t\\t\\t\\tvar x = array[ i ];\\n\\t\\t\\t\\tvar y = array[ i + 1 ];\\n\\t\\t\\t\\tvar z = array[ i + 2 ];\\n\\n\\t\\t\\t\\tif ( x < minX ) minX = x;\\n\\t\\t\\t\\tif ( y < minY ) minY = y;\\n\\t\\t\\t\\tif ( z < minZ ) minZ = z;\\n\\n\\t\\t\\t\\tif ( x > maxX ) maxX = x;\\n\\t\\t\\t\\tif ( y > maxY ) maxY = y;\\n\\t\\t\\t\\tif ( z > maxZ ) maxZ = z;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.min.set( minX, minY, minZ );\\n\\t\\t\\tthis.max.set( maxX, maxY, maxZ );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromBufferAttribute: function ( attribute ) {\\n\\n\\t\\t\\tvar minX = + Infinity;\\n\\t\\t\\tvar minY = + Infinity;\\n\\t\\t\\tvar minZ = + Infinity;\\n\\n\\t\\t\\tvar maxX = - Infinity;\\n\\t\\t\\tvar maxY = - Infinity;\\n\\t\\t\\tvar maxZ = - Infinity;\\n\\n\\t\\t\\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar x = attribute.getX( i );\\n\\t\\t\\t\\tvar y = attribute.getY( i );\\n\\t\\t\\t\\tvar z = attribute.getZ( i );\\n\\n\\t\\t\\t\\tif ( x < minX ) minX = x;\\n\\t\\t\\t\\tif ( y < minY ) minY = y;\\n\\t\\t\\t\\tif ( z < minZ ) minZ = z;\\n\\n\\t\\t\\t\\tif ( x > maxX ) maxX = x;\\n\\t\\t\\t\\tif ( y > maxY ) maxY = y;\\n\\t\\t\\t\\tif ( z > maxZ ) maxZ = z;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.min.set( minX, minY, minZ );\\n\\t\\t\\tthis.max.set( maxX, maxY, maxZ );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromPoints: function ( points ) {\\n\\n\\t\\t\\tthis.makeEmpty();\\n\\n\\t\\t\\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.expandByPoint( points[ i ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromCenterAndSize: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function setFromCenterAndSize( center, size ) {\\n\\n\\t\\t\\t\\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\\n\\n\\t\\t\\t\\tthis.min.copy( center ).sub( halfSize );\\n\\t\\t\\t\\tthis.max.copy( center ).add( halfSize );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tsetFromObject: function ( object ) {\\n\\n\\t\\t\\tthis.makeEmpty();\\n\\n\\t\\t\\treturn this.expandByObject( object );\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( box ) {\\n\\n\\t\\t\\tthis.min.copy( box.min );\\n\\t\\t\\tthis.max.copy( box.max );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeEmpty: function () {\\n\\n\\t\\t\\tthis.min.x = this.min.y = this.min.z = + Infinity;\\n\\t\\t\\tthis.max.x = this.max.y = this.max.z = - Infinity;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tisEmpty: function () {\\n\\n\\t\\t\\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\\n\\n\\t\\t\\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\\n\\n\\t\\t},\\n\\n\\t\\tgetCenter: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\t\\t\\treturn this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\\n\\n\\t\\t},\\n\\n\\t\\tgetSize: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\t\\t\\treturn this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );\\n\\n\\t\\t},\\n\\n\\t\\texpandByPoint: function ( point ) {\\n\\n\\t\\t\\tthis.min.min( point );\\n\\t\\t\\tthis.max.max( point );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\texpandByVector: function ( vector ) {\\n\\n\\t\\t\\tthis.min.sub( vector );\\n\\t\\t\\tthis.max.add( vector );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\texpandByScalar: function ( scalar ) {\\n\\n\\t\\t\\tthis.min.addScalar( - scalar );\\n\\t\\t\\tthis.max.addScalar( scalar );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\texpandByObject: function () {\\n\\n\\t\\t\\t// Computes the world-axis-aligned bounding box of an object (including its children),\\n\\t\\t\\t// accounting for both the object's, and children's, world transforms\\n\\n\\t\\t\\tvar scope, i, l;\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\tfunction traverse( node ) {\\n\\n\\t\\t\\t\\tvar geometry = node.geometry;\\n\\n\\t\\t\\t\\tif ( geometry !== undefined ) {\\n\\n\\t\\t\\t\\t\\tif ( geometry.isGeometry ) {\\n\\n\\t\\t\\t\\t\\t\\tvar vertices = geometry.vertices;\\n\\n\\t\\t\\t\\t\\t\\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tv1.copy( vertices[ i ] );\\n\\t\\t\\t\\t\\t\\t\\tv1.applyMatrix4( node.matrixWorld );\\n\\n\\t\\t\\t\\t\\t\\t\\tscope.expandByPoint( v1 );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else if ( geometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\t\\t\\tvar attribute = geometry.attributes.position;\\n\\n\\t\\t\\t\\t\\t\\tif ( attribute !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( i = 0, l = attribute.count; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tv1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tscope.expandByPoint( v1 );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn function expandByObject( object ) {\\n\\n\\t\\t\\t\\tscope = this;\\n\\n\\t\\t\\t\\tobject.updateMatrixWorld( true );\\n\\n\\t\\t\\t\\tobject.traverse( traverse );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tcontainsPoint: function ( point ) {\\n\\n\\t\\t\\treturn point.x < this.min.x || point.x > this.max.x ||\\n\\t\\t\\t\\tpoint.y < this.min.y || point.y > this.max.y ||\\n\\t\\t\\t\\tpoint.z < this.min.z || point.z > this.max.z ? false : true;\\n\\n\\t\\t},\\n\\n\\t\\tcontainsBox: function ( box ) {\\n\\n\\t\\t\\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\\n\\t\\t\\t\\tthis.min.y <= box.min.y && box.max.y <= this.max.y &&\\n\\t\\t\\t\\tthis.min.z <= box.min.z && box.max.z <= this.max.z;\\n\\n\\t\\t},\\n\\n\\t\\tgetParameter: function ( point, optionalTarget ) {\\n\\n\\t\\t\\t// This can potentially have a divide by zero if the box\\n\\t\\t\\t// has a size dimension of 0.\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\treturn result.set(\\n\\t\\t\\t\\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\\n\\t\\t\\t\\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\\n\\t\\t\\t\\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\\n\\t\\t\\t);\\n\\n\\t\\t},\\n\\n\\t\\tintersectsBox: function ( box ) {\\n\\n\\t\\t\\t// using 6 splitting planes to rule out intersections.\\n\\t\\t\\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\\n\\t\\t\\t\\tbox.max.y < this.min.y || box.min.y > this.max.y ||\\n\\t\\t\\t\\tbox.max.z < this.min.z || box.min.z > this.max.z ? false : true;\\n\\n\\t\\t},\\n\\n\\t\\tintersectsSphere: ( function () {\\n\\n\\t\\t\\tvar closestPoint = new Vector3();\\n\\n\\t\\t\\treturn function intersectsSphere( sphere ) {\\n\\n\\t\\t\\t\\t// Find the point on the AABB closest to the sphere center.\\n\\t\\t\\t\\tthis.clampPoint( sphere.center, closestPoint );\\n\\n\\t\\t\\t\\t// If that point is inside the sphere, the AABB and sphere intersect.\\n\\t\\t\\t\\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )(),\\n\\n\\t\\tintersectsPlane: function ( plane ) {\\n\\n\\t\\t\\t// We compute the minimum and maximum dot product values. If those values\\n\\t\\t\\t// are on the same side (back or front) of the plane, then there is no intersection.\\n\\n\\t\\t\\tvar min, max;\\n\\n\\t\\t\\tif ( plane.normal.x > 0 ) {\\n\\n\\t\\t\\t\\tmin = plane.normal.x * this.min.x;\\n\\t\\t\\t\\tmax = plane.normal.x * this.max.x;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tmin = plane.normal.x * this.max.x;\\n\\t\\t\\t\\tmax = plane.normal.x * this.min.x;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( plane.normal.y > 0 ) {\\n\\n\\t\\t\\t\\tmin += plane.normal.y * this.min.y;\\n\\t\\t\\t\\tmax += plane.normal.y * this.max.y;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tmin += plane.normal.y * this.max.y;\\n\\t\\t\\t\\tmax += plane.normal.y * this.min.y;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( plane.normal.z > 0 ) {\\n\\n\\t\\t\\t\\tmin += plane.normal.z * this.min.z;\\n\\t\\t\\t\\tmax += plane.normal.z * this.max.z;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tmin += plane.normal.z * this.max.z;\\n\\t\\t\\t\\tmax += plane.normal.z * this.min.z;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ( min <= plane.constant && max >= plane.constant );\\n\\n\\t\\t},\\n\\n\\t\\tclampPoint: function ( point, optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\t\\t\\treturn result.copy( point ).clamp( this.min, this.max );\\n\\n\\t\\t},\\n\\n\\t\\tdistanceToPoint: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function distanceToPoint( point ) {\\n\\n\\t\\t\\t\\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\\n\\t\\t\\t\\treturn clampedPoint.sub( point ).length();\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tgetBoundingSphere: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function getBoundingSphere( optionalTarget ) {\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Sphere();\\n\\n\\t\\t\\t\\tthis.getCenter( result.center );\\n\\n\\t\\t\\t\\tresult.radius = this.getSize( v1 ).length() * 0.5;\\n\\n\\t\\t\\t\\treturn result;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tintersect: function ( box ) {\\n\\n\\t\\t\\tthis.min.max( box.min );\\n\\t\\t\\tthis.max.min( box.max );\\n\\n\\t\\t\\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\\n\\t\\t\\tif ( this.isEmpty() ) this.makeEmpty();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tunion: function ( box ) {\\n\\n\\t\\t\\tthis.min.min( box.min );\\n\\t\\t\\tthis.max.max( box.max );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tapplyMatrix4: function () {\\n\\n\\t\\t\\tvar points = [\\n\\t\\t\\t\\tnew Vector3(),\\n\\t\\t\\t\\tnew Vector3(),\\n\\t\\t\\t\\tnew Vector3(),\\n\\t\\t\\t\\tnew Vector3(),\\n\\t\\t\\t\\tnew Vector3(),\\n\\t\\t\\t\\tnew Vector3(),\\n\\t\\t\\t\\tnew Vector3(),\\n\\t\\t\\t\\tnew Vector3()\\n\\t\\t\\t];\\n\\n\\t\\t\\treturn function applyMatrix4( matrix ) {\\n\\n\\t\\t\\t\\t// transform of empty box is an empty box.\\n\\t\\t\\t\\tif ( this.isEmpty() ) return this;\\n\\n\\t\\t\\t\\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\\n\\t\\t\\t\\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\\n\\t\\t\\t\\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\\n\\t\\t\\t\\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\\n\\t\\t\\t\\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\\n\\t\\t\\t\\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\\n\\t\\t\\t\\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\\n\\t\\t\\t\\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\\n\\t\\t\\t\\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );\\t// 111\\n\\n\\t\\t\\t\\tthis.setFromPoints( points );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttranslate: function ( offset ) {\\n\\n\\t\\t\\tthis.min.add( offset );\\n\\t\\t\\tthis.max.add( offset );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( box ) {\\n\\n\\t\\t\\treturn box.min.equals( this.min ) && box.max.equals( this.max );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author bhouston / http://clara.io\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction Sphere( center, radius ) {\\n\\n\\t\\tthis.center = ( center !== undefined ) ? center : new Vector3();\\n\\t\\tthis.radius = ( radius !== undefined ) ? radius : 0;\\n\\n\\t}\\n\\n\\tObject.assign( Sphere.prototype, {\\n\\n\\t\\tset: function ( center, radius ) {\\n\\n\\t\\t\\tthis.center.copy( center );\\n\\t\\t\\tthis.radius = radius;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromPoints: function () {\\n\\n\\t\\t\\tvar box = new Box3();\\n\\n\\t\\t\\treturn function setFromPoints( points, optionalCenter ) {\\n\\n\\t\\t\\t\\tvar center = this.center;\\n\\n\\t\\t\\t\\tif ( optionalCenter !== undefined ) {\\n\\n\\t\\t\\t\\t\\tcenter.copy( optionalCenter );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tbox.setFromPoints( points ).getCenter( center );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar maxRadiusSq = 0;\\n\\n\\t\\t\\t\\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.radius = Math.sqrt( maxRadiusSq );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( sphere ) {\\n\\n\\t\\t\\tthis.center.copy( sphere.center );\\n\\t\\t\\tthis.radius = sphere.radius;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tempty: function () {\\n\\n\\t\\t\\treturn ( this.radius <= 0 );\\n\\n\\t\\t},\\n\\n\\t\\tcontainsPoint: function ( point ) {\\n\\n\\t\\t\\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\\n\\n\\t\\t},\\n\\n\\t\\tdistanceToPoint: function ( point ) {\\n\\n\\t\\t\\treturn ( point.distanceTo( this.center ) - this.radius );\\n\\n\\t\\t},\\n\\n\\t\\tintersectsSphere: function ( sphere ) {\\n\\n\\t\\t\\tvar radiusSum = this.radius + sphere.radius;\\n\\n\\t\\t\\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\\n\\n\\t\\t},\\n\\n\\t\\tintersectsBox: function ( box ) {\\n\\n\\t\\t\\treturn box.intersectsSphere( this );\\n\\n\\t\\t},\\n\\n\\t\\tintersectsPlane: function ( plane ) {\\n\\n\\t\\t\\treturn Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;\\n\\n\\t\\t},\\n\\n\\t\\tclampPoint: function ( point, optionalTarget ) {\\n\\n\\t\\t\\tvar deltaLengthSq = this.center.distanceToSquared( point );\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\tresult.copy( point );\\n\\n\\t\\t\\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\\n\\n\\t\\t\\t\\tresult.sub( this.center ).normalize();\\n\\t\\t\\t\\tresult.multiplyScalar( this.radius ).add( this.center );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\n\\t\\t},\\n\\n\\t\\tgetBoundingBox: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar box = optionalTarget || new Box3();\\n\\n\\t\\t\\tbox.set( this.center, this.center );\\n\\t\\t\\tbox.expandByScalar( this.radius );\\n\\n\\t\\t\\treturn box;\\n\\n\\t\\t},\\n\\n\\t\\tapplyMatrix4: function ( matrix ) {\\n\\n\\t\\t\\tthis.center.applyMatrix4( matrix );\\n\\t\\t\\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttranslate: function ( offset ) {\\n\\n\\t\\t\\tthis.center.add( offset );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( sphere ) {\\n\\n\\t\\t\\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author bhouston / http://clara.io\\n\\t */\\n\\n\\tfunction Plane( normal, constant ) {\\n\\n\\t\\t// normal is assumed to be normalized\\n\\n\\t\\tthis.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );\\n\\t\\tthis.constant = ( constant !== undefined ) ? constant : 0;\\n\\n\\t}\\n\\n\\tObject.assign( Plane.prototype, {\\n\\n\\t\\tset: function ( normal, constant ) {\\n\\n\\t\\t\\tthis.normal.copy( normal );\\n\\t\\t\\tthis.constant = constant;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetComponents: function ( x, y, z, w ) {\\n\\n\\t\\t\\tthis.normal.set( x, y, z );\\n\\t\\t\\tthis.constant = w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\\n\\n\\t\\t\\tthis.normal.copy( normal );\\n\\t\\t\\tthis.constant = - point.dot( this.normal );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromCoplanarPoints: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\t\\t\\tvar v2 = new Vector3();\\n\\n\\t\\t\\treturn function setFromCoplanarPoints( a, b, c ) {\\n\\n\\t\\t\\t\\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\\n\\n\\t\\t\\t\\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\\n\\n\\t\\t\\t\\tthis.setFromNormalAndCoplanarPoint( normal, a );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( plane ) {\\n\\n\\t\\t\\tthis.normal.copy( plane.normal );\\n\\t\\t\\tthis.constant = plane.constant;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tnormalize: function () {\\n\\n\\t\\t\\t// Note: will lead to a divide by zero if the plane is invalid.\\n\\n\\t\\t\\tvar inverseNormalLength = 1.0 / this.normal.length();\\n\\t\\t\\tthis.normal.multiplyScalar( inverseNormalLength );\\n\\t\\t\\tthis.constant *= inverseNormalLength;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tnegate: function () {\\n\\n\\t\\t\\tthis.constant *= - 1;\\n\\t\\t\\tthis.normal.negate();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdistanceToPoint: function ( point ) {\\n\\n\\t\\t\\treturn this.normal.dot( point ) + this.constant;\\n\\n\\t\\t},\\n\\n\\t\\tdistanceToSphere: function ( sphere ) {\\n\\n\\t\\t\\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\\n\\n\\t\\t},\\n\\n\\t\\tprojectPoint: function ( point, optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\treturn result.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );\\n\\n\\t\\t},\\n\\n\\t\\tintersectLine: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function intersectLine( line, optionalTarget ) {\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\t\\tvar direction = line.delta( v1 );\\n\\n\\t\\t\\t\\tvar denominator = this.normal.dot( direction );\\n\\n\\t\\t\\t\\tif ( denominator === 0 ) {\\n\\n\\t\\t\\t\\t\\t// line is coplanar, return origin\\n\\t\\t\\t\\t\\tif ( this.distanceToPoint( line.start ) === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\treturn result.copy( line.start );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Unsure if this is the correct method to handle this case.\\n\\t\\t\\t\\t\\treturn undefined;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\\n\\n\\t\\t\\t\\tif ( t < 0 || t > 1 ) {\\n\\n\\t\\t\\t\\t\\treturn undefined;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tintersectsLine: function ( line ) {\\n\\n\\t\\t\\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\\n\\n\\t\\t\\tvar startSign = this.distanceToPoint( line.start );\\n\\t\\t\\tvar endSign = this.distanceToPoint( line.end );\\n\\n\\t\\t\\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\\n\\n\\t\\t},\\n\\n\\t\\tintersectsBox: function ( box ) {\\n\\n\\t\\t\\treturn box.intersectsPlane( this );\\n\\n\\t\\t},\\n\\n\\t\\tintersectsSphere: function ( sphere ) {\\n\\n\\t\\t\\treturn sphere.intersectsPlane( this );\\n\\n\\t\\t},\\n\\n\\t\\tcoplanarPoint: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\\n\\n\\t\\t},\\n\\n\\t\\tapplyMatrix4: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\t\\t\\tvar m1 = new Matrix3();\\n\\n\\t\\t\\treturn function applyMatrix4( matrix, optionalNormalMatrix ) {\\n\\n\\t\\t\\t\\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\\n\\n\\t\\t\\t\\tvar referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\\n\\n\\t\\t\\t\\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\\n\\n\\t\\t\\t\\tthis.constant = - referencePoint.dot( normal );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttranslate: function ( offset ) {\\n\\n\\t\\t\\tthis.constant -= offset.dot( this.normal );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( plane ) {\\n\\n\\t\\t\\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author bhouston / http://clara.io\\n\\t */\\n\\n\\tfunction Frustum( p0, p1, p2, p3, p4, p5 ) {\\n\\n\\t\\tthis.planes = [\\n\\n\\t\\t\\t( p0 !== undefined ) ? p0 : new Plane(),\\n\\t\\t\\t( p1 !== undefined ) ? p1 : new Plane(),\\n\\t\\t\\t( p2 !== undefined ) ? p2 : new Plane(),\\n\\t\\t\\t( p3 !== undefined ) ? p3 : new Plane(),\\n\\t\\t\\t( p4 !== undefined ) ? p4 : new Plane(),\\n\\t\\t\\t( p5 !== undefined ) ? p5 : new Plane()\\n\\n\\t\\t];\\n\\n\\t}\\n\\n\\tObject.assign( Frustum.prototype, {\\n\\n\\t\\tset: function ( p0, p1, p2, p3, p4, p5 ) {\\n\\n\\t\\t\\tvar planes = this.planes;\\n\\n\\t\\t\\tplanes[ 0 ].copy( p0 );\\n\\t\\t\\tplanes[ 1 ].copy( p1 );\\n\\t\\t\\tplanes[ 2 ].copy( p2 );\\n\\t\\t\\tplanes[ 3 ].copy( p3 );\\n\\t\\t\\tplanes[ 4 ].copy( p4 );\\n\\t\\t\\tplanes[ 5 ].copy( p5 );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( frustum ) {\\n\\n\\t\\t\\tvar planes = this.planes;\\n\\n\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\tplanes[ i ].copy( frustum.planes[ i ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromMatrix: function ( m ) {\\n\\n\\t\\t\\tvar planes = this.planes;\\n\\t\\t\\tvar me = m.elements;\\n\\t\\t\\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\\n\\t\\t\\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\\n\\t\\t\\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\\n\\t\\t\\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\\n\\n\\t\\t\\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\\n\\t\\t\\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\\n\\t\\t\\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\\n\\t\\t\\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\\n\\t\\t\\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\\n\\t\\t\\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tintersectsObject: function () {\\n\\n\\t\\t\\tvar sphere = new Sphere();\\n\\n\\t\\t\\treturn function intersectsObject( object ) {\\n\\n\\t\\t\\t\\tvar geometry = object.geometry;\\n\\n\\t\\t\\t\\tif ( geometry.boundingSphere === null )\\n\\t\\t\\t\\t\\tgeometry.computeBoundingSphere();\\n\\n\\t\\t\\t\\tsphere.copy( geometry.boundingSphere )\\n\\t\\t\\t\\t\\t.applyMatrix4( object.matrixWorld );\\n\\n\\t\\t\\t\\treturn this.intersectsSphere( sphere );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tintersectsSprite: function () {\\n\\n\\t\\t\\tvar sphere = new Sphere();\\n\\n\\t\\t\\treturn function intersectsSprite( sprite ) {\\n\\n\\t\\t\\t\\tsphere.center.set( 0, 0, 0 );\\n\\t\\t\\t\\tsphere.radius = 0.7071067811865476;\\n\\t\\t\\t\\tsphere.applyMatrix4( sprite.matrixWorld );\\n\\n\\t\\t\\t\\treturn this.intersectsSphere( sphere );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tintersectsSphere: function ( sphere ) {\\n\\n\\t\\t\\tvar planes = this.planes;\\n\\t\\t\\tvar center = sphere.center;\\n\\t\\t\\tvar negRadius = - sphere.radius;\\n\\n\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\tvar distance = planes[ i ].distanceToPoint( center );\\n\\n\\t\\t\\t\\tif ( distance < negRadius ) {\\n\\n\\t\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn true;\\n\\n\\t\\t},\\n\\n\\t\\tintersectsBox: function () {\\n\\n\\t\\t\\tvar p1 = new Vector3(),\\n\\t\\t\\t\\tp2 = new Vector3();\\n\\n\\t\\t\\treturn function intersectsBox( box ) {\\n\\n\\t\\t\\t\\tvar planes = this.planes;\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar plane = planes[ i ];\\n\\n\\t\\t\\t\\t\\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\\n\\t\\t\\t\\t\\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\\n\\t\\t\\t\\t\\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\\n\\t\\t\\t\\t\\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\\n\\t\\t\\t\\t\\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\\n\\t\\t\\t\\t\\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\\n\\n\\t\\t\\t\\t\\tvar d1 = plane.distanceToPoint( p1 );\\n\\t\\t\\t\\t\\tvar d2 = plane.distanceToPoint( p2 );\\n\\n\\t\\t\\t\\t\\t// if both outside plane, no intersection\\n\\n\\t\\t\\t\\t\\tif ( d1 < 0 && d2 < 0 ) {\\n\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tcontainsPoint: function ( point ) {\\n\\n\\t\\t\\tvar planes = this.planes;\\n\\n\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\\n\\n\\t\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn true;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLShadowMap( _renderer, _objects, maxTextureSize ) {\\n\\n\\t\\tvar _frustum = new Frustum(),\\n\\t\\t\\t_projScreenMatrix = new Matrix4(),\\n\\n\\t\\t\\t_shadowMapSize = new Vector2(),\\n\\t\\t\\t_maxShadowMapSize = new Vector2( maxTextureSize, maxTextureSize ),\\n\\n\\t\\t\\t_lookTarget = new Vector3(),\\n\\t\\t\\t_lightPositionWorld = new Vector3(),\\n\\n\\t\\t\\t_MorphingFlag = 1,\\n\\t\\t\\t_SkinningFlag = 2,\\n\\n\\t\\t\\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\\n\\n\\t\\t\\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\\n\\t\\t\\t_distanceMaterials = new Array( _NumberOfMaterialVariants ),\\n\\n\\t\\t\\t_materialCache = {};\\n\\n\\t\\tvar cubeDirections = [\\n\\t\\t\\tnew Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),\\n\\t\\t\\tnew Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )\\n\\t\\t];\\n\\n\\t\\tvar cubeUps = [\\n\\t\\t\\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),\\n\\t\\t\\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),\\tnew Vector3( 0, 0, - 1 )\\n\\t\\t];\\n\\n\\t\\tvar cube2DViewPorts = [\\n\\t\\t\\tnew Vector4(), new Vector4(), new Vector4(),\\n\\t\\t\\tnew Vector4(), new Vector4(), new Vector4()\\n\\t\\t];\\n\\n\\t\\t// init\\n\\n\\t\\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\\n\\n\\t\\t\\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\\n\\t\\t\\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\\n\\n\\t\\t\\tvar depthMaterial = new MeshDepthMaterial( {\\n\\n\\t\\t\\t\\tdepthPacking: RGBADepthPacking,\\n\\n\\t\\t\\t\\tmorphTargets: useMorphing,\\n\\t\\t\\t\\tskinning: useSkinning\\n\\n\\t\\t\\t} );\\n\\n\\t\\t\\t_depthMaterials[ i ] = depthMaterial;\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar distanceMaterial = new MeshDistanceMaterial( {\\n\\n\\t\\t\\t\\tmorphTargets: useMorphing,\\n\\t\\t\\t\\tskinning: useSkinning\\n\\n\\t\\t\\t} );\\n\\n\\t\\t\\t_distanceMaterials[ i ] = distanceMaterial;\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\tthis.enabled = false;\\n\\n\\t\\tthis.autoUpdate = true;\\n\\t\\tthis.needsUpdate = false;\\n\\n\\t\\tthis.type = PCFShadowMap;\\n\\n\\t\\tthis.renderReverseSided = true;\\n\\t\\tthis.renderSingleSided = true;\\n\\n\\t\\tthis.render = function ( lights, scene, camera ) {\\n\\n\\t\\t\\tif ( scope.enabled === false ) return;\\n\\t\\t\\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\\n\\n\\t\\t\\tif ( lights.length === 0 ) return;\\n\\n\\t\\t\\t// TODO Clean up (needed in case of contextlost)\\n\\t\\t\\tvar _gl = _renderer.context;\\n\\t\\t\\tvar _state = _renderer.state;\\n\\n\\t\\t\\t// Set GL state for depth map.\\n\\t\\t\\t_state.disable( _gl.BLEND );\\n\\t\\t\\t_state.buffers.color.setClear( 1, 1, 1, 1 );\\n\\t\\t\\t_state.buffers.depth.setTest( true );\\n\\t\\t\\t_state.setScissorTest( false );\\n\\n\\t\\t\\t// render depth map\\n\\n\\t\\t\\tvar faceCount;\\n\\n\\t\\t\\tfor ( var i = 0, il = lights.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar light = lights[ i ];\\n\\t\\t\\t\\tvar shadow = light.shadow;\\n\\t\\t\\t\\tvar isPointLight = light && light.isPointLight;\\n\\n\\t\\t\\t\\tif ( shadow === undefined ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar shadowCamera = shadow.camera;\\n\\n\\t\\t\\t\\t_shadowMapSize.copy( shadow.mapSize );\\n\\t\\t\\t\\t_shadowMapSize.min( _maxShadowMapSize );\\n\\n\\t\\t\\t\\tif ( isPointLight ) {\\n\\n\\t\\t\\t\\t\\tvar vpWidth = _shadowMapSize.x;\\n\\t\\t\\t\\t\\tvar vpHeight = _shadowMapSize.y;\\n\\n\\t\\t\\t\\t\\t// These viewports map a cube-map onto a 2D texture with the\\n\\t\\t\\t\\t\\t// following orientation:\\n\\t\\t\\t\\t\\t//\\n\\t\\t\\t\\t\\t//  xzXZ\\n\\t\\t\\t\\t\\t//   y Y\\n\\t\\t\\t\\t\\t//\\n\\t\\t\\t\\t\\t// X - Positive x direction\\n\\t\\t\\t\\t\\t// x - Negative x direction\\n\\t\\t\\t\\t\\t// Y - Positive y direction\\n\\t\\t\\t\\t\\t// y - Negative y direction\\n\\t\\t\\t\\t\\t// Z - Positive z direction\\n\\t\\t\\t\\t\\t// z - Negative z direction\\n\\n\\t\\t\\t\\t\\t// positive X\\n\\t\\t\\t\\t\\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\\n\\t\\t\\t\\t\\t// negative X\\n\\t\\t\\t\\t\\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\\n\\t\\t\\t\\t\\t// positive Z\\n\\t\\t\\t\\t\\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\\n\\t\\t\\t\\t\\t// negative Z\\n\\t\\t\\t\\t\\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\\n\\t\\t\\t\\t\\t// positive Y\\n\\t\\t\\t\\t\\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\\n\\t\\t\\t\\t\\t// negative Y\\n\\t\\t\\t\\t\\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\\n\\n\\t\\t\\t\\t\\t_shadowMapSize.x *= 4.0;\\n\\t\\t\\t\\t\\t_shadowMapSize.y *= 2.0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( shadow.map === null ) {\\n\\n\\t\\t\\t\\t\\tvar pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };\\n\\n\\t\\t\\t\\t\\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\\n\\t\\t\\t\\t\\tshadow.map.texture.name = light.name + \\\".shadowMap\\\";\\n\\n\\t\\t\\t\\t\\tshadowCamera.updateProjectionMatrix();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( shadow.isSpotLightShadow ) {\\n\\n\\t\\t\\t\\t\\tshadow.update( light );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar shadowMap = shadow.map;\\n\\t\\t\\t\\tvar shadowMatrix = shadow.matrix;\\n\\n\\t\\t\\t\\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\\n\\t\\t\\t\\tshadowCamera.position.copy( _lightPositionWorld );\\n\\n\\t\\t\\t\\tif ( isPointLight ) {\\n\\n\\t\\t\\t\\t\\tfaceCount = 6;\\n\\n\\t\\t\\t\\t\\t// for point lights we set the shadow matrix to be a translation-only matrix\\n\\t\\t\\t\\t\\t// equal to inverse of the light's position\\n\\n\\t\\t\\t\\t\\tshadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tfaceCount = 1;\\n\\n\\t\\t\\t\\t\\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\\n\\t\\t\\t\\t\\tshadowCamera.lookAt( _lookTarget );\\n\\t\\t\\t\\t\\tshadowCamera.updateMatrixWorld();\\n\\n\\t\\t\\t\\t\\t// compute shadow matrix\\n\\n\\t\\t\\t\\t\\tshadowMatrix.set(\\n\\t\\t\\t\\t\\t\\t0.5, 0.0, 0.0, 0.5,\\n\\t\\t\\t\\t\\t\\t0.0, 0.5, 0.0, 0.5,\\n\\t\\t\\t\\t\\t\\t0.0, 0.0, 0.5, 0.5,\\n\\t\\t\\t\\t\\t\\t0.0, 0.0, 0.0, 1.0\\n\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\\n\\t\\t\\t\\t\\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t_renderer.setRenderTarget( shadowMap );\\n\\t\\t\\t\\t_renderer.clear();\\n\\n\\t\\t\\t\\t// render shadow map for each cube face (if omni-directional) or\\n\\t\\t\\t\\t// run a single pass if not\\n\\n\\t\\t\\t\\tfor ( var face = 0; face < faceCount; face ++ ) {\\n\\n\\t\\t\\t\\t\\tif ( isPointLight ) {\\n\\n\\t\\t\\t\\t\\t\\t_lookTarget.copy( shadowCamera.position );\\n\\t\\t\\t\\t\\t\\t_lookTarget.add( cubeDirections[ face ] );\\n\\t\\t\\t\\t\\t\\tshadowCamera.up.copy( cubeUps[ face ] );\\n\\t\\t\\t\\t\\t\\tshadowCamera.lookAt( _lookTarget );\\n\\t\\t\\t\\t\\t\\tshadowCamera.updateMatrixWorld();\\n\\n\\t\\t\\t\\t\\t\\tvar vpDimensions = cube2DViewPorts[ face ];\\n\\t\\t\\t\\t\\t\\t_state.viewport( vpDimensions );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// update camera matrices and frustum\\n\\n\\t\\t\\t\\t\\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\\n\\t\\t\\t\\t\\t_frustum.setFromMatrix( _projScreenMatrix );\\n\\n\\t\\t\\t\\t\\t// set object matrices & frustum culling\\n\\n\\t\\t\\t\\t\\trenderObject( scene, camera, shadowCamera, isPointLight );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tscope.needsUpdate = false;\\n\\n\\t\\t};\\n\\n\\t\\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar ) {\\n\\n\\t\\t\\tvar geometry = object.geometry;\\n\\n\\t\\t\\tvar result = null;\\n\\n\\t\\t\\tvar materialVariants = _depthMaterials;\\n\\t\\t\\tvar customMaterial = object.customDepthMaterial;\\n\\n\\t\\t\\tif ( isPointLight ) {\\n\\n\\t\\t\\t\\tmaterialVariants = _distanceMaterials;\\n\\t\\t\\t\\tcustomMaterial = object.customDistanceMaterial;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( ! customMaterial ) {\\n\\n\\t\\t\\t\\tvar useMorphing = false;\\n\\n\\t\\t\\t\\tif ( material.morphTargets ) {\\n\\n\\t\\t\\t\\t\\tif ( geometry && geometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\t\\t\\tuseMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\\n\\n\\t\\t\\t\\t\\t} else if ( geometry && geometry.isGeometry ) {\\n\\n\\t\\t\\t\\t\\t\\tuseMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( object.isSkinnedMesh && material.skinning === false ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar useSkinning = object.isSkinnedMesh && material.skinning;\\n\\n\\t\\t\\t\\tvar variantIndex = 0;\\n\\n\\t\\t\\t\\tif ( useMorphing ) variantIndex |= _MorphingFlag;\\n\\t\\t\\t\\tif ( useSkinning ) variantIndex |= _SkinningFlag;\\n\\n\\t\\t\\t\\tresult = materialVariants[ variantIndex ];\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tresult = customMaterial;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( _renderer.localClippingEnabled &&\\n\\t\\t\\t\\t\\tmaterial.clipShadows === true &&\\n\\t\\t\\t\\t\\tmaterial.clippingPlanes.length !== 0 ) {\\n\\n\\t\\t\\t\\t// in this case we need a unique material instance reflecting the\\n\\t\\t\\t\\t// appropriate state\\n\\n\\t\\t\\t\\tvar keyA = result.uuid, keyB = material.uuid;\\n\\n\\t\\t\\t\\tvar materialsForVariant = _materialCache[ keyA ];\\n\\n\\t\\t\\t\\tif ( materialsForVariant === undefined ) {\\n\\n\\t\\t\\t\\t\\tmaterialsForVariant = {};\\n\\t\\t\\t\\t\\t_materialCache[ keyA ] = materialsForVariant;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar cachedMaterial = materialsForVariant[ keyB ];\\n\\n\\t\\t\\t\\tif ( cachedMaterial === undefined ) {\\n\\n\\t\\t\\t\\t\\tcachedMaterial = result.clone();\\n\\t\\t\\t\\t\\tmaterialsForVariant[ keyB ] = cachedMaterial;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tresult = cachedMaterial;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tresult.visible = material.visible;\\n\\t\\t\\tresult.wireframe = material.wireframe;\\n\\n\\t\\t\\tvar side = material.side;\\n\\n\\t\\t\\tif ( scope.renderSingleSided && side == DoubleSide ) {\\n\\n\\t\\t\\t\\tside = FrontSide;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( scope.renderReverseSided ) {\\n\\n\\t\\t\\t\\tif ( side === FrontSide ) side = BackSide;\\n\\t\\t\\t\\telse if ( side === BackSide ) side = FrontSide;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tresult.side = side;\\n\\n\\t\\t\\tresult.clipShadows = material.clipShadows;\\n\\t\\t\\tresult.clippingPlanes = material.clippingPlanes;\\n\\t\\t\\tresult.clipIntersection = material.clipIntersection;\\n\\n\\t\\t\\tresult.wireframeLinewidth = material.wireframeLinewidth;\\n\\t\\t\\tresult.linewidth = material.linewidth;\\n\\n\\t\\t\\tif ( isPointLight && result.isMeshDistanceMaterial ) {\\n\\n\\t\\t\\t\\tresult.referencePosition.copy( lightPositionWorld );\\n\\t\\t\\t\\tresult.nearDistance = shadowCameraNear;\\n\\t\\t\\t\\tresult.farDistance = shadowCameraFar;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\n\\t\\t}\\n\\n\\t\\tfunction renderObject( object, camera, shadowCamera, isPointLight ) {\\n\\n\\t\\t\\tif ( object.visible === false ) return;\\n\\n\\t\\t\\tvar visible = object.layers.test( camera.layers );\\n\\n\\t\\t\\tif ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {\\n\\n\\t\\t\\t\\tif ( object.castShadow && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {\\n\\n\\t\\t\\t\\t\\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\\n\\n\\t\\t\\t\\t\\tvar geometry = _objects.update( object );\\n\\t\\t\\t\\t\\tvar material = object.material;\\n\\n\\t\\t\\t\\t\\tif ( Array.isArray( material ) ) {\\n\\n\\t\\t\\t\\t\\t\\tvar groups = geometry.groups;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar group = groups[ k ];\\n\\t\\t\\t\\t\\t\\t\\tvar groupMaterial = material[ group.materialIndex ];\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( groupMaterial && groupMaterial.visible ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );\\n\\t\\t\\t\\t\\t\\t\\t\\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else if ( material.visible ) {\\n\\n\\t\\t\\t\\t\\t\\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );\\n\\t\\t\\t\\t\\t\\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar children = object.children;\\n\\n\\t\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\trenderObject( children[ i ], camera, shadowCamera, isPointLight );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLAttributes( gl ) {\\n\\n\\t\\tvar buffers = {};\\n\\n\\t\\tfunction createBuffer( attribute, bufferType ) {\\n\\n\\t\\t\\tvar array = attribute.array;\\n\\t\\t\\tvar usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\\n\\n\\t\\t\\tvar buffer = gl.createBuffer();\\n\\n\\t\\t\\tgl.bindBuffer( bufferType, buffer );\\n\\t\\t\\tgl.bufferData( bufferType, array, usage );\\n\\n\\t\\t\\tattribute.onUploadCallback();\\n\\n\\t\\t\\tvar type = gl.FLOAT;\\n\\n\\t\\t\\tif ( array instanceof Float32Array ) {\\n\\n\\t\\t\\t\\ttype = gl.FLOAT;\\n\\n\\t\\t\\t} else if ( array instanceof Float64Array ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );\\n\\n\\t\\t\\t} else if ( array instanceof Uint16Array ) {\\n\\n\\t\\t\\t\\ttype = gl.UNSIGNED_SHORT;\\n\\n\\t\\t\\t} else if ( array instanceof Int16Array ) {\\n\\n\\t\\t\\t\\ttype = gl.SHORT;\\n\\n\\t\\t\\t} else if ( array instanceof Uint32Array ) {\\n\\n\\t\\t\\t\\ttype = gl.UNSIGNED_INT;\\n\\n\\t\\t\\t} else if ( array instanceof Int32Array ) {\\n\\n\\t\\t\\t\\ttype = gl.INT;\\n\\n\\t\\t\\t} else if ( array instanceof Int8Array ) {\\n\\n\\t\\t\\t\\ttype = gl.BYTE;\\n\\n\\t\\t\\t} else if ( array instanceof Uint8Array ) {\\n\\n\\t\\t\\t\\ttype = gl.UNSIGNED_BYTE;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tbuffer: buffer,\\n\\t\\t\\t\\ttype: type,\\n\\t\\t\\t\\tbytesPerElement: array.BYTES_PER_ELEMENT,\\n\\t\\t\\t\\tversion: attribute.version\\n\\t\\t\\t};\\n\\n\\t\\t}\\n\\n\\t\\tfunction updateBuffer( buffer, attribute, bufferType ) {\\n\\n\\t\\t\\tvar array = attribute.array;\\n\\t\\t\\tvar updateRange = attribute.updateRange;\\n\\n\\t\\t\\tgl.bindBuffer( bufferType, buffer );\\n\\n\\t\\t\\tif ( attribute.dynamic === false ) {\\n\\n\\t\\t\\t\\tgl.bufferData( bufferType, array, gl.STATIC_DRAW );\\n\\n\\t\\t\\t} else if ( updateRange.count === - 1 ) {\\n\\n\\t\\t\\t\\t// Not using update ranges\\n\\n\\t\\t\\t\\tgl.bufferSubData( bufferType, 0, array );\\n\\n\\t\\t\\t} else if ( updateRange.count === 0 ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tgl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,\\n\\t\\t\\t\\t\\tarray.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );\\n\\n\\t\\t\\t\\tupdateRange.count = - 1; // reset range\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tfunction get( attribute ) {\\n\\n\\t\\t\\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\\n\\n\\t\\t\\treturn buffers[ attribute.uuid ];\\n\\n\\t\\t}\\n\\n\\t\\tfunction remove( attribute ) {\\n\\n\\t\\t\\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\\n\\n\\t\\t\\tvar data = buffers[ attribute.uuid ];\\n\\n\\t\\t\\tif ( data ) {\\n\\n\\t\\t\\t\\tgl.deleteBuffer( data.buffer );\\n\\n\\t\\t\\t\\tdelete buffers[ attribute.uuid ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction update( attribute, bufferType ) {\\n\\n\\t\\t\\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\\n\\n\\t\\t\\tvar data = buffers[ attribute.uuid ];\\n\\n\\t\\t\\tif ( data === undefined ) {\\n\\n\\t\\t\\t\\tbuffers[ attribute.uuid ] = createBuffer( attribute, bufferType );\\n\\n\\t\\t\\t} else if ( data.version < attribute.version ) {\\n\\n\\t\\t\\t\\tupdateBuffer( data.buffer, attribute, bufferType );\\n\\n\\t\\t\\t\\tdata.version = attribute.version;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tget: get,\\n\\t\\t\\tremove: remove,\\n\\t\\t\\tupdate: update\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t * @author bhouston / http://clara.io\\n\\t */\\n\\n\\tfunction Euler( x, y, z, order ) {\\n\\n\\t\\tthis._x = x || 0;\\n\\t\\tthis._y = y || 0;\\n\\t\\tthis._z = z || 0;\\n\\t\\tthis._order = order || Euler.DefaultOrder;\\n\\n\\t}\\n\\n\\tEuler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\\n\\n\\tEuler.DefaultOrder = 'XYZ';\\n\\n\\tObject.defineProperties( Euler.prototype, {\\n\\n\\t\\tx: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this._x;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis._x = value;\\n\\t\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\ty: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this._y;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis._y = value;\\n\\t\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tz: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this._z;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis._z = value;\\n\\t\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\torder: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this._order;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis._order = value;\\n\\t\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( Euler.prototype, {\\n\\n\\t\\tisEuler: true,\\n\\n\\t\\tset: function ( x, y, z, order ) {\\n\\n\\t\\t\\tthis._x = x;\\n\\t\\t\\tthis._y = y;\\n\\t\\t\\tthis._z = z;\\n\\t\\t\\tthis._order = order || this._order;\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this._x, this._y, this._z, this._order );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( euler ) {\\n\\n\\t\\t\\tthis._x = euler._x;\\n\\t\\t\\tthis._y = euler._y;\\n\\t\\t\\tthis._z = euler._z;\\n\\t\\t\\tthis._order = euler._order;\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromRotationMatrix: function ( m, order, update ) {\\n\\n\\t\\t\\tvar clamp = _Math.clamp;\\n\\n\\t\\t\\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\\n\\n\\t\\t\\tvar te = m.elements;\\n\\t\\t\\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\\n\\t\\t\\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\\n\\t\\t\\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\\n\\n\\t\\t\\torder = order || this._order;\\n\\n\\t\\t\\tif ( order === 'XYZ' ) {\\n\\n\\t\\t\\t\\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\\n\\n\\t\\t\\t\\tif ( Math.abs( m13 ) < 0.99999 ) {\\n\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( - m23, m33 );\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( - m12, m11 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( m32, m22 );\\n\\t\\t\\t\\t\\tthis._z = 0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( order === 'YXZ' ) {\\n\\n\\t\\t\\t\\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\\n\\n\\t\\t\\t\\tif ( Math.abs( m23 ) < 0.99999 ) {\\n\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( m13, m33 );\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( m21, m22 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( - m31, m11 );\\n\\t\\t\\t\\t\\tthis._z = 0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( order === 'ZXY' ) {\\n\\n\\t\\t\\t\\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\\n\\n\\t\\t\\t\\tif ( Math.abs( m32 ) < 0.99999 ) {\\n\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( - m31, m33 );\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( - m12, m22 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthis._y = 0;\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( m21, m11 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( order === 'ZYX' ) {\\n\\n\\t\\t\\t\\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\\n\\n\\t\\t\\t\\tif ( Math.abs( m31 ) < 0.99999 ) {\\n\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( m32, m33 );\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( m21, m11 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthis._x = 0;\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( - m12, m22 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( order === 'YZX' ) {\\n\\n\\t\\t\\t\\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\\n\\n\\t\\t\\t\\tif ( Math.abs( m21 ) < 0.99999 ) {\\n\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( - m23, m22 );\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( - m31, m11 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthis._x = 0;\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( m13, m33 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( order === 'XZY' ) {\\n\\n\\t\\t\\t\\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\\n\\n\\t\\t\\t\\tif ( Math.abs( m12 ) < 0.99999 ) {\\n\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( m32, m22 );\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( m13, m11 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( - m23, m33 );\\n\\t\\t\\t\\t\\tthis._y = 0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._order = order;\\n\\n\\t\\t\\tif ( update !== false ) this.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromQuaternion: function () {\\n\\n\\t\\t\\tvar matrix = new Matrix4();\\n\\n\\t\\t\\treturn function setFromQuaternion( q, order, update ) {\\n\\n\\t\\t\\t\\tmatrix.makeRotationFromQuaternion( q );\\n\\n\\t\\t\\t\\treturn this.setFromRotationMatrix( matrix, order, update );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tsetFromVector3: function ( v, order ) {\\n\\n\\t\\t\\treturn this.set( v.x, v.y, v.z, order || this._order );\\n\\n\\t\\t},\\n\\n\\t\\treorder: function () {\\n\\n\\t\\t\\t// WARNING: this discards revolution information -bhouston\\n\\n\\t\\t\\tvar q = new Quaternion();\\n\\n\\t\\t\\treturn function reorder( newOrder ) {\\n\\n\\t\\t\\t\\tq.setFromEuler( this );\\n\\n\\t\\t\\t\\treturn this.setFromQuaternion( q, newOrder );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tequals: function ( euler ) {\\n\\n\\t\\t\\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\\n\\n\\t\\t},\\n\\n\\t\\tfromArray: function ( array ) {\\n\\n\\t\\t\\tthis._x = array[ 0 ];\\n\\t\\t\\tthis._y = array[ 1 ];\\n\\t\\t\\tthis._z = array[ 2 ];\\n\\t\\t\\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( array === undefined ) array = [];\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tarray[ offset ] = this._x;\\n\\t\\t\\tarray[ offset + 1 ] = this._y;\\n\\t\\t\\tarray[ offset + 2 ] = this._z;\\n\\t\\t\\tarray[ offset + 3 ] = this._order;\\n\\n\\t\\t\\treturn array;\\n\\n\\t\\t},\\n\\n\\t\\ttoVector3: function ( optionalResult ) {\\n\\n\\t\\t\\tif ( optionalResult ) {\\n\\n\\t\\t\\t\\treturn optionalResult.set( this._x, this._y, this._z );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\treturn new Vector3( this._x, this._y, this._z );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tonChange: function ( callback ) {\\n\\n\\t\\t\\tthis.onChangeCallback = callback;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tonChangeCallback: function () {}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction Layers() {\\n\\n\\t\\tthis.mask = 1 | 0;\\n\\n\\t}\\n\\n\\tObject.assign( Layers.prototype, {\\n\\n\\t\\tset: function ( channel ) {\\n\\n\\t\\t\\tthis.mask = 1 << channel | 0;\\n\\n\\t\\t},\\n\\n\\t\\tenable: function ( channel ) {\\n\\n\\t\\t\\tthis.mask |= 1 << channel | 0;\\n\\n\\t\\t},\\n\\n\\t\\ttoggle: function ( channel ) {\\n\\n\\t\\t\\tthis.mask ^= 1 << channel | 0;\\n\\n\\t\\t},\\n\\n\\t\\tdisable: function ( channel ) {\\n\\n\\t\\t\\tthis.mask &= ~ ( 1 << channel | 0 );\\n\\n\\t\\t},\\n\\n\\t\\ttest: function ( layers ) {\\n\\n\\t\\t\\treturn ( this.mask & layers.mask ) !== 0;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t * @author elephantatwork / www.elephantatwork.ch\\n\\t */\\n\\n\\tvar object3DId = 0;\\n\\n\\tfunction Object3D() {\\n\\n\\t\\tObject.defineProperty( this, 'id', { value: object3DId ++ } );\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\tthis.name = '';\\n\\t\\tthis.type = 'Object3D';\\n\\n\\t\\tthis.parent = null;\\n\\t\\tthis.children = [];\\n\\n\\t\\tthis.up = Object3D.DefaultUp.clone();\\n\\n\\t\\tvar position = new Vector3();\\n\\t\\tvar rotation = new Euler();\\n\\t\\tvar quaternion = new Quaternion();\\n\\t\\tvar scale = new Vector3( 1, 1, 1 );\\n\\n\\t\\tfunction onRotationChange() {\\n\\n\\t\\t\\tquaternion.setFromEuler( rotation, false );\\n\\n\\t\\t}\\n\\n\\t\\tfunction onQuaternionChange() {\\n\\n\\t\\t\\trotation.setFromQuaternion( quaternion, undefined, false );\\n\\n\\t\\t}\\n\\n\\t\\trotation.onChange( onRotationChange );\\n\\t\\tquaternion.onChange( onQuaternionChange );\\n\\n\\t\\tObject.defineProperties( this, {\\n\\t\\t\\tposition: {\\n\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t\\tvalue: position\\n\\t\\t\\t},\\n\\t\\t\\trotation: {\\n\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t\\tvalue: rotation\\n\\t\\t\\t},\\n\\t\\t\\tquaternion: {\\n\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t\\tvalue: quaternion\\n\\t\\t\\t},\\n\\t\\t\\tscale: {\\n\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t\\tvalue: scale\\n\\t\\t\\t},\\n\\t\\t\\tmodelViewMatrix: {\\n\\t\\t\\t\\tvalue: new Matrix4()\\n\\t\\t\\t},\\n\\t\\t\\tnormalMatrix: {\\n\\t\\t\\t\\tvalue: new Matrix3()\\n\\t\\t\\t}\\n\\t\\t} );\\n\\n\\t\\tthis.matrix = new Matrix4();\\n\\t\\tthis.matrixWorld = new Matrix4();\\n\\n\\t\\tthis.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\\n\\t\\tthis.matrixWorldNeedsUpdate = false;\\n\\n\\t\\tthis.layers = new Layers();\\n\\t\\tthis.visible = true;\\n\\n\\t\\tthis.castShadow = false;\\n\\t\\tthis.receiveShadow = false;\\n\\n\\t\\tthis.frustumCulled = true;\\n\\t\\tthis.renderOrder = 0;\\n\\n\\t\\tthis.userData = {};\\n\\n\\t}\\n\\n\\tObject3D.DefaultUp = new Vector3( 0, 1, 0 );\\n\\tObject3D.DefaultMatrixAutoUpdate = true;\\n\\n\\tObject3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\n\\n\\t\\tconstructor: Object3D,\\n\\n\\t\\tisObject3D: true,\\n\\n\\t\\tonBeforeRender: function () {},\\n\\t\\tonAfterRender: function () {},\\n\\n\\t\\tapplyMatrix: function ( matrix ) {\\n\\n\\t\\t\\tthis.matrix.multiplyMatrices( matrix, this.matrix );\\n\\n\\t\\t\\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\\n\\n\\t\\t},\\n\\n\\t\\tapplyQuaternion: function ( q ) {\\n\\n\\t\\t\\tthis.quaternion.premultiply( q );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetRotationFromAxisAngle: function ( axis, angle ) {\\n\\n\\t\\t\\t// assumes axis is normalized\\n\\n\\t\\t\\tthis.quaternion.setFromAxisAngle( axis, angle );\\n\\n\\t\\t},\\n\\n\\t\\tsetRotationFromEuler: function ( euler ) {\\n\\n\\t\\t\\tthis.quaternion.setFromEuler( euler, true );\\n\\n\\t\\t},\\n\\n\\t\\tsetRotationFromMatrix: function ( m ) {\\n\\n\\t\\t\\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\\n\\n\\t\\t\\tthis.quaternion.setFromRotationMatrix( m );\\n\\n\\t\\t},\\n\\n\\t\\tsetRotationFromQuaternion: function ( q ) {\\n\\n\\t\\t\\t// assumes q is normalized\\n\\n\\t\\t\\tthis.quaternion.copy( q );\\n\\n\\t\\t},\\n\\n\\t\\trotateOnAxis: function () {\\n\\n\\t\\t\\t// rotate object on axis in object space\\n\\t\\t\\t// axis is assumed to be normalized\\n\\n\\t\\t\\tvar q1 = new Quaternion();\\n\\n\\t\\t\\treturn function rotateOnAxis( axis, angle ) {\\n\\n\\t\\t\\t\\tq1.setFromAxisAngle( axis, angle );\\n\\n\\t\\t\\t\\tthis.quaternion.multiply( q1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\trotateOnWorldAxis: function () {\\n\\n\\t\\t\\t// rotate object on axis in world space\\n\\t\\t\\t// axis is assumed to be normalized\\n\\t\\t\\t// method assumes no rotated parent\\n\\n\\t\\t\\tvar q1 = new Quaternion();\\n\\n\\t\\t\\treturn function rotateOnWorldAxis( axis, angle ) {\\n\\n\\t\\t\\t\\tq1.setFromAxisAngle( axis, angle );\\n\\n\\t\\t\\t\\tthis.quaternion.premultiply( q1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\trotateX: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3( 1, 0, 0 );\\n\\n\\t\\t\\treturn function rotateX( angle ) {\\n\\n\\t\\t\\t\\treturn this.rotateOnAxis( v1, angle );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\trotateY: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3( 0, 1, 0 );\\n\\n\\t\\t\\treturn function rotateY( angle ) {\\n\\n\\t\\t\\t\\treturn this.rotateOnAxis( v1, angle );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\trotateZ: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3( 0, 0, 1 );\\n\\n\\t\\t\\treturn function rotateZ( angle ) {\\n\\n\\t\\t\\t\\treturn this.rotateOnAxis( v1, angle );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttranslateOnAxis: function () {\\n\\n\\t\\t\\t// translate object by distance along axis in object space\\n\\t\\t\\t// axis is assumed to be normalized\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function translateOnAxis( axis, distance ) {\\n\\n\\t\\t\\t\\tv1.copy( axis ).applyQuaternion( this.quaternion );\\n\\n\\t\\t\\t\\tthis.position.add( v1.multiplyScalar( distance ) );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttranslateX: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3( 1, 0, 0 );\\n\\n\\t\\t\\treturn function translateX( distance ) {\\n\\n\\t\\t\\t\\treturn this.translateOnAxis( v1, distance );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttranslateY: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3( 0, 1, 0 );\\n\\n\\t\\t\\treturn function translateY( distance ) {\\n\\n\\t\\t\\t\\treturn this.translateOnAxis( v1, distance );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttranslateZ: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3( 0, 0, 1 );\\n\\n\\t\\t\\treturn function translateZ( distance ) {\\n\\n\\t\\t\\t\\treturn this.translateOnAxis( v1, distance );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tlocalToWorld: function ( vector ) {\\n\\n\\t\\t\\treturn vector.applyMatrix4( this.matrixWorld );\\n\\n\\t\\t},\\n\\n\\t\\tworldToLocal: function () {\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function worldToLocal( vector ) {\\n\\n\\t\\t\\t\\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tlookAt: function () {\\n\\n\\t\\t\\t// This method does not support objects with rotated and/or translated parent(s)\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\t\\t\\tvar vector = new Vector3();\\n\\n\\t\\t\\treturn function lookAt( x, y, z ) {\\n\\n\\t\\t\\t\\tif ( x.isVector3 ) {\\n\\n\\t\\t\\t\\t\\tvector.copy( x );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tvector.set( x, y, z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( this.isCamera ) {\\n\\n\\t\\t\\t\\t\\tm1.lookAt( this.position, vector, this.up );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tm1.lookAt( vector, this.position, this.up );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.quaternion.setFromRotationMatrix( m1 );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tadd: function ( object ) {\\n\\n\\t\\t\\tif ( arguments.length > 1 ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < arguments.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tthis.add( arguments[ i ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( object === this ) {\\n\\n\\t\\t\\t\\tconsole.error( \\\"THREE.Object3D.add: object can't be added as a child of itself.\\\", object );\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( ( object && object.isObject3D ) ) {\\n\\n\\t\\t\\t\\tif ( object.parent !== null ) {\\n\\n\\t\\t\\t\\t\\tobject.parent.remove( object );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tobject.parent = this;\\n\\t\\t\\t\\tobject.dispatchEvent( { type: 'added' } );\\n\\n\\t\\t\\t\\tthis.children.push( object );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tconsole.error( \\\"THREE.Object3D.add: object not an instance of THREE.Object3D.\\\", object );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tremove: function ( object ) {\\n\\n\\t\\t\\tif ( arguments.length > 1 ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < arguments.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tthis.remove( arguments[ i ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar index = this.children.indexOf( object );\\n\\n\\t\\t\\tif ( index !== - 1 ) {\\n\\n\\t\\t\\t\\tobject.parent = null;\\n\\n\\t\\t\\t\\tobject.dispatchEvent( { type: 'removed' } );\\n\\n\\t\\t\\t\\tthis.children.splice( index, 1 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetObjectById: function ( id ) {\\n\\n\\t\\t\\treturn this.getObjectByProperty( 'id', id );\\n\\n\\t\\t},\\n\\n\\t\\tgetObjectByName: function ( name ) {\\n\\n\\t\\t\\treturn this.getObjectByProperty( 'name', name );\\n\\n\\t\\t},\\n\\n\\t\\tgetObjectByProperty: function ( name, value ) {\\n\\n\\t\\t\\tif ( this[ name ] === value ) return this;\\n\\n\\t\\t\\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar child = this.children[ i ];\\n\\t\\t\\t\\tvar object = child.getObjectByProperty( name, value );\\n\\n\\t\\t\\t\\tif ( object !== undefined ) {\\n\\n\\t\\t\\t\\t\\treturn object;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn undefined;\\n\\n\\t\\t},\\n\\n\\t\\tgetWorldPosition: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\tthis.updateMatrixWorld( true );\\n\\n\\t\\t\\treturn result.setFromMatrixPosition( this.matrixWorld );\\n\\n\\t\\t},\\n\\n\\t\\tgetWorldQuaternion: function () {\\n\\n\\t\\t\\tvar position = new Vector3();\\n\\t\\t\\tvar scale = new Vector3();\\n\\n\\t\\t\\treturn function getWorldQuaternion( optionalTarget ) {\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Quaternion();\\n\\n\\t\\t\\t\\tthis.updateMatrixWorld( true );\\n\\n\\t\\t\\t\\tthis.matrixWorld.decompose( position, result, scale );\\n\\n\\t\\t\\t\\treturn result;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tgetWorldRotation: function () {\\n\\n\\t\\t\\tvar quaternion = new Quaternion();\\n\\n\\t\\t\\treturn function getWorldRotation( optionalTarget ) {\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Euler();\\n\\n\\t\\t\\t\\tthis.getWorldQuaternion( quaternion );\\n\\n\\t\\t\\t\\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tgetWorldScale: function () {\\n\\n\\t\\t\\tvar position = new Vector3();\\n\\t\\t\\tvar quaternion = new Quaternion();\\n\\n\\t\\t\\treturn function getWorldScale( optionalTarget ) {\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\t\\tthis.updateMatrixWorld( true );\\n\\n\\t\\t\\t\\tthis.matrixWorld.decompose( position, quaternion, result );\\n\\n\\t\\t\\t\\treturn result;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tgetWorldDirection: function () {\\n\\n\\t\\t\\tvar quaternion = new Quaternion();\\n\\n\\t\\t\\treturn function getWorldDirection( optionalTarget ) {\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\t\\tthis.getWorldQuaternion( quaternion );\\n\\n\\t\\t\\t\\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\traycast: function () {},\\n\\n\\t\\ttraverse: function ( callback ) {\\n\\n\\t\\t\\tcallback( this );\\n\\n\\t\\t\\tvar children = this.children;\\n\\n\\t\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tchildren[ i ].traverse( callback );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\ttraverseVisible: function ( callback ) {\\n\\n\\t\\t\\tif ( this.visible === false ) return;\\n\\n\\t\\t\\tcallback( this );\\n\\n\\t\\t\\tvar children = this.children;\\n\\n\\t\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tchildren[ i ].traverseVisible( callback );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\ttraverseAncestors: function ( callback ) {\\n\\n\\t\\t\\tvar parent = this.parent;\\n\\n\\t\\t\\tif ( parent !== null ) {\\n\\n\\t\\t\\t\\tcallback( parent );\\n\\n\\t\\t\\t\\tparent.traverseAncestors( callback );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tupdateMatrix: function () {\\n\\n\\t\\t\\tthis.matrix.compose( this.position, this.quaternion, this.scale );\\n\\n\\t\\t\\tthis.matrixWorldNeedsUpdate = true;\\n\\n\\t\\t},\\n\\n\\t\\tupdateMatrixWorld: function ( force ) {\\n\\n\\t\\t\\tif ( this.matrixAutoUpdate ) this.updateMatrix();\\n\\n\\t\\t\\tif ( this.matrixWorldNeedsUpdate || force ) {\\n\\n\\t\\t\\t\\tif ( this.parent === null ) {\\n\\n\\t\\t\\t\\t\\tthis.matrixWorld.copy( this.matrix );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.matrixWorldNeedsUpdate = false;\\n\\n\\t\\t\\t\\tforce = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// update children\\n\\n\\t\\t\\tvar children = this.children;\\n\\n\\t\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tchildren[ i ].updateMatrixWorld( force );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( meta ) {\\n\\n\\t\\t\\t// meta is a string when called from JSON.stringify\\n\\t\\t\\tvar isRootObject = ( meta === undefined || typeof meta === 'string' );\\n\\n\\t\\t\\tvar output = {};\\n\\n\\t\\t\\t// meta is a hash used to collect geometries, materials.\\n\\t\\t\\t// not providing it implies that this is the root object\\n\\t\\t\\t// being serialized.\\n\\t\\t\\tif ( isRootObject ) {\\n\\n\\t\\t\\t\\t// initialize meta obj\\n\\t\\t\\t\\tmeta = {\\n\\t\\t\\t\\t\\tgeometries: {},\\n\\t\\t\\t\\t\\tmaterials: {},\\n\\t\\t\\t\\t\\ttextures: {},\\n\\t\\t\\t\\t\\timages: {},\\n\\t\\t\\t\\t\\tshapes: {}\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\toutput.metadata = {\\n\\t\\t\\t\\t\\tversion: 4.5,\\n\\t\\t\\t\\t\\ttype: 'Object',\\n\\t\\t\\t\\t\\tgenerator: 'Object3D.toJSON'\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// standard Object3D serialization\\n\\n\\t\\t\\tvar object = {};\\n\\n\\t\\t\\tobject.uuid = this.uuid;\\n\\t\\t\\tobject.type = this.type;\\n\\n\\t\\t\\tif ( this.name !== '' ) object.name = this.name;\\n\\t\\t\\tif ( this.castShadow === true ) object.castShadow = true;\\n\\t\\t\\tif ( this.receiveShadow === true ) object.receiveShadow = true;\\n\\t\\t\\tif ( this.visible === false ) object.visible = false;\\n\\t\\t\\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\\n\\n\\t\\t\\tobject.matrix = this.matrix.toArray();\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tfunction serialize( library, element ) {\\n\\n\\t\\t\\t\\tif ( library[ element.uuid ] === undefined ) {\\n\\n\\t\\t\\t\\t\\tlibrary[ element.uuid ] = element.toJSON( meta );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn element.uuid;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.geometry !== undefined ) {\\n\\n\\t\\t\\t\\tobject.geometry = serialize( meta.geometries, this.geometry );\\n\\n\\t\\t\\t\\tvar parameters = this.geometry.parameters;\\n\\n\\t\\t\\t\\tif ( parameters !== undefined && parameters.shapes !== undefined ) {\\n\\n\\t\\t\\t\\t\\tvar shapes = parameters.shapes;\\n\\n\\t\\t\\t\\t\\tif ( Array.isArray( shapes ) ) {\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar shape = shapes[ i ];\\n\\n\\t\\t\\t\\t\\t\\t\\tserialize( meta.shapes, shape );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tserialize( meta.shapes, shapes );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.material !== undefined ) {\\n\\n\\t\\t\\t\\tif ( Array.isArray( this.material ) ) {\\n\\n\\t\\t\\t\\t\\tvar uuids = [];\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = this.material.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tuuids.push( serialize( meta.materials, this.material[ i ] ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tobject.material = uuids;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tobject.material = serialize( meta.materials, this.material );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tif ( this.children.length > 0 ) {\\n\\n\\t\\t\\t\\tobject.children = [];\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < this.children.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tobject.children.push( this.children[ i ].toJSON( meta ).object );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( isRootObject ) {\\n\\n\\t\\t\\t\\tvar geometries = extractFromCache( meta.geometries );\\n\\t\\t\\t\\tvar materials = extractFromCache( meta.materials );\\n\\t\\t\\t\\tvar textures = extractFromCache( meta.textures );\\n\\t\\t\\t\\tvar images = extractFromCache( meta.images );\\n\\t\\t\\t\\tvar shapes = extractFromCache( meta.shapes );\\n\\n\\t\\t\\t\\tif ( geometries.length > 0 ) output.geometries = geometries;\\n\\t\\t\\t\\tif ( materials.length > 0 ) output.materials = materials;\\n\\t\\t\\t\\tif ( textures.length > 0 ) output.textures = textures;\\n\\t\\t\\t\\tif ( images.length > 0 ) output.images = images;\\n\\t\\t\\t\\tif ( shapes.length > 0 ) output.shapes = shapes;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\toutput.object = object;\\n\\n\\t\\t\\treturn output;\\n\\n\\t\\t\\t// extract data from the cache hash\\n\\t\\t\\t// remove metadata on each item\\n\\t\\t\\t// and return as array\\n\\t\\t\\tfunction extractFromCache( cache ) {\\n\\n\\t\\t\\t\\tvar values = [];\\n\\t\\t\\t\\tfor ( var key in cache ) {\\n\\n\\t\\t\\t\\t\\tvar data = cache[ key ];\\n\\t\\t\\t\\t\\tdelete data.metadata;\\n\\t\\t\\t\\t\\tvalues.push( data );\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn values;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tclone: function ( recursive ) {\\n\\n\\t\\t\\treturn new this.constructor().copy( this, recursive );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source, recursive ) {\\n\\n\\t\\t\\tif ( recursive === undefined ) recursive = true;\\n\\n\\t\\t\\tthis.name = source.name;\\n\\n\\t\\t\\tthis.up.copy( source.up );\\n\\n\\t\\t\\tthis.position.copy( source.position );\\n\\t\\t\\tthis.quaternion.copy( source.quaternion );\\n\\t\\t\\tthis.scale.copy( source.scale );\\n\\n\\t\\t\\tthis.matrix.copy( source.matrix );\\n\\t\\t\\tthis.matrixWorld.copy( source.matrixWorld );\\n\\n\\t\\t\\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\\n\\t\\t\\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\\n\\n\\t\\t\\tthis.layers.mask = source.layers.mask;\\n\\t\\t\\tthis.visible = source.visible;\\n\\n\\t\\t\\tthis.castShadow = source.castShadow;\\n\\t\\t\\tthis.receiveShadow = source.receiveShadow;\\n\\n\\t\\t\\tthis.frustumCulled = source.frustumCulled;\\n\\t\\t\\tthis.renderOrder = source.renderOrder;\\n\\n\\t\\t\\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\\n\\n\\t\\t\\tif ( recursive === true ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < source.children.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar child = source.children[ i ];\\n\\t\\t\\t\\t\\tthis.add( child.clone() );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t*/\\n\\n\\tfunction Camera() {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Camera';\\n\\n\\t\\tthis.matrixWorldInverse = new Matrix4();\\n\\t\\tthis.projectionMatrix = new Matrix4();\\n\\n\\t}\\n\\n\\tCamera.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Camera,\\n\\n\\t\\tisCamera: true,\\n\\n\\t\\tcopy: function ( source, recursive ) {\\n\\n\\t\\t\\tObject3D.prototype.copy.call( this, source, recursive );\\n\\n\\t\\t\\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\\n\\t\\t\\tthis.projectionMatrix.copy( source.projectionMatrix );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetWorldDirection: function () {\\n\\n\\t\\t\\tvar quaternion = new Quaternion();\\n\\n\\t\\t\\treturn function getWorldDirection( optionalTarget ) {\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\t\\tthis.getWorldQuaternion( quaternion );\\n\\n\\t\\t\\t\\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tupdateMatrixWorld: function ( force ) {\\n\\n\\t\\t\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\n\\n\\t\\t\\tthis.matrixWorldInverse.getInverse( this.matrixWorld );\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author arose / http://github.com/arose\\n\\t */\\n\\n\\tfunction OrthographicCamera( left, right, top, bottom, near, far ) {\\n\\n\\t\\tCamera.call( this );\\n\\n\\t\\tthis.type = 'OrthographicCamera';\\n\\n\\t\\tthis.zoom = 1;\\n\\t\\tthis.view = null;\\n\\n\\t\\tthis.left = left;\\n\\t\\tthis.right = right;\\n\\t\\tthis.top = top;\\n\\t\\tthis.bottom = bottom;\\n\\n\\t\\tthis.near = ( near !== undefined ) ? near : 0.1;\\n\\t\\tthis.far = ( far !== undefined ) ? far : 2000;\\n\\n\\t\\tthis.updateProjectionMatrix();\\n\\n\\t}\\n\\n\\tOrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\\n\\n\\t\\tconstructor: OrthographicCamera,\\n\\n\\t\\tisOrthographicCamera: true,\\n\\n\\t\\tcopy: function ( source, recursive ) {\\n\\n\\t\\t\\tCamera.prototype.copy.call( this, source, recursive );\\n\\n\\t\\t\\tthis.left = source.left;\\n\\t\\t\\tthis.right = source.right;\\n\\t\\t\\tthis.top = source.top;\\n\\t\\t\\tthis.bottom = source.bottom;\\n\\t\\t\\tthis.near = source.near;\\n\\t\\t\\tthis.far = source.far;\\n\\n\\t\\t\\tthis.zoom = source.zoom;\\n\\t\\t\\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\\n\\n\\t\\t\\tif ( this.view === null ) {\\n\\n\\t\\t\\t\\tthis.view = {\\n\\t\\t\\t\\t\\tenabled: true,\\n\\t\\t\\t\\t\\tfullWidth: 1,\\n\\t\\t\\t\\t\\tfullHeight: 1,\\n\\t\\t\\t\\t\\toffsetX: 0,\\n\\t\\t\\t\\t\\toffsetY: 0,\\n\\t\\t\\t\\t\\twidth: 1,\\n\\t\\t\\t\\t\\theight: 1\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.view.enabled = true;\\n\\t\\t\\tthis.view.fullWidth = fullWidth;\\n\\t\\t\\tthis.view.fullHeight = fullHeight;\\n\\t\\t\\tthis.view.offsetX = x;\\n\\t\\t\\tthis.view.offsetY = y;\\n\\t\\t\\tthis.view.width = width;\\n\\t\\t\\tthis.view.height = height;\\n\\n\\t\\t\\tthis.updateProjectionMatrix();\\n\\n\\t\\t},\\n\\n\\t\\tclearViewOffset: function () {\\n\\n\\t\\t\\tif ( this.view !== null ) {\\n\\n\\t\\t\\t\\tthis.view.enabled = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.updateProjectionMatrix();\\n\\n\\t\\t},\\n\\n\\t\\tupdateProjectionMatrix: function () {\\n\\n\\t\\t\\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\\n\\t\\t\\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\\n\\t\\t\\tvar cx = ( this.right + this.left ) / 2;\\n\\t\\t\\tvar cy = ( this.top + this.bottom ) / 2;\\n\\n\\t\\t\\tvar left = cx - dx;\\n\\t\\t\\tvar right = cx + dx;\\n\\t\\t\\tvar top = cy + dy;\\n\\t\\t\\tvar bottom = cy - dy;\\n\\n\\t\\t\\tif ( this.view !== null && this.view.enabled ) {\\n\\n\\t\\t\\t\\tvar zoomW = this.zoom / ( this.view.width / this.view.fullWidth );\\n\\t\\t\\t\\tvar zoomH = this.zoom / ( this.view.height / this.view.fullHeight );\\n\\t\\t\\t\\tvar scaleW = ( this.right - this.left ) / this.view.width;\\n\\t\\t\\t\\tvar scaleH = ( this.top - this.bottom ) / this.view.height;\\n\\n\\t\\t\\t\\tleft += scaleW * ( this.view.offsetX / zoomW );\\n\\t\\t\\t\\tright = left + scaleW * ( this.view.width / zoomW );\\n\\t\\t\\t\\ttop -= scaleH * ( this.view.offsetY / zoomH );\\n\\t\\t\\t\\tbottom = top - scaleH * ( this.view.height / zoomH );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( meta ) {\\n\\n\\t\\t\\tvar data = Object3D.prototype.toJSON.call( this, meta );\\n\\n\\t\\t\\tdata.object.zoom = this.zoom;\\n\\t\\t\\tdata.object.left = this.left;\\n\\t\\t\\tdata.object.right = this.right;\\n\\t\\t\\tdata.object.top = this.top;\\n\\t\\t\\tdata.object.bottom = this.bottom;\\n\\t\\t\\tdata.object.near = this.near;\\n\\t\\t\\tdata.object.far = this.far;\\n\\n\\t\\t\\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction Face3( a, b, c, normal, color, materialIndex ) {\\n\\n\\t\\tthis.a = a;\\n\\t\\tthis.b = b;\\n\\t\\tthis.c = c;\\n\\n\\t\\tthis.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();\\n\\t\\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\\n\\n\\t\\tthis.color = ( color && color.isColor ) ? color : new Color();\\n\\t\\tthis.vertexColors = Array.isArray( color ) ? color : [];\\n\\n\\t\\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\\n\\n\\t}\\n\\n\\tObject.assign( Face3.prototype, {\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tthis.a = source.a;\\n\\t\\t\\tthis.b = source.b;\\n\\t\\t\\tthis.c = source.c;\\n\\n\\t\\t\\tthis.normal.copy( source.normal );\\n\\t\\t\\tthis.color.copy( source.color );\\n\\n\\t\\t\\tthis.materialIndex = source.materialIndex;\\n\\n\\t\\t\\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author kile / http://kile.stravaganza.org/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t * @author bhouston / http://clara.io\\n\\t */\\n\\n\\tvar geometryId = 0; // Geometry uses even numbers as Id\\n\\n\\tfunction Geometry() {\\n\\n\\t\\tObject.defineProperty( this, 'id', { value: geometryId += 2 } );\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\tthis.name = '';\\n\\t\\tthis.type = 'Geometry';\\n\\n\\t\\tthis.vertices = [];\\n\\t\\tthis.colors = [];\\n\\t\\tthis.faces = [];\\n\\t\\tthis.faceVertexUvs = [[]];\\n\\n\\t\\tthis.morphTargets = [];\\n\\t\\tthis.morphNormals = [];\\n\\n\\t\\tthis.skinWeights = [];\\n\\t\\tthis.skinIndices = [];\\n\\n\\t\\tthis.lineDistances = [];\\n\\n\\t\\tthis.boundingBox = null;\\n\\t\\tthis.boundingSphere = null;\\n\\n\\t\\t// update flags\\n\\n\\t\\tthis.elementsNeedUpdate = false;\\n\\t\\tthis.verticesNeedUpdate = false;\\n\\t\\tthis.uvsNeedUpdate = false;\\n\\t\\tthis.normalsNeedUpdate = false;\\n\\t\\tthis.colorsNeedUpdate = false;\\n\\t\\tthis.lineDistancesNeedUpdate = false;\\n\\t\\tthis.groupsNeedUpdate = false;\\n\\n\\t}\\n\\n\\tGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\n\\n\\t\\tconstructor: Geometry,\\n\\n\\t\\tisGeometry: true,\\n\\n\\t\\tapplyMatrix: function ( matrix ) {\\n\\n\\t\\t\\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\\n\\n\\t\\t\\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar vertex = this.vertices[ i ];\\n\\t\\t\\t\\tvertex.applyMatrix4( matrix );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar face = this.faces[ i ];\\n\\t\\t\\t\\tface.normal.applyMatrix3( normalMatrix ).normalize();\\n\\n\\t\\t\\t\\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.boundingBox !== null ) {\\n\\n\\t\\t\\t\\tthis.computeBoundingBox();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.boundingSphere !== null ) {\\n\\n\\t\\t\\t\\tthis.computeBoundingSphere();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.verticesNeedUpdate = true;\\n\\t\\t\\tthis.normalsNeedUpdate = true;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\trotateX: function () {\\n\\n\\t\\t\\t// rotate geometry around world x-axis\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function rotateX( angle ) {\\n\\n\\t\\t\\t\\tm1.makeRotationX( angle );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\trotateY: function () {\\n\\n\\t\\t\\t// rotate geometry around world y-axis\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function rotateY( angle ) {\\n\\n\\t\\t\\t\\tm1.makeRotationY( angle );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\trotateZ: function () {\\n\\n\\t\\t\\t// rotate geometry around world z-axis\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function rotateZ( angle ) {\\n\\n\\t\\t\\t\\tm1.makeRotationZ( angle );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttranslate: function () {\\n\\n\\t\\t\\t// translate geometry\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function translate( x, y, z ) {\\n\\n\\t\\t\\t\\tm1.makeTranslation( x, y, z );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tscale: function () {\\n\\n\\t\\t\\t// scale geometry\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function scale( x, y, z ) {\\n\\n\\t\\t\\t\\tm1.makeScale( x, y, z );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tlookAt: function () {\\n\\n\\t\\t\\tvar obj = new Object3D();\\n\\n\\t\\t\\treturn function lookAt( vector ) {\\n\\n\\t\\t\\t\\tobj.lookAt( vector );\\n\\n\\t\\t\\t\\tobj.updateMatrix();\\n\\n\\t\\t\\t\\tthis.applyMatrix( obj.matrix );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tfromBufferGeometry: function ( geometry ) {\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\\n\\t\\t\\tvar attributes = geometry.attributes;\\n\\n\\t\\t\\tvar positions = attributes.position.array;\\n\\t\\t\\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\\n\\t\\t\\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\\n\\t\\t\\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\\n\\t\\t\\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\\n\\n\\t\\t\\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\\n\\n\\t\\t\\tvar tempNormals = [];\\n\\t\\t\\tvar tempUVs = [];\\n\\t\\t\\tvar tempUVs2 = [];\\n\\n\\t\\t\\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\\n\\n\\t\\t\\t\\tscope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\\n\\n\\t\\t\\t\\tif ( normals !== undefined ) {\\n\\n\\t\\t\\t\\t\\ttempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( colors !== undefined ) {\\n\\n\\t\\t\\t\\t\\tscope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( uvs !== undefined ) {\\n\\n\\t\\t\\t\\t\\ttempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( uvs2 !== undefined ) {\\n\\n\\t\\t\\t\\t\\ttempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction addFace( a, b, c, materialIndex ) {\\n\\n\\t\\t\\t\\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\\n\\t\\t\\t\\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\\n\\n\\t\\t\\t\\tvar face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\\n\\n\\t\\t\\t\\tscope.faces.push( face );\\n\\n\\t\\t\\t\\tif ( uvs !== undefined ) {\\n\\n\\t\\t\\t\\t\\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( uvs2 !== undefined ) {\\n\\n\\t\\t\\t\\t\\tscope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar groups = geometry.groups;\\n\\n\\t\\t\\tif ( groups.length > 0 ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < groups.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar group = groups[ i ];\\n\\n\\t\\t\\t\\t\\tvar start = group.start;\\n\\t\\t\\t\\t\\tvar count = group.count;\\n\\n\\t\\t\\t\\t\\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( indices !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\taddFace( j, j + 1, j + 2, group.materialIndex );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tif ( indices !== undefined ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < indices.length; i += 3 ) {\\n\\n\\t\\t\\t\\t\\t\\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\\n\\n\\t\\t\\t\\t\\t\\taddFace( i, i + 1, i + 2 );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.computeFaceNormals();\\n\\n\\t\\t\\tif ( geometry.boundingBox !== null ) {\\n\\n\\t\\t\\t\\tthis.boundingBox = geometry.boundingBox.clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.boundingSphere !== null ) {\\n\\n\\t\\t\\t\\tthis.boundingSphere = geometry.boundingSphere.clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcenter: function () {\\n\\n\\t\\t\\tthis.computeBoundingBox();\\n\\n\\t\\t\\tvar offset = this.boundingBox.getCenter().negate();\\n\\n\\t\\t\\tthis.translate( offset.x, offset.y, offset.z );\\n\\n\\t\\t\\treturn offset;\\n\\n\\t\\t},\\n\\n\\t\\tnormalize: function () {\\n\\n\\t\\t\\tthis.computeBoundingSphere();\\n\\n\\t\\t\\tvar center = this.boundingSphere.center;\\n\\t\\t\\tvar radius = this.boundingSphere.radius;\\n\\n\\t\\t\\tvar s = radius === 0 ? 1 : 1.0 / radius;\\n\\n\\t\\t\\tvar matrix = new Matrix4();\\n\\t\\t\\tmatrix.set(\\n\\t\\t\\t\\ts, 0, 0, - s * center.x,\\n\\t\\t\\t\\t0, s, 0, - s * center.y,\\n\\t\\t\\t\\t0, 0, s, - s * center.z,\\n\\t\\t\\t\\t0, 0, 0, 1\\n\\t\\t\\t);\\n\\n\\t\\t\\tthis.applyMatrix( matrix );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcomputeFaceNormals: function () {\\n\\n\\t\\t\\tvar cb = new Vector3(), ab = new Vector3();\\n\\n\\t\\t\\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\tvar face = this.faces[ f ];\\n\\n\\t\\t\\t\\tvar vA = this.vertices[ face.a ];\\n\\t\\t\\t\\tvar vB = this.vertices[ face.b ];\\n\\t\\t\\t\\tvar vC = this.vertices[ face.c ];\\n\\n\\t\\t\\t\\tcb.subVectors( vC, vB );\\n\\t\\t\\t\\tab.subVectors( vA, vB );\\n\\t\\t\\t\\tcb.cross( ab );\\n\\n\\t\\t\\t\\tcb.normalize();\\n\\n\\t\\t\\t\\tface.normal.copy( cb );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tcomputeVertexNormals: function ( areaWeighted ) {\\n\\n\\t\\t\\tif ( areaWeighted === undefined ) areaWeighted = true;\\n\\n\\t\\t\\tvar v, vl, f, fl, face, vertices;\\n\\n\\t\\t\\tvertices = new Array( this.vertices.length );\\n\\n\\t\\t\\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\\n\\n\\t\\t\\t\\tvertices[ v ] = new Vector3();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( areaWeighted ) {\\n\\n\\t\\t\\t\\t// vertex normals weighted by triangle areas\\n\\t\\t\\t\\t// http://www.iquilezles.org/www/articles/normals/normals.htm\\n\\n\\t\\t\\t\\tvar vA, vB, vC;\\n\\t\\t\\t\\tvar cb = new Vector3(), ab = new Vector3();\\n\\n\\t\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\t\\tface = this.faces[ f ];\\n\\n\\t\\t\\t\\t\\tvA = this.vertices[ face.a ];\\n\\t\\t\\t\\t\\tvB = this.vertices[ face.b ];\\n\\t\\t\\t\\t\\tvC = this.vertices[ face.c ];\\n\\n\\t\\t\\t\\t\\tcb.subVectors( vC, vB );\\n\\t\\t\\t\\t\\tab.subVectors( vA, vB );\\n\\t\\t\\t\\t\\tcb.cross( ab );\\n\\n\\t\\t\\t\\t\\tvertices[ face.a ].add( cb );\\n\\t\\t\\t\\t\\tvertices[ face.b ].add( cb );\\n\\t\\t\\t\\t\\tvertices[ face.c ].add( cb );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.computeFaceNormals();\\n\\n\\t\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\t\\tface = this.faces[ f ];\\n\\n\\t\\t\\t\\t\\tvertices[ face.a ].add( face.normal );\\n\\t\\t\\t\\t\\tvertices[ face.b ].add( face.normal );\\n\\t\\t\\t\\t\\tvertices[ face.c ].add( face.normal );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\\n\\n\\t\\t\\t\\tvertices[ v ].normalize();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\tface = this.faces[ f ];\\n\\n\\t\\t\\t\\tvar vertexNormals = face.vertexNormals;\\n\\n\\t\\t\\t\\tif ( vertexNormals.length === 3 ) {\\n\\n\\t\\t\\t\\t\\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\\n\\t\\t\\t\\t\\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\\n\\t\\t\\t\\t\\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\\n\\t\\t\\t\\t\\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\\n\\t\\t\\t\\t\\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.faces.length > 0 ) {\\n\\n\\t\\t\\t\\tthis.normalsNeedUpdate = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tcomputeFlatVertexNormals: function () {\\n\\n\\t\\t\\tvar f, fl, face;\\n\\n\\t\\t\\tthis.computeFaceNormals();\\n\\n\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\tface = this.faces[ f ];\\n\\n\\t\\t\\t\\tvar vertexNormals = face.vertexNormals;\\n\\n\\t\\t\\t\\tif ( vertexNormals.length === 3 ) {\\n\\n\\t\\t\\t\\t\\tvertexNormals[ 0 ].copy( face.normal );\\n\\t\\t\\t\\t\\tvertexNormals[ 1 ].copy( face.normal );\\n\\t\\t\\t\\t\\tvertexNormals[ 2 ].copy( face.normal );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tvertexNormals[ 0 ] = face.normal.clone();\\n\\t\\t\\t\\t\\tvertexNormals[ 1 ] = face.normal.clone();\\n\\t\\t\\t\\t\\tvertexNormals[ 2 ] = face.normal.clone();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.faces.length > 0 ) {\\n\\n\\t\\t\\t\\tthis.normalsNeedUpdate = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tcomputeMorphNormals: function () {\\n\\n\\t\\t\\tvar i, il, f, fl, face;\\n\\n\\t\\t\\t// save original normals\\n\\t\\t\\t// - create temp variables on first access\\n\\t\\t\\t//   otherwise just copy (for faster repeated calls)\\n\\n\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\tface = this.faces[ f ];\\n\\n\\t\\t\\t\\tif ( ! face.__originalFaceNormal ) {\\n\\n\\t\\t\\t\\t\\tface.__originalFaceNormal = face.normal.clone();\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tface.__originalFaceNormal.copy( face.normal );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\\n\\n\\t\\t\\t\\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\tif ( ! face.__originalVertexNormals[ i ] ) {\\n\\n\\t\\t\\t\\t\\t\\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// use temp geometry to compute face and vertex normals for each morph\\n\\n\\t\\t\\tvar tmpGeo = new Geometry();\\n\\t\\t\\ttmpGeo.faces = this.faces;\\n\\n\\t\\t\\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t// create on first access\\n\\n\\t\\t\\t\\tif ( ! this.morphNormals[ i ] ) {\\n\\n\\t\\t\\t\\t\\tthis.morphNormals[ i ] = {};\\n\\t\\t\\t\\t\\tthis.morphNormals[ i ].faceNormals = [];\\n\\t\\t\\t\\t\\tthis.morphNormals[ i ].vertexNormals = [];\\n\\n\\t\\t\\t\\t\\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\\n\\t\\t\\t\\t\\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\\n\\n\\t\\t\\t\\t\\tvar faceNormal, vertexNormals;\\n\\n\\t\\t\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tfaceNormal = new Vector3();\\n\\t\\t\\t\\t\\t\\tvertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\\n\\n\\t\\t\\t\\t\\t\\tdstNormalsFace.push( faceNormal );\\n\\t\\t\\t\\t\\t\\tdstNormalsVertex.push( vertexNormals );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar morphNormals = this.morphNormals[ i ];\\n\\n\\t\\t\\t\\t// set vertices to morph target\\n\\n\\t\\t\\t\\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\\n\\n\\t\\t\\t\\t// compute morph normals\\n\\n\\t\\t\\t\\ttmpGeo.computeFaceNormals();\\n\\t\\t\\t\\ttmpGeo.computeVertexNormals();\\n\\n\\t\\t\\t\\t// store morph normals\\n\\n\\t\\t\\t\\tvar faceNormal, vertexNormals;\\n\\n\\t\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\t\\tface = this.faces[ f ];\\n\\n\\t\\t\\t\\t\\tfaceNormal = morphNormals.faceNormals[ f ];\\n\\t\\t\\t\\t\\tvertexNormals = morphNormals.vertexNormals[ f ];\\n\\n\\t\\t\\t\\t\\tfaceNormal.copy( face.normal );\\n\\n\\t\\t\\t\\t\\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\\n\\t\\t\\t\\t\\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\\n\\t\\t\\t\\t\\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// restore original normals\\n\\n\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\tface = this.faces[ f ];\\n\\n\\t\\t\\t\\tface.normal = face.__originalFaceNormal;\\n\\t\\t\\t\\tface.vertexNormals = face.__originalVertexNormals;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tcomputeLineDistances: function () {\\n\\n\\t\\t\\tvar d = 0;\\n\\t\\t\\tvar vertices = this.vertices;\\n\\n\\t\\t\\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tif ( i > 0 ) {\\n\\n\\t\\t\\t\\t\\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.lineDistances[ i ] = d;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tcomputeBoundingBox: function () {\\n\\n\\t\\t\\tif ( this.boundingBox === null ) {\\n\\n\\t\\t\\t\\tthis.boundingBox = new Box3();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.boundingBox.setFromPoints( this.vertices );\\n\\n\\t\\t},\\n\\n\\t\\tcomputeBoundingSphere: function () {\\n\\n\\t\\t\\tif ( this.boundingSphere === null ) {\\n\\n\\t\\t\\t\\tthis.boundingSphere = new Sphere();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.boundingSphere.setFromPoints( this.vertices );\\n\\n\\t\\t},\\n\\n\\t\\tmerge: function ( geometry, matrix, materialIndexOffset ) {\\n\\n\\t\\t\\tif ( ! ( geometry && geometry.isGeometry ) ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar normalMatrix,\\n\\t\\t\\t\\tvertexOffset = this.vertices.length,\\n\\t\\t\\t\\tvertices1 = this.vertices,\\n\\t\\t\\t\\tvertices2 = geometry.vertices,\\n\\t\\t\\t\\tfaces1 = this.faces,\\n\\t\\t\\t\\tfaces2 = geometry.faces,\\n\\t\\t\\t\\tuvs1 = this.faceVertexUvs[ 0 ],\\n\\t\\t\\t\\tuvs2 = geometry.faceVertexUvs[ 0 ],\\n\\t\\t\\t\\tcolors1 = this.colors,\\n\\t\\t\\t\\tcolors2 = geometry.colors;\\n\\n\\t\\t\\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\\n\\n\\t\\t\\tif ( matrix !== undefined ) {\\n\\n\\t\\t\\t\\tnormalMatrix = new Matrix3().getNormalMatrix( matrix );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// vertices\\n\\n\\t\\t\\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar vertex = vertices2[ i ];\\n\\n\\t\\t\\t\\tvar vertexCopy = vertex.clone();\\n\\n\\t\\t\\t\\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\\n\\n\\t\\t\\t\\tvertices1.push( vertexCopy );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// colors\\n\\n\\t\\t\\tfor ( var i = 0, il = colors2.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tcolors1.push( colors2[ i ].clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// faces\\n\\n\\t\\t\\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar face = faces2[ i ], faceCopy, normal, color,\\n\\t\\t\\t\\t\\tfaceVertexNormals = face.vertexNormals,\\n\\t\\t\\t\\t\\tfaceVertexColors = face.vertexColors;\\n\\n\\t\\t\\t\\tfaceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\\n\\t\\t\\t\\tfaceCopy.normal.copy( face.normal );\\n\\n\\t\\t\\t\\tif ( normalMatrix !== undefined ) {\\n\\n\\t\\t\\t\\t\\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\tnormal = faceVertexNormals[ j ].clone();\\n\\n\\t\\t\\t\\t\\tif ( normalMatrix !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tnormal.applyMatrix3( normalMatrix ).normalize();\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfaceCopy.vertexNormals.push( normal );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfaceCopy.color.copy( face.color );\\n\\n\\t\\t\\t\\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\tcolor = faceVertexColors[ j ];\\n\\t\\t\\t\\t\\tfaceCopy.vertexColors.push( color.clone() );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\\n\\n\\t\\t\\t\\tfaces1.push( faceCopy );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// uvs\\n\\n\\t\\t\\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar uv = uvs2[ i ], uvCopy = [];\\n\\n\\t\\t\\t\\tif ( uv === undefined ) {\\n\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\tuvCopy.push( uv[ j ].clone() );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tuvs1.push( uvCopy );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tmergeMesh: function ( mesh ) {\\n\\n\\t\\t\\tif ( ! ( mesh && mesh.isMesh ) ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tmesh.matrixAutoUpdate && mesh.updateMatrix();\\n\\n\\t\\t\\tthis.merge( mesh.geometry, mesh.matrix );\\n\\n\\t\\t},\\n\\n\\t\\t/*\\n\\t\\t * Checks for duplicate vertices with hashmap.\\n\\t\\t * Duplicated vertices are removed\\n\\t\\t * and faces' vertices are updated.\\n\\t\\t */\\n\\n\\t\\tmergeVertices: function () {\\n\\n\\t\\t\\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\\n\\t\\t\\tvar unique = [], changes = [];\\n\\n\\t\\t\\tvar v, key;\\n\\t\\t\\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\\n\\t\\t\\tvar precision = Math.pow( 10, precisionPoints );\\n\\t\\t\\tvar i, il, face;\\n\\t\\t\\tvar indices, j, jl;\\n\\n\\t\\t\\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tv = this.vertices[ i ];\\n\\t\\t\\t\\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\\n\\n\\t\\t\\t\\tif ( verticesMap[ key ] === undefined ) {\\n\\n\\t\\t\\t\\t\\tverticesMap[ key ] = i;\\n\\t\\t\\t\\t\\tunique.push( this.vertices[ i ] );\\n\\t\\t\\t\\t\\tchanges[ i ] = unique.length - 1;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\\n\\t\\t\\t\\t\\tchanges[ i ] = changes[ verticesMap[ key ] ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\t// if faces are completely degenerate after merging vertices, we\\n\\t\\t\\t// have to remove them from the geometry.\\n\\t\\t\\tvar faceIndicesToRemove = [];\\n\\n\\t\\t\\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tface = this.faces[ i ];\\n\\n\\t\\t\\t\\tface.a = changes[ face.a ];\\n\\t\\t\\t\\tface.b = changes[ face.b ];\\n\\t\\t\\t\\tface.c = changes[ face.c ];\\n\\n\\t\\t\\t\\tindices = [ face.a, face.b, face.c ];\\n\\n\\t\\t\\t\\t// if any duplicate vertices are found in a Face3\\n\\t\\t\\t\\t// we have to remove the face as nothing can be saved\\n\\t\\t\\t\\tfor ( var n = 0; n < 3; n ++ ) {\\n\\n\\t\\t\\t\\t\\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\\n\\n\\t\\t\\t\\t\\t\\tfaceIndicesToRemove.push( i );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\\n\\n\\t\\t\\t\\tvar idx = faceIndicesToRemove[ i ];\\n\\n\\t\\t\\t\\tthis.faces.splice( idx, 1 );\\n\\n\\t\\t\\t\\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\tthis.faceVertexUvs[ j ].splice( idx, 1 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Use unique set of vertices\\n\\n\\t\\t\\tvar diff = this.vertices.length - unique.length;\\n\\t\\t\\tthis.vertices = unique;\\n\\t\\t\\treturn diff;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromPoints: function ( points ) {\\n\\n\\t\\t\\tthis.vertices = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar point = points[ i ];\\n\\t\\t\\t\\tthis.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsortFacesByMaterialIndex: function () {\\n\\n\\t\\t\\tvar faces = this.faces;\\n\\t\\t\\tvar length = faces.length;\\n\\n\\t\\t\\t// tag faces\\n\\n\\t\\t\\tfor ( var i = 0; i < length; i ++ ) {\\n\\n\\t\\t\\t\\tfaces[ i ]._id = i;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// sort faces\\n\\n\\t\\t\\tfunction materialIndexSort( a, b ) {\\n\\n\\t\\t\\t\\treturn a.materialIndex - b.materialIndex;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfaces.sort( materialIndexSort );\\n\\n\\t\\t\\t// sort uvs\\n\\n\\t\\t\\tvar uvs1 = this.faceVertexUvs[ 0 ];\\n\\t\\t\\tvar uvs2 = this.faceVertexUvs[ 1 ];\\n\\n\\t\\t\\tvar newUvs1, newUvs2;\\n\\n\\t\\t\\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\\n\\t\\t\\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\\n\\n\\t\\t\\tfor ( var i = 0; i < length; i ++ ) {\\n\\n\\t\\t\\t\\tvar id = faces[ i ]._id;\\n\\n\\t\\t\\t\\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\\n\\t\\t\\t\\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\\n\\t\\t\\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function () {\\n\\n\\t\\t\\tvar data = {\\n\\t\\t\\t\\tmetadata: {\\n\\t\\t\\t\\t\\tversion: 4.5,\\n\\t\\t\\t\\t\\ttype: 'Geometry',\\n\\t\\t\\t\\t\\tgenerator: 'Geometry.toJSON'\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\t\\t// standard Geometry serialization\\n\\n\\t\\t\\tdata.uuid = this.uuid;\\n\\t\\t\\tdata.type = this.type;\\n\\t\\t\\tif ( this.name !== '' ) data.name = this.name;\\n\\n\\t\\t\\tif ( this.parameters !== undefined ) {\\n\\n\\t\\t\\t\\tvar parameters = this.parameters;\\n\\n\\t\\t\\t\\tfor ( var key in parameters ) {\\n\\n\\t\\t\\t\\t\\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn data;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar vertices = [];\\n\\n\\t\\t\\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\\n\\n\\t\\t\\t\\tvar vertex = this.vertices[ i ];\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar faces = [];\\n\\t\\t\\tvar normals = [];\\n\\t\\t\\tvar normalsHash = {};\\n\\t\\t\\tvar colors = [];\\n\\t\\t\\tvar colorsHash = {};\\n\\t\\t\\tvar uvs = [];\\n\\t\\t\\tvar uvsHash = {};\\n\\n\\t\\t\\tfor ( var i = 0; i < this.faces.length; i ++ ) {\\n\\n\\t\\t\\t\\tvar face = this.faces[ i ];\\n\\n\\t\\t\\t\\tvar hasMaterial = true;\\n\\t\\t\\t\\tvar hasFaceUv = false; // deprecated\\n\\t\\t\\t\\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\\n\\t\\t\\t\\tvar hasFaceNormal = face.normal.length() > 0;\\n\\t\\t\\t\\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\\n\\t\\t\\t\\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\\n\\t\\t\\t\\tvar hasFaceVertexColor = face.vertexColors.length > 0;\\n\\n\\t\\t\\t\\tvar faceType = 0;\\n\\n\\t\\t\\t\\tfaceType = setBit( faceType, 0, 0 ); // isQuad\\n\\t\\t\\t\\tfaceType = setBit( faceType, 1, hasMaterial );\\n\\t\\t\\t\\tfaceType = setBit( faceType, 2, hasFaceUv );\\n\\t\\t\\t\\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\\n\\t\\t\\t\\tfaceType = setBit( faceType, 4, hasFaceNormal );\\n\\t\\t\\t\\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\\n\\t\\t\\t\\tfaceType = setBit( faceType, 6, hasFaceColor );\\n\\t\\t\\t\\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\\n\\n\\t\\t\\t\\tfaces.push( faceType );\\n\\t\\t\\t\\tfaces.push( face.a, face.b, face.c );\\n\\t\\t\\t\\tfaces.push( face.materialIndex );\\n\\n\\t\\t\\t\\tif ( hasFaceVertexUv ) {\\n\\n\\t\\t\\t\\t\\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\\n\\n\\t\\t\\t\\t\\tfaces.push(\\n\\t\\t\\t\\t\\t\\tgetUvIndex( faceVertexUvs[ 0 ] ),\\n\\t\\t\\t\\t\\t\\tgetUvIndex( faceVertexUvs[ 1 ] ),\\n\\t\\t\\t\\t\\t\\tgetUvIndex( faceVertexUvs[ 2 ] )\\n\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( hasFaceNormal ) {\\n\\n\\t\\t\\t\\t\\tfaces.push( getNormalIndex( face.normal ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( hasFaceVertexNormal ) {\\n\\n\\t\\t\\t\\t\\tvar vertexNormals = face.vertexNormals;\\n\\n\\t\\t\\t\\t\\tfaces.push(\\n\\t\\t\\t\\t\\t\\tgetNormalIndex( vertexNormals[ 0 ] ),\\n\\t\\t\\t\\t\\t\\tgetNormalIndex( vertexNormals[ 1 ] ),\\n\\t\\t\\t\\t\\t\\tgetNormalIndex( vertexNormals[ 2 ] )\\n\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( hasFaceColor ) {\\n\\n\\t\\t\\t\\t\\tfaces.push( getColorIndex( face.color ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( hasFaceVertexColor ) {\\n\\n\\t\\t\\t\\t\\tvar vertexColors = face.vertexColors;\\n\\n\\t\\t\\t\\t\\tfaces.push(\\n\\t\\t\\t\\t\\t\\tgetColorIndex( vertexColors[ 0 ] ),\\n\\t\\t\\t\\t\\t\\tgetColorIndex( vertexColors[ 1 ] ),\\n\\t\\t\\t\\t\\t\\tgetColorIndex( vertexColors[ 2 ] )\\n\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction setBit( value, position, enabled ) {\\n\\n\\t\\t\\t\\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction getNormalIndex( normal ) {\\n\\n\\t\\t\\t\\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\\n\\n\\t\\t\\t\\tif ( normalsHash[ hash ] !== undefined ) {\\n\\n\\t\\t\\t\\t\\treturn normalsHash[ hash ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tnormalsHash[ hash ] = normals.length / 3;\\n\\t\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\n\\n\\t\\t\\t\\treturn normalsHash[ hash ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction getColorIndex( color ) {\\n\\n\\t\\t\\t\\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\\n\\n\\t\\t\\t\\tif ( colorsHash[ hash ] !== undefined ) {\\n\\n\\t\\t\\t\\t\\treturn colorsHash[ hash ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcolorsHash[ hash ] = colors.length;\\n\\t\\t\\t\\tcolors.push( color.getHex() );\\n\\n\\t\\t\\t\\treturn colorsHash[ hash ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction getUvIndex( uv ) {\\n\\n\\t\\t\\t\\tvar hash = uv.x.toString() + uv.y.toString();\\n\\n\\t\\t\\t\\tif ( uvsHash[ hash ] !== undefined ) {\\n\\n\\t\\t\\t\\t\\treturn uvsHash[ hash ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tuvsHash[ hash ] = uvs.length / 2;\\n\\t\\t\\t\\tuvs.push( uv.x, uv.y );\\n\\n\\t\\t\\t\\treturn uvsHash[ hash ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tdata.data = {};\\n\\n\\t\\t\\tdata.data.vertices = vertices;\\n\\t\\t\\tdata.data.normals = normals;\\n\\t\\t\\tif ( colors.length > 0 ) data.data.colors = colors;\\n\\t\\t\\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\\n\\t\\t\\tdata.data.faces = faces;\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\t/*\\n\\t\\t\\t // Handle primitives\\n\\n\\t\\t\\t var parameters = this.parameters;\\n\\n\\t\\t\\t if ( parameters !== undefined ) {\\n\\n\\t\\t\\t var values = [];\\n\\n\\t\\t\\t for ( var key in parameters ) {\\n\\n\\t\\t\\t values.push( parameters[ key ] );\\n\\n\\t\\t\\t }\\n\\n\\t\\t\\t var geometry = Object.create( this.constructor.prototype );\\n\\t\\t\\t this.constructor.apply( geometry, values );\\n\\t\\t\\t return geometry;\\n\\n\\t\\t\\t }\\n\\n\\t\\t\\t return new this.constructor().copy( this );\\n\\t\\t\\t */\\n\\n\\t\\t\\treturn new Geometry().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tvar i, il, j, jl, k, kl;\\n\\n\\t\\t\\t// reset\\n\\n\\t\\t\\tthis.vertices = [];\\n\\t\\t\\tthis.colors = [];\\n\\t\\t\\tthis.faces = [];\\n\\t\\t\\tthis.faceVertexUvs = [[]];\\n\\t\\t\\tthis.morphTargets = [];\\n\\t\\t\\tthis.morphNormals = [];\\n\\t\\t\\tthis.skinWeights = [];\\n\\t\\t\\tthis.skinIndices = [];\\n\\t\\t\\tthis.lineDistances = [];\\n\\t\\t\\tthis.boundingBox = null;\\n\\t\\t\\tthis.boundingSphere = null;\\n\\n\\t\\t\\t// name\\n\\n\\t\\t\\tthis.name = source.name;\\n\\n\\t\\t\\t// vertices\\n\\n\\t\\t\\tvar vertices = source.vertices;\\n\\n\\t\\t\\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.vertices.push( vertices[ i ].clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// colors\\n\\n\\t\\t\\tvar colors = source.colors;\\n\\n\\t\\t\\tfor ( i = 0, il = colors.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.colors.push( colors[ i ].clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// faces\\n\\n\\t\\t\\tvar faces = source.faces;\\n\\n\\t\\t\\tfor ( i = 0, il = faces.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.faces.push( faces[ i ].clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// face vertex uvs\\n\\n\\t\\t\\tfor ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar faceVertexUvs = source.faceVertexUvs[ i ];\\n\\n\\t\\t\\t\\tif ( this.faceVertexUvs[ i ] === undefined ) {\\n\\n\\t\\t\\t\\t\\tthis.faceVertexUvs[ i ] = [];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\\n\\n\\t\\t\\t\\t\\tfor ( k = 0, kl = uvs.length; k < kl; k ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar uv = uvs[ k ];\\n\\n\\t\\t\\t\\t\\t\\tuvsCopy.push( uv.clone() );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tthis.faceVertexUvs[ i ].push( uvsCopy );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// morph targets\\n\\n\\t\\t\\tvar morphTargets = source.morphTargets;\\n\\n\\t\\t\\tfor ( i = 0, il = morphTargets.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar morphTarget = {};\\n\\t\\t\\t\\tmorphTarget.name = morphTargets[ i ].name;\\n\\n\\t\\t\\t\\t// vertices\\n\\n\\t\\t\\t\\tif ( morphTargets[ i ].vertices !== undefined ) {\\n\\n\\t\\t\\t\\t\\tmorphTarget.vertices = [];\\n\\n\\t\\t\\t\\t\\tfor ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tmorphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// normals\\n\\n\\t\\t\\t\\tif ( morphTargets[ i ].normals !== undefined ) {\\n\\n\\t\\t\\t\\t\\tmorphTarget.normals = [];\\n\\n\\t\\t\\t\\t\\tfor ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tmorphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.morphTargets.push( morphTarget );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// morph normals\\n\\n\\t\\t\\tvar morphNormals = source.morphNormals;\\n\\n\\t\\t\\tfor ( i = 0, il = morphNormals.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar morphNormal = {};\\n\\n\\t\\t\\t\\t// vertex normals\\n\\n\\t\\t\\t\\tif ( morphNormals[ i ].vertexNormals !== undefined ) {\\n\\n\\t\\t\\t\\t\\tmorphNormal.vertexNormals = [];\\n\\n\\t\\t\\t\\t\\tfor ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];\\n\\t\\t\\t\\t\\t\\tvar destVertexNormal = {};\\n\\n\\t\\t\\t\\t\\t\\tdestVertexNormal.a = srcVertexNormal.a.clone();\\n\\t\\t\\t\\t\\t\\tdestVertexNormal.b = srcVertexNormal.b.clone();\\n\\t\\t\\t\\t\\t\\tdestVertexNormal.c = srcVertexNormal.c.clone();\\n\\n\\t\\t\\t\\t\\t\\tmorphNormal.vertexNormals.push( destVertexNormal );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// face normals\\n\\n\\t\\t\\t\\tif ( morphNormals[ i ].faceNormals !== undefined ) {\\n\\n\\t\\t\\t\\t\\tmorphNormal.faceNormals = [];\\n\\n\\t\\t\\t\\t\\tfor ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tmorphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.morphNormals.push( morphNormal );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// skin weights\\n\\n\\t\\t\\tvar skinWeights = source.skinWeights;\\n\\n\\t\\t\\tfor ( i = 0, il = skinWeights.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.skinWeights.push( skinWeights[ i ].clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// skin indices\\n\\n\\t\\t\\tvar skinIndices = source.skinIndices;\\n\\n\\t\\t\\tfor ( i = 0, il = skinIndices.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.skinIndices.push( skinIndices[ i ].clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// line distances\\n\\n\\t\\t\\tvar lineDistances = source.lineDistances;\\n\\n\\t\\t\\tfor ( i = 0, il = lineDistances.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.lineDistances.push( lineDistances[ i ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// bounding box\\n\\n\\t\\t\\tvar boundingBox = source.boundingBox;\\n\\n\\t\\t\\tif ( boundingBox !== null ) {\\n\\n\\t\\t\\t\\tthis.boundingBox = boundingBox.clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// bounding sphere\\n\\n\\t\\t\\tvar boundingSphere = source.boundingSphere;\\n\\n\\t\\t\\tif ( boundingSphere !== null ) {\\n\\n\\t\\t\\t\\tthis.boundingSphere = boundingSphere.clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// update flags\\n\\n\\t\\t\\tthis.elementsNeedUpdate = source.elementsNeedUpdate;\\n\\t\\t\\tthis.verticesNeedUpdate = source.verticesNeedUpdate;\\n\\t\\t\\tthis.uvsNeedUpdate = source.uvsNeedUpdate;\\n\\t\\t\\tthis.normalsNeedUpdate = source.normalsNeedUpdate;\\n\\t\\t\\tthis.colorsNeedUpdate = source.colorsNeedUpdate;\\n\\t\\t\\tthis.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\\n\\t\\t\\tthis.groupsNeedUpdate = source.groupsNeedUpdate;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdispose: function () {\\n\\n\\t\\t\\tthis.dispatchEvent( { type: 'dispose' } );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction BufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tif ( Array.isArray( array ) ) {\\n\\n\\t\\t\\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\\n\\n\\t\\t}\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\t\\tthis.name = '';\\n\\n\\t\\tthis.array = array;\\n\\t\\tthis.itemSize = itemSize;\\n\\t\\tthis.count = array !== undefined ? array.length / itemSize : 0;\\n\\t\\tthis.normalized = normalized === true;\\n\\n\\t\\tthis.dynamic = false;\\n\\t\\tthis.updateRange = { offset: 0, count: - 1 };\\n\\n\\t\\tthis.onUploadCallback = function () {};\\n\\n\\t\\tthis.version = 0;\\n\\n\\t}\\n\\n\\tObject.defineProperty( BufferAttribute.prototype, 'needsUpdate', {\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tif ( value === true ) this.version ++;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( BufferAttribute.prototype, {\\n\\n\\t\\tisBufferAttribute: true,\\n\\n\\t\\tsetArray: function ( array ) {\\n\\n\\t\\t\\tif ( Array.isArray( array ) ) {\\n\\n\\t\\t\\t\\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.count = array !== undefined ? array.length / this.itemSize : 0;\\n\\t\\t\\tthis.array = array;\\n\\n\\t\\t},\\n\\n\\t\\tsetDynamic: function ( value ) {\\n\\n\\t\\t\\tthis.dynamic = value;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tthis.array = new source.array.constructor( source.array );\\n\\t\\t\\tthis.itemSize = source.itemSize;\\n\\t\\t\\tthis.count = source.count;\\n\\t\\t\\tthis.normalized = source.normalized;\\n\\n\\t\\t\\tthis.dynamic = source.dynamic;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyAt: function ( index1, attribute, index2 ) {\\n\\n\\t\\t\\tindex1 *= this.itemSize;\\n\\t\\t\\tindex2 *= attribute.itemSize;\\n\\n\\t\\t\\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyArray: function ( array ) {\\n\\n\\t\\t\\tthis.array.set( array );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyColorsArray: function ( colors ) {\\n\\n\\t\\t\\tvar array = this.array, offset = 0;\\n\\n\\t\\t\\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar color = colors[ i ];\\n\\n\\t\\t\\t\\tif ( color === undefined ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\\n\\t\\t\\t\\t\\tcolor = new Color();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tarray[ offset ++ ] = color.r;\\n\\t\\t\\t\\tarray[ offset ++ ] = color.g;\\n\\t\\t\\t\\tarray[ offset ++ ] = color.b;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyIndicesArray: function ( indices ) {\\n\\n\\t\\t\\tvar array = this.array, offset = 0;\\n\\n\\t\\t\\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar index = indices[ i ];\\n\\n\\t\\t\\t\\tarray[ offset ++ ] = index.a;\\n\\t\\t\\t\\tarray[ offset ++ ] = index.b;\\n\\t\\t\\t\\tarray[ offset ++ ] = index.c;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyVector2sArray: function ( vectors ) {\\n\\n\\t\\t\\tvar array = this.array, offset = 0;\\n\\n\\t\\t\\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar vector = vectors[ i ];\\n\\n\\t\\t\\t\\tif ( vector === undefined ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\\n\\t\\t\\t\\t\\tvector = new Vector2();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.x;\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.y;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyVector3sArray: function ( vectors ) {\\n\\n\\t\\t\\tvar array = this.array, offset = 0;\\n\\n\\t\\t\\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar vector = vectors[ i ];\\n\\n\\t\\t\\t\\tif ( vector === undefined ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\\n\\t\\t\\t\\t\\tvector = new Vector3();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.x;\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.y;\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.z;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyVector4sArray: function ( vectors ) {\\n\\n\\t\\t\\tvar array = this.array, offset = 0;\\n\\n\\t\\t\\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar vector = vectors[ i ];\\n\\n\\t\\t\\t\\tif ( vector === undefined ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\\n\\t\\t\\t\\t\\tvector = new Vector4();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.x;\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.y;\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.z;\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.w;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value, offset ) {\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tthis.array.set( value, offset );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetX: function ( index ) {\\n\\n\\t\\t\\treturn this.array[ index * this.itemSize ];\\n\\n\\t\\t},\\n\\n\\t\\tsetX: function ( index, x ) {\\n\\n\\t\\t\\tthis.array[ index * this.itemSize ] = x;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetY: function ( index ) {\\n\\n\\t\\t\\treturn this.array[ index * this.itemSize + 1 ];\\n\\n\\t\\t},\\n\\n\\t\\tsetY: function ( index, y ) {\\n\\n\\t\\t\\tthis.array[ index * this.itemSize + 1 ] = y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetZ: function ( index ) {\\n\\n\\t\\t\\treturn this.array[ index * this.itemSize + 2 ];\\n\\n\\t\\t},\\n\\n\\t\\tsetZ: function ( index, z ) {\\n\\n\\t\\t\\tthis.array[ index * this.itemSize + 2 ] = z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetW: function ( index ) {\\n\\n\\t\\t\\treturn this.array[ index * this.itemSize + 3 ];\\n\\n\\t\\t},\\n\\n\\t\\tsetW: function ( index, w ) {\\n\\n\\t\\t\\tthis.array[ index * this.itemSize + 3 ] = w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetXY: function ( index, x, y ) {\\n\\n\\t\\t\\tindex *= this.itemSize;\\n\\n\\t\\t\\tthis.array[ index + 0 ] = x;\\n\\t\\t\\tthis.array[ index + 1 ] = y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetXYZ: function ( index, x, y, z ) {\\n\\n\\t\\t\\tindex *= this.itemSize;\\n\\n\\t\\t\\tthis.array[ index + 0 ] = x;\\n\\t\\t\\tthis.array[ index + 1 ] = y;\\n\\t\\t\\tthis.array[ index + 2 ] = z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetXYZW: function ( index, x, y, z, w ) {\\n\\n\\t\\t\\tindex *= this.itemSize;\\n\\n\\t\\t\\tthis.array[ index + 0 ] = x;\\n\\t\\t\\tthis.array[ index + 1 ] = y;\\n\\t\\t\\tthis.array[ index + 2 ] = z;\\n\\t\\t\\tthis.array[ index + 3 ] = w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tonUpload: function ( callback ) {\\n\\n\\t\\t\\tthis.onUploadCallback = callback;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.array, this.itemSize ).copy( this );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tfunction Int8BufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tBufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );\\n\\n\\t}\\n\\n\\tInt8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\n\\tInt8BufferAttribute.prototype.constructor = Int8BufferAttribute;\\n\\n\\n\\tfunction Uint8BufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tBufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );\\n\\n\\t}\\n\\n\\tUint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\n\\tUint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;\\n\\n\\n\\tfunction Uint8ClampedBufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tBufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );\\n\\n\\t}\\n\\n\\tUint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\n\\tUint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;\\n\\n\\n\\tfunction Int16BufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tBufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );\\n\\n\\t}\\n\\n\\tInt16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\n\\tInt16BufferAttribute.prototype.constructor = Int16BufferAttribute;\\n\\n\\n\\tfunction Uint16BufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tBufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );\\n\\n\\t}\\n\\n\\tUint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\n\\tUint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;\\n\\n\\n\\tfunction Int32BufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tBufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );\\n\\n\\t}\\n\\n\\tInt32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\n\\tInt32BufferAttribute.prototype.constructor = Int32BufferAttribute;\\n\\n\\n\\tfunction Uint32BufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tBufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );\\n\\n\\t}\\n\\n\\tUint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\n\\tUint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;\\n\\n\\n\\tfunction Float32BufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tBufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );\\n\\n\\t}\\n\\n\\tFloat32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\n\\tFloat32BufferAttribute.prototype.constructor = Float32BufferAttribute;\\n\\n\\n\\tfunction Float64BufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tBufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );\\n\\n\\t}\\n\\n\\tFloat64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\n\\tFloat64BufferAttribute.prototype.constructor = Float64BufferAttribute;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction DirectGeometry() {\\n\\n\\t\\tthis.indices = [];\\n\\t\\tthis.vertices = [];\\n\\t\\tthis.normals = [];\\n\\t\\tthis.colors = [];\\n\\t\\tthis.uvs = [];\\n\\t\\tthis.uvs2 = [];\\n\\n\\t\\tthis.groups = [];\\n\\n\\t\\tthis.morphTargets = {};\\n\\n\\t\\tthis.skinWeights = [];\\n\\t\\tthis.skinIndices = [];\\n\\n\\t\\t// this.lineDistances = [];\\n\\n\\t\\tthis.boundingBox = null;\\n\\t\\tthis.boundingSphere = null;\\n\\n\\t\\t// update flags\\n\\n\\t\\tthis.verticesNeedUpdate = false;\\n\\t\\tthis.normalsNeedUpdate = false;\\n\\t\\tthis.colorsNeedUpdate = false;\\n\\t\\tthis.uvsNeedUpdate = false;\\n\\t\\tthis.groupsNeedUpdate = false;\\n\\n\\t}\\n\\n\\tObject.assign( DirectGeometry.prototype, {\\n\\n\\t\\tcomputeGroups: function ( geometry ) {\\n\\n\\t\\t\\tvar group;\\n\\t\\t\\tvar groups = [];\\n\\t\\t\\tvar materialIndex = undefined;\\n\\n\\t\\t\\tvar faces = geometry.faces;\\n\\n\\t\\t\\tfor ( var i = 0; i < faces.length; i ++ ) {\\n\\n\\t\\t\\t\\tvar face = faces[ i ];\\n\\n\\t\\t\\t\\t// materials\\n\\n\\t\\t\\t\\tif ( face.materialIndex !== materialIndex ) {\\n\\n\\t\\t\\t\\t\\tmaterialIndex = face.materialIndex;\\n\\n\\t\\t\\t\\t\\tif ( group !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tgroup.count = ( i * 3 ) - group.start;\\n\\t\\t\\t\\t\\t\\tgroups.push( group );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tgroup = {\\n\\t\\t\\t\\t\\t\\tstart: i * 3,\\n\\t\\t\\t\\t\\t\\tmaterialIndex: materialIndex\\n\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( group !== undefined ) {\\n\\n\\t\\t\\t\\tgroup.count = ( i * 3 ) - group.start;\\n\\t\\t\\t\\tgroups.push( group );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.groups = groups;\\n\\n\\t\\t},\\n\\n\\t\\tfromGeometry: function ( geometry ) {\\n\\n\\t\\t\\tvar faces = geometry.faces;\\n\\t\\t\\tvar vertices = geometry.vertices;\\n\\t\\t\\tvar faceVertexUvs = geometry.faceVertexUvs;\\n\\n\\t\\t\\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\\n\\t\\t\\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\\n\\n\\t\\t\\t// morphs\\n\\n\\t\\t\\tvar morphTargets = geometry.morphTargets;\\n\\t\\t\\tvar morphTargetsLength = morphTargets.length;\\n\\n\\t\\t\\tvar morphTargetsPosition;\\n\\n\\t\\t\\tif ( morphTargetsLength > 0 ) {\\n\\n\\t\\t\\t\\tmorphTargetsPosition = [];\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\\n\\n\\t\\t\\t\\t\\tmorphTargetsPosition[ i ] = [];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.morphTargets.position = morphTargetsPosition;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar morphNormals = geometry.morphNormals;\\n\\t\\t\\tvar morphNormalsLength = morphNormals.length;\\n\\n\\t\\t\\tvar morphTargetsNormal;\\n\\n\\t\\t\\tif ( morphNormalsLength > 0 ) {\\n\\n\\t\\t\\t\\tmorphTargetsNormal = [];\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\\n\\n\\t\\t\\t\\t\\tmorphTargetsNormal[ i ] = [];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.morphTargets.normal = morphTargetsNormal;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// skins\\n\\n\\t\\t\\tvar skinIndices = geometry.skinIndices;\\n\\t\\t\\tvar skinWeights = geometry.skinWeights;\\n\\n\\t\\t\\tvar hasSkinIndices = skinIndices.length === vertices.length;\\n\\t\\t\\tvar hasSkinWeights = skinWeights.length === vertices.length;\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tfor ( var i = 0; i < faces.length; i ++ ) {\\n\\n\\t\\t\\t\\tvar face = faces[ i ];\\n\\n\\t\\t\\t\\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\\n\\n\\t\\t\\t\\tvar vertexNormals = face.vertexNormals;\\n\\n\\t\\t\\t\\tif ( vertexNormals.length === 3 ) {\\n\\n\\t\\t\\t\\t\\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tvar normal = face.normal;\\n\\n\\t\\t\\t\\t\\tthis.normals.push( normal, normal, normal );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar vertexColors = face.vertexColors;\\n\\n\\t\\t\\t\\tif ( vertexColors.length === 3 ) {\\n\\n\\t\\t\\t\\t\\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tvar color = face.color;\\n\\n\\t\\t\\t\\t\\tthis.colors.push( color, color, color );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( hasFaceVertexUv === true ) {\\n\\n\\t\\t\\t\\t\\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\\n\\n\\t\\t\\t\\t\\tif ( vertexUvs !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\\n\\n\\t\\t\\t\\t\\t\\tthis.uvs.push( new Vector2(), new Vector2(), new Vector2() );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( hasFaceVertexUv2 === true ) {\\n\\n\\t\\t\\t\\t\\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\\n\\n\\t\\t\\t\\t\\tif ( vertexUvs !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\\n\\n\\t\\t\\t\\t\\t\\tthis.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// morphs\\n\\n\\t\\t\\t\\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\\n\\n\\t\\t\\t\\t\\tvar morphTarget = morphTargets[ j ].vertices;\\n\\n\\t\\t\\t\\t\\tmorphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\\n\\n\\t\\t\\t\\t\\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\\n\\n\\t\\t\\t\\t\\tmorphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// skins\\n\\n\\t\\t\\t\\tif ( hasSkinIndices ) {\\n\\n\\t\\t\\t\\t\\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( hasSkinWeights ) {\\n\\n\\t\\t\\t\\t\\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.computeGroups( geometry );\\n\\n\\t\\t\\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\\n\\t\\t\\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\\n\\t\\t\\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\\n\\t\\t\\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\\n\\t\\t\\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction arrayMax( array ) {\\n\\n\\t\\tif ( array.length === 0 ) return - Infinity;\\n\\n\\t\\tvar max = array[ 0 ];\\n\\n\\t\\tfor ( var i = 1, l = array.length; i < l; ++ i ) {\\n\\n\\t\\t\\tif ( array[ i ] > max ) max = array[ i ];\\n\\n\\t\\t}\\n\\n\\t\\treturn max;\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tvar bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id\\n\\n\\tfunction BufferGeometry() {\\n\\n\\t\\tObject.defineProperty( this, 'id', { value: bufferGeometryId += 2 } );\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\tthis.name = '';\\n\\t\\tthis.type = 'BufferGeometry';\\n\\n\\t\\tthis.index = null;\\n\\t\\tthis.attributes = {};\\n\\n\\t\\tthis.morphAttributes = {};\\n\\n\\t\\tthis.groups = [];\\n\\n\\t\\tthis.boundingBox = null;\\n\\t\\tthis.boundingSphere = null;\\n\\n\\t\\tthis.drawRange = { start: 0, count: Infinity };\\n\\n\\t}\\n\\n\\tBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\n\\n\\t\\tconstructor: BufferGeometry,\\n\\n\\t\\tisBufferGeometry: true,\\n\\n\\t\\tgetIndex: function () {\\n\\n\\t\\t\\treturn this.index;\\n\\n\\t\\t},\\n\\n\\t\\tsetIndex: function ( index ) {\\n\\n\\t\\t\\tif ( Array.isArray( index ) ) {\\n\\n\\t\\t\\t\\tthis.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.index = index;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\taddAttribute: function ( name, attribute ) {\\n\\n\\t\\t\\tif ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\\n\\n\\t\\t\\t\\tthis.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\\n\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( name === 'index' ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\\n\\t\\t\\t\\tthis.setIndex( attribute );\\n\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.attributes[ name ] = attribute;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetAttribute: function ( name ) {\\n\\n\\t\\t\\treturn this.attributes[ name ];\\n\\n\\t\\t},\\n\\n\\t\\tremoveAttribute: function ( name ) {\\n\\n\\t\\t\\tdelete this.attributes[ name ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddGroup: function ( start, count, materialIndex ) {\\n\\n\\t\\t\\tthis.groups.push( {\\n\\n\\t\\t\\t\\tstart: start,\\n\\t\\t\\t\\tcount: count,\\n\\t\\t\\t\\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\\n\\n\\t\\t\\t} );\\n\\n\\t\\t},\\n\\n\\t\\tclearGroups: function () {\\n\\n\\t\\t\\tthis.groups = [];\\n\\n\\t\\t},\\n\\n\\t\\tsetDrawRange: function ( start, count ) {\\n\\n\\t\\t\\tthis.drawRange.start = start;\\n\\t\\t\\tthis.drawRange.count = count;\\n\\n\\t\\t},\\n\\n\\t\\tapplyMatrix: function ( matrix ) {\\n\\n\\t\\t\\tvar position = this.attributes.position;\\n\\n\\t\\t\\tif ( position !== undefined ) {\\n\\n\\t\\t\\t\\tmatrix.applyToBufferAttribute( position );\\n\\t\\t\\t\\tposition.needsUpdate = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar normal = this.attributes.normal;\\n\\n\\t\\t\\tif ( normal !== undefined ) {\\n\\n\\t\\t\\t\\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\\n\\n\\t\\t\\t\\tnormalMatrix.applyToBufferAttribute( normal );\\n\\t\\t\\t\\tnormal.needsUpdate = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.boundingBox !== null ) {\\n\\n\\t\\t\\t\\tthis.computeBoundingBox();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.boundingSphere !== null ) {\\n\\n\\t\\t\\t\\tthis.computeBoundingSphere();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\trotateX: function () {\\n\\n\\t\\t\\t// rotate geometry around world x-axis\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function rotateX( angle ) {\\n\\n\\t\\t\\t\\tm1.makeRotationX( angle );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\trotateY: function () {\\n\\n\\t\\t\\t// rotate geometry around world y-axis\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function rotateY( angle ) {\\n\\n\\t\\t\\t\\tm1.makeRotationY( angle );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\trotateZ: function () {\\n\\n\\t\\t\\t// rotate geometry around world z-axis\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function rotateZ( angle ) {\\n\\n\\t\\t\\t\\tm1.makeRotationZ( angle );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttranslate: function () {\\n\\n\\t\\t\\t// translate geometry\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function translate( x, y, z ) {\\n\\n\\t\\t\\t\\tm1.makeTranslation( x, y, z );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tscale: function () {\\n\\n\\t\\t\\t// scale geometry\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function scale( x, y, z ) {\\n\\n\\t\\t\\t\\tm1.makeScale( x, y, z );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tlookAt: function () {\\n\\n\\t\\t\\tvar obj = new Object3D();\\n\\n\\t\\t\\treturn function lookAt( vector ) {\\n\\n\\t\\t\\t\\tobj.lookAt( vector );\\n\\n\\t\\t\\t\\tobj.updateMatrix();\\n\\n\\t\\t\\t\\tthis.applyMatrix( obj.matrix );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tcenter: function () {\\n\\n\\t\\t\\tthis.computeBoundingBox();\\n\\n\\t\\t\\tvar offset = this.boundingBox.getCenter().negate();\\n\\n\\t\\t\\tthis.translate( offset.x, offset.y, offset.z );\\n\\n\\t\\t\\treturn offset;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromObject: function ( object ) {\\n\\n\\t\\t\\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\\n\\n\\t\\t\\tvar geometry = object.geometry;\\n\\n\\t\\t\\tif ( object.isPoints || object.isLine ) {\\n\\n\\t\\t\\t\\tvar positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );\\n\\t\\t\\t\\tvar colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );\\n\\n\\t\\t\\t\\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\\n\\t\\t\\t\\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\\n\\n\\t\\t\\t\\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\\n\\n\\t\\t\\t\\t\\tvar lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );\\n\\n\\t\\t\\t\\t\\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( geometry.boundingSphere !== null ) {\\n\\n\\t\\t\\t\\t\\tthis.boundingSphere = geometry.boundingSphere.clone();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( geometry.boundingBox !== null ) {\\n\\n\\t\\t\\t\\t\\tthis.boundingBox = geometry.boundingBox.clone();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( object.isMesh ) {\\n\\n\\t\\t\\t\\tif ( geometry && geometry.isGeometry ) {\\n\\n\\t\\t\\t\\t\\tthis.fromGeometry( geometry );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromPoints: function ( points ) {\\n\\n\\t\\t\\tvar position = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar point = points[ i ];\\n\\t\\t\\t\\tposition.push( point.x, point.y, point.z || 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tupdateFromObject: function ( object ) {\\n\\n\\t\\t\\tvar geometry = object.geometry;\\n\\n\\t\\t\\tif ( object.isMesh ) {\\n\\n\\t\\t\\t\\tvar direct = geometry.__directGeometry;\\n\\n\\t\\t\\t\\tif ( geometry.elementsNeedUpdate === true ) {\\n\\n\\t\\t\\t\\t\\tdirect = undefined;\\n\\t\\t\\t\\t\\tgeometry.elementsNeedUpdate = false;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( direct === undefined ) {\\n\\n\\t\\t\\t\\t\\treturn this.fromGeometry( geometry );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\\n\\t\\t\\t\\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\\n\\t\\t\\t\\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\\n\\t\\t\\t\\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\\n\\t\\t\\t\\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\\n\\n\\t\\t\\t\\tgeometry.verticesNeedUpdate = false;\\n\\t\\t\\t\\tgeometry.normalsNeedUpdate = false;\\n\\t\\t\\t\\tgeometry.colorsNeedUpdate = false;\\n\\t\\t\\t\\tgeometry.uvsNeedUpdate = false;\\n\\t\\t\\t\\tgeometry.groupsNeedUpdate = false;\\n\\n\\t\\t\\t\\tgeometry = direct;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar attribute;\\n\\n\\t\\t\\tif ( geometry.verticesNeedUpdate === true ) {\\n\\n\\t\\t\\t\\tattribute = this.attributes.position;\\n\\n\\t\\t\\t\\tif ( attribute !== undefined ) {\\n\\n\\t\\t\\t\\t\\tattribute.copyVector3sArray( geometry.vertices );\\n\\t\\t\\t\\t\\tattribute.needsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgeometry.verticesNeedUpdate = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.normalsNeedUpdate === true ) {\\n\\n\\t\\t\\t\\tattribute = this.attributes.normal;\\n\\n\\t\\t\\t\\tif ( attribute !== undefined ) {\\n\\n\\t\\t\\t\\t\\tattribute.copyVector3sArray( geometry.normals );\\n\\t\\t\\t\\t\\tattribute.needsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgeometry.normalsNeedUpdate = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.colorsNeedUpdate === true ) {\\n\\n\\t\\t\\t\\tattribute = this.attributes.color;\\n\\n\\t\\t\\t\\tif ( attribute !== undefined ) {\\n\\n\\t\\t\\t\\t\\tattribute.copyColorsArray( geometry.colors );\\n\\t\\t\\t\\t\\tattribute.needsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgeometry.colorsNeedUpdate = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.uvsNeedUpdate ) {\\n\\n\\t\\t\\t\\tattribute = this.attributes.uv;\\n\\n\\t\\t\\t\\tif ( attribute !== undefined ) {\\n\\n\\t\\t\\t\\t\\tattribute.copyVector2sArray( geometry.uvs );\\n\\t\\t\\t\\t\\tattribute.needsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgeometry.uvsNeedUpdate = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.lineDistancesNeedUpdate ) {\\n\\n\\t\\t\\t\\tattribute = this.attributes.lineDistance;\\n\\n\\t\\t\\t\\tif ( attribute !== undefined ) {\\n\\n\\t\\t\\t\\t\\tattribute.copyArray( geometry.lineDistances );\\n\\t\\t\\t\\t\\tattribute.needsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgeometry.lineDistancesNeedUpdate = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.groupsNeedUpdate ) {\\n\\n\\t\\t\\t\\tgeometry.computeGroups( object.geometry );\\n\\t\\t\\t\\tthis.groups = geometry.groups;\\n\\n\\t\\t\\t\\tgeometry.groupsNeedUpdate = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tfromGeometry: function ( geometry ) {\\n\\n\\t\\t\\tgeometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );\\n\\n\\t\\t\\treturn this.fromDirectGeometry( geometry.__directGeometry );\\n\\n\\t\\t},\\n\\n\\t\\tfromDirectGeometry: function ( geometry ) {\\n\\n\\t\\t\\tvar positions = new Float32Array( geometry.vertices.length * 3 );\\n\\t\\t\\tthis.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\\n\\n\\t\\t\\tif ( geometry.normals.length > 0 ) {\\n\\n\\t\\t\\t\\tvar normals = new Float32Array( geometry.normals.length * 3 );\\n\\t\\t\\t\\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.colors.length > 0 ) {\\n\\n\\t\\t\\t\\tvar colors = new Float32Array( geometry.colors.length * 3 );\\n\\t\\t\\t\\tthis.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.uvs.length > 0 ) {\\n\\n\\t\\t\\t\\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\\n\\t\\t\\t\\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.uvs2.length > 0 ) {\\n\\n\\t\\t\\t\\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\\n\\t\\t\\t\\tthis.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.indices.length > 0 ) {\\n\\n\\t\\t\\t\\tvar TypeArray = arrayMax( geometry.indices ) > 65535 ? Uint32Array : Uint16Array;\\n\\t\\t\\t\\tvar indices = new TypeArray( geometry.indices.length * 3 );\\n\\t\\t\\t\\tthis.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// groups\\n\\n\\t\\t\\tthis.groups = geometry.groups;\\n\\n\\t\\t\\t// morphs\\n\\n\\t\\t\\tfor ( var name in geometry.morphTargets ) {\\n\\n\\t\\t\\t\\tvar array = [];\\n\\t\\t\\t\\tvar morphTargets = geometry.morphTargets[ name ];\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar morphTarget = morphTargets[ i ];\\n\\n\\t\\t\\t\\t\\tvar attribute = new Float32BufferAttribute( morphTarget.length * 3, 3 );\\n\\n\\t\\t\\t\\t\\tarray.push( attribute.copyVector3sArray( morphTarget ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.morphAttributes[ name ] = array;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// skinning\\n\\n\\t\\t\\tif ( geometry.skinIndices.length > 0 ) {\\n\\n\\t\\t\\t\\tvar skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );\\n\\t\\t\\t\\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.skinWeights.length > 0 ) {\\n\\n\\t\\t\\t\\tvar skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );\\n\\t\\t\\t\\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tif ( geometry.boundingSphere !== null ) {\\n\\n\\t\\t\\t\\tthis.boundingSphere = geometry.boundingSphere.clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.boundingBox !== null ) {\\n\\n\\t\\t\\t\\tthis.boundingBox = geometry.boundingBox.clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcomputeBoundingBox: function () {\\n\\n\\t\\t\\tif ( this.boundingBox === null ) {\\n\\n\\t\\t\\t\\tthis.boundingBox = new Box3();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar position = this.attributes.position;\\n\\n\\t\\t\\tif ( position !== undefined ) {\\n\\n\\t\\t\\t\\tthis.boundingBox.setFromBufferAttribute( position );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.boundingBox.makeEmpty();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \\\"position\\\" attribute is likely to have NaN values.', this );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tcomputeBoundingSphere: function () {\\n\\n\\t\\t\\tvar box = new Box3();\\n\\t\\t\\tvar vector = new Vector3();\\n\\n\\t\\t\\treturn function computeBoundingSphere() {\\n\\n\\t\\t\\t\\tif ( this.boundingSphere === null ) {\\n\\n\\t\\t\\t\\t\\tthis.boundingSphere = new Sphere();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar position = this.attributes.position;\\n\\n\\t\\t\\t\\tif ( position ) {\\n\\n\\t\\t\\t\\t\\tvar center = this.boundingSphere.center;\\n\\n\\t\\t\\t\\t\\tbox.setFromBufferAttribute( position );\\n\\t\\t\\t\\t\\tbox.getCenter( center );\\n\\n\\t\\t\\t\\t\\t// hoping to find a boundingSphere with a radius smaller than the\\n\\t\\t\\t\\t\\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\\n\\n\\t\\t\\t\\t\\tvar maxRadiusSq = 0;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = position.count; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvector.x = position.getX( i );\\n\\t\\t\\t\\t\\t\\tvector.y = position.getY( i );\\n\\t\\t\\t\\t\\t\\tvector.z = position.getZ( i );\\n\\t\\t\\t\\t\\t\\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\\n\\n\\t\\t\\t\\t\\tif ( isNaN( this.boundingSphere.radius ) ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \\\"position\\\" attribute is likely to have NaN values.', this );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tcomputeFaceNormals: function () {\\n\\n\\t\\t\\t// backwards compatibility\\n\\n\\t\\t},\\n\\n\\t\\tcomputeVertexNormals: function () {\\n\\n\\t\\t\\tvar index = this.index;\\n\\t\\t\\tvar attributes = this.attributes;\\n\\t\\t\\tvar groups = this.groups;\\n\\n\\t\\t\\tif ( attributes.position ) {\\n\\n\\t\\t\\t\\tvar positions = attributes.position.array;\\n\\n\\t\\t\\t\\tif ( attributes.normal === undefined ) {\\n\\n\\t\\t\\t\\t\\tthis.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// reset existing normals to zero\\n\\n\\t\\t\\t\\t\\tvar array = attributes.normal.array;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tarray[ i ] = 0;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar normals = attributes.normal.array;\\n\\n\\t\\t\\t\\tvar vA, vB, vC;\\n\\t\\t\\t\\tvar pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\\n\\t\\t\\t\\tvar cb = new Vector3(), ab = new Vector3();\\n\\n\\t\\t\\t\\t// indexed elements\\n\\n\\t\\t\\t\\tif ( index ) {\\n\\n\\t\\t\\t\\t\\tvar indices = index.array;\\n\\n\\t\\t\\t\\t\\tif ( groups.length === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.addGroup( 0, indices.length );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0, jl = groups.length; j < jl; ++ j ) {\\n\\n\\t\\t\\t\\t\\t\\tvar group = groups[ j ];\\n\\n\\t\\t\\t\\t\\t\\tvar start = group.start;\\n\\t\\t\\t\\t\\t\\tvar count = group.count;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvA = indices[ i + 0 ] * 3;\\n\\t\\t\\t\\t\\t\\t\\tvB = indices[ i + 1 ] * 3;\\n\\t\\t\\t\\t\\t\\t\\tvC = indices[ i + 2 ] * 3;\\n\\n\\t\\t\\t\\t\\t\\t\\tpA.fromArray( positions, vA );\\n\\t\\t\\t\\t\\t\\t\\tpB.fromArray( positions, vB );\\n\\t\\t\\t\\t\\t\\t\\tpC.fromArray( positions, vC );\\n\\n\\t\\t\\t\\t\\t\\t\\tcb.subVectors( pC, pB );\\n\\t\\t\\t\\t\\t\\t\\tab.subVectors( pA, pB );\\n\\t\\t\\t\\t\\t\\t\\tcb.cross( ab );\\n\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vA ] += cb.x;\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vA + 1 ] += cb.y;\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vA + 2 ] += cb.z;\\n\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vB ] += cb.x;\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vB + 1 ] += cb.y;\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vB + 2 ] += cb.z;\\n\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vC ] += cb.x;\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vC + 1 ] += cb.y;\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vC + 2 ] += cb.z;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// non-indexed elements (unconnected triangle soup)\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\\n\\n\\t\\t\\t\\t\\t\\tpA.fromArray( positions, i );\\n\\t\\t\\t\\t\\t\\tpB.fromArray( positions, i + 3 );\\n\\t\\t\\t\\t\\t\\tpC.fromArray( positions, i + 6 );\\n\\n\\t\\t\\t\\t\\t\\tcb.subVectors( pC, pB );\\n\\t\\t\\t\\t\\t\\tab.subVectors( pA, pB );\\n\\t\\t\\t\\t\\t\\tcb.cross( ab );\\n\\n\\t\\t\\t\\t\\t\\tnormals[ i ] = cb.x;\\n\\t\\t\\t\\t\\t\\tnormals[ i + 1 ] = cb.y;\\n\\t\\t\\t\\t\\t\\tnormals[ i + 2 ] = cb.z;\\n\\n\\t\\t\\t\\t\\t\\tnormals[ i + 3 ] = cb.x;\\n\\t\\t\\t\\t\\t\\tnormals[ i + 4 ] = cb.y;\\n\\t\\t\\t\\t\\t\\tnormals[ i + 5 ] = cb.z;\\n\\n\\t\\t\\t\\t\\t\\tnormals[ i + 6 ] = cb.x;\\n\\t\\t\\t\\t\\t\\tnormals[ i + 7 ] = cb.y;\\n\\t\\t\\t\\t\\t\\tnormals[ i + 8 ] = cb.z;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.normalizeNormals();\\n\\n\\t\\t\\t\\tattributes.normal.needsUpdate = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tmerge: function ( geometry, offset ) {\\n\\n\\t\\t\\tif ( ! ( geometry && geometry.isBufferGeometry ) ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tvar attributes = this.attributes;\\n\\n\\t\\t\\tfor ( var key in attributes ) {\\n\\n\\t\\t\\t\\tif ( geometry.attributes[ key ] === undefined ) continue;\\n\\n\\t\\t\\t\\tvar attribute1 = attributes[ key ];\\n\\t\\t\\t\\tvar attributeArray1 = attribute1.array;\\n\\n\\t\\t\\t\\tvar attribute2 = geometry.attributes[ key ];\\n\\t\\t\\t\\tvar attributeArray2 = attribute2.array;\\n\\n\\t\\t\\t\\tvar attributeSize = attribute2.itemSize;\\n\\n\\t\\t\\t\\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\\n\\n\\t\\t\\t\\t\\tattributeArray1[ j ] = attributeArray2[ i ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tnormalizeNormals: function () {\\n\\n\\t\\t\\tvar vector = new Vector3();\\n\\n\\t\\t\\treturn function normalizeNormals() {\\n\\n\\t\\t\\t\\tvar normals = this.attributes.normal;\\n\\n\\t\\t\\t\\tfor ( var i = 0, il = normals.count; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvector.x = normals.getX( i );\\n\\t\\t\\t\\t\\tvector.y = normals.getY( i );\\n\\t\\t\\t\\t\\tvector.z = normals.getZ( i );\\n\\n\\t\\t\\t\\t\\tvector.normalize();\\n\\n\\t\\t\\t\\t\\tnormals.setXYZ( i, vector.x, vector.y, vector.z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttoNonIndexed: function () {\\n\\n\\t\\t\\tif ( this.index === null ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar geometry2 = new BufferGeometry();\\n\\n\\t\\t\\tvar indices = this.index.array;\\n\\t\\t\\tvar attributes = this.attributes;\\n\\n\\t\\t\\tfor ( var name in attributes ) {\\n\\n\\t\\t\\t\\tvar attribute = attributes[ name ];\\n\\n\\t\\t\\t\\tvar array = attribute.array;\\n\\t\\t\\t\\tvar itemSize = attribute.itemSize;\\n\\n\\t\\t\\t\\tvar array2 = new array.constructor( indices.length * itemSize );\\n\\n\\t\\t\\t\\tvar index = 0, index2 = 0;\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tindex = indices[ i ] * itemSize;\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0; j < itemSize; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tarray2[ index2 ++ ] = array[ index ++ ];\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgeometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn geometry2;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function () {\\n\\n\\t\\t\\tvar data = {\\n\\t\\t\\t\\tmetadata: {\\n\\t\\t\\t\\t\\tversion: 4.5,\\n\\t\\t\\t\\t\\ttype: 'BufferGeometry',\\n\\t\\t\\t\\t\\tgenerator: 'BufferGeometry.toJSON'\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\t\\t// standard BufferGeometry serialization\\n\\n\\t\\t\\tdata.uuid = this.uuid;\\n\\t\\t\\tdata.type = this.type;\\n\\t\\t\\tif ( this.name !== '' ) data.name = this.name;\\n\\n\\t\\t\\tif ( this.parameters !== undefined ) {\\n\\n\\t\\t\\t\\tvar parameters = this.parameters;\\n\\n\\t\\t\\t\\tfor ( var key in parameters ) {\\n\\n\\t\\t\\t\\t\\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn data;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tdata.data = { attributes: {} };\\n\\n\\t\\t\\tvar index = this.index;\\n\\n\\t\\t\\tif ( index !== null ) {\\n\\n\\t\\t\\t\\tvar array = Array.prototype.slice.call( index.array );\\n\\n\\t\\t\\t\\tdata.data.index = {\\n\\t\\t\\t\\t\\ttype: index.array.constructor.name,\\n\\t\\t\\t\\t\\tarray: array\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar attributes = this.attributes;\\n\\n\\t\\t\\tfor ( var key in attributes ) {\\n\\n\\t\\t\\t\\tvar attribute = attributes[ key ];\\n\\n\\t\\t\\t\\tvar array = Array.prototype.slice.call( attribute.array );\\n\\n\\t\\t\\t\\tdata.data.attributes[ key ] = {\\n\\t\\t\\t\\t\\titemSize: attribute.itemSize,\\n\\t\\t\\t\\t\\ttype: attribute.array.constructor.name,\\n\\t\\t\\t\\t\\tarray: array,\\n\\t\\t\\t\\t\\tnormalized: attribute.normalized\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar groups = this.groups;\\n\\n\\t\\t\\tif ( groups.length > 0 ) {\\n\\n\\t\\t\\t\\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar boundingSphere = this.boundingSphere;\\n\\n\\t\\t\\tif ( boundingSphere !== null ) {\\n\\n\\t\\t\\t\\tdata.data.boundingSphere = {\\n\\t\\t\\t\\t\\tcenter: boundingSphere.center.toArray(),\\n\\t\\t\\t\\t\\tradius: boundingSphere.radius\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\t/*\\n\\t\\t\\t // Handle primitives\\n\\n\\t\\t\\t var parameters = this.parameters;\\n\\n\\t\\t\\t if ( parameters !== undefined ) {\\n\\n\\t\\t\\t var values = [];\\n\\n\\t\\t\\t for ( var key in parameters ) {\\n\\n\\t\\t\\t values.push( parameters[ key ] );\\n\\n\\t\\t\\t }\\n\\n\\t\\t\\t var geometry = Object.create( this.constructor.prototype );\\n\\t\\t\\t this.constructor.apply( geometry, values );\\n\\t\\t\\t return geometry;\\n\\n\\t\\t\\t }\\n\\n\\t\\t\\t return new this.constructor().copy( this );\\n\\t\\t\\t */\\n\\n\\t\\t\\treturn new BufferGeometry().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tvar name, i, l;\\n\\n\\t\\t\\t// reset\\n\\n\\t\\t\\tthis.index = null;\\n\\t\\t\\tthis.attributes = {};\\n\\t\\t\\tthis.morphAttributes = {};\\n\\t\\t\\tthis.groups = [];\\n\\t\\t\\tthis.boundingBox = null;\\n\\t\\t\\tthis.boundingSphere = null;\\n\\n\\t\\t\\t// name\\n\\n\\t\\t\\tthis.name = source.name;\\n\\n\\t\\t\\t// index\\n\\n\\t\\t\\tvar index = source.index;\\n\\n\\t\\t\\tif ( index !== null ) {\\n\\n\\t\\t\\t\\tthis.setIndex( index.clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// attributes\\n\\n\\t\\t\\tvar attributes = source.attributes;\\n\\n\\t\\t\\tfor ( name in attributes ) {\\n\\n\\t\\t\\t\\tvar attribute = attributes[ name ];\\n\\t\\t\\t\\tthis.addAttribute( name, attribute.clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// morph attributes\\n\\n\\t\\t\\tvar morphAttributes = source.morphAttributes;\\n\\n\\t\\t\\tfor ( name in morphAttributes ) {\\n\\n\\t\\t\\t\\tvar array = [];\\n\\t\\t\\t\\tvar morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\\n\\n\\t\\t\\t\\tfor ( i = 0, l = morphAttribute.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tarray.push( morphAttribute[ i ].clone() );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.morphAttributes[ name ] = array;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// groups\\n\\n\\t\\t\\tvar groups = source.groups;\\n\\n\\t\\t\\tfor ( i = 0, l = groups.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar group = groups[ i ];\\n\\t\\t\\t\\tthis.addGroup( group.start, group.count, group.materialIndex );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// bounding box\\n\\n\\t\\t\\tvar boundingBox = source.boundingBox;\\n\\n\\t\\t\\tif ( boundingBox !== null ) {\\n\\n\\t\\t\\t\\tthis.boundingBox = boundingBox.clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// bounding sphere\\n\\n\\t\\t\\tvar boundingSphere = source.boundingSphere;\\n\\n\\t\\t\\tif ( boundingSphere !== null ) {\\n\\n\\t\\t\\t\\tthis.boundingSphere = boundingSphere.clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// draw range\\n\\n\\t\\t\\tthis.drawRange.start = source.drawRange.start;\\n\\t\\t\\tthis.drawRange.count = source.drawRange.count;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdispose: function () {\\n\\n\\t\\t\\tthis.dispatchEvent( { type: 'dispose' } );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// BoxGeometry\\n\\n\\tfunction BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'BoxGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\twidth: width,\\n\\t\\t\\theight: height,\\n\\t\\t\\tdepth: depth,\\n\\t\\t\\twidthSegments: widthSegments,\\n\\t\\t\\theightSegments: heightSegments,\\n\\t\\t\\tdepthSegments: depthSegments\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tBoxGeometry.prototype = Object.create( Geometry.prototype );\\n\\tBoxGeometry.prototype.constructor = BoxGeometry;\\n\\n\\t// BoxBufferGeometry\\n\\n\\tfunction BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'BoxBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\twidth: width,\\n\\t\\t\\theight: height,\\n\\t\\t\\tdepth: depth,\\n\\t\\t\\twidthSegments: widthSegments,\\n\\t\\t\\theightSegments: heightSegments,\\n\\t\\t\\tdepthSegments: depthSegments\\n\\t\\t};\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\twidth = width || 1;\\n\\t\\theight = height || 1;\\n\\t\\tdepth = depth || 1;\\n\\n\\t\\t// segments\\n\\n\\t\\twidthSegments = Math.floor( widthSegments ) || 1;\\n\\t\\theightSegments = Math.floor( heightSegments ) || 1;\\n\\t\\tdepthSegments = Math.floor( depthSegments ) || 1;\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar numberOfVertices = 0;\\n\\t\\tvar groupStart = 0;\\n\\n\\t\\t// build each side of the box geometry\\n\\n\\t\\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px\\n\\t\\tbuildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx\\n\\t\\tbuildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py\\n\\t\\tbuildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny\\n\\t\\tbuildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz\\n\\t\\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t\\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\\n\\n\\t\\t\\tvar segmentWidth = width / gridX;\\n\\t\\t\\tvar segmentHeight = height / gridY;\\n\\n\\t\\t\\tvar widthHalf = width / 2;\\n\\t\\t\\tvar heightHalf = height / 2;\\n\\t\\t\\tvar depthHalf = depth / 2;\\n\\n\\t\\t\\tvar gridX1 = gridX + 1;\\n\\t\\t\\tvar gridY1 = gridY + 1;\\n\\n\\t\\t\\tvar vertexCounter = 0;\\n\\t\\t\\tvar groupCount = 0;\\n\\n\\t\\t\\tvar ix, iy;\\n\\n\\t\\t\\tvar vector = new Vector3();\\n\\n\\t\\t\\t// generate vertices, normals and uvs\\n\\n\\t\\t\\tfor ( iy = 0; iy < gridY1; iy ++ ) {\\n\\n\\t\\t\\t\\tvar y = iy * segmentHeight - heightHalf;\\n\\n\\t\\t\\t\\tfor ( ix = 0; ix < gridX1; ix ++ ) {\\n\\n\\t\\t\\t\\t\\tvar x = ix * segmentWidth - widthHalf;\\n\\n\\t\\t\\t\\t\\t// set values to correct vector component\\n\\n\\t\\t\\t\\t\\tvector[ u ] = x * udir;\\n\\t\\t\\t\\t\\tvector[ v ] = y * vdir;\\n\\t\\t\\t\\t\\tvector[ w ] = depthHalf;\\n\\n\\t\\t\\t\\t\\t// now apply vector to vertex buffer\\n\\n\\t\\t\\t\\t\\tvertices.push( vector.x, vector.y, vector.z );\\n\\n\\t\\t\\t\\t\\t// set values to correct vector component\\n\\n\\t\\t\\t\\t\\tvector[ u ] = 0;\\n\\t\\t\\t\\t\\tvector[ v ] = 0;\\n\\t\\t\\t\\t\\tvector[ w ] = depth > 0 ? 1 : - 1;\\n\\n\\t\\t\\t\\t\\t// now apply vector to normal buffer\\n\\n\\t\\t\\t\\t\\tnormals.push( vector.x, vector.y, vector.z );\\n\\n\\t\\t\\t\\t\\t// uvs\\n\\n\\t\\t\\t\\t\\tuvs.push( ix / gridX );\\n\\t\\t\\t\\t\\tuvs.push( 1 - ( iy / gridY ) );\\n\\n\\t\\t\\t\\t\\t// counters\\n\\n\\t\\t\\t\\t\\tvertexCounter += 1;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// indices\\n\\n\\t\\t\\t// 1. you need three indices to draw a single face\\n\\t\\t\\t// 2. a single segment consists of two faces\\n\\t\\t\\t// 3. so we need to generate six (2*3) indices per segment\\n\\n\\t\\t\\tfor ( iy = 0; iy < gridY; iy ++ ) {\\n\\n\\t\\t\\t\\tfor ( ix = 0; ix < gridX; ix ++ ) {\\n\\n\\t\\t\\t\\t\\tvar a = numberOfVertices + ix + gridX1 * iy;\\n\\t\\t\\t\\t\\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\\n\\t\\t\\t\\t\\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\\n\\t\\t\\t\\t\\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\\n\\n\\t\\t\\t\\t\\t// faces\\n\\n\\t\\t\\t\\t\\tindices.push( a, b, d );\\n\\t\\t\\t\\t\\tindices.push( b, c, d );\\n\\n\\t\\t\\t\\t\\t// increase counter\\n\\n\\t\\t\\t\\t\\tgroupCount += 6;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// add a group to the geometry. this will ensure multi material support\\n\\n\\t\\t\\tscope.addGroup( groupStart, groupCount, materialIndex );\\n\\n\\t\\t\\t// calculate new start value for groups\\n\\n\\t\\t\\tgroupStart += groupCount;\\n\\n\\t\\t\\t// update total number of vertices\\n\\n\\t\\t\\tnumberOfVertices += vertexCounter;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tBoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tBoxBufferGeometry.prototype.constructor = BoxBufferGeometry;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// PlaneGeometry\\n\\n\\tfunction PlaneGeometry( width, height, widthSegments, heightSegments ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'PlaneGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\twidth: width,\\n\\t\\t\\theight: height,\\n\\t\\t\\twidthSegments: widthSegments,\\n\\t\\t\\theightSegments: heightSegments\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tPlaneGeometry.prototype = Object.create( Geometry.prototype );\\n\\tPlaneGeometry.prototype.constructor = PlaneGeometry;\\n\\n\\t// PlaneBufferGeometry\\n\\n\\tfunction PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'PlaneBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\twidth: width,\\n\\t\\t\\theight: height,\\n\\t\\t\\twidthSegments: widthSegments,\\n\\t\\t\\theightSegments: heightSegments\\n\\t\\t};\\n\\n\\t\\twidth = width || 1;\\n\\t\\theight = height || 1;\\n\\n\\t\\tvar width_half = width / 2;\\n\\t\\tvar height_half = height / 2;\\n\\n\\t\\tvar gridX = Math.floor( widthSegments ) || 1;\\n\\t\\tvar gridY = Math.floor( heightSegments ) || 1;\\n\\n\\t\\tvar gridX1 = gridX + 1;\\n\\t\\tvar gridY1 = gridY + 1;\\n\\n\\t\\tvar segment_width = width / gridX;\\n\\t\\tvar segment_height = height / gridY;\\n\\n\\t\\tvar ix, iy;\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// generate vertices, normals and uvs\\n\\n\\t\\tfor ( iy = 0; iy < gridY1; iy ++ ) {\\n\\n\\t\\t\\tvar y = iy * segment_height - height_half;\\n\\n\\t\\t\\tfor ( ix = 0; ix < gridX1; ix ++ ) {\\n\\n\\t\\t\\t\\tvar x = ix * segment_width - width_half;\\n\\n\\t\\t\\t\\tvertices.push( x, - y, 0 );\\n\\n\\t\\t\\t\\tnormals.push( 0, 0, 1 );\\n\\n\\t\\t\\t\\tuvs.push( ix / gridX );\\n\\t\\t\\t\\tuvs.push( 1 - ( iy / gridY ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// indices\\n\\n\\t\\tfor ( iy = 0; iy < gridY; iy ++ ) {\\n\\n\\t\\t\\tfor ( ix = 0; ix < gridX; ix ++ ) {\\n\\n\\t\\t\\t\\tvar a = ix + gridX1 * iy;\\n\\t\\t\\t\\tvar b = ix + gridX1 * ( iy + 1 );\\n\\t\\t\\t\\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\\n\\t\\t\\t\\tvar d = ( ix + 1 ) + gridX1 * iy;\\n\\n\\t\\t\\t\\t// faces\\n\\n\\t\\t\\t\\tindices.push( a, b, d );\\n\\t\\t\\t\\tindices.push( b, c, d );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t}\\n\\n\\tPlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tPlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t *\\n\\t * parameters = {\\n\\t *  color: <hex>,\\n\\t *  opacity: <float>,\\n\\t *  map: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  lightMap: new THREE.Texture( <Image> ),\\n\\t *  lightMapIntensity: <float>\\n\\t *\\n\\t *  aoMap: new THREE.Texture( <Image> ),\\n\\t *  aoMapIntensity: <float>\\n\\t *\\n\\t *  specularMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  alphaMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\\n\\t *  combine: THREE.Multiply,\\n\\t *  reflectivity: <float>,\\n\\t *  refractionRatio: <float>,\\n\\t *\\n\\t *  depthTest: <bool>,\\n\\t *  depthWrite: <bool>,\\n\\t *\\n\\t *  wireframe: <boolean>,\\n\\t *  wireframeLinewidth: <float>,\\n\\t *\\n\\t *  skinning: <bool>,\\n\\t *  morphTargets: <bool>\\n\\t * }\\n\\t */\\n\\n\\tfunction MeshBasicMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'MeshBasicMaterial';\\n\\n\\t\\tthis.color = new Color( 0xffffff ); // emissive\\n\\n\\t\\tthis.map = null;\\n\\n\\t\\tthis.lightMap = null;\\n\\t\\tthis.lightMapIntensity = 1.0;\\n\\n\\t\\tthis.aoMap = null;\\n\\t\\tthis.aoMapIntensity = 1.0;\\n\\n\\t\\tthis.specularMap = null;\\n\\n\\t\\tthis.alphaMap = null;\\n\\n\\t\\tthis.envMap = null;\\n\\t\\tthis.combine = MultiplyOperation;\\n\\t\\tthis.reflectivity = 1;\\n\\t\\tthis.refractionRatio = 0.98;\\n\\n\\t\\tthis.wireframe = false;\\n\\t\\tthis.wireframeLinewidth = 1;\\n\\t\\tthis.wireframeLinecap = 'round';\\n\\t\\tthis.wireframeLinejoin = 'round';\\n\\n\\t\\tthis.skinning = false;\\n\\t\\tthis.morphTargets = false;\\n\\n\\t\\tthis.lights = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tMeshBasicMaterial.prototype = Object.create( Material.prototype );\\n\\tMeshBasicMaterial.prototype.constructor = MeshBasicMaterial;\\n\\n\\tMeshBasicMaterial.prototype.isMeshBasicMaterial = true;\\n\\n\\tMeshBasicMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.color.copy( source.color );\\n\\n\\t\\tthis.map = source.map;\\n\\n\\t\\tthis.lightMap = source.lightMap;\\n\\t\\tthis.lightMapIntensity = source.lightMapIntensity;\\n\\n\\t\\tthis.aoMap = source.aoMap;\\n\\t\\tthis.aoMapIntensity = source.aoMapIntensity;\\n\\n\\t\\tthis.specularMap = source.specularMap;\\n\\n\\t\\tthis.alphaMap = source.alphaMap;\\n\\n\\t\\tthis.envMap = source.envMap;\\n\\t\\tthis.combine = source.combine;\\n\\t\\tthis.reflectivity = source.reflectivity;\\n\\t\\tthis.refractionRatio = source.refractionRatio;\\n\\n\\t\\tthis.wireframe = source.wireframe;\\n\\t\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\n\\t\\tthis.wireframeLinecap = source.wireframeLinecap;\\n\\t\\tthis.wireframeLinejoin = source.wireframeLinejoin;\\n\\n\\t\\tthis.skinning = source.skinning;\\n\\t\\tthis.morphTargets = source.morphTargets;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t *\\n\\t * parameters = {\\n\\t *  defines: { \\\"label\\\" : \\\"value\\\" },\\n\\t *  uniforms: { \\\"parameter1\\\": { value: 1.0 }, \\\"parameter2\\\": { value2: 2 } },\\n\\t *\\n\\t *  fragmentShader: <string>,\\n\\t *  vertexShader: <string>,\\n\\t *\\n\\t *  wireframe: <boolean>,\\n\\t *  wireframeLinewidth: <float>,\\n\\t *\\n\\t *  lights: <bool>,\\n\\t *\\n\\t *  skinning: <bool>,\\n\\t *  morphTargets: <bool>,\\n\\t *  morphNormals: <bool>\\n\\t * }\\n\\t */\\n\\n\\tfunction ShaderMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'ShaderMaterial';\\n\\n\\t\\tthis.defines = {};\\n\\t\\tthis.uniforms = {};\\n\\n\\t\\tthis.vertexShader = 'void main() {\\\\n\\\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\\n}';\\n\\t\\tthis.fragmentShader = 'void main() {\\\\n\\\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\\\n}';\\n\\n\\t\\tthis.linewidth = 1;\\n\\n\\t\\tthis.wireframe = false;\\n\\t\\tthis.wireframeLinewidth = 1;\\n\\n\\t\\tthis.fog = false; // set to use scene fog\\n\\t\\tthis.lights = false; // set to use scene lights\\n\\t\\tthis.clipping = false; // set to use user-defined clipping planes\\n\\n\\t\\tthis.skinning = false; // set to use skinning attribute streams\\n\\t\\tthis.morphTargets = false; // set to use morph targets\\n\\t\\tthis.morphNormals = false; // set to use morph normals\\n\\n\\t\\tthis.extensions = {\\n\\t\\t\\tderivatives: false, // set to use derivatives\\n\\t\\t\\tfragDepth: false, // set to use fragment depth values\\n\\t\\t\\tdrawBuffers: false, // set to use draw buffers\\n\\t\\t\\tshaderTextureLOD: false // set to use shader texture LOD\\n\\t\\t};\\n\\n\\t\\t// When rendered geometry doesn't include these attributes but the material does,\\n\\t\\t// use these default values in WebGL. This avoids errors when buffer data is missing.\\n\\t\\tthis.defaultAttributeValues = {\\n\\t\\t\\t'color': [ 1, 1, 1 ],\\n\\t\\t\\t'uv': [ 0, 0 ],\\n\\t\\t\\t'uv2': [ 0, 0 ]\\n\\t\\t};\\n\\n\\t\\tthis.index0AttributeName = undefined;\\n\\n\\t\\tif ( parameters !== undefined ) {\\n\\n\\t\\t\\tif ( parameters.attributes !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.setValues( parameters );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tShaderMaterial.prototype = Object.create( Material.prototype );\\n\\tShaderMaterial.prototype.constructor = ShaderMaterial;\\n\\n\\tShaderMaterial.prototype.isShaderMaterial = true;\\n\\n\\tShaderMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.fragmentShader = source.fragmentShader;\\n\\t\\tthis.vertexShader = source.vertexShader;\\n\\n\\t\\tthis.uniforms = UniformsUtils.clone( source.uniforms );\\n\\n\\t\\tthis.defines = source.defines;\\n\\n\\t\\tthis.wireframe = source.wireframe;\\n\\t\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\n\\n\\t\\tthis.lights = source.lights;\\n\\t\\tthis.clipping = source.clipping;\\n\\n\\t\\tthis.skinning = source.skinning;\\n\\n\\t\\tthis.morphTargets = source.morphTargets;\\n\\t\\tthis.morphNormals = source.morphNormals;\\n\\n\\t\\tthis.extensions = source.extensions;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tShaderMaterial.prototype.toJSON = function ( meta ) {\\n\\n\\t\\tvar data = Material.prototype.toJSON.call( this, meta );\\n\\n\\t\\tdata.uniforms = this.uniforms;\\n\\t\\tdata.vertexShader = this.vertexShader;\\n\\t\\tdata.fragmentShader = this.fragmentShader;\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author bhouston / http://clara.io\\n\\t */\\n\\n\\tfunction Ray( origin, direction ) {\\n\\n\\t\\tthis.origin = ( origin !== undefined ) ? origin : new Vector3();\\n\\t\\tthis.direction = ( direction !== undefined ) ? direction : new Vector3();\\n\\n\\t}\\n\\n\\tObject.assign( Ray.prototype, {\\n\\n\\t\\tset: function ( origin, direction ) {\\n\\n\\t\\t\\tthis.origin.copy( origin );\\n\\t\\t\\tthis.direction.copy( direction );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( ray ) {\\n\\n\\t\\t\\tthis.origin.copy( ray.origin );\\n\\t\\t\\tthis.direction.copy( ray.direction );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tat: function ( t, optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\\n\\n\\t\\t},\\n\\n\\t\\tlookAt: function ( v ) {\\n\\n\\t\\t\\tthis.direction.copy( v ).sub( this.origin ).normalize();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\trecast: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function recast( t ) {\\n\\n\\t\\t\\t\\tthis.origin.copy( this.at( t, v1 ) );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tclosestPointToPoint: function ( point, optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\t\\t\\tresult.subVectors( point, this.origin );\\n\\t\\t\\tvar directionDistance = result.dot( this.direction );\\n\\n\\t\\t\\tif ( directionDistance < 0 ) {\\n\\n\\t\\t\\t\\treturn result.copy( this.origin );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\\n\\n\\t\\t},\\n\\n\\t\\tdistanceToPoint: function ( point ) {\\n\\n\\t\\t\\treturn Math.sqrt( this.distanceSqToPoint( point ) );\\n\\n\\t\\t},\\n\\n\\t\\tdistanceSqToPoint: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function distanceSqToPoint( point ) {\\n\\n\\t\\t\\t\\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\\n\\n\\t\\t\\t\\t// point behind the ray\\n\\n\\t\\t\\t\\tif ( directionDistance < 0 ) {\\n\\n\\t\\t\\t\\t\\treturn this.origin.distanceToSquared( point );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\\n\\n\\t\\t\\t\\treturn v1.distanceToSquared( point );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tdistanceSqToSegment: function () {\\n\\n\\t\\t\\tvar segCenter = new Vector3();\\n\\t\\t\\tvar segDir = new Vector3();\\n\\t\\t\\tvar diff = new Vector3();\\n\\n\\t\\t\\treturn function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\\n\\n\\t\\t\\t\\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\\n\\t\\t\\t\\t// It returns the min distance between the ray and the segment\\n\\t\\t\\t\\t// defined by v0 and v1\\n\\t\\t\\t\\t// It can also set two optional targets :\\n\\t\\t\\t\\t// - The closest point on the ray\\n\\t\\t\\t\\t// - The closest point on the segment\\n\\n\\t\\t\\t\\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\\n\\t\\t\\t\\tsegDir.copy( v1 ).sub( v0 ).normalize();\\n\\t\\t\\t\\tdiff.copy( this.origin ).sub( segCenter );\\n\\n\\t\\t\\t\\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\\n\\t\\t\\t\\tvar a01 = - this.direction.dot( segDir );\\n\\t\\t\\t\\tvar b0 = diff.dot( this.direction );\\n\\t\\t\\t\\tvar b1 = - diff.dot( segDir );\\n\\t\\t\\t\\tvar c = diff.lengthSq();\\n\\t\\t\\t\\tvar det = Math.abs( 1 - a01 * a01 );\\n\\t\\t\\t\\tvar s0, s1, sqrDist, extDet;\\n\\n\\t\\t\\t\\tif ( det > 0 ) {\\n\\n\\t\\t\\t\\t\\t// The ray and segment are not parallel.\\n\\n\\t\\t\\t\\t\\ts0 = a01 * b1 - b0;\\n\\t\\t\\t\\t\\ts1 = a01 * b0 - b1;\\n\\t\\t\\t\\t\\textDet = segExtent * det;\\n\\n\\t\\t\\t\\t\\tif ( s0 >= 0 ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( s1 >= - extDet ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( s1 <= extDet ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// region 0\\n\\t\\t\\t\\t\\t\\t\\t\\t// Minimum at interior points of ray and segment.\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar invDet = 1 / det;\\n\\t\\t\\t\\t\\t\\t\\t\\ts0 *= invDet;\\n\\t\\t\\t\\t\\t\\t\\t\\ts1 *= invDet;\\n\\t\\t\\t\\t\\t\\t\\t\\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// region 1\\n\\n\\t\\t\\t\\t\\t\\t\\t\\ts1 = segExtent;\\n\\t\\t\\t\\t\\t\\t\\t\\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\\n\\t\\t\\t\\t\\t\\t\\t\\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t// region 5\\n\\n\\t\\t\\t\\t\\t\\t\\ts1 = - segExtent;\\n\\t\\t\\t\\t\\t\\t\\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\\n\\t\\t\\t\\t\\t\\t\\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tif ( s1 <= - extDet ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// region 4\\n\\n\\t\\t\\t\\t\\t\\t\\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\\n\\t\\t\\t\\t\\t\\t\\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\\n\\t\\t\\t\\t\\t\\t\\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\\n\\n\\t\\t\\t\\t\\t\\t} else if ( s1 <= extDet ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// region 3\\n\\n\\t\\t\\t\\t\\t\\t\\ts0 = 0;\\n\\t\\t\\t\\t\\t\\t\\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\\n\\t\\t\\t\\t\\t\\t\\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t// region 2\\n\\n\\t\\t\\t\\t\\t\\t\\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\\n\\t\\t\\t\\t\\t\\t\\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\\n\\t\\t\\t\\t\\t\\t\\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// Ray and segment are parallel.\\n\\n\\t\\t\\t\\t\\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\\n\\t\\t\\t\\t\\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\\n\\t\\t\\t\\t\\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( optionalPointOnRay ) {\\n\\n\\t\\t\\t\\t\\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( optionalPointOnSegment ) {\\n\\n\\t\\t\\t\\t\\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn sqrDist;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tintersectSphere: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function intersectSphere( sphere, optionalTarget ) {\\n\\n\\t\\t\\t\\tv1.subVectors( sphere.center, this.origin );\\n\\t\\t\\t\\tvar tca = v1.dot( this.direction );\\n\\t\\t\\t\\tvar d2 = v1.dot( v1 ) - tca * tca;\\n\\t\\t\\t\\tvar radius2 = sphere.radius * sphere.radius;\\n\\n\\t\\t\\t\\tif ( d2 > radius2 ) return null;\\n\\n\\t\\t\\t\\tvar thc = Math.sqrt( radius2 - d2 );\\n\\n\\t\\t\\t\\t// t0 = first intersect point - entrance on front of sphere\\n\\t\\t\\t\\tvar t0 = tca - thc;\\n\\n\\t\\t\\t\\t// t1 = second intersect point - exit point on back of sphere\\n\\t\\t\\t\\tvar t1 = tca + thc;\\n\\n\\t\\t\\t\\t// test to see if both t0 and t1 are behind the ray - if so, return null\\n\\t\\t\\t\\tif ( t0 < 0 && t1 < 0 ) return null;\\n\\n\\t\\t\\t\\t// test to see if t0 is behind the ray:\\n\\t\\t\\t\\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\\n\\t\\t\\t\\t// in order to always return an intersect point that is in front of the ray.\\n\\t\\t\\t\\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\\n\\n\\t\\t\\t\\t// else t0 is in front of the ray, so return the first collision point scaled by t0\\n\\t\\t\\t\\treturn this.at( t0, optionalTarget );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tintersectsSphere: function ( sphere ) {\\n\\n\\t\\t\\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\\n\\n\\t\\t},\\n\\n\\t\\tdistanceToPlane: function ( plane ) {\\n\\n\\t\\t\\tvar denominator = plane.normal.dot( this.direction );\\n\\n\\t\\t\\tif ( denominator === 0 ) {\\n\\n\\t\\t\\t\\t// line is coplanar, return origin\\n\\t\\t\\t\\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\\n\\n\\t\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Null is preferable to undefined since undefined means.... it is undefined\\n\\n\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\\n\\n\\t\\t\\t// Return if the ray never intersects the plane\\n\\n\\t\\t\\treturn t >= 0 ? t : null;\\n\\n\\t\\t},\\n\\n\\t\\tintersectPlane: function ( plane, optionalTarget ) {\\n\\n\\t\\t\\tvar t = this.distanceToPlane( plane );\\n\\n\\t\\t\\tif ( t === null ) {\\n\\n\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this.at( t, optionalTarget );\\n\\n\\t\\t},\\n\\n\\t\\tintersectsPlane: function ( plane ) {\\n\\n\\t\\t\\t// check if the ray lies on the plane first\\n\\n\\t\\t\\tvar distToPoint = plane.distanceToPoint( this.origin );\\n\\n\\t\\t\\tif ( distToPoint === 0 ) {\\n\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar denominator = plane.normal.dot( this.direction );\\n\\n\\t\\t\\tif ( denominator * distToPoint < 0 ) {\\n\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// ray origin is behind the plane (and is pointing behind it)\\n\\n\\t\\t\\treturn false;\\n\\n\\t\\t},\\n\\n\\t\\tintersectBox: function ( box, optionalTarget ) {\\n\\n\\t\\t\\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\\n\\n\\t\\t\\tvar invdirx = 1 / this.direction.x,\\n\\t\\t\\t\\tinvdiry = 1 / this.direction.y,\\n\\t\\t\\t\\tinvdirz = 1 / this.direction.z;\\n\\n\\t\\t\\tvar origin = this.origin;\\n\\n\\t\\t\\tif ( invdirx >= 0 ) {\\n\\n\\t\\t\\t\\ttmin = ( box.min.x - origin.x ) * invdirx;\\n\\t\\t\\t\\ttmax = ( box.max.x - origin.x ) * invdirx;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\ttmin = ( box.max.x - origin.x ) * invdirx;\\n\\t\\t\\t\\ttmax = ( box.min.x - origin.x ) * invdirx;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( invdiry >= 0 ) {\\n\\n\\t\\t\\t\\ttymin = ( box.min.y - origin.y ) * invdiry;\\n\\t\\t\\t\\ttymax = ( box.max.y - origin.y ) * invdiry;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\ttymin = ( box.max.y - origin.y ) * invdiry;\\n\\t\\t\\t\\ttymax = ( box.min.y - origin.y ) * invdiry;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\\n\\n\\t\\t\\t// These lines also handle the case where tmin or tmax is NaN\\n\\t\\t\\t// (result of 0 * Infinity). x !== x returns true if x is NaN\\n\\n\\t\\t\\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\\n\\n\\t\\t\\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\\n\\n\\t\\t\\tif ( invdirz >= 0 ) {\\n\\n\\t\\t\\t\\ttzmin = ( box.min.z - origin.z ) * invdirz;\\n\\t\\t\\t\\ttzmax = ( box.max.z - origin.z ) * invdirz;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\ttzmin = ( box.max.z - origin.z ) * invdirz;\\n\\t\\t\\t\\ttzmax = ( box.min.z - origin.z ) * invdirz;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\\n\\n\\t\\t\\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\\n\\n\\t\\t\\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\\n\\n\\t\\t\\t//return point closest to the ray (positive side)\\n\\n\\t\\t\\tif ( tmax < 0 ) return null;\\n\\n\\t\\t\\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\\n\\n\\t\\t},\\n\\n\\t\\tintersectsBox: ( function () {\\n\\n\\t\\t\\tvar v = new Vector3();\\n\\n\\t\\t\\treturn function intersectsBox( box ) {\\n\\n\\t\\t\\t\\treturn this.intersectBox( box, v ) !== null;\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )(),\\n\\n\\t\\tintersectTriangle: function () {\\n\\n\\t\\t\\t// Compute the offset origin, edges, and normal.\\n\\t\\t\\tvar diff = new Vector3();\\n\\t\\t\\tvar edge1 = new Vector3();\\n\\t\\t\\tvar edge2 = new Vector3();\\n\\t\\t\\tvar normal = new Vector3();\\n\\n\\t\\t\\treturn function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {\\n\\n\\t\\t\\t\\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\\n\\n\\t\\t\\t\\tedge1.subVectors( b, a );\\n\\t\\t\\t\\tedge2.subVectors( c, a );\\n\\t\\t\\t\\tnormal.crossVectors( edge1, edge2 );\\n\\n\\t\\t\\t\\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\\n\\t\\t\\t\\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\\n\\t\\t\\t\\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\\n\\t\\t\\t\\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\\n\\t\\t\\t\\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\\n\\t\\t\\t\\tvar DdN = this.direction.dot( normal );\\n\\t\\t\\t\\tvar sign;\\n\\n\\t\\t\\t\\tif ( DdN > 0 ) {\\n\\n\\t\\t\\t\\t\\tif ( backfaceCulling ) return null;\\n\\t\\t\\t\\t\\tsign = 1;\\n\\n\\t\\t\\t\\t} else if ( DdN < 0 ) {\\n\\n\\t\\t\\t\\t\\tsign = - 1;\\n\\t\\t\\t\\t\\tDdN = - DdN;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdiff.subVectors( this.origin, a );\\n\\t\\t\\t\\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\\n\\n\\t\\t\\t\\t// b1 < 0, no intersection\\n\\t\\t\\t\\tif ( DdQxE2 < 0 ) {\\n\\n\\t\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\\n\\n\\t\\t\\t\\t// b2 < 0, no intersection\\n\\t\\t\\t\\tif ( DdE1xQ < 0 ) {\\n\\n\\t\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// b1+b2 > 1, no intersection\\n\\t\\t\\t\\tif ( DdQxE2 + DdE1xQ > DdN ) {\\n\\n\\t\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Line intersects triangle, check if ray does.\\n\\t\\t\\t\\tvar QdN = - sign * diff.dot( normal );\\n\\n\\t\\t\\t\\t// t < 0, no intersection\\n\\t\\t\\t\\tif ( QdN < 0 ) {\\n\\n\\t\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Ray intersects triangle.\\n\\t\\t\\t\\treturn this.at( QdN / DdN, optionalTarget );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tapplyMatrix4: function ( matrix4 ) {\\n\\n\\t\\t\\tthis.origin.applyMatrix4( matrix4 );\\n\\t\\t\\tthis.direction.transformDirection( matrix4 );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( ray ) {\\n\\n\\t\\t\\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author bhouston / http://clara.io\\n\\t */\\n\\n\\tfunction Line3( start, end ) {\\n\\n\\t\\tthis.start = ( start !== undefined ) ? start : new Vector3();\\n\\t\\tthis.end = ( end !== undefined ) ? end : new Vector3();\\n\\n\\t}\\n\\n\\tObject.assign( Line3.prototype, {\\n\\n\\t\\tset: function ( start, end ) {\\n\\n\\t\\t\\tthis.start.copy( start );\\n\\t\\t\\tthis.end.copy( end );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( line ) {\\n\\n\\t\\t\\tthis.start.copy( line.start );\\n\\t\\t\\tthis.end.copy( line.end );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetCenter: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\t\\t\\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\\n\\n\\t\\t},\\n\\n\\t\\tdelta: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\t\\t\\treturn result.subVectors( this.end, this.start );\\n\\n\\t\\t},\\n\\n\\t\\tdistanceSq: function () {\\n\\n\\t\\t\\treturn this.start.distanceToSquared( this.end );\\n\\n\\t\\t},\\n\\n\\t\\tdistance: function () {\\n\\n\\t\\t\\treturn this.start.distanceTo( this.end );\\n\\n\\t\\t},\\n\\n\\t\\tat: function ( t, optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\\n\\n\\t\\t},\\n\\n\\t\\tclosestPointToPointParameter: function () {\\n\\n\\t\\t\\tvar startP = new Vector3();\\n\\t\\t\\tvar startEnd = new Vector3();\\n\\n\\t\\t\\treturn function closestPointToPointParameter( point, clampToLine ) {\\n\\n\\t\\t\\t\\tstartP.subVectors( point, this.start );\\n\\t\\t\\t\\tstartEnd.subVectors( this.end, this.start );\\n\\n\\t\\t\\t\\tvar startEnd2 = startEnd.dot( startEnd );\\n\\t\\t\\t\\tvar startEnd_startP = startEnd.dot( startP );\\n\\n\\t\\t\\t\\tvar t = startEnd_startP / startEnd2;\\n\\n\\t\\t\\t\\tif ( clampToLine ) {\\n\\n\\t\\t\\t\\t\\tt = _Math.clamp( t, 0, 1 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn t;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\\n\\n\\t\\t\\tvar t = this.closestPointToPointParameter( point, clampToLine );\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\\n\\n\\t\\t},\\n\\n\\t\\tapplyMatrix4: function ( matrix ) {\\n\\n\\t\\t\\tthis.start.applyMatrix4( matrix );\\n\\t\\t\\tthis.end.applyMatrix4( matrix );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( line ) {\\n\\n\\t\\t\\treturn line.start.equals( this.start ) && line.end.equals( this.end );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author bhouston / http://clara.io\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction Triangle( a, b, c ) {\\n\\n\\t\\tthis.a = ( a !== undefined ) ? a : new Vector3();\\n\\t\\tthis.b = ( b !== undefined ) ? b : new Vector3();\\n\\t\\tthis.c = ( c !== undefined ) ? c : new Vector3();\\n\\n\\t}\\n\\n\\tObject.assign( Triangle, {\\n\\n\\t\\tnormal: function () {\\n\\n\\t\\t\\tvar v0 = new Vector3();\\n\\n\\t\\t\\treturn function normal( a, b, c, optionalTarget ) {\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\t\\tresult.subVectors( c, b );\\n\\t\\t\\t\\tv0.subVectors( a, b );\\n\\t\\t\\t\\tresult.cross( v0 );\\n\\n\\t\\t\\t\\tvar resultLengthSq = result.lengthSq();\\n\\t\\t\\t\\tif ( resultLengthSq > 0 ) {\\n\\n\\t\\t\\t\\t\\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn result.set( 0, 0, 0 );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\t// static/instance method to calculate barycentric coordinates\\n\\t\\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\\n\\t\\tbarycoordFromPoint: function () {\\n\\n\\t\\t\\tvar v0 = new Vector3();\\n\\t\\t\\tvar v1 = new Vector3();\\n\\t\\t\\tvar v2 = new Vector3();\\n\\n\\t\\t\\treturn function barycoordFromPoint( point, a, b, c, optionalTarget ) {\\n\\n\\t\\t\\t\\tv0.subVectors( c, a );\\n\\t\\t\\t\\tv1.subVectors( b, a );\\n\\t\\t\\t\\tv2.subVectors( point, a );\\n\\n\\t\\t\\t\\tvar dot00 = v0.dot( v0 );\\n\\t\\t\\t\\tvar dot01 = v0.dot( v1 );\\n\\t\\t\\t\\tvar dot02 = v0.dot( v2 );\\n\\t\\t\\t\\tvar dot11 = v1.dot( v1 );\\n\\t\\t\\t\\tvar dot12 = v1.dot( v2 );\\n\\n\\t\\t\\t\\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\t\\t// collinear or singular triangle\\n\\t\\t\\t\\tif ( denom === 0 ) {\\n\\n\\t\\t\\t\\t\\t// arbitrary location outside of triangle?\\n\\t\\t\\t\\t\\t// not sure if this is the best idea, maybe should be returning undefined\\n\\t\\t\\t\\t\\treturn result.set( - 2, - 1, - 1 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar invDenom = 1 / denom;\\n\\t\\t\\t\\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\\n\\t\\t\\t\\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\\n\\n\\t\\t\\t\\t// barycentric coordinates must always sum to 1\\n\\t\\t\\t\\treturn result.set( 1 - u - v, v, u );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tcontainsPoint: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function containsPoint( point, a, b, c ) {\\n\\n\\t\\t\\t\\tvar result = Triangle.barycoordFromPoint( point, a, b, c, v1 );\\n\\n\\t\\t\\t\\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}()\\n\\n\\t} );\\n\\n\\tObject.assign( Triangle.prototype, {\\n\\n\\t\\tset: function ( a, b, c ) {\\n\\n\\t\\t\\tthis.a.copy( a );\\n\\t\\t\\tthis.b.copy( b );\\n\\t\\t\\tthis.c.copy( c );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\\n\\n\\t\\t\\tthis.a.copy( points[ i0 ] );\\n\\t\\t\\tthis.b.copy( points[ i1 ] );\\n\\t\\t\\tthis.c.copy( points[ i2 ] );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( triangle ) {\\n\\n\\t\\t\\tthis.a.copy( triangle.a );\\n\\t\\t\\tthis.b.copy( triangle.b );\\n\\t\\t\\tthis.c.copy( triangle.c );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tarea: function () {\\n\\n\\t\\t\\tvar v0 = new Vector3();\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function area() {\\n\\n\\t\\t\\t\\tv0.subVectors( this.c, this.b );\\n\\t\\t\\t\\tv1.subVectors( this.a, this.b );\\n\\n\\t\\t\\t\\treturn v0.cross( v1 ).length() * 0.5;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tmidpoint: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\t\\t\\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\\n\\n\\t\\t},\\n\\n\\t\\tnormal: function ( optionalTarget ) {\\n\\n\\t\\t\\treturn Triangle.normal( this.a, this.b, this.c, optionalTarget );\\n\\n\\t\\t},\\n\\n\\t\\tplane: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Plane();\\n\\n\\t\\t\\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\\n\\n\\t\\t},\\n\\n\\t\\tbarycoordFromPoint: function ( point, optionalTarget ) {\\n\\n\\t\\t\\treturn Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\\n\\n\\t\\t},\\n\\n\\t\\tcontainsPoint: function ( point ) {\\n\\n\\t\\t\\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\\n\\n\\t\\t},\\n\\n\\t\\tclosestPointToPoint: function () {\\n\\n\\t\\t\\tvar plane = new Plane();\\n\\t\\t\\tvar edgeList = [ new Line3(), new Line3(), new Line3() ];\\n\\t\\t\\tvar projectedPoint = new Vector3();\\n\\t\\t\\tvar closestPoint = new Vector3();\\n\\n\\t\\t\\treturn function closestPointToPoint( point, optionalTarget ) {\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\t\\t\\t\\tvar minDistance = Infinity;\\n\\n\\t\\t\\t\\t// project the point onto the plane of the triangle\\n\\n\\t\\t\\t\\tplane.setFromCoplanarPoints( this.a, this.b, this.c );\\n\\t\\t\\t\\tplane.projectPoint( point, projectedPoint );\\n\\n\\t\\t\\t\\t// check if the projection lies within the triangle\\n\\n\\t\\t\\t\\tif ( this.containsPoint( projectedPoint ) === true ) {\\n\\n\\t\\t\\t\\t\\t// if so, this is the closest point\\n\\n\\t\\t\\t\\t\\tresult.copy( projectedPoint );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices\\n\\n\\t\\t\\t\\t\\tedgeList[ 0 ].set( this.a, this.b );\\n\\t\\t\\t\\t\\tedgeList[ 1 ].set( this.b, this.c );\\n\\t\\t\\t\\t\\tedgeList[ 2 ].set( this.c, this.a );\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < edgeList.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tedgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );\\n\\n\\t\\t\\t\\t\\t\\tvar distance = projectedPoint.distanceToSquared( closestPoint );\\n\\n\\t\\t\\t\\t\\t\\tif ( distance < minDistance ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tminDistance = distance;\\n\\n\\t\\t\\t\\t\\t\\t\\tresult.copy( closestPoint );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn result;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tequals: function ( triangle ) {\\n\\n\\t\\t\\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author jonobr1 / http://jonobr1.com/\\n\\t */\\n\\n\\tfunction Mesh( geometry, material ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Mesh';\\n\\n\\t\\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\\n\\t\\tthis.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );\\n\\n\\t\\tthis.drawMode = TrianglesDrawMode;\\n\\n\\t\\tthis.updateMorphTargets();\\n\\n\\t}\\n\\n\\tMesh.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Mesh,\\n\\n\\t\\tisMesh: true,\\n\\n\\t\\tsetDrawMode: function ( value ) {\\n\\n\\t\\t\\tthis.drawMode = value;\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tObject3D.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.drawMode = source.drawMode;\\n\\n\\t\\t\\tif ( source.morphTargetInfluences !== undefined ) {\\n\\n\\t\\t\\t\\tthis.morphTargetInfluences = source.morphTargetInfluences.slice();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( source.morphTargetDictionary !== undefined ) {\\n\\n\\t\\t\\t\\tthis.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tupdateMorphTargets: function () {\\n\\n\\t\\t\\tvar geometry = this.geometry;\\n\\t\\t\\tvar m, ml, name;\\n\\n\\t\\t\\tif ( geometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\tvar morphAttributes = geometry.morphAttributes;\\n\\t\\t\\t\\tvar keys = Object.keys( morphAttributes );\\n\\n\\t\\t\\t\\tif ( keys.length > 0 ) {\\n\\n\\t\\t\\t\\t\\tvar morphAttribute = morphAttributes[ keys[ 0 ] ];\\n\\n\\t\\t\\t\\t\\tif ( morphAttribute !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.morphTargetInfluences = [];\\n\\t\\t\\t\\t\\t\\tthis.morphTargetDictionary = {};\\n\\n\\t\\t\\t\\t\\t\\tfor ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tname = morphAttribute[ m ].name || String( m );\\n\\n\\t\\t\\t\\t\\t\\t\\tthis.morphTargetInfluences.push( 0 );\\n\\t\\t\\t\\t\\t\\t\\tthis.morphTargetDictionary[ name ] = m;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tvar morphTargets = geometry.morphTargets;\\n\\n\\t\\t\\t\\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\\n\\n\\t\\t\\t\\t\\tthis.morphTargetInfluences = [];\\n\\t\\t\\t\\t\\tthis.morphTargetDictionary = {};\\n\\n\\t\\t\\t\\t\\tfor ( m = 0, ml = morphTargets.length; m < ml; m ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tname = morphTargets[ m ].name || String( m );\\n\\n\\t\\t\\t\\t\\t\\tthis.morphTargetInfluences.push( 0 );\\n\\t\\t\\t\\t\\t\\tthis.morphTargetDictionary[ name ] = m;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\traycast: ( function () {\\n\\n\\t\\t\\tvar inverseMatrix = new Matrix4();\\n\\t\\t\\tvar ray = new Ray();\\n\\t\\t\\tvar sphere = new Sphere();\\n\\n\\t\\t\\tvar vA = new Vector3();\\n\\t\\t\\tvar vB = new Vector3();\\n\\t\\t\\tvar vC = new Vector3();\\n\\n\\t\\t\\tvar tempA = new Vector3();\\n\\t\\t\\tvar tempB = new Vector3();\\n\\t\\t\\tvar tempC = new Vector3();\\n\\n\\t\\t\\tvar uvA = new Vector2();\\n\\t\\t\\tvar uvB = new Vector2();\\n\\t\\t\\tvar uvC = new Vector2();\\n\\n\\t\\t\\tvar barycoord = new Vector3();\\n\\n\\t\\t\\tvar intersectionPoint = new Vector3();\\n\\t\\t\\tvar intersectionPointWorld = new Vector3();\\n\\n\\t\\t\\tfunction uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\\n\\n\\t\\t\\t\\tTriangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\\n\\n\\t\\t\\t\\tuv1.multiplyScalar( barycoord.x );\\n\\t\\t\\t\\tuv2.multiplyScalar( barycoord.y );\\n\\t\\t\\t\\tuv3.multiplyScalar( barycoord.z );\\n\\n\\t\\t\\t\\tuv1.add( uv2 ).add( uv3 );\\n\\n\\t\\t\\t\\treturn uv1.clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {\\n\\n\\t\\t\\t\\tvar intersect;\\n\\n\\t\\t\\t\\tif ( material.side === BackSide ) {\\n\\n\\t\\t\\t\\t\\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( intersect === null ) return null;\\n\\n\\t\\t\\t\\tintersectionPointWorld.copy( point );\\n\\t\\t\\t\\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\\n\\n\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\\n\\n\\t\\t\\t\\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\\n\\n\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\tdistance: distance,\\n\\t\\t\\t\\t\\tpoint: intersectionPointWorld.clone(),\\n\\t\\t\\t\\t\\tobject: object\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction checkBufferGeometryIntersection( object, raycaster, ray, position, uv, a, b, c ) {\\n\\n\\t\\t\\t\\tvA.fromBufferAttribute( position, a );\\n\\t\\t\\t\\tvB.fromBufferAttribute( position, b );\\n\\t\\t\\t\\tvC.fromBufferAttribute( position, c );\\n\\n\\t\\t\\t\\tvar intersection = checkIntersection( object, object.material, raycaster, ray, vA, vB, vC, intersectionPoint );\\n\\n\\t\\t\\t\\tif ( intersection ) {\\n\\n\\t\\t\\t\\t\\tif ( uv ) {\\n\\n\\t\\t\\t\\t\\t\\tuvA.fromBufferAttribute( uv, a );\\n\\t\\t\\t\\t\\t\\tuvB.fromBufferAttribute( uv, b );\\n\\t\\t\\t\\t\\t\\tuvC.fromBufferAttribute( uv, c );\\n\\n\\t\\t\\t\\t\\t\\tintersection.uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tintersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );\\n\\t\\t\\t\\t\\tintersection.faceIndex = a;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn intersection;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn function raycast( raycaster, intersects ) {\\n\\n\\t\\t\\t\\tvar geometry = this.geometry;\\n\\t\\t\\t\\tvar material = this.material;\\n\\t\\t\\t\\tvar matrixWorld = this.matrixWorld;\\n\\n\\t\\t\\t\\tif ( material === undefined ) return;\\n\\n\\t\\t\\t\\t// Checking boundingSphere distance to ray\\n\\n\\t\\t\\t\\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\\n\\n\\t\\t\\t\\tsphere.copy( geometry.boundingSphere );\\n\\t\\t\\t\\tsphere.applyMatrix4( matrixWorld );\\n\\n\\t\\t\\t\\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\\n\\n\\t\\t\\t\\t//\\n\\n\\t\\t\\t\\tinverseMatrix.getInverse( matrixWorld );\\n\\t\\t\\t\\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\\n\\n\\t\\t\\t\\t// Check boundingBox before continuing\\n\\n\\t\\t\\t\\tif ( geometry.boundingBox !== null ) {\\n\\n\\t\\t\\t\\t\\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar intersection;\\n\\n\\t\\t\\t\\tif ( geometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\t\\tvar a, b, c;\\n\\t\\t\\t\\t\\tvar index = geometry.index;\\n\\t\\t\\t\\t\\tvar position = geometry.attributes.position;\\n\\t\\t\\t\\t\\tvar uv = geometry.attributes.uv;\\n\\t\\t\\t\\t\\tvar i, l;\\n\\n\\t\\t\\t\\t\\tif ( index !== null ) {\\n\\n\\t\\t\\t\\t\\t\\t// indexed buffer geometry\\n\\n\\t\\t\\t\\t\\t\\tfor ( i = 0, l = index.count; i < l; i += 3 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\ta = index.getX( i );\\n\\t\\t\\t\\t\\t\\t\\tb = index.getX( i + 1 );\\n\\t\\t\\t\\t\\t\\t\\tc = index.getX( i + 2 );\\n\\n\\t\\t\\t\\t\\t\\t\\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( intersection ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\\n\\t\\t\\t\\t\\t\\t\\t\\tintersects.push( intersection );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else if ( position !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t// non-indexed buffer geometry\\n\\n\\t\\t\\t\\t\\t\\tfor ( i = 0, l = position.count; i < l; i += 3 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\ta = i;\\n\\t\\t\\t\\t\\t\\t\\tb = i + 1;\\n\\t\\t\\t\\t\\t\\t\\tc = i + 2;\\n\\n\\t\\t\\t\\t\\t\\t\\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( intersection ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tintersection.index = a; // triangle number in positions buffer semantics\\n\\t\\t\\t\\t\\t\\t\\t\\tintersects.push( intersection );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( geometry.isGeometry ) {\\n\\n\\t\\t\\t\\t\\tvar fvA, fvB, fvC;\\n\\t\\t\\t\\t\\tvar isMultiMaterial = Array.isArray( material );\\n\\n\\t\\t\\t\\t\\tvar vertices = geometry.vertices;\\n\\t\\t\\t\\t\\tvar faces = geometry.faces;\\n\\t\\t\\t\\t\\tvar uvs;\\n\\n\\t\\t\\t\\t\\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\\n\\t\\t\\t\\t\\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\\n\\n\\t\\t\\t\\t\\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar face = faces[ f ];\\n\\t\\t\\t\\t\\t\\tvar faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;\\n\\n\\t\\t\\t\\t\\t\\tif ( faceMaterial === undefined ) continue;\\n\\n\\t\\t\\t\\t\\t\\tfvA = vertices[ face.a ];\\n\\t\\t\\t\\t\\t\\tfvB = vertices[ face.b ];\\n\\t\\t\\t\\t\\t\\tfvC = vertices[ face.c ];\\n\\n\\t\\t\\t\\t\\t\\tif ( faceMaterial.morphTargets === true ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar morphTargets = geometry.morphTargets;\\n\\t\\t\\t\\t\\t\\t\\tvar morphInfluences = this.morphTargetInfluences;\\n\\n\\t\\t\\t\\t\\t\\t\\tvA.set( 0, 0, 0 );\\n\\t\\t\\t\\t\\t\\t\\tvB.set( 0, 0, 0 );\\n\\t\\t\\t\\t\\t\\t\\tvC.set( 0, 0, 0 );\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar influence = morphInfluences[ t ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( influence === 0 ) continue;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar targets = morphTargets[ t ].vertices;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\\n\\t\\t\\t\\t\\t\\t\\t\\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\\n\\t\\t\\t\\t\\t\\t\\t\\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tvA.add( fvA );\\n\\t\\t\\t\\t\\t\\t\\tvB.add( fvB );\\n\\t\\t\\t\\t\\t\\t\\tvC.add( fvC );\\n\\n\\t\\t\\t\\t\\t\\t\\tfvA = vA;\\n\\t\\t\\t\\t\\t\\t\\tfvB = vB;\\n\\t\\t\\t\\t\\t\\t\\tfvC = vC;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tintersection = checkIntersection( this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\\n\\n\\t\\t\\t\\t\\t\\tif ( intersection ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( uvs && uvs[ f ] ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar uvs_f = uvs[ f ];\\n\\t\\t\\t\\t\\t\\t\\t\\tuvA.copy( uvs_f[ 0 ] );\\n\\t\\t\\t\\t\\t\\t\\t\\tuvB.copy( uvs_f[ 1 ] );\\n\\t\\t\\t\\t\\t\\t\\t\\tuvC.copy( uvs_f[ 2 ] );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tintersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tintersection.face = face;\\n\\t\\t\\t\\t\\t\\t\\tintersection.faceIndex = f;\\n\\t\\t\\t\\t\\t\\t\\tintersects.push( intersection );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}() ),\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.geometry, this.material ).copy( this );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLBackground( renderer, state, geometries, premultipliedAlpha ) {\\n\\n\\t\\tvar clearColor = new Color( 0x000000 );\\n\\t\\tvar clearAlpha = 0;\\n\\n\\t\\tvar planeCamera, planeMesh;\\n\\t\\tvar boxMesh;\\n\\n\\t\\tfunction render( renderList, scene, camera, forceClear ) {\\n\\n\\t\\t\\tvar background = scene.background;\\n\\n\\t\\t\\tif ( background === null ) {\\n\\n\\t\\t\\t\\tsetClear( clearColor, clearAlpha );\\n\\n\\t\\t\\t} else if ( background && background.isColor ) {\\n\\n\\t\\t\\t\\tsetClear( background, 1 );\\n\\t\\t\\t\\tforceClear = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( renderer.autoClear || forceClear ) {\\n\\n\\t\\t\\t\\trenderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( background && background.isCubeTexture ) {\\n\\n\\t\\t\\t\\tif ( boxMesh === undefined ) {\\n\\n\\t\\t\\t\\t\\tboxMesh = new Mesh(\\n\\t\\t\\t\\t\\t\\tnew BoxBufferGeometry( 1, 1, 1 ),\\n\\t\\t\\t\\t\\t\\tnew ShaderMaterial( {\\n\\t\\t\\t\\t\\t\\t\\tuniforms: ShaderLib.cube.uniforms,\\n\\t\\t\\t\\t\\t\\t\\tvertexShader: ShaderLib.cube.vertexShader,\\n\\t\\t\\t\\t\\t\\t\\tfragmentShader: ShaderLib.cube.fragmentShader,\\n\\t\\t\\t\\t\\t\\t\\tside: BackSide,\\n\\t\\t\\t\\t\\t\\t\\tdepthTest: true,\\n\\t\\t\\t\\t\\t\\t\\tdepthWrite: false,\\n\\t\\t\\t\\t\\t\\t\\tfog: false\\n\\t\\t\\t\\t\\t\\t} )\\n\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\tboxMesh.geometry.removeAttribute( 'normal' );\\n\\t\\t\\t\\t\\tboxMesh.geometry.removeAttribute( 'uv' );\\n\\n\\t\\t\\t\\t\\tboxMesh.onBeforeRender = function ( renderer, scene, camera ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.matrixWorld.copyPosition( camera.matrixWorld );\\n\\n\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\tgeometries.update( boxMesh.geometry );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tboxMesh.material.uniforms.tCube.value = background;\\n\\n\\t\\t\\t\\trenderList.push( boxMesh, boxMesh.geometry, boxMesh.material, 0, null );\\n\\n\\t\\t\\t} else if ( background && background.isTexture ) {\\n\\n\\t\\t\\t\\tif ( planeCamera === undefined ) {\\n\\n\\t\\t\\t\\t\\tplaneCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\\n\\n\\t\\t\\t\\t\\tplaneMesh = new Mesh(\\n\\t\\t\\t\\t\\t\\tnew PlaneBufferGeometry( 2, 2 ),\\n\\t\\t\\t\\t\\t\\tnew MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )\\n\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\tgeometries.update( planeMesh.geometry );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tplaneMesh.material.map = background;\\n\\n\\t\\t\\t\\t// TODO Push this to renderList\\n\\n\\t\\t\\t\\trenderer.renderBufferDirect( planeCamera, null, planeMesh.geometry, planeMesh.material, planeMesh, null );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction setClear( color, alpha ) {\\n\\n\\t\\t\\tstate.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tgetClearColor: function () {\\n\\n\\t\\t\\t\\treturn clearColor;\\n\\n\\t\\t\\t},\\n\\t\\t\\tsetClearColor: function ( color, alpha ) {\\n\\n\\t\\t\\t\\tclearColor.set( color );\\n\\t\\t\\t\\tclearAlpha = alpha !== undefined ? alpha : 1;\\n\\t\\t\\t\\tsetClear( clearColor, clearAlpha );\\n\\n\\t\\t\\t},\\n\\t\\t\\tgetClearAlpha: function () {\\n\\n\\t\\t\\t\\treturn clearAlpha;\\n\\n\\t\\t\\t},\\n\\t\\t\\tsetClearAlpha: function ( alpha ) {\\n\\n\\t\\t\\t\\tclearAlpha = alpha;\\n\\t\\t\\t\\tsetClear( clearColor, clearAlpha );\\n\\n\\t\\t\\t},\\n\\t\\t\\trender: render\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction painterSortStable( a, b ) {\\n\\n\\t\\tif ( a.renderOrder !== b.renderOrder ) {\\n\\n\\t\\t\\treturn a.renderOrder - b.renderOrder;\\n\\n\\t\\t} else if ( a.program && b.program && a.program !== b.program ) {\\n\\n\\t\\t\\treturn a.program.id - b.program.id;\\n\\n\\t\\t} else if ( a.material.id !== b.material.id ) {\\n\\n\\t\\t\\treturn a.material.id - b.material.id;\\n\\n\\t\\t} else if ( a.z !== b.z ) {\\n\\n\\t\\t\\treturn a.z - b.z;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\treturn a.id - b.id;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction reversePainterSortStable( a, b ) {\\n\\n\\t\\tif ( a.renderOrder !== b.renderOrder ) {\\n\\n\\t\\t\\treturn a.renderOrder - b.renderOrder;\\n\\n\\t\\t} if ( a.z !== b.z ) {\\n\\n\\t\\t\\treturn b.z - a.z;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\treturn a.id - b.id;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction WebGLRenderList() {\\n\\n\\t\\tvar renderItems = [];\\n\\t\\tvar renderItemsIndex = 0;\\n\\n\\t\\tvar opaque = [];\\n\\t\\tvar transparent = [];\\n\\n\\t\\tfunction init() {\\n\\n\\t\\t\\trenderItemsIndex = 0;\\n\\n\\t\\t\\topaque.length = 0;\\n\\t\\t\\ttransparent.length = 0;\\n\\n\\t\\t}\\n\\n\\t\\tfunction push( object, geometry, material, z, group ) {\\n\\n\\t\\t\\tvar renderItem = renderItems[ renderItemsIndex ];\\n\\n\\t\\t\\tif ( renderItem === undefined ) {\\n\\n\\t\\t\\t\\trenderItem = {\\n\\t\\t\\t\\t\\tid: object.id,\\n\\t\\t\\t\\t\\tobject: object,\\n\\t\\t\\t\\t\\tgeometry: geometry,\\n\\t\\t\\t\\t\\tmaterial: material,\\n\\t\\t\\t\\t\\tprogram: material.program,\\n\\t\\t\\t\\t\\trenderOrder: object.renderOrder,\\n\\t\\t\\t\\t\\tz: z,\\n\\t\\t\\t\\t\\tgroup: group\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\trenderItems[ renderItemsIndex ] = renderItem;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\trenderItem.id = object.id;\\n\\t\\t\\t\\trenderItem.object = object;\\n\\t\\t\\t\\trenderItem.geometry = geometry;\\n\\t\\t\\t\\trenderItem.material = material;\\n\\t\\t\\t\\trenderItem.program = material.program;\\n\\t\\t\\t\\trenderItem.renderOrder = object.renderOrder;\\n\\t\\t\\t\\trenderItem.z = z;\\n\\t\\t\\t\\trenderItem.group = group;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t( material.transparent === true ? transparent : opaque ).push( renderItem );\\n\\n\\t\\t\\trenderItemsIndex ++;\\n\\n\\t\\t}\\n\\n\\t\\tfunction sort() {\\n\\n\\t\\t\\tif ( opaque.length > 1 ) opaque.sort( painterSortStable );\\n\\t\\t\\tif ( transparent.length > 1 ) transparent.sort( reversePainterSortStable );\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\topaque: opaque,\\n\\t\\t\\ttransparent: transparent,\\n\\n\\t\\t\\tinit: init,\\n\\t\\t\\tpush: push,\\n\\n\\t\\t\\tsort: sort\\n\\t\\t};\\n\\n\\t}\\n\\n\\tfunction WebGLRenderLists() {\\n\\n\\t\\tvar lists = {};\\n\\n\\t\\tfunction get( scene, camera ) {\\n\\n\\t\\t\\tvar hash = scene.id + ',' + camera.id;\\n\\t\\t\\tvar list = lists[ hash ];\\n\\n\\t\\t\\tif ( list === undefined ) {\\n\\n\\t\\t\\t\\t// console.log( 'THREE.WebGLRenderLists:', hash );\\n\\n\\t\\t\\t\\tlist = new WebGLRenderList();\\n\\t\\t\\t\\tlists[ hash ] = list;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn list;\\n\\n\\t\\t}\\n\\n\\t\\tfunction dispose() {\\n\\n\\t\\t\\tlists = {};\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\tget: get,\\n\\t\\t\\tdispose: dispose\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction absNumericalSort( a, b ) {\\n\\n\\t\\treturn Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );\\n\\n\\t}\\n\\n\\tfunction WebGLMorphtargets( gl ) {\\n\\n\\t\\tvar influencesList = {};\\n\\t\\tvar morphInfluences = new Float32Array( 8 );\\n\\n\\t\\tfunction update( object, geometry, material, program ) {\\n\\n\\t\\t\\tvar objectInfluences = object.morphTargetInfluences;\\n\\n\\t\\t\\tvar length = objectInfluences.length;\\n\\n\\t\\t\\tvar influences = influencesList[ geometry.id ];\\n\\n\\t\\t\\tif ( influences === undefined ) {\\n\\n\\t\\t\\t\\t// initialise list\\n\\n\\t\\t\\t\\tinfluences = [];\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tinfluences[ i ] = [ i, 0 ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tinfluencesList[ geometry.id ] = influences;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar morphTargets = material.morphTargets && geometry.morphAttributes.position;\\n\\t\\t\\tvar morphNormals = material.morphNormals && geometry.morphAttributes.normal;\\n\\n\\t\\t\\t// Remove current morphAttributes\\n\\n\\t\\t\\tfor ( var i = 0; i < length; i ++ ) {\\n\\n\\t\\t\\t\\tvar influence = influences[ i ];\\n\\n\\t\\t\\t\\tif ( influence[ 1 ] !== 0 ) {\\n\\n\\t\\t\\t\\t\\tif ( morphTargets ) geometry.removeAttribute( 'morphTarget' + i );\\n\\t\\t\\t\\t\\tif ( morphNormals ) geometry.removeAttribute( 'morphNormal' + i );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Collect influences\\n\\n\\t\\t\\tfor ( var i = 0; i < length; i ++ ) {\\n\\n\\t\\t\\t\\tvar influence = influences[ i ];\\n\\n\\t\\t\\t\\tinfluence[ 0 ] = i;\\n\\t\\t\\t\\tinfluence[ 1 ] = objectInfluences[ i ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tinfluences.sort( absNumericalSort );\\n\\n\\t\\t\\t// Add morphAttributes\\n\\n\\t\\t\\tfor ( var i = 0; i < 8; i ++ ) {\\n\\n\\t\\t\\t\\tvar influence = influences[ i ];\\n\\n\\t\\t\\t\\tif ( influence ) {\\n\\n\\t\\t\\t\\t\\tvar index = influence[ 0 ];\\n\\t\\t\\t\\t\\tvar value = influence[ 1 ];\\n\\n\\t\\t\\t\\t\\tif ( value ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( morphTargets ) geometry.addAttribute( 'morphTarget' + i, morphTargets[ index ] );\\n\\t\\t\\t\\t\\t\\tif ( morphNormals ) geometry.addAttribute( 'morphNormal' + i, morphNormals[ index ] );\\n\\n\\t\\t\\t\\t\\t\\tmorphInfluences[ i ] = value;\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tmorphInfluences[ i ] = 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tprogram.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tupdate: update\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {\\n\\n\\t\\tvar mode;\\n\\n\\t\\tfunction setMode( value ) {\\n\\n\\t\\t\\tmode = value;\\n\\n\\t\\t}\\n\\n\\t\\tvar type, bytesPerElement;\\n\\n\\t\\tfunction setIndex( value ) {\\n\\n\\t\\t\\ttype = value.type;\\n\\t\\t\\tbytesPerElement = value.bytesPerElement;\\n\\n\\t\\t}\\n\\n\\t\\tfunction render( start, count ) {\\n\\n\\t\\t\\tgl.drawElements( mode, count, type, start * bytesPerElement );\\n\\n\\t\\t\\tinfoRender.calls ++;\\n\\t\\t\\tinfoRender.vertices += count;\\n\\n\\t\\t\\tif ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\\n\\t\\t\\telse if ( mode === gl.POINTS ) infoRender.points += count;\\n\\n\\t\\t}\\n\\n\\t\\tfunction renderInstances( geometry, start, count ) {\\n\\n\\t\\t\\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\\n\\n\\t\\t\\tif ( extension === null ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\textension.drawElementsInstancedANGLE( mode, count, type, start * bytesPerElement, geometry.maxInstancedCount );\\n\\n\\t\\t\\tinfoRender.calls ++;\\n\\t\\t\\tinfoRender.vertices += count * geometry.maxInstancedCount;\\n\\n\\t\\t\\tif ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\\n\\t\\t\\telse if ( mode === gl.POINTS ) infoRender.points += geometry.maxInstancedCount * count;\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tthis.setMode = setMode;\\n\\t\\tthis.setIndex = setIndex;\\n\\t\\tthis.render = render;\\n\\t\\tthis.renderInstances = renderInstances;\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLBufferRenderer( gl, extensions, infoRender ) {\\n\\n\\t\\tvar mode;\\n\\n\\t\\tfunction setMode( value ) {\\n\\n\\t\\t\\tmode = value;\\n\\n\\t\\t}\\n\\n\\t\\tfunction render( start, count ) {\\n\\n\\t\\t\\tgl.drawArrays( mode, start, count );\\n\\n\\t\\t\\tinfoRender.calls ++;\\n\\t\\t\\tinfoRender.vertices += count;\\n\\n\\t\\t\\tif ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\\n\\t\\t\\telse if ( mode === gl.POINTS ) infoRender.points += count;\\n\\n\\t\\t}\\n\\n\\t\\tfunction renderInstances( geometry, start, count ) {\\n\\n\\t\\t\\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\\n\\n\\t\\t\\tif ( extension === null ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar position = geometry.attributes.position;\\n\\n\\t\\t\\tif ( position.isInterleavedBufferAttribute ) {\\n\\n\\t\\t\\t\\tcount = position.data.count;\\n\\n\\t\\t\\t\\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\textension.drawArraysInstancedANGLE( mode, start, count, geometry.maxInstancedCount );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tinfoRender.calls ++;\\n\\t\\t\\tinfoRender.vertices += count * geometry.maxInstancedCount;\\n\\n\\t\\t\\tif ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\\n\\t\\t\\telse if ( mode === gl.POINTS ) infoRender.points += geometry.maxInstancedCount * count;\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tthis.setMode = setMode;\\n\\t\\tthis.render = render;\\n\\t\\tthis.renderInstances = renderInstances;\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLGeometries( gl, attributes, infoMemory ) {\\n\\n\\t\\tvar geometries = {};\\n\\t\\tvar wireframeAttributes = {};\\n\\n\\t\\tfunction onGeometryDispose( event ) {\\n\\n\\t\\t\\tvar geometry = event.target;\\n\\t\\t\\tvar buffergeometry = geometries[ geometry.id ];\\n\\n\\t\\t\\tif ( buffergeometry.index !== null ) {\\n\\n\\t\\t\\t\\tattributes.remove( buffergeometry.index );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var name in buffergeometry.attributes ) {\\n\\n\\t\\t\\t\\tattributes.remove( buffergeometry.attributes[ name ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\\n\\n\\t\\t\\tdelete geometries[ geometry.id ];\\n\\n\\t\\t\\t// TODO Remove duplicate code\\n\\n\\t\\t\\tvar attribute = wireframeAttributes[ geometry.id ];\\n\\n\\t\\t\\tif ( attribute ) {\\n\\n\\t\\t\\t\\tattributes.remove( attribute );\\n\\t\\t\\t\\tdelete wireframeAttributes[ geometry.id ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tattribute = wireframeAttributes[ buffergeometry.id ];\\n\\n\\t\\t\\tif ( attribute ) {\\n\\n\\t\\t\\t\\tattributes.remove( attribute );\\n\\t\\t\\t\\tdelete wireframeAttributes[ buffergeometry.id ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tinfoMemory.geometries --;\\n\\n\\t\\t}\\n\\n\\t\\tfunction get( object, geometry ) {\\n\\n\\t\\t\\tvar buffergeometry = geometries[ geometry.id ];\\n\\n\\t\\t\\tif ( buffergeometry ) return buffergeometry;\\n\\n\\t\\t\\tgeometry.addEventListener( 'dispose', onGeometryDispose );\\n\\n\\t\\t\\tif ( geometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\tbuffergeometry = geometry;\\n\\n\\t\\t\\t} else if ( geometry.isGeometry ) {\\n\\n\\t\\t\\t\\tif ( geometry._bufferGeometry === undefined ) {\\n\\n\\t\\t\\t\\t\\tgeometry._bufferGeometry = new BufferGeometry().setFromObject( object );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbuffergeometry = geometry._bufferGeometry;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tgeometries[ geometry.id ] = buffergeometry;\\n\\n\\t\\t\\tinfoMemory.geometries ++;\\n\\n\\t\\t\\treturn buffergeometry;\\n\\n\\t\\t}\\n\\n\\t\\tfunction update( geometry ) {\\n\\n\\t\\t\\tvar index = geometry.index;\\n\\t\\t\\tvar geometryAttributes = geometry.attributes;\\n\\n\\t\\t\\tif ( index !== null ) {\\n\\n\\t\\t\\t\\tattributes.update( index, gl.ELEMENT_ARRAY_BUFFER );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var name in geometryAttributes ) {\\n\\n\\t\\t\\t\\tattributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// morph targets\\n\\n\\t\\t\\tvar morphAttributes = geometry.morphAttributes;\\n\\n\\t\\t\\tfor ( var name in morphAttributes ) {\\n\\n\\t\\t\\t\\tvar array = morphAttributes[ name ];\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tattributes.update( array[ i ], gl.ARRAY_BUFFER );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction getWireframeAttribute( geometry ) {\\n\\n\\t\\t\\tvar attribute = wireframeAttributes[ geometry.id ];\\n\\n\\t\\t\\tif ( attribute ) return attribute;\\n\\n\\t\\t\\tvar indices = [];\\n\\n\\t\\t\\tvar geometryIndex = geometry.index;\\n\\t\\t\\tvar geometryAttributes = geometry.attributes;\\n\\n\\t\\t\\t// console.time( 'wireframe' );\\n\\n\\t\\t\\tif ( geometryIndex !== null ) {\\n\\n\\t\\t\\t\\tvar array = geometryIndex.array;\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\\n\\n\\t\\t\\t\\t\\tvar a = array[ i + 0 ];\\n\\t\\t\\t\\t\\tvar b = array[ i + 1 ];\\n\\t\\t\\t\\t\\tvar c = array[ i + 2 ];\\n\\n\\t\\t\\t\\t\\tindices.push( a, b, b, c, c, a );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tvar array = geometryAttributes.position.array;\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\\n\\n\\t\\t\\t\\t\\tvar a = i + 0;\\n\\t\\t\\t\\t\\tvar b = i + 1;\\n\\t\\t\\t\\t\\tvar c = i + 2;\\n\\n\\t\\t\\t\\t\\tindices.push( a, b, b, c, c, a );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// console.timeEnd( 'wireframe' );\\n\\n\\t\\t\\tattribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );\\n\\n\\t\\t\\tattributes.update( attribute, gl.ELEMENT_ARRAY_BUFFER );\\n\\n\\t\\t\\twireframeAttributes[ geometry.id ] = attribute;\\n\\n\\t\\t\\treturn attribute;\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tget: get,\\n\\t\\t\\tupdate: update,\\n\\n\\t\\t\\tgetWireframeAttribute: getWireframeAttribute\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction UniformsCache() {\\n\\n\\t\\tvar lights = {};\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tget: function ( light ) {\\n\\n\\t\\t\\t\\tif ( lights[ light.id ] !== undefined ) {\\n\\n\\t\\t\\t\\t\\treturn lights[ light.id ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar uniforms;\\n\\n\\t\\t\\t\\tswitch ( light.type ) {\\n\\n\\t\\t\\t\\t\\tcase 'DirectionalLight':\\n\\t\\t\\t\\t\\t\\tuniforms = {\\n\\t\\t\\t\\t\\t\\t\\tdirection: new Vector3(),\\n\\t\\t\\t\\t\\t\\t\\tcolor: new Color(),\\n\\n\\t\\t\\t\\t\\t\\t\\tshadow: false,\\n\\t\\t\\t\\t\\t\\t\\tshadowBias: 0,\\n\\t\\t\\t\\t\\t\\t\\tshadowRadius: 1,\\n\\t\\t\\t\\t\\t\\t\\tshadowMapSize: new Vector2()\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'SpotLight':\\n\\t\\t\\t\\t\\t\\tuniforms = {\\n\\t\\t\\t\\t\\t\\t\\tposition: new Vector3(),\\n\\t\\t\\t\\t\\t\\t\\tdirection: new Vector3(),\\n\\t\\t\\t\\t\\t\\t\\tcolor: new Color(),\\n\\t\\t\\t\\t\\t\\t\\tdistance: 0,\\n\\t\\t\\t\\t\\t\\t\\tconeCos: 0,\\n\\t\\t\\t\\t\\t\\t\\tpenumbraCos: 0,\\n\\t\\t\\t\\t\\t\\t\\tdecay: 0,\\n\\n\\t\\t\\t\\t\\t\\t\\tshadow: false,\\n\\t\\t\\t\\t\\t\\t\\tshadowBias: 0,\\n\\t\\t\\t\\t\\t\\t\\tshadowRadius: 1,\\n\\t\\t\\t\\t\\t\\t\\tshadowMapSize: new Vector2()\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'PointLight':\\n\\t\\t\\t\\t\\t\\tuniforms = {\\n\\t\\t\\t\\t\\t\\t\\tposition: new Vector3(),\\n\\t\\t\\t\\t\\t\\t\\tcolor: new Color(),\\n\\t\\t\\t\\t\\t\\t\\tdistance: 0,\\n\\t\\t\\t\\t\\t\\t\\tdecay: 0,\\n\\n\\t\\t\\t\\t\\t\\t\\tshadow: false,\\n\\t\\t\\t\\t\\t\\t\\tshadowBias: 0,\\n\\t\\t\\t\\t\\t\\t\\tshadowRadius: 1,\\n\\t\\t\\t\\t\\t\\t\\tshadowMapSize: new Vector2(),\\n\\t\\t\\t\\t\\t\\t\\tshadowCameraNear: 1,\\n\\t\\t\\t\\t\\t\\t\\tshadowCameraFar: 1000\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'HemisphereLight':\\n\\t\\t\\t\\t\\t\\tuniforms = {\\n\\t\\t\\t\\t\\t\\t\\tdirection: new Vector3(),\\n\\t\\t\\t\\t\\t\\t\\tskyColor: new Color(),\\n\\t\\t\\t\\t\\t\\t\\tgroundColor: new Color()\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'RectAreaLight':\\n\\t\\t\\t\\t\\t\\tuniforms = {\\n\\t\\t\\t\\t\\t\\t\\tcolor: new Color(),\\n\\t\\t\\t\\t\\t\\t\\tposition: new Vector3(),\\n\\t\\t\\t\\t\\t\\t\\thalfWidth: new Vector3(),\\n\\t\\t\\t\\t\\t\\t\\thalfHeight: new Vector3()\\n\\t\\t\\t\\t\\t\\t\\t// TODO (abelnation): set RectAreaLight shadow uniforms\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tlights[ light.id ] = uniforms;\\n\\n\\t\\t\\t\\treturn uniforms;\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\tfunction WebGLLights() {\\n\\n\\t\\tvar cache = new UniformsCache();\\n\\n\\t\\tvar state = {\\n\\n\\t\\t\\thash: '',\\n\\n\\t\\t\\tambient: [ 0, 0, 0 ],\\n\\t\\t\\tdirectional: [],\\n\\t\\t\\tdirectionalShadowMap: [],\\n\\t\\t\\tdirectionalShadowMatrix: [],\\n\\t\\t\\tspot: [],\\n\\t\\t\\tspotShadowMap: [],\\n\\t\\t\\tspotShadowMatrix: [],\\n\\t\\t\\trectArea: [],\\n\\t\\t\\tpoint: [],\\n\\t\\t\\tpointShadowMap: [],\\n\\t\\t\\tpointShadowMatrix: [],\\n\\t\\t\\themi: []\\n\\n\\t\\t};\\n\\n\\t\\tvar vector3 = new Vector3();\\n\\t\\tvar matrix4 = new Matrix4();\\n\\t\\tvar matrix42 = new Matrix4();\\n\\n\\t\\tfunction setup( lights, shadows, camera ) {\\n\\n\\t\\t\\tvar r = 0, g = 0, b = 0;\\n\\n\\t\\t\\tvar directionalLength = 0;\\n\\t\\t\\tvar pointLength = 0;\\n\\t\\t\\tvar spotLength = 0;\\n\\t\\t\\tvar rectAreaLength = 0;\\n\\t\\t\\tvar hemiLength = 0;\\n\\n\\t\\t\\tvar viewMatrix = camera.matrixWorldInverse;\\n\\n\\t\\t\\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar light = lights[ i ];\\n\\n\\t\\t\\t\\tvar color = light.color;\\n\\t\\t\\t\\tvar intensity = light.intensity;\\n\\t\\t\\t\\tvar distance = light.distance;\\n\\n\\t\\t\\t\\tvar shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\\n\\n\\t\\t\\t\\tif ( light.isAmbientLight ) {\\n\\n\\t\\t\\t\\t\\tr += color.r * intensity;\\n\\t\\t\\t\\t\\tg += color.g * intensity;\\n\\t\\t\\t\\t\\tb += color.b * intensity;\\n\\n\\t\\t\\t\\t} else if ( light.isDirectionalLight ) {\\n\\n\\t\\t\\t\\t\\tvar uniforms = cache.get( light );\\n\\n\\t\\t\\t\\t\\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\\n\\t\\t\\t\\t\\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\\n\\t\\t\\t\\t\\tvector3.setFromMatrixPosition( light.target.matrixWorld );\\n\\t\\t\\t\\t\\tuniforms.direction.sub( vector3 );\\n\\t\\t\\t\\t\\tuniforms.direction.transformDirection( viewMatrix );\\n\\n\\t\\t\\t\\t\\tuniforms.shadow = light.castShadow;\\n\\n\\t\\t\\t\\t\\tif ( light.castShadow ) {\\n\\n\\t\\t\\t\\t\\t\\tvar shadow = light.shadow;\\n\\n\\t\\t\\t\\t\\t\\tuniforms.shadowBias = shadow.bias;\\n\\t\\t\\t\\t\\t\\tuniforms.shadowRadius = shadow.radius;\\n\\t\\t\\t\\t\\t\\tuniforms.shadowMapSize = shadow.mapSize;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tstate.directionalShadowMap[ directionalLength ] = shadowMap;\\n\\t\\t\\t\\t\\tstate.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\\n\\t\\t\\t\\t\\tstate.directional[ directionalLength ] = uniforms;\\n\\n\\t\\t\\t\\t\\tdirectionalLength ++;\\n\\n\\t\\t\\t\\t} else if ( light.isSpotLight ) {\\n\\n\\t\\t\\t\\t\\tvar uniforms = cache.get( light );\\n\\n\\t\\t\\t\\t\\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\\n\\t\\t\\t\\t\\tuniforms.position.applyMatrix4( viewMatrix );\\n\\n\\t\\t\\t\\t\\tuniforms.color.copy( color ).multiplyScalar( intensity );\\n\\t\\t\\t\\t\\tuniforms.distance = distance;\\n\\n\\t\\t\\t\\t\\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\\n\\t\\t\\t\\t\\tvector3.setFromMatrixPosition( light.target.matrixWorld );\\n\\t\\t\\t\\t\\tuniforms.direction.sub( vector3 );\\n\\t\\t\\t\\t\\tuniforms.direction.transformDirection( viewMatrix );\\n\\n\\t\\t\\t\\t\\tuniforms.coneCos = Math.cos( light.angle );\\n\\t\\t\\t\\t\\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\\n\\t\\t\\t\\t\\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\\n\\n\\t\\t\\t\\t\\tuniforms.shadow = light.castShadow;\\n\\n\\t\\t\\t\\t\\tif ( light.castShadow ) {\\n\\n\\t\\t\\t\\t\\t\\tvar shadow = light.shadow;\\n\\n\\t\\t\\t\\t\\t\\tuniforms.shadowBias = shadow.bias;\\n\\t\\t\\t\\t\\t\\tuniforms.shadowRadius = shadow.radius;\\n\\t\\t\\t\\t\\t\\tuniforms.shadowMapSize = shadow.mapSize;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tstate.spotShadowMap[ spotLength ] = shadowMap;\\n\\t\\t\\t\\t\\tstate.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\\n\\t\\t\\t\\t\\tstate.spot[ spotLength ] = uniforms;\\n\\n\\t\\t\\t\\t\\tspotLength ++;\\n\\n\\t\\t\\t\\t} else if ( light.isRectAreaLight ) {\\n\\n\\t\\t\\t\\t\\tvar uniforms = cache.get( light );\\n\\n\\t\\t\\t\\t\\t// (a) intensity controls irradiance of entire light\\n\\t\\t\\t\\t\\tuniforms.color\\n\\t\\t\\t\\t\\t\\t.copy( color )\\n\\t\\t\\t\\t\\t\\t.multiplyScalar( intensity / ( light.width * light.height ) );\\n\\n\\t\\t\\t\\t\\t// (b) intensity controls the radiance per light area\\n\\t\\t\\t\\t\\t// uniforms.color.copy( color ).multiplyScalar( intensity );\\n\\n\\t\\t\\t\\t\\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\\n\\t\\t\\t\\t\\tuniforms.position.applyMatrix4( viewMatrix );\\n\\n\\t\\t\\t\\t\\t// extract local rotation of light to derive width/height half vectors\\n\\t\\t\\t\\t\\tmatrix42.identity();\\n\\t\\t\\t\\t\\tmatrix4.copy( light.matrixWorld );\\n\\t\\t\\t\\t\\tmatrix4.premultiply( viewMatrix );\\n\\t\\t\\t\\t\\tmatrix42.extractRotation( matrix4 );\\n\\n\\t\\t\\t\\t\\tuniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );\\n\\t\\t\\t\\t\\tuniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );\\n\\n\\t\\t\\t\\t\\tuniforms.halfWidth.applyMatrix4( matrix42 );\\n\\t\\t\\t\\t\\tuniforms.halfHeight.applyMatrix4( matrix42 );\\n\\n\\t\\t\\t\\t\\t// TODO (abelnation): RectAreaLight distance?\\n\\t\\t\\t\\t\\t// uniforms.distance = distance;\\n\\n\\t\\t\\t\\t\\tstate.rectArea[ rectAreaLength ] = uniforms;\\n\\n\\t\\t\\t\\t\\trectAreaLength ++;\\n\\n\\t\\t\\t\\t} else if ( light.isPointLight ) {\\n\\n\\t\\t\\t\\t\\tvar uniforms = cache.get( light );\\n\\n\\t\\t\\t\\t\\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\\n\\t\\t\\t\\t\\tuniforms.position.applyMatrix4( viewMatrix );\\n\\n\\t\\t\\t\\t\\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\\n\\t\\t\\t\\t\\tuniforms.distance = light.distance;\\n\\t\\t\\t\\t\\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\\n\\n\\t\\t\\t\\t\\tuniforms.shadow = light.castShadow;\\n\\n\\t\\t\\t\\t\\tif ( light.castShadow ) {\\n\\n\\t\\t\\t\\t\\t\\tvar shadow = light.shadow;\\n\\n\\t\\t\\t\\t\\t\\tuniforms.shadowBias = shadow.bias;\\n\\t\\t\\t\\t\\t\\tuniforms.shadowRadius = shadow.radius;\\n\\t\\t\\t\\t\\t\\tuniforms.shadowMapSize = shadow.mapSize;\\n\\t\\t\\t\\t\\t\\tuniforms.shadowCameraNear = shadow.camera.near;\\n\\t\\t\\t\\t\\t\\tuniforms.shadowCameraFar = shadow.camera.far;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tstate.pointShadowMap[ pointLength ] = shadowMap;\\n\\t\\t\\t\\t\\tstate.pointShadowMatrix[ pointLength ] = light.shadow.matrix;\\n\\t\\t\\t\\t\\tstate.point[ pointLength ] = uniforms;\\n\\n\\t\\t\\t\\t\\tpointLength ++;\\n\\n\\t\\t\\t\\t} else if ( light.isHemisphereLight ) {\\n\\n\\t\\t\\t\\t\\tvar uniforms = cache.get( light );\\n\\n\\t\\t\\t\\t\\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\\n\\t\\t\\t\\t\\tuniforms.direction.transformDirection( viewMatrix );\\n\\t\\t\\t\\t\\tuniforms.direction.normalize();\\n\\n\\t\\t\\t\\t\\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\\n\\t\\t\\t\\t\\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\\n\\n\\t\\t\\t\\t\\tstate.hemi[ hemiLength ] = uniforms;\\n\\n\\t\\t\\t\\t\\themiLength ++;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tstate.ambient[ 0 ] = r;\\n\\t\\t\\tstate.ambient[ 1 ] = g;\\n\\t\\t\\tstate.ambient[ 2 ] = b;\\n\\n\\t\\t\\tstate.directional.length = directionalLength;\\n\\t\\t\\tstate.spot.length = spotLength;\\n\\t\\t\\tstate.rectArea.length = rectAreaLength;\\n\\t\\t\\tstate.point.length = pointLength;\\n\\t\\t\\tstate.hemi.length = hemiLength;\\n\\n\\t\\t\\t// TODO (sam-g-steel) why aren't we using join\\n\\t\\t\\tstate.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + rectAreaLength + ',' + hemiLength + ',' + shadows.length;\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\tsetup: setup,\\n\\t\\t\\tstate: state\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLObjects( geometries, infoRender ) {\\n\\n\\t\\tvar updateList = {};\\n\\n\\t\\tfunction update( object ) {\\n\\n\\t\\t\\tvar frame = infoRender.frame;\\n\\n\\t\\t\\tvar geometry = object.geometry;\\n\\t\\t\\tvar buffergeometry = geometries.get( object, geometry );\\n\\n\\t\\t\\t// Update once per frame\\n\\n\\t\\t\\tif ( updateList[ buffergeometry.id ] !== frame ) {\\n\\n\\t\\t\\t\\tif ( geometry.isGeometry ) {\\n\\n\\t\\t\\t\\t\\tbuffergeometry.updateFromObject( object );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgeometries.update( buffergeometry );\\n\\n\\t\\t\\t\\tupdateList[ buffergeometry.id ] = frame;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn buffergeometry;\\n\\n\\t\\t}\\n\\n\\t\\tfunction clear() {\\n\\n\\t\\t\\tupdateList = {};\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tupdate: update,\\n\\t\\t\\tclear: clear\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction addLineNumbers( string ) {\\n\\n\\t\\tvar lines = string.split( '\\\\n' );\\n\\n\\t\\tfor ( var i = 0; i < lines.length; i ++ ) {\\n\\n\\t\\t\\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\\n\\n\\t\\t}\\n\\n\\t\\treturn lines.join( '\\\\n' );\\n\\n\\t}\\n\\n\\tfunction WebGLShader( gl, type, string ) {\\n\\n\\t\\tvar shader = gl.createShader( type );\\n\\n\\t\\tgl.shaderSource( shader, string );\\n\\t\\tgl.compileShader( shader );\\n\\n\\t\\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.WebGLShader: Shader couldn\\\\'t compile.' );\\n\\n\\t\\t}\\n\\n\\t\\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\\n\\n\\t\\t}\\n\\n\\t\\t// --enable-privileged-webgl-extension\\n\\t\\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\\n\\n\\t\\treturn shader;\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tvar programIdCount = 0;\\n\\n\\tfunction getEncodingComponents( encoding ) {\\n\\n\\t\\tswitch ( encoding ) {\\n\\n\\t\\t\\tcase LinearEncoding:\\n\\t\\t\\t\\treturn [ 'Linear', '( value )' ];\\n\\t\\t\\tcase sRGBEncoding:\\n\\t\\t\\t\\treturn [ 'sRGB', '( value )' ];\\n\\t\\t\\tcase RGBEEncoding:\\n\\t\\t\\t\\treturn [ 'RGBE', '( value )' ];\\n\\t\\t\\tcase RGBM7Encoding:\\n\\t\\t\\t\\treturn [ 'RGBM', '( value, 7.0 )' ];\\n\\t\\t\\tcase RGBM16Encoding:\\n\\t\\t\\t\\treturn [ 'RGBM', '( value, 16.0 )' ];\\n\\t\\t\\tcase RGBDEncoding:\\n\\t\\t\\t\\treturn [ 'RGBD', '( value, 256.0 )' ];\\n\\t\\t\\tcase GammaEncoding:\\n\\t\\t\\t\\treturn [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tthrow new Error( 'unsupported encoding: ' + encoding );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction getTexelDecodingFunction( functionName, encoding ) {\\n\\n\\t\\tvar components = getEncodingComponents( encoding );\\n\\t\\treturn 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';\\n\\n\\t}\\n\\n\\tfunction getTexelEncodingFunction( functionName, encoding ) {\\n\\n\\t\\tvar components = getEncodingComponents( encoding );\\n\\t\\treturn 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';\\n\\n\\t}\\n\\n\\tfunction getToneMappingFunction( functionName, toneMapping ) {\\n\\n\\t\\tvar toneMappingName;\\n\\n\\t\\tswitch ( toneMapping ) {\\n\\n\\t\\t\\tcase LinearToneMapping:\\n\\t\\t\\t\\ttoneMappingName = 'Linear';\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase ReinhardToneMapping:\\n\\t\\t\\t\\ttoneMappingName = 'Reinhard';\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase Uncharted2ToneMapping:\\n\\t\\t\\t\\ttoneMappingName = 'Uncharted2';\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase CineonToneMapping:\\n\\t\\t\\t\\ttoneMappingName = 'OptimizedCineon';\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\\n\\n\\t\\t}\\n\\n\\t\\treturn 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';\\n\\n\\t}\\n\\n\\tfunction generateExtensions( extensions, parameters, rendererExtensions ) {\\n\\n\\t\\textensions = extensions || {};\\n\\n\\t\\tvar chunks = [\\n\\t\\t\\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\\n\\t\\t\\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\\n\\t\\t\\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\\n\\t\\t\\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''\\n\\t\\t];\\n\\n\\t\\treturn chunks.filter( filterEmptyLine ).join( '\\\\n' );\\n\\n\\t}\\n\\n\\tfunction generateDefines( defines ) {\\n\\n\\t\\tvar chunks = [];\\n\\n\\t\\tfor ( var name in defines ) {\\n\\n\\t\\t\\tvar value = defines[ name ];\\n\\n\\t\\t\\tif ( value === false ) continue;\\n\\n\\t\\t\\tchunks.push( '#define ' + name + ' ' + value );\\n\\n\\t\\t}\\n\\n\\t\\treturn chunks.join( '\\\\n' );\\n\\n\\t}\\n\\n\\tfunction fetchAttributeLocations( gl, program ) {\\n\\n\\t\\tvar attributes = {};\\n\\n\\t\\tvar n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\\n\\n\\t\\tfor ( var i = 0; i < n; i ++ ) {\\n\\n\\t\\t\\tvar info = gl.getActiveAttrib( program, i );\\n\\t\\t\\tvar name = info.name;\\n\\n\\t\\t\\t// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );\\n\\n\\t\\t\\tattributes[ name ] = gl.getAttribLocation( program, name );\\n\\n\\t\\t}\\n\\n\\t\\treturn attributes;\\n\\n\\t}\\n\\n\\tfunction filterEmptyLine( string ) {\\n\\n\\t\\treturn string !== '';\\n\\n\\t}\\n\\n\\tfunction replaceLightNums( string, parameters ) {\\n\\n\\t\\treturn string\\n\\t\\t\\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\\n\\t\\t\\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\\n\\t\\t\\t.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )\\n\\t\\t\\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\\n\\t\\t\\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\\n\\n\\t}\\n\\n\\tfunction parseIncludes( string ) {\\n\\n\\t\\tvar pattern = /^[ \\\\t]*#include +<([\\\\w\\\\d.]+)>/gm;\\n\\n\\t\\tfunction replace( match, include ) {\\n\\n\\t\\t\\tvar replace = ShaderChunk[ include ];\\n\\n\\t\\t\\tif ( replace === undefined ) {\\n\\n\\t\\t\\t\\tthrow new Error( 'Can not resolve #include <' + include + '>' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn parseIncludes( replace );\\n\\n\\t\\t}\\n\\n\\t\\treturn string.replace( pattern, replace );\\n\\n\\t}\\n\\n\\tfunction unrollLoops( string ) {\\n\\n\\t\\tvar pattern = /for \\\\( int i \\\\= (\\\\d+)\\\\; i < (\\\\d+)\\\\; i \\\\+\\\\+ \\\\) \\\\{([\\\\s\\\\S]+?)(?=\\\\})\\\\}/g;\\n\\n\\t\\tfunction replace( match, start, end, snippet ) {\\n\\n\\t\\t\\tvar unroll = '';\\n\\n\\t\\t\\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\\n\\n\\t\\t\\t\\tunroll += snippet.replace( /\\\\[ i \\\\]/g, '[ ' + i + ' ]' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn unroll;\\n\\n\\t\\t}\\n\\n\\t\\treturn string.replace( pattern, replace );\\n\\n\\t}\\n\\n\\tfunction WebGLProgram( renderer, extensions, code, material, shader, parameters ) {\\n\\n\\t\\tvar gl = renderer.context;\\n\\n\\t\\tvar defines = material.defines;\\n\\n\\t\\tvar vertexShader = shader.vertexShader;\\n\\t\\tvar fragmentShader = shader.fragmentShader;\\n\\n\\t\\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\\n\\n\\t\\tif ( parameters.shadowMapType === PCFShadowMap ) {\\n\\n\\t\\t\\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\\n\\n\\t\\t} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {\\n\\n\\t\\t\\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\\n\\n\\t\\t}\\n\\n\\t\\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\\n\\t\\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\\n\\t\\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\\n\\n\\t\\tif ( parameters.envMap ) {\\n\\n\\t\\t\\tswitch ( material.envMap.mapping ) {\\n\\n\\t\\t\\t\\tcase CubeReflectionMapping:\\n\\t\\t\\t\\tcase CubeRefractionMapping:\\n\\t\\t\\t\\t\\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase CubeUVReflectionMapping:\\n\\t\\t\\t\\tcase CubeUVRefractionMapping:\\n\\t\\t\\t\\t\\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase EquirectangularReflectionMapping:\\n\\t\\t\\t\\tcase EquirectangularRefractionMapping:\\n\\t\\t\\t\\t\\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase SphericalReflectionMapping:\\n\\t\\t\\t\\t\\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tswitch ( material.envMap.mapping ) {\\n\\n\\t\\t\\t\\tcase CubeRefractionMapping:\\n\\t\\t\\t\\tcase EquirectangularRefractionMapping:\\n\\t\\t\\t\\t\\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tswitch ( material.combine ) {\\n\\n\\t\\t\\t\\tcase MultiplyOperation:\\n\\t\\t\\t\\t\\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase MixOperation:\\n\\t\\t\\t\\t\\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase AddOperation:\\n\\t\\t\\t\\t\\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\\n\\n\\t\\t// console.log( 'building new program ' );\\n\\n\\t\\t//\\n\\n\\t\\tvar customExtensions = generateExtensions( material.extensions, parameters, extensions );\\n\\n\\t\\tvar customDefines = generateDefines( defines );\\n\\n\\t\\t//\\n\\n\\t\\tvar program = gl.createProgram();\\n\\n\\t\\tvar prefixVertex, prefixFragment;\\n\\n\\t\\tif ( material.isRawShaderMaterial ) {\\n\\n\\t\\t\\tprefixVertex = [\\n\\n\\t\\t\\t\\tcustomDefines\\n\\n\\t\\t\\t].filter( filterEmptyLine ).join( '\\\\n' );\\n\\n\\t\\t\\tif ( prefixVertex.length > 0 ) {\\n\\n\\t\\t\\t\\tprefixVertex += '\\\\n';\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tprefixFragment = [\\n\\n\\t\\t\\t\\tcustomExtensions,\\n\\t\\t\\t\\tcustomDefines\\n\\n\\t\\t\\t].filter( filterEmptyLine ).join( '\\\\n' );\\n\\n\\t\\t\\tif ( prefixFragment.length > 0 ) {\\n\\n\\t\\t\\t\\tprefixFragment += '\\\\n';\\n\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tprefixVertex = [\\n\\n\\t\\t\\t\\t'precision ' + parameters.precision + ' float;',\\n\\t\\t\\t\\t'precision ' + parameters.precision + ' int;',\\n\\n\\t\\t\\t\\t'#define SHADER_NAME ' + shader.name,\\n\\n\\t\\t\\t\\tcustomDefines,\\n\\n\\t\\t\\t\\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\\n\\n\\t\\t\\t\\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\\n\\n\\t\\t\\t\\t'#define MAX_BONES ' + parameters.maxBones,\\n\\t\\t\\t\\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\\n\\t\\t\\t\\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\\n\\n\\t\\t\\t\\tparameters.map ? '#define USE_MAP' : '',\\n\\t\\t\\t\\tparameters.envMap ? '#define USE_ENVMAP' : '',\\n\\t\\t\\t\\tparameters.envMap ? '#define ' + envMapModeDefine : '',\\n\\t\\t\\t\\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\\n\\t\\t\\t\\tparameters.aoMap ? '#define USE_AOMAP' : '',\\n\\t\\t\\t\\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\\n\\t\\t\\t\\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\\n\\t\\t\\t\\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\\n\\t\\t\\t\\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\\n\\t\\t\\t\\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\\n\\t\\t\\t\\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\\n\\t\\t\\t\\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\\n\\t\\t\\t\\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\\n\\t\\t\\t\\tparameters.vertexColors ? '#define USE_COLOR' : '',\\n\\n\\t\\t\\t\\tparameters.flatShading ? '#define FLAT_SHADED' : '',\\n\\n\\t\\t\\t\\tparameters.skinning ? '#define USE_SKINNING' : '',\\n\\t\\t\\t\\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\\n\\n\\t\\t\\t\\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\\n\\t\\t\\t\\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\\n\\t\\t\\t\\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\\n\\t\\t\\t\\tparameters.flipSided ? '#define FLIP_SIDED' : '',\\n\\n\\t\\t\\t\\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\\n\\n\\t\\t\\t\\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\\n\\t\\t\\t\\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\\n\\n\\t\\t\\t\\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\\n\\n\\t\\t\\t\\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\\n\\t\\t\\t\\tparameters.logarithmicDepthBuffer && extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\\n\\n\\t\\t\\t\\t'uniform mat4 modelMatrix;',\\n\\t\\t\\t\\t'uniform mat4 modelViewMatrix;',\\n\\t\\t\\t\\t'uniform mat4 projectionMatrix;',\\n\\t\\t\\t\\t'uniform mat4 viewMatrix;',\\n\\t\\t\\t\\t'uniform mat3 normalMatrix;',\\n\\t\\t\\t\\t'uniform vec3 cameraPosition;',\\n\\n\\t\\t\\t\\t'attribute vec3 position;',\\n\\t\\t\\t\\t'attribute vec3 normal;',\\n\\t\\t\\t\\t'attribute vec2 uv;',\\n\\n\\t\\t\\t\\t'#ifdef USE_COLOR',\\n\\n\\t\\t\\t\\t'\\tattribute vec3 color;',\\n\\n\\t\\t\\t\\t'#endif',\\n\\n\\t\\t\\t\\t'#ifdef USE_MORPHTARGETS',\\n\\n\\t\\t\\t\\t'\\tattribute vec3 morphTarget0;',\\n\\t\\t\\t\\t'\\tattribute vec3 morphTarget1;',\\n\\t\\t\\t\\t'\\tattribute vec3 morphTarget2;',\\n\\t\\t\\t\\t'\\tattribute vec3 morphTarget3;',\\n\\n\\t\\t\\t\\t'\\t#ifdef USE_MORPHNORMALS',\\n\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphNormal0;',\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphNormal1;',\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphNormal2;',\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphNormal3;',\\n\\n\\t\\t\\t\\t'\\t#else',\\n\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphTarget4;',\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphTarget5;',\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphTarget6;',\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphTarget7;',\\n\\n\\t\\t\\t\\t'\\t#endif',\\n\\n\\t\\t\\t\\t'#endif',\\n\\n\\t\\t\\t\\t'#ifdef USE_SKINNING',\\n\\n\\t\\t\\t\\t'\\tattribute vec4 skinIndex;',\\n\\t\\t\\t\\t'\\tattribute vec4 skinWeight;',\\n\\n\\t\\t\\t\\t'#endif',\\n\\n\\t\\t\\t\\t'\\\\n'\\n\\n\\t\\t\\t].filter( filterEmptyLine ).join( '\\\\n' );\\n\\n\\t\\t\\tprefixFragment = [\\n\\n\\t\\t\\t\\tcustomExtensions,\\n\\n\\t\\t\\t\\t'precision ' + parameters.precision + ' float;',\\n\\t\\t\\t\\t'precision ' + parameters.precision + ' int;',\\n\\n\\t\\t\\t\\t'#define SHADER_NAME ' + shader.name,\\n\\n\\t\\t\\t\\tcustomDefines,\\n\\n\\t\\t\\t\\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\\n\\n\\t\\t\\t\\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\\n\\n\\t\\t\\t\\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\\n\\t\\t\\t\\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\\n\\n\\t\\t\\t\\tparameters.map ? '#define USE_MAP' : '',\\n\\t\\t\\t\\tparameters.envMap ? '#define USE_ENVMAP' : '',\\n\\t\\t\\t\\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\\n\\t\\t\\t\\tparameters.envMap ? '#define ' + envMapModeDefine : '',\\n\\t\\t\\t\\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\\n\\t\\t\\t\\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\\n\\t\\t\\t\\tparameters.aoMap ? '#define USE_AOMAP' : '',\\n\\t\\t\\t\\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\\n\\t\\t\\t\\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\\n\\t\\t\\t\\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\\n\\t\\t\\t\\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\\n\\t\\t\\t\\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\\n\\t\\t\\t\\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\\n\\t\\t\\t\\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\\n\\t\\t\\t\\tparameters.vertexColors ? '#define USE_COLOR' : '',\\n\\n\\t\\t\\t\\tparameters.gradientMap ? '#define USE_GRADIENTMAP' : '',\\n\\n\\t\\t\\t\\tparameters.flatShading ? '#define FLAT_SHADED' : '',\\n\\n\\t\\t\\t\\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\\n\\t\\t\\t\\tparameters.flipSided ? '#define FLIP_SIDED' : '',\\n\\n\\t\\t\\t\\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\\n\\t\\t\\t\\t'#define UNION_CLIPPING_PLANES ' + ( parameters.numClippingPlanes - parameters.numClipIntersection ),\\n\\n\\t\\t\\t\\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\\n\\t\\t\\t\\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\\n\\n\\t\\t\\t\\tparameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',\\n\\n\\t\\t\\t\\tparameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',\\n\\n\\t\\t\\t\\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\\n\\t\\t\\t\\tparameters.logarithmicDepthBuffer && extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\\n\\n\\t\\t\\t\\tparameters.envMap && extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\\n\\n\\t\\t\\t\\t'uniform mat4 viewMatrix;',\\n\\t\\t\\t\\t'uniform vec3 cameraPosition;',\\n\\n\\t\\t\\t\\t( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',\\n\\t\\t\\t\\t( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below\\n\\t\\t\\t\\t( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',\\n\\n\\t\\t\\t\\tparameters.dithering ? '#define DITHERING' : '',\\n\\n\\t\\t\\t\\t( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\\n\\t\\t\\t\\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\\n\\t\\t\\t\\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\\n\\t\\t\\t\\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\\n\\t\\t\\t\\tparameters.outputEncoding ? getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ) : '',\\n\\n\\t\\t\\t\\tparameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '',\\n\\n\\t\\t\\t\\t'\\\\n'\\n\\n\\t\\t\\t].filter( filterEmptyLine ).join( '\\\\n' );\\n\\n\\t\\t}\\n\\n\\t\\tvertexShader = parseIncludes( vertexShader );\\n\\t\\tvertexShader = replaceLightNums( vertexShader, parameters );\\n\\n\\t\\tfragmentShader = parseIncludes( fragmentShader );\\n\\t\\tfragmentShader = replaceLightNums( fragmentShader, parameters );\\n\\n\\t\\tif ( ! material.isShaderMaterial ) {\\n\\n\\t\\t\\tvertexShader = unrollLoops( vertexShader );\\n\\t\\t\\tfragmentShader = unrollLoops( fragmentShader );\\n\\n\\t\\t}\\n\\n\\t\\tvar vertexGlsl = prefixVertex + vertexShader;\\n\\t\\tvar fragmentGlsl = prefixFragment + fragmentShader;\\n\\n\\t\\t// console.log( '*VERTEX*', vertexGlsl );\\n\\t\\t// console.log( '*FRAGMENT*', fragmentGlsl );\\n\\n\\t\\tvar glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\\n\\t\\tvar glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\\n\\n\\t\\tgl.attachShader( program, glVertexShader );\\n\\t\\tgl.attachShader( program, glFragmentShader );\\n\\n\\t\\t// Force a particular attribute to index 0.\\n\\n\\t\\tif ( material.index0AttributeName !== undefined ) {\\n\\n\\t\\t\\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\\n\\n\\t\\t} else if ( parameters.morphTargets === true ) {\\n\\n\\t\\t\\t// programs with morphTargets displace position out of attribute 0\\n\\t\\t\\tgl.bindAttribLocation( program, 0, 'position' );\\n\\n\\t\\t}\\n\\n\\t\\tgl.linkProgram( program );\\n\\n\\t\\tvar programLog = gl.getProgramInfoLog( program );\\n\\t\\tvar vertexLog = gl.getShaderInfoLog( glVertexShader );\\n\\t\\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader );\\n\\n\\t\\tvar runnable = true;\\n\\t\\tvar haveDiagnostics = true;\\n\\n\\t\\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\\n\\t\\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\\n\\n\\t\\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\\n\\n\\t\\t\\trunnable = false;\\n\\n\\t\\t\\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\\n\\n\\t\\t} else if ( programLog !== '' ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\\n\\n\\t\\t} else if ( vertexLog === '' || fragmentLog === '' ) {\\n\\n\\t\\t\\thaveDiagnostics = false;\\n\\n\\t\\t}\\n\\n\\t\\tif ( haveDiagnostics ) {\\n\\n\\t\\t\\tthis.diagnostics = {\\n\\n\\t\\t\\t\\trunnable: runnable,\\n\\t\\t\\t\\tmaterial: material,\\n\\n\\t\\t\\t\\tprogramLog: programLog,\\n\\n\\t\\t\\t\\tvertexShader: {\\n\\n\\t\\t\\t\\t\\tlog: vertexLog,\\n\\t\\t\\t\\t\\tprefix: prefixVertex\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tfragmentShader: {\\n\\n\\t\\t\\t\\t\\tlog: fragmentLog,\\n\\t\\t\\t\\t\\tprefix: prefixFragment\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}\\n\\n\\t\\t// clean up\\n\\n\\t\\tgl.deleteShader( glVertexShader );\\n\\t\\tgl.deleteShader( glFragmentShader );\\n\\n\\t\\t// set up caching for uniform locations\\n\\n\\t\\tvar cachedUniforms;\\n\\n\\t\\tthis.getUniforms = function () {\\n\\n\\t\\t\\tif ( cachedUniforms === undefined ) {\\n\\n\\t\\t\\t\\tcachedUniforms = new WebGLUniforms( gl, program, renderer );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn cachedUniforms;\\n\\n\\t\\t};\\n\\n\\t\\t// set up caching for attribute locations\\n\\n\\t\\tvar cachedAttributes;\\n\\n\\t\\tthis.getAttributes = function () {\\n\\n\\t\\t\\tif ( cachedAttributes === undefined ) {\\n\\n\\t\\t\\t\\tcachedAttributes = fetchAttributeLocations( gl, program );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn cachedAttributes;\\n\\n\\t\\t};\\n\\n\\t\\t// free resource\\n\\n\\t\\tthis.destroy = function () {\\n\\n\\t\\t\\tgl.deleteProgram( program );\\n\\t\\t\\tthis.program = undefined;\\n\\n\\t\\t};\\n\\n\\t\\t// DEPRECATED\\n\\n\\t\\tObject.defineProperties( this, {\\n\\n\\t\\t\\tuniforms: {\\n\\t\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\\n\\t\\t\\t\\t\\treturn this.getUniforms();\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\n\\t\\t\\tattributes: {\\n\\t\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\\n\\t\\t\\t\\t\\treturn this.getAttributes();\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t} );\\n\\n\\n\\t\\t//\\n\\n\\t\\tthis.id = programIdCount ++;\\n\\t\\tthis.code = code;\\n\\t\\tthis.usedTimes = 1;\\n\\t\\tthis.program = program;\\n\\t\\tthis.vertexShader = glVertexShader;\\n\\t\\tthis.fragmentShader = glFragmentShader;\\n\\n\\t\\treturn this;\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLPrograms( renderer, extensions, capabilities ) {\\n\\n\\t\\tvar programs = [];\\n\\n\\t\\tvar shaderIDs = {\\n\\t\\t\\tMeshDepthMaterial: 'depth',\\n\\t\\t\\tMeshDistanceMaterial: 'distanceRGBA',\\n\\t\\t\\tMeshNormalMaterial: 'normal',\\n\\t\\t\\tMeshBasicMaterial: 'basic',\\n\\t\\t\\tMeshLambertMaterial: 'lambert',\\n\\t\\t\\tMeshPhongMaterial: 'phong',\\n\\t\\t\\tMeshToonMaterial: 'phong',\\n\\t\\t\\tMeshStandardMaterial: 'physical',\\n\\t\\t\\tMeshPhysicalMaterial: 'physical',\\n\\t\\t\\tLineBasicMaterial: 'basic',\\n\\t\\t\\tLineDashedMaterial: 'dashed',\\n\\t\\t\\tPointsMaterial: 'points',\\n\\t\\t\\tShadowMaterial: 'shadow'\\n\\t\\t};\\n\\n\\t\\tvar parameterNames = [\\n\\t\\t\\t\\\"precision\\\", \\\"supportsVertexTextures\\\", \\\"map\\\", \\\"mapEncoding\\\", \\\"envMap\\\", \\\"envMapMode\\\", \\\"envMapEncoding\\\",\\n\\t\\t\\t\\\"lightMap\\\", \\\"aoMap\\\", \\\"emissiveMap\\\", \\\"emissiveMapEncoding\\\", \\\"bumpMap\\\", \\\"normalMap\\\", \\\"displacementMap\\\", \\\"specularMap\\\",\\n\\t\\t\\t\\\"roughnessMap\\\", \\\"metalnessMap\\\", \\\"gradientMap\\\",\\n\\t\\t\\t\\\"alphaMap\\\", \\\"combine\\\", \\\"vertexColors\\\", \\\"fog\\\", \\\"useFog\\\", \\\"fogExp\\\",\\n\\t\\t\\t\\\"flatShading\\\", \\\"sizeAttenuation\\\", \\\"logarithmicDepthBuffer\\\", \\\"skinning\\\",\\n\\t\\t\\t\\\"maxBones\\\", \\\"useVertexTexture\\\", \\\"morphTargets\\\", \\\"morphNormals\\\",\\n\\t\\t\\t\\\"maxMorphTargets\\\", \\\"maxMorphNormals\\\", \\\"premultipliedAlpha\\\",\\n\\t\\t\\t\\\"numDirLights\\\", \\\"numPointLights\\\", \\\"numSpotLights\\\", \\\"numHemiLights\\\", \\\"numRectAreaLights\\\",\\n\\t\\t\\t\\\"shadowMapEnabled\\\", \\\"shadowMapType\\\", \\\"toneMapping\\\", 'physicallyCorrectLights',\\n\\t\\t\\t\\\"alphaTest\\\", \\\"doubleSided\\\", \\\"flipSided\\\", \\\"numClippingPlanes\\\", \\\"numClipIntersection\\\", \\\"depthPacking\\\", \\\"dithering\\\"\\n\\t\\t];\\n\\n\\n\\t\\tfunction allocateBones( object ) {\\n\\n\\t\\t\\tvar skeleton = object.skeleton;\\n\\t\\t\\tvar bones = skeleton.bones;\\n\\n\\t\\t\\tif ( capabilities.floatVertexTextures ) {\\n\\n\\t\\t\\t\\treturn 1024;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// default for when object is not specified\\n\\t\\t\\t\\t// ( for example when prebuilding shader to be used with multiple objects )\\n\\t\\t\\t\\t//\\n\\t\\t\\t\\t//  - leave some extra space for other uniforms\\n\\t\\t\\t\\t//  - limit here is ANGLE's 254 max uniform vectors\\n\\t\\t\\t\\t//    (up to 54 should be safe)\\n\\n\\t\\t\\t\\tvar nVertexUniforms = capabilities.maxVertexUniforms;\\n\\t\\t\\t\\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\\n\\n\\t\\t\\t\\tvar maxBones = Math.min( nVertexMatrices, bones.length );\\n\\n\\t\\t\\t\\tif ( maxBones < bones.length ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );\\n\\t\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn maxBones;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\\n\\n\\t\\t\\tvar encoding;\\n\\n\\t\\t\\tif ( ! map ) {\\n\\n\\t\\t\\t\\tencoding = LinearEncoding;\\n\\n\\t\\t\\t} else if ( map.isTexture ) {\\n\\n\\t\\t\\t\\tencoding = map.encoding;\\n\\n\\t\\t\\t} else if ( map.isWebGLRenderTarget ) {\\n\\n\\t\\t\\t\\tconsole.warn( \\\"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\\\" );\\n\\t\\t\\t\\tencoding = map.texture.encoding;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\\n\\t\\t\\tif ( encoding === LinearEncoding && gammaOverrideLinear ) {\\n\\n\\t\\t\\t\\tencoding = GammaEncoding;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn encoding;\\n\\n\\t\\t}\\n\\n\\t\\tthis.getParameters = function ( material, lights, shadows, fog, nClipPlanes, nClipIntersection, object ) {\\n\\n\\t\\t\\tvar shaderID = shaderIDs[ material.type ];\\n\\n\\t\\t\\t// heuristics to create shader parameters according to lights in the scene\\n\\t\\t\\t// (not to blow over maxLights budget)\\n\\n\\t\\t\\tvar maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;\\n\\t\\t\\tvar precision = capabilities.precision;\\n\\n\\t\\t\\tif ( material.precision !== null ) {\\n\\n\\t\\t\\t\\tprecision = capabilities.getMaxPrecision( material.precision );\\n\\n\\t\\t\\t\\tif ( precision !== material.precision ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar currentRenderTarget = renderer.getRenderTarget();\\n\\n\\t\\t\\tvar parameters = {\\n\\n\\t\\t\\t\\tshaderID: shaderID,\\n\\n\\t\\t\\t\\tprecision: precision,\\n\\t\\t\\t\\tsupportsVertexTextures: capabilities.vertexTextures,\\n\\t\\t\\t\\toutputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),\\n\\t\\t\\t\\tmap: !! material.map,\\n\\t\\t\\t\\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\\n\\t\\t\\t\\tenvMap: !! material.envMap,\\n\\t\\t\\t\\tenvMapMode: material.envMap && material.envMap.mapping,\\n\\t\\t\\t\\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\\n\\t\\t\\t\\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),\\n\\t\\t\\t\\tlightMap: !! material.lightMap,\\n\\t\\t\\t\\taoMap: !! material.aoMap,\\n\\t\\t\\t\\temissiveMap: !! material.emissiveMap,\\n\\t\\t\\t\\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\\n\\t\\t\\t\\tbumpMap: !! material.bumpMap,\\n\\t\\t\\t\\tnormalMap: !! material.normalMap,\\n\\t\\t\\t\\tdisplacementMap: !! material.displacementMap,\\n\\t\\t\\t\\troughnessMap: !! material.roughnessMap,\\n\\t\\t\\t\\tmetalnessMap: !! material.metalnessMap,\\n\\t\\t\\t\\tspecularMap: !! material.specularMap,\\n\\t\\t\\t\\talphaMap: !! material.alphaMap,\\n\\n\\t\\t\\t\\tgradientMap: !! material.gradientMap,\\n\\n\\t\\t\\t\\tcombine: material.combine,\\n\\n\\t\\t\\t\\tvertexColors: material.vertexColors,\\n\\n\\t\\t\\t\\tfog: !! fog,\\n\\t\\t\\t\\tuseFog: material.fog,\\n\\t\\t\\t\\tfogExp: ( fog && fog.isFogExp2 ),\\n\\n\\t\\t\\t\\tflatShading: material.flatShading,\\n\\n\\t\\t\\t\\tsizeAttenuation: material.sizeAttenuation,\\n\\t\\t\\t\\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\\n\\n\\t\\t\\t\\tskinning: material.skinning && maxBones > 0,\\n\\t\\t\\t\\tmaxBones: maxBones,\\n\\t\\t\\t\\tuseVertexTexture: capabilities.floatVertexTextures,\\n\\n\\t\\t\\t\\tmorphTargets: material.morphTargets,\\n\\t\\t\\t\\tmorphNormals: material.morphNormals,\\n\\t\\t\\t\\tmaxMorphTargets: renderer.maxMorphTargets,\\n\\t\\t\\t\\tmaxMorphNormals: renderer.maxMorphNormals,\\n\\n\\t\\t\\t\\tnumDirLights: lights.directional.length,\\n\\t\\t\\t\\tnumPointLights: lights.point.length,\\n\\t\\t\\t\\tnumSpotLights: lights.spot.length,\\n\\t\\t\\t\\tnumRectAreaLights: lights.rectArea.length,\\n\\t\\t\\t\\tnumHemiLights: lights.hemi.length,\\n\\n\\t\\t\\t\\tnumClippingPlanes: nClipPlanes,\\n\\t\\t\\t\\tnumClipIntersection: nClipIntersection,\\n\\n\\t\\t\\t\\tdithering: material.dithering,\\n\\n\\t\\t\\t\\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,\\n\\t\\t\\t\\tshadowMapType: renderer.shadowMap.type,\\n\\n\\t\\t\\t\\ttoneMapping: renderer.toneMapping,\\n\\t\\t\\t\\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\\n\\n\\t\\t\\t\\tpremultipliedAlpha: material.premultipliedAlpha,\\n\\n\\t\\t\\t\\talphaTest: material.alphaTest,\\n\\t\\t\\t\\tdoubleSided: material.side === DoubleSide,\\n\\t\\t\\t\\tflipSided: material.side === BackSide,\\n\\n\\t\\t\\t\\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\\n\\n\\t\\t\\t};\\n\\n\\t\\t\\treturn parameters;\\n\\n\\t\\t};\\n\\n\\t\\tthis.getProgramCode = function ( material, parameters ) {\\n\\n\\t\\t\\tvar array = [];\\n\\n\\t\\t\\tif ( parameters.shaderID ) {\\n\\n\\t\\t\\t\\tarray.push( parameters.shaderID );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tarray.push( material.fragmentShader );\\n\\t\\t\\t\\tarray.push( material.vertexShader );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.defines !== undefined ) {\\n\\n\\t\\t\\t\\tfor ( var name in material.defines ) {\\n\\n\\t\\t\\t\\t\\tarray.push( name );\\n\\t\\t\\t\\t\\tarray.push( material.defines[ name ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\\n\\n\\t\\t\\t\\tarray.push( parameters[ parameterNames[ i ] ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tarray.push( material.onBeforeCompile.toString() );\\n\\n\\t\\t\\tarray.push( renderer.gammaOutput );\\n\\n\\t\\t\\treturn array.join();\\n\\n\\t\\t};\\n\\n\\t\\tthis.acquireProgram = function ( material, shader, parameters, code ) {\\n\\n\\t\\t\\tvar program;\\n\\n\\t\\t\\t// Check if code has been already compiled\\n\\t\\t\\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\\n\\n\\t\\t\\t\\tvar programInfo = programs[ p ];\\n\\n\\t\\t\\t\\tif ( programInfo.code === code ) {\\n\\n\\t\\t\\t\\t\\tprogram = programInfo;\\n\\t\\t\\t\\t\\t++ program.usedTimes;\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( program === undefined ) {\\n\\n\\t\\t\\t\\tprogram = new WebGLProgram( renderer, extensions, code, material, shader, parameters );\\n\\t\\t\\t\\tprograms.push( program );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn program;\\n\\n\\t\\t};\\n\\n\\t\\tthis.releaseProgram = function ( program ) {\\n\\n\\t\\t\\tif ( -- program.usedTimes === 0 ) {\\n\\n\\t\\t\\t\\t// Remove from unordered set\\n\\t\\t\\t\\tvar i = programs.indexOf( program );\\n\\t\\t\\t\\tprograms[ i ] = programs[ programs.length - 1 ];\\n\\t\\t\\t\\tprograms.pop();\\n\\n\\t\\t\\t\\t// Free WebGL resources\\n\\t\\t\\t\\tprogram.destroy();\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\t// Exposed for resource monitoring & error feedback via renderer.info:\\n\\t\\tthis.programs = programs;\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils, infoMemory ) {\\n\\n\\t\\tvar _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof window.WebGL2RenderingContext );\\n\\t\\tvar _videoTextures = {};\\n\\n\\t\\t//\\n\\n\\t\\tfunction clampToMaxSize( image, maxSize ) {\\n\\n\\t\\t\\tif ( image.width > maxSize || image.height > maxSize ) {\\n\\n\\t\\t\\t\\t// Warning: Scaling through the canvas will only work with images that use\\n\\t\\t\\t\\t// premultiplied alpha.\\n\\n\\t\\t\\t\\tvar scale = maxSize / Math.max( image.width, image.height );\\n\\n\\t\\t\\t\\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\\n\\t\\t\\t\\tcanvas.width = Math.floor( image.width * scale );\\n\\t\\t\\t\\tcanvas.height = Math.floor( image.height * scale );\\n\\n\\t\\t\\t\\tvar context = canvas.getContext( '2d' );\\n\\t\\t\\t\\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\\n\\n\\t\\t\\t\\treturn canvas;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn image;\\n\\n\\t\\t}\\n\\n\\t\\tfunction isPowerOfTwo( image ) {\\n\\n\\t\\t\\treturn _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );\\n\\n\\t\\t}\\n\\n\\t\\tfunction makePowerOfTwo( image ) {\\n\\n\\t\\t\\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof ImageBitmap ) {\\n\\n\\t\\t\\t\\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\\n\\t\\t\\t\\tcanvas.width = _Math.floorPowerOfTwo( image.width );\\n\\t\\t\\t\\tcanvas.height = _Math.floorPowerOfTwo( image.height );\\n\\n\\t\\t\\t\\tvar context = canvas.getContext( '2d' );\\n\\t\\t\\t\\tcontext.drawImage( image, 0, 0, canvas.width, canvas.height );\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\\n\\n\\t\\t\\t\\treturn canvas;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn image;\\n\\n\\t\\t}\\n\\n\\t\\tfunction textureNeedsPowerOfTwo( texture ) {\\n\\n\\t\\t\\treturn ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||\\n\\t\\t\\t\\t( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );\\n\\n\\t\\t}\\n\\n\\t\\tfunction textureNeedsGenerateMipmaps( texture, isPowerOfTwo ) {\\n\\n\\t\\t\\treturn texture.generateMipmaps && isPowerOfTwo &&\\n\\t\\t\\t\\ttexture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\\n\\n\\t\\t}\\n\\n\\t\\t// Fallback filters for non-power-of-2 textures\\n\\n\\t\\tfunction filterFallback( f ) {\\n\\n\\t\\t\\tif ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {\\n\\n\\t\\t\\t\\treturn _gl.NEAREST;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn _gl.LINEAR;\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tfunction onTextureDispose( event ) {\\n\\n\\t\\t\\tvar texture = event.target;\\n\\n\\t\\t\\ttexture.removeEventListener( 'dispose', onTextureDispose );\\n\\n\\t\\t\\tdeallocateTexture( texture );\\n\\n\\t\\t\\tif ( texture.isVideoTexture ) {\\n\\n\\t\\t\\t\\tdelete _videoTextures[ texture.id ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tinfoMemory.textures --;\\n\\n\\t\\t}\\n\\n\\t\\tfunction onRenderTargetDispose( event ) {\\n\\n\\t\\t\\tvar renderTarget = event.target;\\n\\n\\t\\t\\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\\n\\n\\t\\t\\tdeallocateRenderTarget( renderTarget );\\n\\n\\t\\t\\tinfoMemory.textures --;\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tfunction deallocateTexture( texture ) {\\n\\n\\t\\t\\tvar textureProperties = properties.get( texture );\\n\\n\\t\\t\\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\\n\\n\\t\\t\\t\\t// cube texture\\n\\n\\t\\t\\t\\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// 2D texture\\n\\n\\t\\t\\t\\tif ( textureProperties.__webglInit === undefined ) return;\\n\\n\\t\\t\\t\\t_gl.deleteTexture( textureProperties.__webglTexture );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// remove all webgl properties\\n\\t\\t\\tproperties.remove( texture );\\n\\n\\t\\t}\\n\\n\\t\\tfunction deallocateRenderTarget( renderTarget ) {\\n\\n\\t\\t\\tvar renderTargetProperties = properties.get( renderTarget );\\n\\t\\t\\tvar textureProperties = properties.get( renderTarget.texture );\\n\\n\\t\\t\\tif ( ! renderTarget ) return;\\n\\n\\t\\t\\tif ( textureProperties.__webglTexture !== undefined ) {\\n\\n\\t\\t\\t\\t_gl.deleteTexture( textureProperties.__webglTexture );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( renderTarget.depthTexture ) {\\n\\n\\t\\t\\t\\trenderTarget.depthTexture.dispose();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( renderTarget.isWebGLRenderTargetCube ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\t\\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\\n\\t\\t\\t\\t\\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\\n\\t\\t\\t\\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tproperties.remove( renderTarget.texture );\\n\\t\\t\\tproperties.remove( renderTarget );\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\n\\n\\t\\tfunction setTexture2D( texture, slot ) {\\n\\n\\t\\t\\tvar textureProperties = properties.get( texture );\\n\\n\\t\\t\\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\\n\\n\\t\\t\\t\\tvar image = texture.image;\\n\\n\\t\\t\\t\\tif ( image === undefined ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\\n\\n\\t\\t\\t\\t} else if ( image.complete === false ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tuploadTexture( textureProperties, texture, slot );\\n\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tstate.activeTexture( _gl.TEXTURE0 + slot );\\n\\t\\t\\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\\n\\n\\t\\t}\\n\\n\\t\\tfunction setTextureCube( texture, slot ) {\\n\\n\\t\\t\\tvar textureProperties = properties.get( texture );\\n\\n\\t\\t\\tif ( texture.image.length === 6 ) {\\n\\n\\t\\t\\t\\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\\n\\n\\t\\t\\t\\t\\tif ( ! textureProperties.__image__webglTextureCube ) {\\n\\n\\t\\t\\t\\t\\t\\ttexture.addEventListener( 'dispose', onTextureDispose );\\n\\n\\t\\t\\t\\t\\t\\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\\n\\n\\t\\t\\t\\t\\t\\tinfoMemory.textures ++;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tstate.activeTexture( _gl.TEXTURE0 + slot );\\n\\t\\t\\t\\t\\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\\n\\n\\t\\t\\t\\t\\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\\n\\n\\t\\t\\t\\t\\tvar isCompressed = ( texture && texture.isCompressedTexture );\\n\\t\\t\\t\\t\\tvar isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );\\n\\n\\t\\t\\t\\t\\tvar cubeImage = [];\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( ! isCompressed && ! isDataTexture ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvar image = cubeImage[ 0 ],\\n\\t\\t\\t\\t\\t\\tisPowerOfTwoImage = isPowerOfTwo( image ),\\n\\t\\t\\t\\t\\t\\tglFormat = utils.convert( texture.format ),\\n\\t\\t\\t\\t\\t\\tglType = utils.convert( texture.type );\\n\\n\\t\\t\\t\\t\\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( ! isCompressed ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( isDataTexture ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tmipmap = mipmaps[ j ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) {\\n\\n\\t\\t\\t\\t\\t\\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ttextureProperties.__version = texture.version;\\n\\n\\t\\t\\t\\t\\tif ( texture.onUpdate ) texture.onUpdate( texture );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tstate.activeTexture( _gl.TEXTURE0 + slot );\\n\\t\\t\\t\\t\\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction setTextureCubeDynamic( texture, slot ) {\\n\\n\\t\\t\\tstate.activeTexture( _gl.TEXTURE0 + slot );\\n\\t\\t\\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\\n\\n\\t\\t}\\n\\n\\t\\tfunction setTextureParameters( textureType, texture, isPowerOfTwoImage ) {\\n\\n\\t\\t\\tvar extension;\\n\\n\\t\\t\\tif ( isPowerOfTwoImage ) {\\n\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, utils.convert( texture.wrapS ) );\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, utils.convert( texture.wrapT ) );\\n\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, utils.convert( texture.magFilter ) );\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, utils.convert( texture.minFilter ) );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\\n\\n\\t\\t\\t\\tif ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\\n\\n\\t\\t\\t\\tif ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\\n\\n\\t\\t\\tif ( extension ) {\\n\\n\\t\\t\\t\\tif ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\\n\\t\\t\\t\\tif ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\\n\\n\\t\\t\\t\\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\\n\\n\\t\\t\\t\\t\\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\\n\\t\\t\\t\\t\\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction uploadTexture( textureProperties, texture, slot ) {\\n\\n\\t\\t\\tif ( textureProperties.__webglInit === undefined ) {\\n\\n\\t\\t\\t\\ttextureProperties.__webglInit = true;\\n\\n\\t\\t\\t\\ttexture.addEventListener( 'dispose', onTextureDispose );\\n\\n\\t\\t\\t\\ttextureProperties.__webglTexture = _gl.createTexture();\\n\\n\\t\\t\\t\\tif ( texture.isVideoTexture ) {\\n\\n\\t\\t\\t\\t\\t_videoTextures[ texture.id ] = texture;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tinfoMemory.textures ++;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tstate.activeTexture( _gl.TEXTURE0 + slot );\\n\\t\\t\\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\\n\\n\\t\\t\\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\\n\\t\\t\\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\\n\\t\\t\\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\\n\\n\\t\\t\\tvar image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\\n\\n\\t\\t\\tif ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\\n\\n\\t\\t\\t\\timage = makePowerOfTwo( image );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar isPowerOfTwoImage = isPowerOfTwo( image ),\\n\\t\\t\\t\\tglFormat = utils.convert( texture.format ),\\n\\t\\t\\t\\tglType = utils.convert( texture.type );\\n\\n\\t\\t\\tsetTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\\n\\n\\t\\t\\tvar mipmap, mipmaps = texture.mipmaps;\\n\\n\\t\\t\\tif ( texture.isDepthTexture ) {\\n\\n\\t\\t\\t\\t// populate depth texture with dummy data\\n\\n\\t\\t\\t\\tvar internalFormat = _gl.DEPTH_COMPONENT;\\n\\n\\t\\t\\t\\tif ( texture.type === FloatType ) {\\n\\n\\t\\t\\t\\t\\tif ( ! _isWebGL2 ) throw new Error( 'Float Depth Texture only supported in WebGL2.0' );\\n\\t\\t\\t\\t\\tinternalFormat = _gl.DEPTH_COMPONENT32F;\\n\\n\\t\\t\\t\\t} else if ( _isWebGL2 ) {\\n\\n\\t\\t\\t\\t\\t// WebGL 2.0 requires signed internalformat for glTexImage2D\\n\\t\\t\\t\\t\\tinternalFormat = _gl.DEPTH_COMPONENT16;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( texture.format === DepthFormat && internalFormat === _gl.DEPTH_COMPONENT ) {\\n\\n\\t\\t\\t\\t\\t// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\\n\\t\\t\\t\\t\\t// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT\\n\\t\\t\\t\\t\\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\\n\\t\\t\\t\\t\\tif ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );\\n\\n\\t\\t\\t\\t\\t\\ttexture.type = UnsignedShortType;\\n\\t\\t\\t\\t\\t\\tglType = utils.convert( texture.type );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Depth stencil textures need the DEPTH_STENCIL internal format\\n\\t\\t\\t\\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\\n\\t\\t\\t\\tif ( texture.format === DepthStencilFormat ) {\\n\\n\\t\\t\\t\\t\\tinternalFormat = _gl.DEPTH_STENCIL;\\n\\n\\t\\t\\t\\t\\t// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\\n\\t\\t\\t\\t\\t// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.\\n\\t\\t\\t\\t\\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\\n\\t\\t\\t\\t\\tif ( texture.type !== UnsignedInt248Type ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );\\n\\n\\t\\t\\t\\t\\t\\ttexture.type = UnsignedInt248Type;\\n\\t\\t\\t\\t\\t\\tglType = utils.convert( texture.type );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );\\n\\n\\t\\t\\t} else if ( texture.isDataTexture ) {\\n\\n\\t\\t\\t\\t// use manually created mipmaps if available\\n\\t\\t\\t\\t// if there are no manual mipmaps\\n\\t\\t\\t\\t// set 0 level mipmap and then use GL to generate other mipmap levels\\n\\n\\t\\t\\t\\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tmipmap = mipmaps[ i ];\\n\\t\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ttexture.generateMipmaps = false;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( texture.isCompressedTexture ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\tmipmap = mipmaps[ i ];\\n\\n\\t\\t\\t\\t\\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// regular Texture (image, video, canvas)\\n\\n\\t\\t\\t\\t// use manually created mipmaps if available\\n\\t\\t\\t\\t// if there are no manual mipmaps\\n\\t\\t\\t\\t// set 0 level mipmap and then use GL to generate other mipmap levels\\n\\n\\t\\t\\t\\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tmipmap = mipmaps[ i ];\\n\\t\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ttexture.generateMipmaps = false;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) _gl.generateMipmap( _gl.TEXTURE_2D );\\n\\n\\t\\t\\ttextureProperties.__version = texture.version;\\n\\n\\t\\t\\tif ( texture.onUpdate ) texture.onUpdate( texture );\\n\\n\\t\\t}\\n\\n\\t\\t// Render targets\\n\\n\\t\\t// Setup storage for target texture and bind it to correct framebuffer\\n\\t\\tfunction setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {\\n\\n\\t\\t\\tvar glFormat = utils.convert( renderTarget.texture.format );\\n\\t\\t\\tvar glType = utils.convert( renderTarget.texture.type );\\n\\t\\t\\tstate.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\\n\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\\n\\t\\t\\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\\n\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\\n\\n\\t\\t}\\n\\n\\t\\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\\n\\t\\tfunction setupRenderBufferStorage( renderbuffer, renderTarget ) {\\n\\n\\t\\t\\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\\n\\n\\t\\t\\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\\n\\n\\t\\t\\t\\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\\n\\t\\t\\t\\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\\n\\n\\t\\t\\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\\n\\n\\t\\t\\t\\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\\n\\t\\t\\t\\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// FIXME: We don't support !depth !stencil\\n\\t\\t\\t\\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\\n\\n\\t\\t}\\n\\n\\t\\t// Setup resources for a Depth Texture for a FBO (needs an extension)\\n\\t\\tfunction setupDepthTexture( framebuffer, renderTarget ) {\\n\\n\\t\\t\\tvar isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );\\n\\t\\t\\tif ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );\\n\\n\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\\n\\n\\t\\t\\tif ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {\\n\\n\\t\\t\\t\\tthrow new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// upload an empty depth texture with framebuffer size\\n\\t\\t\\tif ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||\\n\\t\\t\\t\\t\\trenderTarget.depthTexture.image.width !== renderTarget.width ||\\n\\t\\t\\t\\t\\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\\n\\n\\t\\t\\t\\trenderTarget.depthTexture.image.width = renderTarget.width;\\n\\t\\t\\t\\trenderTarget.depthTexture.image.height = renderTarget.height;\\n\\t\\t\\t\\trenderTarget.depthTexture.needsUpdate = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tsetTexture2D( renderTarget.depthTexture, 0 );\\n\\n\\t\\t\\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\\n\\n\\t\\t\\tif ( renderTarget.depthTexture.format === DepthFormat ) {\\n\\n\\t\\t\\t\\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\\n\\n\\t\\t\\t} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {\\n\\n\\t\\t\\t\\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthrow new Error( 'Unknown depthTexture format' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// Setup GL resources for a non-texture depth buffer\\n\\t\\tfunction setupDepthRenderbuffer( renderTarget ) {\\n\\n\\t\\t\\tvar renderTargetProperties = properties.get( renderTarget );\\n\\n\\t\\t\\tvar isCube = ( renderTarget.isWebGLRenderTargetCube === true );\\n\\n\\t\\t\\tif ( renderTarget.depthTexture ) {\\n\\n\\t\\t\\t\\tif ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );\\n\\n\\t\\t\\t\\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tif ( isCube ) {\\n\\n\\t\\t\\t\\t\\trenderTargetProperties.__webglDepthbuffer = [];\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\\n\\t\\t\\t\\t\\t\\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\\n\\t\\t\\t\\t\\t\\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\\n\\t\\t\\t\\t\\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\\n\\t\\t\\t\\t\\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\\n\\n\\t\\t}\\n\\n\\t\\t// Set up GL resources for the render target\\n\\t\\tfunction setupRenderTarget( renderTarget ) {\\n\\n\\t\\t\\tvar renderTargetProperties = properties.get( renderTarget );\\n\\t\\t\\tvar textureProperties = properties.get( renderTarget.texture );\\n\\n\\t\\t\\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\\n\\n\\t\\t\\ttextureProperties.__webglTexture = _gl.createTexture();\\n\\n\\t\\t\\tinfoMemory.textures ++;\\n\\n\\t\\t\\tvar isCube = ( renderTarget.isWebGLRenderTargetCube === true );\\n\\t\\t\\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\\n\\n\\t\\t\\t// Setup framebuffer\\n\\n\\t\\t\\tif ( isCube ) {\\n\\n\\t\\t\\t\\trenderTargetProperties.__webglFramebuffer = [];\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\t\\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Setup color buffer\\n\\n\\t\\t\\tif ( isCube ) {\\n\\n\\t\\t\\t\\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\\n\\t\\t\\t\\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\t\\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\\n\\t\\t\\t\\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\\n\\t\\t\\t\\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\\n\\t\\t\\t\\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\\n\\n\\t\\t\\t\\tif ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) _gl.generateMipmap( _gl.TEXTURE_2D );\\n\\t\\t\\t\\tstate.bindTexture( _gl.TEXTURE_2D, null );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Setup depth and stencil buffers\\n\\n\\t\\t\\tif ( renderTarget.depthBuffer ) {\\n\\n\\t\\t\\t\\tsetupDepthRenderbuffer( renderTarget );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction updateRenderTargetMipmap( renderTarget ) {\\n\\n\\t\\t\\tvar texture = renderTarget.texture;\\n\\t\\t\\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\\n\\n\\t\\t\\tif ( textureNeedsGenerateMipmaps( texture, isTargetPowerOfTwo ) ) {\\n\\n\\t\\t\\t\\tvar target = renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\\n\\t\\t\\t\\tvar webglTexture = properties.get( texture ).__webglTexture;\\n\\n\\t\\t\\t\\tstate.bindTexture( target, webglTexture );\\n\\t\\t\\t\\t_gl.generateMipmap( target );\\n\\t\\t\\t\\tstate.bindTexture( target, null );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction updateVideoTextures() {\\n\\n\\t\\t\\tfor ( var id in _videoTextures ) {\\n\\n\\t\\t\\t\\t_videoTextures[ id ].update();\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tthis.setTexture2D = setTexture2D;\\n\\t\\tthis.setTextureCube = setTextureCube;\\n\\t\\tthis.setTextureCubeDynamic = setTextureCubeDynamic;\\n\\t\\tthis.setupRenderTarget = setupRenderTarget;\\n\\t\\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\\n\\t\\tthis.updateVideoTextures = updateVideoTextures;\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author fordacious / fordacious.github.io\\n\\t */\\n\\n\\tfunction WebGLProperties() {\\n\\n\\t\\tvar properties = {};\\n\\n\\t\\tfunction get( object ) {\\n\\n\\t\\t\\tvar uuid = object.uuid;\\n\\t\\t\\tvar map = properties[ uuid ];\\n\\n\\t\\t\\tif ( map === undefined ) {\\n\\n\\t\\t\\t\\tmap = {};\\n\\t\\t\\t\\tproperties[ uuid ] = map;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn map;\\n\\n\\t\\t}\\n\\n\\t\\tfunction remove( object ) {\\n\\n\\t\\t\\tdelete properties[ object.uuid ];\\n\\n\\t\\t}\\n\\n\\t\\tfunction clear() {\\n\\n\\t\\t\\tproperties = {};\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\tget: get,\\n\\t\\t\\tremove: remove,\\n\\t\\t\\tclear: clear\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLState( gl, extensions, utils ) {\\n\\n\\t\\tfunction ColorBuffer() {\\n\\n\\t\\t\\tvar locked = false;\\n\\n\\t\\t\\tvar color = new Vector4();\\n\\t\\t\\tvar currentColorMask = null;\\n\\t\\t\\tvar currentColorClear = new Vector4( 0, 0, 0, 0 );\\n\\n\\t\\t\\treturn {\\n\\n\\t\\t\\t\\tsetMask: function ( colorMask ) {\\n\\n\\t\\t\\t\\t\\tif ( currentColorMask !== colorMask && ! locked ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\\n\\t\\t\\t\\t\\t\\tcurrentColorMask = colorMask;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetLocked: function ( lock ) {\\n\\n\\t\\t\\t\\t\\tlocked = lock;\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetClear: function ( r, g, b, a, premultipliedAlpha ) {\\n\\n\\t\\t\\t\\t\\tif ( premultipliedAlpha === true ) {\\n\\n\\t\\t\\t\\t\\t\\tr *= a; g *= a; b *= a;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tcolor.set( r, g, b, a );\\n\\n\\t\\t\\t\\t\\tif ( currentColorClear.equals( color ) === false ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.clearColor( r, g, b, a );\\n\\t\\t\\t\\t\\t\\tcurrentColorClear.copy( color );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\treset: function () {\\n\\n\\t\\t\\t\\t\\tlocked = false;\\n\\n\\t\\t\\t\\t\\tcurrentColorMask = null;\\n\\t\\t\\t\\t\\tcurrentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}\\n\\n\\t\\tfunction DepthBuffer() {\\n\\n\\t\\t\\tvar locked = false;\\n\\n\\t\\t\\tvar currentDepthMask = null;\\n\\t\\t\\tvar currentDepthFunc = null;\\n\\t\\t\\tvar currentDepthClear = null;\\n\\n\\t\\t\\treturn {\\n\\n\\t\\t\\t\\tsetTest: function ( depthTest ) {\\n\\n\\t\\t\\t\\t\\tif ( depthTest ) {\\n\\n\\t\\t\\t\\t\\t\\tenable( gl.DEPTH_TEST );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tdisable( gl.DEPTH_TEST );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetMask: function ( depthMask ) {\\n\\n\\t\\t\\t\\t\\tif ( currentDepthMask !== depthMask && ! locked ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.depthMask( depthMask );\\n\\t\\t\\t\\t\\t\\tcurrentDepthMask = depthMask;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetFunc: function ( depthFunc ) {\\n\\n\\t\\t\\t\\t\\tif ( currentDepthFunc !== depthFunc ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( depthFunc ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tswitch ( depthFunc ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase NeverDepth:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.NEVER );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase AlwaysDepth:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.ALWAYS );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase LessDepth:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.LESS );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase LessEqualDepth:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.LEQUAL );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase EqualDepth:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.EQUAL );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase GreaterEqualDepth:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.GEQUAL );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase GreaterDepth:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.GREATER );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase NotEqualDepth:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.NOTEQUAL );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.LEQUAL );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.LEQUAL );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tcurrentDepthFunc = depthFunc;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetLocked: function ( lock ) {\\n\\n\\t\\t\\t\\t\\tlocked = lock;\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetClear: function ( depth ) {\\n\\n\\t\\t\\t\\t\\tif ( currentDepthClear !== depth ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.clearDepth( depth );\\n\\t\\t\\t\\t\\t\\tcurrentDepthClear = depth;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\treset: function () {\\n\\n\\t\\t\\t\\t\\tlocked = false;\\n\\n\\t\\t\\t\\t\\tcurrentDepthMask = null;\\n\\t\\t\\t\\t\\tcurrentDepthFunc = null;\\n\\t\\t\\t\\t\\tcurrentDepthClear = null;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}\\n\\n\\t\\tfunction StencilBuffer() {\\n\\n\\t\\t\\tvar locked = false;\\n\\n\\t\\t\\tvar currentStencilMask = null;\\n\\t\\t\\tvar currentStencilFunc = null;\\n\\t\\t\\tvar currentStencilRef = null;\\n\\t\\t\\tvar currentStencilFuncMask = null;\\n\\t\\t\\tvar currentStencilFail = null;\\n\\t\\t\\tvar currentStencilZFail = null;\\n\\t\\t\\tvar currentStencilZPass = null;\\n\\t\\t\\tvar currentStencilClear = null;\\n\\n\\t\\t\\treturn {\\n\\n\\t\\t\\t\\tsetTest: function ( stencilTest ) {\\n\\n\\t\\t\\t\\t\\tif ( stencilTest ) {\\n\\n\\t\\t\\t\\t\\t\\tenable( gl.STENCIL_TEST );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tdisable( gl.STENCIL_TEST );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetMask: function ( stencilMask ) {\\n\\n\\t\\t\\t\\t\\tif ( currentStencilMask !== stencilMask && ! locked ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.stencilMask( stencilMask );\\n\\t\\t\\t\\t\\t\\tcurrentStencilMask = stencilMask;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetFunc: function ( stencilFunc, stencilRef, stencilMask ) {\\n\\n\\t\\t\\t\\t\\tif ( currentStencilFunc !== stencilFunc ||\\n\\t\\t\\t\\t\\t     currentStencilRef \\t!== stencilRef \\t||\\n\\t\\t\\t\\t\\t     currentStencilFuncMask !== stencilMask ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.stencilFunc( stencilFunc, stencilRef, stencilMask );\\n\\n\\t\\t\\t\\t\\t\\tcurrentStencilFunc = stencilFunc;\\n\\t\\t\\t\\t\\t\\tcurrentStencilRef = stencilRef;\\n\\t\\t\\t\\t\\t\\tcurrentStencilFuncMask = stencilMask;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetOp: function ( stencilFail, stencilZFail, stencilZPass ) {\\n\\n\\t\\t\\t\\t\\tif ( currentStencilFail\\t !== stencilFail \\t||\\n\\t\\t\\t\\t\\t     currentStencilZFail !== stencilZFail ||\\n\\t\\t\\t\\t\\t     currentStencilZPass !== stencilZPass ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.stencilOp( stencilFail, stencilZFail, stencilZPass );\\n\\n\\t\\t\\t\\t\\t\\tcurrentStencilFail = stencilFail;\\n\\t\\t\\t\\t\\t\\tcurrentStencilZFail = stencilZFail;\\n\\t\\t\\t\\t\\t\\tcurrentStencilZPass = stencilZPass;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetLocked: function ( lock ) {\\n\\n\\t\\t\\t\\t\\tlocked = lock;\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetClear: function ( stencil ) {\\n\\n\\t\\t\\t\\t\\tif ( currentStencilClear !== stencil ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.clearStencil( stencil );\\n\\t\\t\\t\\t\\t\\tcurrentStencilClear = stencil;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\treset: function () {\\n\\n\\t\\t\\t\\t\\tlocked = false;\\n\\n\\t\\t\\t\\t\\tcurrentStencilMask = null;\\n\\t\\t\\t\\t\\tcurrentStencilFunc = null;\\n\\t\\t\\t\\t\\tcurrentStencilRef = null;\\n\\t\\t\\t\\t\\tcurrentStencilFuncMask = null;\\n\\t\\t\\t\\t\\tcurrentStencilFail = null;\\n\\t\\t\\t\\t\\tcurrentStencilZFail = null;\\n\\t\\t\\t\\t\\tcurrentStencilZPass = null;\\n\\t\\t\\t\\t\\tcurrentStencilClear = null;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tvar colorBuffer = new ColorBuffer();\\n\\t\\tvar depthBuffer = new DepthBuffer();\\n\\t\\tvar stencilBuffer = new StencilBuffer();\\n\\n\\t\\tvar maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\\n\\t\\tvar newAttributes = new Uint8Array( maxVertexAttributes );\\n\\t\\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\\n\\t\\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\\n\\n\\t\\tvar capabilities = {};\\n\\n\\t\\tvar compressedTextureFormats = null;\\n\\n\\t\\tvar currentProgram = null;\\n\\n\\t\\tvar currentBlending = null;\\n\\t\\tvar currentBlendEquation = null;\\n\\t\\tvar currentBlendSrc = null;\\n\\t\\tvar currentBlendDst = null;\\n\\t\\tvar currentBlendEquationAlpha = null;\\n\\t\\tvar currentBlendSrcAlpha = null;\\n\\t\\tvar currentBlendDstAlpha = null;\\n\\t\\tvar currentPremultipledAlpha = false;\\n\\n\\t\\tvar currentFlipSided = null;\\n\\t\\tvar currentCullFace = null;\\n\\n\\t\\tvar currentLineWidth = null;\\n\\n\\t\\tvar currentPolygonOffsetFactor = null;\\n\\t\\tvar currentPolygonOffsetUnits = null;\\n\\n\\t\\tvar maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );\\n\\n\\t\\tvar version = parseFloat( /^WebGL\\\\ ([0-9])/.exec( gl.getParameter( gl.VERSION ) )[ 1 ] );\\n\\t\\tvar lineWidthAvailable = parseFloat( version ) >= 1.0;\\n\\n\\t\\tvar currentTextureSlot = null;\\n\\t\\tvar currentBoundTextures = {};\\n\\n\\t\\tvar currentScissor = new Vector4();\\n\\t\\tvar currentViewport = new Vector4();\\n\\n\\t\\tfunction createTexture( type, target, count ) {\\n\\n\\t\\t\\tvar data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\\n\\t\\t\\tvar texture = gl.createTexture();\\n\\n\\t\\t\\tgl.bindTexture( type, texture );\\n\\t\\t\\tgl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\\n\\t\\t\\tgl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\\n\\n\\t\\t\\tfor ( var i = 0; i < count; i ++ ) {\\n\\n\\t\\t\\t\\tgl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn texture;\\n\\n\\t\\t}\\n\\n\\t\\tvar emptyTextures = {};\\n\\t\\temptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\\n\\t\\temptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\\n\\n\\t\\t// init\\n\\n\\t\\tcolorBuffer.setClear( 0, 0, 0, 1 );\\n\\t\\tdepthBuffer.setClear( 1 );\\n\\t\\tstencilBuffer.setClear( 0 );\\n\\n\\t\\tenable( gl.DEPTH_TEST );\\n\\t\\tdepthBuffer.setFunc( LessEqualDepth );\\n\\n\\t\\tsetFlipSided( false );\\n\\t\\tsetCullFace( CullFaceBack );\\n\\t\\tenable( gl.CULL_FACE );\\n\\n\\t\\tenable( gl.BLEND );\\n\\t\\tsetBlending( NormalBlending );\\n\\n\\t\\t//\\n\\n\\t\\tfunction initAttributes() {\\n\\n\\t\\t\\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tnewAttributes[ i ] = 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction enableAttribute( attribute ) {\\n\\n\\t\\t\\tnewAttributes[ attribute ] = 1;\\n\\n\\t\\t\\tif ( enabledAttributes[ attribute ] === 0 ) {\\n\\n\\t\\t\\t\\tgl.enableVertexAttribArray( attribute );\\n\\t\\t\\t\\tenabledAttributes[ attribute ] = 1;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( attributeDivisors[ attribute ] !== 0 ) {\\n\\n\\t\\t\\t\\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\\n\\n\\t\\t\\t\\textension.vertexAttribDivisorANGLE( attribute, 0 );\\n\\t\\t\\t\\tattributeDivisors[ attribute ] = 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction enableAttributeAndDivisor( attribute, meshPerAttribute ) {\\n\\n\\t\\t\\tnewAttributes[ attribute ] = 1;\\n\\n\\t\\t\\tif ( enabledAttributes[ attribute ] === 0 ) {\\n\\n\\t\\t\\t\\tgl.enableVertexAttribArray( attribute );\\n\\t\\t\\t\\tenabledAttributes[ attribute ] = 1;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\\n\\n\\t\\t\\t\\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\\n\\n\\t\\t\\t\\textension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\\n\\t\\t\\t\\tattributeDivisors[ attribute ] = meshPerAttribute;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction disableUnusedAttributes() {\\n\\n\\t\\t\\tfor ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {\\n\\n\\t\\t\\t\\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\\n\\n\\t\\t\\t\\t\\tgl.disableVertexAttribArray( i );\\n\\t\\t\\t\\t\\tenabledAttributes[ i ] = 0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction enable( id ) {\\n\\n\\t\\t\\tif ( capabilities[ id ] !== true ) {\\n\\n\\t\\t\\t\\tgl.enable( id );\\n\\t\\t\\t\\tcapabilities[ id ] = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction disable( id ) {\\n\\n\\t\\t\\tif ( capabilities[ id ] !== false ) {\\n\\n\\t\\t\\t\\tgl.disable( id );\\n\\t\\t\\t\\tcapabilities[ id ] = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction getCompressedTextureFormats() {\\n\\n\\t\\t\\tif ( compressedTextureFormats === null ) {\\n\\n\\t\\t\\t\\tcompressedTextureFormats = [];\\n\\n\\t\\t\\t\\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\\n\\t\\t\\t\\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\\n\\t\\t\\t\\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {\\n\\n\\t\\t\\t\\t\\tvar formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < formats.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tcompressedTextureFormats.push( formats[ i ] );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn compressedTextureFormats;\\n\\n\\t\\t}\\n\\n\\t\\tfunction useProgram( program ) {\\n\\n\\t\\t\\tif ( currentProgram !== program ) {\\n\\n\\t\\t\\t\\tgl.useProgram( program );\\n\\n\\t\\t\\t\\tcurrentProgram = program;\\n\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn false;\\n\\n\\t\\t}\\n\\n\\t\\tfunction setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\\n\\n\\t\\t\\tif ( blending !== NoBlending ) {\\n\\n\\t\\t\\t\\tenable( gl.BLEND );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tdisable( gl.BLEND );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( blending !== CustomBlending ) {\\n\\n\\t\\t\\t\\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\\n\\n\\t\\t\\t\\t\\tswitch ( blending ) {\\n\\n\\t\\t\\t\\t\\t\\tcase AdditiveBlending:\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( premultipliedAlpha ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquation( gl.FUNC_ADD );\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase SubtractiveBlending:\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( premultipliedAlpha ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquation( gl.FUNC_ADD );\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase MultiplyBlending:\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( premultipliedAlpha ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquation( gl.FUNC_ADD );\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( premultipliedAlpha ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcurrentBlendEquation = null;\\n\\t\\t\\t\\tcurrentBlendSrc = null;\\n\\t\\t\\t\\tcurrentBlendDst = null;\\n\\t\\t\\t\\tcurrentBlendEquationAlpha = null;\\n\\t\\t\\t\\tcurrentBlendSrcAlpha = null;\\n\\t\\t\\t\\tcurrentBlendDstAlpha = null;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tblendEquationAlpha = blendEquationAlpha || blendEquation;\\n\\t\\t\\t\\tblendSrcAlpha = blendSrcAlpha || blendSrc;\\n\\t\\t\\t\\tblendDstAlpha = blendDstAlpha || blendDst;\\n\\n\\t\\t\\t\\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\\n\\n\\t\\t\\t\\t\\tgl.blendEquationSeparate( utils.convert( blendEquation ), utils.convert( blendEquationAlpha ) );\\n\\n\\t\\t\\t\\t\\tcurrentBlendEquation = blendEquation;\\n\\t\\t\\t\\t\\tcurrentBlendEquationAlpha = blendEquationAlpha;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\\n\\n\\t\\t\\t\\t\\tgl.blendFuncSeparate( utils.convert( blendSrc ), utils.convert( blendDst ), utils.convert( blendSrcAlpha ), utils.convert( blendDstAlpha ) );\\n\\n\\t\\t\\t\\t\\tcurrentBlendSrc = blendSrc;\\n\\t\\t\\t\\t\\tcurrentBlendDst = blendDst;\\n\\t\\t\\t\\t\\tcurrentBlendSrcAlpha = blendSrcAlpha;\\n\\t\\t\\t\\t\\tcurrentBlendDstAlpha = blendDstAlpha;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tcurrentBlending = blending;\\n\\t\\t\\tcurrentPremultipledAlpha = premultipliedAlpha;\\n\\n\\t\\t}\\n\\n\\t\\tfunction setMaterial( material, frontFaceCW ) {\\n\\n\\t\\t\\tmaterial.side === DoubleSide\\n\\t\\t\\t\\t? disable( gl.CULL_FACE )\\n\\t\\t\\t\\t: enable( gl.CULL_FACE );\\n\\n\\t\\t\\tvar flipSided = ( material.side === BackSide );\\n\\t\\t\\tif ( frontFaceCW ) flipSided = ! flipSided;\\n\\n\\t\\t\\tsetFlipSided( flipSided );\\n\\n\\t\\t\\tmaterial.transparent === true\\n\\t\\t\\t\\t? setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )\\n\\t\\t\\t\\t: setBlending( NoBlending );\\n\\n\\t\\t\\tdepthBuffer.setFunc( material.depthFunc );\\n\\t\\t\\tdepthBuffer.setTest( material.depthTest );\\n\\t\\t\\tdepthBuffer.setMask( material.depthWrite );\\n\\t\\t\\tcolorBuffer.setMask( material.colorWrite );\\n\\n\\t\\t\\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tfunction setFlipSided( flipSided ) {\\n\\n\\t\\t\\tif ( currentFlipSided !== flipSided ) {\\n\\n\\t\\t\\t\\tif ( flipSided ) {\\n\\n\\t\\t\\t\\t\\tgl.frontFace( gl.CW );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tgl.frontFace( gl.CCW );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcurrentFlipSided = flipSided;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction setCullFace( cullFace ) {\\n\\n\\t\\t\\tif ( cullFace !== CullFaceNone ) {\\n\\n\\t\\t\\t\\tenable( gl.CULL_FACE );\\n\\n\\t\\t\\t\\tif ( cullFace !== currentCullFace ) {\\n\\n\\t\\t\\t\\t\\tif ( cullFace === CullFaceBack ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.cullFace( gl.BACK );\\n\\n\\t\\t\\t\\t\\t} else if ( cullFace === CullFaceFront ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.cullFace( gl.FRONT );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tgl.cullFace( gl.FRONT_AND_BACK );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tdisable( gl.CULL_FACE );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tcurrentCullFace = cullFace;\\n\\n\\t\\t}\\n\\n\\t\\tfunction setLineWidth( width ) {\\n\\n\\t\\t\\tif ( width !== currentLineWidth ) {\\n\\n\\t\\t\\t\\tif ( lineWidthAvailable ) gl.lineWidth( width );\\n\\n\\t\\t\\t\\tcurrentLineWidth = width;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction setPolygonOffset( polygonOffset, factor, units ) {\\n\\n\\t\\t\\tif ( polygonOffset ) {\\n\\n\\t\\t\\t\\tenable( gl.POLYGON_OFFSET_FILL );\\n\\n\\t\\t\\t\\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\\n\\n\\t\\t\\t\\t\\tgl.polygonOffset( factor, units );\\n\\n\\t\\t\\t\\t\\tcurrentPolygonOffsetFactor = factor;\\n\\t\\t\\t\\t\\tcurrentPolygonOffsetUnits = units;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tdisable( gl.POLYGON_OFFSET_FILL );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction setScissorTest( scissorTest ) {\\n\\n\\t\\t\\tif ( scissorTest ) {\\n\\n\\t\\t\\t\\tenable( gl.SCISSOR_TEST );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tdisable( gl.SCISSOR_TEST );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// texture\\n\\n\\t\\tfunction activeTexture( webglSlot ) {\\n\\n\\t\\t\\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\\n\\n\\t\\t\\tif ( currentTextureSlot !== webglSlot ) {\\n\\n\\t\\t\\t\\tgl.activeTexture( webglSlot );\\n\\t\\t\\t\\tcurrentTextureSlot = webglSlot;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction bindTexture( webglType, webglTexture ) {\\n\\n\\t\\t\\tif ( currentTextureSlot === null ) {\\n\\n\\t\\t\\t\\tactiveTexture();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\\n\\n\\t\\t\\tif ( boundTexture === undefined ) {\\n\\n\\t\\t\\t\\tboundTexture = { type: undefined, texture: undefined };\\n\\t\\t\\t\\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\\n\\n\\t\\t\\t\\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\\n\\n\\t\\t\\t\\tboundTexture.type = webglType;\\n\\t\\t\\t\\tboundTexture.texture = webglTexture;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction compressedTexImage2D() {\\n\\n\\t\\t\\ttry {\\n\\n\\t\\t\\t\\tgl.compressedTexImage2D.apply( gl, arguments );\\n\\n\\t\\t\\t} catch ( error ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLState:', error );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction texImage2D() {\\n\\n\\t\\t\\ttry {\\n\\n\\t\\t\\t\\tgl.texImage2D.apply( gl, arguments );\\n\\n\\t\\t\\t} catch ( error ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLState:', error );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tfunction scissor( scissor ) {\\n\\n\\t\\t\\tif ( currentScissor.equals( scissor ) === false ) {\\n\\n\\t\\t\\t\\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\\n\\t\\t\\t\\tcurrentScissor.copy( scissor );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction viewport( viewport ) {\\n\\n\\t\\t\\tif ( currentViewport.equals( viewport ) === false ) {\\n\\n\\t\\t\\t\\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\\n\\t\\t\\t\\tcurrentViewport.copy( viewport );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tfunction reset() {\\n\\n\\t\\t\\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\\n\\n\\t\\t\\t\\tif ( enabledAttributes[ i ] === 1 ) {\\n\\n\\t\\t\\t\\t\\tgl.disableVertexAttribArray( i );\\n\\t\\t\\t\\t\\tenabledAttributes[ i ] = 0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tcapabilities = {};\\n\\n\\t\\t\\tcompressedTextureFormats = null;\\n\\n\\t\\t\\tcurrentTextureSlot = null;\\n\\t\\t\\tcurrentBoundTextures = {};\\n\\n\\t\\t\\tcurrentProgram = null;\\n\\n\\t\\t\\tcurrentBlending = null;\\n\\n\\t\\t\\tcurrentFlipSided = null;\\n\\t\\t\\tcurrentCullFace = null;\\n\\n\\t\\t\\tcolorBuffer.reset();\\n\\t\\t\\tdepthBuffer.reset();\\n\\t\\t\\tstencilBuffer.reset();\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tbuffers: {\\n\\t\\t\\t\\tcolor: colorBuffer,\\n\\t\\t\\t\\tdepth: depthBuffer,\\n\\t\\t\\t\\tstencil: stencilBuffer\\n\\t\\t\\t},\\n\\n\\t\\t\\tinitAttributes: initAttributes,\\n\\t\\t\\tenableAttribute: enableAttribute,\\n\\t\\t\\tenableAttributeAndDivisor: enableAttributeAndDivisor,\\n\\t\\t\\tdisableUnusedAttributes: disableUnusedAttributes,\\n\\t\\t\\tenable: enable,\\n\\t\\t\\tdisable: disable,\\n\\t\\t\\tgetCompressedTextureFormats: getCompressedTextureFormats,\\n\\n\\t\\t\\tuseProgram: useProgram,\\n\\n\\t\\t\\tsetBlending: setBlending,\\n\\t\\t\\tsetMaterial: setMaterial,\\n\\n\\t\\t\\tsetFlipSided: setFlipSided,\\n\\t\\t\\tsetCullFace: setCullFace,\\n\\n\\t\\t\\tsetLineWidth: setLineWidth,\\n\\t\\t\\tsetPolygonOffset: setPolygonOffset,\\n\\n\\t\\t\\tsetScissorTest: setScissorTest,\\n\\n\\t\\t\\tactiveTexture: activeTexture,\\n\\t\\t\\tbindTexture: bindTexture,\\n\\t\\t\\tcompressedTexImage2D: compressedTexImage2D,\\n\\t\\t\\ttexImage2D: texImage2D,\\n\\n\\t\\t\\tscissor: scissor,\\n\\t\\t\\tviewport: viewport,\\n\\n\\t\\t\\treset: reset\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLCapabilities( gl, extensions, parameters ) {\\n\\n\\t\\tvar maxAnisotropy;\\n\\n\\t\\tfunction getMaxAnisotropy() {\\n\\n\\t\\t\\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\\n\\n\\t\\t\\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\\n\\n\\t\\t\\tif ( extension !== null ) {\\n\\n\\t\\t\\t\\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tmaxAnisotropy = 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn maxAnisotropy;\\n\\n\\t\\t}\\n\\n\\t\\tfunction getMaxPrecision( precision ) {\\n\\n\\t\\t\\tif ( precision === 'highp' ) {\\n\\n\\t\\t\\t\\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\\n\\t\\t\\t\\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\\n\\n\\t\\t\\t\\t\\treturn 'highp';\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tprecision = 'mediump';\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( precision === 'mediump' ) {\\n\\n\\t\\t\\t\\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\\n\\t\\t\\t\\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\\n\\n\\t\\t\\t\\t\\treturn 'mediump';\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn 'lowp';\\n\\n\\t\\t}\\n\\n\\t\\tvar precision = parameters.precision !== undefined ? parameters.precision : 'highp';\\n\\t\\tvar maxPrecision = getMaxPrecision( precision );\\n\\n\\t\\tif ( maxPrecision !== precision ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );\\n\\t\\t\\tprecision = maxPrecision;\\n\\n\\t\\t}\\n\\n\\t\\tvar logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;\\n\\n\\t\\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\\n\\t\\tvar maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\\n\\t\\tvar maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\\n\\t\\tvar maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\\n\\n\\t\\tvar maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\\n\\t\\tvar maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\\n\\t\\tvar maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\\n\\t\\tvar maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\\n\\n\\t\\tvar vertexTextures = maxVertexTextures > 0;\\n\\t\\tvar floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\\n\\t\\tvar floatVertexTextures = vertexTextures && floatFragmentTextures;\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tgetMaxAnisotropy: getMaxAnisotropy,\\n\\t\\t\\tgetMaxPrecision: getMaxPrecision,\\n\\n\\t\\t\\tprecision: precision,\\n\\t\\t\\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\\n\\n\\t\\t\\tmaxTextures: maxTextures,\\n\\t\\t\\tmaxVertexTextures: maxVertexTextures,\\n\\t\\t\\tmaxTextureSize: maxTextureSize,\\n\\t\\t\\tmaxCubemapSize: maxCubemapSize,\\n\\n\\t\\t\\tmaxAttributes: maxAttributes,\\n\\t\\t\\tmaxVertexUniforms: maxVertexUniforms,\\n\\t\\t\\tmaxVaryings: maxVaryings,\\n\\t\\t\\tmaxFragmentUniforms: maxFragmentUniforms,\\n\\n\\t\\t\\tvertexTextures: vertexTextures,\\n\\t\\t\\tfloatFragmentTextures: floatFragmentTextures,\\n\\t\\t\\tfloatVertexTextures: floatVertexTextures\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author greggman / http://games.greggman.com/\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction PerspectiveCamera( fov, aspect, near, far ) {\\n\\n\\t\\tCamera.call( this );\\n\\n\\t\\tthis.type = 'PerspectiveCamera';\\n\\n\\t\\tthis.fov = fov !== undefined ? fov : 50;\\n\\t\\tthis.zoom = 1;\\n\\n\\t\\tthis.near = near !== undefined ? near : 0.1;\\n\\t\\tthis.far = far !== undefined ? far : 2000;\\n\\t\\tthis.focus = 10;\\n\\n\\t\\tthis.aspect = aspect !== undefined ? aspect : 1;\\n\\t\\tthis.view = null;\\n\\n\\t\\tthis.filmGauge = 35;\\t// width of the film (default in millimeters)\\n\\t\\tthis.filmOffset = 0;\\t// horizontal film offset (same unit as gauge)\\n\\n\\t\\tthis.updateProjectionMatrix();\\n\\n\\t}\\n\\n\\tPerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\\n\\n\\t\\tconstructor: PerspectiveCamera,\\n\\n\\t\\tisPerspectiveCamera: true,\\n\\n\\t\\tcopy: function ( source, recursive ) {\\n\\n\\t\\t\\tCamera.prototype.copy.call( this, source, recursive );\\n\\n\\t\\t\\tthis.fov = source.fov;\\n\\t\\t\\tthis.zoom = source.zoom;\\n\\n\\t\\t\\tthis.near = source.near;\\n\\t\\t\\tthis.far = source.far;\\n\\t\\t\\tthis.focus = source.focus;\\n\\n\\t\\t\\tthis.aspect = source.aspect;\\n\\t\\t\\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\\n\\n\\t\\t\\tthis.filmGauge = source.filmGauge;\\n\\t\\t\\tthis.filmOffset = source.filmOffset;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Sets the FOV by focal length in respect to the current .filmGauge.\\n\\t\\t *\\n\\t\\t * The default film gauge is 35, so that the focal length can be specified for\\n\\t\\t * a 35mm (full frame) camera.\\n\\t\\t *\\n\\t\\t * Values for focal length and film gauge must have the same unit.\\n\\t\\t */\\n\\t\\tsetFocalLength: function ( focalLength ) {\\n\\n\\t\\t\\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\\n\\t\\t\\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\\n\\n\\t\\t\\tthis.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\\n\\t\\t\\tthis.updateProjectionMatrix();\\n\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Calculates the focal length from the current .fov and .filmGauge.\\n\\t\\t */\\n\\t\\tgetFocalLength: function () {\\n\\n\\t\\t\\tvar vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );\\n\\n\\t\\t\\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\\n\\n\\t\\t},\\n\\n\\t\\tgetEffectiveFOV: function () {\\n\\n\\t\\t\\treturn _Math.RAD2DEG * 2 * Math.atan(\\n\\t\\t\\t\\tMath.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\\n\\n\\t\\t},\\n\\n\\t\\tgetFilmWidth: function () {\\n\\n\\t\\t\\t// film not completely covered in portrait format (aspect < 1)\\n\\t\\t\\treturn this.filmGauge * Math.min( this.aspect, 1 );\\n\\n\\t\\t},\\n\\n\\t\\tgetFilmHeight: function () {\\n\\n\\t\\t\\t// film not completely covered in landscape format (aspect > 1)\\n\\t\\t\\treturn this.filmGauge / Math.max( this.aspect, 1 );\\n\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Sets an offset in a larger frustum. This is useful for multi-window or\\n\\t\\t * multi-monitor/multi-machine setups.\\n\\t\\t *\\n\\t\\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\\n\\t\\t * the monitors are in grid like this\\n\\t\\t *\\n\\t\\t *   +---+---+---+\\n\\t\\t *   | A | B | C |\\n\\t\\t *   +---+---+---+\\n\\t\\t *   | D | E | F |\\n\\t\\t *   +---+---+---+\\n\\t\\t *\\n\\t\\t * then for each monitor you would call it like this\\n\\t\\t *\\n\\t\\t *   var w = 1920;\\n\\t\\t *   var h = 1080;\\n\\t\\t *   var fullWidth = w * 3;\\n\\t\\t *   var fullHeight = h * 2;\\n\\t\\t *\\n\\t\\t *   --A--\\n\\t\\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\\n\\t\\t *   --B--\\n\\t\\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\\n\\t\\t *   --C--\\n\\t\\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\\n\\t\\t *   --D--\\n\\t\\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\\n\\t\\t *   --E--\\n\\t\\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\\n\\t\\t *   --F--\\n\\t\\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\\n\\t\\t *\\n\\t\\t *   Note there is no reason monitors have to be the same size or in a grid.\\n\\t\\t */\\n\\t\\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\\n\\n\\t\\t\\tthis.aspect = fullWidth / fullHeight;\\n\\n\\t\\t\\tif ( this.view === null ) {\\n\\n\\t\\t\\t\\tthis.view = {\\n\\t\\t\\t\\t\\tenabled: true,\\n\\t\\t\\t\\t\\tfullWidth: 1,\\n\\t\\t\\t\\t\\tfullHeight: 1,\\n\\t\\t\\t\\t\\toffsetX: 0,\\n\\t\\t\\t\\t\\toffsetY: 0,\\n\\t\\t\\t\\t\\twidth: 1,\\n\\t\\t\\t\\t\\theight: 1\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.view.enabled = true;\\n\\t\\t\\tthis.view.fullWidth = fullWidth;\\n\\t\\t\\tthis.view.fullHeight = fullHeight;\\n\\t\\t\\tthis.view.offsetX = x;\\n\\t\\t\\tthis.view.offsetY = y;\\n\\t\\t\\tthis.view.width = width;\\n\\t\\t\\tthis.view.height = height;\\n\\n\\t\\t\\tthis.updateProjectionMatrix();\\n\\n\\t\\t},\\n\\n\\t\\tclearViewOffset: function () {\\n\\n\\t\\t\\tif ( this.view !== null ) {\\n\\n\\t\\t\\t\\tthis.view.enabled = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.updateProjectionMatrix();\\n\\n\\t\\t},\\n\\n\\t\\tupdateProjectionMatrix: function () {\\n\\n\\t\\t\\tvar near = this.near,\\n\\t\\t\\t\\ttop = near * Math.tan(\\n\\t\\t\\t\\t\\t_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\\n\\t\\t\\t\\theight = 2 * top,\\n\\t\\t\\t\\twidth = this.aspect * height,\\n\\t\\t\\t\\tleft = - 0.5 * width,\\n\\t\\t\\t\\tview = this.view;\\n\\n\\t\\t\\tif ( this.view !== null && this.view.enabled ) {\\n\\n\\t\\t\\t\\tvar fullWidth = view.fullWidth,\\n\\t\\t\\t\\t\\tfullHeight = view.fullHeight;\\n\\n\\t\\t\\t\\tleft += view.offsetX * width / fullWidth;\\n\\t\\t\\t\\ttop -= view.offsetY * height / fullHeight;\\n\\t\\t\\t\\twidth *= view.width / fullWidth;\\n\\t\\t\\t\\theight *= view.height / fullHeight;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar skew = this.filmOffset;\\n\\t\\t\\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\\n\\n\\t\\t\\tthis.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( meta ) {\\n\\n\\t\\t\\tvar data = Object3D.prototype.toJSON.call( this, meta );\\n\\n\\t\\t\\tdata.object.fov = this.fov;\\n\\t\\t\\tdata.object.zoom = this.zoom;\\n\\n\\t\\t\\tdata.object.near = this.near;\\n\\t\\t\\tdata.object.far = this.far;\\n\\t\\t\\tdata.object.focus = this.focus;\\n\\n\\t\\t\\tdata.object.aspect = this.aspect;\\n\\n\\t\\t\\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\\n\\n\\t\\t\\tdata.object.filmGauge = this.filmGauge;\\n\\t\\t\\tdata.object.filmOffset = this.filmOffset;\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction ArrayCamera( array ) {\\n\\n\\t\\tPerspectiveCamera.call( this );\\n\\n\\t\\tthis.cameras = array || [];\\n\\n\\t}\\n\\n\\tArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {\\n\\n\\t\\tconstructor: ArrayCamera,\\n\\n\\t\\tisArrayCamera: true\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebVRManager( renderer ) {\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\tvar device = null;\\n\\t\\tvar frameData = null;\\n\\n\\t\\tvar poseTarget = null;\\n\\n\\t\\tif ( typeof window !== 'undefined' && 'VRFrameData' in window ) {\\n\\n\\t\\t\\tframeData = new window.VRFrameData();\\n\\n\\t\\t}\\n\\n\\t\\tvar matrixWorldInverse = new Matrix4();\\n\\n\\t\\tvar cameraL = new PerspectiveCamera();\\n\\t\\tcameraL.bounds = new Vector4( 0.0, 0.0, 0.5, 1.0 );\\n\\t\\tcameraL.layers.enable( 1 );\\n\\n\\t\\tvar cameraR = new PerspectiveCamera();\\n\\t\\tcameraR.bounds = new Vector4( 0.5, 0.0, 0.5, 1.0 );\\n\\t\\tcameraR.layers.enable( 2 );\\n\\n\\t\\tvar cameraVR = new ArrayCamera( [ cameraL, cameraR ] );\\n\\t\\tcameraVR.layers.enable( 1 );\\n\\t\\tcameraVR.layers.enable( 2 );\\n\\n\\t\\t//\\n\\n\\t\\tvar currentSize, currentPixelRatio;\\n\\n\\t\\tfunction onVRDisplayPresentChange() {\\n\\n\\t\\t\\tif ( device !== null && device.isPresenting ) {\\n\\n\\t\\t\\t\\tvar eyeParameters = device.getEyeParameters( 'left' );\\n\\t\\t\\t\\tvar renderWidth = eyeParameters.renderWidth;\\n\\t\\t\\t\\tvar renderHeight = eyeParameters.renderHeight;\\n\\n\\t\\t\\t\\tcurrentPixelRatio = renderer.getPixelRatio();\\n\\t\\t\\t\\tcurrentSize = renderer.getSize();\\n\\n\\t\\t\\t\\trenderer.setDrawingBufferSize( renderWidth * 2, renderHeight, 1 );\\n\\n\\t\\t\\t} else if ( scope.enabled ) {\\n\\n\\t\\t\\t\\trenderer.setDrawingBufferSize( currentSize.width, currentSize.height, currentPixelRatio );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tif ( typeof window !== 'undefined' ) {\\n\\n\\t\\t\\twindow.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tthis.enabled = false;\\n\\n\\t\\tthis.getDevice = function () {\\n\\n\\t\\t\\treturn device;\\n\\n\\t\\t};\\n\\n\\t\\tthis.setDevice = function ( value ) {\\n\\n\\t\\t\\tif ( value !== undefined ) device = value;\\n\\n\\t\\t};\\n\\n\\t\\tthis.setPoseTarget = function ( object ) {\\n\\n\\t\\t\\tif ( object !== undefined ) poseTarget = object;\\n\\n\\t\\t};\\n\\n\\t\\tthis.getCamera = function ( camera ) {\\n\\n\\t\\t\\tif ( device === null ) return camera;\\n\\n\\t\\t\\tdevice.depthNear = camera.near;\\n\\t\\t\\tdevice.depthFar = camera.far;\\n\\n\\t\\t\\tdevice.getFrameData( frameData );\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar pose = frameData.pose;\\n\\t\\t\\tvar poseObject = poseTarget !== null ? poseTarget : camera;\\n\\n\\t\\t\\tif ( pose.position !== null ) {\\n\\n\\t\\t\\t\\tposeObject.position.fromArray( pose.position );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tposeObject.position.set( 0, 0, 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( pose.orientation !== null ) {\\n\\n\\t\\t\\t\\tposeObject.quaternion.fromArray( pose.orientation );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tposeObject.updateMatrixWorld();\\n\\n\\t\\t\\tif ( device.isPresenting === false ) return camera;\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tcameraL.near = camera.near;\\n\\t\\t\\tcameraR.near = camera.near;\\n\\n\\t\\t\\tcameraL.far = camera.far;\\n\\t\\t\\tcameraR.far = camera.far;\\n\\n\\t\\t\\tcameraVR.matrixWorld.copy( camera.matrixWorld );\\n\\t\\t\\tcameraVR.matrixWorldInverse.copy( camera.matrixWorldInverse );\\n\\n\\t\\t\\tcameraL.matrixWorldInverse.fromArray( frameData.leftViewMatrix );\\n\\t\\t\\tcameraR.matrixWorldInverse.fromArray( frameData.rightViewMatrix );\\n\\n\\t\\t\\tvar parent = poseObject.parent;\\n\\n\\t\\t\\tif ( parent !== null ) {\\n\\n\\t\\t\\t\\tmatrixWorldInverse.getInverse( parent.matrixWorld );\\n\\n\\t\\t\\t\\tcameraL.matrixWorldInverse.multiply( matrixWorldInverse );\\n\\t\\t\\t\\tcameraR.matrixWorldInverse.multiply( matrixWorldInverse );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// envMap and Mirror needs camera.matrixWorld\\n\\n\\t\\t\\tcameraL.matrixWorld.getInverse( cameraL.matrixWorldInverse );\\n\\t\\t\\tcameraR.matrixWorld.getInverse( cameraR.matrixWorldInverse );\\n\\n\\t\\t\\tcameraL.projectionMatrix.fromArray( frameData.leftProjectionMatrix );\\n\\t\\t\\tcameraR.projectionMatrix.fromArray( frameData.rightProjectionMatrix );\\n\\n\\t\\t\\t// HACK @mrdoob\\n\\t\\t\\t// https://github.com/w3c/webvr/issues/203\\n\\n\\t\\t\\tcameraVR.projectionMatrix.copy( cameraL.projectionMatrix );\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar layers = device.getLayers();\\n\\n\\t\\t\\tif ( layers.length ) {\\n\\n\\t\\t\\t\\tvar layer = layers[ 0 ];\\n\\n\\t\\t\\t\\tif ( layer.leftBounds !== null && layer.leftBounds.length === 4 ) {\\n\\n\\t\\t\\t\\t\\tcameraL.bounds.fromArray( layer.leftBounds );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( layer.rightBounds !== null && layer.rightBounds.length === 4 ) {\\n\\n\\t\\t\\t\\t\\tcameraR.bounds.fromArray( layer.rightBounds );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn cameraVR;\\n\\n\\t\\t};\\n\\n\\t\\tthis.submitFrame = function () {\\n\\n\\t\\t\\tif ( device && device.isPresenting ) device.submitFrame();\\n\\n\\t\\t};\\n\\n\\t\\tthis.dispose = function () {\\n\\n\\t\\t\\tif ( typeof window !== 'undefined' ) {\\n\\n\\t\\t\\t\\twindow.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLExtensions( gl ) {\\n\\n\\t\\tvar extensions = {};\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tget: function ( name ) {\\n\\n\\t\\t\\t\\tif ( extensions[ name ] !== undefined ) {\\n\\n\\t\\t\\t\\t\\treturn extensions[ name ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar extension;\\n\\n\\t\\t\\t\\tswitch ( name ) {\\n\\n\\t\\t\\t\\t\\tcase 'WEBGL_depth_texture':\\n\\t\\t\\t\\t\\t\\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'EXT_texture_filter_anisotropic':\\n\\t\\t\\t\\t\\t\\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'WEBGL_compressed_texture_s3tc':\\n\\t\\t\\t\\t\\t\\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'WEBGL_compressed_texture_pvrtc':\\n\\t\\t\\t\\t\\t\\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'WEBGL_compressed_texture_etc1':\\n\\t\\t\\t\\t\\t\\textension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\textension = gl.getExtension( name );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( extension === null ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\textensions[ name ] = extension;\\n\\n\\t\\t\\t\\treturn extension;\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction WebGLClipping() {\\n\\n\\t\\tvar scope = this,\\n\\n\\t\\t\\tglobalState = null,\\n\\t\\t\\tnumGlobalPlanes = 0,\\n\\t\\t\\tlocalClippingEnabled = false,\\n\\t\\t\\trenderingShadows = false,\\n\\n\\t\\t\\tplane = new Plane(),\\n\\t\\t\\tviewNormalMatrix = new Matrix3(),\\n\\n\\t\\t\\tuniform = { value: null, needsUpdate: false };\\n\\n\\t\\tthis.uniform = uniform;\\n\\t\\tthis.numPlanes = 0;\\n\\t\\tthis.numIntersection = 0;\\n\\n\\t\\tthis.init = function ( planes, enableLocalClipping, camera ) {\\n\\n\\t\\t\\tvar enabled =\\n\\t\\t\\t\\tplanes.length !== 0 ||\\n\\t\\t\\t\\tenableLocalClipping ||\\n\\t\\t\\t\\t// enable state of previous frame - the clipping code has to\\n\\t\\t\\t\\t// run another frame in order to reset the state:\\n\\t\\t\\t\\tnumGlobalPlanes !== 0 ||\\n\\t\\t\\t\\tlocalClippingEnabled;\\n\\n\\t\\t\\tlocalClippingEnabled = enableLocalClipping;\\n\\n\\t\\t\\tglobalState = projectPlanes( planes, camera, 0 );\\n\\t\\t\\tnumGlobalPlanes = planes.length;\\n\\n\\t\\t\\treturn enabled;\\n\\n\\t\\t};\\n\\n\\t\\tthis.beginShadows = function () {\\n\\n\\t\\t\\trenderingShadows = true;\\n\\t\\t\\tprojectPlanes( null );\\n\\n\\t\\t};\\n\\n\\t\\tthis.endShadows = function () {\\n\\n\\t\\t\\trenderingShadows = false;\\n\\t\\t\\tresetGlobalState();\\n\\n\\t\\t};\\n\\n\\t\\tthis.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {\\n\\n\\t\\t\\tif ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {\\n\\n\\t\\t\\t\\t// there's no local clipping\\n\\n\\t\\t\\t\\tif ( renderingShadows ) {\\n\\n\\t\\t\\t\\t\\t// there's no global clipping\\n\\n\\t\\t\\t\\t\\tprojectPlanes( null );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tresetGlobalState();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tvar nGlobal = renderingShadows ? 0 : numGlobalPlanes,\\n\\t\\t\\t\\t\\tlGlobal = nGlobal * 4,\\n\\n\\t\\t\\t\\t\\tdstArray = cache.clippingState || null;\\n\\n\\t\\t\\t\\tuniform.value = dstArray; // ensure unique state\\n\\n\\t\\t\\t\\tdstArray = projectPlanes( planes, camera, lGlobal, fromCache );\\n\\n\\t\\t\\t\\tfor ( var i = 0; i !== lGlobal; ++ i ) {\\n\\n\\t\\t\\t\\t\\tdstArray[ i ] = globalState[ i ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcache.clippingState = dstArray;\\n\\t\\t\\t\\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\\n\\t\\t\\t\\tthis.numPlanes += nGlobal;\\n\\n\\t\\t\\t}\\n\\n\\n\\t\\t};\\n\\n\\t\\tfunction resetGlobalState() {\\n\\n\\t\\t\\tif ( uniform.value !== globalState ) {\\n\\n\\t\\t\\t\\tuniform.value = globalState;\\n\\t\\t\\t\\tuniform.needsUpdate = numGlobalPlanes > 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tscope.numPlanes = numGlobalPlanes;\\n\\t\\t\\tscope.numIntersection = 0;\\n\\n\\t\\t}\\n\\n\\t\\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\\n\\n\\t\\t\\tvar nPlanes = planes !== null ? planes.length : 0,\\n\\t\\t\\t\\tdstArray = null;\\n\\n\\t\\t\\tif ( nPlanes !== 0 ) {\\n\\n\\t\\t\\t\\tdstArray = uniform.value;\\n\\n\\t\\t\\t\\tif ( skipTransform !== true || dstArray === null ) {\\n\\n\\t\\t\\t\\t\\tvar flatSize = dstOffset + nPlanes * 4,\\n\\t\\t\\t\\t\\t\\tviewMatrix = camera.matrixWorldInverse;\\n\\n\\t\\t\\t\\t\\tviewNormalMatrix.getNormalMatrix( viewMatrix );\\n\\n\\t\\t\\t\\t\\tif ( dstArray === null || dstArray.length < flatSize ) {\\n\\n\\t\\t\\t\\t\\t\\tdstArray = new Float32Array( flatSize );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {\\n\\n\\t\\t\\t\\t\\t\\tplane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );\\n\\n\\t\\t\\t\\t\\t\\tplane.normal.toArray( dstArray, i4 );\\n\\t\\t\\t\\t\\t\\tdstArray[ i4 + 3 ] = plane.constant;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tuniform.value = dstArray;\\n\\t\\t\\t\\tuniform.needsUpdate = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tscope.numPlanes = nPlanes;\\n\\n\\t\\t\\treturn dstArray;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author thespite / http://www.twitter.com/thespite\\n\\t */\\n\\n\\tfunction WebGLUtils( gl, extensions ) {\\n\\n\\t\\tfunction convert( p ) {\\n\\n\\t\\t\\tvar extension;\\n\\n\\t\\t\\tif ( p === RepeatWrapping ) return gl.REPEAT;\\n\\t\\t\\tif ( p === ClampToEdgeWrapping ) return gl.CLAMP_TO_EDGE;\\n\\t\\t\\tif ( p === MirroredRepeatWrapping ) return gl.MIRRORED_REPEAT;\\n\\n\\t\\t\\tif ( p === NearestFilter ) return gl.NEAREST;\\n\\t\\t\\tif ( p === NearestMipMapNearestFilter ) return gl.NEAREST_MIPMAP_NEAREST;\\n\\t\\t\\tif ( p === NearestMipMapLinearFilter ) return gl.NEAREST_MIPMAP_LINEAR;\\n\\n\\t\\t\\tif ( p === LinearFilter ) return gl.LINEAR;\\n\\t\\t\\tif ( p === LinearMipMapNearestFilter ) return gl.LINEAR_MIPMAP_NEAREST;\\n\\t\\t\\tif ( p === LinearMipMapLinearFilter ) return gl.LINEAR_MIPMAP_LINEAR;\\n\\n\\t\\t\\tif ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;\\n\\t\\t\\tif ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;\\n\\t\\t\\tif ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;\\n\\t\\t\\tif ( p === UnsignedShort565Type ) return gl.UNSIGNED_SHORT_5_6_5;\\n\\n\\t\\t\\tif ( p === ByteType ) return gl.BYTE;\\n\\t\\t\\tif ( p === ShortType ) return gl.SHORT;\\n\\t\\t\\tif ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;\\n\\t\\t\\tif ( p === IntType ) return gl.INT;\\n\\t\\t\\tif ( p === UnsignedIntType ) return gl.UNSIGNED_INT;\\n\\t\\t\\tif ( p === FloatType ) return gl.FLOAT;\\n\\n\\t\\t\\tif ( p === HalfFloatType ) {\\n\\n\\t\\t\\t\\textension = extensions.get( 'OES_texture_half_float' );\\n\\n\\t\\t\\t\\tif ( extension !== null ) return extension.HALF_FLOAT_OES;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( p === AlphaFormat ) return gl.ALPHA;\\n\\t\\t\\tif ( p === RGBFormat ) return gl.RGB;\\n\\t\\t\\tif ( p === RGBAFormat ) return gl.RGBA;\\n\\t\\t\\tif ( p === LuminanceFormat ) return gl.LUMINANCE;\\n\\t\\t\\tif ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;\\n\\t\\t\\tif ( p === DepthFormat ) return gl.DEPTH_COMPONENT;\\n\\t\\t\\tif ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;\\n\\n\\t\\t\\tif ( p === AddEquation ) return gl.FUNC_ADD;\\n\\t\\t\\tif ( p === SubtractEquation ) return gl.FUNC_SUBTRACT;\\n\\t\\t\\tif ( p === ReverseSubtractEquation ) return gl.FUNC_REVERSE_SUBTRACT;\\n\\n\\t\\t\\tif ( p === ZeroFactor ) return gl.ZERO;\\n\\t\\t\\tif ( p === OneFactor ) return gl.ONE;\\n\\t\\t\\tif ( p === SrcColorFactor ) return gl.SRC_COLOR;\\n\\t\\t\\tif ( p === OneMinusSrcColorFactor ) return gl.ONE_MINUS_SRC_COLOR;\\n\\t\\t\\tif ( p === SrcAlphaFactor ) return gl.SRC_ALPHA;\\n\\t\\t\\tif ( p === OneMinusSrcAlphaFactor ) return gl.ONE_MINUS_SRC_ALPHA;\\n\\t\\t\\tif ( p === DstAlphaFactor ) return gl.DST_ALPHA;\\n\\t\\t\\tif ( p === OneMinusDstAlphaFactor ) return gl.ONE_MINUS_DST_ALPHA;\\n\\n\\t\\t\\tif ( p === DstColorFactor ) return gl.DST_COLOR;\\n\\t\\t\\tif ( p === OneMinusDstColorFactor ) return gl.ONE_MINUS_DST_COLOR;\\n\\t\\t\\tif ( p === SrcAlphaSaturateFactor ) return gl.SRC_ALPHA_SATURATE;\\n\\n\\t\\t\\tif ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||\\n\\t\\t\\t\\tp === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {\\n\\n\\t\\t\\t\\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\\n\\n\\t\\t\\t\\tif ( extension !== null ) {\\n\\n\\t\\t\\t\\t\\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\\n\\t\\t\\t\\t\\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\\n\\t\\t\\t\\t\\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\\n\\t\\t\\t\\t\\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||\\n\\t\\t\\t\\tp === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {\\n\\n\\t\\t\\t\\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\\n\\n\\t\\t\\t\\tif ( extension !== null ) {\\n\\n\\t\\t\\t\\t\\tif ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\\n\\t\\t\\t\\t\\tif ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\\n\\t\\t\\t\\t\\tif ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\\n\\t\\t\\t\\t\\tif ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( p === RGB_ETC1_Format ) {\\n\\n\\t\\t\\t\\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\\n\\n\\t\\t\\t\\tif ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( p === MinEquation || p === MaxEquation ) {\\n\\n\\t\\t\\t\\textension = extensions.get( 'EXT_blend_minmax' );\\n\\n\\t\\t\\t\\tif ( extension !== null ) {\\n\\n\\t\\t\\t\\t\\tif ( p === MinEquation ) return extension.MIN_EXT;\\n\\t\\t\\t\\t\\tif ( p === MaxEquation ) return extension.MAX_EXT;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( p === UnsignedInt248Type ) {\\n\\n\\t\\t\\t\\textension = extensions.get( 'WEBGL_depth_texture' );\\n\\n\\t\\t\\t\\tif ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn 0;\\n\\n\\t\\t}\\n\\n\\t\\treturn { convert: convert };\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author supereggbert / http://www.paulbrunt.co.uk/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author szimek / https://github.com/szimek/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction WebGLRenderer( parameters ) {\\n\\n\\t\\tconsole.log( 'THREE.WebGLRenderer', REVISION );\\n\\n\\t\\tparameters = parameters || {};\\n\\n\\t\\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),\\n\\t\\t\\t_context = parameters.context !== undefined ? parameters.context : null,\\n\\n\\t\\t\\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\\n\\t\\t\\t_depth = parameters.depth !== undefined ? parameters.depth : true,\\n\\t\\t\\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\\n\\t\\t\\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\\n\\t\\t\\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\\n\\t\\t\\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\\n\\t\\t\\t_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default';\\n\\n\\t\\tvar lightsArray = [];\\n\\t\\tvar shadowsArray = [];\\n\\n\\t\\tvar currentRenderList = null;\\n\\n\\t\\tvar spritesArray = [];\\n\\t\\tvar flaresArray = [];\\n\\n\\t\\t// public properties\\n\\n\\t\\tthis.domElement = _canvas;\\n\\t\\tthis.context = null;\\n\\n\\t\\t// clearing\\n\\n\\t\\tthis.autoClear = true;\\n\\t\\tthis.autoClearColor = true;\\n\\t\\tthis.autoClearDepth = true;\\n\\t\\tthis.autoClearStencil = true;\\n\\n\\t\\t// scene graph\\n\\n\\t\\tthis.sortObjects = true;\\n\\n\\t\\t// user-defined clipping\\n\\n\\t\\tthis.clippingPlanes = [];\\n\\t\\tthis.localClippingEnabled = false;\\n\\n\\t\\t// physically based shading\\n\\n\\t\\tthis.gammaFactor = 2.0;\\t// for backwards compatibility\\n\\t\\tthis.gammaInput = false;\\n\\t\\tthis.gammaOutput = false;\\n\\n\\t\\t// physical lights\\n\\n\\t\\tthis.physicallyCorrectLights = false;\\n\\n\\t\\t// tone mapping\\n\\n\\t\\tthis.toneMapping = LinearToneMapping;\\n\\t\\tthis.toneMappingExposure = 1.0;\\n\\t\\tthis.toneMappingWhitePoint = 1.0;\\n\\n\\t\\t// morphs\\n\\n\\t\\tthis.maxMorphTargets = 8;\\n\\t\\tthis.maxMorphNormals = 4;\\n\\n\\t\\t// internal properties\\n\\n\\t\\tvar _this = this,\\n\\n\\t\\t\\t_isContextLost = false,\\n\\n\\t\\t\\t// internal state cache\\n\\n\\t\\t\\t_currentRenderTarget = null,\\n\\t\\t\\t_currentFramebuffer = null,\\n\\t\\t\\t_currentMaterialId = - 1,\\n\\t\\t\\t_currentGeometryProgram = '',\\n\\n\\t\\t\\t_currentCamera = null,\\n\\t\\t\\t_currentArrayCamera = null,\\n\\n\\t\\t\\t_currentViewport = new Vector4(),\\n\\t\\t\\t_currentScissor = new Vector4(),\\n\\t\\t\\t_currentScissorTest = null,\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\t_usedTextureUnits = 0,\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\t_width = _canvas.width,\\n\\t\\t\\t_height = _canvas.height,\\n\\n\\t\\t\\t_pixelRatio = 1,\\n\\n\\t\\t\\t_viewport = new Vector4( 0, 0, _width, _height ),\\n\\t\\t\\t_scissor = new Vector4( 0, 0, _width, _height ),\\n\\t\\t\\t_scissorTest = false,\\n\\n\\t\\t\\t// frustum\\n\\n\\t\\t\\t_frustum = new Frustum(),\\n\\n\\t\\t\\t// clipping\\n\\n\\t\\t\\t_clipping = new WebGLClipping(),\\n\\t\\t\\t_clippingEnabled = false,\\n\\t\\t\\t_localClippingEnabled = false,\\n\\n\\t\\t\\t// camera matrices cache\\n\\n\\t\\t\\t_projScreenMatrix = new Matrix4(),\\n\\n\\t\\t\\t_vector3 = new Vector3(),\\n\\n\\t\\t\\t// info\\n\\n\\t\\t\\t_infoMemory = {\\n\\t\\t\\t\\tgeometries: 0,\\n\\t\\t\\t\\ttextures: 0\\n\\t\\t\\t},\\n\\n\\t\\t\\t_infoRender = {\\n\\n\\t\\t\\t\\tframe: 0,\\n\\t\\t\\t\\tcalls: 0,\\n\\t\\t\\t\\tvertices: 0,\\n\\t\\t\\t\\tfaces: 0,\\n\\t\\t\\t\\tpoints: 0\\n\\n\\t\\t\\t};\\n\\n\\t\\tthis.info = {\\n\\n\\t\\t\\trender: _infoRender,\\n\\t\\t\\tmemory: _infoMemory,\\n\\t\\t\\tprograms: null\\n\\n\\t\\t};\\n\\n\\t\\tfunction getTargetPixelRatio() {\\n\\n\\t\\t\\treturn _currentRenderTarget === null ? _pixelRatio : 1;\\n\\n\\t\\t}\\n\\n\\t\\t// initialize\\n\\n\\t\\tvar _gl;\\n\\n\\t\\ttry {\\n\\n\\t\\t\\tvar contextAttributes = {\\n\\t\\t\\t\\talpha: _alpha,\\n\\t\\t\\t\\tdepth: _depth,\\n\\t\\t\\t\\tstencil: _stencil,\\n\\t\\t\\t\\tantialias: _antialias,\\n\\t\\t\\t\\tpremultipliedAlpha: _premultipliedAlpha,\\n\\t\\t\\t\\tpreserveDrawingBuffer: _preserveDrawingBuffer,\\n\\t\\t\\t\\tpowerPreference: _powerPreference\\n\\t\\t\\t};\\n\\n\\t\\t\\t// event listeners must be registered before WebGL context is created, see #12753\\n\\n\\t\\t\\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\\n\\t\\t\\t_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );\\n\\n\\t\\t\\t_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );\\n\\n\\t\\t\\tif ( _gl === null ) {\\n\\n\\t\\t\\t\\tif ( _canvas.getContext( 'webgl' ) !== null ) {\\n\\n\\t\\t\\t\\t\\tthrow new Error( 'Error creating WebGL context with your selected attributes.' );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthrow new Error( 'Error creating WebGL context.' );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\\n\\n\\t\\t\\tif ( _gl.getShaderPrecisionFormat === undefined ) {\\n\\n\\t\\t\\t\\t_gl.getShaderPrecisionFormat = function () {\\n\\n\\t\\t\\t\\t\\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\\n\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t}\\n\\n\\t\\t} catch ( error ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.WebGLRenderer: ' + error.message );\\n\\n\\t\\t}\\n\\n\\t\\tvar extensions, capabilities, state;\\n\\t\\tvar properties, textures, attributes, geometries, objects, lights;\\n\\t\\tvar programCache, renderLists;\\n\\n\\t\\tvar background, morphtargets, bufferRenderer, indexedBufferRenderer;\\n\\t\\tvar flareRenderer, spriteRenderer;\\n\\n\\t\\tvar utils;\\n\\n\\t\\tfunction initGLContext() {\\n\\n\\t\\t\\textensions = new WebGLExtensions( _gl );\\n\\t\\t\\textensions.get( 'WEBGL_depth_texture' );\\n\\t\\t\\textensions.get( 'OES_texture_float' );\\n\\t\\t\\textensions.get( 'OES_texture_float_linear' );\\n\\t\\t\\textensions.get( 'OES_texture_half_float' );\\n\\t\\t\\textensions.get( 'OES_texture_half_float_linear' );\\n\\t\\t\\textensions.get( 'OES_standard_derivatives' );\\n\\t\\t\\textensions.get( 'OES_element_index_uint' );\\n\\t\\t\\textensions.get( 'ANGLE_instanced_arrays' );\\n\\n\\t\\t\\tutils = new WebGLUtils( _gl, extensions );\\n\\n\\t\\t\\tcapabilities = new WebGLCapabilities( _gl, extensions, parameters );\\n\\n\\t\\t\\tstate = new WebGLState( _gl, extensions, utils );\\n\\t\\t\\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\\n\\t\\t\\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\\n\\n\\t\\t\\tproperties = new WebGLProperties();\\n\\t\\t\\ttextures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, _infoMemory );\\n\\t\\t\\tattributes = new WebGLAttributes( _gl );\\n\\t\\t\\tgeometries = new WebGLGeometries( _gl, attributes, _infoMemory );\\n\\t\\t\\tobjects = new WebGLObjects( geometries, _infoRender );\\n\\t\\t\\tmorphtargets = new WebGLMorphtargets( _gl );\\n\\t\\t\\tprogramCache = new WebGLPrograms( _this, extensions, capabilities );\\n\\t\\t\\tlights = new WebGLLights();\\n\\t\\t\\trenderLists = new WebGLRenderLists();\\n\\n\\t\\t\\tbackground = new WebGLBackground( _this, state, geometries, _premultipliedAlpha );\\n\\n\\t\\t\\tbufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );\\n\\t\\t\\tindexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\\n\\n\\t\\t\\tflareRenderer = new WebGLFlareRenderer( _this, _gl, state, textures, capabilities );\\n\\t\\t\\tspriteRenderer = new WebGLSpriteRenderer( _this, _gl, state, textures, capabilities );\\n\\n\\t\\t\\t_this.info.programs = programCache.programs;\\n\\n\\t\\t\\t_this.context = _gl;\\n\\t\\t\\t_this.capabilities = capabilities;\\n\\t\\t\\t_this.extensions = extensions;\\n\\t\\t\\t_this.properties = properties;\\n\\t\\t\\t_this.renderLists = renderLists;\\n\\t\\t\\t_this.state = state;\\n\\n\\t\\t}\\n\\n\\t\\tinitGLContext();\\n\\n\\t\\t// vr\\n\\n\\t\\tvar vr = new WebVRManager( _this );\\n\\n\\t\\tthis.vr = vr;\\n\\n\\t\\t// shadow map\\n\\n\\t\\tvar shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );\\n\\n\\t\\tthis.shadowMap = shadowMap;\\n\\n\\t\\t// API\\n\\n\\t\\tthis.getContext = function () {\\n\\n\\t\\t\\treturn _gl;\\n\\n\\t\\t};\\n\\n\\t\\tthis.getContextAttributes = function () {\\n\\n\\t\\t\\treturn _gl.getContextAttributes();\\n\\n\\t\\t};\\n\\n\\t\\tthis.forceContextLoss = function () {\\n\\n\\t\\t\\tvar extension = extensions.get( 'WEBGL_lose_context' );\\n\\t\\t\\tif ( extension ) extension.loseContext();\\n\\n\\t\\t};\\n\\n\\t\\tthis.forceContextRestore = function () {\\n\\n\\t\\t\\tvar extension = extensions.get( 'WEBGL_lose_context' );\\n\\t\\t\\tif ( extension ) extension.restoreContext();\\n\\n\\t\\t};\\n\\n\\t\\tthis.getPixelRatio = function () {\\n\\n\\t\\t\\treturn _pixelRatio;\\n\\n\\t\\t};\\n\\n\\t\\tthis.setPixelRatio = function ( value ) {\\n\\n\\t\\t\\tif ( value === undefined ) return;\\n\\n\\t\\t\\t_pixelRatio = value;\\n\\n\\t\\t\\tthis.setSize( _width, _height, false );\\n\\n\\t\\t};\\n\\n\\t\\tthis.getSize = function () {\\n\\n\\t\\t\\treturn {\\n\\t\\t\\t\\twidth: _width,\\n\\t\\t\\t\\theight: _height\\n\\t\\t\\t};\\n\\n\\t\\t};\\n\\n\\t\\tthis.setSize = function ( width, height, updateStyle ) {\\n\\n\\t\\t\\tvar device = vr.getDevice();\\n\\n\\t\\t\\tif ( device && device.isPresenting ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Can\\\\'t change size while VR device is presenting.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t_width = width;\\n\\t\\t\\t_height = height;\\n\\n\\t\\t\\t_canvas.width = width * _pixelRatio;\\n\\t\\t\\t_canvas.height = height * _pixelRatio;\\n\\n\\t\\t\\tif ( updateStyle !== false ) {\\n\\n\\t\\t\\t\\t_canvas.style.width = width + 'px';\\n\\t\\t\\t\\t_canvas.style.height = height + 'px';\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.setViewport( 0, 0, width, height );\\n\\n\\t\\t};\\n\\n\\t\\tthis.getDrawingBufferSize = function () {\\n\\n\\t\\t\\treturn {\\n\\t\\t\\t\\twidth: _width * _pixelRatio,\\n\\t\\t\\t\\theight: _height * _pixelRatio\\n\\t\\t\\t};\\n\\n\\t\\t};\\n\\n\\t\\tthis.setDrawingBufferSize = function ( width, height, pixelRatio ) {\\n\\n\\t\\t\\t_width = width;\\n\\t\\t\\t_height = height;\\n\\n\\t\\t\\t_pixelRatio = pixelRatio;\\n\\n\\t\\t\\t_canvas.width = width * pixelRatio;\\n\\t\\t\\t_canvas.height = height * pixelRatio;\\n\\n\\t\\t\\tthis.setViewport( 0, 0, width, height );\\n\\n\\t\\t};\\n\\n\\t\\tthis.setViewport = function ( x, y, width, height ) {\\n\\n\\t\\t\\t_viewport.set( x, _height - y - height, width, height );\\n\\t\\t\\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\\n\\n\\t\\t};\\n\\n\\t\\tthis.setScissor = function ( x, y, width, height ) {\\n\\n\\t\\t\\t_scissor.set( x, _height - y - height, width, height );\\n\\t\\t\\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\\n\\n\\t\\t};\\n\\n\\t\\tthis.setScissorTest = function ( boolean ) {\\n\\n\\t\\t\\tstate.setScissorTest( _scissorTest = boolean );\\n\\n\\t\\t};\\n\\n\\t\\t// Clearing\\n\\n\\t\\tthis.getClearColor = function () {\\n\\n\\t\\t\\treturn background.getClearColor();\\n\\n\\t\\t};\\n\\n\\t\\tthis.setClearColor = function () {\\n\\n\\t\\t\\tbackground.setClearColor.apply( background, arguments );\\n\\n\\t\\t};\\n\\n\\t\\tthis.getClearAlpha = function () {\\n\\n\\t\\t\\treturn background.getClearAlpha();\\n\\n\\t\\t};\\n\\n\\t\\tthis.setClearAlpha = function () {\\n\\n\\t\\t\\tbackground.setClearAlpha.apply( background, arguments );\\n\\n\\t\\t};\\n\\n\\t\\tthis.clear = function ( color, depth, stencil ) {\\n\\n\\t\\t\\tvar bits = 0;\\n\\n\\t\\t\\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\\n\\t\\t\\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\\n\\t\\t\\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\\n\\n\\t\\t\\t_gl.clear( bits );\\n\\n\\t\\t};\\n\\n\\t\\tthis.clearColor = function () {\\n\\n\\t\\t\\tthis.clear( true, false, false );\\n\\n\\t\\t};\\n\\n\\t\\tthis.clearDepth = function () {\\n\\n\\t\\t\\tthis.clear( false, true, false );\\n\\n\\t\\t};\\n\\n\\t\\tthis.clearStencil = function () {\\n\\n\\t\\t\\tthis.clear( false, false, true );\\n\\n\\t\\t};\\n\\n\\t\\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\\n\\n\\t\\t\\tthis.setRenderTarget( renderTarget );\\n\\t\\t\\tthis.clear( color, depth, stencil );\\n\\n\\t\\t};\\n\\n\\t\\t//\\n\\n\\t\\tthis.dispose = function () {\\n\\n\\t\\t\\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\\n\\t\\t\\t_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );\\n\\n\\t\\t\\trenderLists.dispose();\\n\\n\\t\\t\\tvr.dispose();\\n\\n\\t\\t};\\n\\n\\t\\t// Events\\n\\n\\t\\tfunction onContextLost( event ) {\\n\\n\\t\\t\\tevent.preventDefault();\\n\\n\\t\\t\\tconsole.log( 'THREE.WebGLRenderer: Context Lost.' );\\n\\n\\t\\t\\t_isContextLost = true;\\n\\n\\t\\t}\\n\\n\\t\\tfunction onContextRestore( /* event */ ) {\\n\\n\\t\\t\\tconsole.log( 'THREE.WebGLRenderer: Context Restored.' );\\n\\n\\t\\t\\t_isContextLost = false;\\n\\n\\t\\t\\tinitGLContext();\\n\\n\\t\\t}\\n\\n\\t\\tfunction onMaterialDispose( event ) {\\n\\n\\t\\t\\tvar material = event.target;\\n\\n\\t\\t\\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\\n\\n\\t\\t\\tdeallocateMaterial( material );\\n\\n\\t\\t}\\n\\n\\t\\t// Buffer deallocation\\n\\n\\t\\tfunction deallocateMaterial( material ) {\\n\\n\\t\\t\\treleaseMaterialProgramReference( material );\\n\\n\\t\\t\\tproperties.remove( material );\\n\\n\\t\\t}\\n\\n\\n\\t\\tfunction releaseMaterialProgramReference( material ) {\\n\\n\\t\\t\\tvar programInfo = properties.get( material ).program;\\n\\n\\t\\t\\tmaterial.program = undefined;\\n\\n\\t\\t\\tif ( programInfo !== undefined ) {\\n\\n\\t\\t\\t\\tprogramCache.releaseProgram( programInfo );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// Buffer rendering\\n\\n\\t\\tfunction renderObjectImmediate( object, program, material ) {\\n\\n\\t\\t\\tobject.render( function ( object ) {\\n\\n\\t\\t\\t\\t_this.renderBufferImmediate( object, program, material );\\n\\n\\t\\t\\t} );\\n\\n\\t\\t}\\n\\n\\t\\tthis.renderBufferImmediate = function ( object, program, material ) {\\n\\n\\t\\t\\tstate.initAttributes();\\n\\n\\t\\t\\tvar buffers = properties.get( object );\\n\\n\\t\\t\\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\\n\\t\\t\\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\\n\\t\\t\\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\\n\\t\\t\\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\\n\\n\\t\\t\\tvar programAttributes = program.getAttributes();\\n\\n\\t\\t\\tif ( object.hasPositions ) {\\n\\n\\t\\t\\t\\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\\n\\t\\t\\t\\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\\n\\n\\t\\t\\t\\tstate.enableAttribute( programAttributes.position );\\n\\t\\t\\t\\t_gl.vertexAttribPointer( programAttributes.position, 3, _gl.FLOAT, false, 0, 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( object.hasNormals ) {\\n\\n\\t\\t\\t\\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\\n\\n\\t\\t\\t\\tif ( ! material.isMeshPhongMaterial &&\\n\\t\\t\\t\\t\\t! material.isMeshStandardMaterial &&\\n\\t\\t\\t\\t\\t! material.isMeshNormalMaterial &&\\n\\t\\t\\t\\t\\tmaterial.flatShading === true ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\\n\\n\\t\\t\\t\\t\\t\\tvar array = object.normalArray;\\n\\n\\t\\t\\t\\t\\t\\tvar nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\\n\\t\\t\\t\\t\\t\\tvar ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\\n\\t\\t\\t\\t\\t\\tvar nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\\n\\n\\t\\t\\t\\t\\t\\tarray[ i + 0 ] = nx;\\n\\t\\t\\t\\t\\t\\tarray[ i + 1 ] = ny;\\n\\t\\t\\t\\t\\t\\tarray[ i + 2 ] = nz;\\n\\n\\t\\t\\t\\t\\t\\tarray[ i + 3 ] = nx;\\n\\t\\t\\t\\t\\t\\tarray[ i + 4 ] = ny;\\n\\t\\t\\t\\t\\t\\tarray[ i + 5 ] = nz;\\n\\n\\t\\t\\t\\t\\t\\tarray[ i + 6 ] = nx;\\n\\t\\t\\t\\t\\t\\tarray[ i + 7 ] = ny;\\n\\t\\t\\t\\t\\t\\tarray[ i + 8 ] = nz;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\\n\\n\\t\\t\\t\\tstate.enableAttribute( programAttributes.normal );\\n\\n\\t\\t\\t\\t_gl.vertexAttribPointer( programAttributes.normal, 3, _gl.FLOAT, false, 0, 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( object.hasUvs && material.map ) {\\n\\n\\t\\t\\t\\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\\n\\t\\t\\t\\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\\n\\n\\t\\t\\t\\tstate.enableAttribute( programAttributes.uv );\\n\\n\\t\\t\\t\\t_gl.vertexAttribPointer( programAttributes.uv, 2, _gl.FLOAT, false, 0, 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( object.hasColors && material.vertexColors !== NoColors ) {\\n\\n\\t\\t\\t\\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\\n\\t\\t\\t\\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\\n\\n\\t\\t\\t\\tstate.enableAttribute( programAttributes.color );\\n\\n\\t\\t\\t\\t_gl.vertexAttribPointer( programAttributes.color, 3, _gl.FLOAT, false, 0, 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tstate.disableUnusedAttributes();\\n\\n\\t\\t\\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\\n\\n\\t\\t\\tobject.count = 0;\\n\\n\\t\\t};\\n\\n\\t\\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\\n\\n\\t\\t\\tvar frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\\n\\n\\t\\t\\tstate.setMaterial( material, frontFaceCW );\\n\\n\\t\\t\\tvar program = setProgram( camera, fog, material, object );\\n\\t\\t\\tvar geometryProgram = geometry.id + '_' + program.id + '_' + ( material.wireframe === true );\\n\\n\\t\\t\\tvar updateBuffers = false;\\n\\n\\t\\t\\tif ( geometryProgram !== _currentGeometryProgram ) {\\n\\n\\t\\t\\t\\t_currentGeometryProgram = geometryProgram;\\n\\t\\t\\t\\tupdateBuffers = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( object.morphTargetInfluences ) {\\n\\n\\t\\t\\t\\tmorphtargets.update( object, geometry, material, program );\\n\\n\\t\\t\\t\\tupdateBuffers = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar index = geometry.index;\\n\\t\\t\\tvar position = geometry.attributes.position;\\n\\t\\t\\tvar rangeFactor = 1;\\n\\n\\t\\t\\tif ( material.wireframe === true ) {\\n\\n\\t\\t\\t\\tindex = geometries.getWireframeAttribute( geometry );\\n\\t\\t\\t\\trangeFactor = 2;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar attribute;\\n\\t\\t\\tvar renderer = bufferRenderer;\\n\\n\\t\\t\\tif ( index !== null ) {\\n\\n\\t\\t\\t\\tattribute = attributes.get( index );\\n\\n\\t\\t\\t\\trenderer = indexedBufferRenderer;\\n\\t\\t\\t\\trenderer.setIndex( attribute );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( updateBuffers ) {\\n\\n\\t\\t\\t\\tsetupVertexAttributes( material, program, geometry );\\n\\n\\t\\t\\t\\tif ( index !== null ) {\\n\\n\\t\\t\\t\\t\\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attribute.buffer );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar dataCount = 0;\\n\\n\\t\\t\\tif ( index !== null ) {\\n\\n\\t\\t\\t\\tdataCount = index.count;\\n\\n\\t\\t\\t} else if ( position !== undefined ) {\\n\\n\\t\\t\\t\\tdataCount = position.count;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar rangeStart = geometry.drawRange.start * rangeFactor;\\n\\t\\t\\tvar rangeCount = geometry.drawRange.count * rangeFactor;\\n\\n\\t\\t\\tvar groupStart = group !== null ? group.start * rangeFactor : 0;\\n\\t\\t\\tvar groupCount = group !== null ? group.count * rangeFactor : Infinity;\\n\\n\\t\\t\\tvar drawStart = Math.max( rangeStart, groupStart );\\n\\t\\t\\tvar drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\\n\\n\\t\\t\\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\\n\\n\\t\\t\\tif ( drawCount === 0 ) return;\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tif ( object.isMesh ) {\\n\\n\\t\\t\\t\\tif ( material.wireframe === true ) {\\n\\n\\t\\t\\t\\t\\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\\n\\t\\t\\t\\t\\trenderer.setMode( _gl.LINES );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tswitch ( object.drawMode ) {\\n\\n\\t\\t\\t\\t\\t\\tcase TrianglesDrawMode:\\n\\t\\t\\t\\t\\t\\t\\trenderer.setMode( _gl.TRIANGLES );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase TriangleStripDrawMode:\\n\\t\\t\\t\\t\\t\\t\\trenderer.setMode( _gl.TRIANGLE_STRIP );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase TriangleFanDrawMode:\\n\\t\\t\\t\\t\\t\\t\\trenderer.setMode( _gl.TRIANGLE_FAN );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t} else if ( object.isLine ) {\\n\\n\\t\\t\\t\\tvar lineWidth = material.linewidth;\\n\\n\\t\\t\\t\\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\\n\\n\\t\\t\\t\\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\\n\\n\\t\\t\\t\\tif ( object.isLineSegments ) {\\n\\n\\t\\t\\t\\t\\trenderer.setMode( _gl.LINES );\\n\\n\\t\\t\\t\\t} else if ( object.isLineLoop ) {\\n\\n\\t\\t\\t\\t\\trenderer.setMode( _gl.LINE_LOOP );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\trenderer.setMode( _gl.LINE_STRIP );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( object.isPoints ) {\\n\\n\\t\\t\\t\\trenderer.setMode( _gl.POINTS );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry && geometry.isInstancedBufferGeometry ) {\\n\\n\\t\\t\\t\\tif ( geometry.maxInstancedCount > 0 ) {\\n\\n\\t\\t\\t\\t\\trenderer.renderInstances( geometry, drawStart, drawCount );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\trenderer.render( drawStart, drawCount );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\\n\\n\\t\\t\\tif ( geometry && geometry.isInstancedBufferGeometry ) {\\n\\n\\t\\t\\t\\tif ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) {\\n\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\\n\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( startIndex === undefined ) startIndex = 0;\\n\\n\\t\\t\\tstate.initAttributes();\\n\\n\\t\\t\\tvar geometryAttributes = geometry.attributes;\\n\\n\\t\\t\\tvar programAttributes = program.getAttributes();\\n\\n\\t\\t\\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\\n\\n\\t\\t\\tfor ( var name in programAttributes ) {\\n\\n\\t\\t\\t\\tvar programAttribute = programAttributes[ name ];\\n\\n\\t\\t\\t\\tif ( programAttribute >= 0 ) {\\n\\n\\t\\t\\t\\t\\tvar geometryAttribute = geometryAttributes[ name ];\\n\\n\\t\\t\\t\\t\\tif ( geometryAttribute !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tvar normalized = geometryAttribute.normalized;\\n\\t\\t\\t\\t\\t\\tvar size = geometryAttribute.itemSize;\\n\\n\\t\\t\\t\\t\\t\\tvar attribute = attributes.get( geometryAttribute );\\n\\n\\t\\t\\t\\t\\t\\t// TODO Attribute may not be available on context restore\\n\\n\\t\\t\\t\\t\\t\\tif ( attribute === undefined ) continue;\\n\\n\\t\\t\\t\\t\\t\\tvar buffer = attribute.buffer;\\n\\t\\t\\t\\t\\t\\tvar type = attribute.type;\\n\\t\\t\\t\\t\\t\\tvar bytesPerElement = attribute.bytesPerElement;\\n\\n\\t\\t\\t\\t\\t\\tif ( geometryAttribute.isInterleavedBufferAttribute ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar data = geometryAttribute.data;\\n\\t\\t\\t\\t\\t\\t\\tvar stride = data.stride;\\n\\t\\t\\t\\t\\t\\t\\tvar offset = geometryAttribute.offset;\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( data && data.isInstancedInterleavedBuffer ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( geometry.maxInstancedCount === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tstate.enableAttribute( programAttribute );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\\n\\t\\t\\t\\t\\t\\t\\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, ( startIndex * stride + offset ) * bytesPerElement );\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( geometryAttribute.isInstancedBufferAttribute ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( geometry.maxInstancedCount === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tstate.enableAttribute( programAttribute );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\\n\\t\\t\\t\\t\\t\\t\\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * bytesPerElement );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else if ( materialDefaultAttributeValues !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tvar value = materialDefaultAttributeValues[ name ];\\n\\n\\t\\t\\t\\t\\t\\tif ( value !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tswitch ( value.length ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase 2:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t_gl.vertexAttrib2fv( programAttribute, value );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase 3:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t_gl.vertexAttrib3fv( programAttribute, value );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase 4:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t_gl.vertexAttrib4fv( programAttribute, value );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t_gl.vertexAttrib1fv( programAttribute, value );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tstate.disableUnusedAttributes();\\n\\n\\t\\t}\\n\\n\\t\\t// Compile\\n\\n\\t\\tthis.compile = function ( scene, camera ) {\\n\\n\\t\\t\\tlightsArray.length = 0;\\n\\t\\t\\tshadowsArray.length = 0;\\n\\n\\t\\t\\tscene.traverse( function ( object ) {\\n\\n\\t\\t\\t\\tif ( object.isLight ) {\\n\\n\\t\\t\\t\\t\\tlightsArray.push( object );\\n\\n\\t\\t\\t\\t\\tif ( object.castShadow ) {\\n\\n\\t\\t\\t\\t\\t\\tshadowsArray.push( object );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} );\\n\\n\\t\\t\\tlights.setup( lightsArray, shadowsArray, camera );\\n\\n\\t\\t\\tscene.traverse( function ( object ) {\\n\\n\\t\\t\\t\\tif ( object.material ) {\\n\\n\\t\\t\\t\\t\\tif ( Array.isArray( object.material ) ) {\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < object.material.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tinitMaterial( object.material[ i ], scene.fog, object );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tinitMaterial( object.material, scene.fog, object );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} );\\n\\n\\t\\t};\\n\\n\\t\\t// Animation Loop\\n\\n\\t\\tvar isAnimating = false;\\n\\t\\tvar onAnimationFrame = null;\\n\\n\\t\\tfunction start() {\\n\\n\\t\\t\\tif ( isAnimating ) return;\\n\\n\\t\\t\\tvar device = vr.getDevice();\\n\\n\\t\\t\\tif ( device && device.isPresenting ) {\\n\\n\\t\\t\\t\\tdevice.requestAnimationFrame( loop );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\twindow.requestAnimationFrame( loop );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tisAnimating = true;\\n\\n\\t\\t}\\n\\n\\t\\tfunction loop( time ) {\\n\\n\\t\\t\\tif ( onAnimationFrame !== null ) onAnimationFrame( time );\\n\\n\\t\\t\\tvar device = vr.getDevice();\\n\\n\\t\\t\\tif ( device && device.isPresenting ) {\\n\\n\\t\\t\\t\\tdevice.requestAnimationFrame( loop );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\twindow.requestAnimationFrame( loop );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tthis.animate = function ( callback ) {\\n\\n\\t\\t\\tonAnimationFrame = callback;\\n\\t\\t\\tstart();\\n\\n\\t\\t};\\n\\n\\t\\t// Rendering\\n\\n\\t\\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\\n\\n\\t\\t\\tif ( ! ( camera && camera.isCamera ) ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( _isContextLost ) return;\\n\\n\\t\\t\\t// reset caching for this frame\\n\\n\\t\\t\\t_currentGeometryProgram = '';\\n\\t\\t\\t_currentMaterialId = - 1;\\n\\t\\t\\t_currentCamera = null;\\n\\n\\t\\t\\t// update scene graph\\n\\n\\t\\t\\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\\n\\n\\t\\t\\t// update camera matrices and frustum\\n\\n\\t\\t\\tif ( camera.parent === null ) camera.updateMatrixWorld();\\n\\n\\t\\t\\tif ( vr.enabled ) {\\n\\n\\t\\t\\t\\tcamera = vr.getCamera( camera );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\\n\\t\\t\\t_frustum.setFromMatrix( _projScreenMatrix );\\n\\n\\t\\t\\tlightsArray.length = 0;\\n\\t\\t\\tshadowsArray.length = 0;\\n\\n\\t\\t\\tspritesArray.length = 0;\\n\\t\\t\\tflaresArray.length = 0;\\n\\n\\t\\t\\t_localClippingEnabled = this.localClippingEnabled;\\n\\t\\t\\t_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\\n\\n\\t\\t\\tcurrentRenderList = renderLists.get( scene, camera );\\n\\t\\t\\tcurrentRenderList.init();\\n\\n\\t\\t\\tprojectObject( scene, camera, _this.sortObjects );\\n\\n\\t\\t\\tif ( _this.sortObjects === true ) {\\n\\n\\t\\t\\t\\tcurrentRenderList.sort();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\ttextures.updateVideoTextures();\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tif ( _clippingEnabled ) _clipping.beginShadows();\\n\\n\\t\\t\\tshadowMap.render( shadowsArray, scene, camera );\\n\\n\\t\\t\\tlights.setup( lightsArray, shadowsArray, camera );\\n\\n\\t\\t\\tif ( _clippingEnabled ) _clipping.endShadows();\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\t_infoRender.frame ++;\\n\\t\\t\\t_infoRender.calls = 0;\\n\\t\\t\\t_infoRender.vertices = 0;\\n\\t\\t\\t_infoRender.faces = 0;\\n\\t\\t\\t_infoRender.points = 0;\\n\\n\\t\\t\\tif ( renderTarget === undefined ) {\\n\\n\\t\\t\\t\\trenderTarget = null;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.setRenderTarget( renderTarget );\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tbackground.render( currentRenderList, scene, camera, forceClear );\\n\\n\\t\\t\\t// render scene\\n\\n\\t\\t\\tvar opaqueObjects = currentRenderList.opaque;\\n\\t\\t\\tvar transparentObjects = currentRenderList.transparent;\\n\\n\\t\\t\\tif ( scene.overrideMaterial ) {\\n\\n\\t\\t\\t\\tvar overrideMaterial = scene.overrideMaterial;\\n\\n\\t\\t\\t\\tif ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial );\\n\\t\\t\\t\\tif ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// opaque pass (front-to-back order)\\n\\n\\t\\t\\t\\tif ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera );\\n\\n\\t\\t\\t\\t// transparent pass (back-to-front order)\\n\\n\\t\\t\\t\\tif ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// custom renderers\\n\\n\\t\\t\\tspriteRenderer.render( spritesArray, scene, camera );\\n\\t\\t\\tflareRenderer.render( flaresArray, scene, camera, _currentViewport );\\n\\n\\t\\t\\t// Generate mipmap if we're using any kind of mipmap filtering\\n\\n\\t\\t\\tif ( renderTarget ) {\\n\\n\\t\\t\\t\\ttextures.updateRenderTargetMipmap( renderTarget );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Ensure depth buffer writing is enabled so it can be cleared on next render\\n\\n\\t\\t\\tstate.buffers.depth.setTest( true );\\n\\t\\t\\tstate.buffers.depth.setMask( true );\\n\\t\\t\\tstate.buffers.color.setMask( true );\\n\\n\\t\\t\\tstate.setPolygonOffset( false );\\n\\n\\t\\t\\tif ( vr.enabled ) {\\n\\n\\t\\t\\t\\tvr.submitFrame();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// _gl.finish();\\n\\n\\t\\t};\\n\\n\\t\\t/*\\n\\t\\t// TODO Duplicated code (Frustum)\\n\\n\\t\\tvar _sphere = new Sphere();\\n\\n\\t\\tfunction isObjectViewable( object ) {\\n\\n\\t\\t\\tvar geometry = object.geometry;\\n\\n\\t\\t\\tif ( geometry.boundingSphere === null )\\n\\t\\t\\t\\tgeometry.computeBoundingSphere();\\n\\n\\t\\t\\t_sphere.copy( geometry.boundingSphere ).\\n\\t\\t\\tapplyMatrix4( object.matrixWorld );\\n\\n\\t\\t\\treturn isSphereViewable( _sphere );\\n\\n\\t\\t}\\n\\n\\t\\tfunction isSpriteViewable( sprite ) {\\n\\n\\t\\t\\t_sphere.center.set( 0, 0, 0 );\\n\\t\\t\\t_sphere.radius = 0.7071067811865476;\\n\\t\\t\\t_sphere.applyMatrix4( sprite.matrixWorld );\\n\\n\\t\\t\\treturn isSphereViewable( _sphere );\\n\\n\\t\\t}\\n\\n\\t\\tfunction isSphereViewable( sphere ) {\\n\\n\\t\\t\\tif ( ! _frustum.intersectsSphere( sphere ) ) return false;\\n\\n\\t\\t\\tvar numPlanes = _clipping.numPlanes;\\n\\n\\t\\t\\tif ( numPlanes === 0 ) return true;\\n\\n\\t\\t\\tvar planes = _this.clippingPlanes,\\n\\n\\t\\t\\t\\tcenter = sphere.center,\\n\\t\\t\\t\\tnegRad = - sphere.radius,\\n\\t\\t\\t\\ti = 0;\\n\\n\\t\\t\\tdo {\\n\\n\\t\\t\\t\\t// out when deeper than radius in the negative halfspace\\n\\t\\t\\t\\tif ( planes[ i ].distanceToPoint( center ) < negRad ) return false;\\n\\n\\t\\t\\t} while ( ++ i !== numPlanes );\\n\\n\\t\\t\\treturn true;\\n\\n\\t\\t}\\n\\t\\t*/\\n\\n\\t\\tfunction projectObject( object, camera, sortObjects ) {\\n\\n\\t\\t\\tif ( object.visible === false ) return;\\n\\n\\t\\t\\tvar visible = object.layers.test( camera.layers );\\n\\n\\t\\t\\tif ( visible ) {\\n\\n\\t\\t\\t\\tif ( object.isLight ) {\\n\\n\\t\\t\\t\\t\\tlightsArray.push( object );\\n\\n\\t\\t\\t\\t\\tif ( object.castShadow ) {\\n\\n\\t\\t\\t\\t\\t\\tshadowsArray.push( object );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( object.isSprite ) {\\n\\n\\t\\t\\t\\t\\tif ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {\\n\\n\\t\\t\\t\\t\\t\\tspritesArray.push( object );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( object.isLensFlare ) {\\n\\n\\t\\t\\t\\t\\tflaresArray.push( object );\\n\\n\\t\\t\\t\\t} else if ( object.isImmediateRenderObject ) {\\n\\n\\t\\t\\t\\t\\tif ( sortObjects ) {\\n\\n\\t\\t\\t\\t\\t\\t_vector3.setFromMatrixPosition( object.matrixWorld )\\n\\t\\t\\t\\t\\t\\t\\t.applyMatrix4( _projScreenMatrix );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tcurrentRenderList.push( object, null, object.material, _vector3.z, null );\\n\\n\\t\\t\\t\\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\\n\\n\\t\\t\\t\\t\\tif ( object.isSkinnedMesh ) {\\n\\n\\t\\t\\t\\t\\t\\tobject.skeleton.update();\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( sortObjects ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t_vector3.setFromMatrixPosition( object.matrixWorld )\\n\\t\\t\\t\\t\\t\\t\\t\\t.applyMatrix4( _projScreenMatrix );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tvar geometry = objects.update( object );\\n\\t\\t\\t\\t\\t\\tvar material = object.material;\\n\\n\\t\\t\\t\\t\\t\\tif ( Array.isArray( material ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar groups = geometry.groups;\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar group = groups[ i ];\\n\\t\\t\\t\\t\\t\\t\\t\\tvar groupMaterial = material[ group.materialIndex ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( groupMaterial && groupMaterial.visible ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcurrentRenderList.push( object, geometry, groupMaterial, _vector3.z, group );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t} else if ( material.visible ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tcurrentRenderList.push( object, geometry, material, _vector3.z, null );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar children = object.children;\\n\\n\\t\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tprojectObject( children[ i ], camera, sortObjects );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction renderObjects( renderList, scene, camera, overrideMaterial ) {\\n\\n\\t\\t\\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar renderItem = renderList[ i ];\\n\\n\\t\\t\\t\\tvar object = renderItem.object;\\n\\t\\t\\t\\tvar geometry = renderItem.geometry;\\n\\t\\t\\t\\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\\n\\t\\t\\t\\tvar group = renderItem.group;\\n\\n\\t\\t\\t\\tif ( camera.isArrayCamera ) {\\n\\n\\t\\t\\t\\t\\t_currentArrayCamera = camera;\\n\\n\\t\\t\\t\\t\\tvar cameras = camera.cameras;\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0, jl = cameras.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar camera2 = cameras[ j ];\\n\\n\\t\\t\\t\\t\\t\\tif ( object.layers.test( camera2.layers ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar bounds = camera2.bounds;\\n\\n\\t\\t\\t\\t\\t\\t\\tvar x = bounds.x * _width;\\n\\t\\t\\t\\t\\t\\t\\tvar y = bounds.y * _height;\\n\\t\\t\\t\\t\\t\\t\\tvar width = bounds.z * _width;\\n\\t\\t\\t\\t\\t\\t\\tvar height = bounds.w * _height;\\n\\n\\t\\t\\t\\t\\t\\t\\tstate.viewport( _currentViewport.set( x, y, width, height ).multiplyScalar( _pixelRatio ) );\\n\\n\\t\\t\\t\\t\\t\\t\\trenderObject( object, scene, camera2, geometry, material, group );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t_currentArrayCamera = null;\\n\\n\\t\\t\\t\\t\\trenderObject( object, scene, camera, geometry, material, group );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction renderObject( object, scene, camera, geometry, material, group ) {\\n\\n\\t\\t\\tobject.onBeforeRender( _this, scene, camera, geometry, material, group );\\n\\n\\t\\t\\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\\n\\t\\t\\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\\n\\n\\t\\t\\tif ( object.isImmediateRenderObject ) {\\n\\n\\t\\t\\t\\tvar frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\\n\\n\\t\\t\\t\\tstate.setMaterial( material, frontFaceCW );\\n\\n\\t\\t\\t\\tvar program = setProgram( camera, scene.fog, material, object );\\n\\n\\t\\t\\t\\t_currentGeometryProgram = '';\\n\\n\\t\\t\\t\\trenderObjectImmediate( object, program, material );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tobject.onAfterRender( _this, scene, camera, geometry, material, group );\\n\\n\\t\\t}\\n\\n\\t\\tfunction initMaterial( material, fog, object ) {\\n\\n\\t\\t\\tvar materialProperties = properties.get( material );\\n\\n\\t\\t\\tvar parameters = programCache.getParameters(\\n\\t\\t\\t\\tmaterial, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object );\\n\\n\\t\\t\\tvar code = programCache.getProgramCode( material, parameters );\\n\\n\\t\\t\\tvar program = materialProperties.program;\\n\\t\\t\\tvar programChange = true;\\n\\n\\t\\t\\tif ( program === undefined ) {\\n\\n\\t\\t\\t\\t// new material\\n\\t\\t\\t\\tmaterial.addEventListener( 'dispose', onMaterialDispose );\\n\\n\\t\\t\\t} else if ( program.code !== code ) {\\n\\n\\t\\t\\t\\t// changed glsl or parameters\\n\\t\\t\\t\\treleaseMaterialProgramReference( material );\\n\\n\\t\\t\\t} else if ( parameters.shaderID !== undefined ) {\\n\\n\\t\\t\\t\\t// same glsl and uniform list\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// only rebuild uniform list\\n\\t\\t\\t\\tprogramChange = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( programChange ) {\\n\\n\\t\\t\\t\\tif ( parameters.shaderID ) {\\n\\n\\t\\t\\t\\t\\tvar shader = ShaderLib[ parameters.shaderID ];\\n\\n\\t\\t\\t\\t\\tmaterialProperties.shader = {\\n\\t\\t\\t\\t\\t\\tname: material.type,\\n\\t\\t\\t\\t\\t\\tuniforms: UniformsUtils.clone( shader.uniforms ),\\n\\t\\t\\t\\t\\t\\tvertexShader: shader.vertexShader,\\n\\t\\t\\t\\t\\t\\tfragmentShader: shader.fragmentShader\\n\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tmaterialProperties.shader = {\\n\\t\\t\\t\\t\\t\\tname: material.type,\\n\\t\\t\\t\\t\\t\\tuniforms: material.uniforms,\\n\\t\\t\\t\\t\\t\\tvertexShader: material.vertexShader,\\n\\t\\t\\t\\t\\t\\tfragmentShader: material.fragmentShader\\n\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tmaterial.onBeforeCompile( materialProperties.shader );\\n\\n\\t\\t\\t\\tprogram = programCache.acquireProgram( material, materialProperties.shader, parameters, code );\\n\\n\\t\\t\\t\\tmaterialProperties.program = program;\\n\\t\\t\\t\\tmaterial.program = program;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar programAttributes = program.getAttributes();\\n\\n\\t\\t\\tif ( material.morphTargets ) {\\n\\n\\t\\t\\t\\tmaterial.numSupportedMorphTargets = 0;\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\\n\\n\\t\\t\\t\\t\\tif ( programAttributes[ 'morphTarget' + i ] >= 0 ) {\\n\\n\\t\\t\\t\\t\\t\\tmaterial.numSupportedMorphTargets ++;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.morphNormals ) {\\n\\n\\t\\t\\t\\tmaterial.numSupportedMorphNormals = 0;\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\\n\\n\\t\\t\\t\\t\\tif ( programAttributes[ 'morphNormal' + i ] >= 0 ) {\\n\\n\\t\\t\\t\\t\\t\\tmaterial.numSupportedMorphNormals ++;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar uniforms = materialProperties.shader.uniforms;\\n\\n\\t\\t\\tif ( ! material.isShaderMaterial &&\\n\\t\\t\\t\\t! material.isRawShaderMaterial ||\\n\\t\\t\\t\\tmaterial.clipping === true ) {\\n\\n\\t\\t\\t\\tmaterialProperties.numClippingPlanes = _clipping.numPlanes;\\n\\t\\t\\t\\tmaterialProperties.numIntersection = _clipping.numIntersection;\\n\\t\\t\\t\\tuniforms.clippingPlanes = _clipping.uniform;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tmaterialProperties.fog = fog;\\n\\n\\t\\t\\t// store the light setup it was created for\\n\\n\\t\\t\\tmaterialProperties.lightsHash = lights.state.hash;\\n\\n\\t\\t\\tif ( material.lights ) {\\n\\n\\t\\t\\t\\t// wire up the material to this renderer's lighting state\\n\\n\\t\\t\\t\\tuniforms.ambientLightColor.value = lights.state.ambient;\\n\\t\\t\\t\\tuniforms.directionalLights.value = lights.state.directional;\\n\\t\\t\\t\\tuniforms.spotLights.value = lights.state.spot;\\n\\t\\t\\t\\tuniforms.rectAreaLights.value = lights.state.rectArea;\\n\\t\\t\\t\\tuniforms.pointLights.value = lights.state.point;\\n\\t\\t\\t\\tuniforms.hemisphereLights.value = lights.state.hemi;\\n\\n\\t\\t\\t\\tuniforms.directionalShadowMap.value = lights.state.directionalShadowMap;\\n\\t\\t\\t\\tuniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;\\n\\t\\t\\t\\tuniforms.spotShadowMap.value = lights.state.spotShadowMap;\\n\\t\\t\\t\\tuniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;\\n\\t\\t\\t\\tuniforms.pointShadowMap.value = lights.state.pointShadowMap;\\n\\t\\t\\t\\tuniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;\\n\\t\\t\\t\\t// TODO (abelnation): add area lights shadow info to uniforms\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar progUniforms = materialProperties.program.getUniforms(),\\n\\t\\t\\t\\tuniformsList =\\n\\t\\t\\t\\t\\tWebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\\n\\n\\t\\t\\tmaterialProperties.uniformsList = uniformsList;\\n\\n\\t\\t}\\n\\n\\t\\tfunction setProgram( camera, fog, material, object ) {\\n\\n\\t\\t\\t_usedTextureUnits = 0;\\n\\n\\t\\t\\tvar materialProperties = properties.get( material );\\n\\n\\t\\t\\tif ( _clippingEnabled ) {\\n\\n\\t\\t\\t\\tif ( _localClippingEnabled || camera !== _currentCamera ) {\\n\\n\\t\\t\\t\\t\\tvar useCache =\\n\\t\\t\\t\\t\\t\\tcamera === _currentCamera &&\\n\\t\\t\\t\\t\\t\\tmaterial.id === _currentMaterialId;\\n\\n\\t\\t\\t\\t\\t// we might want to call this function with some ClippingGroup\\n\\t\\t\\t\\t\\t// object instead of the material, once it becomes feasible\\n\\t\\t\\t\\t\\t// (#8465, #8379)\\n\\t\\t\\t\\t\\t_clipping.setState(\\n\\t\\t\\t\\t\\t\\tmaterial.clippingPlanes, material.clipIntersection, material.clipShadows,\\n\\t\\t\\t\\t\\t\\tcamera, materialProperties, useCache );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.needsUpdate === false ) {\\n\\n\\t\\t\\t\\tif ( materialProperties.program === undefined ) {\\n\\n\\t\\t\\t\\t\\tmaterial.needsUpdate = true;\\n\\n\\t\\t\\t\\t} else if ( material.fog && materialProperties.fog !== fog ) {\\n\\n\\t\\t\\t\\t\\tmaterial.needsUpdate = true;\\n\\n\\t\\t\\t\\t} else if ( material.lights && materialProperties.lightsHash !== lights.state.hash ) {\\n\\n\\t\\t\\t\\t\\tmaterial.needsUpdate = true;\\n\\n\\t\\t\\t\\t} else if ( materialProperties.numClippingPlanes !== undefined &&\\n\\t\\t\\t\\t\\t( materialProperties.numClippingPlanes !== _clipping.numPlanes ||\\n\\t\\t\\t\\t\\tmaterialProperties.numIntersection !== _clipping.numIntersection ) ) {\\n\\n\\t\\t\\t\\t\\tmaterial.needsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.needsUpdate ) {\\n\\n\\t\\t\\t\\tinitMaterial( material, fog, object );\\n\\t\\t\\t\\tmaterial.needsUpdate = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar refreshProgram = false;\\n\\t\\t\\tvar refreshMaterial = false;\\n\\t\\t\\tvar refreshLights = false;\\n\\n\\t\\t\\tvar program = materialProperties.program,\\n\\t\\t\\t\\tp_uniforms = program.getUniforms(),\\n\\t\\t\\t\\tm_uniforms = materialProperties.shader.uniforms;\\n\\n\\t\\t\\tif ( state.useProgram( program.program ) ) {\\n\\n\\t\\t\\t\\trefreshProgram = true;\\n\\t\\t\\t\\trefreshMaterial = true;\\n\\t\\t\\t\\trefreshLights = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.id !== _currentMaterialId ) {\\n\\n\\t\\t\\t\\t_currentMaterialId = material.id;\\n\\n\\t\\t\\t\\trefreshMaterial = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( refreshProgram || camera !== _currentCamera ) {\\n\\n\\t\\t\\t\\tp_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );\\n\\n\\t\\t\\t\\tif ( capabilities.logarithmicDepthBuffer ) {\\n\\n\\t\\t\\t\\t\\tp_uniforms.setValue( _gl, 'logDepthBufFC',\\n\\t\\t\\t\\t\\t\\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Avoid unneeded uniform updates per ArrayCamera's sub-camera\\n\\n\\t\\t\\t\\tif ( _currentCamera !== ( _currentArrayCamera || camera ) ) {\\n\\n\\t\\t\\t\\t\\t_currentCamera = ( _currentArrayCamera || camera );\\n\\n\\t\\t\\t\\t\\t// lighting uniforms depend on the camera so enforce an update\\n\\t\\t\\t\\t\\t// now, in case this material supports lights - or later, when\\n\\t\\t\\t\\t\\t// the next material that does gets activated:\\n\\n\\t\\t\\t\\t\\trefreshMaterial = true;\\t\\t// set to true on material change\\n\\t\\t\\t\\t\\trefreshLights = true;\\t\\t// remains set until update done\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// load material specific uniforms\\n\\t\\t\\t\\t// (shader material also gets them for the sake of genericity)\\n\\n\\t\\t\\t\\tif ( material.isShaderMaterial ||\\n\\t\\t\\t\\t\\tmaterial.isMeshPhongMaterial ||\\n\\t\\t\\t\\t\\tmaterial.isMeshStandardMaterial ||\\n\\t\\t\\t\\t\\tmaterial.envMap ) {\\n\\n\\t\\t\\t\\t\\tvar uCamPos = p_uniforms.map.cameraPosition;\\n\\n\\t\\t\\t\\t\\tif ( uCamPos !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tuCamPos.setValue( _gl,\\n\\t\\t\\t\\t\\t\\t\\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( material.isMeshPhongMaterial ||\\n\\t\\t\\t\\t\\tmaterial.isMeshLambertMaterial ||\\n\\t\\t\\t\\t\\tmaterial.isMeshBasicMaterial ||\\n\\t\\t\\t\\t\\tmaterial.isMeshStandardMaterial ||\\n\\t\\t\\t\\t\\tmaterial.isShaderMaterial ||\\n\\t\\t\\t\\t\\tmaterial.skinning ) {\\n\\n\\t\\t\\t\\t\\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// skinning uniforms must be set even if material didn't change\\n\\t\\t\\t// auto-setting of texture unit for bone texture must go before other textures\\n\\t\\t\\t// not sure why, but otherwise weird things happen\\n\\n\\t\\t\\tif ( material.skinning ) {\\n\\n\\t\\t\\t\\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\\n\\t\\t\\t\\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\\n\\n\\t\\t\\t\\tvar skeleton = object.skeleton;\\n\\n\\t\\t\\t\\tif ( skeleton ) {\\n\\n\\t\\t\\t\\t\\tvar bones = skeleton.bones;\\n\\n\\t\\t\\t\\t\\tif ( capabilities.floatVertexTextures ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( skeleton.boneTexture === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// layout (1 matrix = 4 pixels)\\n\\t\\t\\t\\t\\t\\t\\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\\n\\t\\t\\t\\t\\t\\t\\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\\n\\t\\t\\t\\t\\t\\t\\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\\n\\t\\t\\t\\t\\t\\t\\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\\n\\t\\t\\t\\t\\t\\t\\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\\n\\n\\n\\t\\t\\t\\t\\t\\t\\tvar size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix\\n\\t\\t\\t\\t\\t\\t\\tsize = _Math.ceilPowerOfTwo( size );\\n\\t\\t\\t\\t\\t\\t\\tsize = Math.max( size, 4 );\\n\\n\\t\\t\\t\\t\\t\\t\\tvar boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel\\n\\t\\t\\t\\t\\t\\t\\tboneMatrices.set( skeleton.boneMatrices ); // copy current values\\n\\n\\t\\t\\t\\t\\t\\t\\tvar boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );\\n\\n\\t\\t\\t\\t\\t\\t\\tskeleton.boneMatrices = boneMatrices;\\n\\t\\t\\t\\t\\t\\t\\tskeleton.boneTexture = boneTexture;\\n\\t\\t\\t\\t\\t\\t\\tskeleton.boneTextureSize = size;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tp_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture );\\n\\t\\t\\t\\t\\t\\tp_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( refreshMaterial ) {\\n\\n\\t\\t\\t\\tp_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );\\n\\t\\t\\t\\tp_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );\\n\\n\\t\\t\\t\\tif ( material.lights ) {\\n\\n\\t\\t\\t\\t\\t// the current material requires lighting info\\n\\n\\t\\t\\t\\t\\t// note: all lighting uniforms are always set correctly\\n\\t\\t\\t\\t\\t// they simply reference the renderer's state for their\\n\\t\\t\\t\\t\\t// values\\n\\t\\t\\t\\t\\t//\\n\\t\\t\\t\\t\\t// use the current material's .needsUpdate flags to set\\n\\t\\t\\t\\t\\t// the GL state when required\\n\\n\\t\\t\\t\\t\\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// refresh uniforms common to several materials\\n\\n\\t\\t\\t\\tif ( fog && material.fog ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsFog( m_uniforms, fog );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( material.isMeshBasicMaterial ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsCommon( m_uniforms, material );\\n\\n\\t\\t\\t\\t} else if ( material.isMeshLambertMaterial ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsCommon( m_uniforms, material );\\n\\t\\t\\t\\t\\trefreshUniformsLambert( m_uniforms, material );\\n\\n\\t\\t\\t\\t} else if ( material.isMeshPhongMaterial ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsCommon( m_uniforms, material );\\n\\n\\t\\t\\t\\t\\tif ( material.isMeshToonMaterial ) {\\n\\n\\t\\t\\t\\t\\t\\trefreshUniformsToon( m_uniforms, material );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\trefreshUniformsPhong( m_uniforms, material );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( material.isMeshStandardMaterial ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsCommon( m_uniforms, material );\\n\\n\\t\\t\\t\\t\\tif ( material.isMeshPhysicalMaterial ) {\\n\\n\\t\\t\\t\\t\\t\\trefreshUniformsPhysical( m_uniforms, material );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\trefreshUniformsStandard( m_uniforms, material );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( material.isMeshDepthMaterial ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsCommon( m_uniforms, material );\\n\\t\\t\\t\\t\\trefreshUniformsDepth( m_uniforms, material );\\n\\n\\t\\t\\t\\t} else if ( material.isMeshDistanceMaterial ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsCommon( m_uniforms, material );\\n\\t\\t\\t\\t\\trefreshUniformsDistance( m_uniforms, material );\\n\\n\\t\\t\\t\\t} else if ( material.isMeshNormalMaterial ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsCommon( m_uniforms, material );\\n\\t\\t\\t\\t\\trefreshUniformsNormal( m_uniforms, material );\\n\\n\\t\\t\\t\\t} else if ( material.isLineBasicMaterial ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsLine( m_uniforms, material );\\n\\n\\t\\t\\t\\t\\tif ( material.isLineDashedMaterial ) {\\n\\n\\t\\t\\t\\t\\t\\trefreshUniformsDash( m_uniforms, material );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( material.isPointsMaterial ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsPoints( m_uniforms, material );\\n\\n\\t\\t\\t\\t} else if ( material.isShadowMaterial ) {\\n\\n\\t\\t\\t\\t\\tm_uniforms.color.value = material.color;\\n\\t\\t\\t\\t\\tm_uniforms.opacity.value = material.opacity;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// RectAreaLight Texture\\n\\t\\t\\t\\t// TODO (mrdoob): Find a nicer implementation\\n\\n\\t\\t\\t\\tif ( m_uniforms.ltcMat !== undefined ) m_uniforms.ltcMat.value = UniformsLib.LTC_MAT_TEXTURE;\\n\\t\\t\\t\\tif ( m_uniforms.ltcMag !== undefined ) m_uniforms.ltcMag.value = UniformsLib.LTC_MAG_TEXTURE;\\n\\n\\t\\t\\t\\tWebGLUniforms.upload(\\n\\t\\t\\t\\t\\t_gl, materialProperties.uniformsList, m_uniforms, _this );\\n\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\t// common matrices\\n\\n\\t\\t\\tp_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );\\n\\t\\t\\tp_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );\\n\\t\\t\\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\\n\\n\\t\\t\\treturn program;\\n\\n\\t\\t}\\n\\n\\t\\t// Uniforms (refresh uniforms objects)\\n\\n\\t\\tfunction refreshUniformsCommon( uniforms, material ) {\\n\\n\\t\\t\\tuniforms.opacity.value = material.opacity;\\n\\n\\t\\t\\tif ( material.color ) {\\n\\n\\t\\t\\t\\tuniforms.diffuse.value = material.color;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.emissive ) {\\n\\n\\t\\t\\t\\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.map ) {\\n\\n\\t\\t\\t\\tuniforms.map.value = material.map;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.alphaMap ) {\\n\\n\\t\\t\\t\\tuniforms.alphaMap.value = material.alphaMap;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.specularMap ) {\\n\\n\\t\\t\\t\\tuniforms.specularMap.value = material.specularMap;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.envMap ) {\\n\\n\\t\\t\\t\\tuniforms.envMap.value = material.envMap;\\n\\n\\t\\t\\t\\t// don't flip CubeTexture envMaps, flip everything else:\\n\\t\\t\\t\\t//  WebGLRenderTargetCube will be flipped for backwards compatibility\\n\\t\\t\\t\\t//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\\n\\t\\t\\t\\t// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\\n\\t\\t\\t\\tuniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;\\n\\n\\t\\t\\t\\tuniforms.reflectivity.value = material.reflectivity;\\n\\t\\t\\t\\tuniforms.refractionRatio.value = material.refractionRatio;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.lightMap ) {\\n\\n\\t\\t\\t\\tuniforms.lightMap.value = material.lightMap;\\n\\t\\t\\t\\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.aoMap ) {\\n\\n\\t\\t\\t\\tuniforms.aoMap.value = material.aoMap;\\n\\t\\t\\t\\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// uv repeat and offset setting priorities\\n\\t\\t\\t// 1. color map\\n\\t\\t\\t// 2. specular map\\n\\t\\t\\t// 3. normal map\\n\\t\\t\\t// 4. bump map\\n\\t\\t\\t// 5. alpha map\\n\\t\\t\\t// 6. emissive map\\n\\n\\t\\t\\tvar uvScaleMap;\\n\\n\\t\\t\\tif ( material.map ) {\\n\\n\\t\\t\\t\\tuvScaleMap = material.map;\\n\\n\\t\\t\\t} else if ( material.specularMap ) {\\n\\n\\t\\t\\t\\tuvScaleMap = material.specularMap;\\n\\n\\t\\t\\t} else if ( material.displacementMap ) {\\n\\n\\t\\t\\t\\tuvScaleMap = material.displacementMap;\\n\\n\\t\\t\\t} else if ( material.normalMap ) {\\n\\n\\t\\t\\t\\tuvScaleMap = material.normalMap;\\n\\n\\t\\t\\t} else if ( material.bumpMap ) {\\n\\n\\t\\t\\t\\tuvScaleMap = material.bumpMap;\\n\\n\\t\\t\\t} else if ( material.roughnessMap ) {\\n\\n\\t\\t\\t\\tuvScaleMap = material.roughnessMap;\\n\\n\\t\\t\\t} else if ( material.metalnessMap ) {\\n\\n\\t\\t\\t\\tuvScaleMap = material.metalnessMap;\\n\\n\\t\\t\\t} else if ( material.alphaMap ) {\\n\\n\\t\\t\\t\\tuvScaleMap = material.alphaMap;\\n\\n\\t\\t\\t} else if ( material.emissiveMap ) {\\n\\n\\t\\t\\t\\tuvScaleMap = material.emissiveMap;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( uvScaleMap !== undefined ) {\\n\\n\\t\\t\\t\\t// backwards compatibility\\n\\t\\t\\t\\tif ( uvScaleMap.isWebGLRenderTarget ) {\\n\\n\\t\\t\\t\\t\\tuvScaleMap = uvScaleMap.texture;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( uvScaleMap.matrixAutoUpdate === true ) {\\n\\n\\t\\t\\t\\t\\tvar offset = uvScaleMap.offset;\\n\\t\\t\\t\\t\\tvar repeat = uvScaleMap.repeat;\\n\\t\\t\\t\\t\\tvar rotation = uvScaleMap.rotation;\\n\\t\\t\\t\\t\\tvar center = uvScaleMap.center;\\n\\n\\t\\t\\t\\t\\tuvScaleMap.matrix.setUvTransform( offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tuniforms.uvTransform.value.copy( uvScaleMap.matrix );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsLine( uniforms, material ) {\\n\\n\\t\\t\\tuniforms.diffuse.value = material.color;\\n\\t\\t\\tuniforms.opacity.value = material.opacity;\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsDash( uniforms, material ) {\\n\\n\\t\\t\\tuniforms.dashSize.value = material.dashSize;\\n\\t\\t\\tuniforms.totalSize.value = material.dashSize + material.gapSize;\\n\\t\\t\\tuniforms.scale.value = material.scale;\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsPoints( uniforms, material ) {\\n\\n\\t\\t\\tuniforms.diffuse.value = material.color;\\n\\t\\t\\tuniforms.opacity.value = material.opacity;\\n\\t\\t\\tuniforms.size.value = material.size * _pixelRatio;\\n\\t\\t\\tuniforms.scale.value = _height * 0.5;\\n\\n\\t\\t\\tuniforms.map.value = material.map;\\n\\n\\t\\t\\tif ( material.map !== null ) {\\n\\n\\t\\t\\t\\tif ( material.map.matrixAutoUpdate === true ) {\\n\\n\\t\\t\\t\\t\\tvar offset = material.map.offset;\\n\\t\\t\\t\\t\\tvar repeat = material.map.repeat;\\n\\t\\t\\t\\t\\tvar rotation = material.map.rotation;\\n\\t\\t\\t\\t\\tvar center = material.map.center;\\n\\n\\t\\t\\t\\t\\tmaterial.map.matrix.setUvTransform( offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tuniforms.uvTransform.value.copy( material.map.matrix );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsFog( uniforms, fog ) {\\n\\n\\t\\t\\tuniforms.fogColor.value = fog.color;\\n\\n\\t\\t\\tif ( fog.isFog ) {\\n\\n\\t\\t\\t\\tuniforms.fogNear.value = fog.near;\\n\\t\\t\\t\\tuniforms.fogFar.value = fog.far;\\n\\n\\t\\t\\t} else if ( fog.isFogExp2 ) {\\n\\n\\t\\t\\t\\tuniforms.fogDensity.value = fog.density;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsLambert( uniforms, material ) {\\n\\n\\t\\t\\tif ( material.emissiveMap ) {\\n\\n\\t\\t\\t\\tuniforms.emissiveMap.value = material.emissiveMap;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsPhong( uniforms, material ) {\\n\\n\\t\\t\\tuniforms.specular.value = material.specular;\\n\\t\\t\\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\\n\\n\\t\\t\\tif ( material.emissiveMap ) {\\n\\n\\t\\t\\t\\tuniforms.emissiveMap.value = material.emissiveMap;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.bumpMap ) {\\n\\n\\t\\t\\t\\tuniforms.bumpMap.value = material.bumpMap;\\n\\t\\t\\t\\tuniforms.bumpScale.value = material.bumpScale;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.normalMap ) {\\n\\n\\t\\t\\t\\tuniforms.normalMap.value = material.normalMap;\\n\\t\\t\\t\\tuniforms.normalScale.value.copy( material.normalScale );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.displacementMap ) {\\n\\n\\t\\t\\t\\tuniforms.displacementMap.value = material.displacementMap;\\n\\t\\t\\t\\tuniforms.displacementScale.value = material.displacementScale;\\n\\t\\t\\t\\tuniforms.displacementBias.value = material.displacementBias;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsToon( uniforms, material ) {\\n\\n\\t\\t\\trefreshUniformsPhong( uniforms, material );\\n\\n\\t\\t\\tif ( material.gradientMap ) {\\n\\n\\t\\t\\t\\tuniforms.gradientMap.value = material.gradientMap;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsStandard( uniforms, material ) {\\n\\n\\t\\t\\tuniforms.roughness.value = material.roughness;\\n\\t\\t\\tuniforms.metalness.value = material.metalness;\\n\\n\\t\\t\\tif ( material.roughnessMap ) {\\n\\n\\t\\t\\t\\tuniforms.roughnessMap.value = material.roughnessMap;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.metalnessMap ) {\\n\\n\\t\\t\\t\\tuniforms.metalnessMap.value = material.metalnessMap;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.emissiveMap ) {\\n\\n\\t\\t\\t\\tuniforms.emissiveMap.value = material.emissiveMap;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.bumpMap ) {\\n\\n\\t\\t\\t\\tuniforms.bumpMap.value = material.bumpMap;\\n\\t\\t\\t\\tuniforms.bumpScale.value = material.bumpScale;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.normalMap ) {\\n\\n\\t\\t\\t\\tuniforms.normalMap.value = material.normalMap;\\n\\t\\t\\t\\tuniforms.normalScale.value.copy( material.normalScale );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.displacementMap ) {\\n\\n\\t\\t\\t\\tuniforms.displacementMap.value = material.displacementMap;\\n\\t\\t\\t\\tuniforms.displacementScale.value = material.displacementScale;\\n\\t\\t\\t\\tuniforms.displacementBias.value = material.displacementBias;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.envMap ) {\\n\\n\\t\\t\\t\\t//uniforms.envMap.value = material.envMap; // part of uniforms common\\n\\t\\t\\t\\tuniforms.envMapIntensity.value = material.envMapIntensity;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsPhysical( uniforms, material ) {\\n\\n\\t\\t\\tuniforms.clearCoat.value = material.clearCoat;\\n\\t\\t\\tuniforms.clearCoatRoughness.value = material.clearCoatRoughness;\\n\\n\\t\\t\\trefreshUniformsStandard( uniforms, material );\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsDepth( uniforms, material ) {\\n\\n\\t\\t\\tif ( material.displacementMap ) {\\n\\n\\t\\t\\t\\tuniforms.displacementMap.value = material.displacementMap;\\n\\t\\t\\t\\tuniforms.displacementScale.value = material.displacementScale;\\n\\t\\t\\t\\tuniforms.displacementBias.value = material.displacementBias;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsDistance( uniforms, material ) {\\n\\n\\t\\t\\tif ( material.displacementMap ) {\\n\\n\\t\\t\\t\\tuniforms.displacementMap.value = material.displacementMap;\\n\\t\\t\\t\\tuniforms.displacementScale.value = material.displacementScale;\\n\\t\\t\\t\\tuniforms.displacementBias.value = material.displacementBias;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tuniforms.referencePosition.value.copy( material.referencePosition );\\n\\t\\t\\tuniforms.nearDistance.value = material.nearDistance;\\n\\t\\t\\tuniforms.farDistance.value = material.farDistance;\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsNormal( uniforms, material ) {\\n\\n\\t\\t\\tif ( material.bumpMap ) {\\n\\n\\t\\t\\t\\tuniforms.bumpMap.value = material.bumpMap;\\n\\t\\t\\t\\tuniforms.bumpScale.value = material.bumpScale;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.normalMap ) {\\n\\n\\t\\t\\t\\tuniforms.normalMap.value = material.normalMap;\\n\\t\\t\\t\\tuniforms.normalScale.value.copy( material.normalScale );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.displacementMap ) {\\n\\n\\t\\t\\t\\tuniforms.displacementMap.value = material.displacementMap;\\n\\t\\t\\t\\tuniforms.displacementScale.value = material.displacementScale;\\n\\t\\t\\t\\tuniforms.displacementBias.value = material.displacementBias;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\\n\\n\\t\\tfunction markUniformsLightsNeedsUpdate( uniforms, value ) {\\n\\n\\t\\t\\tuniforms.ambientLightColor.needsUpdate = value;\\n\\n\\t\\t\\tuniforms.directionalLights.needsUpdate = value;\\n\\t\\t\\tuniforms.pointLights.needsUpdate = value;\\n\\t\\t\\tuniforms.spotLights.needsUpdate = value;\\n\\t\\t\\tuniforms.rectAreaLights.needsUpdate = value;\\n\\t\\t\\tuniforms.hemisphereLights.needsUpdate = value;\\n\\n\\t\\t}\\n\\n\\t\\t// GL state setting\\n\\n\\t\\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\\n\\n\\t\\t\\tstate.setCullFace( cullFace );\\n\\t\\t\\tstate.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );\\n\\n\\t\\t};\\n\\n\\t\\t// Textures\\n\\n\\t\\tfunction allocTextureUnit() {\\n\\n\\t\\t\\tvar textureUnit = _usedTextureUnits;\\n\\n\\t\\t\\tif ( textureUnit >= capabilities.maxTextures ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t_usedTextureUnits += 1;\\n\\n\\t\\t\\treturn textureUnit;\\n\\n\\t\\t}\\n\\n\\t\\tthis.allocTextureUnit = allocTextureUnit;\\n\\n\\t\\t// this.setTexture2D = setTexture2D;\\n\\t\\tthis.setTexture2D = ( function () {\\n\\n\\t\\t\\tvar warned = false;\\n\\n\\t\\t\\t// backwards compatibility: peel texture.texture\\n\\t\\t\\treturn function setTexture2D( texture, slot ) {\\n\\n\\t\\t\\t\\tif ( texture && texture.isWebGLRenderTarget ) {\\n\\n\\t\\t\\t\\t\\tif ( ! warned ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( \\\"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\\\" );\\n\\t\\t\\t\\t\\t\\twarned = true;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ttexture = texture.texture;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttextures.setTexture2D( texture, slot );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}() );\\n\\n\\t\\tthis.setTexture = ( function () {\\n\\n\\t\\t\\tvar warned = false;\\n\\n\\t\\t\\treturn function setTexture( texture, slot ) {\\n\\n\\t\\t\\t\\tif ( ! warned ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( \\\"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\\\" );\\n\\t\\t\\t\\t\\twarned = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttextures.setTexture2D( texture, slot );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}() );\\n\\n\\t\\tthis.setTextureCube = ( function () {\\n\\n\\t\\t\\tvar warned = false;\\n\\n\\t\\t\\treturn function setTextureCube( texture, slot ) {\\n\\n\\t\\t\\t\\t// backwards compatibility: peel texture.texture\\n\\t\\t\\t\\tif ( texture && texture.isWebGLRenderTargetCube ) {\\n\\n\\t\\t\\t\\t\\tif ( ! warned ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( \\\"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\\\" );\\n\\t\\t\\t\\t\\t\\twarned = true;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ttexture = texture.texture;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\\n\\t\\t\\t\\t// TODO: unify these code paths\\n\\t\\t\\t\\tif ( ( texture && texture.isCubeTexture ) ||\\n\\t\\t\\t\\t\\t( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\\n\\n\\t\\t\\t\\t\\t// CompressedTexture can have Array in image :/\\n\\n\\t\\t\\t\\t\\t// this function alone should take care of cube textures\\n\\t\\t\\t\\t\\ttextures.setTextureCube( texture, slot );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// assumed: texture property of THREE.WebGLRenderTargetCube\\n\\n\\t\\t\\t\\t\\ttextures.setTextureCubeDynamic( texture, slot );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}() );\\n\\n\\t\\tthis.getRenderTarget = function () {\\n\\n\\t\\t\\treturn _currentRenderTarget;\\n\\n\\t\\t};\\n\\n\\t\\tthis.setRenderTarget = function ( renderTarget ) {\\n\\n\\t\\t\\t_currentRenderTarget = renderTarget;\\n\\n\\t\\t\\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\\n\\n\\t\\t\\t\\ttextures.setupRenderTarget( renderTarget );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar framebuffer = null;\\n\\t\\t\\tvar isCube = false;\\n\\n\\t\\t\\tif ( renderTarget ) {\\n\\n\\t\\t\\t\\tvar __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;\\n\\n\\t\\t\\t\\tif ( renderTarget.isWebGLRenderTargetCube ) {\\n\\n\\t\\t\\t\\t\\tframebuffer = __webglFramebuffer[ renderTarget.activeCubeFace ];\\n\\t\\t\\t\\t\\tisCube = true;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tframebuffer = __webglFramebuffer;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t_currentViewport.copy( renderTarget.viewport );\\n\\t\\t\\t\\t_currentScissor.copy( renderTarget.scissor );\\n\\t\\t\\t\\t_currentScissorTest = renderTarget.scissorTest;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\\n\\t\\t\\t\\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\\n\\t\\t\\t\\t_currentScissorTest = _scissorTest;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( _currentFramebuffer !== framebuffer ) {\\n\\n\\t\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\\n\\t\\t\\t\\t_currentFramebuffer = framebuffer;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tstate.viewport( _currentViewport );\\n\\t\\t\\tstate.scissor( _currentScissor );\\n\\t\\t\\tstate.setScissorTest( _currentScissorTest );\\n\\n\\t\\t\\tif ( isCube ) {\\n\\n\\t\\t\\t\\tvar textureProperties = properties.get( renderTarget.texture );\\n\\t\\t\\t\\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\\n\\n\\t\\t\\tif ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\\n\\n\\t\\t\\tif ( framebuffer ) {\\n\\n\\t\\t\\t\\tvar restore = false;\\n\\n\\t\\t\\t\\tif ( framebuffer !== _currentFramebuffer ) {\\n\\n\\t\\t\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\\n\\n\\t\\t\\t\\t\\trestore = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttry {\\n\\n\\t\\t\\t\\t\\tvar texture = renderTarget.texture;\\n\\t\\t\\t\\t\\tvar textureFormat = texture.format;\\n\\t\\t\\t\\t\\tvar textureType = texture.type;\\n\\n\\t\\t\\t\\t\\tif ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\\n\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)\\n\\t\\t\\t\\t\\t\\t! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox\\n\\t\\t\\t\\t\\t\\t! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\\n\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\\n\\n\\t\\t\\t\\t\\t\\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\\n\\n\\t\\t\\t\\t\\t\\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} finally {\\n\\n\\t\\t\\t\\t\\tif ( restore ) {\\n\\n\\t\\t\\t\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction FogExp2( color, density ) {\\n\\n\\t\\tthis.name = '';\\n\\n\\t\\tthis.color = new Color( color );\\n\\t\\tthis.density = ( density !== undefined ) ? density : 0.00025;\\n\\n\\t}\\n\\n\\tFogExp2.prototype.isFogExp2 = true;\\n\\n\\tFogExp2.prototype.clone = function () {\\n\\n\\t\\treturn new FogExp2( this.color.getHex(), this.density );\\n\\n\\t};\\n\\n\\tFogExp2.prototype.toJSON = function ( /* meta */ ) {\\n\\n\\t\\treturn {\\n\\t\\t\\ttype: 'FogExp2',\\n\\t\\t\\tcolor: this.color.getHex(),\\n\\t\\t\\tdensity: this.density\\n\\t\\t};\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction Fog( color, near, far ) {\\n\\n\\t\\tthis.name = '';\\n\\n\\t\\tthis.color = new Color( color );\\n\\n\\t\\tthis.near = ( near !== undefined ) ? near : 1;\\n\\t\\tthis.far = ( far !== undefined ) ? far : 1000;\\n\\n\\t}\\n\\n\\tFog.prototype.isFog = true;\\n\\n\\tFog.prototype.clone = function () {\\n\\n\\t\\treturn new Fog( this.color.getHex(), this.near, this.far );\\n\\n\\t};\\n\\n\\tFog.prototype.toJSON = function ( /* meta */ ) {\\n\\n\\t\\treturn {\\n\\t\\t\\ttype: 'Fog',\\n\\t\\t\\tcolor: this.color.getHex(),\\n\\t\\t\\tnear: this.near,\\n\\t\\t\\tfar: this.far\\n\\t\\t};\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction Scene() {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Scene';\\n\\n\\t\\tthis.background = null;\\n\\t\\tthis.fog = null;\\n\\t\\tthis.overrideMaterial = null;\\n\\n\\t\\tthis.autoUpdate = true; // checked by the renderer\\n\\n\\t}\\n\\n\\tScene.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Scene,\\n\\n\\t\\tcopy: function ( source, recursive ) {\\n\\n\\t\\t\\tObject3D.prototype.copy.call( this, source, recursive );\\n\\n\\t\\t\\tif ( source.background !== null ) this.background = source.background.clone();\\n\\t\\t\\tif ( source.fog !== null ) this.fog = source.fog.clone();\\n\\t\\t\\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\\n\\n\\t\\t\\tthis.autoUpdate = source.autoUpdate;\\n\\t\\t\\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( meta ) {\\n\\n\\t\\t\\tvar data = Object3D.prototype.toJSON.call( this, meta );\\n\\n\\t\\t\\tif ( this.background !== null ) data.object.background = this.background.toJSON( meta );\\n\\t\\t\\tif ( this.fog !== null ) data.object.fog = this.fog.toJSON();\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction LensFlare( texture, size, distance, blending, color ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.lensFlares = [];\\n\\n\\t\\tthis.positionScreen = new Vector3();\\n\\t\\tthis.customUpdateCallback = undefined;\\n\\n\\t\\tif ( texture !== undefined ) {\\n\\n\\t\\t\\tthis.add( texture, size, distance, blending, color );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tLensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: LensFlare,\\n\\n\\t\\tisLensFlare: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tObject3D.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.positionScreen.copy( source.positionScreen );\\n\\t\\t\\tthis.customUpdateCallback = source.customUpdateCallback;\\n\\n\\t\\t\\tfor ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tthis.lensFlares.push( source.lensFlares[ i ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tadd: function ( texture, size, distance, blending, color, opacity ) {\\n\\n\\t\\t\\tif ( size === undefined ) size = - 1;\\n\\t\\t\\tif ( distance === undefined ) distance = 0;\\n\\t\\t\\tif ( opacity === undefined ) opacity = 1;\\n\\t\\t\\tif ( color === undefined ) color = new Color( 0xffffff );\\n\\t\\t\\tif ( blending === undefined ) blending = NormalBlending;\\n\\n\\t\\t\\tdistance = Math.min( distance, Math.max( 0, distance ) );\\n\\n\\t\\t\\tthis.lensFlares.push( {\\n\\t\\t\\t\\ttexture: texture,\\t// THREE.Texture\\n\\t\\t\\t\\tsize: size, \\t\\t// size in pixels (-1 = use texture.width)\\n\\t\\t\\t\\tdistance: distance, \\t// distance (0-1) from light source (0=at light source)\\n\\t\\t\\t\\tx: 0, y: 0, z: 0,\\t// screen position (-1 => 1) z = 0 is in front z = 1 is back\\n\\t\\t\\t\\tscale: 1, \\t\\t// scale\\n\\t\\t\\t\\trotation: 0, \\t\\t// rotation\\n\\t\\t\\t\\topacity: opacity,\\t// opacity\\n\\t\\t\\t\\tcolor: color,\\t\\t// color\\n\\t\\t\\t\\tblending: blending\\t// blending\\n\\t\\t\\t} );\\n\\n\\t\\t},\\n\\n\\t\\t/*\\n\\t\\t * Update lens flares update positions on all flares based on the screen position\\n\\t\\t * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\\n\\t\\t */\\n\\n\\t\\tupdateLensFlares: function () {\\n\\n\\t\\t\\tvar f, fl = this.lensFlares.length;\\n\\t\\t\\tvar flare;\\n\\t\\t\\tvar vecX = - this.positionScreen.x * 2;\\n\\t\\t\\tvar vecY = - this.positionScreen.y * 2;\\n\\n\\t\\t\\tfor ( f = 0; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\tflare = this.lensFlares[ f ];\\n\\n\\t\\t\\t\\tflare.x = this.positionScreen.x + vecX * flare.distance;\\n\\t\\t\\t\\tflare.y = this.positionScreen.y + vecY * flare.distance;\\n\\n\\t\\t\\t\\tflare.wantedRotation = flare.x * Math.PI * 0.25;\\n\\t\\t\\t\\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t *\\n\\t * parameters = {\\n\\t *  color: <hex>,\\n\\t *  opacity: <float>,\\n\\t *  map: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *\\tuvOffset: new THREE.Vector2(),\\n\\t *\\tuvScale: new THREE.Vector2()\\n\\t * }\\n\\t */\\n\\n\\tfunction SpriteMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'SpriteMaterial';\\n\\n\\t\\tthis.color = new Color( 0xffffff );\\n\\t\\tthis.map = null;\\n\\n\\t\\tthis.rotation = 0;\\n\\n\\t\\tthis.fog = false;\\n\\t\\tthis.lights = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tSpriteMaterial.prototype = Object.create( Material.prototype );\\n\\tSpriteMaterial.prototype.constructor = SpriteMaterial;\\n\\tSpriteMaterial.prototype.isSpriteMaterial = true;\\n\\n\\tSpriteMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.color.copy( source.color );\\n\\t\\tthis.map = source.map;\\n\\n\\t\\tthis.rotation = source.rotation;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction Sprite( material ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Sprite';\\n\\n\\t\\tthis.material = ( material !== undefined ) ? material : new SpriteMaterial();\\n\\n\\t}\\n\\n\\tSprite.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Sprite,\\n\\n\\t\\tisSprite: true,\\n\\n\\t\\traycast: ( function () {\\n\\n\\t\\t\\tvar intersectPoint = new Vector3();\\n\\t\\t\\tvar worldPosition = new Vector3();\\n\\t\\t\\tvar worldScale = new Vector3();\\n\\n\\t\\t\\treturn function raycast( raycaster, intersects ) {\\n\\n\\t\\t\\t\\tworldPosition.setFromMatrixPosition( this.matrixWorld );\\n\\t\\t\\t\\traycaster.ray.closestPointToPoint( worldPosition, intersectPoint );\\n\\n\\t\\t\\t\\tworldScale.setFromMatrixScale( this.matrixWorld );\\n\\t\\t\\t\\tvar guessSizeSq = worldScale.x * worldScale.y / 4;\\n\\n\\t\\t\\t\\tif ( worldPosition.distanceToSquared( intersectPoint ) > guessSizeSq ) return;\\n\\n\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\\n\\n\\t\\t\\t\\tif ( distance < raycaster.near || distance > raycaster.far ) return;\\n\\n\\t\\t\\t\\tintersects.push( {\\n\\n\\t\\t\\t\\t\\tdistance: distance,\\n\\t\\t\\t\\t\\tpoint: intersectPoint.clone(),\\n\\t\\t\\t\\t\\tface: null,\\n\\t\\t\\t\\t\\tobject: this\\n\\n\\t\\t\\t\\t} );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}() ),\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.material ).copy( this );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction LOD() {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'LOD';\\n\\n\\t\\tObject.defineProperties( this, {\\n\\t\\t\\tlevels: {\\n\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t\\tvalue: []\\n\\t\\t\\t}\\n\\t\\t} );\\n\\n\\t}\\n\\n\\tLOD.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: LOD,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tObject3D.prototype.copy.call( this, source, false );\\n\\n\\t\\t\\tvar levels = source.levels;\\n\\n\\t\\t\\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar level = levels[ i ];\\n\\n\\t\\t\\t\\tthis.addLevel( level.object.clone(), level.distance );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddLevel: function ( object, distance ) {\\n\\n\\t\\t\\tif ( distance === undefined ) distance = 0;\\n\\n\\t\\t\\tdistance = Math.abs( distance );\\n\\n\\t\\t\\tvar levels = this.levels;\\n\\n\\t\\t\\tfor ( var l = 0; l < levels.length; l ++ ) {\\n\\n\\t\\t\\t\\tif ( distance < levels[ l ].distance ) {\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tlevels.splice( l, 0, { distance: distance, object: object } );\\n\\n\\t\\t\\tthis.add( object );\\n\\n\\t\\t},\\n\\n\\t\\tgetObjectForDistance: function ( distance ) {\\n\\n\\t\\t\\tvar levels = this.levels;\\n\\n\\t\\t\\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tif ( distance < levels[ i ].distance ) {\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn levels[ i - 1 ].object;\\n\\n\\t\\t},\\n\\n\\t\\traycast: ( function () {\\n\\n\\t\\t\\tvar matrixPosition = new Vector3();\\n\\n\\t\\t\\treturn function raycast( raycaster, intersects ) {\\n\\n\\t\\t\\t\\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\\n\\n\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\\n\\n\\t\\t\\t\\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}() ),\\n\\n\\t\\tupdate: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\t\\t\\tvar v2 = new Vector3();\\n\\n\\t\\t\\treturn function update( camera ) {\\n\\n\\t\\t\\t\\tvar levels = this.levels;\\n\\n\\t\\t\\t\\tif ( levels.length > 1 ) {\\n\\n\\t\\t\\t\\t\\tv1.setFromMatrixPosition( camera.matrixWorld );\\n\\t\\t\\t\\t\\tv2.setFromMatrixPosition( this.matrixWorld );\\n\\n\\t\\t\\t\\t\\tvar distance = v1.distanceTo( v2 );\\n\\n\\t\\t\\t\\t\\tlevels[ 0 ].object.visible = true;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( distance >= levels[ i ].distance ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tlevels[ i - 1 ].object.visible = false;\\n\\t\\t\\t\\t\\t\\t\\tlevels[ i ].object.visible = true;\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfor ( ; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tlevels[ i ].object.visible = false;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttoJSON: function ( meta ) {\\n\\n\\t\\t\\tvar data = Object3D.prototype.toJSON.call( this, meta );\\n\\n\\t\\t\\tdata.object.levels = [];\\n\\n\\t\\t\\tvar levels = this.levels;\\n\\n\\t\\t\\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar level = levels[ i ];\\n\\n\\t\\t\\t\\tdata.object.levels.push( {\\n\\t\\t\\t\\t\\tobject: level.object.uuid,\\n\\t\\t\\t\\t\\tdistance: level.distance\\n\\t\\t\\t\\t} );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author michael guerrero / http://realitymeltdown.com\\n\\t * @author ikerr / http://verold.com\\n\\t */\\n\\n\\tfunction Skeleton( bones, boneInverses ) {\\n\\n\\t\\t// copy the bone array\\n\\n\\t\\tbones = bones || [];\\n\\n\\t\\tthis.bones = bones.slice( 0 );\\n\\t\\tthis.boneMatrices = new Float32Array( this.bones.length * 16 );\\n\\n\\t\\t// use the supplied bone inverses or calculate the inverses\\n\\n\\t\\tif ( boneInverses === undefined ) {\\n\\n\\t\\t\\tthis.calculateInverses();\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tif ( this.bones.length === boneInverses.length ) {\\n\\n\\t\\t\\t\\tthis.boneInverses = boneInverses.slice( 0 );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Skeleton boneInverses is the wrong length.' );\\n\\n\\t\\t\\t\\tthis.boneInverses = [];\\n\\n\\t\\t\\t\\tfor ( var i = 0, il = this.bones.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\tthis.boneInverses.push( new Matrix4() );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tObject.assign( Skeleton.prototype, {\\n\\n\\t\\tcalculateInverses: function () {\\n\\n\\t\\t\\tthis.boneInverses = [];\\n\\n\\t\\t\\tfor ( var i = 0, il = this.bones.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar inverse = new Matrix4();\\n\\n\\t\\t\\t\\tif ( this.bones[ i ] ) {\\n\\n\\t\\t\\t\\t\\tinverse.getInverse( this.bones[ i ].matrixWorld );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.boneInverses.push( inverse );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tpose: function () {\\n\\n\\t\\t\\tvar bone, i, il;\\n\\n\\t\\t\\t// recover the bind-time world matrices\\n\\n\\t\\t\\tfor ( i = 0, il = this.bones.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tbone = this.bones[ i ];\\n\\n\\t\\t\\t\\tif ( bone ) {\\n\\n\\t\\t\\t\\t\\tbone.matrixWorld.getInverse( this.boneInverses[ i ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// compute the local matrices, positions, rotations and scales\\n\\n\\t\\t\\tfor ( i = 0, il = this.bones.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tbone = this.bones[ i ];\\n\\n\\t\\t\\t\\tif ( bone ) {\\n\\n\\t\\t\\t\\t\\tif ( bone.parent && bone.parent.isBone ) {\\n\\n\\t\\t\\t\\t\\t\\tbone.matrix.getInverse( bone.parent.matrixWorld );\\n\\t\\t\\t\\t\\t\\tbone.matrix.multiply( bone.matrixWorld );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tbone.matrix.copy( bone.matrixWorld );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tupdate: ( function () {\\n\\n\\t\\t\\tvar offsetMatrix = new Matrix4();\\n\\t\\t\\tvar identityMatrix = new Matrix4();\\n\\n\\t\\t\\treturn function update() {\\n\\n\\t\\t\\t\\tvar bones = this.bones;\\n\\t\\t\\t\\tvar boneInverses = this.boneInverses;\\n\\t\\t\\t\\tvar boneMatrices = this.boneMatrices;\\n\\t\\t\\t\\tvar boneTexture = this.boneTexture;\\n\\n\\t\\t\\t\\t// flatten bone matrices to array\\n\\n\\t\\t\\t\\tfor ( var i = 0, il = bones.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t// compute the offset between the current and the original transform\\n\\n\\t\\t\\t\\t\\tvar matrix = bones[ i ] ? bones[ i ].matrixWorld : identityMatrix;\\n\\n\\t\\t\\t\\t\\toffsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );\\n\\t\\t\\t\\t\\toffsetMatrix.toArray( boneMatrices, i * 16 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( boneTexture !== undefined ) {\\n\\n\\t\\t\\t\\t\\tboneTexture.needsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )(),\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new Skeleton( this.bones, this.boneInverses );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author ikerr / http://verold.com\\n\\t */\\n\\n\\tfunction Bone() {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Bone';\\n\\n\\t}\\n\\n\\tBone.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Bone,\\n\\n\\t\\tisBone: true\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author ikerr / http://verold.com\\n\\t */\\n\\n\\tfunction SkinnedMesh( geometry, material ) {\\n\\n\\t\\tMesh.call( this, geometry, material );\\n\\n\\t\\tthis.type = 'SkinnedMesh';\\n\\n\\t\\tthis.bindMode = 'attached';\\n\\t\\tthis.bindMatrix = new Matrix4();\\n\\t\\tthis.bindMatrixInverse = new Matrix4();\\n\\n\\t\\tvar bones = this.initBones();\\n\\t\\tvar skeleton = new Skeleton( bones );\\n\\n\\t\\tthis.bind( skeleton, this.matrixWorld );\\n\\n\\t\\tthis.normalizeSkinWeights();\\n\\n\\t}\\n\\n\\tSkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {\\n\\n\\t\\tconstructor: SkinnedMesh,\\n\\n\\t\\tisSkinnedMesh: true,\\n\\n\\t\\tinitBones: function () {\\n\\n\\t\\t\\tvar bones = [], bone, gbone;\\n\\t\\t\\tvar i, il;\\n\\n\\t\\t\\tif ( this.geometry && this.geometry.bones !== undefined ) {\\n\\n\\t\\t\\t\\t// first, create array of 'Bone' objects from geometry data\\n\\n\\t\\t\\t\\tfor ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\tgbone = this.geometry.bones[ i ];\\n\\n\\t\\t\\t\\t\\t// create new 'Bone' object\\n\\n\\t\\t\\t\\t\\tbone = new Bone();\\n\\t\\t\\t\\t\\tbones.push( bone );\\n\\n\\t\\t\\t\\t\\t// apply values\\n\\n\\t\\t\\t\\t\\tbone.name = gbone.name;\\n\\t\\t\\t\\t\\tbone.position.fromArray( gbone.pos );\\n\\t\\t\\t\\t\\tbone.quaternion.fromArray( gbone.rotq );\\n\\t\\t\\t\\t\\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// second, create bone hierarchy\\n\\n\\t\\t\\t\\tfor ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\tgbone = this.geometry.bones[ i ];\\n\\n\\t\\t\\t\\t\\tif ( ( gbone.parent !== - 1 ) && ( gbone.parent !== null ) && ( bones[ gbone.parent ] !== undefined ) ) {\\n\\n\\t\\t\\t\\t\\t\\t// subsequent bones in the hierarchy\\n\\n\\t\\t\\t\\t\\t\\tbones[ gbone.parent ].add( bones[ i ] );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t// topmost bone, immediate child of the skinned mesh\\n\\n\\t\\t\\t\\t\\t\\tthis.add( bones[ i ] );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// now the bones are part of the scene graph and children of the skinned mesh.\\n\\t\\t\\t// let's update the corresponding matrices\\n\\n\\t\\t\\tthis.updateMatrixWorld( true );\\n\\n\\t\\t\\treturn bones;\\n\\n\\t\\t},\\n\\n\\t\\tbind: function ( skeleton, bindMatrix ) {\\n\\n\\t\\t\\tthis.skeleton = skeleton;\\n\\n\\t\\t\\tif ( bindMatrix === undefined ) {\\n\\n\\t\\t\\t\\tthis.updateMatrixWorld( true );\\n\\n\\t\\t\\t\\tthis.skeleton.calculateInverses();\\n\\n\\t\\t\\t\\tbindMatrix = this.matrixWorld;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.bindMatrix.copy( bindMatrix );\\n\\t\\t\\tthis.bindMatrixInverse.getInverse( bindMatrix );\\n\\n\\t\\t},\\n\\n\\t\\tpose: function () {\\n\\n\\t\\t\\tthis.skeleton.pose();\\n\\n\\t\\t},\\n\\n\\t\\tnormalizeSkinWeights: function () {\\n\\n\\t\\t\\tvar scale, i;\\n\\n\\t\\t\\tif ( this.geometry && this.geometry.isGeometry ) {\\n\\n\\t\\t\\t\\tfor ( i = 0; i < this.geometry.skinWeights.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar sw = this.geometry.skinWeights[ i ];\\n\\n\\t\\t\\t\\t\\tscale = 1.0 / sw.manhattanLength();\\n\\n\\t\\t\\t\\t\\tif ( scale !== Infinity ) {\\n\\n\\t\\t\\t\\t\\t\\tsw.multiplyScalar( scale );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tsw.set( 1, 0, 0, 0 ); // do something reasonable\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( this.geometry && this.geometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\tvar vec = new Vector4();\\n\\n\\t\\t\\t\\tvar skinWeight = this.geometry.attributes.skinWeight;\\n\\n\\t\\t\\t\\tfor ( i = 0; i < skinWeight.count; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvec.x = skinWeight.getX( i );\\n\\t\\t\\t\\t\\tvec.y = skinWeight.getY( i );\\n\\t\\t\\t\\t\\tvec.z = skinWeight.getZ( i );\\n\\t\\t\\t\\t\\tvec.w = skinWeight.getW( i );\\n\\n\\t\\t\\t\\t\\tscale = 1.0 / vec.manhattanLength();\\n\\n\\t\\t\\t\\t\\tif ( scale !== Infinity ) {\\n\\n\\t\\t\\t\\t\\t\\tvec.multiplyScalar( scale );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tvec.set( 1, 0, 0, 0 ); // do something reasonable\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tskinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tupdateMatrixWorld: function ( force ) {\\n\\n\\t\\t\\tMesh.prototype.updateMatrixWorld.call( this, force );\\n\\n\\t\\t\\tif ( this.bindMode === 'attached' ) {\\n\\n\\t\\t\\t\\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\\n\\n\\t\\t\\t} else if ( this.bindMode === 'detached' ) {\\n\\n\\t\\t\\t\\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.geometry, this.material ).copy( this );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t *\\n\\t * parameters = {\\n\\t *  color: <hex>,\\n\\t *  opacity: <float>,\\n\\t *\\n\\t *  linewidth: <float>,\\n\\t *  linecap: \\\"round\\\",\\n\\t *  linejoin: \\\"round\\\"\\n\\t * }\\n\\t */\\n\\n\\tfunction LineBasicMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'LineBasicMaterial';\\n\\n\\t\\tthis.color = new Color( 0xffffff );\\n\\n\\t\\tthis.linewidth = 1;\\n\\t\\tthis.linecap = 'round';\\n\\t\\tthis.linejoin = 'round';\\n\\n\\t\\tthis.lights = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tLineBasicMaterial.prototype = Object.create( Material.prototype );\\n\\tLineBasicMaterial.prototype.constructor = LineBasicMaterial;\\n\\n\\tLineBasicMaterial.prototype.isLineBasicMaterial = true;\\n\\n\\tLineBasicMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.color.copy( source.color );\\n\\n\\t\\tthis.linewidth = source.linewidth;\\n\\t\\tthis.linecap = source.linecap;\\n\\t\\tthis.linejoin = source.linejoin;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction Line( geometry, material, mode ) {\\n\\n\\t\\tif ( mode === 1 ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\\n\\t\\t\\treturn new LineSegments( geometry, material );\\n\\n\\t\\t}\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Line';\\n\\n\\t\\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\\n\\t\\tthis.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );\\n\\n\\t}\\n\\n\\tLine.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Line,\\n\\n\\t\\tisLine: true,\\n\\n\\t\\traycast: ( function () {\\n\\n\\t\\t\\tvar inverseMatrix = new Matrix4();\\n\\t\\t\\tvar ray = new Ray();\\n\\t\\t\\tvar sphere = new Sphere();\\n\\n\\t\\t\\treturn function raycast( raycaster, intersects ) {\\n\\n\\t\\t\\t\\tvar precision = raycaster.linePrecision;\\n\\t\\t\\t\\tvar precisionSq = precision * precision;\\n\\n\\t\\t\\t\\tvar geometry = this.geometry;\\n\\t\\t\\t\\tvar matrixWorld = this.matrixWorld;\\n\\n\\t\\t\\t\\t// Checking boundingSphere distance to ray\\n\\n\\t\\t\\t\\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\\n\\n\\t\\t\\t\\tsphere.copy( geometry.boundingSphere );\\n\\t\\t\\t\\tsphere.applyMatrix4( matrixWorld );\\n\\n\\t\\t\\t\\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\\n\\n\\t\\t\\t\\t//\\n\\n\\t\\t\\t\\tinverseMatrix.getInverse( matrixWorld );\\n\\t\\t\\t\\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\\n\\n\\t\\t\\t\\tvar vStart = new Vector3();\\n\\t\\t\\t\\tvar vEnd = new Vector3();\\n\\t\\t\\t\\tvar interSegment = new Vector3();\\n\\t\\t\\t\\tvar interRay = new Vector3();\\n\\t\\t\\t\\tvar step = ( this && this.isLineSegments ) ? 2 : 1;\\n\\n\\t\\t\\t\\tif ( geometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\t\\tvar index = geometry.index;\\n\\t\\t\\t\\t\\tvar attributes = geometry.attributes;\\n\\t\\t\\t\\t\\tvar positions = attributes.position.array;\\n\\n\\t\\t\\t\\t\\tif ( index !== null ) {\\n\\n\\t\\t\\t\\t\\t\\tvar indices = index.array;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar a = indices[ i ];\\n\\t\\t\\t\\t\\t\\t\\tvar b = indices[ i + 1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\tvStart.fromArray( positions, a * 3 );\\n\\t\\t\\t\\t\\t\\t\\tvEnd.fromArray( positions, b * 3 );\\n\\n\\t\\t\\t\\t\\t\\t\\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( distSq > precisionSq ) continue;\\n\\n\\t\\t\\t\\t\\t\\t\\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\\n\\n\\t\\t\\t\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( interRay );\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\\n\\n\\t\\t\\t\\t\\t\\t\\tintersects.push( {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tdistance: distance,\\n\\t\\t\\t\\t\\t\\t\\t\\t// What do we want? intersection point on the ray or on the segment??\\n\\t\\t\\t\\t\\t\\t\\t\\t// point: raycaster.ray.at( distance ),\\n\\t\\t\\t\\t\\t\\t\\t\\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\\n\\t\\t\\t\\t\\t\\t\\t\\tindex: i,\\n\\t\\t\\t\\t\\t\\t\\t\\tface: null,\\n\\t\\t\\t\\t\\t\\t\\t\\tfaceIndex: null,\\n\\t\\t\\t\\t\\t\\t\\t\\tobject: this\\n\\n\\t\\t\\t\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvStart.fromArray( positions, 3 * i );\\n\\t\\t\\t\\t\\t\\t\\tvEnd.fromArray( positions, 3 * i + 3 );\\n\\n\\t\\t\\t\\t\\t\\t\\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( distSq > precisionSq ) continue;\\n\\n\\t\\t\\t\\t\\t\\t\\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\\n\\n\\t\\t\\t\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( interRay );\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\\n\\n\\t\\t\\t\\t\\t\\t\\tintersects.push( {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tdistance: distance,\\n\\t\\t\\t\\t\\t\\t\\t\\t// What do we want? intersection point on the ray or on the segment??\\n\\t\\t\\t\\t\\t\\t\\t\\t// point: raycaster.ray.at( distance ),\\n\\t\\t\\t\\t\\t\\t\\t\\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\\n\\t\\t\\t\\t\\t\\t\\t\\tindex: i,\\n\\t\\t\\t\\t\\t\\t\\t\\tface: null,\\n\\t\\t\\t\\t\\t\\t\\t\\tfaceIndex: null,\\n\\t\\t\\t\\t\\t\\t\\t\\tobject: this\\n\\n\\t\\t\\t\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( geometry.isGeometry ) {\\n\\n\\t\\t\\t\\t\\tvar vertices = geometry.vertices;\\n\\t\\t\\t\\t\\tvar nbVertices = vertices.length;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\\n\\n\\t\\t\\t\\t\\t\\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\\n\\n\\t\\t\\t\\t\\t\\tif ( distSq > precisionSq ) continue;\\n\\n\\t\\t\\t\\t\\t\\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\\n\\n\\t\\t\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( interRay );\\n\\n\\t\\t\\t\\t\\t\\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\\n\\n\\t\\t\\t\\t\\t\\tintersects.push( {\\n\\n\\t\\t\\t\\t\\t\\t\\tdistance: distance,\\n\\t\\t\\t\\t\\t\\t\\t// What do we want? intersection point on the ray or on the segment??\\n\\t\\t\\t\\t\\t\\t\\t// point: raycaster.ray.at( distance ),\\n\\t\\t\\t\\t\\t\\t\\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\\n\\t\\t\\t\\t\\t\\t\\tindex: i,\\n\\t\\t\\t\\t\\t\\t\\tface: null,\\n\\t\\t\\t\\t\\t\\t\\tfaceIndex: null,\\n\\t\\t\\t\\t\\t\\t\\tobject: this\\n\\n\\t\\t\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}() ),\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.geometry, this.material ).copy( this );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction LineSegments( geometry, material ) {\\n\\n\\t\\tLine.call( this, geometry, material );\\n\\n\\t\\tthis.type = 'LineSegments';\\n\\n\\t}\\n\\n\\tLineSegments.prototype = Object.assign( Object.create( Line.prototype ), {\\n\\n\\t\\tconstructor: LineSegments,\\n\\n\\t\\tisLineSegments: true\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mgreter / http://github.com/mgreter\\n\\t */\\n\\n\\tfunction LineLoop( geometry, material ) {\\n\\n\\t\\tLine.call( this, geometry, material );\\n\\n\\t\\tthis.type = 'LineLoop';\\n\\n\\t}\\n\\n\\tLineLoop.prototype = Object.assign( Object.create( Line.prototype ), {\\n\\n\\t\\tconstructor: LineLoop,\\n\\n\\t\\tisLineLoop: true,\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t *\\n\\t * parameters = {\\n\\t *  color: <hex>,\\n\\t *  opacity: <float>,\\n\\t *  map: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  size: <float>,\\n\\t *  sizeAttenuation: <bool>\\n\\t * }\\n\\t */\\n\\n\\tfunction PointsMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'PointsMaterial';\\n\\n\\t\\tthis.color = new Color( 0xffffff );\\n\\n\\t\\tthis.map = null;\\n\\n\\t\\tthis.size = 1;\\n\\t\\tthis.sizeAttenuation = true;\\n\\n\\t\\tthis.lights = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tPointsMaterial.prototype = Object.create( Material.prototype );\\n\\tPointsMaterial.prototype.constructor = PointsMaterial;\\n\\n\\tPointsMaterial.prototype.isPointsMaterial = true;\\n\\n\\tPointsMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.color.copy( source.color );\\n\\n\\t\\tthis.map = source.map;\\n\\n\\t\\tthis.size = source.size;\\n\\t\\tthis.sizeAttenuation = source.sizeAttenuation;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction Points( geometry, material ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Points';\\n\\n\\t\\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\\n\\t\\tthis.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );\\n\\n\\t}\\n\\n\\tPoints.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Points,\\n\\n\\t\\tisPoints: true,\\n\\n\\t\\traycast: ( function () {\\n\\n\\t\\t\\tvar inverseMatrix = new Matrix4();\\n\\t\\t\\tvar ray = new Ray();\\n\\t\\t\\tvar sphere = new Sphere();\\n\\n\\t\\t\\treturn function raycast( raycaster, intersects ) {\\n\\n\\t\\t\\t\\tvar object = this;\\n\\t\\t\\t\\tvar geometry = this.geometry;\\n\\t\\t\\t\\tvar matrixWorld = this.matrixWorld;\\n\\t\\t\\t\\tvar threshold = raycaster.params.Points.threshold;\\n\\n\\t\\t\\t\\t// Checking boundingSphere distance to ray\\n\\n\\t\\t\\t\\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\\n\\n\\t\\t\\t\\tsphere.copy( geometry.boundingSphere );\\n\\t\\t\\t\\tsphere.applyMatrix4( matrixWorld );\\n\\t\\t\\t\\tsphere.radius += threshold;\\n\\n\\t\\t\\t\\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\\n\\n\\t\\t\\t\\t//\\n\\n\\t\\t\\t\\tinverseMatrix.getInverse( matrixWorld );\\n\\t\\t\\t\\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\\n\\n\\t\\t\\t\\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\\n\\t\\t\\t\\tvar localThresholdSq = localThreshold * localThreshold;\\n\\t\\t\\t\\tvar position = new Vector3();\\n\\n\\t\\t\\t\\tfunction testPoint( point, index ) {\\n\\n\\t\\t\\t\\t\\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\\n\\n\\t\\t\\t\\t\\tif ( rayPointDistanceSq < localThresholdSq ) {\\n\\n\\t\\t\\t\\t\\t\\tvar intersectPoint = ray.closestPointToPoint( point );\\n\\t\\t\\t\\t\\t\\tintersectPoint.applyMatrix4( matrixWorld );\\n\\n\\t\\t\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\\n\\n\\t\\t\\t\\t\\t\\tif ( distance < raycaster.near || distance > raycaster.far ) return;\\n\\n\\t\\t\\t\\t\\t\\tintersects.push( {\\n\\n\\t\\t\\t\\t\\t\\t\\tdistance: distance,\\n\\t\\t\\t\\t\\t\\t\\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\\n\\t\\t\\t\\t\\t\\t\\tpoint: intersectPoint.clone(),\\n\\t\\t\\t\\t\\t\\t\\tindex: index,\\n\\t\\t\\t\\t\\t\\t\\tface: null,\\n\\t\\t\\t\\t\\t\\t\\tobject: object\\n\\n\\t\\t\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( geometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\t\\tvar index = geometry.index;\\n\\t\\t\\t\\t\\tvar attributes = geometry.attributes;\\n\\t\\t\\t\\t\\tvar positions = attributes.position.array;\\n\\n\\t\\t\\t\\t\\tif ( index !== null ) {\\n\\n\\t\\t\\t\\t\\t\\tvar indices = index.array;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar a = indices[ i ];\\n\\n\\t\\t\\t\\t\\t\\t\\tposition.fromArray( positions, a * 3 );\\n\\n\\t\\t\\t\\t\\t\\t\\ttestPoint( position, a );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tposition.fromArray( positions, i * 3 );\\n\\n\\t\\t\\t\\t\\t\\t\\ttestPoint( position, i );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tvar vertices = geometry.vertices;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\ttestPoint( vertices[ i ], i );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}() ),\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.geometry, this.material ).copy( this );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction Group() {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Group';\\n\\n\\t}\\n\\n\\tGroup.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Group,\\n\\n\\t\\tisGroup: true\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\\n\\n\\t\\tTexture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\\n\\n\\t\\tthis.generateMipmaps = false;\\n\\n\\t\\t// Set needsUpdate when first frame is ready\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\tfunction onLoaded() {\\n\\n\\t\\t\\tvideo.removeEventListener( 'loadeddata', onLoaded, false );\\n\\t\\t\\tscope.needsUpdate = true;\\n\\n\\t\\t}\\n\\n\\t\\tvideo.addEventListener( 'loadeddata', onLoaded, false );\\n\\n\\t}\\n\\n\\tVideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), {\\n\\n\\t\\tconstructor: VideoTexture,\\n\\n\\t\\tisVideoTexture: true,\\n\\n\\t\\tupdate: function () {\\n\\n\\t\\t\\tvar video = this.image;\\n\\n\\t\\t\\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\\n\\n\\t\\t\\t\\tthis.needsUpdate = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\\n\\n\\t\\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\\n\\n\\t\\tthis.image = { width: width, height: height };\\n\\t\\tthis.mipmaps = mipmaps;\\n\\n\\t\\t// no flipping for cube textures\\n\\t\\t// (also flipping doesn't work for compressed textures )\\n\\n\\t\\tthis.flipY = false;\\n\\n\\t\\t// can't generate mipmaps for compressed textures\\n\\t\\t// mips must be embedded in DDS files\\n\\n\\t\\tthis.generateMipmaps = false;\\n\\n\\t}\\n\\n\\tCompressedTexture.prototype = Object.create( Texture.prototype );\\n\\tCompressedTexture.prototype.constructor = CompressedTexture;\\n\\n\\tCompressedTexture.prototype.isCompressedTexture = true;\\n\\n\\t/**\\n\\t * @author Matt DesLauriers / @mattdesl\\n\\t * @author atix / arthursilber.de\\n\\t */\\n\\n\\tfunction DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {\\n\\n\\t\\tformat = format !== undefined ? format : DepthFormat;\\n\\n\\t\\tif ( format !== DepthFormat && format !== DepthStencilFormat ) {\\n\\n\\t\\t\\tthrow new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );\\n\\n\\t\\t}\\n\\n\\t\\tif ( type === undefined && format === DepthFormat ) type = UnsignedShortType;\\n\\t\\tif ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;\\n\\n\\t\\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\\n\\n\\t\\tthis.image = { width: width, height: height };\\n\\n\\t\\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\\n\\t\\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\\n\\n\\t\\tthis.flipY = false;\\n\\t\\tthis.generateMipmaps\\t= false;\\n\\n\\t}\\n\\n\\tDepthTexture.prototype = Object.create( Texture.prototype );\\n\\tDepthTexture.prototype.constructor = DepthTexture;\\n\\tDepthTexture.prototype.isDepthTexture = true;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\tfunction WireframeGeometry( geometry ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'WireframeGeometry';\\n\\n\\t\\t// buffer\\n\\n\\t\\tvar vertices = [];\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar i, j, l, o, ol;\\n\\t\\tvar edge = [ 0, 0 ], edges = {}, e, edge1, edge2;\\n\\t\\tvar key, keys = [ 'a', 'b', 'c' ];\\n\\t\\tvar vertex;\\n\\n\\t\\t// different logic for Geometry and BufferGeometry\\n\\n\\t\\tif ( geometry && geometry.isGeometry ) {\\n\\n\\t\\t\\t// create a data structure that contains all edges without duplicates\\n\\n\\t\\t\\tvar faces = geometry.faces;\\n\\n\\t\\t\\tfor ( i = 0, l = faces.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar face = faces[ i ];\\n\\n\\t\\t\\t\\tfor ( j = 0; j < 3; j ++ ) {\\n\\n\\t\\t\\t\\t\\tedge1 = face[ keys[ j ] ];\\n\\t\\t\\t\\t\\tedge2 = face[ keys[ ( j + 1 ) % 3 ] ];\\n\\t\\t\\t\\t\\tedge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates\\n\\t\\t\\t\\t\\tedge[ 1 ] = Math.max( edge1, edge2 );\\n\\n\\t\\t\\t\\t\\tkey = edge[ 0 ] + ',' + edge[ 1 ];\\n\\n\\t\\t\\t\\t\\tif ( edges[ key ] === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// generate vertices\\n\\n\\t\\t\\tfor ( key in edges ) {\\n\\n\\t\\t\\t\\te = edges[ key ];\\n\\n\\t\\t\\t\\tvertex = geometry.vertices[ e.index1 ];\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\tvertex = geometry.vertices[ e.index2 ];\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t}\\n\\n\\t\\t} else if ( geometry && geometry.isBufferGeometry ) {\\n\\n\\t\\t\\tvar position, indices, groups;\\n\\t\\t\\tvar group, start, count;\\n\\t\\t\\tvar index1, index2;\\n\\n\\t\\t\\tvertex = new Vector3();\\n\\n\\t\\t\\tif ( geometry.index !== null ) {\\n\\n\\t\\t\\t\\t// indexed BufferGeometry\\n\\n\\t\\t\\t\\tposition = geometry.attributes.position;\\n\\t\\t\\t\\tindices = geometry.index;\\n\\t\\t\\t\\tgroups = geometry.groups;\\n\\n\\t\\t\\t\\tif ( groups.length === 0 ) {\\n\\n\\t\\t\\t\\t\\tgroups = [ { start: 0, count: indices.count, materialIndex: 0 } ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// create a data structure that contains all eges without duplicates\\n\\n\\t\\t\\t\\tfor ( o = 0, ol = groups.length; o < ol; ++ o ) {\\n\\n\\t\\t\\t\\t\\tgroup = groups[ o ];\\n\\n\\t\\t\\t\\t\\tstart = group.start;\\n\\t\\t\\t\\t\\tcount = group.count;\\n\\n\\t\\t\\t\\t\\tfor ( i = start, l = ( start + count ); i < l; i += 3 ) {\\n\\n\\t\\t\\t\\t\\t\\tfor ( j = 0; j < 3; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tedge1 = indices.getX( i + j );\\n\\t\\t\\t\\t\\t\\t\\tedge2 = indices.getX( i + ( j + 1 ) % 3 );\\n\\t\\t\\t\\t\\t\\t\\tedge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates\\n\\t\\t\\t\\t\\t\\t\\tedge[ 1 ] = Math.max( edge1, edge2 );\\n\\n\\t\\t\\t\\t\\t\\t\\tkey = edge[ 0 ] + ',' + edge[ 1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( edges[ key ] === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// generate vertices\\n\\n\\t\\t\\t\\tfor ( key in edges ) {\\n\\n\\t\\t\\t\\t\\te = edges[ key ];\\n\\n\\t\\t\\t\\t\\tvertex.fromBufferAttribute( position, e.index1 );\\n\\t\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t\\tvertex.fromBufferAttribute( position, e.index2 );\\n\\t\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// non-indexed BufferGeometry\\n\\n\\t\\t\\t\\tposition = geometry.attributes.position;\\n\\n\\t\\t\\t\\tfor ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tfor ( j = 0; j < 3; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t// three edges per triangle, an edge is represented as (index1, index2)\\n\\t\\t\\t\\t\\t\\t// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\\n\\n\\t\\t\\t\\t\\t\\tindex1 = 3 * i + j;\\n\\t\\t\\t\\t\\t\\tvertex.fromBufferAttribute( position, index1 );\\n\\t\\t\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t\\t\\tindex2 = 3 * i + ( ( j + 1 ) % 3 );\\n\\t\\t\\t\\t\\t\\tvertex.fromBufferAttribute( position, index2 );\\n\\t\\t\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\n\\t}\\n\\n\\tWireframeGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tWireframeGeometry.prototype.constructor = WireframeGeometry;\\n\\n\\t/**\\n\\t * @author zz85 / https://github.com/zz85\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t *\\n\\t * Parametric Surfaces Geometry\\n\\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\\n\\t */\\n\\n\\t// ParametricGeometry\\n\\n\\tfunction ParametricGeometry( func, slices, stacks ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'ParametricGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tfunc: func,\\n\\t\\t\\tslices: slices,\\n\\t\\t\\tstacks: stacks\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tParametricGeometry.prototype = Object.create( Geometry.prototype );\\n\\tParametricGeometry.prototype.constructor = ParametricGeometry;\\n\\n\\t// ParametricBufferGeometry\\n\\n\\tfunction ParametricBufferGeometry( func, slices, stacks ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'ParametricBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tfunc: func,\\n\\t\\t\\tslices: slices,\\n\\t\\t\\tstacks: stacks\\n\\t\\t};\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\tvar EPS = 0.00001;\\n\\n\\t\\tvar normal = new Vector3();\\n\\n\\t\\tvar p0 = new Vector3(), p1 = new Vector3();\\n\\t\\tvar pu = new Vector3(), pv = new Vector3();\\n\\n\\t\\tvar i, j;\\n\\n\\t\\t// generate vertices, normals and uvs\\n\\n\\t\\tvar sliceCount = slices + 1;\\n\\n\\t\\tfor ( i = 0; i <= stacks; i ++ ) {\\n\\n\\t\\t\\tvar v = i / stacks;\\n\\n\\t\\t\\tfor ( j = 0; j <= slices; j ++ ) {\\n\\n\\t\\t\\t\\tvar u = j / slices;\\n\\n\\t\\t\\t\\t// vertex\\n\\n\\t\\t\\t\\tp0 = func( u, v, p0 );\\n\\t\\t\\t\\tvertices.push( p0.x, p0.y, p0.z );\\n\\n\\t\\t\\t\\t// normal\\n\\n\\t\\t\\t\\t// approximate tangent vectors via finite differences\\n\\n\\t\\t\\t\\tif ( u - EPS >= 0 ) {\\n\\n\\t\\t\\t\\t\\tp1 = func( u - EPS, v, p1 );\\n\\t\\t\\t\\t\\tpu.subVectors( p0, p1 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tp1 = func( u + EPS, v, p1 );\\n\\t\\t\\t\\t\\tpu.subVectors( p1, p0 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( v - EPS >= 0 ) {\\n\\n\\t\\t\\t\\t\\tp1 = func( u, v - EPS, p1 );\\n\\t\\t\\t\\t\\tpv.subVectors( p0, p1 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tp1 = func( u, v + EPS, p1 );\\n\\t\\t\\t\\t\\tpv.subVectors( p1, p0 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// cross product of tangent vectors returns surface normal\\n\\n\\t\\t\\t\\tnormal.crossVectors( pu, pv ).normalize();\\n\\t\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\n\\n\\t\\t\\t\\t// uv\\n\\n\\t\\t\\t\\tuvs.push( u, v );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// generate indices\\n\\n\\t\\tfor ( i = 0; i < stacks; i ++ ) {\\n\\n\\t\\t\\tfor ( j = 0; j < slices; j ++ ) {\\n\\n\\t\\t\\t\\tvar a = i * sliceCount + j;\\n\\t\\t\\t\\tvar b = i * sliceCount + j + 1;\\n\\t\\t\\t\\tvar c = ( i + 1 ) * sliceCount + j + 1;\\n\\t\\t\\t\\tvar d = ( i + 1 ) * sliceCount + j;\\n\\n\\t\\t\\t\\t// faces one and two\\n\\n\\t\\t\\t\\tindices.push( a, b, d );\\n\\t\\t\\t\\tindices.push( b, c, d );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t}\\n\\n\\tParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;\\n\\n\\t/**\\n\\t * @author clockworkgeek / https://github.com/clockworkgeek\\n\\t * @author timothypratley / https://github.com/timothypratley\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// PolyhedronGeometry\\n\\n\\tfunction PolyhedronGeometry( vertices, indices, radius, detail ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'PolyhedronGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tvertices: vertices,\\n\\t\\t\\tindices: indices,\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tPolyhedronGeometry.prototype = Object.create( Geometry.prototype );\\n\\tPolyhedronGeometry.prototype.constructor = PolyhedronGeometry;\\n\\n\\t// PolyhedronBufferGeometry\\n\\n\\tfunction PolyhedronBufferGeometry( vertices, indices, radius, detail ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'PolyhedronBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tvertices: vertices,\\n\\t\\t\\tindices: indices,\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t\\tradius = radius || 1;\\n\\t\\tdetail = detail || 0;\\n\\n\\t\\t// default buffer data\\n\\n\\t\\tvar vertexBuffer = [];\\n\\t\\tvar uvBuffer = [];\\n\\n\\t\\t// the subdivision creates the vertex buffer data\\n\\n\\t\\tsubdivide( detail );\\n\\n\\t\\t// all vertices should lie on a conceptual sphere with a given radius\\n\\n\\t\\tappplyRadius( radius );\\n\\n\\t\\t// finally, create the uv data\\n\\n\\t\\tgenerateUVs();\\n\\n\\t\\t// build non-indexed geometry\\n\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );\\n\\n\\t\\tif ( detail === 0 ) {\\n\\n\\t\\t\\tthis.computeVertexNormals(); // flat normals\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tthis.normalizeNormals(); // smooth normals\\n\\n\\t\\t}\\n\\n\\t\\t// helper functions\\n\\n\\t\\tfunction subdivide( detail ) {\\n\\n\\t\\t\\tvar a = new Vector3();\\n\\t\\t\\tvar b = new Vector3();\\n\\t\\t\\tvar c = new Vector3();\\n\\n\\t\\t\\t// iterate over all faces and apply a subdivison with the given detail value\\n\\n\\t\\t\\tfor ( var i = 0; i < indices.length; i += 3 ) {\\n\\n\\t\\t\\t\\t// get the vertices of the face\\n\\n\\t\\t\\t\\tgetVertexByIndex( indices[ i + 0 ], a );\\n\\t\\t\\t\\tgetVertexByIndex( indices[ i + 1 ], b );\\n\\t\\t\\t\\tgetVertexByIndex( indices[ i + 2 ], c );\\n\\n\\t\\t\\t\\t// perform subdivision\\n\\n\\t\\t\\t\\tsubdivideFace( a, b, c, detail );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction subdivideFace( a, b, c, detail ) {\\n\\n\\t\\t\\tvar cols = Math.pow( 2, detail );\\n\\n\\t\\t\\t// we use this multidimensional array as a data structure for creating the subdivision\\n\\n\\t\\t\\tvar v = [];\\n\\n\\t\\t\\tvar i, j;\\n\\n\\t\\t\\t// construct all of the vertices for this subdivision\\n\\n\\t\\t\\tfor ( i = 0; i <= cols; i ++ ) {\\n\\n\\t\\t\\t\\tv[ i ] = [];\\n\\n\\t\\t\\t\\tvar aj = a.clone().lerp( c, i / cols );\\n\\t\\t\\t\\tvar bj = b.clone().lerp( c, i / cols );\\n\\n\\t\\t\\t\\tvar rows = cols - i;\\n\\n\\t\\t\\t\\tfor ( j = 0; j <= rows; j ++ ) {\\n\\n\\t\\t\\t\\t\\tif ( j === 0 && i === cols ) {\\n\\n\\t\\t\\t\\t\\t\\tv[ i ][ j ] = aj;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// construct all of the faces\\n\\n\\t\\t\\tfor ( i = 0; i < cols; i ++ ) {\\n\\n\\t\\t\\t\\tfor ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\\n\\n\\t\\t\\t\\t\\tvar k = Math.floor( j / 2 );\\n\\n\\t\\t\\t\\t\\tif ( j % 2 === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\tpushVertex( v[ i ][ k + 1 ] );\\n\\t\\t\\t\\t\\t\\tpushVertex( v[ i + 1 ][ k ] );\\n\\t\\t\\t\\t\\t\\tpushVertex( v[ i ][ k ] );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tpushVertex( v[ i ][ k + 1 ] );\\n\\t\\t\\t\\t\\t\\tpushVertex( v[ i + 1 ][ k + 1 ] );\\n\\t\\t\\t\\t\\t\\tpushVertex( v[ i + 1 ][ k ] );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction appplyRadius( radius ) {\\n\\n\\t\\t\\tvar vertex = new Vector3();\\n\\n\\t\\t\\t// iterate over the entire buffer and apply the radius to each vertex\\n\\n\\t\\t\\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\\n\\n\\t\\t\\t\\tvertex.x = vertexBuffer[ i + 0 ];\\n\\t\\t\\t\\tvertex.y = vertexBuffer[ i + 1 ];\\n\\t\\t\\t\\tvertex.z = vertexBuffer[ i + 2 ];\\n\\n\\t\\t\\t\\tvertex.normalize().multiplyScalar( radius );\\n\\n\\t\\t\\t\\tvertexBuffer[ i + 0 ] = vertex.x;\\n\\t\\t\\t\\tvertexBuffer[ i + 1 ] = vertex.y;\\n\\t\\t\\t\\tvertexBuffer[ i + 2 ] = vertex.z;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction generateUVs() {\\n\\n\\t\\t\\tvar vertex = new Vector3();\\n\\n\\t\\t\\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\\n\\n\\t\\t\\t\\tvertex.x = vertexBuffer[ i + 0 ];\\n\\t\\t\\t\\tvertex.y = vertexBuffer[ i + 1 ];\\n\\t\\t\\t\\tvertex.z = vertexBuffer[ i + 2 ];\\n\\n\\t\\t\\t\\tvar u = azimuth( vertex ) / 2 / Math.PI + 0.5;\\n\\t\\t\\t\\tvar v = inclination( vertex ) / Math.PI + 0.5;\\n\\t\\t\\t\\tuvBuffer.push( u, 1 - v );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tcorrectUVs();\\n\\n\\t\\t\\tcorrectSeam();\\n\\n\\t\\t}\\n\\n\\t\\tfunction correctSeam() {\\n\\n\\t\\t\\t// handle case when face straddles the seam, see #3269\\n\\n\\t\\t\\tfor ( var i = 0; i < uvBuffer.length; i += 6 ) {\\n\\n\\t\\t\\t\\t// uv data of a single face\\n\\n\\t\\t\\t\\tvar x0 = uvBuffer[ i + 0 ];\\n\\t\\t\\t\\tvar x1 = uvBuffer[ i + 2 ];\\n\\t\\t\\t\\tvar x2 = uvBuffer[ i + 4 ];\\n\\n\\t\\t\\t\\tvar max = Math.max( x0, x1, x2 );\\n\\t\\t\\t\\tvar min = Math.min( x0, x1, x2 );\\n\\n\\t\\t\\t\\t// 0.9 is somewhat arbitrary\\n\\n\\t\\t\\t\\tif ( max > 0.9 && min < 0.1 ) {\\n\\n\\t\\t\\t\\t\\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\\n\\t\\t\\t\\t\\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\\n\\t\\t\\t\\t\\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction pushVertex( vertex ) {\\n\\n\\t\\t\\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t}\\n\\n\\t\\tfunction getVertexByIndex( index, vertex ) {\\n\\n\\t\\t\\tvar stride = index * 3;\\n\\n\\t\\t\\tvertex.x = vertices[ stride + 0 ];\\n\\t\\t\\tvertex.y = vertices[ stride + 1 ];\\n\\t\\t\\tvertex.z = vertices[ stride + 2 ];\\n\\n\\t\\t}\\n\\n\\t\\tfunction correctUVs() {\\n\\n\\t\\t\\tvar a = new Vector3();\\n\\t\\t\\tvar b = new Vector3();\\n\\t\\t\\tvar c = new Vector3();\\n\\n\\t\\t\\tvar centroid = new Vector3();\\n\\n\\t\\t\\tvar uvA = new Vector2();\\n\\t\\t\\tvar uvB = new Vector2();\\n\\t\\t\\tvar uvC = new Vector2();\\n\\n\\t\\t\\tfor ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\\n\\n\\t\\t\\t\\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\\n\\t\\t\\t\\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\\n\\t\\t\\t\\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\\n\\n\\t\\t\\t\\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\\n\\t\\t\\t\\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\\n\\t\\t\\t\\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\\n\\n\\t\\t\\t\\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\\n\\n\\t\\t\\t\\tvar azi = azimuth( centroid );\\n\\n\\t\\t\\t\\tcorrectUV( uvA, j + 0, a, azi );\\n\\t\\t\\t\\tcorrectUV( uvB, j + 2, b, azi );\\n\\t\\t\\t\\tcorrectUV( uvC, j + 4, c, azi );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction correctUV( uv, stride, vector, azimuth ) {\\n\\n\\t\\t\\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\\n\\n\\t\\t\\t\\tuvBuffer[ stride ] = uv.x - 1;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\\n\\n\\t\\t\\t\\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// Angle around the Y axis, counter-clockwise when looking from above.\\n\\n\\t\\tfunction azimuth( vector ) {\\n\\n\\t\\t\\treturn Math.atan2( vector.z, - vector.x );\\n\\n\\t\\t}\\n\\n\\n\\t\\t// Angle above the XZ plane.\\n\\n\\t\\tfunction inclination( vector ) {\\n\\n\\t\\t\\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tPolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tPolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;\\n\\n\\t/**\\n\\t * @author timothypratley / https://github.com/timothypratley\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// TetrahedronGeometry\\n\\n\\tfunction TetrahedronGeometry( radius, detail ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'TetrahedronGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tTetrahedronGeometry.prototype = Object.create( Geometry.prototype );\\n\\tTetrahedronGeometry.prototype.constructor = TetrahedronGeometry;\\n\\n\\t// TetrahedronBufferGeometry\\n\\n\\tfunction TetrahedronBufferGeometry( radius, detail ) {\\n\\n\\t\\tvar vertices = [\\n\\t\\t\\t1, 1, 1, \\t- 1, - 1, 1, \\t- 1, 1, - 1, \\t1, - 1, - 1\\n\\t\\t];\\n\\n\\t\\tvar indices = [\\n\\t\\t\\t2, 1, 0, \\t0, 3, 2,\\t1, 3, 0,\\t2, 3, 1\\n\\t\\t];\\n\\n\\t\\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\\n\\n\\t\\tthis.type = 'TetrahedronBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t}\\n\\n\\tTetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\\n\\tTetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;\\n\\n\\t/**\\n\\t * @author timothypratley / https://github.com/timothypratley\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// OctahedronGeometry\\n\\n\\tfunction OctahedronGeometry( radius, detail ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'OctahedronGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tOctahedronGeometry.prototype = Object.create( Geometry.prototype );\\n\\tOctahedronGeometry.prototype.constructor = OctahedronGeometry;\\n\\n\\t// OctahedronBufferGeometry\\n\\n\\tfunction OctahedronBufferGeometry( radius, detail ) {\\n\\n\\t\\tvar vertices = [\\n\\t\\t\\t1, 0, 0, \\t- 1, 0, 0,\\t0, 1, 0,\\n\\t\\t\\t0, - 1, 0, \\t0, 0, 1,\\t0, 0, - 1\\n\\t\\t];\\n\\n\\t\\tvar indices = [\\n\\t\\t\\t0, 2, 4,\\t0, 4, 3,\\t0, 3, 5,\\n\\t\\t\\t0, 5, 2,\\t1, 2, 5,\\t1, 5, 3,\\n\\t\\t\\t1, 3, 4,\\t1, 4, 2\\n\\t\\t];\\n\\n\\t\\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\\n\\n\\t\\tthis.type = 'OctahedronBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t}\\n\\n\\tOctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\\n\\tOctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;\\n\\n\\t/**\\n\\t * @author timothypratley / https://github.com/timothypratley\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// IcosahedronGeometry\\n\\n\\tfunction IcosahedronGeometry( radius, detail ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'IcosahedronGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tIcosahedronGeometry.prototype = Object.create( Geometry.prototype );\\n\\tIcosahedronGeometry.prototype.constructor = IcosahedronGeometry;\\n\\n\\t// IcosahedronBufferGeometry\\n\\n\\tfunction IcosahedronBufferGeometry( radius, detail ) {\\n\\n\\t\\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\\n\\n\\t\\tvar vertices = [\\n\\t\\t\\t- 1, t, 0, \\t1, t, 0, \\t- 1, - t, 0, \\t1, - t, 0,\\n\\t\\t\\t 0, - 1, t, \\t0, 1, t,\\t0, - 1, - t, \\t0, 1, - t,\\n\\t\\t\\t t, 0, - 1, \\tt, 0, 1, \\t- t, 0, - 1, \\t- t, 0, 1\\n\\t\\t];\\n\\n\\t\\tvar indices = [\\n\\t\\t\\t 0, 11, 5, \\t0, 5, 1, \\t0, 1, 7, \\t0, 7, 10, \\t0, 10, 11,\\n\\t\\t\\t 1, 5, 9, \\t5, 11, 4,\\t11, 10, 2,\\t10, 7, 6,\\t7, 1, 8,\\n\\t\\t\\t 3, 9, 4, \\t3, 4, 2,\\t3, 2, 6,\\t3, 6, 8,\\t3, 8, 9,\\n\\t\\t\\t 4, 9, 5, \\t2, 4, 11,\\t6, 2, 10,\\t8, 6, 7,\\t9, 8, 1\\n\\t\\t];\\n\\n\\t\\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\\n\\n\\t\\tthis.type = 'IcosahedronBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t}\\n\\n\\tIcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\\n\\tIcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;\\n\\n\\t/**\\n\\t * @author Abe Pazos / https://hamoid.com\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// DodecahedronGeometry\\n\\n\\tfunction DodecahedronGeometry( radius, detail ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'DodecahedronGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tDodecahedronGeometry.prototype = Object.create( Geometry.prototype );\\n\\tDodecahedronGeometry.prototype.constructor = DodecahedronGeometry;\\n\\n\\t// DodecahedronBufferGeometry\\n\\n\\tfunction DodecahedronBufferGeometry( radius, detail ) {\\n\\n\\t\\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\\n\\t\\tvar r = 1 / t;\\n\\n\\t\\tvar vertices = [\\n\\n\\t\\t\\t// (1, 1, 1)\\n\\t\\t\\t- 1, - 1, - 1,\\t- 1, - 1, 1,\\n\\t\\t\\t- 1, 1, - 1, - 1, 1, 1,\\n\\t\\t\\t1, - 1, - 1, 1, - 1, 1,\\n\\t\\t\\t1, 1, - 1, 1, 1, 1,\\n\\n\\t\\t\\t// (0, 1/, )\\n\\t\\t\\t 0, - r, - t, 0, - r, t,\\n\\t\\t\\t 0, r, - t, 0, r, t,\\n\\n\\t\\t\\t// (1/, , 0)\\n\\t\\t\\t- r, - t, 0, - r, t, 0,\\n\\t\\t\\t r, - t, 0, r, t, 0,\\n\\n\\t\\t\\t// (, 0, 1/)\\n\\t\\t\\t- t, 0, - r, t, 0, - r,\\n\\t\\t\\t- t, 0, r, t, 0, r\\n\\t\\t];\\n\\n\\t\\tvar indices = [\\n\\t\\t\\t3, 11, 7, \\t3, 7, 15, \\t3, 15, 13,\\n\\t\\t\\t7, 19, 17, \\t7, 17, 6, \\t7, 6, 15,\\n\\t\\t\\t17, 4, 8, \\t17, 8, 10, \\t17, 10, 6,\\n\\t\\t\\t8, 0, 16, \\t8, 16, 2, \\t8, 2, 10,\\n\\t\\t\\t0, 12, 1, \\t0, 1, 18, \\t0, 18, 16,\\n\\t\\t\\t6, 10, 2, \\t6, 2, 13, \\t6, 13, 15,\\n\\t\\t\\t2, 16, 18, \\t2, 18, 3, \\t2, 3, 13,\\n\\t\\t\\t18, 1, 9, \\t18, 9, 11, \\t18, 11, 3,\\n\\t\\t\\t4, 14, 12, \\t4, 12, 0, \\t4, 0, 8,\\n\\t\\t\\t11, 9, 5, \\t11, 5, 19, \\t11, 19, 7,\\n\\t\\t\\t19, 5, 14, \\t19, 14, 4, \\t19, 4, 17,\\n\\t\\t\\t1, 12, 14, \\t1, 14, 5, \\t1, 5, 9\\n\\t\\t];\\n\\n\\t\\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\\n\\n\\t\\tthis.type = 'DodecahedronBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t}\\n\\n\\tDodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\\n\\tDodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;\\n\\n\\t/**\\n\\t * @author oosmoxiecode / https://github.com/oosmoxiecode\\n\\t * @author WestLangley / https://github.com/WestLangley\\n\\t * @author zz85 / https://github.com/zz85\\n\\t * @author miningold / https://github.com/miningold\\n\\t * @author jonobr1 / https://github.com/jonobr1\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t *\\n\\t */\\n\\n\\t// TubeGeometry\\n\\n\\tfunction TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'TubeGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tpath: path,\\n\\t\\t\\ttubularSegments: tubularSegments,\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\tclosed: closed\\n\\t\\t};\\n\\n\\t\\tif ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );\\n\\n\\t\\tvar bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );\\n\\n\\t\\t// expose internals\\n\\n\\t\\tthis.tangents = bufferGeometry.tangents;\\n\\t\\tthis.normals = bufferGeometry.normals;\\n\\t\\tthis.binormals = bufferGeometry.binormals;\\n\\n\\t\\t// create geometry\\n\\n\\t\\tthis.fromBufferGeometry( bufferGeometry );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tTubeGeometry.prototype = Object.create( Geometry.prototype );\\n\\tTubeGeometry.prototype.constructor = TubeGeometry;\\n\\n\\t// TubeBufferGeometry\\n\\n\\tfunction TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'TubeBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tpath: path,\\n\\t\\t\\ttubularSegments: tubularSegments,\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\tclosed: closed\\n\\t\\t};\\n\\n\\t\\ttubularSegments = tubularSegments || 64;\\n\\t\\tradius = radius || 1;\\n\\t\\tradialSegments = radialSegments || 8;\\n\\t\\tclosed = closed || false;\\n\\n\\t\\tvar frames = path.computeFrenetFrames( tubularSegments, closed );\\n\\n\\t\\t// expose internals\\n\\n\\t\\tthis.tangents = frames.tangents;\\n\\t\\tthis.normals = frames.normals;\\n\\t\\tthis.binormals = frames.binormals;\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar vertex = new Vector3();\\n\\t\\tvar normal = new Vector3();\\n\\t\\tvar uv = new Vector2();\\n\\t\\tvar P = new Vector3();\\n\\n\\t\\tvar i, j;\\n\\n\\t\\t// buffer\\n\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\t\\tvar indices = [];\\n\\n\\t\\t// create buffer data\\n\\n\\t\\tgenerateBufferData();\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t\\t// functions\\n\\n\\t\\tfunction generateBufferData() {\\n\\n\\t\\t\\tfor ( i = 0; i < tubularSegments; i ++ ) {\\n\\n\\t\\t\\t\\tgenerateSegment( i );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// if the geometry is not closed, generate the last row of vertices and normals\\n\\t\\t\\t// at the regular position on the given path\\n\\t\\t\\t//\\n\\t\\t\\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\\n\\n\\t\\t\\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\\n\\n\\t\\t\\t// uvs are generated in a separate function.\\n\\t\\t\\t// this makes it easy compute correct values for closed geometries\\n\\n\\t\\t\\tgenerateUVs();\\n\\n\\t\\t\\t// finally create faces\\n\\n\\t\\t\\tgenerateIndices();\\n\\n\\t\\t}\\n\\n\\t\\tfunction generateSegment( i ) {\\n\\n\\t\\t\\t// we use getPointAt to sample evenly distributed points from the given path\\n\\n\\t\\t\\tP = path.getPointAt( i / tubularSegments, P );\\n\\n\\t\\t\\t// retrieve corresponding normal and binormal\\n\\n\\t\\t\\tvar N = frames.normals[ i ];\\n\\t\\t\\tvar B = frames.binormals[ i ];\\n\\n\\t\\t\\t// generate normals and vertices for the current segment\\n\\n\\t\\t\\tfor ( j = 0; j <= radialSegments; j ++ ) {\\n\\n\\t\\t\\t\\tvar v = j / radialSegments * Math.PI * 2;\\n\\n\\t\\t\\t\\tvar sin = Math.sin( v );\\n\\t\\t\\t\\tvar cos = - Math.cos( v );\\n\\n\\t\\t\\t\\t// normal\\n\\n\\t\\t\\t\\tnormal.x = ( cos * N.x + sin * B.x );\\n\\t\\t\\t\\tnormal.y = ( cos * N.y + sin * B.y );\\n\\t\\t\\t\\tnormal.z = ( cos * N.z + sin * B.z );\\n\\t\\t\\t\\tnormal.normalize();\\n\\n\\t\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\n\\n\\t\\t\\t\\t// vertex\\n\\n\\t\\t\\t\\tvertex.x = P.x + radius * normal.x;\\n\\t\\t\\t\\tvertex.y = P.y + radius * normal.y;\\n\\t\\t\\t\\tvertex.z = P.z + radius * normal.z;\\n\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction generateIndices() {\\n\\n\\t\\t\\tfor ( j = 1; j <= tubularSegments; j ++ ) {\\n\\n\\t\\t\\t\\tfor ( i = 1; i <= radialSegments; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\\n\\t\\t\\t\\t\\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\\n\\t\\t\\t\\t\\tvar c = ( radialSegments + 1 ) * j + i;\\n\\t\\t\\t\\t\\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\\n\\n\\t\\t\\t\\t\\t// faces\\n\\n\\t\\t\\t\\t\\tindices.push( a, b, d );\\n\\t\\t\\t\\t\\tindices.push( b, c, d );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction generateUVs() {\\n\\n\\t\\t\\tfor ( i = 0; i <= tubularSegments; i ++ ) {\\n\\n\\t\\t\\t\\tfor ( j = 0; j <= radialSegments; j ++ ) {\\n\\n\\t\\t\\t\\t\\tuv.x = i / tubularSegments;\\n\\t\\t\\t\\t\\tuv.y = j / radialSegments;\\n\\n\\t\\t\\t\\t\\tuvs.push( uv.x, uv.y );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tTubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tTubeBufferGeometry.prototype.constructor = TubeBufferGeometry;\\n\\n\\t/**\\n\\t * @author oosmoxiecode\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t *\\n\\t * based on http://www.blackpawn.com/texts/pqtorus/\\n\\t */\\n\\n\\t// TorusKnotGeometry\\n\\n\\tfunction TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'TorusKnotGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\ttube: tube,\\n\\t\\t\\ttubularSegments: tubularSegments,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\tp: p,\\n\\t\\t\\tq: q\\n\\t\\t};\\n\\n\\t\\tif ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\\n\\n\\t\\tthis.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tTorusKnotGeometry.prototype = Object.create( Geometry.prototype );\\n\\tTorusKnotGeometry.prototype.constructor = TorusKnotGeometry;\\n\\n\\t// TorusKnotBufferGeometry\\n\\n\\tfunction TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'TorusKnotBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\ttube: tube,\\n\\t\\t\\ttubularSegments: tubularSegments,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\tp: p,\\n\\t\\t\\tq: q\\n\\t\\t};\\n\\n\\t\\tradius = radius || 1;\\n\\t\\ttube = tube || 0.4;\\n\\t\\ttubularSegments = Math.floor( tubularSegments ) || 64;\\n\\t\\tradialSegments = Math.floor( radialSegments ) || 8;\\n\\t\\tp = p || 2;\\n\\t\\tq = q || 3;\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar i, j;\\n\\n\\t\\tvar vertex = new Vector3();\\n\\t\\tvar normal = new Vector3();\\n\\n\\t\\tvar P1 = new Vector3();\\n\\t\\tvar P2 = new Vector3();\\n\\n\\t\\tvar B = new Vector3();\\n\\t\\tvar T = new Vector3();\\n\\t\\tvar N = new Vector3();\\n\\n\\t\\t// generate vertices, normals and uvs\\n\\n\\t\\tfor ( i = 0; i <= tubularSegments; ++ i ) {\\n\\n\\t\\t\\t// the radian \\\"u\\\" is used to calculate the position on the torus curve of the current tubular segement\\n\\n\\t\\t\\tvar u = i / tubularSegments * p * Math.PI * 2;\\n\\n\\t\\t\\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\\n\\t\\t\\t// these points are used to create a special \\\"coordinate space\\\", which is necessary to calculate the correct vertex positions\\n\\n\\t\\t\\tcalculatePositionOnCurve( u, p, q, radius, P1 );\\n\\t\\t\\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\\n\\n\\t\\t\\t// calculate orthonormal basis\\n\\n\\t\\t\\tT.subVectors( P2, P1 );\\n\\t\\t\\tN.addVectors( P2, P1 );\\n\\t\\t\\tB.crossVectors( T, N );\\n\\t\\t\\tN.crossVectors( B, T );\\n\\n\\t\\t\\t// normalize B, N. T can be ignored, we don't use it\\n\\n\\t\\t\\tB.normalize();\\n\\t\\t\\tN.normalize();\\n\\n\\t\\t\\tfor ( j = 0; j <= radialSegments; ++ j ) {\\n\\n\\t\\t\\t\\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\\n\\t\\t\\t\\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\\n\\n\\t\\t\\t\\tvar v = j / radialSegments * Math.PI * 2;\\n\\t\\t\\t\\tvar cx = - tube * Math.cos( v );\\n\\t\\t\\t\\tvar cy = tube * Math.sin( v );\\n\\n\\t\\t\\t\\t// now calculate the final vertex position.\\n\\t\\t\\t\\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\\n\\n\\t\\t\\t\\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\\n\\t\\t\\t\\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\\n\\t\\t\\t\\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\\n\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\\n\\n\\t\\t\\t\\tnormal.subVectors( vertex, P1 ).normalize();\\n\\n\\t\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\n\\n\\t\\t\\t\\t// uv\\n\\n\\t\\t\\t\\tuvs.push( i / tubularSegments );\\n\\t\\t\\t\\tuvs.push( j / radialSegments );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// generate indices\\n\\n\\t\\tfor ( j = 1; j <= tubularSegments; j ++ ) {\\n\\n\\t\\t\\tfor ( i = 1; i <= radialSegments; i ++ ) {\\n\\n\\t\\t\\t\\t// indices\\n\\n\\t\\t\\t\\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\\n\\t\\t\\t\\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\\n\\t\\t\\t\\tvar c = ( radialSegments + 1 ) * j + i;\\n\\t\\t\\t\\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\\n\\n\\t\\t\\t\\t// faces\\n\\n\\t\\t\\t\\tindices.push( a, b, d );\\n\\t\\t\\t\\tindices.push( b, c, d );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t\\t// this function calculates the current position on the torus curve\\n\\n\\t\\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\\n\\n\\t\\t\\tvar cu = Math.cos( u );\\n\\t\\t\\tvar su = Math.sin( u );\\n\\t\\t\\tvar quOverP = q / p * u;\\n\\t\\t\\tvar cs = Math.cos( quOverP );\\n\\n\\t\\t\\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\\n\\t\\t\\tposition.y = radius * ( 2 + cs ) * su * 0.5;\\n\\t\\t\\tposition.z = radius * Math.sin( quOverP ) * 0.5;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tTorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tTorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;\\n\\n\\t/**\\n\\t * @author oosmoxiecode\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// TorusGeometry\\n\\n\\tfunction TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'TorusGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\ttube: tube,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\ttubularSegments: tubularSegments,\\n\\t\\t\\tarc: arc\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tTorusGeometry.prototype = Object.create( Geometry.prototype );\\n\\tTorusGeometry.prototype.constructor = TorusGeometry;\\n\\n\\t// TorusBufferGeometry\\n\\n\\tfunction TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'TorusBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\ttube: tube,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\ttubularSegments: tubularSegments,\\n\\t\\t\\tarc: arc\\n\\t\\t};\\n\\n\\t\\tradius = radius || 1;\\n\\t\\ttube = tube || 0.4;\\n\\t\\tradialSegments = Math.floor( radialSegments ) || 8;\\n\\t\\ttubularSegments = Math.floor( tubularSegments ) || 6;\\n\\t\\tarc = arc || Math.PI * 2;\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar center = new Vector3();\\n\\t\\tvar vertex = new Vector3();\\n\\t\\tvar normal = new Vector3();\\n\\n\\t\\tvar j, i;\\n\\n\\t\\t// generate vertices, normals and uvs\\n\\n\\t\\tfor ( j = 0; j <= radialSegments; j ++ ) {\\n\\n\\t\\t\\tfor ( i = 0; i <= tubularSegments; i ++ ) {\\n\\n\\t\\t\\t\\tvar u = i / tubularSegments * arc;\\n\\t\\t\\t\\tvar v = j / radialSegments * Math.PI * 2;\\n\\n\\t\\t\\t\\t// vertex\\n\\n\\t\\t\\t\\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\\n\\t\\t\\t\\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\\n\\t\\t\\t\\tvertex.z = tube * Math.sin( v );\\n\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t// normal\\n\\n\\t\\t\\t\\tcenter.x = radius * Math.cos( u );\\n\\t\\t\\t\\tcenter.y = radius * Math.sin( u );\\n\\t\\t\\t\\tnormal.subVectors( vertex, center ).normalize();\\n\\n\\t\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\n\\n\\t\\t\\t\\t// uv\\n\\n\\t\\t\\t\\tuvs.push( i / tubularSegments );\\n\\t\\t\\t\\tuvs.push( j / radialSegments );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// generate indices\\n\\n\\t\\tfor ( j = 1; j <= radialSegments; j ++ ) {\\n\\n\\t\\t\\tfor ( i = 1; i <= tubularSegments; i ++ ) {\\n\\n\\t\\t\\t\\t// indices\\n\\n\\t\\t\\t\\tvar a = ( tubularSegments + 1 ) * j + i - 1;\\n\\t\\t\\t\\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\\n\\t\\t\\t\\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\\n\\t\\t\\t\\tvar d = ( tubularSegments + 1 ) * j + i;\\n\\n\\t\\t\\t\\t// faces\\n\\n\\t\\t\\t\\tindices.push( a, b, d );\\n\\t\\t\\t\\tindices.push( b, c, d );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t}\\n\\n\\tTorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tTorusBufferGeometry.prototype.constructor = TorusBufferGeometry;\\n\\n\\t/**\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t * Port from https://github.com/mapbox/earcut (v2.1.2)\\n\\t */\\n\\n\\tvar Earcut = {\\n\\n\\t\\ttriangulate: function ( data, holeIndices, dim ) {\\n\\n\\t\\t\\tdim = dim || 2;\\n\\n\\t\\t\\tvar hasHoles = holeIndices && holeIndices.length,\\n\\t\\t\\t\\touterLen = hasHoles ? holeIndices[ 0 ] * dim : data.length,\\n\\t\\t\\t\\touterNode = linkedList( data, 0, outerLen, dim, true ),\\n\\t\\t\\t\\ttriangles = [];\\n\\n\\t\\t\\tif ( ! outerNode ) return triangles;\\n\\n\\t\\t\\tvar minX, minY, maxX, maxY, x, y, invSize;\\n\\n\\t\\t\\tif ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );\\n\\n\\t\\t\\t// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\\n\\n\\t\\t\\tif ( data.length > 80 * dim ) {\\n\\n\\t\\t\\t\\tminX = maxX = data[ 0 ];\\n\\t\\t\\t\\tminY = maxY = data[ 1 ];\\n\\n\\t\\t\\t\\tfor ( var i = dim; i < outerLen; i += dim ) {\\n\\n\\t\\t\\t\\t\\tx = data[ i ];\\n\\t\\t\\t\\t\\ty = data[ i + 1 ];\\n\\t\\t\\t\\t\\tif ( x < minX ) minX = x;\\n\\t\\t\\t\\t\\tif ( y < minY ) minY = y;\\n\\t\\t\\t\\t\\tif ( x > maxX ) maxX = x;\\n\\t\\t\\t\\t\\tif ( y > maxY ) maxY = y;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// minX, minY and invSize are later used to transform coords into integers for z-order calculation\\n\\n\\t\\t\\t\\tinvSize = Math.max( maxX - minX, maxY - minY );\\n\\t\\t\\t\\tinvSize = invSize !== 0 ? 1 / invSize : 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tearcutLinked( outerNode, triangles, dim, minX, minY, invSize );\\n\\n\\t\\t\\treturn triangles;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t// create a circular doubly linked list from polygon points in the specified winding order\\n\\n\\tfunction linkedList( data, start, end, dim, clockwise ) {\\n\\n\\t\\tvar i, last;\\n\\n\\t\\tif ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {\\n\\n\\t\\t\\tfor ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tfor ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\\n\\n\\t\\t}\\n\\n\\t\\tif ( last && equals( last, last.next ) ) {\\n\\n\\t\\t\\tremoveNode( last );\\n\\t\\t\\tlast = last.next;\\n\\n\\t\\t}\\n\\n\\t\\treturn last;\\n\\n\\t}\\n\\n\\t// eliminate colinear or duplicate points\\n\\n\\tfunction filterPoints( start, end ) {\\n\\n\\t\\tif ( ! start ) return start;\\n\\t\\tif ( ! end ) end = start;\\n\\n\\t\\tvar p = start, again;\\n\\n\\t\\tdo {\\n\\n\\t\\t\\tagain = false;\\n\\n\\t\\t\\tif ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {\\n\\n\\t\\t\\t\\tremoveNode( p );\\n\\t\\t\\t\\tp = end = p.prev;\\n\\t\\t\\t\\tif ( p === p.next ) break;\\n\\t\\t\\t\\tagain = true;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tp = p.next;\\n\\n\\t\\t\\t}\\n\\n\\t\\t} while ( again || p !== end );\\n\\n\\t\\treturn end;\\n\\n\\t}\\n\\n\\t// main ear slicing loop which triangulates a polygon (given as a linked list)\\n\\n\\tfunction earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {\\n\\n\\t\\tif ( ! ear ) return;\\n\\n\\t\\t// interlink polygon nodes in z-order\\n\\n\\t\\tif ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );\\n\\n\\t\\tvar stop = ear, prev, next;\\n\\n\\t\\t// iterate through ears, slicing them one by one\\n\\n\\t\\twhile ( ear.prev !== ear.next ) {\\n\\n\\t\\t\\tprev = ear.prev;\\n\\t\\t\\tnext = ear.next;\\n\\n\\t\\t\\tif ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {\\n\\n\\t\\t\\t\\t// cut off the triangle\\n\\t\\t\\t\\ttriangles.push( prev.i / dim );\\n\\t\\t\\t\\ttriangles.push( ear.i / dim );\\n\\t\\t\\t\\ttriangles.push( next.i / dim );\\n\\n\\t\\t\\t\\tremoveNode( ear );\\n\\n\\t\\t\\t\\t// skipping the next vertice leads to less sliver triangles\\n\\t\\t\\t\\tear = next.next;\\n\\t\\t\\t\\tstop = next.next;\\n\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tear = next;\\n\\n\\t\\t\\t// if we looped through the whole remaining polygon and can't find any more ears\\n\\n\\t\\t\\tif ( ear === stop ) {\\n\\n\\t\\t\\t\\t// try filtering points and slicing again\\n\\n\\t\\t\\t\\tif ( ! pass ) {\\n\\n\\t\\t\\t\\t\\tearcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );\\n\\n\\t\\t\\t\\t\\t// if this didn't work, try curing all small self-intersections locally\\n\\n\\t\\t\\t\\t} else if ( pass === 1 ) {\\n\\n\\t\\t\\t\\t\\tear = cureLocalIntersections( ear, triangles, dim );\\n\\t\\t\\t\\t\\tearcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );\\n\\n\\t\\t\\t\\t// as a last resort, try splitting the remaining polygon into two\\n\\n\\t\\t\\t\\t} else if ( pass === 2 ) {\\n\\n\\t\\t\\t\\t\\tsplitEarcut( ear, triangles, dim, minX, minY, invSize );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// check whether a polygon node forms a valid ear with adjacent nodes\\n\\n\\tfunction isEar( ear ) {\\n\\n\\t\\tvar a = ear.prev,\\n\\t\\t\\tb = ear,\\n\\t\\t\\tc = ear.next;\\n\\n\\t\\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\\n\\n\\t\\t// now make sure we don't have other points inside the potential ear\\n\\t\\tvar p = ear.next.next;\\n\\n\\t\\twhile ( p !== ear.prev ) {\\n\\n\\t\\t\\tif ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) {\\n\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tp = p.next;\\n\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\n\\t}\\n\\n\\tfunction isEarHashed( ear, minX, minY, invSize ) {\\n\\n\\t\\tvar a = ear.prev,\\n\\t\\t\\tb = ear,\\n\\t\\t\\tc = ear.next;\\n\\n\\t\\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\\n\\n\\t\\t// triangle bbox; min & max are calculated like this for speed\\n\\n\\t\\tvar minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),\\n\\t\\t\\tminTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),\\n\\t\\t\\tmaxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),\\n\\t\\t\\tmaxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );\\n\\n\\t\\t// z-order range for the current triangle bbox;\\n\\n\\t\\tvar minZ = zOrder( minTX, minTY, minX, minY, invSize ),\\n\\t\\t\\tmaxZ = zOrder( maxTX, maxTY, minX, minY, invSize );\\n\\n\\t\\t// first look for points inside the triangle in increasing z-order\\n\\n\\t\\tvar p = ear.nextZ;\\n\\n\\t\\twhile ( p && p.z <= maxZ ) {\\n\\n\\t\\t\\tif ( p !== ear.prev && p !== ear.next &&\\n\\t\\t\\t\\t\\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\\n\\t\\t\\t\\t\\tarea( p.prev, p, p.next ) >= 0 ) return false;\\n\\t\\t\\tp = p.nextZ;\\n\\n\\t\\t}\\n\\n\\t\\t// then look for points in decreasing z-order\\n\\n\\t\\tp = ear.prevZ;\\n\\n\\t\\twhile ( p && p.z >= minZ ) {\\n\\n\\t\\t\\tif ( p !== ear.prev && p !== ear.next &&\\n\\t\\t\\t\\t\\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\\n\\t\\t\\t\\t\\tarea( p.prev, p, p.next ) >= 0 ) return false;\\n\\n\\t\\t\\tp = p.prevZ;\\n\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\n\\t}\\n\\n\\t// go through all polygon nodes and cure small local self-intersections\\n\\n\\tfunction cureLocalIntersections( start, triangles, dim ) {\\n\\n\\t\\tvar p = start;\\n\\n\\t\\tdo {\\n\\n\\t\\t\\tvar a = p.prev, b = p.next.next;\\n\\n\\t\\t\\tif ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {\\n\\n\\t\\t\\t\\ttriangles.push( a.i / dim );\\n\\t\\t\\t\\ttriangles.push( p.i / dim );\\n\\t\\t\\t\\ttriangles.push( b.i / dim );\\n\\n\\t\\t\\t\\t// remove two nodes involved\\n\\n\\t\\t\\t\\tremoveNode( p );\\n\\t\\t\\t\\tremoveNode( p.next );\\n\\n\\t\\t\\t\\tp = start = b;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tp = p.next;\\n\\n\\t\\t} while ( p !== start );\\n\\n\\t\\treturn p;\\n\\n\\t}\\n\\n\\t// try splitting polygon into two and triangulate them independently\\n\\n\\tfunction splitEarcut( start, triangles, dim, minX, minY, invSize ) {\\n\\n\\t\\t// look for a valid diagonal that divides the polygon into two\\n\\n\\t\\tvar a = start;\\n\\n\\t\\tdo {\\n\\n\\t\\t\\tvar b = a.next.next;\\n\\n\\t\\t\\twhile ( b !== a.prev ) {\\n\\n\\t\\t\\t\\tif ( a.i !== b.i && isValidDiagonal( a, b ) ) {\\n\\n\\t\\t\\t\\t\\t// split the polygon in two by the diagonal\\n\\n\\t\\t\\t\\t\\tvar c = splitPolygon( a, b );\\n\\n\\t\\t\\t\\t\\t// filter colinear points around the cuts\\n\\n\\t\\t\\t\\t\\ta = filterPoints( a, a.next );\\n\\t\\t\\t\\t\\tc = filterPoints( c, c.next );\\n\\n\\t\\t\\t\\t\\t// run earcut on each half\\n\\n\\t\\t\\t\\t\\tearcutLinked( a, triangles, dim, minX, minY, invSize );\\n\\t\\t\\t\\t\\tearcutLinked( c, triangles, dim, minX, minY, invSize );\\n\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tb = b.next;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\ta = a.next;\\n\\n\\t\\t} while ( a !== start );\\n\\n\\t}\\n\\n\\t// link every hole into the outer loop, producing a single-ring polygon without holes\\n\\n\\tfunction eliminateHoles( data, holeIndices, outerNode, dim ) {\\n\\n\\t\\tvar queue = [], i, len, start, end, list;\\n\\n\\t\\tfor ( i = 0, len = holeIndices.length; i < len; i ++ ) {\\n\\n\\t\\t\\tstart = holeIndices[ i ] * dim;\\n\\t\\t\\tend = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;\\n\\t\\t\\tlist = linkedList( data, start, end, dim, false );\\n\\t\\t\\tif ( list === list.next ) list.steiner = true;\\n\\t\\t\\tqueue.push( getLeftmost( list ) );\\n\\n\\t\\t}\\n\\n\\t\\tqueue.sort( compareX );\\n\\n\\t\\t// process holes from left to right\\n\\n\\t\\tfor ( i = 0; i < queue.length; i ++ ) {\\n\\n\\t\\t\\teliminateHole( queue[ i ], outerNode );\\n\\t\\t\\touterNode = filterPoints( outerNode, outerNode.next );\\n\\n\\t\\t}\\n\\n\\t\\treturn outerNode;\\n\\n\\t}\\n\\n\\tfunction compareX( a, b ) {\\n\\n\\t\\treturn a.x - b.x;\\n\\n\\t}\\n\\n\\t// find a bridge between vertices that connects hole with an outer ring and and link it\\n\\n\\tfunction eliminateHole( hole, outerNode ) {\\n\\n\\t\\touterNode = findHoleBridge( hole, outerNode );\\n\\n\\t\\tif ( outerNode ) {\\n\\n\\t\\t\\tvar b = splitPolygon( outerNode, hole );\\n\\n\\t\\t\\tfilterPoints( b, b.next );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// David Eberly's algorithm for finding a bridge between hole and outer polygon\\n\\n\\tfunction findHoleBridge( hole, outerNode ) {\\n\\n\\t\\tvar p = outerNode,\\n\\t\\t\\thx = hole.x,\\n\\t\\t\\thy = hole.y,\\n\\t\\t\\tqx = - Infinity,\\n\\t\\t\\tm;\\n\\n\\t\\t// find a segment intersected by a ray from the hole's leftmost point to the left;\\n\\t\\t// segment's endpoint with lesser x will be potential connection point\\n\\n\\t\\tdo {\\n\\n\\t\\t\\tif ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {\\n\\n\\t\\t\\t\\tvar x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );\\n\\n\\t\\t\\t\\tif ( x <= hx && x > qx ) {\\n\\n\\t\\t\\t\\t\\tqx = x;\\n\\n\\t\\t\\t\\t\\tif ( x === hx ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( hy === p.y ) return p;\\n\\t\\t\\t\\t\\t\\tif ( hy === p.next.y ) return p.next;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tm = p.x < p.next.x ? p : p.next;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tp = p.next;\\n\\n\\t\\t} while ( p !== outerNode );\\n\\n\\t\\tif ( ! m ) return null;\\n\\n\\t\\tif ( hx === qx ) return m.prev; // hole touches outer segment; pick lower endpoint\\n\\n\\t\\t// look for points inside the triangle of hole point, segment intersection and endpoint;\\n\\t\\t// if there are no points found, we have a valid connection;\\n\\t\\t// otherwise choose the point of the minimum angle with the ray as connection point\\n\\n\\t\\tvar stop = m,\\n\\t\\t\\tmx = m.x,\\n\\t\\t\\tmy = m.y,\\n\\t\\t\\ttanMin = Infinity,\\n\\t\\t\\ttan;\\n\\n\\t\\tp = m.next;\\n\\n\\t\\twhile ( p !== stop ) {\\n\\n\\t\\t\\tif ( hx >= p.x && p.x >= mx && hx !== p.x &&\\n\\t\\t\\t\\t\\t\\t\\tpointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {\\n\\n\\t\\t\\t\\ttan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential\\n\\n\\t\\t\\t\\tif ( ( tan < tanMin || ( tan === tanMin && p.x > m.x ) ) && locallyInside( p, hole ) ) {\\n\\n\\t\\t\\t\\t\\tm = p;\\n\\t\\t\\t\\t\\ttanMin = tan;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tp = p.next;\\n\\n\\t\\t}\\n\\n\\t\\treturn m;\\n\\n\\t}\\n\\n\\t// interlink polygon nodes in z-order\\n\\n\\tfunction indexCurve( start, minX, minY, invSize ) {\\n\\n\\t\\tvar p = start;\\n\\n\\t\\tdo {\\n\\n\\t\\t\\tif ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );\\n\\t\\t\\tp.prevZ = p.prev;\\n\\t\\t\\tp.nextZ = p.next;\\n\\t\\t\\tp = p.next;\\n\\n\\t\\t} while ( p !== start );\\n\\n\\t\\tp.prevZ.nextZ = null;\\n\\t\\tp.prevZ = null;\\n\\n\\t\\tsortLinked( p );\\n\\n\\t}\\n\\n\\t// Simon Tatham's linked list merge sort algorithm\\n\\t// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\\n\\n\\tfunction sortLinked( list ) {\\n\\n\\t\\tvar i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;\\n\\n\\t\\tdo {\\n\\n\\t\\t\\tp = list;\\n\\t\\t\\tlist = null;\\n\\t\\t\\ttail = null;\\n\\t\\t\\tnumMerges = 0;\\n\\n\\t\\t\\twhile ( p ) {\\n\\n\\t\\t\\t\\tnumMerges ++;\\n\\t\\t\\t\\tq = p;\\n\\t\\t\\t\\tpSize = 0;\\n\\n\\t\\t\\t\\tfor ( i = 0; i < inSize; i ++ ) {\\n\\n\\t\\t\\t\\t\\tpSize ++;\\n\\t\\t\\t\\t\\tq = q.nextZ;\\n\\t\\t\\t\\t\\tif ( ! q ) break;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tqSize = inSize;\\n\\n\\t\\t\\t\\twhile ( pSize > 0 || ( qSize > 0 && q ) ) {\\n\\n\\t\\t\\t\\t\\tif ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {\\n\\n\\t\\t\\t\\t\\t\\te = p;\\n\\t\\t\\t\\t\\t\\tp = p.nextZ;\\n\\t\\t\\t\\t\\t\\tpSize --;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\te = q;\\n\\t\\t\\t\\t\\t\\tq = q.nextZ;\\n\\t\\t\\t\\t\\t\\tqSize --;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( tail ) tail.nextZ = e;\\n\\t\\t\\t\\t\\telse list = e;\\n\\n\\t\\t\\t\\t\\te.prevZ = tail;\\n\\t\\t\\t\\t\\ttail = e;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tp = q;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\ttail.nextZ = null;\\n\\t\\t\\tinSize *= 2;\\n\\n\\t\\t} while ( numMerges > 1 );\\n\\n\\t\\treturn list;\\n\\n\\t}\\n\\n\\t// z-order of a point given coords and inverse of the longer side of data bbox\\n\\n\\tfunction zOrder( x, y, minX, minY, invSize ) {\\n\\n\\t\\t// coords are transformed into non-negative 15-bit integer range\\n\\n\\t\\tx = 32767 * ( x - minX ) * invSize;\\n\\t\\ty = 32767 * ( y - minY ) * invSize;\\n\\n\\t\\tx = ( x | ( x << 8 ) ) & 0x00FF00FF;\\n\\t\\tx = ( x | ( x << 4 ) ) & 0x0F0F0F0F;\\n\\t\\tx = ( x | ( x << 2 ) ) & 0x33333333;\\n\\t\\tx = ( x | ( x << 1 ) ) & 0x55555555;\\n\\n\\t\\ty = ( y | ( y << 8 ) ) & 0x00FF00FF;\\n\\t\\ty = ( y | ( y << 4 ) ) & 0x0F0F0F0F;\\n\\t\\ty = ( y | ( y << 2 ) ) & 0x33333333;\\n\\t\\ty = ( y | ( y << 1 ) ) & 0x55555555;\\n\\n\\t\\treturn x | ( y << 1 );\\n\\n\\t}\\n\\n\\t// find the leftmost node of a polygon ring\\n\\n\\tfunction getLeftmost( start ) {\\n\\n\\t\\tvar p = start, leftmost = start;\\n\\n\\t\\tdo {\\n\\n\\t\\t\\tif ( p.x < leftmost.x ) leftmost = p;\\n\\t\\t\\tp = p.next;\\n\\n\\t\\t} while ( p !== start );\\n\\n\\t\\treturn leftmost;\\n\\n\\t}\\n\\n\\t// check if a point lies within a convex triangle\\n\\n\\tfunction pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {\\n\\n\\t\\treturn ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&\\n\\t\\t ( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&\\n\\t\\t ( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;\\n\\n\\t}\\n\\n\\t// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\\n\\n\\tfunction isValidDiagonal( a, b ) {\\n\\n\\t\\treturn a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) &&\\n\\t\\t\\tlocallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b );\\n\\n\\t}\\n\\n\\t// signed area of a triangle\\n\\n\\tfunction area( p, q, r ) {\\n\\n\\t\\treturn ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );\\n\\n\\t}\\n\\n\\t// check if two points are equal\\n\\n\\tfunction equals( p1, p2 ) {\\n\\n\\t\\treturn p1.x === p2.x && p1.y === p2.y;\\n\\n\\t}\\n\\n\\t// check if two segments intersect\\n\\n\\tfunction intersects( p1, q1, p2, q2 ) {\\n\\n\\t\\tif ( ( equals( p1, q1 ) && equals( p2, q2 ) ) ||\\n\\t\\t\\t\\t( equals( p1, q2 ) && equals( p2, q1 ) ) ) return true;\\n\\n\\t\\treturn area( p1, q1, p2 ) > 0 !== area( p1, q1, q2 ) > 0 &&\\n\\t\\t\\t\\t\\t area( p2, q2, p1 ) > 0 !== area( p2, q2, q1 ) > 0;\\n\\n\\t}\\n\\n\\t// check if a polygon diagonal intersects any polygon segments\\n\\n\\tfunction intersectsPolygon( a, b ) {\\n\\n\\t\\tvar p = a;\\n\\n\\t\\tdo {\\n\\n\\t\\t\\tif ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\\n\\t\\t\\t\\t\\t\\t\\tintersects( p, p.next, a, b ) ) {\\n\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tp = p.next;\\n\\n\\t\\t} while ( p !== a );\\n\\n\\t\\treturn false;\\n\\n\\t}\\n\\n\\t// check if a polygon diagonal is locally inside the polygon\\n\\n\\tfunction locallyInside( a, b ) {\\n\\n\\t\\treturn area( a.prev, a, a.next ) < 0 ?\\n\\t\\t\\tarea( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :\\n\\t\\t\\tarea( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;\\n\\n\\t}\\n\\n\\t// check if the middle point of a polygon diagonal is inside the polygon\\n\\n\\tfunction middleInside( a, b ) {\\n\\n\\t\\tvar p = a,\\n\\t\\t\\tinside = false,\\n\\t\\t\\tpx = ( a.x + b.x ) / 2,\\n\\t\\t\\tpy = ( a.y + b.y ) / 2;\\n\\n\\t\\tdo {\\n\\n\\t\\t\\tif ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&\\n\\t\\t\\t\\t\\t\\t\\t( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) ) {\\n\\n\\t\\t\\t\\tinside = ! inside;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tp = p.next;\\n\\n\\t\\t} while ( p !== a );\\n\\n\\t\\treturn inside;\\n\\n\\t}\\n\\n\\t// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\\n\\t// if one belongs to the outer ring and another to a hole, it merges it into a single ring\\n\\n\\tfunction splitPolygon( a, b ) {\\n\\n\\t\\tvar a2 = new Node( a.i, a.x, a.y ),\\n\\t\\t\\tb2 = new Node( b.i, b.x, b.y ),\\n\\t\\t\\tan = a.next,\\n\\t\\t\\tbp = b.prev;\\n\\n\\t\\ta.next = b;\\n\\t\\tb.prev = a;\\n\\n\\t\\ta2.next = an;\\n\\t\\tan.prev = a2;\\n\\n\\t\\tb2.next = a2;\\n\\t\\ta2.prev = b2;\\n\\n\\t\\tbp.next = b2;\\n\\t\\tb2.prev = bp;\\n\\n\\t\\treturn b2;\\n\\n\\t}\\n\\n\\t// create a node and optionally link it with previous one (in a circular doubly linked list)\\n\\n\\tfunction insertNode( i, x, y, last ) {\\n\\n\\t\\tvar p = new Node( i, x, y );\\n\\n\\t\\tif ( ! last ) {\\n\\n\\t\\t\\tp.prev = p;\\n\\t\\t\\tp.next = p;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tp.next = last.next;\\n\\t\\t\\tp.prev = last;\\n\\t\\t\\tlast.next.prev = p;\\n\\t\\t\\tlast.next = p;\\n\\n\\t\\t}\\n\\n\\t\\treturn p;\\n\\n\\t}\\n\\n\\tfunction removeNode( p ) {\\n\\n\\t\\tp.next.prev = p.prev;\\n\\t\\tp.prev.next = p.next;\\n\\n\\t\\tif ( p.prevZ ) p.prevZ.nextZ = p.nextZ;\\n\\t\\tif ( p.nextZ ) p.nextZ.prevZ = p.prevZ;\\n\\n\\t}\\n\\n\\tfunction Node( i, x, y ) {\\n\\n\\t\\t// vertice index in coordinates array\\n\\t\\tthis.i = i;\\n\\n\\t\\t// vertex coordinates\\n\\t\\tthis.x = x;\\n\\t\\tthis.y = y;\\n\\n\\t\\t// previous and next vertice nodes in a polygon ring\\n\\t\\tthis.prev = null;\\n\\t\\tthis.next = null;\\n\\n\\t\\t// z-order curve value\\n\\t\\tthis.z = null;\\n\\n\\t\\t// previous and next nodes in z-order\\n\\t\\tthis.prevZ = null;\\n\\t\\tthis.nextZ = null;\\n\\n\\t\\t// indicates whether this is a steiner point\\n\\t\\tthis.steiner = false;\\n\\n\\t}\\n\\n\\tfunction signedArea( data, start, end, dim ) {\\n\\n\\t\\tvar sum = 0;\\n\\n\\t\\tfor ( var i = start, j = end - dim; i < end; i += dim ) {\\n\\n\\t\\t\\tsum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );\\n\\t\\t\\tj = i;\\n\\n\\t\\t}\\n\\n\\t\\treturn sum;\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t */\\n\\n\\tvar ShapeUtils = {\\n\\n\\t\\t// calculate area of the contour polygon\\n\\n\\t\\tarea: function ( contour ) {\\n\\n\\t\\t\\tvar n = contour.length;\\n\\t\\t\\tvar a = 0.0;\\n\\n\\t\\t\\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\\n\\n\\t\\t\\t\\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn a * 0.5;\\n\\n\\t\\t},\\n\\n\\t\\tisClockWise: function ( pts ) {\\n\\n\\t\\t\\treturn ShapeUtils.area( pts ) < 0;\\n\\n\\t\\t},\\n\\n\\t\\ttriangulateShape: function ( contour, holes ) {\\n\\n\\t\\t\\tfunction removeDupEndPts( points ) {\\n\\n\\t\\t\\t\\tvar l = points.length;\\n\\n\\t\\t\\t\\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\\n\\n\\t\\t\\t\\t\\tpoints.pop();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction addContour( vertices, contour ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < contour.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvertices.push( contour[ i ].x );\\n\\t\\t\\t\\t\\tvertices.push( contour[ i ].y );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\\n\\t\\t\\tvar holeIndices = []; // array of hole indices\\n\\t\\t\\tvar faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\\n\\n\\t\\t\\tremoveDupEndPts( contour );\\n\\t\\t\\taddContour( vertices, contour );\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar holeIndex = contour.length;\\n\\t\\t\\tholes.forEach( removeDupEndPts );\\n\\n\\t\\t\\tfor ( i = 0; i < holes.length; i ++ ) {\\n\\n\\t\\t\\t\\tholeIndices.push( holeIndex );\\n\\t\\t\\t\\tholeIndex += holes[ i ].length;\\n\\t\\t\\t\\taddContour( vertices, holes[ i ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar triangles = Earcut.triangulate( vertices, holeIndices );\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tfor ( var i = 0; i < triangles.length; i += 3 ) {\\n\\n\\t\\t\\t\\tfaces.push( triangles.slice( i, i + 3 ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn faces;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t *\\n\\t * Creates extruded geometry from a path shape.\\n\\t *\\n\\t * parameters = {\\n\\t *\\n\\t *  curveSegments: <int>, // number of points on the curves\\n\\t *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\\n\\t *  amount: <int>, // Depth to extrude the shape\\n\\t *\\n\\t *  bevelEnabled: <bool>, // turn on bevel\\n\\t *  bevelThickness: <float>, // how deep into the original shape bevel goes\\n\\t *  bevelSize: <float>, // how far from shape outline is bevel\\n\\t *  bevelSegments: <int>, // number of bevel layers\\n\\t *\\n\\t *  extrudePath: <THREE.Curve> // curve to extrude shape along\\n\\t *  frames: <Object> // containing arrays of tangents, normals, binormals\\n\\t *\\n\\t *  UVGenerator: <Object> // object that provides UV generator functions\\n\\t *\\n\\t * }\\n\\t */\\n\\n\\t// ExtrudeGeometry\\n\\n\\tfunction ExtrudeGeometry( shapes, options ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'ExtrudeGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tshapes: shapes,\\n\\t\\t\\toptions: options\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tExtrudeGeometry.prototype = Object.create( Geometry.prototype );\\n\\tExtrudeGeometry.prototype.constructor = ExtrudeGeometry;\\n\\n\\t// ExtrudeBufferGeometry\\n\\n\\tfunction ExtrudeBufferGeometry( shapes, options ) {\\n\\n\\t\\tif ( typeof ( shapes ) === \\\"undefined\\\" ) {\\n\\n\\t\\t\\treturn;\\n\\n\\t\\t}\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'ExtrudeBufferGeometry';\\n\\n\\t\\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\\n\\n\\t\\tthis.addShapeList( shapes, options );\\n\\n\\t\\tthis.computeVertexNormals();\\n\\n\\t\\t// can't really use automatic vertex normals\\n\\t\\t// as then front and back sides get smoothed too\\n\\t\\t// should do separate smoothing just for sides\\n\\n\\t\\t//this.computeVertexNormals();\\n\\n\\t\\t//console.log( \\\"took\\\", ( Date.now() - startTime ) );\\n\\n\\t}\\n\\n\\tExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;\\n\\n\\tExtrudeBufferGeometry.prototype.getArrays = function () {\\n\\n\\t\\tvar positionAttribute = this.getAttribute( \\\"position\\\" );\\n\\t\\tvar verticesArray = positionAttribute ? Array.prototype.slice.call( positionAttribute.array ) : [];\\n\\n\\t\\tvar uvAttribute = this.getAttribute( \\\"uv\\\" );\\n\\t\\tvar uvArray = uvAttribute ? Array.prototype.slice.call( uvAttribute.array ) : [];\\n\\n\\t\\tvar IndexAttribute = this.index;\\n\\t\\tvar indicesArray = IndexAttribute ? Array.prototype.slice.call( IndexAttribute.array ) : [];\\n\\n\\t\\treturn {\\n\\t\\t\\tposition: verticesArray,\\n\\t\\t\\tuv: uvArray,\\n\\t\\t\\tindex: indicesArray\\n\\t\\t};\\n\\n\\t};\\n\\n\\tExtrudeBufferGeometry.prototype.addShapeList = function ( shapes, options ) {\\n\\n\\t\\tvar sl = shapes.length;\\n\\t\\toptions.arrays = this.getArrays();\\n\\n\\t\\tfor ( var s = 0; s < sl; s ++ ) {\\n\\n\\t\\t\\tvar shape = shapes[ s ];\\n\\t\\t\\tthis.addShape( shape, options );\\n\\n\\t\\t}\\n\\n\\t\\tthis.setIndex( options.arrays.index );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( options.arrays.position, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( options.arrays.uv, 2 ) );\\n\\n\\t};\\n\\n\\tExtrudeBufferGeometry.prototype.addShape = function ( shape, options ) {\\n\\n\\t\\tvar arrays = options.arrays ? options.arrays : this.getArrays();\\n\\t\\tvar verticesArray = arrays.position;\\n\\t\\tvar indicesArray = arrays.index;\\n\\t\\tvar uvArray = arrays.uv;\\n\\n\\t\\tvar placeholder = [];\\n\\n\\n\\t\\tvar amount = options.amount !== undefined ? options.amount : 100;\\n\\n\\t\\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\\n\\t\\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\\n\\t\\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\\n\\n\\t\\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\\n\\n\\t\\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\\n\\n\\t\\tvar steps = options.steps !== undefined ? options.steps : 1;\\n\\n\\t\\tvar extrudePath = options.extrudePath;\\n\\t\\tvar extrudePts, extrudeByPath = false;\\n\\n\\t\\t// Use default WorldUVGenerator if no UV generators are specified.\\n\\t\\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;\\n\\n\\t\\tvar splineTube, binormal, normal, position2;\\n\\t\\tif ( extrudePath ) {\\n\\n\\t\\t\\textrudePts = extrudePath.getSpacedPoints( steps );\\n\\n\\t\\t\\textrudeByPath = true;\\n\\t\\t\\tbevelEnabled = false; // bevels not supported for path extrusion\\n\\n\\t\\t\\t// SETUP TNB variables\\n\\n\\t\\t\\t// TODO1 - have a .isClosed in spline?\\n\\n\\t\\t\\tsplineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );\\n\\n\\t\\t\\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\\n\\n\\t\\t\\tbinormal = new Vector3();\\n\\t\\t\\tnormal = new Vector3();\\n\\t\\t\\tposition2 = new Vector3();\\n\\n\\t\\t}\\n\\n\\t\\t// Safeguards if bevels are not enabled\\n\\n\\t\\tif ( ! bevelEnabled ) {\\n\\n\\t\\t\\tbevelSegments = 0;\\n\\t\\t\\tbevelThickness = 0;\\n\\t\\t\\tbevelSize = 0;\\n\\n\\t\\t}\\n\\n\\t\\t// Variables initialization\\n\\n\\t\\tvar ahole, h, hl; // looping of holes\\n\\t\\tvar scope = this;\\n\\n\\t\\tvar shapePoints = shape.extractPoints( curveSegments );\\n\\n\\t\\tvar vertices = shapePoints.shape;\\n\\t\\tvar holes = shapePoints.holes;\\n\\n\\t\\tvar reverse = ! ShapeUtils.isClockWise( vertices );\\n\\n\\t\\tif ( reverse ) {\\n\\n\\t\\t\\tvertices = vertices.reverse();\\n\\n\\t\\t\\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\\n\\n\\t\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\n\\n\\t\\t\\t\\tahole = holes[ h ];\\n\\n\\t\\t\\t\\tif ( ShapeUtils.isClockWise( ahole ) ) {\\n\\n\\t\\t\\t\\t\\tholes[ h ] = ahole.reverse();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\n\\t\\tvar faces = ShapeUtils.triangulateShape( vertices, holes );\\n\\n\\t\\t/* Vertices */\\n\\n\\t\\tvar contour = vertices; // vertices has all points but contour has only points of circumference\\n\\n\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\n\\n\\t\\t\\tahole = holes[ h ];\\n\\n\\t\\t\\tvertices = vertices.concat( ahole );\\n\\n\\t\\t}\\n\\n\\n\\t\\tfunction scalePt2( pt, vec, size ) {\\n\\n\\t\\t\\tif ( ! vec ) console.error( \\\"THREE.ExtrudeGeometry: vec does not exist\\\" );\\n\\n\\t\\t\\treturn vec.clone().multiplyScalar( size ).add( pt );\\n\\n\\t\\t}\\n\\n\\t\\tvar b, bs, t, z,\\n\\t\\t\\tvert, vlen = vertices.length,\\n\\t\\t\\tface, flen = faces.length;\\n\\n\\n\\t\\t// Find directions for point movement\\n\\n\\n\\t\\tfunction getBevelVec( inPt, inPrev, inNext ) {\\n\\n\\t\\t\\t// computes for inPt the corresponding point inPt' on a new contour\\n\\t\\t\\t//   shifted by 1 unit (length of normalized vector) to the left\\n\\t\\t\\t// if we walk along contour clockwise, this new contour is outside the old one\\n\\t\\t\\t//\\n\\t\\t\\t// inPt' is the intersection of the two lines parallel to the two\\n\\t\\t\\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\\n\\n\\t\\t\\tvar v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\\n\\n\\t\\t\\t// good reading for geometry algorithms (here: line-line intersection)\\n\\t\\t\\t// http://geomalgorithms.com/a05-_intersect-1.html\\n\\n\\t\\t\\tvar v_prev_x = inPt.x - inPrev.x,\\n\\t\\t\\t\\tv_prev_y = inPt.y - inPrev.y;\\n\\t\\t\\tvar v_next_x = inNext.x - inPt.x,\\n\\t\\t\\t\\tv_next_y = inNext.y - inPt.y;\\n\\n\\t\\t\\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\\n\\n\\t\\t\\t// check for collinear edges\\n\\t\\t\\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\\n\\n\\t\\t\\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\\n\\n\\t\\t\\t\\t// not collinear\\n\\n\\t\\t\\t\\t// length of vectors for normalizing\\n\\n\\t\\t\\t\\tvar v_prev_len = Math.sqrt( v_prev_lensq );\\n\\t\\t\\t\\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\\n\\n\\t\\t\\t\\t// shift adjacent points by unit vectors to the left\\n\\n\\t\\t\\t\\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\\n\\t\\t\\t\\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\\n\\n\\t\\t\\t\\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\\n\\t\\t\\t\\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\\n\\n\\t\\t\\t\\t// scaling factor for v_prev to intersection point\\n\\n\\t\\t\\t\\tvar sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\\n\\t\\t\\t\\t\\t\\t( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /\\n\\t\\t\\t\\t\\t( v_prev_x * v_next_y - v_prev_y * v_next_x );\\n\\n\\t\\t\\t\\t// vector from inPt to intersection point\\n\\n\\t\\t\\t\\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\\n\\t\\t\\t\\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\\n\\n\\t\\t\\t\\t// Don't normalize!, otherwise sharp corners become ugly\\n\\t\\t\\t\\t//  but prevent crazy spikes\\n\\t\\t\\t\\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\\n\\t\\t\\t\\tif ( v_trans_lensq <= 2 ) {\\n\\n\\t\\t\\t\\t\\treturn new Vector2( v_trans_x, v_trans_y );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// handle special case of collinear edges\\n\\n\\t\\t\\t\\tvar direction_eq = false; // assumes: opposite\\n\\t\\t\\t\\tif ( v_prev_x > Number.EPSILON ) {\\n\\n\\t\\t\\t\\t\\tif ( v_next_x > Number.EPSILON ) {\\n\\n\\t\\t\\t\\t\\t\\tdirection_eq = true;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tif ( v_prev_x < - Number.EPSILON ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( v_next_x < - Number.EPSILON ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tdirection_eq = true;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tdirection_eq = true;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( direction_eq ) {\\n\\n\\t\\t\\t\\t\\t// console.log(\\\"Warning: lines are a straight sequence\\\");\\n\\t\\t\\t\\t\\tv_trans_x = - v_prev_y;\\n\\t\\t\\t\\t\\tv_trans_y = v_prev_x;\\n\\t\\t\\t\\t\\tshrink_by = Math.sqrt( v_prev_lensq );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// console.log(\\\"Warning: lines are a straight spike\\\");\\n\\t\\t\\t\\t\\tv_trans_x = v_prev_x;\\n\\t\\t\\t\\t\\tv_trans_y = v_prev_y;\\n\\t\\t\\t\\t\\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\\n\\n\\t\\t}\\n\\n\\n\\t\\tvar contourMovements = [];\\n\\n\\t\\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\\n\\n\\t\\t\\tif ( j === il ) j = 0;\\n\\t\\t\\tif ( k === il ) k = 0;\\n\\n\\t\\t\\t//  (j)---(i)---(k)\\n\\t\\t\\t// console.log('i,j,k', i, j , k)\\n\\n\\t\\t\\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\\n\\n\\t\\t}\\n\\n\\t\\tvar holesMovements = [],\\n\\t\\t\\toneHoleMovements, verticesMovements = contourMovements.concat();\\n\\n\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\n\\n\\t\\t\\tahole = holes[ h ];\\n\\n\\t\\t\\toneHoleMovements = [];\\n\\n\\t\\t\\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\\n\\n\\t\\t\\t\\tif ( j === il ) j = 0;\\n\\t\\t\\t\\tif ( k === il ) k = 0;\\n\\n\\t\\t\\t\\t//  (j)---(i)---(k)\\n\\t\\t\\t\\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tholesMovements.push( oneHoleMovements );\\n\\t\\t\\tverticesMovements = verticesMovements.concat( oneHoleMovements );\\n\\n\\t\\t}\\n\\n\\n\\t\\t// Loop bevelSegments, 1 for the front, 1 for the back\\n\\n\\t\\tfor ( b = 0; b < bevelSegments; b ++ ) {\\n\\n\\t\\t\\t//for ( b = bevelSegments; b > 0; b -- ) {\\n\\n\\t\\t\\tt = b / bevelSegments;\\n\\t\\t\\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\\n\\t\\t\\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\\n\\n\\t\\t\\t// contract shape\\n\\n\\t\\t\\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\\n\\n\\t\\t\\t\\tv( vert.x, vert.y, - z );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// expand holes\\n\\n\\t\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\n\\n\\t\\t\\t\\tahole = holes[ h ];\\n\\t\\t\\t\\toneHoleMovements = holesMovements[ h ];\\n\\n\\t\\t\\t\\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\\n\\n\\t\\t\\t\\t\\tv( vert.x, vert.y, - z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tbs = bevelSize;\\n\\n\\t\\t// Back facing vertices\\n\\n\\t\\tfor ( i = 0; i < vlen; i ++ ) {\\n\\n\\t\\t\\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\\n\\n\\t\\t\\tif ( ! extrudeByPath ) {\\n\\n\\t\\t\\t\\tv( vert.x, vert.y, 0 );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\\n\\n\\t\\t\\t\\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\\n\\t\\t\\t\\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\\n\\n\\t\\t\\t\\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\\n\\n\\t\\t\\t\\tv( position2.x, position2.y, position2.z );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// Add stepped vertices...\\n\\t\\t// Including front facing vertices\\n\\n\\t\\tvar s;\\n\\n\\t\\tfor ( s = 1; s <= steps; s ++ ) {\\n\\n\\t\\t\\tfor ( i = 0; i < vlen; i ++ ) {\\n\\n\\t\\t\\t\\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\\n\\n\\t\\t\\t\\tif ( ! extrudeByPath ) {\\n\\n\\t\\t\\t\\t\\tv( vert.x, vert.y, amount / steps * s );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\\n\\n\\t\\t\\t\\t\\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\\n\\t\\t\\t\\t\\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\\n\\n\\t\\t\\t\\t\\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\\n\\n\\t\\t\\t\\t\\tv( position2.x, position2.y, position2.z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\n\\t\\t// Add bevel segments planes\\n\\n\\t\\t//for ( b = 1; b <= bevelSegments; b ++ ) {\\n\\t\\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\\n\\n\\t\\t\\tt = b / bevelSegments;\\n\\t\\t\\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\\n\\t\\t\\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\\n\\n\\t\\t\\t// contract shape\\n\\n\\t\\t\\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\\n\\t\\t\\t\\tv( vert.x, vert.y, amount + z );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// expand holes\\n\\n\\t\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\n\\n\\t\\t\\t\\tahole = holes[ h ];\\n\\t\\t\\t\\toneHoleMovements = holesMovements[ h ];\\n\\n\\t\\t\\t\\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\\n\\n\\t\\t\\t\\t\\tif ( ! extrudeByPath ) {\\n\\n\\t\\t\\t\\t\\t\\tv( vert.x, vert.y, amount + z );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t/* Faces */\\n\\n\\t\\t// Top and bottom faces\\n\\n\\t\\tbuildLidFaces();\\n\\n\\t\\t// Sides faces\\n\\n\\t\\tbuildSideFaces();\\n\\n\\n\\t\\t/////  Internal functions\\n\\n\\t\\tfunction buildLidFaces() {\\n\\n\\t\\t\\tvar start = verticesArray.length / 3;\\n\\n\\t\\t\\tif ( bevelEnabled ) {\\n\\n\\t\\t\\t\\tvar layer = 0; // steps + 1\\n\\t\\t\\t\\tvar offset = vlen * layer;\\n\\n\\t\\t\\t\\t// Bottom faces\\n\\n\\t\\t\\t\\tfor ( i = 0; i < flen; i ++ ) {\\n\\n\\t\\t\\t\\t\\tface = faces[ i ];\\n\\t\\t\\t\\t\\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tlayer = steps + bevelSegments * 2;\\n\\t\\t\\t\\toffset = vlen * layer;\\n\\n\\t\\t\\t\\t// Top faces\\n\\n\\t\\t\\t\\tfor ( i = 0; i < flen; i ++ ) {\\n\\n\\t\\t\\t\\t\\tface = faces[ i ];\\n\\t\\t\\t\\t\\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Bottom faces\\n\\n\\t\\t\\t\\tfor ( i = 0; i < flen; i ++ ) {\\n\\n\\t\\t\\t\\t\\tface = faces[ i ];\\n\\t\\t\\t\\t\\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Top faces\\n\\n\\t\\t\\t\\tfor ( i = 0; i < flen; i ++ ) {\\n\\n\\t\\t\\t\\t\\tface = faces[ i ];\\n\\t\\t\\t\\t\\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tscope.addGroup( start, verticesArray.length / 3 - start, options.material !== undefined ? options.material : 0 );\\n\\n\\t\\t}\\n\\n\\t\\t// Create faces for the z-sides of the shape\\n\\n\\t\\tfunction buildSideFaces() {\\n\\n\\t\\t\\tvar start = verticesArray.length / 3;\\n\\t\\t\\tvar layeroffset = 0;\\n\\t\\t\\tsidewalls( contour, layeroffset );\\n\\t\\t\\tlayeroffset += contour.length;\\n\\n\\t\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\n\\n\\t\\t\\t\\tahole = holes[ h ];\\n\\t\\t\\t\\tsidewalls( ahole, layeroffset );\\n\\n\\t\\t\\t\\t//, true\\n\\t\\t\\t\\tlayeroffset += ahole.length;\\n\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\tscope.addGroup( start, verticesArray.length / 3 - start, options.extrudeMaterial !== undefined ? options.extrudeMaterial : 1 );\\n\\n\\n\\t\\t}\\n\\n\\t\\tfunction sidewalls( contour, layeroffset ) {\\n\\n\\t\\t\\tvar j, k;\\n\\t\\t\\ti = contour.length;\\n\\n\\t\\t\\twhile ( -- i >= 0 ) {\\n\\n\\t\\t\\t\\tj = i;\\n\\t\\t\\t\\tk = i - 1;\\n\\t\\t\\t\\tif ( k < 0 ) k = contour.length - 1;\\n\\n\\t\\t\\t\\t//console.log('b', i,j, i-1, k,vertices.length);\\n\\n\\t\\t\\t\\tvar s = 0,\\n\\t\\t\\t\\t\\tsl = steps + bevelSegments * 2;\\n\\n\\t\\t\\t\\tfor ( s = 0; s < sl; s ++ ) {\\n\\n\\t\\t\\t\\t\\tvar slen1 = vlen * s;\\n\\t\\t\\t\\t\\tvar slen2 = vlen * ( s + 1 );\\n\\n\\t\\t\\t\\t\\tvar a = layeroffset + j + slen1,\\n\\t\\t\\t\\t\\t\\tb = layeroffset + k + slen1,\\n\\t\\t\\t\\t\\t\\tc = layeroffset + k + slen2,\\n\\t\\t\\t\\t\\t\\td = layeroffset + j + slen2;\\n\\n\\t\\t\\t\\t\\tf4( a, b, c, d );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction v( x, y, z ) {\\n\\n\\t\\t\\tplaceholder.push( x );\\n\\t\\t\\tplaceholder.push( y );\\n\\t\\t\\tplaceholder.push( z );\\n\\n\\t\\t}\\n\\n\\n\\t\\tfunction f3( a, b, c ) {\\n\\n\\t\\t\\taddVertex( a );\\n\\t\\t\\taddVertex( b );\\n\\t\\t\\taddVertex( c );\\n\\n\\t\\t\\tvar nextIndex = verticesArray.length / 3;\\n\\t\\t\\tvar uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\\n\\n\\t\\t\\taddUV( uvs[ 0 ] );\\n\\t\\t\\taddUV( uvs[ 1 ] );\\n\\t\\t\\taddUV( uvs[ 2 ] );\\n\\n\\t\\t}\\n\\n\\t\\tfunction f4( a, b, c, d ) {\\n\\n\\t\\t\\taddVertex( a );\\n\\t\\t\\taddVertex( b );\\n\\t\\t\\taddVertex( d );\\n\\n\\t\\t\\taddVertex( b );\\n\\t\\t\\taddVertex( c );\\n\\t\\t\\taddVertex( d );\\n\\n\\n\\t\\t\\tvar nextIndex = verticesArray.length / 3;\\n\\t\\t\\tvar uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\\n\\n\\t\\t\\taddUV( uvs[ 0 ] );\\n\\t\\t\\taddUV( uvs[ 1 ] );\\n\\t\\t\\taddUV( uvs[ 3 ] );\\n\\n\\t\\t\\taddUV( uvs[ 1 ] );\\n\\t\\t\\taddUV( uvs[ 2 ] );\\n\\t\\t\\taddUV( uvs[ 3 ] );\\n\\n\\t\\t}\\n\\n\\t\\tfunction addVertex( index ) {\\n\\n\\t\\t\\tindicesArray.push( verticesArray.length / 3 );\\n\\t\\t\\tverticesArray.push( placeholder[ index * 3 + 0 ] );\\n\\t\\t\\tverticesArray.push( placeholder[ index * 3 + 1 ] );\\n\\t\\t\\tverticesArray.push( placeholder[ index * 3 + 2 ] );\\n\\n\\t\\t}\\n\\n\\n\\t\\tfunction addUV( vector2 ) {\\n\\n\\t\\t\\tuvArray.push( vector2.x );\\n\\t\\t\\tuvArray.push( vector2.y );\\n\\n\\t\\t}\\n\\n\\t\\tif ( ! options.arrays ) {\\n\\n\\t\\t\\tthis.setIndex( indicesArray );\\n\\t\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );\\n\\t\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tExtrudeGeometry.WorldUVGenerator = {\\n\\n\\t\\tgenerateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {\\n\\n\\t\\t\\tvar a_x = vertices[ indexA * 3 ];\\n\\t\\t\\tvar a_y = vertices[ indexA * 3 + 1 ];\\n\\t\\t\\tvar b_x = vertices[ indexB * 3 ];\\n\\t\\t\\tvar b_y = vertices[ indexB * 3 + 1 ];\\n\\t\\t\\tvar c_x = vertices[ indexC * 3 ];\\n\\t\\t\\tvar c_y = vertices[ indexC * 3 + 1 ];\\n\\n\\t\\t\\treturn [\\n\\t\\t\\t\\tnew Vector2( a_x, a_y ),\\n\\t\\t\\t\\tnew Vector2( b_x, b_y ),\\n\\t\\t\\t\\tnew Vector2( c_x, c_y )\\n\\t\\t\\t];\\n\\n\\t\\t},\\n\\n\\t\\tgenerateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {\\n\\n\\t\\t\\tvar a_x = vertices[ indexA * 3 ];\\n\\t\\t\\tvar a_y = vertices[ indexA * 3 + 1 ];\\n\\t\\t\\tvar a_z = vertices[ indexA * 3 + 2 ];\\n\\t\\t\\tvar b_x = vertices[ indexB * 3 ];\\n\\t\\t\\tvar b_y = vertices[ indexB * 3 + 1 ];\\n\\t\\t\\tvar b_z = vertices[ indexB * 3 + 2 ];\\n\\t\\t\\tvar c_x = vertices[ indexC * 3 ];\\n\\t\\t\\tvar c_y = vertices[ indexC * 3 + 1 ];\\n\\t\\t\\tvar c_z = vertices[ indexC * 3 + 2 ];\\n\\t\\t\\tvar d_x = vertices[ indexD * 3 ];\\n\\t\\t\\tvar d_y = vertices[ indexD * 3 + 1 ];\\n\\t\\t\\tvar d_z = vertices[ indexD * 3 + 2 ];\\n\\n\\t\\t\\tif ( Math.abs( a_y - b_y ) < 0.01 ) {\\n\\n\\t\\t\\t\\treturn [\\n\\t\\t\\t\\t\\tnew Vector2( a_x, 1 - a_z ),\\n\\t\\t\\t\\t\\tnew Vector2( b_x, 1 - b_z ),\\n\\t\\t\\t\\t\\tnew Vector2( c_x, 1 - c_z ),\\n\\t\\t\\t\\t\\tnew Vector2( d_x, 1 - d_z )\\n\\t\\t\\t\\t];\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\treturn [\\n\\t\\t\\t\\t\\tnew Vector2( a_y, 1 - a_z ),\\n\\t\\t\\t\\t\\tnew Vector2( b_y, 1 - b_z ),\\n\\t\\t\\t\\t\\tnew Vector2( c_y, 1 - c_z ),\\n\\t\\t\\t\\t\\tnew Vector2( d_y, 1 - d_z )\\n\\t\\t\\t\\t];\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t *\\n\\t * Text = 3D Text\\n\\t *\\n\\t * parameters = {\\n\\t *  font: <THREE.Font>, // font\\n\\t *\\n\\t *  size: <float>, // size of the text\\n\\t *  height: <float>, // thickness to extrude text\\n\\t *  curveSegments: <int>, // number of points on the curves\\n\\t *\\n\\t *  bevelEnabled: <bool>, // turn on bevel\\n\\t *  bevelThickness: <float>, // how deep into text bevel goes\\n\\t *  bevelSize: <float> // how far from text outline is bevel\\n\\t * }\\n\\t */\\n\\n\\t// TextGeometry\\n\\n\\tfunction TextGeometry( text, parameters ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'TextGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\ttext: text,\\n\\t\\t\\tparameters: parameters\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tTextGeometry.prototype = Object.create( Geometry.prototype );\\n\\tTextGeometry.prototype.constructor = TextGeometry;\\n\\n\\t// TextBufferGeometry\\n\\n\\tfunction TextBufferGeometry( text, parameters ) {\\n\\n\\t\\tparameters = parameters || {};\\n\\n\\t\\tvar font = parameters.font;\\n\\n\\t\\tif ( ! ( font && font.isFont ) ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\\n\\t\\t\\treturn new Geometry();\\n\\n\\t\\t}\\n\\n\\t\\tvar shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\\n\\n\\t\\t// translate parameters to ExtrudeGeometry API\\n\\n\\t\\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\\n\\n\\t\\t// defaults\\n\\n\\t\\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\\n\\t\\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\\n\\t\\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\\n\\n\\t\\tExtrudeBufferGeometry.call( this, shapes, parameters );\\n\\n\\t\\tthis.type = 'TextBufferGeometry';\\n\\n\\t}\\n\\n\\tTextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype );\\n\\tTextBufferGeometry.prototype.constructor = TextBufferGeometry;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author benaadams / https://twitter.com/ben_a_adams\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// SphereGeometry\\n\\n\\tfunction SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'SphereGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\twidthSegments: widthSegments,\\n\\t\\t\\theightSegments: heightSegments,\\n\\t\\t\\tphiStart: phiStart,\\n\\t\\t\\tphiLength: phiLength,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tSphereGeometry.prototype = Object.create( Geometry.prototype );\\n\\tSphereGeometry.prototype.constructor = SphereGeometry;\\n\\n\\t// SphereBufferGeometry\\n\\n\\tfunction SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'SphereBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\twidthSegments: widthSegments,\\n\\t\\t\\theightSegments: heightSegments,\\n\\t\\t\\tphiStart: phiStart,\\n\\t\\t\\tphiLength: phiLength,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t\\tradius = radius || 1;\\n\\n\\t\\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\\n\\t\\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\\n\\n\\t\\tphiStart = phiStart !== undefined ? phiStart : 0;\\n\\t\\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\\n\\n\\t\\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\\n\\t\\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\\n\\n\\t\\tvar thetaEnd = thetaStart + thetaLength;\\n\\n\\t\\tvar ix, iy;\\n\\n\\t\\tvar index = 0;\\n\\t\\tvar grid = [];\\n\\n\\t\\tvar vertex = new Vector3();\\n\\t\\tvar normal = new Vector3();\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// generate vertices, normals and uvs\\n\\n\\t\\tfor ( iy = 0; iy <= heightSegments; iy ++ ) {\\n\\n\\t\\t\\tvar verticesRow = [];\\n\\n\\t\\t\\tvar v = iy / heightSegments;\\n\\n\\t\\t\\tfor ( ix = 0; ix <= widthSegments; ix ++ ) {\\n\\n\\t\\t\\t\\tvar u = ix / widthSegments;\\n\\n\\t\\t\\t\\t// vertex\\n\\n\\t\\t\\t\\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\\n\\t\\t\\t\\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\\n\\t\\t\\t\\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\\n\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t// normal\\n\\n\\t\\t\\t\\tnormal.set( vertex.x, vertex.y, vertex.z ).normalize();\\n\\t\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\n\\n\\t\\t\\t\\t// uv\\n\\n\\t\\t\\t\\tuvs.push( u, 1 - v );\\n\\n\\t\\t\\t\\tverticesRow.push( index ++ );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tgrid.push( verticesRow );\\n\\n\\t\\t}\\n\\n\\t\\t// indices\\n\\n\\t\\tfor ( iy = 0; iy < heightSegments; iy ++ ) {\\n\\n\\t\\t\\tfor ( ix = 0; ix < widthSegments; ix ++ ) {\\n\\n\\t\\t\\t\\tvar a = grid[ iy ][ ix + 1 ];\\n\\t\\t\\t\\tvar b = grid[ iy ][ ix ];\\n\\t\\t\\t\\tvar c = grid[ iy + 1 ][ ix ];\\n\\t\\t\\t\\tvar d = grid[ iy + 1 ][ ix + 1 ];\\n\\n\\t\\t\\t\\tif ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );\\n\\t\\t\\t\\tif ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t}\\n\\n\\tSphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tSphereBufferGeometry.prototype.constructor = SphereBufferGeometry;\\n\\n\\t/**\\n\\t * @author Kaleb Murphy\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// RingGeometry\\n\\n\\tfunction RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'RingGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tinnerRadius: innerRadius,\\n\\t\\t\\touterRadius: outerRadius,\\n\\t\\t\\tthetaSegments: thetaSegments,\\n\\t\\t\\tphiSegments: phiSegments,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tRingGeometry.prototype = Object.create( Geometry.prototype );\\n\\tRingGeometry.prototype.constructor = RingGeometry;\\n\\n\\t// RingBufferGeometry\\n\\n\\tfunction RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'RingBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tinnerRadius: innerRadius,\\n\\t\\t\\touterRadius: outerRadius,\\n\\t\\t\\tthetaSegments: thetaSegments,\\n\\t\\t\\tphiSegments: phiSegments,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t\\tinnerRadius = innerRadius || 0.5;\\n\\t\\touterRadius = outerRadius || 1;\\n\\n\\t\\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\\n\\t\\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\\n\\n\\t\\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\\n\\t\\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// some helper variables\\n\\n\\t\\tvar segment;\\n\\t\\tvar radius = innerRadius;\\n\\t\\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\\n\\t\\tvar vertex = new Vector3();\\n\\t\\tvar uv = new Vector2();\\n\\t\\tvar j, i;\\n\\n\\t\\t// generate vertices, normals and uvs\\n\\n\\t\\tfor ( j = 0; j <= phiSegments; j ++ ) {\\n\\n\\t\\t\\tfor ( i = 0; i <= thetaSegments; i ++ ) {\\n\\n\\t\\t\\t\\t// values are generate from the inside of the ring to the outside\\n\\n\\t\\t\\t\\tsegment = thetaStart + i / thetaSegments * thetaLength;\\n\\n\\t\\t\\t\\t// vertex\\n\\n\\t\\t\\t\\tvertex.x = radius * Math.cos( segment );\\n\\t\\t\\t\\tvertex.y = radius * Math.sin( segment );\\n\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t// normal\\n\\n\\t\\t\\t\\tnormals.push( 0, 0, 1 );\\n\\n\\t\\t\\t\\t// uv\\n\\n\\t\\t\\t\\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\\n\\t\\t\\t\\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\\n\\n\\t\\t\\t\\tuvs.push( uv.x, uv.y );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// increase the radius for next row of vertices\\n\\n\\t\\t\\tradius += radiusStep;\\n\\n\\t\\t}\\n\\n\\t\\t// indices\\n\\n\\t\\tfor ( j = 0; j < phiSegments; j ++ ) {\\n\\n\\t\\t\\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\\n\\n\\t\\t\\tfor ( i = 0; i < thetaSegments; i ++ ) {\\n\\n\\t\\t\\t\\tsegment = i + thetaSegmentLevel;\\n\\n\\t\\t\\t\\tvar a = segment;\\n\\t\\t\\t\\tvar b = segment + thetaSegments + 1;\\n\\t\\t\\t\\tvar c = segment + thetaSegments + 2;\\n\\t\\t\\t\\tvar d = segment + 1;\\n\\n\\t\\t\\t\\t// faces\\n\\n\\t\\t\\t\\tindices.push( a, b, d );\\n\\t\\t\\t\\tindices.push( b, c, d );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t}\\n\\n\\tRingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tRingBufferGeometry.prototype.constructor = RingBufferGeometry;\\n\\n\\t/**\\n\\t * @author astrodud / http://astrodud.isgreat.org/\\n\\t * @author zz85 / https://github.com/zz85\\n\\t * @author bhouston / http://clara.io\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// LatheGeometry\\n\\n\\tfunction LatheGeometry( points, segments, phiStart, phiLength ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'LatheGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tpoints: points,\\n\\t\\t\\tsegments: segments,\\n\\t\\t\\tphiStart: phiStart,\\n\\t\\t\\tphiLength: phiLength\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tLatheGeometry.prototype = Object.create( Geometry.prototype );\\n\\tLatheGeometry.prototype.constructor = LatheGeometry;\\n\\n\\t// LatheBufferGeometry\\n\\n\\tfunction LatheBufferGeometry( points, segments, phiStart, phiLength ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'LatheBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tpoints: points,\\n\\t\\t\\tsegments: segments,\\n\\t\\t\\tphiStart: phiStart,\\n\\t\\t\\tphiLength: phiLength\\n\\t\\t};\\n\\n\\t\\tsegments = Math.floor( segments ) || 12;\\n\\t\\tphiStart = phiStart || 0;\\n\\t\\tphiLength = phiLength || Math.PI * 2;\\n\\n\\t\\t// clamp phiLength so it's in range of [ 0, 2PI ]\\n\\n\\t\\tphiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );\\n\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar base;\\n\\t\\tvar inverseSegments = 1.0 / segments;\\n\\t\\tvar vertex = new Vector3();\\n\\t\\tvar uv = new Vector2();\\n\\t\\tvar i, j;\\n\\n\\t\\t// generate vertices and uvs\\n\\n\\t\\tfor ( i = 0; i <= segments; i ++ ) {\\n\\n\\t\\t\\tvar phi = phiStart + i * inverseSegments * phiLength;\\n\\n\\t\\t\\tvar sin = Math.sin( phi );\\n\\t\\t\\tvar cos = Math.cos( phi );\\n\\n\\t\\t\\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\\n\\n\\t\\t\\t\\t// vertex\\n\\n\\t\\t\\t\\tvertex.x = points[ j ].x * sin;\\n\\t\\t\\t\\tvertex.y = points[ j ].y;\\n\\t\\t\\t\\tvertex.z = points[ j ].x * cos;\\n\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t// uv\\n\\n\\t\\t\\t\\tuv.x = i / segments;\\n\\t\\t\\t\\tuv.y = j / ( points.length - 1 );\\n\\n\\t\\t\\t\\tuvs.push( uv.x, uv.y );\\n\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// indices\\n\\n\\t\\tfor ( i = 0; i < segments; i ++ ) {\\n\\n\\t\\t\\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\\n\\n\\t\\t\\t\\tbase = j + i * points.length;\\n\\n\\t\\t\\t\\tvar a = base;\\n\\t\\t\\t\\tvar b = base + points.length;\\n\\t\\t\\t\\tvar c = base + points.length + 1;\\n\\t\\t\\t\\tvar d = base + 1;\\n\\n\\t\\t\\t\\t// faces\\n\\n\\t\\t\\t\\tindices.push( a, b, d );\\n\\t\\t\\t\\tindices.push( b, c, d );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t\\t// generate normals\\n\\n\\t\\tthis.computeVertexNormals();\\n\\n\\t\\t// if the geometry is closed, we need to average the normals along the seam.\\n\\t\\t// because the corresponding vertices are identical (but still have different UVs).\\n\\n\\t\\tif ( phiLength === Math.PI * 2 ) {\\n\\n\\t\\t\\tvar normals = this.attributes.normal.array;\\n\\t\\t\\tvar n1 = new Vector3();\\n\\t\\t\\tvar n2 = new Vector3();\\n\\t\\t\\tvar n = new Vector3();\\n\\n\\t\\t\\t// this is the buffer offset for the last line of vertices\\n\\n\\t\\t\\tbase = segments * points.length * 3;\\n\\n\\t\\t\\tfor ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\\n\\n\\t\\t\\t\\t// select the normal of the vertex in the first line\\n\\n\\t\\t\\t\\tn1.x = normals[ j + 0 ];\\n\\t\\t\\t\\tn1.y = normals[ j + 1 ];\\n\\t\\t\\t\\tn1.z = normals[ j + 2 ];\\n\\n\\t\\t\\t\\t// select the normal of the vertex in the last line\\n\\n\\t\\t\\t\\tn2.x = normals[ base + j + 0 ];\\n\\t\\t\\t\\tn2.y = normals[ base + j + 1 ];\\n\\t\\t\\t\\tn2.z = normals[ base + j + 2 ];\\n\\n\\t\\t\\t\\t// average normals\\n\\n\\t\\t\\t\\tn.addVectors( n1, n2 ).normalize();\\n\\n\\t\\t\\t\\t// assign the new values to both normals\\n\\n\\t\\t\\t\\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\\n\\t\\t\\t\\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\\n\\t\\t\\t\\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tLatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tLatheBufferGeometry.prototype.constructor = LatheBufferGeometry;\\n\\n\\t/**\\n\\t * @author jonobr1 / http://jonobr1.com\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// ShapeGeometry\\n\\n\\tfunction ShapeGeometry( shapes, curveSegments ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'ShapeGeometry';\\n\\n\\t\\tif ( typeof curveSegments === 'object' ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );\\n\\n\\t\\t\\tcurveSegments = curveSegments.curveSegments;\\n\\n\\t\\t}\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tshapes: shapes,\\n\\t\\t\\tcurveSegments: curveSegments\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tShapeGeometry.prototype = Object.create( Geometry.prototype );\\n\\tShapeGeometry.prototype.constructor = ShapeGeometry;\\n\\n\\tShapeGeometry.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Geometry.prototype.toJSON.call( this );\\n\\n\\t\\tvar shapes = this.parameters.shapes;\\n\\n\\t\\treturn toJSON( shapes, data );\\n\\n\\t};\\n\\n\\t// ShapeBufferGeometry\\n\\n\\tfunction ShapeBufferGeometry( shapes, curveSegments ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'ShapeBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tshapes: shapes,\\n\\t\\t\\tcurveSegments: curveSegments\\n\\t\\t};\\n\\n\\t\\tcurveSegments = curveSegments || 12;\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar groupStart = 0;\\n\\t\\tvar groupCount = 0;\\n\\n\\t\\t// allow single and array values for \\\"shapes\\\" parameter\\n\\n\\t\\tif ( Array.isArray( shapes ) === false ) {\\n\\n\\t\\t\\taddShape( shapes );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tfor ( var i = 0; i < shapes.length; i ++ ) {\\n\\n\\t\\t\\t\\taddShape( shapes[ i ] );\\n\\n\\t\\t\\t\\tthis.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support\\n\\n\\t\\t\\t\\tgroupStart += groupCount;\\n\\t\\t\\t\\tgroupCount = 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\n\\t\\t// helper functions\\n\\n\\t\\tfunction addShape( shape ) {\\n\\n\\t\\t\\tvar i, l, shapeHole;\\n\\n\\t\\t\\tvar indexOffset = vertices.length / 3;\\n\\t\\t\\tvar points = shape.extractPoints( curveSegments );\\n\\n\\t\\t\\tvar shapeVertices = points.shape;\\n\\t\\t\\tvar shapeHoles = points.holes;\\n\\n\\t\\t\\t// check direction of vertices\\n\\n\\t\\t\\tif ( ShapeUtils.isClockWise( shapeVertices ) === false ) {\\n\\n\\t\\t\\t\\tshapeVertices = shapeVertices.reverse();\\n\\n\\t\\t\\t\\t// also check if holes are in the opposite direction\\n\\n\\t\\t\\t\\tfor ( i = 0, l = shapeHoles.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tshapeHole = shapeHoles[ i ];\\n\\n\\t\\t\\t\\t\\tif ( ShapeUtils.isClockWise( shapeHole ) === true ) {\\n\\n\\t\\t\\t\\t\\t\\tshapeHoles[ i ] = shapeHole.reverse();\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );\\n\\n\\t\\t\\t// join vertices of inner and outer paths to a single array\\n\\n\\t\\t\\tfor ( i = 0, l = shapeHoles.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tshapeHole = shapeHoles[ i ];\\n\\t\\t\\t\\tshapeVertices = shapeVertices.concat( shapeHole );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// vertices, normals, uvs\\n\\n\\t\\t\\tfor ( i = 0, l = shapeVertices.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar vertex = shapeVertices[ i ];\\n\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, 0 );\\n\\t\\t\\t\\tnormals.push( 0, 0, 1 );\\n\\t\\t\\t\\tuvs.push( vertex.x, vertex.y ); // world uvs\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// incides\\n\\n\\t\\t\\tfor ( i = 0, l = faces.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar face = faces[ i ];\\n\\n\\t\\t\\t\\tvar a = face[ 0 ] + indexOffset;\\n\\t\\t\\t\\tvar b = face[ 1 ] + indexOffset;\\n\\t\\t\\t\\tvar c = face[ 2 ] + indexOffset;\\n\\n\\t\\t\\t\\tindices.push( a, b, c );\\n\\t\\t\\t\\tgroupCount += 3;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;\\n\\n\\tShapeBufferGeometry.prototype.toJSON = function () {\\n\\n\\t\\tvar data = BufferGeometry.prototype.toJSON.call( this );\\n\\n\\t\\tvar shapes = this.parameters.shapes;\\n\\n\\t\\treturn toJSON( shapes, data );\\n\\n\\t};\\n\\n\\t//\\n\\n\\tfunction toJSON( shapes, data ) {\\n\\n\\t\\tdata.shapes = [];\\n\\n\\t\\tif ( Array.isArray( shapes ) ) {\\n\\n\\t\\t\\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar shape = shapes[ i ];\\n\\n\\t\\t\\t\\tdata.shapes.push( shape.uuid );\\n\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tdata.shapes.push( shapes.uuid );\\n\\n\\t\\t}\\n\\n\\t\\treturn data;\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\tfunction EdgesGeometry( geometry, thresholdAngle ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'EdgesGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tthresholdAngle: thresholdAngle\\n\\t\\t};\\n\\n\\t\\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\\n\\n\\t\\t// buffer\\n\\n\\t\\tvar vertices = [];\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );\\n\\t\\tvar edge = [ 0, 0 ], edges = {}, edge1, edge2;\\n\\t\\tvar key, keys = [ 'a', 'b', 'c' ];\\n\\n\\t\\t// prepare source geometry\\n\\n\\t\\tvar geometry2;\\n\\n\\t\\tif ( geometry.isBufferGeometry ) {\\n\\n\\t\\t\\tgeometry2 = new Geometry();\\n\\t\\t\\tgeometry2.fromBufferGeometry( geometry );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tgeometry2 = geometry.clone();\\n\\n\\t\\t}\\n\\n\\t\\tgeometry2.mergeVertices();\\n\\t\\tgeometry2.computeFaceNormals();\\n\\n\\t\\tvar sourceVertices = geometry2.vertices;\\n\\t\\tvar faces = geometry2.faces;\\n\\n\\t\\t// now create a data structure where each entry represents an edge with its adjoining faces\\n\\n\\t\\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\\n\\n\\t\\t\\tvar face = faces[ i ];\\n\\n\\t\\t\\tfor ( var j = 0; j < 3; j ++ ) {\\n\\n\\t\\t\\t\\tedge1 = face[ keys[ j ] ];\\n\\t\\t\\t\\tedge2 = face[ keys[ ( j + 1 ) % 3 ] ];\\n\\t\\t\\t\\tedge[ 0 ] = Math.min( edge1, edge2 );\\n\\t\\t\\t\\tedge[ 1 ] = Math.max( edge1, edge2 );\\n\\n\\t\\t\\t\\tkey = edge[ 0 ] + ',' + edge[ 1 ];\\n\\n\\t\\t\\t\\tif ( edges[ key ] === undefined ) {\\n\\n\\t\\t\\t\\t\\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tedges[ key ].face2 = i;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// generate vertices\\n\\n\\t\\tfor ( key in edges ) {\\n\\n\\t\\t\\tvar e = edges[ key ];\\n\\n\\t\\t\\t// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.\\n\\n\\t\\t\\tif ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {\\n\\n\\t\\t\\t\\tvar vertex = sourceVertices[ e.index1 ];\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\tvertex = sourceVertices[ e.index2 ];\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\n\\t}\\n\\n\\tEdgesGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tEdgesGeometry.prototype.constructor = EdgesGeometry;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// CylinderGeometry\\n\\n\\tfunction CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'CylinderGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradiusTop: radiusTop,\\n\\t\\t\\tradiusBottom: radiusBottom,\\n\\t\\t\\theight: height,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\theightSegments: heightSegments,\\n\\t\\t\\topenEnded: openEnded,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tCylinderGeometry.prototype = Object.create( Geometry.prototype );\\n\\tCylinderGeometry.prototype.constructor = CylinderGeometry;\\n\\n\\t// CylinderBufferGeometry\\n\\n\\tfunction CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'CylinderBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradiusTop: radiusTop,\\n\\t\\t\\tradiusBottom: radiusBottom,\\n\\t\\t\\theight: height,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\theightSegments: heightSegments,\\n\\t\\t\\topenEnded: openEnded,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\tradiusTop = radiusTop !== undefined ? radiusTop : 1;\\n\\t\\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 1;\\n\\t\\theight = height || 1;\\n\\n\\t\\tradialSegments = Math.floor( radialSegments ) || 8;\\n\\t\\theightSegments = Math.floor( heightSegments ) || 1;\\n\\n\\t\\topenEnded = openEnded !== undefined ? openEnded : false;\\n\\t\\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\\n\\t\\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar index = 0;\\n\\t\\tvar indexArray = [];\\n\\t\\tvar halfHeight = height / 2;\\n\\t\\tvar groupStart = 0;\\n\\n\\t\\t// generate geometry\\n\\n\\t\\tgenerateTorso();\\n\\n\\t\\tif ( openEnded === false ) {\\n\\n\\t\\t\\tif ( radiusTop > 0 ) generateCap( true );\\n\\t\\t\\tif ( radiusBottom > 0 ) generateCap( false );\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t\\tfunction generateTorso() {\\n\\n\\t\\t\\tvar x, y;\\n\\t\\t\\tvar normal = new Vector3();\\n\\t\\t\\tvar vertex = new Vector3();\\n\\n\\t\\t\\tvar groupCount = 0;\\n\\n\\t\\t\\t// this will be used to calculate the normal\\n\\t\\t\\tvar slope = ( radiusBottom - radiusTop ) / height;\\n\\n\\t\\t\\t// generate vertices, normals and uvs\\n\\n\\t\\t\\tfor ( y = 0; y <= heightSegments; y ++ ) {\\n\\n\\t\\t\\t\\tvar indexRow = [];\\n\\n\\t\\t\\t\\tvar v = y / heightSegments;\\n\\n\\t\\t\\t\\t// calculate the radius of the current row\\n\\n\\t\\t\\t\\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\\n\\n\\t\\t\\t\\tfor ( x = 0; x <= radialSegments; x ++ ) {\\n\\n\\t\\t\\t\\t\\tvar u = x / radialSegments;\\n\\n\\t\\t\\t\\t\\tvar theta = u * thetaLength + thetaStart;\\n\\n\\t\\t\\t\\t\\tvar sinTheta = Math.sin( theta );\\n\\t\\t\\t\\t\\tvar cosTheta = Math.cos( theta );\\n\\n\\t\\t\\t\\t\\t// vertex\\n\\n\\t\\t\\t\\t\\tvertex.x = radius * sinTheta;\\n\\t\\t\\t\\t\\tvertex.y = - v * height + halfHeight;\\n\\t\\t\\t\\t\\tvertex.z = radius * cosTheta;\\n\\t\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t\\t// normal\\n\\n\\t\\t\\t\\t\\tnormal.set( sinTheta, slope, cosTheta ).normalize();\\n\\t\\t\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\n\\n\\t\\t\\t\\t\\t// uv\\n\\n\\t\\t\\t\\t\\tuvs.push( u, 1 - v );\\n\\n\\t\\t\\t\\t\\t// save index of vertex in respective row\\n\\n\\t\\t\\t\\t\\tindexRow.push( index ++ );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// now save vertices of the row in our index array\\n\\n\\t\\t\\t\\tindexArray.push( indexRow );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// generate indices\\n\\n\\t\\t\\tfor ( x = 0; x < radialSegments; x ++ ) {\\n\\n\\t\\t\\t\\tfor ( y = 0; y < heightSegments; y ++ ) {\\n\\n\\t\\t\\t\\t\\t// we use the index array to access the correct indices\\n\\n\\t\\t\\t\\t\\tvar a = indexArray[ y ][ x ];\\n\\t\\t\\t\\t\\tvar b = indexArray[ y + 1 ][ x ];\\n\\t\\t\\t\\t\\tvar c = indexArray[ y + 1 ][ x + 1 ];\\n\\t\\t\\t\\t\\tvar d = indexArray[ y ][ x + 1 ];\\n\\n\\t\\t\\t\\t\\t// faces\\n\\n\\t\\t\\t\\t\\tindices.push( a, b, d );\\n\\t\\t\\t\\t\\tindices.push( b, c, d );\\n\\n\\t\\t\\t\\t\\t// update group counter\\n\\n\\t\\t\\t\\t\\tgroupCount += 6;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// add a group to the geometry. this will ensure multi material support\\n\\n\\t\\t\\tscope.addGroup( groupStart, groupCount, 0 );\\n\\n\\t\\t\\t// calculate new start value for groups\\n\\n\\t\\t\\tgroupStart += groupCount;\\n\\n\\t\\t}\\n\\n\\t\\tfunction generateCap( top ) {\\n\\n\\t\\t\\tvar x, centerIndexStart, centerIndexEnd;\\n\\n\\t\\t\\tvar uv = new Vector2();\\n\\t\\t\\tvar vertex = new Vector3();\\n\\n\\t\\t\\tvar groupCount = 0;\\n\\n\\t\\t\\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\\n\\t\\t\\tvar sign = ( top === true ) ? 1 : - 1;\\n\\n\\t\\t\\t// save the index of the first center vertex\\n\\t\\t\\tcenterIndexStart = index;\\n\\n\\t\\t\\t// first we generate the center vertex data of the cap.\\n\\t\\t\\t// because the geometry needs one set of uvs per face,\\n\\t\\t\\t// we must generate a center vertex per face/segment\\n\\n\\t\\t\\tfor ( x = 1; x <= radialSegments; x ++ ) {\\n\\n\\t\\t\\t\\t// vertex\\n\\n\\t\\t\\t\\tvertices.push( 0, halfHeight * sign, 0 );\\n\\n\\t\\t\\t\\t// normal\\n\\n\\t\\t\\t\\tnormals.push( 0, sign, 0 );\\n\\n\\t\\t\\t\\t// uv\\n\\n\\t\\t\\t\\tuvs.push( 0.5, 0.5 );\\n\\n\\t\\t\\t\\t// increase index\\n\\n\\t\\t\\t\\tindex ++;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// save the index of the last center vertex\\n\\n\\t\\t\\tcenterIndexEnd = index;\\n\\n\\t\\t\\t// now we generate the surrounding vertices, normals and uvs\\n\\n\\t\\t\\tfor ( x = 0; x <= radialSegments; x ++ ) {\\n\\n\\t\\t\\t\\tvar u = x / radialSegments;\\n\\t\\t\\t\\tvar theta = u * thetaLength + thetaStart;\\n\\n\\t\\t\\t\\tvar cosTheta = Math.cos( theta );\\n\\t\\t\\t\\tvar sinTheta = Math.sin( theta );\\n\\n\\t\\t\\t\\t// vertex\\n\\n\\t\\t\\t\\tvertex.x = radius * sinTheta;\\n\\t\\t\\t\\tvertex.y = halfHeight * sign;\\n\\t\\t\\t\\tvertex.z = radius * cosTheta;\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t// normal\\n\\n\\t\\t\\t\\tnormals.push( 0, sign, 0 );\\n\\n\\t\\t\\t\\t// uv\\n\\n\\t\\t\\t\\tuv.x = ( cosTheta * 0.5 ) + 0.5;\\n\\t\\t\\t\\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\\n\\t\\t\\t\\tuvs.push( uv.x, uv.y );\\n\\n\\t\\t\\t\\t// increase index\\n\\n\\t\\t\\t\\tindex ++;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// generate indices\\n\\n\\t\\t\\tfor ( x = 0; x < radialSegments; x ++ ) {\\n\\n\\t\\t\\t\\tvar c = centerIndexStart + x;\\n\\t\\t\\t\\tvar i = centerIndexEnd + x;\\n\\n\\t\\t\\t\\tif ( top === true ) {\\n\\n\\t\\t\\t\\t\\t// face top\\n\\n\\t\\t\\t\\t\\tindices.push( i, i + 1, c );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// face bottom\\n\\n\\t\\t\\t\\t\\tindices.push( i + 1, i, c );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgroupCount += 3;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// add a group to the geometry. this will ensure multi material support\\n\\n\\t\\t\\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\\n\\n\\t\\t\\t// calculate new start value for groups\\n\\n\\t\\t\\tgroupStart += groupCount;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tCylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tCylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;\\n\\n\\t/**\\n\\t * @author abelnation / http://github.com/abelnation\\n\\t */\\n\\n\\t// ConeGeometry\\n\\n\\tfunction ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\\n\\n\\t\\tCylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\\n\\n\\t\\tthis.type = 'ConeGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\theight: height,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\theightSegments: heightSegments,\\n\\t\\t\\topenEnded: openEnded,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t}\\n\\n\\tConeGeometry.prototype = Object.create( CylinderGeometry.prototype );\\n\\tConeGeometry.prototype.constructor = ConeGeometry;\\n\\n\\t// ConeBufferGeometry\\n\\n\\tfunction ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\\n\\n\\t\\tCylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\\n\\n\\t\\tthis.type = 'ConeBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\theight: height,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\theightSegments: heightSegments,\\n\\t\\t\\topenEnded: openEnded,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t}\\n\\n\\tConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );\\n\\tConeBufferGeometry.prototype.constructor = ConeBufferGeometry;\\n\\n\\t/**\\n\\t * @author benaadams / https://twitter.com/ben_a_adams\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t * @author hughes\\n\\t */\\n\\n\\t// CircleGeometry\\n\\n\\tfunction CircleGeometry( radius, segments, thetaStart, thetaLength ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'CircleGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tsegments: segments,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tCircleGeometry.prototype = Object.create( Geometry.prototype );\\n\\tCircleGeometry.prototype.constructor = CircleGeometry;\\n\\n\\t// CircleBufferGeometry\\n\\n\\tfunction CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'CircleBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tsegments: segments,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t\\tradius = radius || 1;\\n\\t\\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\\n\\n\\t\\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\\n\\t\\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar i, s;\\n\\t\\tvar vertex = new Vector3();\\n\\t\\tvar uv = new Vector2();\\n\\n\\t\\t// center point\\n\\n\\t\\tvertices.push( 0, 0, 0 );\\n\\t\\tnormals.push( 0, 0, 1 );\\n\\t\\tuvs.push( 0.5, 0.5 );\\n\\n\\t\\tfor ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {\\n\\n\\t\\t\\tvar segment = thetaStart + s / segments * thetaLength;\\n\\n\\t\\t\\t// vertex\\n\\n\\t\\t\\tvertex.x = radius * Math.cos( segment );\\n\\t\\t\\tvertex.y = radius * Math.sin( segment );\\n\\n\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t// normal\\n\\n\\t\\t\\tnormals.push( 0, 0, 1 );\\n\\n\\t\\t\\t// uvs\\n\\n\\t\\t\\tuv.x = ( vertices[ i ] / radius + 1 ) / 2;\\n\\t\\t\\tuv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;\\n\\n\\t\\t\\tuvs.push( uv.x, uv.y );\\n\\n\\t\\t}\\n\\n\\t\\t// indices\\n\\n\\t\\tfor ( i = 1; i <= segments; i ++ ) {\\n\\n\\t\\t\\tindices.push( i, i + 1, 0 );\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t}\\n\\n\\tCircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tCircleBufferGeometry.prototype.constructor = CircleBufferGeometry;\\n\\n\\n\\n\\tvar Geometries = Object.freeze({\\n\\t\\tWireframeGeometry: WireframeGeometry,\\n\\t\\tParametricGeometry: ParametricGeometry,\\n\\t\\tParametricBufferGeometry: ParametricBufferGeometry,\\n\\t\\tTetrahedronGeometry: TetrahedronGeometry,\\n\\t\\tTetrahedronBufferGeometry: TetrahedronBufferGeometry,\\n\\t\\tOctahedronGeometry: OctahedronGeometry,\\n\\t\\tOctahedronBufferGeometry: OctahedronBufferGeometry,\\n\\t\\tIcosahedronGeometry: IcosahedronGeometry,\\n\\t\\tIcosahedronBufferGeometry: IcosahedronBufferGeometry,\\n\\t\\tDodecahedronGeometry: DodecahedronGeometry,\\n\\t\\tDodecahedronBufferGeometry: DodecahedronBufferGeometry,\\n\\t\\tPolyhedronGeometry: PolyhedronGeometry,\\n\\t\\tPolyhedronBufferGeometry: PolyhedronBufferGeometry,\\n\\t\\tTubeGeometry: TubeGeometry,\\n\\t\\tTubeBufferGeometry: TubeBufferGeometry,\\n\\t\\tTorusKnotGeometry: TorusKnotGeometry,\\n\\t\\tTorusKnotBufferGeometry: TorusKnotBufferGeometry,\\n\\t\\tTorusGeometry: TorusGeometry,\\n\\t\\tTorusBufferGeometry: TorusBufferGeometry,\\n\\t\\tTextGeometry: TextGeometry,\\n\\t\\tTextBufferGeometry: TextBufferGeometry,\\n\\t\\tSphereGeometry: SphereGeometry,\\n\\t\\tSphereBufferGeometry: SphereBufferGeometry,\\n\\t\\tRingGeometry: RingGeometry,\\n\\t\\tRingBufferGeometry: RingBufferGeometry,\\n\\t\\tPlaneGeometry: PlaneGeometry,\\n\\t\\tPlaneBufferGeometry: PlaneBufferGeometry,\\n\\t\\tLatheGeometry: LatheGeometry,\\n\\t\\tLatheBufferGeometry: LatheBufferGeometry,\\n\\t\\tShapeGeometry: ShapeGeometry,\\n\\t\\tShapeBufferGeometry: ShapeBufferGeometry,\\n\\t\\tExtrudeGeometry: ExtrudeGeometry,\\n\\t\\tExtrudeBufferGeometry: ExtrudeBufferGeometry,\\n\\t\\tEdgesGeometry: EdgesGeometry,\\n\\t\\tConeGeometry: ConeGeometry,\\n\\t\\tConeBufferGeometry: ConeBufferGeometry,\\n\\t\\tCylinderGeometry: CylinderGeometry,\\n\\t\\tCylinderBufferGeometry: CylinderBufferGeometry,\\n\\t\\tCircleGeometry: CircleGeometry,\\n\\t\\tCircleBufferGeometry: CircleBufferGeometry,\\n\\t\\tBoxGeometry: BoxGeometry,\\n\\t\\tBoxBufferGeometry: BoxBufferGeometry\\n\\t});\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t *\\n\\t * parameters = {\\n\\t *  color: <THREE.Color>,\\n\\t *  opacity: <float>\\n\\t * }\\n\\t */\\n\\n\\tfunction ShadowMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'ShadowMaterial';\\n\\n\\t\\tthis.color = new Color( 0x000000 );\\n\\t\\tthis.opacity = 1.0;\\n\\n\\t\\tthis.lights = true;\\n\\t\\tthis.transparent = true;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tShadowMaterial.prototype = Object.create( Material.prototype );\\n\\tShadowMaterial.prototype.constructor = ShadowMaterial;\\n\\n\\tShadowMaterial.prototype.isShadowMaterial = true;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction RawShaderMaterial( parameters ) {\\n\\n\\t\\tShaderMaterial.call( this, parameters );\\n\\n\\t\\tthis.type = 'RawShaderMaterial';\\n\\n\\t}\\n\\n\\tRawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );\\n\\tRawShaderMaterial.prototype.constructor = RawShaderMaterial;\\n\\n\\tRawShaderMaterial.prototype.isRawShaderMaterial = true;\\n\\n\\t/**\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t *\\n\\t * parameters = {\\n\\t *  color: <hex>,\\n\\t *  roughness: <float>,\\n\\t *  metalness: <float>,\\n\\t *  opacity: <float>,\\n\\t *\\n\\t *  map: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  lightMap: new THREE.Texture( <Image> ),\\n\\t *  lightMapIntensity: <float>\\n\\t *\\n\\t *  aoMap: new THREE.Texture( <Image> ),\\n\\t *  aoMapIntensity: <float>\\n\\t *\\n\\t *  emissive: <hex>,\\n\\t *  emissiveIntensity: <float>\\n\\t *  emissiveMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  bumpMap: new THREE.Texture( <Image> ),\\n\\t *  bumpScale: <float>,\\n\\t *\\n\\t *  normalMap: new THREE.Texture( <Image> ),\\n\\t *  normalScale: <Vector2>,\\n\\t *\\n\\t *  displacementMap: new THREE.Texture( <Image> ),\\n\\t *  displacementScale: <float>,\\n\\t *  displacementBias: <float>,\\n\\t *\\n\\t *  roughnessMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  metalnessMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  alphaMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\\n\\t *  envMapIntensity: <float>\\n\\t *\\n\\t *  refractionRatio: <float>,\\n\\t *\\n\\t *  wireframe: <boolean>,\\n\\t *  wireframeLinewidth: <float>,\\n\\t *\\n\\t *  skinning: <bool>,\\n\\t *  morphTargets: <bool>,\\n\\t *  morphNormals: <bool>\\n\\t * }\\n\\t */\\n\\n\\tfunction MeshStandardMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.defines = { 'STANDARD': '' };\\n\\n\\t\\tthis.type = 'MeshStandardMaterial';\\n\\n\\t\\tthis.color = new Color( 0xffffff ); // diffuse\\n\\t\\tthis.roughness = 0.5;\\n\\t\\tthis.metalness = 0.5;\\n\\n\\t\\tthis.map = null;\\n\\n\\t\\tthis.lightMap = null;\\n\\t\\tthis.lightMapIntensity = 1.0;\\n\\n\\t\\tthis.aoMap = null;\\n\\t\\tthis.aoMapIntensity = 1.0;\\n\\n\\t\\tthis.emissive = new Color( 0x000000 );\\n\\t\\tthis.emissiveIntensity = 1.0;\\n\\t\\tthis.emissiveMap = null;\\n\\n\\t\\tthis.bumpMap = null;\\n\\t\\tthis.bumpScale = 1;\\n\\n\\t\\tthis.normalMap = null;\\n\\t\\tthis.normalScale = new Vector2( 1, 1 );\\n\\n\\t\\tthis.displacementMap = null;\\n\\t\\tthis.displacementScale = 1;\\n\\t\\tthis.displacementBias = 0;\\n\\n\\t\\tthis.roughnessMap = null;\\n\\n\\t\\tthis.metalnessMap = null;\\n\\n\\t\\tthis.alphaMap = null;\\n\\n\\t\\tthis.envMap = null;\\n\\t\\tthis.envMapIntensity = 1.0;\\n\\n\\t\\tthis.refractionRatio = 0.98;\\n\\n\\t\\tthis.wireframe = false;\\n\\t\\tthis.wireframeLinewidth = 1;\\n\\t\\tthis.wireframeLinecap = 'round';\\n\\t\\tthis.wireframeLinejoin = 'round';\\n\\n\\t\\tthis.skinning = false;\\n\\t\\tthis.morphTargets = false;\\n\\t\\tthis.morphNormals = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tMeshStandardMaterial.prototype = Object.create( Material.prototype );\\n\\tMeshStandardMaterial.prototype.constructor = MeshStandardMaterial;\\n\\n\\tMeshStandardMaterial.prototype.isMeshStandardMaterial = true;\\n\\n\\tMeshStandardMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.defines = { 'STANDARD': '' };\\n\\n\\t\\tthis.color.copy( source.color );\\n\\t\\tthis.roughness = source.roughness;\\n\\t\\tthis.metalness = source.metalness;\\n\\n\\t\\tthis.map = source.map;\\n\\n\\t\\tthis.lightMap = source.lightMap;\\n\\t\\tthis.lightMapIntensity = source.lightMapIntensity;\\n\\n\\t\\tthis.aoMap = source.aoMap;\\n\\t\\tthis.aoMapIntensity = source.aoMapIntensity;\\n\\n\\t\\tthis.emissive.copy( source.emissive );\\n\\t\\tthis.emissiveMap = source.emissiveMap;\\n\\t\\tthis.emissiveIntensity = source.emissiveIntensity;\\n\\n\\t\\tthis.bumpMap = source.bumpMap;\\n\\t\\tthis.bumpScale = source.bumpScale;\\n\\n\\t\\tthis.normalMap = source.normalMap;\\n\\t\\tthis.normalScale.copy( source.normalScale );\\n\\n\\t\\tthis.displacementMap = source.displacementMap;\\n\\t\\tthis.displacementScale = source.displacementScale;\\n\\t\\tthis.displacementBias = source.displacementBias;\\n\\n\\t\\tthis.roughnessMap = source.roughnessMap;\\n\\n\\t\\tthis.metalnessMap = source.metalnessMap;\\n\\n\\t\\tthis.alphaMap = source.alphaMap;\\n\\n\\t\\tthis.envMap = source.envMap;\\n\\t\\tthis.envMapIntensity = source.envMapIntensity;\\n\\n\\t\\tthis.refractionRatio = source.refractionRatio;\\n\\n\\t\\tthis.wireframe = source.wireframe;\\n\\t\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\n\\t\\tthis.wireframeLinecap = source.wireframeLinecap;\\n\\t\\tthis.wireframeLinejoin = source.wireframeLinejoin;\\n\\n\\t\\tthis.skinning = source.skinning;\\n\\t\\tthis.morphTargets = source.morphTargets;\\n\\t\\tthis.morphNormals = source.morphNormals;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t *\\n\\t * parameters = {\\n\\t *  reflectivity: <float>\\n\\t * }\\n\\t */\\n\\n\\tfunction MeshPhysicalMaterial( parameters ) {\\n\\n\\t\\tMeshStandardMaterial.call( this );\\n\\n\\t\\tthis.defines = { 'PHYSICAL': '' };\\n\\n\\t\\tthis.type = 'MeshPhysicalMaterial';\\n\\n\\t\\tthis.reflectivity = 0.5; // maps to F0 = 0.04\\n\\n\\t\\tthis.clearCoat = 0.0;\\n\\t\\tthis.clearCoatRoughness = 0.0;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tMeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );\\n\\tMeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;\\n\\n\\tMeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;\\n\\n\\tMeshPhysicalMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMeshStandardMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.defines = { 'PHYSICAL': '' };\\n\\n\\t\\tthis.reflectivity = source.reflectivity;\\n\\n\\t\\tthis.clearCoat = source.clearCoat;\\n\\t\\tthis.clearCoatRoughness = source.clearCoatRoughness;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t *\\n\\t * parameters = {\\n\\t *  color: <hex>,\\n\\t *  specular: <hex>,\\n\\t *  shininess: <float>,\\n\\t *  opacity: <float>,\\n\\t *\\n\\t *  map: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  lightMap: new THREE.Texture( <Image> ),\\n\\t *  lightMapIntensity: <float>\\n\\t *\\n\\t *  aoMap: new THREE.Texture( <Image> ),\\n\\t *  aoMapIntensity: <float>\\n\\t *\\n\\t *  emissive: <hex>,\\n\\t *  emissiveIntensity: <float>\\n\\t *  emissiveMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  bumpMap: new THREE.Texture( <Image> ),\\n\\t *  bumpScale: <float>,\\n\\t *\\n\\t *  normalMap: new THREE.Texture( <Image> ),\\n\\t *  normalScale: <Vector2>,\\n\\t *\\n\\t *  displacementMap: new THREE.Texture( <Image> ),\\n\\t *  displacementScale: <float>,\\n\\t *  displacementBias: <float>,\\n\\t *\\n\\t *  specularMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  alphaMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\\n\\t *  combine: THREE.Multiply,\\n\\t *  reflectivity: <float>,\\n\\t *  refractionRatio: <float>,\\n\\t *\\n\\t *  wireframe: <boolean>,\\n\\t *  wireframeLinewidth: <float>,\\n\\t *\\n\\t *  skinning: <bool>,\\n\\t *  morphTargets: <bool>,\\n\\t *  morphNormals: <bool>\\n\\t * }\\n\\t */\\n\\n\\tfunction MeshPhongMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'MeshPhongMaterial';\\n\\n\\t\\tthis.color = new Color( 0xffffff ); // diffuse\\n\\t\\tthis.specular = new Color( 0x111111 );\\n\\t\\tthis.shininess = 30;\\n\\n\\t\\tthis.map = null;\\n\\n\\t\\tthis.lightMap = null;\\n\\t\\tthis.lightMapIntensity = 1.0;\\n\\n\\t\\tthis.aoMap = null;\\n\\t\\tthis.aoMapIntensity = 1.0;\\n\\n\\t\\tthis.emissive = new Color( 0x000000 );\\n\\t\\tthis.emissiveIntensity = 1.0;\\n\\t\\tthis.emissiveMap = null;\\n\\n\\t\\tthis.bumpMap = null;\\n\\t\\tthis.bumpScale = 1;\\n\\n\\t\\tthis.normalMap = null;\\n\\t\\tthis.normalScale = new Vector2( 1, 1 );\\n\\n\\t\\tthis.displacementMap = null;\\n\\t\\tthis.displacementScale = 1;\\n\\t\\tthis.displacementBias = 0;\\n\\n\\t\\tthis.specularMap = null;\\n\\n\\t\\tthis.alphaMap = null;\\n\\n\\t\\tthis.envMap = null;\\n\\t\\tthis.combine = MultiplyOperation;\\n\\t\\tthis.reflectivity = 1;\\n\\t\\tthis.refractionRatio = 0.98;\\n\\n\\t\\tthis.wireframe = false;\\n\\t\\tthis.wireframeLinewidth = 1;\\n\\t\\tthis.wireframeLinecap = 'round';\\n\\t\\tthis.wireframeLinejoin = 'round';\\n\\n\\t\\tthis.skinning = false;\\n\\t\\tthis.morphTargets = false;\\n\\t\\tthis.morphNormals = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tMeshPhongMaterial.prototype = Object.create( Material.prototype );\\n\\tMeshPhongMaterial.prototype.constructor = MeshPhongMaterial;\\n\\n\\tMeshPhongMaterial.prototype.isMeshPhongMaterial = true;\\n\\n\\tMeshPhongMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.color.copy( source.color );\\n\\t\\tthis.specular.copy( source.specular );\\n\\t\\tthis.shininess = source.shininess;\\n\\n\\t\\tthis.map = source.map;\\n\\n\\t\\tthis.lightMap = source.lightMap;\\n\\t\\tthis.lightMapIntensity = source.lightMapIntensity;\\n\\n\\t\\tthis.aoMap = source.aoMap;\\n\\t\\tthis.aoMapIntensity = source.aoMapIntensity;\\n\\n\\t\\tthis.emissive.copy( source.emissive );\\n\\t\\tthis.emissiveMap = source.emissiveMap;\\n\\t\\tthis.emissiveIntensity = source.emissiveIntensity;\\n\\n\\t\\tthis.bumpMap = source.bumpMap;\\n\\t\\tthis.bumpScale = source.bumpScale;\\n\\n\\t\\tthis.normalMap = source.normalMap;\\n\\t\\tthis.normalScale.copy( source.normalScale );\\n\\n\\t\\tthis.displacementMap = source.displacementMap;\\n\\t\\tthis.displacementScale = source.displacementScale;\\n\\t\\tthis.displacementBias = source.displacementBias;\\n\\n\\t\\tthis.specularMap = source.specularMap;\\n\\n\\t\\tthis.alphaMap = source.alphaMap;\\n\\n\\t\\tthis.envMap = source.envMap;\\n\\t\\tthis.combine = source.combine;\\n\\t\\tthis.reflectivity = source.reflectivity;\\n\\t\\tthis.refractionRatio = source.refractionRatio;\\n\\n\\t\\tthis.wireframe = source.wireframe;\\n\\t\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\n\\t\\tthis.wireframeLinecap = source.wireframeLinecap;\\n\\t\\tthis.wireframeLinejoin = source.wireframeLinejoin;\\n\\n\\t\\tthis.skinning = source.skinning;\\n\\t\\tthis.morphTargets = source.morphTargets;\\n\\t\\tthis.morphNormals = source.morphNormals;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author takahirox / http://github.com/takahirox\\n\\t *\\n\\t * parameters = {\\n\\t *  gradientMap: new THREE.Texture( <Image> )\\n\\t * }\\n\\t */\\n\\n\\tfunction MeshToonMaterial( parameters ) {\\n\\n\\t\\tMeshPhongMaterial.call( this );\\n\\n\\t\\tthis.defines = { 'TOON': '' };\\n\\n\\t\\tthis.type = 'MeshToonMaterial';\\n\\n\\t\\tthis.gradientMap = null;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tMeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );\\n\\tMeshToonMaterial.prototype.constructor = MeshToonMaterial;\\n\\n\\tMeshToonMaterial.prototype.isMeshToonMaterial = true;\\n\\n\\tMeshToonMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMeshPhongMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.gradientMap = source.gradientMap;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t *\\n\\t * parameters = {\\n\\t *  opacity: <float>,\\n\\t *\\n\\t *  bumpMap: new THREE.Texture( <Image> ),\\n\\t *  bumpScale: <float>,\\n\\t *\\n\\t *  normalMap: new THREE.Texture( <Image> ),\\n\\t *  normalScale: <Vector2>,\\n\\t *\\n\\t *  displacementMap: new THREE.Texture( <Image> ),\\n\\t *  displacementScale: <float>,\\n\\t *  displacementBias: <float>,\\n\\t *\\n\\t *  wireframe: <boolean>,\\n\\t *  wireframeLinewidth: <float>\\n\\t *\\n\\t *  skinning: <bool>,\\n\\t *  morphTargets: <bool>,\\n\\t *  morphNormals: <bool>\\n\\t * }\\n\\t */\\n\\n\\tfunction MeshNormalMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'MeshNormalMaterial';\\n\\n\\t\\tthis.bumpMap = null;\\n\\t\\tthis.bumpScale = 1;\\n\\n\\t\\tthis.normalMap = null;\\n\\t\\tthis.normalScale = new Vector2( 1, 1 );\\n\\n\\t\\tthis.displacementMap = null;\\n\\t\\tthis.displacementScale = 1;\\n\\t\\tthis.displacementBias = 0;\\n\\n\\t\\tthis.wireframe = false;\\n\\t\\tthis.wireframeLinewidth = 1;\\n\\n\\t\\tthis.fog = false;\\n\\t\\tthis.lights = false;\\n\\n\\t\\tthis.skinning = false;\\n\\t\\tthis.morphTargets = false;\\n\\t\\tthis.morphNormals = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tMeshNormalMaterial.prototype = Object.create( Material.prototype );\\n\\tMeshNormalMaterial.prototype.constructor = MeshNormalMaterial;\\n\\n\\tMeshNormalMaterial.prototype.isMeshNormalMaterial = true;\\n\\n\\tMeshNormalMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.bumpMap = source.bumpMap;\\n\\t\\tthis.bumpScale = source.bumpScale;\\n\\n\\t\\tthis.normalMap = source.normalMap;\\n\\t\\tthis.normalScale.copy( source.normalScale );\\n\\n\\t\\tthis.displacementMap = source.displacementMap;\\n\\t\\tthis.displacementScale = source.displacementScale;\\n\\t\\tthis.displacementBias = source.displacementBias;\\n\\n\\t\\tthis.wireframe = source.wireframe;\\n\\t\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\n\\n\\t\\tthis.skinning = source.skinning;\\n\\t\\tthis.morphTargets = source.morphTargets;\\n\\t\\tthis.morphNormals = source.morphNormals;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t *\\n\\t * parameters = {\\n\\t *  color: <hex>,\\n\\t *  opacity: <float>,\\n\\t *\\n\\t *  map: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  lightMap: new THREE.Texture( <Image> ),\\n\\t *  lightMapIntensity: <float>\\n\\t *\\n\\t *  aoMap: new THREE.Texture( <Image> ),\\n\\t *  aoMapIntensity: <float>\\n\\t *\\n\\t *  emissive: <hex>,\\n\\t *  emissiveIntensity: <float>\\n\\t *  emissiveMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  specularMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  alphaMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\\n\\t *  combine: THREE.Multiply,\\n\\t *  reflectivity: <float>,\\n\\t *  refractionRatio: <float>,\\n\\t *\\n\\t *  wireframe: <boolean>,\\n\\t *  wireframeLinewidth: <float>,\\n\\t *\\n\\t *  skinning: <bool>,\\n\\t *  morphTargets: <bool>,\\n\\t *  morphNormals: <bool>\\n\\t * }\\n\\t */\\n\\n\\tfunction MeshLambertMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'MeshLambertMaterial';\\n\\n\\t\\tthis.color = new Color( 0xffffff ); // diffuse\\n\\n\\t\\tthis.map = null;\\n\\n\\t\\tthis.lightMap = null;\\n\\t\\tthis.lightMapIntensity = 1.0;\\n\\n\\t\\tthis.aoMap = null;\\n\\t\\tthis.aoMapIntensity = 1.0;\\n\\n\\t\\tthis.emissive = new Color( 0x000000 );\\n\\t\\tthis.emissiveIntensity = 1.0;\\n\\t\\tthis.emissiveMap = null;\\n\\n\\t\\tthis.specularMap = null;\\n\\n\\t\\tthis.alphaMap = null;\\n\\n\\t\\tthis.envMap = null;\\n\\t\\tthis.combine = MultiplyOperation;\\n\\t\\tthis.reflectivity = 1;\\n\\t\\tthis.refractionRatio = 0.98;\\n\\n\\t\\tthis.wireframe = false;\\n\\t\\tthis.wireframeLinewidth = 1;\\n\\t\\tthis.wireframeLinecap = 'round';\\n\\t\\tthis.wireframeLinejoin = 'round';\\n\\n\\t\\tthis.skinning = false;\\n\\t\\tthis.morphTargets = false;\\n\\t\\tthis.morphNormals = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tMeshLambertMaterial.prototype = Object.create( Material.prototype );\\n\\tMeshLambertMaterial.prototype.constructor = MeshLambertMaterial;\\n\\n\\tMeshLambertMaterial.prototype.isMeshLambertMaterial = true;\\n\\n\\tMeshLambertMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.color.copy( source.color );\\n\\n\\t\\tthis.map = source.map;\\n\\n\\t\\tthis.lightMap = source.lightMap;\\n\\t\\tthis.lightMapIntensity = source.lightMapIntensity;\\n\\n\\t\\tthis.aoMap = source.aoMap;\\n\\t\\tthis.aoMapIntensity = source.aoMapIntensity;\\n\\n\\t\\tthis.emissive.copy( source.emissive );\\n\\t\\tthis.emissiveMap = source.emissiveMap;\\n\\t\\tthis.emissiveIntensity = source.emissiveIntensity;\\n\\n\\t\\tthis.specularMap = source.specularMap;\\n\\n\\t\\tthis.alphaMap = source.alphaMap;\\n\\n\\t\\tthis.envMap = source.envMap;\\n\\t\\tthis.combine = source.combine;\\n\\t\\tthis.reflectivity = source.reflectivity;\\n\\t\\tthis.refractionRatio = source.refractionRatio;\\n\\n\\t\\tthis.wireframe = source.wireframe;\\n\\t\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\n\\t\\tthis.wireframeLinecap = source.wireframeLinecap;\\n\\t\\tthis.wireframeLinejoin = source.wireframeLinejoin;\\n\\n\\t\\tthis.skinning = source.skinning;\\n\\t\\tthis.morphTargets = source.morphTargets;\\n\\t\\tthis.morphNormals = source.morphNormals;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t *\\n\\t * parameters = {\\n\\t *  color: <hex>,\\n\\t *  opacity: <float>,\\n\\t *\\n\\t *  linewidth: <float>,\\n\\t *\\n\\t *  scale: <float>,\\n\\t *  dashSize: <float>,\\n\\t *  gapSize: <float>\\n\\t * }\\n\\t */\\n\\n\\tfunction LineDashedMaterial( parameters ) {\\n\\n\\t\\tLineBasicMaterial.call( this );\\n\\n\\t\\tthis.type = 'LineDashedMaterial';\\n\\n\\t\\tthis.scale = 1;\\n\\t\\tthis.dashSize = 3;\\n\\t\\tthis.gapSize = 1;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tLineDashedMaterial.prototype = Object.create( LineBasicMaterial.prototype );\\n\\tLineDashedMaterial.prototype.constructor = LineDashedMaterial;\\n\\n\\tLineDashedMaterial.prototype.isLineDashedMaterial = true;\\n\\n\\tLineDashedMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tLineBasicMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.scale = source.scale;\\n\\t\\tthis.dashSize = source.dashSize;\\n\\t\\tthis.gapSize = source.gapSize;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\n\\n\\tvar Materials = Object.freeze({\\n\\t\\tShadowMaterial: ShadowMaterial,\\n\\t\\tSpriteMaterial: SpriteMaterial,\\n\\t\\tRawShaderMaterial: RawShaderMaterial,\\n\\t\\tShaderMaterial: ShaderMaterial,\\n\\t\\tPointsMaterial: PointsMaterial,\\n\\t\\tMeshPhysicalMaterial: MeshPhysicalMaterial,\\n\\t\\tMeshStandardMaterial: MeshStandardMaterial,\\n\\t\\tMeshPhongMaterial: MeshPhongMaterial,\\n\\t\\tMeshToonMaterial: MeshToonMaterial,\\n\\t\\tMeshNormalMaterial: MeshNormalMaterial,\\n\\t\\tMeshLambertMaterial: MeshLambertMaterial,\\n\\t\\tMeshDepthMaterial: MeshDepthMaterial,\\n\\t\\tMeshDistanceMaterial: MeshDistanceMaterial,\\n\\t\\tMeshBasicMaterial: MeshBasicMaterial,\\n\\t\\tLineDashedMaterial: LineDashedMaterial,\\n\\t\\tLineBasicMaterial: LineBasicMaterial,\\n\\t\\tMaterial: Material\\n\\t});\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tvar Cache = {\\n\\n\\t\\tenabled: false,\\n\\n\\t\\tfiles: {},\\n\\n\\t\\tadd: function ( key, file ) {\\n\\n\\t\\t\\tif ( this.enabled === false ) return;\\n\\n\\t\\t\\t// console.log( 'THREE.Cache', 'Adding key:', key );\\n\\n\\t\\t\\tthis.files[ key ] = file;\\n\\n\\t\\t},\\n\\n\\t\\tget: function ( key ) {\\n\\n\\t\\t\\tif ( this.enabled === false ) return;\\n\\n\\t\\t\\t// console.log( 'THREE.Cache', 'Checking key:', key );\\n\\n\\t\\t\\treturn this.files[ key ];\\n\\n\\t\\t},\\n\\n\\t\\tremove: function ( key ) {\\n\\n\\t\\t\\tdelete this.files[ key ];\\n\\n\\t\\t},\\n\\n\\t\\tclear: function () {\\n\\n\\t\\t\\tthis.files = {};\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction LoadingManager( onLoad, onProgress, onError ) {\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\tvar isLoading = false;\\n\\t\\tvar itemsLoaded = 0;\\n\\t\\tvar itemsTotal = 0;\\n\\t\\tvar urlModifier = undefined;\\n\\n\\t\\tthis.onStart = undefined;\\n\\t\\tthis.onLoad = onLoad;\\n\\t\\tthis.onProgress = onProgress;\\n\\t\\tthis.onError = onError;\\n\\n\\t\\tthis.itemStart = function ( url ) {\\n\\n\\t\\t\\titemsTotal ++;\\n\\n\\t\\t\\tif ( isLoading === false ) {\\n\\n\\t\\t\\t\\tif ( scope.onStart !== undefined ) {\\n\\n\\t\\t\\t\\t\\tscope.onStart( url, itemsLoaded, itemsTotal );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tisLoading = true;\\n\\n\\t\\t};\\n\\n\\t\\tthis.itemEnd = function ( url ) {\\n\\n\\t\\t\\titemsLoaded ++;\\n\\n\\t\\t\\tif ( scope.onProgress !== undefined ) {\\n\\n\\t\\t\\t\\tscope.onProgress( url, itemsLoaded, itemsTotal );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( itemsLoaded === itemsTotal ) {\\n\\n\\t\\t\\t\\tisLoading = false;\\n\\n\\t\\t\\t\\tif ( scope.onLoad !== undefined ) {\\n\\n\\t\\t\\t\\t\\tscope.onLoad();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tthis.itemError = function ( url ) {\\n\\n\\t\\t\\tif ( scope.onError !== undefined ) {\\n\\n\\t\\t\\t\\tscope.onError( url );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tthis.resolveURL = function ( url ) {\\n\\n\\t\\t\\tif ( urlModifier ) {\\n\\n\\t\\t\\t\\treturn urlModifier( url );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn url;\\n\\n\\t\\t};\\n\\n\\t\\tthis.setURLModifier = function ( transform ) {\\n\\n\\t\\t\\turlModifier = transform;\\n\\t\\t\\treturn this;\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\tvar DefaultLoadingManager = new LoadingManager();\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tvar loading = {};\\n\\n\\tfunction FileLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t}\\n\\n\\tObject.assign( FileLoader.prototype, {\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tif ( url === undefined ) url = '';\\n\\n\\t\\t\\tif ( this.path !== undefined ) url = this.path + url;\\n\\n\\t\\t\\turl = this.manager.resolveURL( url );\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar cached = Cache.get( url );\\n\\n\\t\\t\\tif ( cached !== undefined ) {\\n\\n\\t\\t\\t\\tscope.manager.itemStart( url );\\n\\n\\t\\t\\t\\tsetTimeout( function () {\\n\\n\\t\\t\\t\\t\\tif ( onLoad ) onLoad( cached );\\n\\n\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\n\\t\\t\\t\\t}, 0 );\\n\\n\\t\\t\\t\\treturn cached;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Check if request is duplicate\\n\\n\\t\\t\\tif ( loading[ url ] !== undefined ) {\\n\\n\\t\\t\\t\\tloading[ url ].push( {\\n\\n\\t\\t\\t\\t\\tonLoad: onLoad,\\n\\t\\t\\t\\t\\tonProgress: onProgress,\\n\\t\\t\\t\\t\\tonError: onError\\n\\n\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Check for data: URI\\n\\t\\t\\tvar dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\\n\\t\\t\\tvar dataUriRegexResult = url.match( dataUriRegex );\\n\\n\\t\\t\\t// Safari can not handle Data URIs through XMLHttpRequest so process manually\\n\\t\\t\\tif ( dataUriRegexResult ) {\\n\\n\\t\\t\\t\\tvar mimeType = dataUriRegexResult[ 1 ];\\n\\t\\t\\t\\tvar isBase64 = !! dataUriRegexResult[ 2 ];\\n\\t\\t\\t\\tvar data = dataUriRegexResult[ 3 ];\\n\\n\\t\\t\\t\\tdata = window.decodeURIComponent( data );\\n\\n\\t\\t\\t\\tif ( isBase64 ) data = window.atob( data );\\n\\n\\t\\t\\t\\ttry {\\n\\n\\t\\t\\t\\t\\tvar response;\\n\\t\\t\\t\\t\\tvar responseType = ( this.responseType || '' ).toLowerCase();\\n\\n\\t\\t\\t\\t\\tswitch ( responseType ) {\\n\\n\\t\\t\\t\\t\\t\\tcase 'arraybuffer':\\n\\t\\t\\t\\t\\t\\tcase 'blob':\\n\\n\\t\\t\\t\\t\\t\\t\\tvar view = new Uint8Array( data.length );\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < data.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tview[ i ] = data.charCodeAt( i );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( responseType === 'blob' ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tresponse = new Blob( [ view.buffer ], { type: mimeType } );\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tresponse = view.buffer;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'document':\\n\\n\\t\\t\\t\\t\\t\\t\\tvar parser = new DOMParser();\\n\\t\\t\\t\\t\\t\\t\\tresponse = parser.parseFromString( data, mimeType );\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'json':\\n\\n\\t\\t\\t\\t\\t\\t\\tresponse = JSON.parse( data );\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tdefault: // 'text' or other\\n\\n\\t\\t\\t\\t\\t\\t\\tresponse = data;\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Wait for next browser tick like standard XMLHttpRequest event dispatching does\\n\\t\\t\\t\\t\\twindow.setTimeout( function () {\\n\\n\\t\\t\\t\\t\\t\\tif ( onLoad ) onLoad( response );\\n\\n\\t\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\n\\t\\t\\t\\t\\t}, 0 );\\n\\n\\t\\t\\t\\t} catch ( error ) {\\n\\n\\t\\t\\t\\t\\t// Wait for next browser tick like standard XMLHttpRequest event dispatching does\\n\\t\\t\\t\\t\\twindow.setTimeout( function () {\\n\\n\\t\\t\\t\\t\\t\\tif ( onError ) onError( error );\\n\\n\\t\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\t\\t\\t\\t\\t\\tscope.manager.itemError( url );\\n\\n\\t\\t\\t\\t\\t}, 0 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Initialise array for duplicate requests\\n\\n\\t\\t\\t\\tloading[ url ] = [];\\n\\n\\t\\t\\t\\tloading[ url ].push( {\\n\\n\\t\\t\\t\\t\\tonLoad: onLoad,\\n\\t\\t\\t\\t\\tonProgress: onProgress,\\n\\t\\t\\t\\t\\tonError: onError\\n\\n\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\tvar request = new XMLHttpRequest();\\n\\n\\t\\t\\t\\trequest.open( 'GET', url, true );\\n\\n\\t\\t\\t\\trequest.addEventListener( 'load', function ( event ) {\\n\\n\\t\\t\\t\\t\\tvar response = this.response;\\n\\n\\t\\t\\t\\t\\tCache.add( url, response );\\n\\n\\t\\t\\t\\t\\tvar callbacks = loading[ url ];\\n\\n\\t\\t\\t\\t\\tdelete loading[ url ];\\n\\n\\t\\t\\t\\t\\tif ( this.status === 200 ) {\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar callback = callbacks[ i ];\\n\\t\\t\\t\\t\\t\\t\\tif ( callback.onLoad ) callback.onLoad( response );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\n\\t\\t\\t\\t\\t} else if ( this.status === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\t// Some browsers return HTTP Status 0 when using non-http protocol\\n\\t\\t\\t\\t\\t\\t// e.g. 'file://' or 'data://'. Handle as success.\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.FileLoader: HTTP Status 0 received.' );\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar callback = callbacks[ i ];\\n\\t\\t\\t\\t\\t\\t\\tif ( callback.onLoad ) callback.onLoad( response );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar callback = callbacks[ i ];\\n\\t\\t\\t\\t\\t\\t\\tif ( callback.onError ) callback.onError( event );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\t\\t\\t\\t\\t\\tscope.manager.itemError( url );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}, false );\\n\\n\\t\\t\\t\\trequest.addEventListener( 'progress', function ( event ) {\\n\\n\\t\\t\\t\\t\\tvar callbacks = loading[ url ];\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar callback = callbacks[ i ];\\n\\t\\t\\t\\t\\t\\tif ( callback.onProgress ) callback.onProgress( event );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}, false );\\n\\n\\t\\t\\t\\trequest.addEventListener( 'error', function ( event ) {\\n\\n\\t\\t\\t\\t\\tvar callbacks = loading[ url ];\\n\\n\\t\\t\\t\\t\\tdelete loading[ url ];\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar callback = callbacks[ i ];\\n\\t\\t\\t\\t\\t\\tif ( callback.onError ) callback.onError( event );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\t\\t\\t\\t\\tscope.manager.itemError( url );\\n\\n\\t\\t\\t\\t}, false );\\n\\n\\t\\t\\t\\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\\n\\t\\t\\t\\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\\n\\n\\t\\t\\t\\tif ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );\\n\\n\\t\\t\\t\\tfor ( var header in this.requestHeader ) {\\n\\n\\t\\t\\t\\t\\trequest.setRequestHeader( header, this.requestHeader[ header ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\trequest.send( null );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tscope.manager.itemStart( url );\\n\\n\\t\\t\\treturn request;\\n\\n\\t\\t},\\n\\n\\t\\tsetPath: function ( value ) {\\n\\n\\t\\t\\tthis.path = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetResponseType: function ( value ) {\\n\\n\\t\\t\\tthis.responseType = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetWithCredentials: function ( value ) {\\n\\n\\t\\t\\tthis.withCredentials = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetMimeType: function ( value ) {\\n\\n\\t\\t\\tthis.mimeType = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetRequestHeader: function ( value ) {\\n\\n\\t\\t\\tthis.requestHeader = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t *\\n\\t * Abstract Base class to block based textures loader (dds, pvr, ...)\\n\\t */\\n\\n\\tfunction CompressedTextureLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t\\t// override in sub classes\\n\\t\\tthis._parser = null;\\n\\n\\t}\\n\\n\\tObject.assign( CompressedTextureLoader.prototype, {\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar images = [];\\n\\n\\t\\t\\tvar texture = new CompressedTexture();\\n\\t\\t\\ttexture.image = images;\\n\\n\\t\\t\\tvar loader = new FileLoader( this.manager );\\n\\t\\t\\tloader.setPath( this.path );\\n\\t\\t\\tloader.setResponseType( 'arraybuffer' );\\n\\n\\t\\t\\tfunction loadTexture( i ) {\\n\\n\\t\\t\\t\\tloader.load( url[ i ], function ( buffer ) {\\n\\n\\t\\t\\t\\t\\tvar texDatas = scope._parser( buffer, true );\\n\\n\\t\\t\\t\\t\\timages[ i ] = {\\n\\t\\t\\t\\t\\t\\twidth: texDatas.width,\\n\\t\\t\\t\\t\\t\\theight: texDatas.height,\\n\\t\\t\\t\\t\\t\\tformat: texDatas.format,\\n\\t\\t\\t\\t\\t\\tmipmaps: texDatas.mipmaps\\n\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\tloaded += 1;\\n\\n\\t\\t\\t\\t\\tif ( loaded === 6 ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( texDatas.mipmapCount === 1 )\\n\\t\\t\\t\\t\\t\\t\\ttexture.minFilter = LinearFilter;\\n\\n\\t\\t\\t\\t\\t\\ttexture.format = texDatas.format;\\n\\t\\t\\t\\t\\t\\ttexture.needsUpdate = true;\\n\\n\\t\\t\\t\\t\\t\\tif ( onLoad ) onLoad( texture );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}, onProgress, onError );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( Array.isArray( url ) ) {\\n\\n\\t\\t\\t\\tvar loaded = 0;\\n\\n\\t\\t\\t\\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\\n\\n\\t\\t\\t\\t\\tloadTexture( i );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// compressed cubemap texture stored in a single DDS file\\n\\n\\t\\t\\t\\tloader.load( url, function ( buffer ) {\\n\\n\\t\\t\\t\\t\\tvar texDatas = scope._parser( buffer, true );\\n\\n\\t\\t\\t\\t\\tif ( texDatas.isCubemap ) {\\n\\n\\t\\t\\t\\t\\t\\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var f = 0; f < faces; f ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\timages[ f ] = { mipmaps: [] };\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\\n\\t\\t\\t\\t\\t\\t\\t\\timages[ f ].format = texDatas.format;\\n\\t\\t\\t\\t\\t\\t\\t\\timages[ f ].width = texDatas.width;\\n\\t\\t\\t\\t\\t\\t\\t\\timages[ f ].height = texDatas.height;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\ttexture.image.width = texDatas.width;\\n\\t\\t\\t\\t\\t\\ttexture.image.height = texDatas.height;\\n\\t\\t\\t\\t\\t\\ttexture.mipmaps = texDatas.mipmaps;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( texDatas.mipmapCount === 1 ) {\\n\\n\\t\\t\\t\\t\\t\\ttexture.minFilter = LinearFilter;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ttexture.format = texDatas.format;\\n\\t\\t\\t\\t\\ttexture.needsUpdate = true;\\n\\n\\t\\t\\t\\t\\tif ( onLoad ) onLoad( texture );\\n\\n\\t\\t\\t\\t}, onProgress, onError );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn texture;\\n\\n\\t\\t},\\n\\n\\t\\tsetPath: function ( value ) {\\n\\n\\t\\t\\tthis.path = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author Nikos M. / https://github.com/foo123/\\n\\t *\\n\\t * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\\n\\t */\\n\\n\\tfunction DataTextureLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t\\t// override in sub classes\\n\\t\\tthis._parser = null;\\n\\n\\t}\\n\\n\\tObject.assign( DataTextureLoader.prototype, {\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar texture = new DataTexture();\\n\\n\\t\\t\\tvar loader = new FileLoader( this.manager );\\n\\t\\t\\tloader.setResponseType( 'arraybuffer' );\\n\\n\\t\\t\\tloader.load( url, function ( buffer ) {\\n\\n\\t\\t\\t\\tvar texData = scope._parser( buffer );\\n\\n\\t\\t\\t\\tif ( ! texData ) return;\\n\\n\\t\\t\\t\\tif ( undefined !== texData.image ) {\\n\\n\\t\\t\\t\\t\\ttexture.image = texData.image;\\n\\n\\t\\t\\t\\t} else if ( undefined !== texData.data ) {\\n\\n\\t\\t\\t\\t\\ttexture.image.width = texData.width;\\n\\t\\t\\t\\t\\ttexture.image.height = texData.height;\\n\\t\\t\\t\\t\\ttexture.image.data = texData.data;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;\\n\\t\\t\\t\\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;\\n\\n\\t\\t\\t\\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;\\n\\t\\t\\t\\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;\\n\\n\\t\\t\\t\\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\\n\\n\\t\\t\\t\\tif ( undefined !== texData.format ) {\\n\\n\\t\\t\\t\\t\\ttexture.format = texData.format;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( undefined !== texData.type ) {\\n\\n\\t\\t\\t\\t\\ttexture.type = texData.type;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( undefined !== texData.mipmaps ) {\\n\\n\\t\\t\\t\\t\\ttexture.mipmaps = texData.mipmaps;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( 1 === texData.mipmapCount ) {\\n\\n\\t\\t\\t\\t\\ttexture.minFilter = LinearFilter;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttexture.needsUpdate = true;\\n\\n\\t\\t\\t\\tif ( onLoad ) onLoad( texture, texData );\\n\\n\\t\\t\\t}, onProgress, onError );\\n\\n\\n\\t\\t\\treturn texture;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction ImageLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t}\\n\\n\\tObject.assign( ImageLoader.prototype, {\\n\\n\\t\\tcrossOrigin: 'Anonymous',\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tif ( url === undefined ) url = '';\\n\\n\\t\\t\\tif ( this.path !== undefined ) url = this.path + url;\\n\\n\\t\\t\\turl = this.manager.resolveURL( url );\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar cached = Cache.get( url );\\n\\n\\t\\t\\tif ( cached !== undefined ) {\\n\\n\\t\\t\\t\\tscope.manager.itemStart( url );\\n\\n\\t\\t\\t\\tsetTimeout( function () {\\n\\n\\t\\t\\t\\t\\tif ( onLoad ) onLoad( cached );\\n\\n\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\n\\t\\t\\t\\t}, 0 );\\n\\n\\t\\t\\t\\treturn cached;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\\n\\n\\t\\t\\timage.addEventListener( 'load', function () {\\n\\n\\t\\t\\t\\tCache.add( url, this );\\n\\n\\t\\t\\t\\tif ( onLoad ) onLoad( this );\\n\\n\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\n\\t\\t\\t}, false );\\n\\n\\t\\t\\t/*\\n\\t\\t\\timage.addEventListener( 'progress', function ( event ) {\\n\\n\\t\\t\\t\\tif ( onProgress ) onProgress( event );\\n\\n\\t\\t\\t}, false );\\n\\t\\t\\t*/\\n\\n\\t\\t\\timage.addEventListener( 'error', function ( event ) {\\n\\n\\t\\t\\t\\tif ( onError ) onError( event );\\n\\n\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\t\\t\\t\\tscope.manager.itemError( url );\\n\\n\\t\\t\\t}, false );\\n\\n\\t\\t\\tif ( url.substr( 0, 5 ) !== 'data:' ) {\\n\\n\\t\\t\\t\\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tscope.manager.itemStart( url );\\n\\n\\t\\t\\timage.src = url;\\n\\n\\t\\t\\treturn image;\\n\\n\\t\\t},\\n\\n\\t\\tsetCrossOrigin: function ( value ) {\\n\\n\\t\\t\\tthis.crossOrigin = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetPath: function ( value ) {\\n\\n\\t\\t\\tthis.path = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction CubeTextureLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t}\\n\\n\\tObject.assign( CubeTextureLoader.prototype, {\\n\\n\\t\\tcrossOrigin: 'Anonymous',\\n\\n\\t\\tload: function ( urls, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tvar texture = new CubeTexture();\\n\\n\\t\\t\\tvar loader = new ImageLoader( this.manager );\\n\\t\\t\\tloader.setCrossOrigin( this.crossOrigin );\\n\\t\\t\\tloader.setPath( this.path );\\n\\n\\t\\t\\tvar loaded = 0;\\n\\n\\t\\t\\tfunction loadTexture( i ) {\\n\\n\\t\\t\\t\\tloader.load( urls[ i ], function ( image ) {\\n\\n\\t\\t\\t\\t\\ttexture.images[ i ] = image;\\n\\n\\t\\t\\t\\t\\tloaded ++;\\n\\n\\t\\t\\t\\t\\tif ( loaded === 6 ) {\\n\\n\\t\\t\\t\\t\\t\\ttexture.needsUpdate = true;\\n\\n\\t\\t\\t\\t\\t\\tif ( onLoad ) onLoad( texture );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}, undefined, onError );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var i = 0; i < urls.length; ++ i ) {\\n\\n\\t\\t\\t\\tloadTexture( i );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn texture;\\n\\n\\t\\t},\\n\\n\\t\\tsetCrossOrigin: function ( value ) {\\n\\n\\t\\t\\tthis.crossOrigin = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetPath: function ( value ) {\\n\\n\\t\\t\\tthis.path = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction TextureLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t}\\n\\n\\tObject.assign( TextureLoader.prototype, {\\n\\n\\t\\tcrossOrigin: 'Anonymous',\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tvar texture = new Texture();\\n\\n\\t\\t\\tvar loader = new ImageLoader( this.manager );\\n\\t\\t\\tloader.setCrossOrigin( this.crossOrigin );\\n\\t\\t\\tloader.setPath( this.path );\\n\\n\\t\\t\\tloader.load( url, function ( image ) {\\n\\n\\t\\t\\t\\ttexture.image = image;\\n\\n\\t\\t\\t\\t// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\\n\\t\\t\\t\\tvar isJPEG = url.search( /\\\\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\\\\:image\\\\/jpeg/ ) === 0;\\n\\n\\t\\t\\t\\ttexture.format = isJPEG ? RGBFormat : RGBAFormat;\\n\\t\\t\\t\\ttexture.needsUpdate = true;\\n\\n\\t\\t\\t\\tif ( onLoad !== undefined ) {\\n\\n\\t\\t\\t\\t\\tonLoad( texture );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}, onProgress, onError );\\n\\n\\t\\t\\treturn texture;\\n\\n\\t\\t},\\n\\n\\t\\tsetCrossOrigin: function ( value ) {\\n\\n\\t\\t\\tthis.crossOrigin = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetPath: function ( value ) {\\n\\n\\t\\t\\tthis.path = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t * Extensible curve object\\n\\t *\\n\\t * Some common of curve methods:\\n\\t * .getPoint( t, optionalTarget ), .getTangent( t )\\n\\t * .getPointAt( u, optionalTarget ), .getTangentAt( u )\\n\\t * .getPoints(), .getSpacedPoints()\\n\\t * .getLength()\\n\\t * .updateArcLengths()\\n\\t *\\n\\t * This following curves inherit from THREE.Curve:\\n\\t *\\n\\t * -- 2D curves --\\n\\t * THREE.ArcCurve\\n\\t * THREE.CubicBezierCurve\\n\\t * THREE.EllipseCurve\\n\\t * THREE.LineCurve\\n\\t * THREE.QuadraticBezierCurve\\n\\t * THREE.SplineCurve\\n\\t *\\n\\t * -- 3D curves --\\n\\t * THREE.CatmullRomCurve3\\n\\t * THREE.CubicBezierCurve3\\n\\t * THREE.LineCurve3\\n\\t * THREE.QuadraticBezierCurve3\\n\\t *\\n\\t * A series of curves can be represented as a THREE.CurvePath.\\n\\t *\\n\\t **/\\n\\n\\t/**************************************************************\\n\\t *\\tAbstract Curve base class\\n\\t **************************************************************/\\n\\n\\tfunction Curve() {\\n\\n\\t\\tthis.type = 'Curve';\\n\\n\\t\\tthis.arcLengthDivisions = 200;\\n\\n\\t}\\n\\n\\tObject.assign( Curve.prototype, {\\n\\n\\t\\t// Virtual base class method to overwrite and implement in subclasses\\n\\t\\t//\\t- t [0 .. 1]\\n\\n\\t\\tgetPoint: function ( /* t, optionalTarget */ ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Curve: .getPoint() not implemented.' );\\n\\t\\t\\treturn null;\\n\\n\\t\\t},\\n\\n\\t\\t// Get point at relative position in curve according to arc length\\n\\t\\t// - u [0 .. 1]\\n\\n\\t\\tgetPointAt: function ( u, optionalTarget ) {\\n\\n\\t\\t\\tvar t = this.getUtoTmapping( u );\\n\\t\\t\\treturn this.getPoint( t, optionalTarget );\\n\\n\\t\\t},\\n\\n\\t\\t// Get sequence of points using getPoint( t )\\n\\n\\t\\tgetPoints: function ( divisions ) {\\n\\n\\t\\t\\tif ( divisions === undefined ) divisions = 5;\\n\\n\\t\\t\\tvar points = [];\\n\\n\\t\\t\\tfor ( var d = 0; d <= divisions; d ++ ) {\\n\\n\\t\\t\\t\\tpoints.push( this.getPoint( d / divisions ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn points;\\n\\n\\t\\t},\\n\\n\\t\\t// Get sequence of points using getPointAt( u )\\n\\n\\t\\tgetSpacedPoints: function ( divisions ) {\\n\\n\\t\\t\\tif ( divisions === undefined ) divisions = 5;\\n\\n\\t\\t\\tvar points = [];\\n\\n\\t\\t\\tfor ( var d = 0; d <= divisions; d ++ ) {\\n\\n\\t\\t\\t\\tpoints.push( this.getPointAt( d / divisions ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn points;\\n\\n\\t\\t},\\n\\n\\t\\t// Get total curve arc length\\n\\n\\t\\tgetLength: function () {\\n\\n\\t\\t\\tvar lengths = this.getLengths();\\n\\t\\t\\treturn lengths[ lengths.length - 1 ];\\n\\n\\t\\t},\\n\\n\\t\\t// Get list of cumulative segment lengths\\n\\n\\t\\tgetLengths: function ( divisions ) {\\n\\n\\t\\t\\tif ( divisions === undefined ) divisions = this.arcLengthDivisions;\\n\\n\\t\\t\\tif ( this.cacheArcLengths &&\\n\\t\\t\\t\\t( this.cacheArcLengths.length === divisions + 1 ) &&\\n\\t\\t\\t\\t! this.needsUpdate ) {\\n\\n\\t\\t\\t\\treturn this.cacheArcLengths;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.needsUpdate = false;\\n\\n\\t\\t\\tvar cache = [];\\n\\t\\t\\tvar current, last = this.getPoint( 0 );\\n\\t\\t\\tvar p, sum = 0;\\n\\n\\t\\t\\tcache.push( 0 );\\n\\n\\t\\t\\tfor ( p = 1; p <= divisions; p ++ ) {\\n\\n\\t\\t\\t\\tcurrent = this.getPoint( p / divisions );\\n\\t\\t\\t\\tsum += current.distanceTo( last );\\n\\t\\t\\t\\tcache.push( sum );\\n\\t\\t\\t\\tlast = current;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.cacheArcLengths = cache;\\n\\n\\t\\t\\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\\n\\n\\t\\t},\\n\\n\\t\\tupdateArcLengths: function () {\\n\\n\\t\\t\\tthis.needsUpdate = true;\\n\\t\\t\\tthis.getLengths();\\n\\n\\t\\t},\\n\\n\\t\\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\\n\\n\\t\\tgetUtoTmapping: function ( u, distance ) {\\n\\n\\t\\t\\tvar arcLengths = this.getLengths();\\n\\n\\t\\t\\tvar i = 0, il = arcLengths.length;\\n\\n\\t\\t\\tvar targetArcLength; // The targeted u distance value to get\\n\\n\\t\\t\\tif ( distance ) {\\n\\n\\t\\t\\t\\ttargetArcLength = distance;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\ttargetArcLength = u * arcLengths[ il - 1 ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// binary search for the index with largest value smaller than target u distance\\n\\n\\t\\t\\tvar low = 0, high = il - 1, comparison;\\n\\n\\t\\t\\twhile ( low <= high ) {\\n\\n\\t\\t\\t\\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\\n\\n\\t\\t\\t\\tcomparison = arcLengths[ i ] - targetArcLength;\\n\\n\\t\\t\\t\\tif ( comparison < 0 ) {\\n\\n\\t\\t\\t\\t\\tlow = i + 1;\\n\\n\\t\\t\\t\\t} else if ( comparison > 0 ) {\\n\\n\\t\\t\\t\\t\\thigh = i - 1;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\thigh = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t// DONE\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\ti = high;\\n\\n\\t\\t\\tif ( arcLengths[ i ] === targetArcLength ) {\\n\\n\\t\\t\\t\\treturn i / ( il - 1 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// we could get finer grain at lengths, or use simple interpolation between two points\\n\\n\\t\\t\\tvar lengthBefore = arcLengths[ i ];\\n\\t\\t\\tvar lengthAfter = arcLengths[ i + 1 ];\\n\\n\\t\\t\\tvar segmentLength = lengthAfter - lengthBefore;\\n\\n\\t\\t\\t// determine where we are between the 'before' and 'after' points\\n\\n\\t\\t\\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\\n\\n\\t\\t\\t// add that fractional amount to t\\n\\n\\t\\t\\tvar t = ( i + segmentFraction ) / ( il - 1 );\\n\\n\\t\\t\\treturn t;\\n\\n\\t\\t},\\n\\n\\t\\t// Returns a unit vector tangent at t\\n\\t\\t// In case any sub curve does not implement its tangent derivation,\\n\\t\\t// 2 points a small delta apart will be used to find its gradient\\n\\t\\t// which seems to give a reasonable approximation\\n\\n\\t\\tgetTangent: function ( t ) {\\n\\n\\t\\t\\tvar delta = 0.0001;\\n\\t\\t\\tvar t1 = t - delta;\\n\\t\\t\\tvar t2 = t + delta;\\n\\n\\t\\t\\t// Capping in case of danger\\n\\n\\t\\t\\tif ( t1 < 0 ) t1 = 0;\\n\\t\\t\\tif ( t2 > 1 ) t2 = 1;\\n\\n\\t\\t\\tvar pt1 = this.getPoint( t1 );\\n\\t\\t\\tvar pt2 = this.getPoint( t2 );\\n\\n\\t\\t\\tvar vec = pt2.clone().sub( pt1 );\\n\\t\\t\\treturn vec.normalize();\\n\\n\\t\\t},\\n\\n\\t\\tgetTangentAt: function ( u ) {\\n\\n\\t\\t\\tvar t = this.getUtoTmapping( u );\\n\\t\\t\\treturn this.getTangent( t );\\n\\n\\t\\t},\\n\\n\\t\\tcomputeFrenetFrames: function ( segments, closed ) {\\n\\n\\t\\t\\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\\n\\n\\t\\t\\tvar normal = new Vector3();\\n\\n\\t\\t\\tvar tangents = [];\\n\\t\\t\\tvar normals = [];\\n\\t\\t\\tvar binormals = [];\\n\\n\\t\\t\\tvar vec = new Vector3();\\n\\t\\t\\tvar mat = new Matrix4();\\n\\n\\t\\t\\tvar i, u, theta;\\n\\n\\t\\t\\t// compute the tangent vectors for each segment on the curve\\n\\n\\t\\t\\tfor ( i = 0; i <= segments; i ++ ) {\\n\\n\\t\\t\\t\\tu = i / segments;\\n\\n\\t\\t\\t\\ttangents[ i ] = this.getTangentAt( u );\\n\\t\\t\\t\\ttangents[ i ].normalize();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// select an initial normal vector perpendicular to the first tangent vector,\\n\\t\\t\\t// and in the direction of the minimum tangent xyz component\\n\\n\\t\\t\\tnormals[ 0 ] = new Vector3();\\n\\t\\t\\tbinormals[ 0 ] = new Vector3();\\n\\t\\t\\tvar min = Number.MAX_VALUE;\\n\\t\\t\\tvar tx = Math.abs( tangents[ 0 ].x );\\n\\t\\t\\tvar ty = Math.abs( tangents[ 0 ].y );\\n\\t\\t\\tvar tz = Math.abs( tangents[ 0 ].z );\\n\\n\\t\\t\\tif ( tx <= min ) {\\n\\n\\t\\t\\t\\tmin = tx;\\n\\t\\t\\t\\tnormal.set( 1, 0, 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( ty <= min ) {\\n\\n\\t\\t\\t\\tmin = ty;\\n\\t\\t\\t\\tnormal.set( 0, 1, 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( tz <= min ) {\\n\\n\\t\\t\\t\\tnormal.set( 0, 0, 1 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\\n\\n\\t\\t\\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\\n\\t\\t\\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\\n\\n\\n\\t\\t\\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\\n\\n\\t\\t\\tfor ( i = 1; i <= segments; i ++ ) {\\n\\n\\t\\t\\t\\tnormals[ i ] = normals[ i - 1 ].clone();\\n\\n\\t\\t\\t\\tbinormals[ i ] = binormals[ i - 1 ].clone();\\n\\n\\t\\t\\t\\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\\n\\n\\t\\t\\t\\tif ( vec.length() > Number.EPSILON ) {\\n\\n\\t\\t\\t\\t\\tvec.normalize();\\n\\n\\t\\t\\t\\t\\ttheta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\\n\\n\\t\\t\\t\\t\\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\\n\\n\\t\\t\\tif ( closed === true ) {\\n\\n\\t\\t\\t\\ttheta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\\n\\t\\t\\t\\ttheta /= segments;\\n\\n\\t\\t\\t\\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\\n\\n\\t\\t\\t\\t\\ttheta = - theta;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor ( i = 1; i <= segments; i ++ ) {\\n\\n\\t\\t\\t\\t\\t// twist a little...\\n\\t\\t\\t\\t\\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\\n\\t\\t\\t\\t\\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn {\\n\\t\\t\\t\\ttangents: tangents,\\n\\t\\t\\t\\tnormals: normals,\\n\\t\\t\\t\\tbinormals: binormals\\n\\t\\t\\t};\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tthis.arcLengthDivisions = source.arcLengthDivisions;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function () {\\n\\n\\t\\t\\tvar data = {\\n\\t\\t\\t\\tmetadata: {\\n\\t\\t\\t\\t\\tversion: 4.5,\\n\\t\\t\\t\\t\\ttype: 'Curve',\\n\\t\\t\\t\\t\\tgenerator: 'Curve.toJSON'\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\t\\tdata.arcLengthDivisions = this.arcLengthDivisions;\\n\\t\\t\\tdata.type = this.type;\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t},\\n\\n\\t\\tfromJSON: function ( json ) {\\n\\n\\t\\t\\tthis.arcLengthDivisions = json.arcLengthDivisions;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tfunction EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'EllipseCurve';\\n\\n\\t\\tthis.aX = aX || 0;\\n\\t\\tthis.aY = aY || 0;\\n\\n\\t\\tthis.xRadius = xRadius || 1;\\n\\t\\tthis.yRadius = yRadius || 1;\\n\\n\\t\\tthis.aStartAngle = aStartAngle || 0;\\n\\t\\tthis.aEndAngle = aEndAngle || 2 * Math.PI;\\n\\n\\t\\tthis.aClockwise = aClockwise || false;\\n\\n\\t\\tthis.aRotation = aRotation || 0;\\n\\n\\t}\\n\\n\\tEllipseCurve.prototype = Object.create( Curve.prototype );\\n\\tEllipseCurve.prototype.constructor = EllipseCurve;\\n\\n\\tEllipseCurve.prototype.isEllipseCurve = true;\\n\\n\\tEllipseCurve.prototype.getPoint = function ( t, optionalTarget ) {\\n\\n\\t\\tvar point = optionalTarget || new Vector2();\\n\\n\\t\\tvar twoPi = Math.PI * 2;\\n\\t\\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\\n\\t\\tvar samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\\n\\n\\t\\t// ensures that deltaAngle is 0 .. 2 PI\\n\\t\\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\\n\\t\\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\\n\\n\\t\\tif ( deltaAngle < Number.EPSILON ) {\\n\\n\\t\\t\\tif ( samePoints ) {\\n\\n\\t\\t\\t\\tdeltaAngle = 0;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tdeltaAngle = twoPi;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tif ( this.aClockwise === true && ! samePoints ) {\\n\\n\\t\\t\\tif ( deltaAngle === twoPi ) {\\n\\n\\t\\t\\t\\tdeltaAngle = - twoPi;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tdeltaAngle = deltaAngle - twoPi;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tvar angle = this.aStartAngle + t * deltaAngle;\\n\\t\\tvar x = this.aX + this.xRadius * Math.cos( angle );\\n\\t\\tvar y = this.aY + this.yRadius * Math.sin( angle );\\n\\n\\t\\tif ( this.aRotation !== 0 ) {\\n\\n\\t\\t\\tvar cos = Math.cos( this.aRotation );\\n\\t\\t\\tvar sin = Math.sin( this.aRotation );\\n\\n\\t\\t\\tvar tx = x - this.aX;\\n\\t\\t\\tvar ty = y - this.aY;\\n\\n\\t\\t\\t// Rotate the point about the center of the ellipse.\\n\\t\\t\\tx = tx * cos - ty * sin + this.aX;\\n\\t\\t\\ty = tx * sin + ty * cos + this.aY;\\n\\n\\t\\t}\\n\\n\\t\\treturn point.set( x, y );\\n\\n\\t};\\n\\n\\tEllipseCurve.prototype.copy = function ( source ) {\\n\\n\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\tthis.aX = source.aX;\\n\\t\\tthis.aY = source.aY;\\n\\n\\t\\tthis.xRadius = source.xRadius;\\n\\t\\tthis.yRadius = source.yRadius;\\n\\n\\t\\tthis.aStartAngle = source.aStartAngle;\\n\\t\\tthis.aEndAngle = source.aEndAngle;\\n\\n\\t\\tthis.aClockwise = source.aClockwise;\\n\\n\\t\\tthis.aRotation = source.aRotation;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\n\\tEllipseCurve.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\tdata.aX = this.aX;\\n\\t\\tdata.aY = this.aY;\\n\\n\\t\\tdata.xRadius = this.xRadius;\\n\\t\\tdata.yRadius = this.yRadius;\\n\\n\\t\\tdata.aStartAngle = this.aStartAngle;\\n\\t\\tdata.aEndAngle = this.aEndAngle;\\n\\n\\t\\tdata.aClockwise = this.aClockwise;\\n\\n\\t\\tdata.aRotation = this.aRotation;\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tEllipseCurve.prototype.fromJSON = function ( json ) {\\n\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\tthis.aX = json.aX;\\n\\t\\tthis.aY = json.aY;\\n\\n\\t\\tthis.xRadius = json.xRadius;\\n\\t\\tthis.yRadius = json.yRadius;\\n\\n\\t\\tthis.aStartAngle = json.aStartAngle;\\n\\t\\tthis.aEndAngle = json.aEndAngle;\\n\\n\\t\\tthis.aClockwise = json.aClockwise;\\n\\n\\t\\tthis.aRotation = json.aRotation;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\\n\\n\\t\\tEllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\\n\\n\\t\\tthis.type = 'ArcCurve';\\n\\n\\t}\\n\\n\\tArcCurve.prototype = Object.create( EllipseCurve.prototype );\\n\\tArcCurve.prototype.constructor = ArcCurve;\\n\\n\\tArcCurve.prototype.isArcCurve = true;\\n\\n\\t/**\\n\\t * @author zz85 https://github.com/zz85\\n\\t *\\n\\t * Centripetal CatmullRom Curve - which is useful for avoiding\\n\\t * cusps and self-intersections in non-uniform catmull rom curves.\\n\\t * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\\n\\t *\\n\\t * curve.type accepts centripetal(default), chordal and catmullrom\\n\\t * curve.tension is used for catmullrom which defaults to 0.5\\n\\t */\\n\\n\\n\\t/*\\n\\tBased on an optimized c++ solution in\\n\\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\\n\\t - http://ideone.com/NoEbVM\\n\\n\\tThis CubicPoly class could be used for reusing some variables and calculations,\\n\\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\\n\\twhich can be placed in CurveUtils.\\n\\t*/\\n\\n\\tfunction CubicPoly() {\\n\\n\\t\\tvar c0 = 0, c1 = 0, c2 = 0, c3 = 0;\\n\\n\\t\\t/*\\n\\t\\t * Compute coefficients for a cubic polynomial\\n\\t\\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\\n\\t\\t * such that\\n\\t\\t *   p(0) = x0, p(1) = x1\\n\\t\\t *  and\\n\\t\\t *   p'(0) = t0, p'(1) = t1.\\n\\t\\t */\\n\\t\\tfunction init( x0, x1, t0, t1 ) {\\n\\n\\t\\t\\tc0 = x0;\\n\\t\\t\\tc1 = t0;\\n\\t\\t\\tc2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\\n\\t\\t\\tc3 = 2 * x0 - 2 * x1 + t0 + t1;\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tinitCatmullRom: function ( x0, x1, x2, x3, tension ) {\\n\\n\\t\\t\\t\\tinit( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tinitNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {\\n\\n\\t\\t\\t\\t// compute tangents when parameterized in [t1,t2]\\n\\t\\t\\t\\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\\n\\t\\t\\t\\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\\n\\n\\t\\t\\t\\t// rescale tangents for parametrization in [0,1]\\n\\t\\t\\t\\tt1 *= dt1;\\n\\t\\t\\t\\tt2 *= dt1;\\n\\n\\t\\t\\t\\tinit( x1, x2, t1, t2 );\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tcalc: function ( t ) {\\n\\n\\t\\t\\t\\tvar t2 = t * t;\\n\\t\\t\\t\\tvar t3 = t2 * t;\\n\\t\\t\\t\\treturn c0 + c1 * t + c2 * t2 + c3 * t3;\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t//\\n\\n\\tvar tmp = new Vector3();\\n\\tvar px = new CubicPoly();\\n\\tvar py = new CubicPoly();\\n\\tvar pz = new CubicPoly();\\n\\n\\tfunction CatmullRomCurve3( points, closed, curveType, tension ) {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'CatmullRomCurve3';\\n\\n\\t\\tthis.points = points || [];\\n\\t\\tthis.closed = closed || false;\\n\\t\\tthis.curveType = curveType || 'centripetal';\\n\\t\\tthis.tension = tension || 0.5;\\n\\n\\t}\\n\\n\\tCatmullRomCurve3.prototype = Object.create( Curve.prototype );\\n\\tCatmullRomCurve3.prototype.constructor = CatmullRomCurve3;\\n\\n\\tCatmullRomCurve3.prototype.isCatmullRomCurve3 = true;\\n\\n\\tCatmullRomCurve3.prototype.getPoint = function ( t, optionalTarget ) {\\n\\n\\t\\tvar point = optionalTarget || new Vector3();\\n\\n\\t\\tvar points = this.points;\\n\\t\\tvar l = points.length;\\n\\n\\t\\tvar p = ( l - ( this.closed ? 0 : 1 ) ) * t;\\n\\t\\tvar intPoint = Math.floor( p );\\n\\t\\tvar weight = p - intPoint;\\n\\n\\t\\tif ( this.closed ) {\\n\\n\\t\\t\\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\\n\\n\\t\\t} else if ( weight === 0 && intPoint === l - 1 ) {\\n\\n\\t\\t\\tintPoint = l - 2;\\n\\t\\t\\tweight = 1;\\n\\n\\t\\t}\\n\\n\\t\\tvar p0, p1, p2, p3; // 4 points\\n\\n\\t\\tif ( this.closed || intPoint > 0 ) {\\n\\n\\t\\t\\tp0 = points[ ( intPoint - 1 ) % l ];\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t// extrapolate first point\\n\\t\\t\\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\\n\\t\\t\\tp0 = tmp;\\n\\n\\t\\t}\\n\\n\\t\\tp1 = points[ intPoint % l ];\\n\\t\\tp2 = points[ ( intPoint + 1 ) % l ];\\n\\n\\t\\tif ( this.closed || intPoint + 2 < l ) {\\n\\n\\t\\t\\tp3 = points[ ( intPoint + 2 ) % l ];\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t// extrapolate last point\\n\\t\\t\\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\\n\\t\\t\\tp3 = tmp;\\n\\n\\t\\t}\\n\\n\\t\\tif ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {\\n\\n\\t\\t\\t// init Centripetal / Chordal Catmull-Rom\\n\\t\\t\\tvar pow = this.curveType === 'chordal' ? 0.5 : 0.25;\\n\\t\\t\\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\\n\\t\\t\\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\\n\\t\\t\\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\\n\\n\\t\\t\\t// safety check for repeated points\\n\\t\\t\\tif ( dt1 < 1e-4 ) dt1 = 1.0;\\n\\t\\t\\tif ( dt0 < 1e-4 ) dt0 = dt1;\\n\\t\\t\\tif ( dt2 < 1e-4 ) dt2 = dt1;\\n\\n\\t\\t\\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\\n\\t\\t\\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\\n\\t\\t\\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\\n\\n\\t\\t} else if ( this.curveType === 'catmullrom' ) {\\n\\n\\t\\t\\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );\\n\\t\\t\\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );\\n\\t\\t\\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );\\n\\n\\t\\t}\\n\\n\\t\\tpoint.set(\\n\\t\\t\\tpx.calc( weight ),\\n\\t\\t\\tpy.calc( weight ),\\n\\t\\t\\tpz.calc( weight )\\n\\t\\t);\\n\\n\\t\\treturn point;\\n\\n\\t};\\n\\n\\tCatmullRomCurve3.prototype.copy = function ( source ) {\\n\\n\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\tthis.points = [];\\n\\n\\t\\tfor ( var i = 0, l = source.points.length; i < l; i ++ ) {\\n\\n\\t\\t\\tvar point = source.points[ i ];\\n\\n\\t\\t\\tthis.points.push( point.clone() );\\n\\n\\t\\t}\\n\\n\\t\\tthis.closed = source.closed;\\n\\t\\tthis.curveType = source.curveType;\\n\\t\\tthis.tension = source.tension;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tCatmullRomCurve3.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\tdata.points = [];\\n\\n\\t\\tfor ( var i = 0, l = this.points.length; i < l; i ++ ) {\\n\\n\\t\\t\\tvar point = this.points[ i ];\\n\\t\\t\\tdata.points.push( point.toArray() );\\n\\n\\t\\t}\\n\\n\\t\\tdata.closed = this.closed;\\n\\t\\tdata.curveType = this.curveType;\\n\\t\\tdata.tension = this.tension;\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tCatmullRomCurve3.prototype.fromJSON = function ( json ) {\\n\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\tthis.points = [];\\n\\n\\t\\tfor ( var i = 0, l = json.points.length; i < l; i ++ ) {\\n\\n\\t\\t\\tvar point = json.points[ i ];\\n\\t\\t\\tthis.points.push( new Vector3().fromArray( point ) );\\n\\n\\t\\t}\\n\\n\\t\\tthis.closed = json.closed;\\n\\t\\tthis.curveType = json.curveType;\\n\\t\\tthis.tension = json.tension;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t *\\n\\t * Bezier Curves formulas obtained from\\n\\t * http://en.wikipedia.org/wiki/Bzier_curve\\n\\t */\\n\\n\\tfunction CatmullRom( t, p0, p1, p2, p3 ) {\\n\\n\\t\\tvar v0 = ( p2 - p0 ) * 0.5;\\n\\t\\tvar v1 = ( p3 - p1 ) * 0.5;\\n\\t\\tvar t2 = t * t;\\n\\t\\tvar t3 = t * t2;\\n\\t\\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\\n\\n\\t}\\n\\n\\t//\\n\\n\\tfunction QuadraticBezierP0( t, p ) {\\n\\n\\t\\tvar k = 1 - t;\\n\\t\\treturn k * k * p;\\n\\n\\t}\\n\\n\\tfunction QuadraticBezierP1( t, p ) {\\n\\n\\t\\treturn 2 * ( 1 - t ) * t * p;\\n\\n\\t}\\n\\n\\tfunction QuadraticBezierP2( t, p ) {\\n\\n\\t\\treturn t * t * p;\\n\\n\\t}\\n\\n\\tfunction QuadraticBezier( t, p0, p1, p2 ) {\\n\\n\\t\\treturn QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +\\n\\t\\t\\tQuadraticBezierP2( t, p2 );\\n\\n\\t}\\n\\n\\t//\\n\\n\\tfunction CubicBezierP0( t, p ) {\\n\\n\\t\\tvar k = 1 - t;\\n\\t\\treturn k * k * k * p;\\n\\n\\t}\\n\\n\\tfunction CubicBezierP1( t, p ) {\\n\\n\\t\\tvar k = 1 - t;\\n\\t\\treturn 3 * k * k * t * p;\\n\\n\\t}\\n\\n\\tfunction CubicBezierP2( t, p ) {\\n\\n\\t\\treturn 3 * ( 1 - t ) * t * t * p;\\n\\n\\t}\\n\\n\\tfunction CubicBezierP3( t, p ) {\\n\\n\\t\\treturn t * t * t * p;\\n\\n\\t}\\n\\n\\tfunction CubicBezier( t, p0, p1, p2, p3 ) {\\n\\n\\t\\treturn CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +\\n\\t\\t\\tCubicBezierP3( t, p3 );\\n\\n\\t}\\n\\n\\tfunction CubicBezierCurve( v0, v1, v2, v3 ) {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'CubicBezierCurve';\\n\\n\\t\\tthis.v0 = v0 || new Vector2();\\n\\t\\tthis.v1 = v1 || new Vector2();\\n\\t\\tthis.v2 = v2 || new Vector2();\\n\\t\\tthis.v3 = v3 || new Vector2();\\n\\n\\t}\\n\\n\\tCubicBezierCurve.prototype = Object.create( Curve.prototype );\\n\\tCubicBezierCurve.prototype.constructor = CubicBezierCurve;\\n\\n\\tCubicBezierCurve.prototype.isCubicBezierCurve = true;\\n\\n\\tCubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {\\n\\n\\t\\tvar point = optionalTarget || new Vector2();\\n\\n\\t\\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\\n\\n\\t\\tpoint.set(\\n\\t\\t\\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\\n\\t\\t\\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y )\\n\\t\\t);\\n\\n\\t\\treturn point;\\n\\n\\t};\\n\\n\\tCubicBezierCurve.prototype.copy = function ( source ) {\\n\\n\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\tthis.v0.copy( source.v0 );\\n\\t\\tthis.v1.copy( source.v1 );\\n\\t\\tthis.v2.copy( source.v2 );\\n\\t\\tthis.v3.copy( source.v3 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tCubicBezierCurve.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\tdata.v0 = this.v0.toArray();\\n\\t\\tdata.v1 = this.v1.toArray();\\n\\t\\tdata.v2 = this.v2.toArray();\\n\\t\\tdata.v3 = this.v3.toArray();\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tCubicBezierCurve.prototype.fromJSON = function ( json ) {\\n\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\tthis.v0.fromArray( json.v0 );\\n\\t\\tthis.v1.fromArray( json.v1 );\\n\\t\\tthis.v2.fromArray( json.v2 );\\n\\t\\tthis.v3.fromArray( json.v3 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction CubicBezierCurve3( v0, v1, v2, v3 ) {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'CubicBezierCurve3';\\n\\n\\t\\tthis.v0 = v0 || new Vector3();\\n\\t\\tthis.v1 = v1 || new Vector3();\\n\\t\\tthis.v2 = v2 || new Vector3();\\n\\t\\tthis.v3 = v3 || new Vector3();\\n\\n\\t}\\n\\n\\tCubicBezierCurve3.prototype = Object.create( Curve.prototype );\\n\\tCubicBezierCurve3.prototype.constructor = CubicBezierCurve3;\\n\\n\\tCubicBezierCurve3.prototype.isCubicBezierCurve3 = true;\\n\\n\\tCubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {\\n\\n\\t\\tvar point = optionalTarget || new Vector3();\\n\\n\\t\\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\\n\\n\\t\\tpoint.set(\\n\\t\\t\\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\\n\\t\\t\\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y ),\\n\\t\\t\\tCubicBezier( t, v0.z, v1.z, v2.z, v3.z )\\n\\t\\t);\\n\\n\\t\\treturn point;\\n\\n\\t};\\n\\n\\tCubicBezierCurve3.prototype.copy = function ( source ) {\\n\\n\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\tthis.v0.copy( source.v0 );\\n\\t\\tthis.v1.copy( source.v1 );\\n\\t\\tthis.v2.copy( source.v2 );\\n\\t\\tthis.v3.copy( source.v3 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tCubicBezierCurve3.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\tdata.v0 = this.v0.toArray();\\n\\t\\tdata.v1 = this.v1.toArray();\\n\\t\\tdata.v2 = this.v2.toArray();\\n\\t\\tdata.v3 = this.v3.toArray();\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tCubicBezierCurve3.prototype.fromJSON = function ( json ) {\\n\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\tthis.v0.fromArray( json.v0 );\\n\\t\\tthis.v1.fromArray( json.v1 );\\n\\t\\tthis.v2.fromArray( json.v2 );\\n\\t\\tthis.v3.fromArray( json.v3 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction LineCurve( v1, v2 ) {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'LineCurve';\\n\\n\\t\\tthis.v1 = v1 || new Vector2();\\n\\t\\tthis.v2 = v2 || new Vector2();\\n\\n\\t}\\n\\n\\tLineCurve.prototype = Object.create( Curve.prototype );\\n\\tLineCurve.prototype.constructor = LineCurve;\\n\\n\\tLineCurve.prototype.isLineCurve = true;\\n\\n\\tLineCurve.prototype.getPoint = function ( t, optionalTarget ) {\\n\\n\\t\\tvar point = optionalTarget || new Vector2();\\n\\n\\t\\tif ( t === 1 ) {\\n\\n\\t\\t\\tpoint.copy( this.v2 );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tpoint.copy( this.v2 ).sub( this.v1 );\\n\\t\\t\\tpoint.multiplyScalar( t ).add( this.v1 );\\n\\n\\t\\t}\\n\\n\\t\\treturn point;\\n\\n\\t};\\n\\n\\t// Line curve is linear, so we can overwrite default getPointAt\\n\\n\\tLineCurve.prototype.getPointAt = function ( u, optionalTarget ) {\\n\\n\\t\\treturn this.getPoint( u, optionalTarget );\\n\\n\\t};\\n\\n\\tLineCurve.prototype.getTangent = function ( /* t */ ) {\\n\\n\\t\\tvar tangent = this.v2.clone().sub( this.v1 );\\n\\n\\t\\treturn tangent.normalize();\\n\\n\\t};\\n\\n\\tLineCurve.prototype.copy = function ( source ) {\\n\\n\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\tthis.v1.copy( source.v1 );\\n\\t\\tthis.v2.copy( source.v2 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tLineCurve.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\tdata.v1 = this.v1.toArray();\\n\\t\\tdata.v2 = this.v2.toArray();\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tLineCurve.prototype.fromJSON = function ( json ) {\\n\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\tthis.v1.fromArray( json.v1 );\\n\\t\\tthis.v2.fromArray( json.v2 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction LineCurve3( v1, v2 ) {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'LineCurve3';\\n\\n\\t\\tthis.v1 = v1 || new Vector3();\\n\\t\\tthis.v2 = v2 || new Vector3();\\n\\n\\t}\\n\\n\\tLineCurve3.prototype = Object.create( Curve.prototype );\\n\\tLineCurve3.prototype.constructor = LineCurve3;\\n\\n\\tLineCurve3.prototype.isLineCurve3 = true;\\n\\n\\tLineCurve3.prototype.getPoint = function ( t, optionalTarget ) {\\n\\n\\t\\tvar point = optionalTarget || new Vector3();\\n\\n\\t\\tif ( t === 1 ) {\\n\\n\\t\\t\\tpoint.copy( this.v2 );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tpoint.copy( this.v2 ).sub( this.v1 );\\n\\t\\t\\tpoint.multiplyScalar( t ).add( this.v1 );\\n\\n\\t\\t}\\n\\n\\t\\treturn point;\\n\\n\\t};\\n\\n\\t// Line curve is linear, so we can overwrite default getPointAt\\n\\n\\tLineCurve3.prototype.getPointAt = function ( u, optionalTarget ) {\\n\\n\\t\\treturn this.getPoint( u, optionalTarget );\\n\\n\\t};\\n\\n\\tLineCurve3.prototype.copy = function ( source ) {\\n\\n\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\tthis.v1.copy( source.v1 );\\n\\t\\tthis.v2.copy( source.v2 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tLineCurve3.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\tdata.v1 = this.v1.toArray();\\n\\t\\tdata.v2 = this.v2.toArray();\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tLineCurve3.prototype.fromJSON = function ( json ) {\\n\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\tthis.v1.fromArray( json.v1 );\\n\\t\\tthis.v2.fromArray( json.v2 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction QuadraticBezierCurve( v0, v1, v2 ) {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'QuadraticBezierCurve';\\n\\n\\t\\tthis.v0 = v0 || new Vector2();\\n\\t\\tthis.v1 = v1 || new Vector2();\\n\\t\\tthis.v2 = v2 || new Vector2();\\n\\n\\t}\\n\\n\\tQuadraticBezierCurve.prototype = Object.create( Curve.prototype );\\n\\tQuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;\\n\\n\\tQuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;\\n\\n\\tQuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {\\n\\n\\t\\tvar point = optionalTarget || new Vector2();\\n\\n\\t\\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2;\\n\\n\\t\\tpoint.set(\\n\\t\\t\\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\\n\\t\\t\\tQuadraticBezier( t, v0.y, v1.y, v2.y )\\n\\t\\t);\\n\\n\\t\\treturn point;\\n\\n\\t};\\n\\n\\tQuadraticBezierCurve.prototype.copy = function ( source ) {\\n\\n\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\tthis.v0.copy( source.v0 );\\n\\t\\tthis.v1.copy( source.v1 );\\n\\t\\tthis.v2.copy( source.v2 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tQuadraticBezierCurve.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\tdata.v0 = this.v0.toArray();\\n\\t\\tdata.v1 = this.v1.toArray();\\n\\t\\tdata.v2 = this.v2.toArray();\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tQuadraticBezierCurve.prototype.fromJSON = function ( json ) {\\n\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\tthis.v0.fromArray( json.v0 );\\n\\t\\tthis.v1.fromArray( json.v1 );\\n\\t\\tthis.v2.fromArray( json.v2 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction QuadraticBezierCurve3( v0, v1, v2 ) {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'QuadraticBezierCurve3';\\n\\n\\t\\tthis.v0 = v0 || new Vector3();\\n\\t\\tthis.v1 = v1 || new Vector3();\\n\\t\\tthis.v2 = v2 || new Vector3();\\n\\n\\t}\\n\\n\\tQuadraticBezierCurve3.prototype = Object.create( Curve.prototype );\\n\\tQuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;\\n\\n\\tQuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;\\n\\n\\tQuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {\\n\\n\\t\\tvar point = optionalTarget || new Vector3();\\n\\n\\t\\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2;\\n\\n\\t\\tpoint.set(\\n\\t\\t\\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\\n\\t\\t\\tQuadraticBezier( t, v0.y, v1.y, v2.y ),\\n\\t\\t\\tQuadraticBezier( t, v0.z, v1.z, v2.z )\\n\\t\\t);\\n\\n\\t\\treturn point;\\n\\n\\t};\\n\\n\\tQuadraticBezierCurve3.prototype.copy = function ( source ) {\\n\\n\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\tthis.v0.copy( source.v0 );\\n\\t\\tthis.v1.copy( source.v1 );\\n\\t\\tthis.v2.copy( source.v2 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tQuadraticBezierCurve3.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\tdata.v0 = this.v0.toArray();\\n\\t\\tdata.v1 = this.v1.toArray();\\n\\t\\tdata.v2 = this.v2.toArray();\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tQuadraticBezierCurve3.prototype.fromJSON = function ( json ) {\\n\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\tthis.v0.fromArray( json.v0 );\\n\\t\\tthis.v1.fromArray( json.v1 );\\n\\t\\tthis.v2.fromArray( json.v2 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction SplineCurve( points /* array of Vector2 */ ) {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'SplineCurve';\\n\\n\\t\\tthis.points = points || [];\\n\\n\\t}\\n\\n\\tSplineCurve.prototype = Object.create( Curve.prototype );\\n\\tSplineCurve.prototype.constructor = SplineCurve;\\n\\n\\tSplineCurve.prototype.isSplineCurve = true;\\n\\n\\tSplineCurve.prototype.getPoint = function ( t, optionalTarget ) {\\n\\n\\t\\tvar point = optionalTarget || new Vector2();\\n\\n\\t\\tvar points = this.points;\\n\\t\\tvar p = ( points.length - 1 ) * t;\\n\\n\\t\\tvar intPoint = Math.floor( p );\\n\\t\\tvar weight = p - intPoint;\\n\\n\\t\\tvar p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\\n\\t\\tvar p1 = points[ intPoint ];\\n\\t\\tvar p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\\n\\t\\tvar p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\\n\\n\\t\\tpoint.set(\\n\\t\\t\\tCatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),\\n\\t\\t\\tCatmullRom( weight, p0.y, p1.y, p2.y, p3.y )\\n\\t\\t);\\n\\n\\t\\treturn point;\\n\\n\\t};\\n\\n\\tSplineCurve.prototype.copy = function ( source ) {\\n\\n\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\tthis.points = [];\\n\\n\\t\\tfor ( var i = 0, l = source.points.length; i < l; i ++ ) {\\n\\n\\t\\t\\tvar point = source.points[ i ];\\n\\n\\t\\t\\tthis.points.push( point.clone() );\\n\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tSplineCurve.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\tdata.points = [];\\n\\n\\t\\tfor ( var i = 0, l = this.points.length; i < l; i ++ ) {\\n\\n\\t\\t\\tvar point = this.points[ i ];\\n\\t\\t\\tdata.points.push( point.toArray() );\\n\\n\\t\\t}\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tSplineCurve.prototype.fromJSON = function ( json ) {\\n\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\tthis.points = [];\\n\\n\\t\\tfor ( var i = 0, l = json.points.length; i < l; i ++ ) {\\n\\n\\t\\t\\tvar point = json.points[ i ];\\n\\t\\t\\tthis.points.push( new Vector2().fromArray( point ) );\\n\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\n\\n\\tvar Curves = Object.freeze({\\n\\t\\tArcCurve: ArcCurve,\\n\\t\\tCatmullRomCurve3: CatmullRomCurve3,\\n\\t\\tCubicBezierCurve: CubicBezierCurve,\\n\\t\\tCubicBezierCurve3: CubicBezierCurve3,\\n\\t\\tEllipseCurve: EllipseCurve,\\n\\t\\tLineCurve: LineCurve,\\n\\t\\tLineCurve3: LineCurve3,\\n\\t\\tQuadraticBezierCurve: QuadraticBezierCurve,\\n\\t\\tQuadraticBezierCurve3: QuadraticBezierCurve3,\\n\\t\\tSplineCurve: SplineCurve\\n\\t});\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t *\\n\\t **/\\n\\n\\t/**************************************************************\\n\\t *\\tCurved Path - a curve path is simply a array of connected\\n\\t *  curves, but retains the api of a curve\\n\\t **************************************************************/\\n\\n\\tfunction CurvePath() {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'CurvePath';\\n\\n\\t\\tthis.curves = [];\\n\\t\\tthis.autoClose = false; // Automatically closes the path\\n\\n\\t}\\n\\n\\tCurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {\\n\\n\\t\\tconstructor: CurvePath,\\n\\n\\t\\tadd: function ( curve ) {\\n\\n\\t\\t\\tthis.curves.push( curve );\\n\\n\\t\\t},\\n\\n\\t\\tclosePath: function () {\\n\\n\\t\\t\\t// Add a line curve if start and end of lines are not connected\\n\\t\\t\\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\\n\\t\\t\\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\\n\\n\\t\\t\\tif ( ! startPoint.equals( endPoint ) ) {\\n\\n\\t\\t\\t\\tthis.curves.push( new LineCurve( endPoint, startPoint ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t// To get accurate point with reference to\\n\\t\\t// entire path distance at time t,\\n\\t\\t// following has to be done:\\n\\n\\t\\t// 1. Length of each sub path have to be known\\n\\t\\t// 2. Locate and identify type of curve\\n\\t\\t// 3. Get t for the curve\\n\\t\\t// 4. Return curve.getPointAt(t')\\n\\n\\t\\tgetPoint: function ( t ) {\\n\\n\\t\\t\\tvar d = t * this.getLength();\\n\\t\\t\\tvar curveLengths = this.getCurveLengths();\\n\\t\\t\\tvar i = 0;\\n\\n\\t\\t\\t// To think about boundaries points.\\n\\n\\t\\t\\twhile ( i < curveLengths.length ) {\\n\\n\\t\\t\\t\\tif ( curveLengths[ i ] >= d ) {\\n\\n\\t\\t\\t\\t\\tvar diff = curveLengths[ i ] - d;\\n\\t\\t\\t\\t\\tvar curve = this.curves[ i ];\\n\\n\\t\\t\\t\\t\\tvar segmentLength = curve.getLength();\\n\\t\\t\\t\\t\\tvar u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\\n\\n\\t\\t\\t\\t\\treturn curve.getPointAt( u );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ti ++;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn null;\\n\\n\\t\\t\\t// loop where sum != 0, sum > d , sum+1 <d\\n\\n\\t\\t},\\n\\n\\t\\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\\n\\t\\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\\n\\t\\t// getPoint() depends on getLength\\n\\n\\t\\tgetLength: function () {\\n\\n\\t\\t\\tvar lens = this.getCurveLengths();\\n\\t\\t\\treturn lens[ lens.length - 1 ];\\n\\n\\t\\t},\\n\\n\\t\\t// cacheLengths must be recalculated.\\n\\t\\tupdateArcLengths: function () {\\n\\n\\t\\t\\tthis.needsUpdate = true;\\n\\t\\t\\tthis.cacheLengths = null;\\n\\t\\t\\tthis.getCurveLengths();\\n\\n\\t\\t},\\n\\n\\t\\t// Compute lengths and cache them\\n\\t\\t// We cannot overwrite getLengths() because UtoT mapping uses it.\\n\\n\\t\\tgetCurveLengths: function () {\\n\\n\\t\\t\\t// We use cache values if curves and cache array are same length\\n\\n\\t\\t\\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\\n\\n\\t\\t\\t\\treturn this.cacheLengths;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Get length of sub-curve\\n\\t\\t\\t// Push sums into cached array\\n\\n\\t\\t\\tvar lengths = [], sums = 0;\\n\\n\\t\\t\\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tsums += this.curves[ i ].getLength();\\n\\t\\t\\t\\tlengths.push( sums );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.cacheLengths = lengths;\\n\\n\\t\\t\\treturn lengths;\\n\\n\\t\\t},\\n\\n\\t\\tgetSpacedPoints: function ( divisions ) {\\n\\n\\t\\t\\tif ( divisions === undefined ) divisions = 40;\\n\\n\\t\\t\\tvar points = [];\\n\\n\\t\\t\\tfor ( var i = 0; i <= divisions; i ++ ) {\\n\\n\\t\\t\\t\\tpoints.push( this.getPoint( i / divisions ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.autoClose ) {\\n\\n\\t\\t\\t\\tpoints.push( points[ 0 ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn points;\\n\\n\\t\\t},\\n\\n\\t\\tgetPoints: function ( divisions ) {\\n\\n\\t\\t\\tdivisions = divisions || 12;\\n\\n\\t\\t\\tvar points = [], last;\\n\\n\\t\\t\\tfor ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {\\n\\n\\t\\t\\t\\tvar curve = curves[ i ];\\n\\t\\t\\t\\tvar resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2\\n\\t\\t\\t\\t\\t: ( curve && curve.isLineCurve ) ? 1\\n\\t\\t\\t\\t\\t\\t: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length\\n\\t\\t\\t\\t\\t\\t\\t: divisions;\\n\\n\\t\\t\\t\\tvar pts = curve.getPoints( resolution );\\n\\n\\t\\t\\t\\tfor ( var j = 0; j < pts.length; j ++ ) {\\n\\n\\t\\t\\t\\t\\tvar point = pts[ j ];\\n\\n\\t\\t\\t\\t\\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\\n\\n\\t\\t\\t\\t\\tpoints.push( point );\\n\\t\\t\\t\\t\\tlast = point;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {\\n\\n\\t\\t\\t\\tpoints.push( points[ 0 ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn points;\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.curves = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = source.curves.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar curve = source.curves[ i ];\\n\\n\\t\\t\\t\\tthis.curves.push( curve.clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.autoClose = source.autoClose;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function () {\\n\\n\\t\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\t\\tdata.autoClose = this.autoClose;\\n\\t\\t\\tdata.curves = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar curve = this.curves[ i ];\\n\\t\\t\\t\\tdata.curves.push( curve.toJSON() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t},\\n\\n\\t\\tfromJSON: function ( json ) {\\n\\n\\t\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\t\\tthis.autoClose = json.autoClose;\\n\\t\\t\\tthis.curves = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = json.curves.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar curve = json.curves[ i ];\\n\\t\\t\\t\\tthis.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t * Creates free form 2d path using series of points, lines or curves.\\n\\t **/\\n\\n\\tfunction Path( points ) {\\n\\n\\t\\tCurvePath.call( this );\\n\\n\\t\\tthis.type = 'Path';\\n\\n\\t\\tthis.currentPoint = new Vector2();\\n\\n\\t\\tif ( points ) {\\n\\n\\t\\t\\tthis.setFromPoints( points );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tPath.prototype = Object.assign( Object.create( CurvePath.prototype ), {\\n\\n\\t\\tconstructor: Path,\\n\\n\\t\\tsetFromPoints: function ( points ) {\\n\\n\\t\\t\\tthis.moveTo( points[ 0 ].x, points[ 0 ].y );\\n\\n\\t\\t\\tfor ( var i = 1, l = points.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tthis.lineTo( points[ i ].x, points[ i ].y );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tmoveTo: function ( x, y ) {\\n\\n\\t\\t\\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\\n\\n\\t\\t},\\n\\n\\t\\tlineTo: function ( x, y ) {\\n\\n\\t\\t\\tvar curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\\n\\t\\t\\tthis.curves.push( curve );\\n\\n\\t\\t\\tthis.currentPoint.set( x, y );\\n\\n\\t\\t},\\n\\n\\t\\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\\n\\n\\t\\t\\tvar curve = new QuadraticBezierCurve(\\n\\t\\t\\t\\tthis.currentPoint.clone(),\\n\\t\\t\\t\\tnew Vector2( aCPx, aCPy ),\\n\\t\\t\\t\\tnew Vector2( aX, aY )\\n\\t\\t\\t);\\n\\n\\t\\t\\tthis.curves.push( curve );\\n\\n\\t\\t\\tthis.currentPoint.set( aX, aY );\\n\\n\\t\\t},\\n\\n\\t\\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\\n\\n\\t\\t\\tvar curve = new CubicBezierCurve(\\n\\t\\t\\t\\tthis.currentPoint.clone(),\\n\\t\\t\\t\\tnew Vector2( aCP1x, aCP1y ),\\n\\t\\t\\t\\tnew Vector2( aCP2x, aCP2y ),\\n\\t\\t\\t\\tnew Vector2( aX, aY )\\n\\t\\t\\t);\\n\\n\\t\\t\\tthis.curves.push( curve );\\n\\n\\t\\t\\tthis.currentPoint.set( aX, aY );\\n\\n\\t\\t},\\n\\n\\t\\tsplineThru: function ( pts /*Array of Vector*/ ) {\\n\\n\\t\\t\\tvar npts = [ this.currentPoint.clone() ].concat( pts );\\n\\n\\t\\t\\tvar curve = new SplineCurve( npts );\\n\\t\\t\\tthis.curves.push( curve );\\n\\n\\t\\t\\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\\n\\n\\t\\t},\\n\\n\\t\\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\\n\\n\\t\\t\\tvar x0 = this.currentPoint.x;\\n\\t\\t\\tvar y0 = this.currentPoint.y;\\n\\n\\t\\t\\tthis.absarc( aX + x0, aY + y0, aRadius,\\n\\t\\t\\t\\taStartAngle, aEndAngle, aClockwise );\\n\\n\\t\\t},\\n\\n\\t\\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\\n\\n\\t\\t\\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\\n\\n\\t\\t},\\n\\n\\t\\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\\n\\n\\t\\t\\tvar x0 = this.currentPoint.x;\\n\\t\\t\\tvar y0 = this.currentPoint.y;\\n\\n\\t\\t\\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\\n\\n\\t\\t},\\n\\n\\t\\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\\n\\n\\t\\t\\tvar curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\\n\\n\\t\\t\\tif ( this.curves.length > 0 ) {\\n\\n\\t\\t\\t\\t// if a previous curve is present, attempt to join\\n\\t\\t\\t\\tvar firstPoint = curve.getPoint( 0 );\\n\\n\\t\\t\\t\\tif ( ! firstPoint.equals( this.currentPoint ) ) {\\n\\n\\t\\t\\t\\t\\tthis.lineTo( firstPoint.x, firstPoint.y );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.curves.push( curve );\\n\\n\\t\\t\\tvar lastPoint = curve.getPoint( 1 );\\n\\t\\t\\tthis.currentPoint.copy( lastPoint );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tCurvePath.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.currentPoint.copy( source.currentPoint );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function () {\\n\\n\\t\\t\\tvar data = CurvePath.prototype.toJSON.call( this );\\n\\n\\t\\t\\tdata.currentPoint = this.currentPoint.toArray();\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t},\\n\\n\\t\\tfromJSON: function ( json ) {\\n\\n\\t\\t\\tCurvePath.prototype.fromJSON.call( this, json );\\n\\n\\t\\t\\tthis.currentPoint.fromArray( json.currentPoint );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t * Defines a 2d shape plane using paths.\\n\\t **/\\n\\n\\t// STEP 1 Create a path.\\n\\t// STEP 2 Turn path into shape.\\n\\t// STEP 3 ExtrudeGeometry takes in Shape/Shapes\\n\\t// STEP 3a - Extract points from each shape, turn to vertices\\n\\t// STEP 3b - Triangulate each shape, add faces.\\n\\n\\tfunction Shape( points ) {\\n\\n\\t\\tPath.call( this, points );\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\tthis.type = 'Shape';\\n\\n\\t\\tthis.holes = [];\\n\\n\\t}\\n\\n\\tShape.prototype = Object.assign( Object.create( Path.prototype ), {\\n\\n\\t\\tconstructor: Shape,\\n\\n\\t\\tgetPointsHoles: function ( divisions ) {\\n\\n\\t\\t\\tvar holesPts = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn holesPts;\\n\\n\\t\\t},\\n\\n\\t\\t// get points of shape and holes (keypoints based on segments parameter)\\n\\n\\t\\textractPoints: function ( divisions ) {\\n\\n\\t\\t\\treturn {\\n\\n\\t\\t\\t\\tshape: this.getPoints( divisions ),\\n\\t\\t\\t\\tholes: this.getPointsHoles( divisions )\\n\\n\\t\\t\\t};\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tPath.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.holes = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = source.holes.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar hole = source.holes[ i ];\\n\\n\\t\\t\\t\\tthis.holes.push( hole.clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function () {\\n\\n\\t\\t\\tvar data = Path.prototype.toJSON.call( this );\\n\\n\\t\\t\\tdata.uuid = this.uuid;\\n\\t\\t\\tdata.holes = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar hole = this.holes[ i ];\\n\\t\\t\\t\\tdata.holes.push( hole.toJSON() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t},\\n\\n\\t\\tfromJSON: function ( json ) {\\n\\n\\t\\t\\tPath.prototype.fromJSON.call( this, json );\\n\\n\\t\\t\\tthis.uuid = json.uuid;\\n\\t\\t\\tthis.holes = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = json.holes.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar hole = json.holes[ i ];\\n\\t\\t\\t\\tthis.holes.push( new Path().fromJSON( hole ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction Light( color, intensity ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Light';\\n\\n\\t\\tthis.color = new Color( color );\\n\\t\\tthis.intensity = intensity !== undefined ? intensity : 1;\\n\\n\\t\\tthis.receiveShadow = undefined;\\n\\n\\t}\\n\\n\\tLight.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Light,\\n\\n\\t\\tisLight: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tObject3D.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.color.copy( source.color );\\n\\t\\t\\tthis.intensity = source.intensity;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( meta ) {\\n\\n\\t\\t\\tvar data = Object3D.prototype.toJSON.call( this, meta );\\n\\n\\t\\t\\tdata.object.color = this.color.getHex();\\n\\t\\t\\tdata.object.intensity = this.intensity;\\n\\n\\t\\t\\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\\n\\n\\t\\t\\tif ( this.distance !== undefined ) data.object.distance = this.distance;\\n\\t\\t\\tif ( this.angle !== undefined ) data.object.angle = this.angle;\\n\\t\\t\\tif ( this.decay !== undefined ) data.object.decay = this.decay;\\n\\t\\t\\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\\n\\n\\t\\t\\tif ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction HemisphereLight( skyColor, groundColor, intensity ) {\\n\\n\\t\\tLight.call( this, skyColor, intensity );\\n\\n\\t\\tthis.type = 'HemisphereLight';\\n\\n\\t\\tthis.castShadow = undefined;\\n\\n\\t\\tthis.position.copy( Object3D.DefaultUp );\\n\\t\\tthis.updateMatrix();\\n\\n\\t\\tthis.groundColor = new Color( groundColor );\\n\\n\\t}\\n\\n\\tHemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {\\n\\n\\t\\tconstructor: HemisphereLight,\\n\\n\\t\\tisHemisphereLight: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tLight.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.groundColor.copy( source.groundColor );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction LightShadow( camera ) {\\n\\n\\t\\tthis.camera = camera;\\n\\n\\t\\tthis.bias = 0;\\n\\t\\tthis.radius = 1;\\n\\n\\t\\tthis.mapSize = new Vector2( 512, 512 );\\n\\n\\t\\tthis.map = null;\\n\\t\\tthis.matrix = new Matrix4();\\n\\n\\t}\\n\\n\\tObject.assign( LightShadow.prototype, {\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tthis.camera = source.camera.clone();\\n\\n\\t\\t\\tthis.bias = source.bias;\\n\\t\\t\\tthis.radius = source.radius;\\n\\n\\t\\t\\tthis.mapSize.copy( source.mapSize );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function () {\\n\\n\\t\\t\\tvar object = {};\\n\\n\\t\\t\\tif ( this.bias !== 0 ) object.bias = this.bias;\\n\\t\\t\\tif ( this.radius !== 1 ) object.radius = this.radius;\\n\\t\\t\\tif ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();\\n\\n\\t\\t\\tobject.camera = this.camera.toJSON( false ).object;\\n\\t\\t\\tdelete object.camera.matrix;\\n\\n\\t\\t\\treturn object;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction SpotLightShadow() {\\n\\n\\t\\tLightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );\\n\\n\\t}\\n\\n\\tSpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\\n\\n\\t\\tconstructor: SpotLightShadow,\\n\\n\\t\\tisSpotLightShadow: true,\\n\\n\\t\\tupdate: function ( light ) {\\n\\n\\t\\t\\tvar camera = this.camera;\\n\\n\\t\\t\\tvar fov = _Math.RAD2DEG * 2 * light.angle;\\n\\t\\t\\tvar aspect = this.mapSize.width / this.mapSize.height;\\n\\t\\t\\tvar far = light.distance || camera.far;\\n\\n\\t\\t\\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\\n\\n\\t\\t\\t\\tcamera.fov = fov;\\n\\t\\t\\t\\tcamera.aspect = aspect;\\n\\t\\t\\t\\tcamera.far = far;\\n\\t\\t\\t\\tcamera.updateProjectionMatrix();\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction SpotLight( color, intensity, distance, angle, penumbra, decay ) {\\n\\n\\t\\tLight.call( this, color, intensity );\\n\\n\\t\\tthis.type = 'SpotLight';\\n\\n\\t\\tthis.position.copy( Object3D.DefaultUp );\\n\\t\\tthis.updateMatrix();\\n\\n\\t\\tthis.target = new Object3D();\\n\\n\\t\\tObject.defineProperty( this, 'power', {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\t// intensity = power per solid angle.\\n\\t\\t\\t\\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\\n\\t\\t\\t\\treturn this.intensity * Math.PI;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( power ) {\\n\\n\\t\\t\\t\\t// intensity = power per solid angle.\\n\\t\\t\\t\\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\\n\\t\\t\\t\\tthis.intensity = power / Math.PI;\\n\\n\\t\\t\\t}\\n\\t\\t} );\\n\\n\\t\\tthis.distance = ( distance !== undefined ) ? distance : 0;\\n\\t\\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\\n\\t\\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\\n\\t\\tthis.decay = ( decay !== undefined ) ? decay : 1;\\t// for physically correct lights, should be 2.\\n\\n\\t\\tthis.shadow = new SpotLightShadow();\\n\\n\\t}\\n\\n\\tSpotLight.prototype = Object.assign( Object.create( Light.prototype ), {\\n\\n\\t\\tconstructor: SpotLight,\\n\\n\\t\\tisSpotLight: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tLight.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.distance = source.distance;\\n\\t\\t\\tthis.angle = source.angle;\\n\\t\\t\\tthis.penumbra = source.penumbra;\\n\\t\\t\\tthis.decay = source.decay;\\n\\n\\t\\t\\tthis.target = source.target.clone();\\n\\n\\t\\t\\tthis.shadow = source.shadow.clone();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\n\\tfunction PointLight( color, intensity, distance, decay ) {\\n\\n\\t\\tLight.call( this, color, intensity );\\n\\n\\t\\tthis.type = 'PointLight';\\n\\n\\t\\tObject.defineProperty( this, 'power', {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\t// intensity = power per solid angle.\\n\\t\\t\\t\\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\\n\\t\\t\\t\\treturn this.intensity * 4 * Math.PI;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( power ) {\\n\\n\\t\\t\\t\\t// intensity = power per solid angle.\\n\\t\\t\\t\\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\\n\\t\\t\\t\\tthis.intensity = power / ( 4 * Math.PI );\\n\\n\\t\\t\\t}\\n\\t\\t} );\\n\\n\\t\\tthis.distance = ( distance !== undefined ) ? distance : 0;\\n\\t\\tthis.decay = ( decay !== undefined ) ? decay : 1;\\t// for physically correct lights, should be 2.\\n\\n\\t\\tthis.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );\\n\\n\\t}\\n\\n\\tPointLight.prototype = Object.assign( Object.create( Light.prototype ), {\\n\\n\\t\\tconstructor: PointLight,\\n\\n\\t\\tisPointLight: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tLight.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.distance = source.distance;\\n\\t\\t\\tthis.decay = source.decay;\\n\\n\\t\\t\\tthis.shadow = source.shadow.clone();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction DirectionalLightShadow( ) {\\n\\n\\t\\tLightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\\n\\n\\t}\\n\\n\\tDirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\\n\\n\\t\\tconstructor: DirectionalLightShadow\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction DirectionalLight( color, intensity ) {\\n\\n\\t\\tLight.call( this, color, intensity );\\n\\n\\t\\tthis.type = 'DirectionalLight';\\n\\n\\t\\tthis.position.copy( Object3D.DefaultUp );\\n\\t\\tthis.updateMatrix();\\n\\n\\t\\tthis.target = new Object3D();\\n\\n\\t\\tthis.shadow = new DirectionalLightShadow();\\n\\n\\t}\\n\\n\\tDirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {\\n\\n\\t\\tconstructor: DirectionalLight,\\n\\n\\t\\tisDirectionalLight: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tLight.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.target = source.target.clone();\\n\\n\\t\\t\\tthis.shadow = source.shadow.clone();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction AmbientLight( color, intensity ) {\\n\\n\\t\\tLight.call( this, color, intensity );\\n\\n\\t\\tthis.type = 'AmbientLight';\\n\\n\\t\\tthis.castShadow = undefined;\\n\\n\\t}\\n\\n\\tAmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {\\n\\n\\t\\tconstructor: AmbientLight,\\n\\n\\t\\tisAmbientLight: true\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author abelnation / http://github.com/abelnation\\n\\t */\\n\\n\\tfunction RectAreaLight( color, intensity, width, height ) {\\n\\n\\t\\tLight.call( this, color, intensity );\\n\\n\\t\\tthis.type = 'RectAreaLight';\\n\\n\\t\\tthis.position.set( 0, 1, 0 );\\n\\t\\tthis.updateMatrix();\\n\\n\\t\\tthis.width = ( width !== undefined ) ? width : 10;\\n\\t\\tthis.height = ( height !== undefined ) ? height : 10;\\n\\n\\t\\t// TODO (abelnation): distance/decay\\n\\n\\t\\t// TODO (abelnation): update method for RectAreaLight to update transform to lookat target\\n\\n\\t\\t// TODO (abelnation): shadows\\n\\n\\t}\\n\\n\\t// TODO (abelnation): RectAreaLight update when light shape is changed\\n\\tRectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {\\n\\n\\t\\tconstructor: RectAreaLight,\\n\\n\\t\\tisRectAreaLight: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tLight.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.width = source.width;\\n\\t\\t\\tthis.height = source.height;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( meta ) {\\n\\n\\t\\t\\tvar data = Light.prototype.toJSON.call( this, meta );\\n\\n\\t\\t\\tdata.object.width = this.width;\\n\\t\\t\\tdata.object.height = this.height;\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * A Track that interpolates Strings\\n\\t *\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction StringKeyframeTrack( name, times, values, interpolation ) {\\n\\n\\t\\tKeyframeTrack.call( this, name, times, values, interpolation );\\n\\n\\t}\\n\\n\\tStringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\n\\n\\t\\tconstructor: StringKeyframeTrack,\\n\\n\\t\\tValueTypeName: 'string',\\n\\t\\tValueBufferType: Array,\\n\\n\\t\\tDefaultInterpolation: InterpolateDiscrete,\\n\\n\\t\\tInterpolantFactoryMethodLinear: undefined,\\n\\n\\t\\tInterpolantFactoryMethodSmooth: undefined\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * A Track of Boolean keyframe values.\\n\\t *\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction BooleanKeyframeTrack( name, times, values ) {\\n\\n\\t\\tKeyframeTrack.call( this, name, times, values );\\n\\n\\t}\\n\\n\\tBooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\n\\n\\t\\tconstructor: BooleanKeyframeTrack,\\n\\n\\t\\tValueTypeName: 'bool',\\n\\t\\tValueBufferType: Array,\\n\\n\\t\\tDefaultInterpolation: InterpolateDiscrete,\\n\\n\\t\\tInterpolantFactoryMethodLinear: undefined,\\n\\t\\tInterpolantFactoryMethodSmooth: undefined\\n\\n\\t\\t// Note: Actually this track could have a optimized / compressed\\n\\t\\t// representation of a single value and a custom interpolant that\\n\\t\\t// computes \\\"firstValue ^ isOdd( index )\\\".\\n\\n\\t} );\\n\\n\\t/**\\n\\t * Abstract base class of interpolants over parametric samples.\\n\\t *\\n\\t * The parameter domain is one dimensional, typically the time or a path\\n\\t * along a curve defined by the data.\\n\\t *\\n\\t * The sample values can have any dimensionality and derived classes may\\n\\t * apply special interpretations to the data.\\n\\t *\\n\\t * This class provides the interval seek in a Template Method, deferring\\n\\t * the actual interpolation to derived classes.\\n\\t *\\n\\t * Time complexity is O(1) for linear access crossing at most two points\\n\\t * and O(log N) for random access, where N is the number of positions.\\n\\t *\\n\\t * References:\\n\\t *\\n\\t * \\t\\thttp://www.oodesign.com/template-method-pattern.html\\n\\t *\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\\n\\n\\t\\tthis.parameterPositions = parameterPositions;\\n\\t\\tthis._cachedIndex = 0;\\n\\n\\t\\tthis.resultBuffer = resultBuffer !== undefined ?\\n\\t\\t\\tresultBuffer : new sampleValues.constructor( sampleSize );\\n\\t\\tthis.sampleValues = sampleValues;\\n\\t\\tthis.valueSize = sampleSize;\\n\\n\\t}\\n\\n\\tObject.assign( Interpolant.prototype, {\\n\\n\\t\\tevaluate: function ( t ) {\\n\\n\\t\\t\\tvar pp = this.parameterPositions,\\n\\t\\t\\t\\ti1 = this._cachedIndex,\\n\\n\\t\\t\\t\\tt1 = pp[ i1 ],\\n\\t\\t\\t\\tt0 = pp[ i1 - 1 ];\\n\\n\\t\\t\\tvalidate_interval: {\\n\\n\\t\\t\\t\\tseek: {\\n\\n\\t\\t\\t\\t\\tvar right;\\n\\n\\t\\t\\t\\t\\tlinear_scan: {\\n\\n\\t\\t\\t\\t\\t\\t//- See http://jsperf.com/comparison-to-undefined/3\\n\\t\\t\\t\\t\\t\\t//- slower code:\\n\\t\\t\\t\\t\\t\\t//-\\n\\t\\t\\t\\t\\t\\t//- \\t\\t\\t\\tif ( t >= t1 || t1 === undefined ) {\\n\\t\\t\\t\\t\\t\\tforward_scan: if ( ! ( t < t1 ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var giveUpAt = i1 + 2; ; ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( t1 === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( t < t0 ) break forward_scan;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// after end\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ti1 = pp.length;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthis._cachedIndex = i1;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturn this.afterEnd_( i1 - 1, t, t0 );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( i1 === giveUpAt ) break; // this loop\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tt0 = t1;\\n\\t\\t\\t\\t\\t\\t\\t\\tt1 = pp[ ++ i1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( t < t1 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// we have arrived at the sought interval\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak seek;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t// prepare binary search on the right side of the index\\n\\t\\t\\t\\t\\t\\t\\tright = pp.length;\\n\\t\\t\\t\\t\\t\\t\\tbreak linear_scan;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t//- slower code:\\n\\t\\t\\t\\t\\t\\t//-\\t\\t\\t\\t\\tif ( t < t0 || t0 === undefined ) {\\n\\t\\t\\t\\t\\t\\tif ( ! ( t >= t0 ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// looping?\\n\\n\\t\\t\\t\\t\\t\\t\\tvar t1global = pp[ 1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( t < t1global ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\ti1 = 2; // + 1, using the scan for the details\\n\\t\\t\\t\\t\\t\\t\\t\\tt0 = t1global;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t// linear reverse scan\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var giveUpAt = i1 - 2; ; ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( t0 === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// before start\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthis._cachedIndex = 0;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturn this.beforeStart_( 0, t, t1 );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( i1 === giveUpAt ) break; // this loop\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tt1 = t0;\\n\\t\\t\\t\\t\\t\\t\\t\\tt0 = pp[ -- i1 - 1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( t >= t0 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// we have arrived at the sought interval\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak seek;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t// prepare binary search on the left side of the index\\n\\t\\t\\t\\t\\t\\t\\tright = i1;\\n\\t\\t\\t\\t\\t\\t\\ti1 = 0;\\n\\t\\t\\t\\t\\t\\t\\tbreak linear_scan;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// the interval is valid\\n\\n\\t\\t\\t\\t\\t\\tbreak validate_interval;\\n\\n\\t\\t\\t\\t\\t} // linear scan\\n\\n\\t\\t\\t\\t\\t// binary search\\n\\n\\t\\t\\t\\t\\twhile ( i1 < right ) {\\n\\n\\t\\t\\t\\t\\t\\tvar mid = ( i1 + right ) >>> 1;\\n\\n\\t\\t\\t\\t\\t\\tif ( t < pp[ mid ] ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tright = mid;\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\ti1 = mid + 1;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tt1 = pp[ i1 ];\\n\\t\\t\\t\\t\\tt0 = pp[ i1 - 1 ];\\n\\n\\t\\t\\t\\t\\t// check boundary cases, again\\n\\n\\t\\t\\t\\t\\tif ( t0 === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tthis._cachedIndex = 0;\\n\\t\\t\\t\\t\\t\\treturn this.beforeStart_( 0, t, t1 );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( t1 === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\ti1 = pp.length;\\n\\t\\t\\t\\t\\t\\tthis._cachedIndex = i1;\\n\\t\\t\\t\\t\\t\\treturn this.afterEnd_( i1 - 1, t0, t );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} // seek\\n\\n\\t\\t\\t\\tthis._cachedIndex = i1;\\n\\n\\t\\t\\t\\tthis.intervalChanged_( i1, t0, t1 );\\n\\n\\t\\t\\t} // validate_interval\\n\\n\\t\\t\\treturn this.interpolate_( i1, t0, t, t1 );\\n\\n\\t\\t},\\n\\n\\t\\tsettings: null, // optional, subclass-specific settings structure\\n\\t\\t// Note: The indirection allows central control of many interpolants.\\n\\n\\t\\t// --- Protected interface\\n\\n\\t\\tDefaultSettings_: {},\\n\\n\\t\\tgetSettings_: function () {\\n\\n\\t\\t\\treturn this.settings || this.DefaultSettings_;\\n\\n\\t\\t},\\n\\n\\t\\tcopySampleValue_: function ( index ) {\\n\\n\\t\\t\\t// copies a sample value to the result buffer\\n\\n\\t\\t\\tvar result = this.resultBuffer,\\n\\t\\t\\t\\tvalues = this.sampleValues,\\n\\t\\t\\t\\tstride = this.valueSize,\\n\\t\\t\\t\\toffset = index * stride;\\n\\n\\t\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\n\\n\\t\\t\\t\\tresult[ i ] = values[ offset + i ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\n\\t\\t},\\n\\n\\t\\t// Template methods for derived classes:\\n\\n\\t\\tinterpolate_: function ( /* i1, t0, t, t1 */ ) {\\n\\n\\t\\t\\tthrow new Error( 'call to abstract method' );\\n\\t\\t\\t// implementations shall return this.resultBuffer\\n\\n\\t\\t},\\n\\n\\t\\tintervalChanged_: function ( /* i1, t0, t1 */ ) {\\n\\n\\t\\t\\t// empty\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//!\\\\ DECLARE ALIAS AFTER assign prototype !\\n\\tObject.assign( Interpolant.prototype, {\\n\\n\\t\\t//( 0, t, t0 ), returns this.resultBuffer\\n\\t\\tbeforeStart_: Interpolant.prototype.copySampleValue_,\\n\\n\\t\\t//( N-1, tN-1, t ), returns this.resultBuffer\\n\\t\\tafterEnd_: Interpolant.prototype.copySampleValue_,\\n\\n\\t} );\\n\\n\\t/**\\n\\t * Spherical linear unit quaternion interpolant.\\n\\t *\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\\n\\n\\t\\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\\n\\n\\t}\\n\\n\\tQuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\\n\\n\\t\\tconstructor: QuaternionLinearInterpolant,\\n\\n\\t\\tinterpolate_: function ( i1, t0, t, t1 ) {\\n\\n\\t\\t\\tvar result = this.resultBuffer,\\n\\t\\t\\t\\tvalues = this.sampleValues,\\n\\t\\t\\t\\tstride = this.valueSize,\\n\\n\\t\\t\\t\\toffset = i1 * stride,\\n\\n\\t\\t\\t\\talpha = ( t - t0 ) / ( t1 - t0 );\\n\\n\\t\\t\\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\\n\\n\\t\\t\\t\\tQuaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * A Track of quaternion keyframe values.\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction QuaternionKeyframeTrack( name, times, values, interpolation ) {\\n\\n\\t\\tKeyframeTrack.call( this, name, times, values, interpolation );\\n\\n\\t}\\n\\n\\tQuaternionKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\n\\n\\t\\tconstructor: QuaternionKeyframeTrack,\\n\\n\\t\\tValueTypeName: 'quaternion',\\n\\n\\t\\t// ValueBufferType is inherited\\n\\n\\t\\tDefaultInterpolation: InterpolateLinear,\\n\\n\\t\\tInterpolantFactoryMethodLinear: function ( result ) {\\n\\n\\t\\t\\treturn new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );\\n\\n\\t\\t},\\n\\n\\t\\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * A Track of keyframe values that represent color.\\n\\t *\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction ColorKeyframeTrack( name, times, values, interpolation ) {\\n\\n\\t\\tKeyframeTrack.call( this, name, times, values, interpolation );\\n\\n\\t}\\n\\n\\tColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\n\\n\\t\\tconstructor: ColorKeyframeTrack,\\n\\n\\t\\tValueTypeName: 'color'\\n\\n\\t\\t// ValueBufferType is inherited\\n\\n\\t\\t// DefaultInterpolation is inherited\\n\\n\\t\\t// Note: Very basic implementation and nothing special yet.\\n\\t\\t// However, this is the place for color space parameterization.\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * A Track of numeric keyframe values.\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction NumberKeyframeTrack( name, times, values, interpolation ) {\\n\\n\\t\\tKeyframeTrack.call( this, name, times, values, interpolation );\\n\\n\\t}\\n\\n\\tNumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\n\\n\\t\\tconstructor: NumberKeyframeTrack,\\n\\n\\t\\tValueTypeName: 'number'\\n\\n\\t\\t// ValueBufferType is inherited\\n\\n\\t\\t// DefaultInterpolation is inherited\\n\\n\\t} );\\n\\n\\t/**\\n\\t * Fast and simple cubic spline interpolant.\\n\\t *\\n\\t * It was derived from a Hermitian construction setting the first derivative\\n\\t * at each sample position to the linear slope between neighboring positions\\n\\t * over their parameter interval.\\n\\t *\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\\n\\n\\t\\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\\n\\n\\t\\tthis._weightPrev = - 0;\\n\\t\\tthis._offsetPrev = - 0;\\n\\t\\tthis._weightNext = - 0;\\n\\t\\tthis._offsetNext = - 0;\\n\\n\\t}\\n\\n\\tCubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\\n\\n\\t\\tconstructor: CubicInterpolant,\\n\\n\\t\\tDefaultSettings_: {\\n\\n\\t\\t\\tendingStart: ZeroCurvatureEnding,\\n\\t\\t\\tendingEnd: ZeroCurvatureEnding\\n\\n\\t\\t},\\n\\n\\t\\tintervalChanged_: function ( i1, t0, t1 ) {\\n\\n\\t\\t\\tvar pp = this.parameterPositions,\\n\\t\\t\\t\\tiPrev = i1 - 2,\\n\\t\\t\\t\\tiNext = i1 + 1,\\n\\n\\t\\t\\t\\ttPrev = pp[ iPrev ],\\n\\t\\t\\t\\ttNext = pp[ iNext ];\\n\\n\\t\\t\\tif ( tPrev === undefined ) {\\n\\n\\t\\t\\t\\tswitch ( this.getSettings_().endingStart ) {\\n\\n\\t\\t\\t\\t\\tcase ZeroSlopeEnding:\\n\\n\\t\\t\\t\\t\\t\\t// f'(t0) = 0\\n\\t\\t\\t\\t\\t\\tiPrev = i1;\\n\\t\\t\\t\\t\\t\\ttPrev = 2 * t0 - t1;\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase WrapAroundEnding:\\n\\n\\t\\t\\t\\t\\t\\t// use the other end of the curve\\n\\t\\t\\t\\t\\t\\tiPrev = pp.length - 2;\\n\\t\\t\\t\\t\\t\\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tdefault: // ZeroCurvatureEnding\\n\\n\\t\\t\\t\\t\\t\\t// f''(t0) = 0 a.k.a. Natural Spline\\n\\t\\t\\t\\t\\t\\tiPrev = i1;\\n\\t\\t\\t\\t\\t\\ttPrev = t1;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( tNext === undefined ) {\\n\\n\\t\\t\\t\\tswitch ( this.getSettings_().endingEnd ) {\\n\\n\\t\\t\\t\\t\\tcase ZeroSlopeEnding:\\n\\n\\t\\t\\t\\t\\t\\t// f'(tN) = 0\\n\\t\\t\\t\\t\\t\\tiNext = i1;\\n\\t\\t\\t\\t\\t\\ttNext = 2 * t1 - t0;\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase WrapAroundEnding:\\n\\n\\t\\t\\t\\t\\t\\t// use the other end of the curve\\n\\t\\t\\t\\t\\t\\tiNext = 1;\\n\\t\\t\\t\\t\\t\\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tdefault: // ZeroCurvatureEnding\\n\\n\\t\\t\\t\\t\\t\\t// f''(tN) = 0, a.k.a. Natural Spline\\n\\t\\t\\t\\t\\t\\tiNext = i1 - 1;\\n\\t\\t\\t\\t\\t\\ttNext = t0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar halfDt = ( t1 - t0 ) * 0.5,\\n\\t\\t\\t\\tstride = this.valueSize;\\n\\n\\t\\t\\tthis._weightPrev = halfDt / ( t0 - tPrev );\\n\\t\\t\\tthis._weightNext = halfDt / ( tNext - t1 );\\n\\t\\t\\tthis._offsetPrev = iPrev * stride;\\n\\t\\t\\tthis._offsetNext = iNext * stride;\\n\\n\\t\\t},\\n\\n\\t\\tinterpolate_: function ( i1, t0, t, t1 ) {\\n\\n\\t\\t\\tvar result = this.resultBuffer,\\n\\t\\t\\t\\tvalues = this.sampleValues,\\n\\t\\t\\t\\tstride = this.valueSize,\\n\\n\\t\\t\\t\\to1 = i1 * stride,\\t\\to0 = o1 - stride,\\n\\t\\t\\t\\toP = this._offsetPrev, \\toN = this._offsetNext,\\n\\t\\t\\t\\twP = this._weightPrev,\\twN = this._weightNext,\\n\\n\\t\\t\\t\\tp = ( t - t0 ) / ( t1 - t0 ),\\n\\t\\t\\t\\tpp = p * p,\\n\\t\\t\\t\\tppp = pp * p;\\n\\n\\t\\t\\t// evaluate polynomials\\n\\n\\t\\t\\tvar sP = - wP * ppp + 2 * wP * pp - wP * p;\\n\\t\\t\\tvar s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;\\n\\t\\t\\tvar s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;\\n\\t\\t\\tvar sN = wN * ppp - wN * pp;\\n\\n\\t\\t\\t// combine data linearly\\n\\n\\t\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\n\\n\\t\\t\\t\\tresult[ i ] =\\n\\t\\t\\t\\t\\t\\tsP * values[ oP + i ] +\\n\\t\\t\\t\\t\\t\\ts0 * values[ o0 + i ] +\\n\\t\\t\\t\\t\\t\\ts1 * values[ o1 + i ] +\\n\\t\\t\\t\\t\\t\\tsN * values[ oN + i ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\\n\\n\\t\\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\\n\\n\\t}\\n\\n\\tLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\\n\\n\\t\\tconstructor: LinearInterpolant,\\n\\n\\t\\tinterpolate_: function ( i1, t0, t, t1 ) {\\n\\n\\t\\t\\tvar result = this.resultBuffer,\\n\\t\\t\\t\\tvalues = this.sampleValues,\\n\\t\\t\\t\\tstride = this.valueSize,\\n\\n\\t\\t\\t\\toffset1 = i1 * stride,\\n\\t\\t\\t\\toffset0 = offset1 - stride,\\n\\n\\t\\t\\t\\tweight1 = ( t - t0 ) / ( t1 - t0 ),\\n\\t\\t\\t\\tweight0 = 1 - weight1;\\n\\n\\t\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\n\\n\\t\\t\\t\\tresult[ i ] =\\n\\t\\t\\t\\t\\t\\tvalues[ offset0 + i ] * weight0 +\\n\\t\\t\\t\\t\\t\\tvalues[ offset1 + i ] * weight1;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * Interpolant that evaluates to the sample value at the position preceeding\\n\\t * the parameter.\\n\\t *\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\\n\\n\\t\\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\\n\\n\\t}\\n\\n\\tDiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\\n\\n\\t\\tconstructor: DiscreteInterpolant,\\n\\n\\t\\tinterpolate_: function ( i1 /*, t0, t, t1 */ ) {\\n\\n\\t\\t\\treturn this.copySampleValue_( i1 - 1 );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author tschw\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t */\\n\\n\\tvar AnimationUtils = {\\n\\n\\t\\t// same as Array.prototype.slice, but also works on typed arrays\\n\\t\\tarraySlice: function ( array, from, to ) {\\n\\n\\t\\t\\tif ( AnimationUtils.isTypedArray( array ) ) {\\n\\n\\t\\t\\t\\t// in ios9 array.subarray(from, undefined) will return empty array\\n\\t\\t\\t\\t// but array.subarray(from) or array.subarray(from, len) is correct\\n\\t\\t\\t\\treturn new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn array.slice( from, to );\\n\\n\\t\\t},\\n\\n\\t\\t// converts an array to a specific type\\n\\t\\tconvertArray: function ( array, type, forceClone ) {\\n\\n\\t\\t\\tif ( ! array || // let 'undefined' and 'null' pass\\n\\t\\t\\t\\t\\t! forceClone && array.constructor === type ) return array;\\n\\n\\t\\t\\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\\n\\n\\t\\t\\t\\treturn new type( array ); // create typed array\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn Array.prototype.slice.call( array ); // create Array\\n\\n\\t\\t},\\n\\n\\t\\tisTypedArray: function ( object ) {\\n\\n\\t\\t\\treturn ArrayBuffer.isView( object ) &&\\n\\t\\t\\t\\t\\t! ( object instanceof DataView );\\n\\n\\t\\t},\\n\\n\\t\\t// returns an array by which times and values can be sorted\\n\\t\\tgetKeyframeOrder: function ( times ) {\\n\\n\\t\\t\\tfunction compareTime( i, j ) {\\n\\n\\t\\t\\t\\treturn times[ i ] - times[ j ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar n = times.length;\\n\\t\\t\\tvar result = new Array( n );\\n\\t\\t\\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\\n\\n\\t\\t\\tresult.sort( compareTime );\\n\\n\\t\\t\\treturn result;\\n\\n\\t\\t},\\n\\n\\t\\t// uses the array previously returned by 'getKeyframeOrder' to sort data\\n\\t\\tsortedArray: function ( values, stride, order ) {\\n\\n\\t\\t\\tvar nValues = values.length;\\n\\t\\t\\tvar result = new values.constructor( nValues );\\n\\n\\t\\t\\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\\n\\n\\t\\t\\t\\tvar srcOffset = order[ i ] * stride;\\n\\n\\t\\t\\t\\tfor ( var j = 0; j !== stride; ++ j ) {\\n\\n\\t\\t\\t\\t\\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\n\\t\\t},\\n\\n\\t\\t// function for parsing AOS keyframe formats\\n\\t\\tflattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {\\n\\n\\t\\t\\tvar i = 1, key = jsonKeys[ 0 ];\\n\\n\\t\\t\\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\\n\\n\\t\\t\\t\\tkey = jsonKeys[ i ++ ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( key === undefined ) return; // no data\\n\\n\\t\\t\\tvar value = key[ valuePropertyName ];\\n\\t\\t\\tif ( value === undefined ) return; // no data\\n\\n\\t\\t\\tif ( Array.isArray( value ) ) {\\n\\n\\t\\t\\t\\tdo {\\n\\n\\t\\t\\t\\t\\tvalue = key[ valuePropertyName ];\\n\\n\\t\\t\\t\\t\\tif ( value !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\ttimes.push( key.time );\\n\\t\\t\\t\\t\\t\\tvalues.push.apply( values, value ); // push all elements\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tkey = jsonKeys[ i ++ ];\\n\\n\\t\\t\\t\\t} while ( key !== undefined );\\n\\n\\t\\t\\t} else if ( value.toArray !== undefined ) {\\n\\n\\t\\t\\t\\t// ...assume THREE.Math-ish\\n\\n\\t\\t\\t\\tdo {\\n\\n\\t\\t\\t\\t\\tvalue = key[ valuePropertyName ];\\n\\n\\t\\t\\t\\t\\tif ( value !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\ttimes.push( key.time );\\n\\t\\t\\t\\t\\t\\tvalue.toArray( values, values.length );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tkey = jsonKeys[ i ++ ];\\n\\n\\t\\t\\t\\t} while ( key !== undefined );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// otherwise push as-is\\n\\n\\t\\t\\t\\tdo {\\n\\n\\t\\t\\t\\t\\tvalue = key[ valuePropertyName ];\\n\\n\\t\\t\\t\\t\\tif ( value !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\ttimes.push( key.time );\\n\\t\\t\\t\\t\\t\\tvalues.push( value );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tkey = jsonKeys[ i ++ ];\\n\\n\\t\\t\\t\\t} while ( key !== undefined );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t *\\n\\t * A timed sequence of keyframes for a specific property.\\n\\t *\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction KeyframeTrack( name, times, values, interpolation ) {\\n\\n\\t\\tif ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );\\n\\t\\tif ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );\\n\\n\\t\\tthis.name = name;\\n\\n\\t\\tthis.times = AnimationUtils.convertArray( times, this.TimeBufferType );\\n\\t\\tthis.values = AnimationUtils.convertArray( values, this.ValueBufferType );\\n\\n\\t\\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\\n\\n\\t\\tthis.validate();\\n\\t\\tthis.optimize();\\n\\n\\t}\\n\\n\\t// Static methods:\\n\\n\\tObject.assign( KeyframeTrack, {\\n\\n\\t\\t// Serialization (in static context, because of constructor invocation\\n\\t\\t// and automatic invocation of .toJSON):\\n\\n\\t\\tparse: function ( json ) {\\n\\n\\t\\t\\tif ( json.type === undefined ) {\\n\\n\\t\\t\\t\\tthrow new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );\\n\\n\\t\\t\\tif ( json.times === undefined ) {\\n\\n\\t\\t\\t\\tvar times = [], values = [];\\n\\n\\t\\t\\t\\tAnimationUtils.flattenJSON( json.keys, times, values, 'value' );\\n\\n\\t\\t\\t\\tjson.times = times;\\n\\t\\t\\t\\tjson.values = values;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// derived classes can define a static parse method\\n\\t\\t\\tif ( trackType.parse !== undefined ) {\\n\\n\\t\\t\\t\\treturn trackType.parse( json );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// by default, we assume a constructor compatible with the base\\n\\t\\t\\t\\treturn new trackType( json.name, json.times, json.values, json.interpolation );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( track ) {\\n\\n\\t\\t\\tvar trackType = track.constructor;\\n\\n\\t\\t\\tvar json;\\n\\n\\t\\t\\t// derived classes can define a static toJSON method\\n\\t\\t\\tif ( trackType.toJSON !== undefined ) {\\n\\n\\t\\t\\t\\tjson = trackType.toJSON( track );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// by default, we assume the data can be serialized as-is\\n\\t\\t\\t\\tjson = {\\n\\n\\t\\t\\t\\t\\t'name': track.name,\\n\\t\\t\\t\\t\\t'times': AnimationUtils.convertArray( track.times, Array ),\\n\\t\\t\\t\\t\\t'values': AnimationUtils.convertArray( track.values, Array )\\n\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\tvar interpolation = track.getInterpolation();\\n\\n\\t\\t\\t\\tif ( interpolation !== track.DefaultInterpolation ) {\\n\\n\\t\\t\\t\\t\\tjson.interpolation = interpolation;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tjson.type = track.ValueTypeName; // mandatory\\n\\n\\t\\t\\treturn json;\\n\\n\\t\\t},\\n\\n\\t\\t_getTrackTypeForValueTypeName: function ( typeName ) {\\n\\n\\t\\t\\tswitch ( typeName.toLowerCase() ) {\\n\\n\\t\\t\\t\\tcase 'scalar':\\n\\t\\t\\t\\tcase 'double':\\n\\t\\t\\t\\tcase 'float':\\n\\t\\t\\t\\tcase 'number':\\n\\t\\t\\t\\tcase 'integer':\\n\\n\\t\\t\\t\\t\\treturn NumberKeyframeTrack;\\n\\n\\t\\t\\t\\tcase 'vector':\\n\\t\\t\\t\\tcase 'vector2':\\n\\t\\t\\t\\tcase 'vector3':\\n\\t\\t\\t\\tcase 'vector4':\\n\\n\\t\\t\\t\\t\\treturn VectorKeyframeTrack;\\n\\n\\t\\t\\t\\tcase 'color':\\n\\n\\t\\t\\t\\t\\treturn ColorKeyframeTrack;\\n\\n\\t\\t\\t\\tcase 'quaternion':\\n\\n\\t\\t\\t\\t\\treturn QuaternionKeyframeTrack;\\n\\n\\t\\t\\t\\tcase 'bool':\\n\\t\\t\\t\\tcase 'boolean':\\n\\n\\t\\t\\t\\t\\treturn BooleanKeyframeTrack;\\n\\n\\t\\t\\t\\tcase 'string':\\n\\n\\t\\t\\t\\t\\treturn StringKeyframeTrack;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthrow new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( KeyframeTrack.prototype, {\\n\\n\\t\\tconstructor: KeyframeTrack,\\n\\n\\t\\tTimeBufferType: Float32Array,\\n\\n\\t\\tValueBufferType: Float32Array,\\n\\n\\t\\tDefaultInterpolation: InterpolateLinear,\\n\\n\\t\\tInterpolantFactoryMethodDiscrete: function ( result ) {\\n\\n\\t\\t\\treturn new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );\\n\\n\\t\\t},\\n\\n\\t\\tInterpolantFactoryMethodLinear: function ( result ) {\\n\\n\\t\\t\\treturn new LinearInterpolant( this.times, this.values, this.getValueSize(), result );\\n\\n\\t\\t},\\n\\n\\t\\tInterpolantFactoryMethodSmooth: function ( result ) {\\n\\n\\t\\t\\treturn new CubicInterpolant( this.times, this.values, this.getValueSize(), result );\\n\\n\\t\\t},\\n\\n\\t\\tsetInterpolation: function ( interpolation ) {\\n\\n\\t\\t\\tvar factoryMethod;\\n\\n\\t\\t\\tswitch ( interpolation ) {\\n\\n\\t\\t\\t\\tcase InterpolateDiscrete:\\n\\n\\t\\t\\t\\t\\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase InterpolateLinear:\\n\\n\\t\\t\\t\\t\\tfactoryMethod = this.InterpolantFactoryMethodLinear;\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase InterpolateSmooth:\\n\\n\\t\\t\\t\\t\\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( factoryMethod === undefined ) {\\n\\n\\t\\t\\t\\tvar message = \\\"unsupported interpolation for \\\" +\\n\\t\\t\\t\\t\\tthis.ValueTypeName + \\\" keyframe track named \\\" + this.name;\\n\\n\\t\\t\\t\\tif ( this.createInterpolant === undefined ) {\\n\\n\\t\\t\\t\\t\\t// fall back to default, unless the default itself is messed up\\n\\t\\t\\t\\t\\tif ( interpolation !== this.DefaultInterpolation ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.setInterpolation( this.DefaultInterpolation );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tthrow new Error( message ); // fatal, in this case\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.KeyframeTrack:', message );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.createInterpolant = factoryMethod;\\n\\n\\t\\t},\\n\\n\\t\\tgetInterpolation: function () {\\n\\n\\t\\t\\tswitch ( this.createInterpolant ) {\\n\\n\\t\\t\\t\\tcase this.InterpolantFactoryMethodDiscrete:\\n\\n\\t\\t\\t\\t\\treturn InterpolateDiscrete;\\n\\n\\t\\t\\t\\tcase this.InterpolantFactoryMethodLinear:\\n\\n\\t\\t\\t\\t\\treturn InterpolateLinear;\\n\\n\\t\\t\\t\\tcase this.InterpolantFactoryMethodSmooth:\\n\\n\\t\\t\\t\\t\\treturn InterpolateSmooth;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tgetValueSize: function () {\\n\\n\\t\\t\\treturn this.values.length / this.times.length;\\n\\n\\t\\t},\\n\\n\\t\\t// move all keyframes either forwards or backwards in time\\n\\t\\tshift: function ( timeOffset ) {\\n\\n\\t\\t\\tif ( timeOffset !== 0.0 ) {\\n\\n\\t\\t\\t\\tvar times = this.times;\\n\\n\\t\\t\\t\\tfor ( var i = 0, n = times.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\ttimes[ i ] += timeOffset;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\\n\\t\\tscale: function ( timeScale ) {\\n\\n\\t\\t\\tif ( timeScale !== 1.0 ) {\\n\\n\\t\\t\\t\\tvar times = this.times;\\n\\n\\t\\t\\t\\tfor ( var i = 0, n = times.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\ttimes[ i ] *= timeScale;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\\n\\t\\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\\n\\t\\ttrim: function ( startTime, endTime ) {\\n\\n\\t\\t\\tvar times = this.times,\\n\\t\\t\\t\\tnKeys = times.length,\\n\\t\\t\\t\\tfrom = 0,\\n\\t\\t\\t\\tto = nKeys - 1;\\n\\n\\t\\t\\twhile ( from !== nKeys && times[ from ] < startTime ) {\\n\\n\\t\\t\\t\\t++ from;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile ( to !== - 1 && times[ to ] > endTime ) {\\n\\n\\t\\t\\t\\t-- to;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t++ to; // inclusive -> exclusive bound\\n\\n\\t\\t\\tif ( from !== 0 || to !== nKeys ) {\\n\\n\\t\\t\\t\\t// empty tracks are forbidden, so keep at least one keyframe\\n\\t\\t\\t\\tif ( from >= to ) to = Math.max( to, 1 ), from = to - 1;\\n\\n\\t\\t\\t\\tvar stride = this.getValueSize();\\n\\t\\t\\t\\tthis.times = AnimationUtils.arraySlice( times, from, to );\\n\\t\\t\\t\\tthis.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\\n\\t\\tvalidate: function () {\\n\\n\\t\\t\\tvar valid = true;\\n\\n\\t\\t\\tvar valueSize = this.getValueSize();\\n\\t\\t\\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );\\n\\t\\t\\t\\tvalid = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar times = this.times,\\n\\t\\t\\t\\tvalues = this.values,\\n\\n\\t\\t\\t\\tnKeys = times.length;\\n\\n\\t\\t\\tif ( nKeys === 0 ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.KeyframeTrack: Track is empty.', this );\\n\\t\\t\\t\\tvalid = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar prevTime = null;\\n\\n\\t\\t\\tfor ( var i = 0; i !== nKeys; i ++ ) {\\n\\n\\t\\t\\t\\tvar currTime = times[ i ];\\n\\n\\t\\t\\t\\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\\n\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );\\n\\t\\t\\t\\t\\tvalid = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( prevTime !== null && prevTime > currTime ) {\\n\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );\\n\\t\\t\\t\\t\\tvalid = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tprevTime = currTime;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( values !== undefined ) {\\n\\n\\t\\t\\t\\tif ( AnimationUtils.isTypedArray( values ) ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\t\\tvar value = values[ i ];\\n\\n\\t\\t\\t\\t\\t\\tif ( isNaN( value ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );\\n\\t\\t\\t\\t\\t\\t\\tvalid = false;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn valid;\\n\\n\\t\\t},\\n\\n\\t\\t// removes equivalent sequential keys as common in morph target sequences\\n\\t\\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --\x3e (0,0,1,1,0,0)\\n\\t\\toptimize: function () {\\n\\n\\t\\t\\tvar times = this.times,\\n\\t\\t\\t\\tvalues = this.values,\\n\\t\\t\\t\\tstride = this.getValueSize(),\\n\\n\\t\\t\\t\\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\\n\\n\\t\\t\\t\\twriteIndex = 1,\\n\\t\\t\\t\\tlastIndex = times.length - 1;\\n\\n\\t\\t\\tfor ( var i = 1; i < lastIndex; ++ i ) {\\n\\n\\t\\t\\t\\tvar keep = false;\\n\\n\\t\\t\\t\\tvar time = times[ i ];\\n\\t\\t\\t\\tvar timeNext = times[ i + 1 ];\\n\\n\\t\\t\\t\\t// remove adjacent keyframes scheduled at the same time\\n\\n\\t\\t\\t\\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\\n\\n\\t\\t\\t\\t\\tif ( ! smoothInterpolation ) {\\n\\n\\t\\t\\t\\t\\t\\t// remove unnecessary keyframes same as their neighbors\\n\\n\\t\\t\\t\\t\\t\\tvar offset = i * stride,\\n\\t\\t\\t\\t\\t\\t\\toffsetP = offset - stride,\\n\\t\\t\\t\\t\\t\\t\\toffsetN = offset + stride;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var j = 0; j !== stride; ++ j ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar value = values[ offset + j ];\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( value !== values[ offsetP + j ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\tvalue !== values[ offsetN + j ] ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tkeep = true;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tkeep = true;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// in-place compaction\\n\\n\\t\\t\\t\\tif ( keep ) {\\n\\n\\t\\t\\t\\t\\tif ( i !== writeIndex ) {\\n\\n\\t\\t\\t\\t\\t\\ttimes[ writeIndex ] = times[ i ];\\n\\n\\t\\t\\t\\t\\t\\tvar readOffset = i * stride,\\n\\t\\t\\t\\t\\t\\t\\twriteOffset = writeIndex * stride;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var j = 0; j !== stride; ++ j ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvalues[ writeOffset + j ] = values[ readOffset + j ];\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t++ writeIndex;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// flush last keyframe (compaction looks ahead)\\n\\n\\t\\t\\tif ( lastIndex > 0 ) {\\n\\n\\t\\t\\t\\ttimes[ writeIndex ] = times[ lastIndex ];\\n\\n\\t\\t\\t\\tfor ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {\\n\\n\\t\\t\\t\\t\\tvalues[ writeOffset + j ] = values[ readOffset + j ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t++ writeIndex;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( writeIndex !== times.length ) {\\n\\n\\t\\t\\t\\tthis.times = AnimationUtils.arraySlice( times, 0, writeIndex );\\n\\t\\t\\t\\tthis.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * A Track of vectored keyframe values.\\n\\t *\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction VectorKeyframeTrack( name, times, values, interpolation ) {\\n\\n\\t\\tKeyframeTrack.call( this, name, times, values, interpolation );\\n\\n\\t}\\n\\n\\tVectorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\n\\n\\t\\tconstructor: VectorKeyframeTrack,\\n\\n\\t\\tValueTypeName: 'vector'\\n\\n\\t\\t// ValueBufferType is inherited\\n\\n\\t\\t// DefaultInterpolation is inherited\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * Reusable set of Tracks that represent an animation.\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t */\\n\\n\\tfunction AnimationClip( name, duration, tracks ) {\\n\\n\\t\\tthis.name = name;\\n\\t\\tthis.tracks = tracks;\\n\\t\\tthis.duration = ( duration !== undefined ) ? duration : - 1;\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\t// this means it should figure out its duration by scanning the tracks\\n\\t\\tif ( this.duration < 0 ) {\\n\\n\\t\\t\\tthis.resetDuration();\\n\\n\\t\\t}\\n\\n\\t\\tthis.optimize();\\n\\n\\t}\\n\\n\\tObject.assign( AnimationClip, {\\n\\n\\t\\tparse: function ( json ) {\\n\\n\\t\\t\\tvar tracks = [],\\n\\t\\t\\t\\tjsonTracks = json.tracks,\\n\\t\\t\\t\\tframeTime = 1.0 / ( json.fps || 1.0 );\\n\\n\\t\\t\\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\ttracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn new AnimationClip( json.name, json.duration, tracks );\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( clip ) {\\n\\n\\t\\t\\tvar tracks = [],\\n\\t\\t\\t\\tclipTracks = clip.tracks;\\n\\n\\t\\t\\tvar json = {\\n\\n\\t\\t\\t\\t'name': clip.name,\\n\\t\\t\\t\\t'duration': clip.duration,\\n\\t\\t\\t\\t'tracks': tracks\\n\\n\\t\\t\\t};\\n\\n\\t\\t\\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn json;\\n\\n\\t\\t},\\n\\n\\t\\tCreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {\\n\\n\\t\\t\\tvar numMorphTargets = morphTargetSequence.length;\\n\\t\\t\\tvar tracks = [];\\n\\n\\t\\t\\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\\n\\n\\t\\t\\t\\tvar times = [];\\n\\t\\t\\t\\tvar values = [];\\n\\n\\t\\t\\t\\ttimes.push(\\n\\t\\t\\t\\t\\t( i + numMorphTargets - 1 ) % numMorphTargets,\\n\\t\\t\\t\\t\\ti,\\n\\t\\t\\t\\t\\t( i + 1 ) % numMorphTargets );\\n\\n\\t\\t\\t\\tvalues.push( 0, 1, 0 );\\n\\n\\t\\t\\t\\tvar order = AnimationUtils.getKeyframeOrder( times );\\n\\t\\t\\t\\ttimes = AnimationUtils.sortedArray( times, 1, order );\\n\\t\\t\\t\\tvalues = AnimationUtils.sortedArray( values, 1, order );\\n\\n\\t\\t\\t\\t// if there is a key at the first frame, duplicate it as the\\n\\t\\t\\t\\t// last frame as well for perfect loop.\\n\\t\\t\\t\\tif ( ! noLoop && times[ 0 ] === 0 ) {\\n\\n\\t\\t\\t\\t\\ttimes.push( numMorphTargets );\\n\\t\\t\\t\\t\\tvalues.push( values[ 0 ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttracks.push(\\n\\t\\t\\t\\t\\tnew NumberKeyframeTrack(\\n\\t\\t\\t\\t\\t\\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\\n\\t\\t\\t\\t\\t\\ttimes, values\\n\\t\\t\\t\\t\\t).scale( 1.0 / fps ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn new AnimationClip( name, - 1, tracks );\\n\\n\\t\\t},\\n\\n\\t\\tfindByName: function ( objectOrClipArray, name ) {\\n\\n\\t\\t\\tvar clipArray = objectOrClipArray;\\n\\n\\t\\t\\tif ( ! Array.isArray( objectOrClipArray ) ) {\\n\\n\\t\\t\\t\\tvar o = objectOrClipArray;\\n\\t\\t\\t\\tclipArray = o.geometry && o.geometry.animations || o.animations;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var i = 0; i < clipArray.length; i ++ ) {\\n\\n\\t\\t\\t\\tif ( clipArray[ i ].name === name ) {\\n\\n\\t\\t\\t\\t\\treturn clipArray[ i ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn null;\\n\\n\\t\\t},\\n\\n\\t\\tCreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {\\n\\n\\t\\t\\tvar animationToMorphTargets = {};\\n\\n\\t\\t\\t// tested with https://regex101.com/ on trick sequences\\n\\t\\t\\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\\n\\t\\t\\tvar pattern = /^([\\\\w-]*?)([\\\\d]+)$/;\\n\\n\\t\\t\\t// sort morph target names into animation groups based\\n\\t\\t\\t// patterns like Walk_001, Walk_002, Run_001, Run_002\\n\\t\\t\\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar morphTarget = morphTargets[ i ];\\n\\t\\t\\t\\tvar parts = morphTarget.name.match( pattern );\\n\\n\\t\\t\\t\\tif ( parts && parts.length > 1 ) {\\n\\n\\t\\t\\t\\t\\tvar name = parts[ 1 ];\\n\\n\\t\\t\\t\\t\\tvar animationMorphTargets = animationToMorphTargets[ name ];\\n\\t\\t\\t\\t\\tif ( ! animationMorphTargets ) {\\n\\n\\t\\t\\t\\t\\t\\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tanimationMorphTargets.push( morphTarget );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar clips = [];\\n\\n\\t\\t\\tfor ( var name in animationToMorphTargets ) {\\n\\n\\t\\t\\t\\tclips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn clips;\\n\\n\\t\\t},\\n\\n\\t\\t// parse the animation.hierarchy format\\n\\t\\tparseAnimation: function ( animation, bones ) {\\n\\n\\t\\t\\tif ( ! animation ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );\\n\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {\\n\\n\\t\\t\\t\\t// only return track if there are actually keys.\\n\\t\\t\\t\\tif ( animationKeys.length !== 0 ) {\\n\\n\\t\\t\\t\\t\\tvar times = [];\\n\\t\\t\\t\\t\\tvar values = [];\\n\\n\\t\\t\\t\\t\\tAnimationUtils.flattenJSON( animationKeys, times, values, propertyName );\\n\\n\\t\\t\\t\\t\\t// empty keys are filtered out, so check again\\n\\t\\t\\t\\t\\tif ( times.length !== 0 ) {\\n\\n\\t\\t\\t\\t\\t\\tdestTracks.push( new trackType( trackName, times, values ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t\\tvar tracks = [];\\n\\n\\t\\t\\tvar clipName = animation.name || 'default';\\n\\t\\t\\t// automatic length determination in AnimationClip.\\n\\t\\t\\tvar duration = animation.length || - 1;\\n\\t\\t\\tvar fps = animation.fps || 30;\\n\\n\\t\\t\\tvar hierarchyTracks = animation.hierarchy || [];\\n\\n\\t\\t\\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\\n\\n\\t\\t\\t\\tvar animationKeys = hierarchyTracks[ h ].keys;\\n\\n\\t\\t\\t\\t// skip empty tracks\\n\\t\\t\\t\\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\\n\\n\\t\\t\\t\\t// process morph targets\\n\\t\\t\\t\\tif ( animationKeys[ 0 ].morphTargets ) {\\n\\n\\t\\t\\t\\t\\t// figure out all morph targets used in this track\\n\\t\\t\\t\\t\\tvar morphTargetNames = {};\\n\\n\\t\\t\\t\\t\\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( animationKeys[ k ].morphTargets ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tmorphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// create a track for each morph target with all zero\\n\\t\\t\\t\\t\\t// morphTargetInfluences except for the keys in which\\n\\t\\t\\t\\t\\t// the morphTarget is named.\\n\\t\\t\\t\\t\\tfor ( var morphTargetName in morphTargetNames ) {\\n\\n\\t\\t\\t\\t\\t\\tvar times = [];\\n\\t\\t\\t\\t\\t\\tvar values = [];\\n\\n\\t\\t\\t\\t\\t\\tfor ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar animationKey = animationKeys[ k ];\\n\\n\\t\\t\\t\\t\\t\\t\\ttimes.push( animationKey.time );\\n\\t\\t\\t\\t\\t\\t\\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\ttracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tduration = morphTargetNames.length * ( fps || 1.0 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// ...assume skeletal animation\\n\\n\\t\\t\\t\\t\\tvar boneName = '.bones[' + bones[ h ].name + ']';\\n\\n\\t\\t\\t\\t\\taddNonemptyTrack(\\n\\t\\t\\t\\t\\t\\tVectorKeyframeTrack, boneName + '.position',\\n\\t\\t\\t\\t\\t\\tanimationKeys, 'pos', tracks );\\n\\n\\t\\t\\t\\t\\taddNonemptyTrack(\\n\\t\\t\\t\\t\\t\\tQuaternionKeyframeTrack, boneName + '.quaternion',\\n\\t\\t\\t\\t\\t\\tanimationKeys, 'rot', tracks );\\n\\n\\t\\t\\t\\t\\taddNonemptyTrack(\\n\\t\\t\\t\\t\\t\\tVectorKeyframeTrack, boneName + '.scale',\\n\\t\\t\\t\\t\\t\\tanimationKeys, 'scl', tracks );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( tracks.length === 0 ) {\\n\\n\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar clip = new AnimationClip( clipName, duration, tracks );\\n\\n\\t\\t\\treturn clip;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( AnimationClip.prototype, {\\n\\n\\t\\tresetDuration: function () {\\n\\n\\t\\t\\tvar tracks = this.tracks, duration = 0;\\n\\n\\t\\t\\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\tvar track = this.tracks[ i ];\\n\\n\\t\\t\\t\\tduration = Math.max( duration, track.times[ track.times.length - 1 ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.duration = duration;\\n\\n\\t\\t},\\n\\n\\t\\ttrim: function () {\\n\\n\\t\\t\\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\\n\\n\\t\\t\\t\\tthis.tracks[ i ].trim( 0, this.duration );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\toptimize: function () {\\n\\n\\t\\t\\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\\n\\n\\t\\t\\t\\tthis.tracks[ i ].optimize();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction MaterialLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\t\\tthis.textures = {};\\n\\n\\t}\\n\\n\\tObject.assign( MaterialLoader.prototype, {\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar loader = new FileLoader( scope.manager );\\n\\t\\t\\tloader.load( url, function ( text ) {\\n\\n\\t\\t\\t\\tonLoad( scope.parse( JSON.parse( text ) ) );\\n\\n\\t\\t\\t}, onProgress, onError );\\n\\n\\t\\t},\\n\\n\\t\\tsetTextures: function ( value ) {\\n\\n\\t\\t\\tthis.textures = value;\\n\\n\\t\\t},\\n\\n\\t\\tparse: function ( json ) {\\n\\n\\t\\t\\tvar textures = this.textures;\\n\\n\\t\\t\\tfunction getTexture( name ) {\\n\\n\\t\\t\\t\\tif ( textures[ name ] === undefined ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn textures[ name ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar material = new Materials[ json.type ]();\\n\\n\\t\\t\\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\\n\\t\\t\\tif ( json.name !== undefined ) material.name = json.name;\\n\\t\\t\\tif ( json.color !== undefined ) material.color.setHex( json.color );\\n\\t\\t\\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\\n\\t\\t\\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\\n\\t\\t\\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\\n\\t\\t\\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\\n\\t\\t\\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\\n\\t\\t\\tif ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;\\n\\t\\t\\tif ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;\\n\\t\\t\\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\\n\\t\\t\\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\\n\\t\\t\\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\\n\\t\\t\\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\\n\\t\\t\\tif ( json.fog !== undefined ) material.fog = json.fog;\\n\\t\\t\\tif ( json.flatShading !== undefined ) material.flatShading = json.flatShading;\\n\\t\\t\\tif ( json.blending !== undefined ) material.blending = json.blending;\\n\\t\\t\\tif ( json.side !== undefined ) material.side = json.side;\\n\\t\\t\\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\\n\\t\\t\\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\\n\\t\\t\\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\\n\\t\\t\\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\\n\\t\\t\\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\\n\\t\\t\\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\\n\\t\\t\\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\\n\\t\\t\\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\\n\\t\\t\\tif ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;\\n\\t\\t\\tif ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;\\n\\n\\t\\t\\tif ( json.rotation !== undefined ) material.rotation = json.rotation;\\n\\n\\t\\t\\tif ( json.linewidth !== 1 ) material.linewidth = json.linewidth;\\n\\t\\t\\tif ( json.dashSize !== undefined ) material.dashSize = json.dashSize;\\n\\t\\t\\tif ( json.gapSize !== undefined ) material.gapSize = json.gapSize;\\n\\t\\t\\tif ( json.scale !== undefined ) material.scale = json.scale;\\n\\n\\t\\t\\tif ( json.skinning !== undefined ) material.skinning = json.skinning;\\n\\t\\t\\tif ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;\\n\\t\\t\\tif ( json.dithering !== undefined ) material.dithering = json.dithering;\\n\\n\\t\\t\\tif ( json.visible !== undefined ) material.visible = json.visible;\\n\\t\\t\\tif ( json.userData !== undefined ) material.userData = json.userData;\\n\\n\\t\\t\\t// Deprecated\\n\\n\\t\\t\\tif ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading\\n\\n\\t\\t\\t// for PointsMaterial\\n\\n\\t\\t\\tif ( json.size !== undefined ) material.size = json.size;\\n\\t\\t\\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\\n\\n\\t\\t\\t// maps\\n\\n\\t\\t\\tif ( json.map !== undefined ) material.map = getTexture( json.map );\\n\\n\\t\\t\\tif ( json.alphaMap !== undefined ) {\\n\\n\\t\\t\\t\\tmaterial.alphaMap = getTexture( json.alphaMap );\\n\\t\\t\\t\\tmaterial.transparent = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );\\n\\t\\t\\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\\n\\n\\t\\t\\tif ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );\\n\\t\\t\\tif ( json.normalScale !== undefined ) {\\n\\n\\t\\t\\t\\tvar normalScale = json.normalScale;\\n\\n\\t\\t\\t\\tif ( Array.isArray( normalScale ) === false ) {\\n\\n\\t\\t\\t\\t\\t// Blender exporter used to export a scalar. See #7459\\n\\n\\t\\t\\t\\t\\tnormalScale = [ normalScale, normalScale ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tmaterial.normalScale = new Vector2().fromArray( normalScale );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );\\n\\t\\t\\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\\n\\t\\t\\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\\n\\n\\t\\t\\tif ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );\\n\\t\\t\\tif ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );\\n\\n\\t\\t\\tif ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );\\n\\t\\t\\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\\n\\n\\t\\t\\tif ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );\\n\\n\\t\\t\\tif ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );\\n\\n\\t\\t\\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\\n\\n\\t\\t\\tif ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );\\n\\t\\t\\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\\n\\n\\t\\t\\tif ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );\\n\\t\\t\\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\\n\\n\\t\\t\\tif ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );\\n\\n\\t\\t\\treturn material;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction BufferGeometryLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t}\\n\\n\\tObject.assign( BufferGeometryLoader.prototype, {\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar loader = new FileLoader( scope.manager );\\n\\t\\t\\tloader.load( url, function ( text ) {\\n\\n\\t\\t\\t\\tonLoad( scope.parse( JSON.parse( text ) ) );\\n\\n\\t\\t\\t}, onProgress, onError );\\n\\n\\t\\t},\\n\\n\\t\\tparse: function ( json ) {\\n\\n\\t\\t\\tvar geometry = new BufferGeometry();\\n\\n\\t\\t\\tvar index = json.data.index;\\n\\n\\t\\t\\tif ( index !== undefined ) {\\n\\n\\t\\t\\t\\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\\n\\t\\t\\t\\tgeometry.setIndex( new BufferAttribute( typedArray, 1 ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar attributes = json.data.attributes;\\n\\n\\t\\t\\tfor ( var key in attributes ) {\\n\\n\\t\\t\\t\\tvar attribute = attributes[ key ];\\n\\t\\t\\t\\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\\n\\n\\t\\t\\t\\tgeometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\\n\\n\\t\\t\\tif ( groups !== undefined ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\tvar group = groups[ i ];\\n\\n\\t\\t\\t\\t\\tgeometry.addGroup( group.start, group.count, group.materialIndex );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar boundingSphere = json.data.boundingSphere;\\n\\n\\t\\t\\tif ( boundingSphere !== undefined ) {\\n\\n\\t\\t\\t\\tvar center = new Vector3();\\n\\n\\t\\t\\t\\tif ( boundingSphere.center !== undefined ) {\\n\\n\\t\\t\\t\\t\\tcenter.fromArray( boundingSphere.center );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgeometry.boundingSphere = new Sphere( center, boundingSphere.radius );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn geometry;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tvar TYPED_ARRAYS = {\\n\\t\\tInt8Array: Int8Array,\\n\\t\\tUint8Array: Uint8Array,\\n\\t\\t// Workaround for IE11 pre KB2929437. See #11440\\n\\t\\tUint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,\\n\\t\\tInt16Array: Int16Array,\\n\\t\\tUint16Array: Uint16Array,\\n\\t\\tInt32Array: Int32Array,\\n\\t\\tUint32Array: Uint32Array,\\n\\t\\tFloat32Array: Float32Array,\\n\\t\\tFloat64Array: Float64Array\\n\\t};\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction Loader() {\\n\\n\\t\\tthis.onLoadStart = function () {};\\n\\t\\tthis.onLoadProgress = function () {};\\n\\t\\tthis.onLoadComplete = function () {};\\n\\n\\t}\\n\\n\\tLoader.Handlers = {\\n\\n\\t\\thandlers: [],\\n\\n\\t\\tadd: function ( regex, loader ) {\\n\\n\\t\\t\\tthis.handlers.push( regex, loader );\\n\\n\\t\\t},\\n\\n\\t\\tget: function ( file ) {\\n\\n\\t\\t\\tvar handlers = this.handlers;\\n\\n\\t\\t\\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\\n\\n\\t\\t\\t\\tvar regex = handlers[ i ];\\n\\t\\t\\t\\tvar loader = handlers[ i + 1 ];\\n\\n\\t\\t\\t\\tif ( regex.test( file ) ) {\\n\\n\\t\\t\\t\\t\\treturn loader;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn null;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tObject.assign( Loader.prototype, {\\n\\n\\t\\tcrossOrigin: undefined,\\n\\n\\t\\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\\n\\n\\t\\t\\tvar array = [];\\n\\n\\t\\t\\tfor ( var i = 0; i < materials.length; ++ i ) {\\n\\n\\t\\t\\t\\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn array;\\n\\n\\t\\t},\\n\\n\\t\\tcreateMaterial: ( function () {\\n\\n\\t\\t\\tvar BlendingMode = {\\n\\t\\t\\t\\tNoBlending: NoBlending,\\n\\t\\t\\t\\tNormalBlending: NormalBlending,\\n\\t\\t\\t\\tAdditiveBlending: AdditiveBlending,\\n\\t\\t\\t\\tSubtractiveBlending: SubtractiveBlending,\\n\\t\\t\\t\\tMultiplyBlending: MultiplyBlending,\\n\\t\\t\\t\\tCustomBlending: CustomBlending\\n\\t\\t\\t};\\n\\n\\t\\t\\tvar color = new Color();\\n\\t\\t\\tvar textureLoader = new TextureLoader();\\n\\t\\t\\tvar materialLoader = new MaterialLoader();\\n\\n\\t\\t\\treturn function createMaterial( m, texturePath, crossOrigin ) {\\n\\n\\t\\t\\t\\t// convert from old material format\\n\\n\\t\\t\\t\\tvar textures = {};\\n\\n\\t\\t\\t\\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\\n\\n\\t\\t\\t\\t\\tvar fullPath = texturePath + path;\\n\\t\\t\\t\\t\\tvar loader = Loader.Handlers.get( fullPath );\\n\\n\\t\\t\\t\\t\\tvar texture;\\n\\n\\t\\t\\t\\t\\tif ( loader !== null ) {\\n\\n\\t\\t\\t\\t\\t\\ttexture = loader.load( fullPath );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\ttextureLoader.setCrossOrigin( crossOrigin );\\n\\t\\t\\t\\t\\t\\ttexture = textureLoader.load( fullPath );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( repeat !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\ttexture.repeat.fromArray( repeat );\\n\\n\\t\\t\\t\\t\\t\\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;\\n\\t\\t\\t\\t\\t\\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( offset !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\ttexture.offset.fromArray( offset );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( wrap !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;\\n\\t\\t\\t\\t\\t\\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;\\n\\n\\t\\t\\t\\t\\t\\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;\\n\\t\\t\\t\\t\\t\\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( anisotropy !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\ttexture.anisotropy = anisotropy;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvar uuid = _Math.generateUUID();\\n\\n\\t\\t\\t\\t\\ttextures[ uuid ] = texture;\\n\\n\\t\\t\\t\\t\\treturn uuid;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t//\\n\\n\\t\\t\\t\\tvar json = {\\n\\t\\t\\t\\t\\tuuid: _Math.generateUUID(),\\n\\t\\t\\t\\t\\ttype: 'MeshLambertMaterial'\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\tfor ( var name in m ) {\\n\\n\\t\\t\\t\\t\\tvar value = m[ name ];\\n\\n\\t\\t\\t\\t\\tswitch ( name ) {\\n\\n\\t\\t\\t\\t\\t\\tcase 'DbgColor':\\n\\t\\t\\t\\t\\t\\tcase 'DbgIndex':\\n\\t\\t\\t\\t\\t\\tcase 'opticalDensity':\\n\\t\\t\\t\\t\\t\\tcase 'illumination':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'DbgName':\\n\\t\\t\\t\\t\\t\\t\\tjson.name = value;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'blending':\\n\\t\\t\\t\\t\\t\\t\\tjson.blending = BlendingMode[ value ];\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'colorAmbient':\\n\\t\\t\\t\\t\\t\\tcase 'mapAmbient':\\n\\t\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'colorDiffuse':\\n\\t\\t\\t\\t\\t\\t\\tjson.color = color.fromArray( value ).getHex();\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'colorSpecular':\\n\\t\\t\\t\\t\\t\\t\\tjson.specular = color.fromArray( value ).getHex();\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'colorEmissive':\\n\\t\\t\\t\\t\\t\\t\\tjson.emissive = color.fromArray( value ).getHex();\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'specularCoef':\\n\\t\\t\\t\\t\\t\\t\\tjson.shininess = value;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'shading':\\n\\t\\t\\t\\t\\t\\t\\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\\n\\t\\t\\t\\t\\t\\t\\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\\n\\t\\t\\t\\t\\t\\t\\tif ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapDiffuse':\\n\\t\\t\\t\\t\\t\\t\\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapDiffuseRepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapDiffuseOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapDiffuseWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapDiffuseAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapEmissive':\\n\\t\\t\\t\\t\\t\\t\\tjson.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapEmissiveRepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapEmissiveOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapEmissiveWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapEmissiveAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapLight':\\n\\t\\t\\t\\t\\t\\t\\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapLightRepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapLightOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapLightWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapLightAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapAO':\\n\\t\\t\\t\\t\\t\\t\\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapAORepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapAOOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapAOWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapAOAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapBump':\\n\\t\\t\\t\\t\\t\\t\\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapBumpScale':\\n\\t\\t\\t\\t\\t\\t\\tjson.bumpScale = value;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapBumpRepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapBumpOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapBumpWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapBumpAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapNormal':\\n\\t\\t\\t\\t\\t\\t\\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapNormalFactor':\\n\\t\\t\\t\\t\\t\\t\\tjson.normalScale = [ value, value ];\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapNormalRepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapNormalOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapNormalWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapNormalAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapSpecular':\\n\\t\\t\\t\\t\\t\\t\\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapSpecularRepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapSpecularOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapSpecularWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapSpecularAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapMetalness':\\n\\t\\t\\t\\t\\t\\t\\tjson.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapMetalnessRepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapMetalnessOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapMetalnessWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapMetalnessAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapRoughness':\\n\\t\\t\\t\\t\\t\\t\\tjson.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapRoughnessRepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapRoughnessOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapRoughnessWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapRoughnessAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapAlpha':\\n\\t\\t\\t\\t\\t\\t\\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapAlphaRepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapAlphaOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapAlphaWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapAlphaAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'flipSided':\\n\\t\\t\\t\\t\\t\\t\\tjson.side = BackSide;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'doubleSided':\\n\\t\\t\\t\\t\\t\\t\\tjson.side = DoubleSide;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'transparency':\\n\\t\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\\n\\t\\t\\t\\t\\t\\t\\tjson.opacity = value;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'depthTest':\\n\\t\\t\\t\\t\\t\\tcase 'depthWrite':\\n\\t\\t\\t\\t\\t\\tcase 'colorWrite':\\n\\t\\t\\t\\t\\t\\tcase 'opacity':\\n\\t\\t\\t\\t\\t\\tcase 'reflectivity':\\n\\t\\t\\t\\t\\t\\tcase 'transparent':\\n\\t\\t\\t\\t\\t\\tcase 'visible':\\n\\t\\t\\t\\t\\t\\tcase 'wireframe':\\n\\t\\t\\t\\t\\t\\t\\tjson[ name ] = value;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'vertexColors':\\n\\t\\t\\t\\t\\t\\t\\tif ( value === true ) json.vertexColors = VertexColors;\\n\\t\\t\\t\\t\\t\\t\\tif ( value === 'face' ) json.vertexColors = FaceColors;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\\n\\t\\t\\t\\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\\n\\n\\t\\t\\t\\tif ( json.opacity < 1 ) json.transparent = true;\\n\\n\\t\\t\\t\\tmaterialLoader.setTextures( textures );\\n\\n\\t\\t\\t\\treturn materialLoader.parse( json );\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )()\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author Don McCurdy / https://www.donmccurdy.com\\n\\t */\\n\\n\\tvar LoaderUtils = {\\n\\n\\t\\tdecodeText: function ( array ) {\\n\\n\\t\\t\\tif ( typeof TextDecoder !== 'undefined' ) {\\n\\n\\t\\t\\t\\treturn new TextDecoder().decode( array );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Avoid the String.fromCharCode.apply(null, array) shortcut, which\\n\\t\\t\\t// throws a \\\"maximum call stack size exceeded\\\" error for large arrays.\\n\\n\\t\\t\\tvar s = '';\\n\\n\\t\\t\\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t// Implicitly assumes little-endian.\\n\\t\\t\\t\\ts += String.fromCharCode( array[ i ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn s;\\n\\n\\t\\t},\\n\\n\\t\\textractUrlBase: function ( url ) {\\n\\n\\t\\t\\tvar parts = url.split( '/' );\\n\\n\\t\\t\\tif ( parts.length === 1 ) return './';\\n\\n\\t\\t\\tparts.pop();\\n\\n\\t\\t\\treturn parts.join( '/' ) + '/';\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction JSONLoader( manager ) {\\n\\n\\t\\tif ( typeof manager === 'boolean' ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\\n\\t\\t\\tmanager = undefined;\\n\\n\\t\\t}\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t\\tthis.withCredentials = false;\\n\\n\\t}\\n\\n\\tObject.assign( JSONLoader.prototype, {\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar texturePath = this.texturePath && ( typeof this.texturePath === 'string' ) ? this.texturePath : LoaderUtils.extractUrlBase( url );\\n\\n\\t\\t\\tvar loader = new FileLoader( this.manager );\\n\\t\\t\\tloader.setWithCredentials( this.withCredentials );\\n\\t\\t\\tloader.load( url, function ( text ) {\\n\\n\\t\\t\\t\\tvar json = JSON.parse( text );\\n\\t\\t\\t\\tvar metadata = json.metadata;\\n\\n\\t\\t\\t\\tif ( metadata !== undefined ) {\\n\\n\\t\\t\\t\\t\\tvar type = metadata.type;\\n\\n\\t\\t\\t\\t\\tif ( type !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( type.toLowerCase() === 'object' ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif ( type.toLowerCase() === 'scene' ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar object = scope.parse( json, texturePath );\\n\\t\\t\\t\\tonLoad( object.geometry, object.materials );\\n\\n\\t\\t\\t}, onProgress, onError );\\n\\n\\t\\t},\\n\\n\\t\\tsetTexturePath: function ( value ) {\\n\\n\\t\\t\\tthis.texturePath = value;\\n\\n\\t\\t},\\n\\n\\t\\tparse: ( function () {\\n\\n\\t\\t\\tfunction parseModel( json, geometry ) {\\n\\n\\t\\t\\t\\tfunction isBitSet( value, position ) {\\n\\n\\t\\t\\t\\t\\treturn value & ( 1 << position );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar i, j, fi,\\n\\n\\t\\t\\t\\t\\toffset, zLength,\\n\\n\\t\\t\\t\\t\\tcolorIndex, normalIndex, uvIndex, materialIndex,\\n\\n\\t\\t\\t\\t\\ttype,\\n\\t\\t\\t\\t\\tisQuad,\\n\\t\\t\\t\\t\\thasMaterial,\\n\\t\\t\\t\\t\\thasFaceVertexUv,\\n\\t\\t\\t\\t\\thasFaceNormal, hasFaceVertexNormal,\\n\\t\\t\\t\\t\\thasFaceColor, hasFaceVertexColor,\\n\\n\\t\\t\\t\\t\\tvertex, face, faceA, faceB, hex, normal,\\n\\n\\t\\t\\t\\t\\tuvLayer, uv, u, v,\\n\\n\\t\\t\\t\\t\\tfaces = json.faces,\\n\\t\\t\\t\\t\\tvertices = json.vertices,\\n\\t\\t\\t\\t\\tnormals = json.normals,\\n\\t\\t\\t\\t\\tcolors = json.colors,\\n\\n\\t\\t\\t\\t\\tscale = json.scale,\\n\\n\\t\\t\\t\\t\\tnUvLayers = 0;\\n\\n\\n\\t\\t\\t\\tif ( json.uvs !== undefined ) {\\n\\n\\t\\t\\t\\t\\t// disregard empty arrays\\n\\n\\t\\t\\t\\t\\tfor ( i = 0; i < json.uvs.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( json.uvs[ i ].length ) nUvLayers ++;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfor ( i = 0; i < nUvLayers; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tgeometry.faceVertexUvs[ i ] = [];\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\toffset = 0;\\n\\t\\t\\t\\tzLength = vertices.length;\\n\\n\\t\\t\\t\\twhile ( offset < zLength ) {\\n\\n\\t\\t\\t\\t\\tvertex = new Vector3();\\n\\n\\t\\t\\t\\t\\tvertex.x = vertices[ offset ++ ] * scale;\\n\\t\\t\\t\\t\\tvertex.y = vertices[ offset ++ ] * scale;\\n\\t\\t\\t\\t\\tvertex.z = vertices[ offset ++ ] * scale;\\n\\n\\t\\t\\t\\t\\tgeometry.vertices.push( vertex );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\toffset = 0;\\n\\t\\t\\t\\tzLength = faces.length;\\n\\n\\t\\t\\t\\twhile ( offset < zLength ) {\\n\\n\\t\\t\\t\\t\\ttype = faces[ offset ++ ];\\n\\n\\t\\t\\t\\t\\tisQuad = isBitSet( type, 0 );\\n\\t\\t\\t\\t\\thasMaterial = isBitSet( type, 1 );\\n\\t\\t\\t\\t\\thasFaceVertexUv = isBitSet( type, 3 );\\n\\t\\t\\t\\t\\thasFaceNormal = isBitSet( type, 4 );\\n\\t\\t\\t\\t\\thasFaceVertexNormal = isBitSet( type, 5 );\\n\\t\\t\\t\\t\\thasFaceColor = isBitSet( type, 6 );\\n\\t\\t\\t\\t\\thasFaceVertexColor = isBitSet( type, 7 );\\n\\n\\t\\t\\t\\t\\t// console.log(\\\"type\\\", type, \\\"bits\\\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\\n\\n\\t\\t\\t\\t\\tif ( isQuad ) {\\n\\n\\t\\t\\t\\t\\t\\tfaceA = new Face3();\\n\\t\\t\\t\\t\\t\\tfaceA.a = faces[ offset ];\\n\\t\\t\\t\\t\\t\\tfaceA.b = faces[ offset + 1 ];\\n\\t\\t\\t\\t\\t\\tfaceA.c = faces[ offset + 3 ];\\n\\n\\t\\t\\t\\t\\t\\tfaceB = new Face3();\\n\\t\\t\\t\\t\\t\\tfaceB.a = faces[ offset + 1 ];\\n\\t\\t\\t\\t\\t\\tfaceB.b = faces[ offset + 2 ];\\n\\t\\t\\t\\t\\t\\tfaceB.c = faces[ offset + 3 ];\\n\\n\\t\\t\\t\\t\\t\\toffset += 4;\\n\\n\\t\\t\\t\\t\\t\\tif ( hasMaterial ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tmaterialIndex = faces[ offset ++ ];\\n\\t\\t\\t\\t\\t\\t\\tfaceA.materialIndex = materialIndex;\\n\\t\\t\\t\\t\\t\\t\\tfaceB.materialIndex = materialIndex;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// to get face <=> uv index correspondence\\n\\n\\t\\t\\t\\t\\t\\tfi = geometry.faces.length;\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceVertexUv ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( i = 0; i < nUvLayers; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tuvLayer = json.uvs[ i ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgeometry.faceVertexUvs[ i ][ fi ] = [];\\n\\t\\t\\t\\t\\t\\t\\t\\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tfor ( j = 0; j < 4; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tuvIndex = faces[ offset ++ ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tu = uvLayer[ uvIndex * 2 ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tv = uvLayer[ uvIndex * 2 + 1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tuv = new Vector2( u, v );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceNormal ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tnormalIndex = faces[ offset ++ ] * 3;\\n\\n\\t\\t\\t\\t\\t\\t\\tfaceA.normal.set(\\n\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\n\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\n\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ]\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tfaceB.normal.copy( faceA.normal );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceVertexNormal ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( i = 0; i < 4; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tnormalIndex = faces[ offset ++ ] * 3;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tnormal = new Vector3(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ]\\n\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceColor ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tcolorIndex = faces[ offset ++ ];\\n\\t\\t\\t\\t\\t\\t\\thex = colors[ colorIndex ];\\n\\n\\t\\t\\t\\t\\t\\t\\tfaceA.color.setHex( hex );\\n\\t\\t\\t\\t\\t\\t\\tfaceB.color.setHex( hex );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceVertexColor ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( i = 0; i < 4; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcolorIndex = faces[ offset ++ ];\\n\\t\\t\\t\\t\\t\\t\\t\\thex = colors[ colorIndex ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tgeometry.faces.push( faceA );\\n\\t\\t\\t\\t\\t\\tgeometry.faces.push( faceB );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tface = new Face3();\\n\\t\\t\\t\\t\\t\\tface.a = faces[ offset ++ ];\\n\\t\\t\\t\\t\\t\\tface.b = faces[ offset ++ ];\\n\\t\\t\\t\\t\\t\\tface.c = faces[ offset ++ ];\\n\\n\\t\\t\\t\\t\\t\\tif ( hasMaterial ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tmaterialIndex = faces[ offset ++ ];\\n\\t\\t\\t\\t\\t\\t\\tface.materialIndex = materialIndex;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// to get face <=> uv index correspondence\\n\\n\\t\\t\\t\\t\\t\\tfi = geometry.faces.length;\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceVertexUv ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( i = 0; i < nUvLayers; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tuvLayer = json.uvs[ i ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgeometry.faceVertexUvs[ i ][ fi ] = [];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tfor ( j = 0; j < 3; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tuvIndex = faces[ offset ++ ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tu = uvLayer[ uvIndex * 2 ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tv = uvLayer[ uvIndex * 2 + 1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tuv = new Vector2( u, v );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceNormal ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tnormalIndex = faces[ offset ++ ] * 3;\\n\\n\\t\\t\\t\\t\\t\\t\\tface.normal.set(\\n\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\n\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\n\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ]\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceVertexNormal ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( i = 0; i < 3; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tnormalIndex = faces[ offset ++ ] * 3;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tnormal = new Vector3(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ]\\n\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tface.vertexNormals.push( normal );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceColor ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tcolorIndex = faces[ offset ++ ];\\n\\t\\t\\t\\t\\t\\t\\tface.color.setHex( colors[ colorIndex ] );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceVertexColor ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( i = 0; i < 3; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcolorIndex = faces[ offset ++ ];\\n\\t\\t\\t\\t\\t\\t\\t\\tface.vertexColors.push( new Color( colors[ colorIndex ] ) );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tgeometry.faces.push( face );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction parseSkin( json, geometry ) {\\n\\n\\t\\t\\t\\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\\n\\n\\t\\t\\t\\tif ( json.skinWeights ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\\n\\n\\t\\t\\t\\t\\t\\tvar x = json.skinWeights[ i ];\\n\\t\\t\\t\\t\\t\\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\\n\\t\\t\\t\\t\\t\\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\\n\\t\\t\\t\\t\\t\\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\\n\\n\\t\\t\\t\\t\\t\\tgeometry.skinWeights.push( new Vector4( x, y, z, w ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( json.skinIndices ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\\n\\n\\t\\t\\t\\t\\t\\tvar a = json.skinIndices[ i ];\\n\\t\\t\\t\\t\\t\\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\\n\\t\\t\\t\\t\\t\\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\\n\\t\\t\\t\\t\\t\\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\\n\\n\\t\\t\\t\\t\\t\\tgeometry.skinIndices.push( new Vector4( a, b, c, d ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgeometry.bones = json.bones;\\n\\n\\t\\t\\t\\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\\n\\t\\t\\t\\t\\t\\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction parseMorphing( json, geometry ) {\\n\\n\\t\\t\\t\\tvar scale = json.scale;\\n\\n\\t\\t\\t\\tif ( json.morphTargets !== undefined ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tgeometry.morphTargets[ i ] = {};\\n\\t\\t\\t\\t\\t\\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\\n\\t\\t\\t\\t\\t\\tgeometry.morphTargets[ i ].vertices = [];\\n\\n\\t\\t\\t\\t\\t\\tvar dstVertices = geometry.morphTargets[ i ].vertices;\\n\\t\\t\\t\\t\\t\\tvar srcVertices = json.morphTargets[ i ].vertices;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar vertex = new Vector3();\\n\\t\\t\\t\\t\\t\\t\\tvertex.x = srcVertices[ v ] * scale;\\n\\t\\t\\t\\t\\t\\t\\tvertex.y = srcVertices[ v + 1 ] * scale;\\n\\t\\t\\t\\t\\t\\t\\tvertex.z = srcVertices[ v + 2 ] * scale;\\n\\n\\t\\t\\t\\t\\t\\t\\tdstVertices.push( vertex );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.JSONLoader: \\\"morphColors\\\" no longer supported. Using them as face colors.' );\\n\\n\\t\\t\\t\\t\\tvar faces = geometry.faces;\\n\\t\\t\\t\\t\\tvar morphColors = json.morphColors[ 0 ].colors;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tfaces[ i ].color.fromArray( morphColors, i * 3 );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction parseAnimations( json, geometry ) {\\n\\n\\t\\t\\t\\tvar outputAnimations = [];\\n\\n\\t\\t\\t\\t// parse old style Bone/Hierarchy animations\\n\\t\\t\\t\\tvar animations = [];\\n\\n\\t\\t\\t\\tif ( json.animation !== undefined ) {\\n\\n\\t\\t\\t\\t\\tanimations.push( json.animation );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( json.animations !== undefined ) {\\n\\n\\t\\t\\t\\t\\tif ( json.animations.length ) {\\n\\n\\t\\t\\t\\t\\t\\tanimations = animations.concat( json.animations );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tanimations.push( json.animations );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < animations.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );\\n\\t\\t\\t\\t\\tif ( clip ) outputAnimations.push( clip );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// parse implicit morph animations\\n\\t\\t\\t\\tif ( geometry.morphTargets ) {\\n\\n\\t\\t\\t\\t\\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\\n\\t\\t\\t\\t\\tvar morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\\n\\t\\t\\t\\t\\toutputAnimations = outputAnimations.concat( morphAnimationClips );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn function ( json, texturePath ) {\\n\\n\\t\\t\\t\\tif ( json.data !== undefined ) {\\n\\n\\t\\t\\t\\t\\t// Geometry 4.0 spec\\n\\t\\t\\t\\t\\tjson = json.data;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( json.scale !== undefined ) {\\n\\n\\t\\t\\t\\t\\tjson.scale = 1.0 / json.scale;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tjson.scale = 1.0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar geometry = new Geometry();\\n\\n\\t\\t\\t\\tparseModel( json, geometry );\\n\\t\\t\\t\\tparseSkin( json, geometry );\\n\\t\\t\\t\\tparseMorphing( json, geometry );\\n\\t\\t\\t\\tparseAnimations( json, geometry );\\n\\n\\t\\t\\t\\tgeometry.computeFaceNormals();\\n\\t\\t\\t\\tgeometry.computeBoundingSphere();\\n\\n\\t\\t\\t\\tif ( json.materials === undefined || json.materials.length === 0 ) {\\n\\n\\t\\t\\t\\t\\treturn { geometry: geometry };\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tvar materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\\n\\n\\t\\t\\t\\t\\treturn { geometry: geometry, materials: materials };\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )()\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction ObjectLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\t\\tthis.texturePath = '';\\n\\n\\t}\\n\\n\\tObject.assign( ObjectLoader.prototype, {\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tif ( this.texturePath === '' ) {\\n\\n\\t\\t\\t\\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar loader = new FileLoader( scope.manager );\\n\\t\\t\\tloader.load( url, function ( text ) {\\n\\n\\t\\t\\t\\tvar json = null;\\n\\n\\t\\t\\t\\ttry {\\n\\n\\t\\t\\t\\t\\tjson = JSON.parse( text );\\n\\n\\t\\t\\t\\t} catch ( error ) {\\n\\n\\t\\t\\t\\t\\tif ( onError !== undefined ) onError( error );\\n\\n\\t\\t\\t\\t\\tconsole.error( 'THREE:ObjectLoader: Can\\\\'t parse ' + url + '.', error.message );\\n\\n\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar metadata = json.metadata;\\n\\n\\t\\t\\t\\tif ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\\n\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.ObjectLoader: Can\\\\'t load ' + url + '. Use THREE.JSONLoader instead.' );\\n\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tscope.parse( json, onLoad );\\n\\n\\t\\t\\t}, onProgress, onError );\\n\\n\\t\\t},\\n\\n\\t\\tsetTexturePath: function ( value ) {\\n\\n\\t\\t\\tthis.texturePath = value;\\n\\n\\t\\t},\\n\\n\\t\\tsetCrossOrigin: function ( value ) {\\n\\n\\t\\t\\tthis.crossOrigin = value;\\n\\n\\t\\t},\\n\\n\\t\\tparse: function ( json, onLoad ) {\\n\\n\\t\\t\\tvar shapes = this.parseShape( json.shapes );\\n\\t\\t\\tvar geometries = this.parseGeometries( json.geometries, shapes );\\n\\n\\t\\t\\tvar images = this.parseImages( json.images, function () {\\n\\n\\t\\t\\t\\tif ( onLoad !== undefined ) onLoad( object );\\n\\n\\t\\t\\t} );\\n\\n\\t\\t\\tvar textures = this.parseTextures( json.textures, images );\\n\\t\\t\\tvar materials = this.parseMaterials( json.materials, textures );\\n\\n\\t\\t\\tvar object = this.parseObject( json.object, geometries, materials );\\n\\n\\t\\t\\tif ( json.animations ) {\\n\\n\\t\\t\\t\\tobject.animations = this.parseAnimations( json.animations );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( json.images === undefined || json.images.length === 0 ) {\\n\\n\\t\\t\\t\\tif ( onLoad !== undefined ) onLoad( object );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn object;\\n\\n\\t\\t},\\n\\n\\t\\tparseShape: function ( json ) {\\n\\n\\t\\t\\tvar shapes = {};\\n\\n\\t\\t\\tif ( json !== undefined ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar shape = new Shape().fromJSON( json[ i ] );\\n\\n\\t\\t\\t\\t\\tshapes[ shape.uuid ] = shape;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn shapes;\\n\\n\\t\\t},\\n\\n\\t\\tparseGeometries: function ( json, shapes ) {\\n\\n\\t\\t\\tvar geometries = {};\\n\\n\\t\\t\\tif ( json !== undefined ) {\\n\\n\\t\\t\\t\\tvar geometryLoader = new JSONLoader();\\n\\t\\t\\t\\tvar bufferGeometryLoader = new BufferGeometryLoader();\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar geometry;\\n\\t\\t\\t\\t\\tvar data = json[ i ];\\n\\n\\t\\t\\t\\t\\tswitch ( data.type ) {\\n\\n\\t\\t\\t\\t\\t\\tcase 'PlaneGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'PlaneBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.width,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.height,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.widthSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.heightSegments\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'BoxGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'BoxBufferGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'CubeGeometry': // backwards compatible\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.width,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.height,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.depth,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.widthSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.heightSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.depthSegments\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'CircleGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'CircleBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radius,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.segments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaStart,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaLength\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'CylinderGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'CylinderBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radiusTop,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radiusBottom,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.height,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radialSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.heightSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.openEnded,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaStart,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaLength\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'ConeGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'ConeBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radius,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.height,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radialSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.heightSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.openEnded,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaStart,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaLength\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'SphereGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'SphereBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radius,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.widthSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.heightSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.phiStart,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.phiLength,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaStart,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaLength\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'DodecahedronGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'DodecahedronBufferGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'IcosahedronGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'IcosahedronBufferGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'OctahedronGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'OctahedronBufferGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'TetrahedronGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'TetrahedronBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radius,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.detail\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'RingGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'RingBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.innerRadius,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.outerRadius,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.phiSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaStart,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaLength\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'TorusGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'TorusBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radius,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.tube,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radialSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.tubularSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.arc\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'TorusKnotGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'TorusKnotBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radius,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.tube,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.tubularSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radialSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.p,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.q\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'LatheGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'LatheBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.points,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.segments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.phiStart,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.phiLength\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'PolyhedronGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'PolyhedronBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.vertices,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.indices,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radius,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.details\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'ShapeGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'ShapeBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tvar geometryShapes = [];\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = data.shapes.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar shape = shapes[ data.shapes[ i ] ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgeometryShapes.push( shape );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tgeometryShapes,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.curveSegments\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'BufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = bufferGeometryLoader.parse( data );\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'Geometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = geometryLoader.parse( data, this.texturePath ).geometry;\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \\\"' + data.type + '\\\"' );\\n\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tgeometry.uuid = data.uuid;\\n\\n\\t\\t\\t\\t\\tif ( data.name !== undefined ) geometry.name = data.name;\\n\\n\\t\\t\\t\\t\\tgeometries[ data.uuid ] = geometry;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn geometries;\\n\\n\\t\\t},\\n\\n\\t\\tparseMaterials: function ( json, textures ) {\\n\\n\\t\\t\\tvar materials = {};\\n\\n\\t\\t\\tif ( json !== undefined ) {\\n\\n\\t\\t\\t\\tvar loader = new MaterialLoader();\\n\\t\\t\\t\\tloader.setTextures( textures );\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar data = json[ i ];\\n\\n\\t\\t\\t\\t\\tif ( data.type === 'MultiMaterial' ) {\\n\\n\\t\\t\\t\\t\\t\\t// Deprecated\\n\\n\\t\\t\\t\\t\\t\\tvar array = [];\\n\\n\\t\\t\\t\\t\\t\\tfor ( var j = 0; j < data.materials.length; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tarray.push( loader.parse( data.materials[ j ] ) );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tmaterials[ data.uuid ] = array;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tmaterials[ data.uuid ] = loader.parse( data );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn materials;\\n\\n\\t\\t},\\n\\n\\t\\tparseAnimations: function ( json ) {\\n\\n\\t\\t\\tvar animations = [];\\n\\n\\t\\t\\tfor ( var i = 0; i < json.length; i ++ ) {\\n\\n\\t\\t\\t\\tvar clip = AnimationClip.parse( json[ i ] );\\n\\n\\t\\t\\t\\tanimations.push( clip );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn animations;\\n\\n\\t\\t},\\n\\n\\t\\tparseImages: function ( json, onLoad ) {\\n\\n\\t\\t\\tvar scope = this;\\n\\t\\t\\tvar images = {};\\n\\n\\t\\t\\tfunction loadImage( url ) {\\n\\n\\t\\t\\t\\tscope.manager.itemStart( url );\\n\\n\\t\\t\\t\\treturn loader.load( url, function () {\\n\\n\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\n\\t\\t\\t\\t}, undefined, function () {\\n\\n\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\t\\t\\t\\t\\tscope.manager.itemError( url );\\n\\n\\t\\t\\t\\t} );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( json !== undefined && json.length > 0 ) {\\n\\n\\t\\t\\t\\tvar manager = new LoadingManager( onLoad );\\n\\n\\t\\t\\t\\tvar loader = new ImageLoader( manager );\\n\\t\\t\\t\\tloader.setCrossOrigin( this.crossOrigin );\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar image = json[ i ];\\n\\t\\t\\t\\t\\tvar path = /^(\\\\/\\\\/)|([a-z]+:(\\\\/\\\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\\n\\n\\t\\t\\t\\t\\timages[ image.uuid ] = loadImage( path );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn images;\\n\\n\\t\\t},\\n\\n\\t\\tparseTextures: function ( json, images ) {\\n\\n\\t\\t\\tfunction parseConstant( value, type ) {\\n\\n\\t\\t\\t\\tif ( typeof value === 'number' ) return value;\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\\n\\n\\t\\t\\t\\treturn type[ value ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar textures = {};\\n\\n\\t\\t\\tif ( json !== undefined ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar data = json[ i ];\\n\\n\\t\\t\\t\\t\\tif ( data.image === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: No \\\"image\\\" specified for', data.uuid );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( images[ data.image ] === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvar texture = new Texture( images[ data.image ] );\\n\\t\\t\\t\\t\\ttexture.needsUpdate = true;\\n\\n\\t\\t\\t\\t\\ttexture.uuid = data.uuid;\\n\\n\\t\\t\\t\\t\\tif ( data.name !== undefined ) texture.name = data.name;\\n\\n\\t\\t\\t\\t\\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );\\n\\n\\t\\t\\t\\t\\tif ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\\n\\t\\t\\t\\t\\tif ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\\n\\t\\t\\t\\t\\tif ( data.center !== undefined ) texture.center.fromArray( data.center );\\n\\t\\t\\t\\t\\tif ( data.rotation !== undefined ) texture.rotation = data.rotation;\\n\\n\\t\\t\\t\\t\\tif ( data.wrap !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\ttexture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );\\n\\t\\t\\t\\t\\t\\ttexture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );\\n\\t\\t\\t\\t\\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );\\n\\t\\t\\t\\t\\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\\n\\n\\t\\t\\t\\t\\tif ( data.flipY !== undefined ) texture.flipY = data.flipY;\\n\\n\\t\\t\\t\\t\\ttextures[ data.uuid ] = texture;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn textures;\\n\\n\\t\\t},\\n\\n\\t\\tparseObject: function () {\\n\\n\\t\\t\\tvar matrix = new Matrix4();\\n\\n\\t\\t\\treturn function parseObject( data, geometries, materials ) {\\n\\n\\t\\t\\t\\tvar object;\\n\\n\\t\\t\\t\\tfunction getGeometry( name ) {\\n\\n\\t\\t\\t\\t\\tif ( geometries[ name ] === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn geometries[ name ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfunction getMaterial( name ) {\\n\\n\\t\\t\\t\\t\\tif ( name === undefined ) return undefined;\\n\\n\\t\\t\\t\\t\\tif ( Array.isArray( name ) ) {\\n\\n\\t\\t\\t\\t\\t\\tvar array = [];\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = name.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar uuid = name[ i ];\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( materials[ uuid ] === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: Undefined material', uuid );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tarray.push( materials[ uuid ] );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\treturn array;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( materials[ name ] === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn materials[ name ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tswitch ( data.type ) {\\n\\n\\t\\t\\t\\t\\tcase 'Scene':\\n\\n\\t\\t\\t\\t\\t\\tobject = new Scene();\\n\\n\\t\\t\\t\\t\\t\\tif ( data.background !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( Number.isInteger( data.background ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tobject.background = new Color( data.background );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif ( data.fog !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( data.fog.type === 'Fog' ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tobject.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );\\n\\n\\t\\t\\t\\t\\t\\t\\t} else if ( data.fog.type === 'FogExp2' ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tobject.fog = new FogExp2( data.fog.color, data.fog.density );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'PerspectiveCamera':\\n\\n\\t\\t\\t\\t\\t\\tobject = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\\n\\n\\t\\t\\t\\t\\t\\tif ( data.focus !== undefined ) object.focus = data.focus;\\n\\t\\t\\t\\t\\t\\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\\n\\t\\t\\t\\t\\t\\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\\n\\t\\t\\t\\t\\t\\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\\n\\t\\t\\t\\t\\t\\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'OrthographicCamera':\\n\\n\\t\\t\\t\\t\\t\\tobject = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'AmbientLight':\\n\\n\\t\\t\\t\\t\\t\\tobject = new AmbientLight( data.color, data.intensity );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'DirectionalLight':\\n\\n\\t\\t\\t\\t\\t\\tobject = new DirectionalLight( data.color, data.intensity );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'PointLight':\\n\\n\\t\\t\\t\\t\\t\\tobject = new PointLight( data.color, data.intensity, data.distance, data.decay );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'RectAreaLight':\\n\\n\\t\\t\\t\\t\\t\\tobject = new RectAreaLight( data.color, data.intensity, data.width, data.height );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'SpotLight':\\n\\n\\t\\t\\t\\t\\t\\tobject = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'HemisphereLight':\\n\\n\\t\\t\\t\\t\\t\\tobject = new HemisphereLight( data.color, data.groundColor, data.intensity );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'SkinnedMesh':\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );\\n\\n\\t\\t\\t\\t\\tcase 'Mesh':\\n\\n\\t\\t\\t\\t\\t\\tvar geometry = getGeometry( data.geometry );\\n\\t\\t\\t\\t\\t\\tvar material = getMaterial( data.material );\\n\\n\\t\\t\\t\\t\\t\\tif ( geometry.bones && geometry.bones.length > 0 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tobject = new SkinnedMesh( geometry, material );\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tobject = new Mesh( geometry, material );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'LOD':\\n\\n\\t\\t\\t\\t\\t\\tobject = new LOD();\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'Line':\\n\\n\\t\\t\\t\\t\\t\\tobject = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'LineLoop':\\n\\n\\t\\t\\t\\t\\t\\tobject = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'LineSegments':\\n\\n\\t\\t\\t\\t\\t\\tobject = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'PointCloud':\\n\\t\\t\\t\\t\\tcase 'Points':\\n\\n\\t\\t\\t\\t\\t\\tobject = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'Sprite':\\n\\n\\t\\t\\t\\t\\t\\tobject = new Sprite( getMaterial( data.material ) );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'Group':\\n\\n\\t\\t\\t\\t\\t\\tobject = new Group();\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\t\\t\\tobject = new Object3D();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tobject.uuid = data.uuid;\\n\\n\\t\\t\\t\\tif ( data.name !== undefined ) object.name = data.name;\\n\\t\\t\\t\\tif ( data.matrix !== undefined ) {\\n\\n\\t\\t\\t\\t\\tmatrix.fromArray( data.matrix );\\n\\t\\t\\t\\t\\tmatrix.decompose( object.position, object.quaternion, object.scale );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tif ( data.position !== undefined ) object.position.fromArray( data.position );\\n\\t\\t\\t\\t\\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\\n\\t\\t\\t\\t\\tif ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );\\n\\t\\t\\t\\t\\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\\n\\t\\t\\t\\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\\n\\n\\t\\t\\t\\tif ( data.shadow ) {\\n\\n\\t\\t\\t\\t\\tif ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;\\n\\t\\t\\t\\t\\tif ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;\\n\\t\\t\\t\\t\\tif ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );\\n\\t\\t\\t\\t\\tif ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( data.visible !== undefined ) object.visible = data.visible;\\n\\t\\t\\t\\tif ( data.userData !== undefined ) object.userData = data.userData;\\n\\n\\t\\t\\t\\tif ( data.children !== undefined ) {\\n\\n\\t\\t\\t\\t\\tvar children = data.children;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < children.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tobject.add( this.parseObject( children[ i ], geometries, materials ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( data.type === 'LOD' ) {\\n\\n\\t\\t\\t\\t\\tvar levels = data.levels;\\n\\n\\t\\t\\t\\t\\tfor ( var l = 0; l < levels.length; l ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar level = levels[ l ];\\n\\t\\t\\t\\t\\t\\tvar child = object.getObjectByProperty( 'uuid', level.object );\\n\\n\\t\\t\\t\\t\\t\\tif ( child !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tobject.addLevel( child, level.distance );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn object;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}()\\n\\n\\t} );\\n\\n\\tvar TEXTURE_MAPPING = {\\n\\t\\tUVMapping: UVMapping,\\n\\t\\tCubeReflectionMapping: CubeReflectionMapping,\\n\\t\\tCubeRefractionMapping: CubeRefractionMapping,\\n\\t\\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\\n\\t\\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\\n\\t\\tSphericalReflectionMapping: SphericalReflectionMapping,\\n\\t\\tCubeUVReflectionMapping: CubeUVReflectionMapping,\\n\\t\\tCubeUVRefractionMapping: CubeUVRefractionMapping\\n\\t};\\n\\n\\tvar TEXTURE_WRAPPING = {\\n\\t\\tRepeatWrapping: RepeatWrapping,\\n\\t\\tClampToEdgeWrapping: ClampToEdgeWrapping,\\n\\t\\tMirroredRepeatWrapping: MirroredRepeatWrapping\\n\\t};\\n\\n\\tvar TEXTURE_FILTER = {\\n\\t\\tNearestFilter: NearestFilter,\\n\\t\\tNearestMipMapNearestFilter: NearestMipMapNearestFilter,\\n\\t\\tNearestMipMapLinearFilter: NearestMipMapLinearFilter,\\n\\t\\tLinearFilter: LinearFilter,\\n\\t\\tLinearMipMapNearestFilter: LinearMipMapNearestFilter,\\n\\t\\tLinearMipMapLinearFilter: LinearMipMapLinearFilter\\n\\t};\\n\\n\\t/**\\n\\t * @author thespite / http://clicktorelease.com/\\n\\t */\\n\\n\\tfunction ImageBitmapLoader( manager ) {\\n\\n\\t\\tif ( typeof createImageBitmap === 'undefined' ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );\\n\\n\\t\\t}\\n\\n\\t\\tif ( typeof fetch === 'undefined' ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );\\n\\n\\t\\t}\\n\\n\\t\\tthis.manager = manager !== undefined ? manager : DefaultLoadingManager;\\n\\t\\tthis.options = undefined;\\n\\n\\t}\\n\\n\\tImageBitmapLoader.prototype = {\\n\\n\\t\\tconstructor: ImageBitmapLoader,\\n\\n\\t\\tsetOptions: function setOptions( options ) {\\n\\n\\t\\t\\tthis.options = options;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tload: function load( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tif ( url === undefined ) url = '';\\n\\n\\t\\t\\tif ( this.path !== undefined ) url = this.path + url;\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar cached = Cache.get( url );\\n\\n\\t\\t\\tif ( cached !== undefined ) {\\n\\n\\t\\t\\t\\tscope.manager.itemStart( url );\\n\\n\\t\\t\\t\\tsetTimeout( function () {\\n\\n\\t\\t\\t\\t\\tif ( onLoad ) onLoad( cached );\\n\\n\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\n\\t\\t\\t\\t}, 0 );\\n\\n\\t\\t\\t\\treturn cached;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfetch( url ).then( function ( res ) {\\n\\n\\t\\t\\t\\treturn res.blob();\\n\\n\\t\\t\\t} ).then( function ( blob ) {\\n\\n\\t\\t\\t\\treturn createImageBitmap( blob, scope.options );\\n\\n\\t\\t\\t} ).then( function ( imageBitmap ) {\\n\\n\\t\\t\\t\\tCache.add( url, imageBitmap );\\n\\n\\t\\t\\t\\tif ( onLoad ) onLoad( imageBitmap );\\n\\n\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\n\\t\\t\\t} ).catch( function ( e ) {\\n\\n\\t\\t\\t\\tif ( onError ) onError( e );\\n\\n\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\t\\t\\t\\tscope.manager.itemError( url );\\n\\n\\t\\t\\t} );\\n\\n\\t\\t},\\n\\n\\t\\tsetCrossOrigin: function ( /* value */ ) {\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetPath: function ( value ) {\\n\\n\\t\\t\\tthis.path = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t * minimal class for proxing functions to Path. Replaces old \\\"extractSubpaths()\\\"\\n\\t **/\\n\\n\\tfunction ShapePath() {\\n\\n\\t\\tthis.type = 'ShapePath';\\n\\n\\t\\tthis.subPaths = [];\\n\\t\\tthis.currentPath = null;\\n\\n\\t}\\n\\n\\tObject.assign( ShapePath.prototype, {\\n\\n\\t\\tmoveTo: function ( x, y ) {\\n\\n\\t\\t\\tthis.currentPath = new Path();\\n\\t\\t\\tthis.subPaths.push( this.currentPath );\\n\\t\\t\\tthis.currentPath.moveTo( x, y );\\n\\n\\t\\t},\\n\\n\\t\\tlineTo: function ( x, y ) {\\n\\n\\t\\t\\tthis.currentPath.lineTo( x, y );\\n\\n\\t\\t},\\n\\n\\t\\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\\n\\n\\t\\t\\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\\n\\n\\t\\t},\\n\\n\\t\\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\\n\\n\\t\\t\\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\\n\\n\\t\\t},\\n\\n\\t\\tsplineThru: function ( pts ) {\\n\\n\\t\\t\\tthis.currentPath.splineThru( pts );\\n\\n\\t\\t},\\n\\n\\t\\ttoShapes: function ( isCCW, noHoles ) {\\n\\n\\t\\t\\tfunction toShapesNoHoles( inSubpaths ) {\\n\\n\\t\\t\\t\\tvar shapes = [];\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar tmpPath = inSubpaths[ i ];\\n\\n\\t\\t\\t\\t\\tvar tmpShape = new Shape();\\n\\t\\t\\t\\t\\ttmpShape.curves = tmpPath.curves;\\n\\n\\t\\t\\t\\t\\tshapes.push( tmpShape );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn shapes;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction isPointInsidePolygon( inPt, inPolygon ) {\\n\\n\\t\\t\\t\\tvar polyLen = inPolygon.length;\\n\\n\\t\\t\\t\\t// inPt on polygon contour => immediate success    or\\n\\t\\t\\t\\t// toggling of inside/outside at every single! intersection point of an edge\\n\\t\\t\\t\\t//  with the horizontal line through inPt, left of inPt\\n\\t\\t\\t\\t//  not counting lowerY endpoints of edges and whole edges on that line\\n\\t\\t\\t\\tvar inside = false;\\n\\t\\t\\t\\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\\n\\n\\t\\t\\t\\t\\tvar edgeLowPt = inPolygon[ p ];\\n\\t\\t\\t\\t\\tvar edgeHighPt = inPolygon[ q ];\\n\\n\\t\\t\\t\\t\\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\\n\\t\\t\\t\\t\\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\\n\\n\\t\\t\\t\\t\\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\\n\\n\\t\\t\\t\\t\\t\\t// not parallel\\n\\t\\t\\t\\t\\t\\tif ( edgeDy < 0 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tedgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;\\n\\t\\t\\t\\t\\t\\t\\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \\t\\tcontinue;\\n\\n\\t\\t\\t\\t\\t\\tif ( inPt.y === edgeLowPt.y ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( inPt.x === edgeLowPt.x )\\t\\treturn\\ttrue;\\t\\t// inPt is on contour ?\\n\\t\\t\\t\\t\\t\\t\\t// continue;\\t\\t\\t\\t// no intersection or edgeLowPt => doesn't count !!!\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\\n\\t\\t\\t\\t\\t\\t\\tif ( perpEdge === 0 )\\t\\t\\t\\treturn\\ttrue;\\t\\t// inPt is on contour ?\\n\\t\\t\\t\\t\\t\\t\\tif ( perpEdge < 0 ) \\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t\\tinside = ! inside;\\t\\t// true intersection left of inPt\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t// parallel or collinear\\n\\t\\t\\t\\t\\t\\tif ( inPt.y !== edgeLowPt.y ) \\t\\tcontinue;\\t\\t\\t// parallel\\n\\t\\t\\t\\t\\t\\t// edge lies on the same horizontal line as inPt\\n\\t\\t\\t\\t\\t\\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\\n\\t\\t\\t\\t\\t\\t\\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\\t\\treturn\\ttrue;\\t// inPt: Point on contour !\\n\\t\\t\\t\\t\\t\\t// continue;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn\\tinside;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar isClockWise = ShapeUtils.isClockWise;\\n\\n\\t\\t\\tvar subPaths = this.subPaths;\\n\\t\\t\\tif ( subPaths.length === 0 ) return [];\\n\\n\\t\\t\\tif ( noHoles === true )\\treturn\\ttoShapesNoHoles( subPaths );\\n\\n\\n\\t\\t\\tvar solid, tmpPath, tmpShape, shapes = [];\\n\\n\\t\\t\\tif ( subPaths.length === 1 ) {\\n\\n\\t\\t\\t\\ttmpPath = subPaths[ 0 ];\\n\\t\\t\\t\\ttmpShape = new Shape();\\n\\t\\t\\t\\ttmpShape.curves = tmpPath.curves;\\n\\t\\t\\t\\tshapes.push( tmpShape );\\n\\t\\t\\t\\treturn shapes;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\\n\\t\\t\\tholesFirst = isCCW ? ! holesFirst : holesFirst;\\n\\n\\t\\t\\t// console.log(\\\"Holes first\\\", holesFirst);\\n\\n\\t\\t\\tvar betterShapeHoles = [];\\n\\t\\t\\tvar newShapes = [];\\n\\t\\t\\tvar newShapeHoles = [];\\n\\t\\t\\tvar mainIdx = 0;\\n\\t\\t\\tvar tmpPoints;\\n\\n\\t\\t\\tnewShapes[ mainIdx ] = undefined;\\n\\t\\t\\tnewShapeHoles[ mainIdx ] = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\ttmpPath = subPaths[ i ];\\n\\t\\t\\t\\ttmpPoints = tmpPath.getPoints();\\n\\t\\t\\t\\tsolid = isClockWise( tmpPoints );\\n\\t\\t\\t\\tsolid = isCCW ? ! solid : solid;\\n\\n\\t\\t\\t\\tif ( solid ) {\\n\\n\\t\\t\\t\\t\\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\\tmainIdx ++;\\n\\n\\t\\t\\t\\t\\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\\n\\t\\t\\t\\t\\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\\n\\n\\t\\t\\t\\t\\tif ( holesFirst )\\tmainIdx ++;\\n\\t\\t\\t\\t\\tnewShapeHoles[ mainIdx ] = [];\\n\\n\\t\\t\\t\\t\\t//console.log('cw', i);\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\\n\\n\\t\\t\\t\\t\\t//console.log('ccw', i);\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// only Holes? -> probably all Shapes with wrong orientation\\n\\t\\t\\tif ( ! newShapes[ 0 ] )\\treturn\\ttoShapesNoHoles( subPaths );\\n\\n\\n\\t\\t\\tif ( newShapes.length > 1 ) {\\n\\n\\t\\t\\t\\tvar ambiguous = false;\\n\\t\\t\\t\\tvar toChange = [];\\n\\n\\t\\t\\t\\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\\n\\n\\t\\t\\t\\t\\tbetterShapeHoles[ sIdx ] = [];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\\n\\n\\t\\t\\t\\t\\tvar sho = newShapeHoles[ sIdx ];\\n\\n\\t\\t\\t\\t\\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar ho = sho[ hIdx ];\\n\\t\\t\\t\\t\\t\\tvar hole_unassigned = true;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( sIdx !== s2Idx )\\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( hole_unassigned ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\thole_unassigned = false;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbetterShapeHoles[ s2Idx ].push( ho );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tambiguous = true;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif ( hole_unassigned ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tbetterShapeHoles[ sIdx ].push( ho );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// console.log(\\\"ambiguous: \\\", ambiguous);\\n\\t\\t\\t\\tif ( toChange.length > 0 ) {\\n\\n\\t\\t\\t\\t\\t// console.log(\\\"to change: \\\", toChange);\\n\\t\\t\\t\\t\\tif ( ! ambiguous )\\tnewShapeHoles = betterShapeHoles;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar tmpHoles;\\n\\n\\t\\t\\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\ttmpShape = newShapes[ i ].s;\\n\\t\\t\\t\\tshapes.push( tmpShape );\\n\\t\\t\\t\\ttmpHoles = newShapeHoles[ i ];\\n\\n\\t\\t\\t\\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\ttmpShape.holes.push( tmpHoles[ j ].h );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//console.log(\\\"shape\\\", shapes);\\n\\n\\t\\t\\treturn shapes;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction Font( data ) {\\n\\n\\t\\tthis.type = 'Font';\\n\\n\\t\\tthis.data = data;\\n\\n\\t}\\n\\n\\tObject.assign( Font.prototype, {\\n\\n\\t\\tisFont: true,\\n\\n\\t\\tgenerateShapes: function ( text, size, divisions ) {\\n\\n\\t\\t\\tfunction createPaths( text ) {\\n\\n\\t\\t\\t\\tvar chars = String( text ).split( '' );\\n\\t\\t\\t\\tvar scale = size / data.resolution;\\n\\t\\t\\t\\tvar line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;\\n\\n\\t\\t\\t\\tvar offsetX = 0, offsetY = 0;\\n\\n\\t\\t\\t\\tvar paths = [];\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < chars.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar char = chars[ i ];\\n\\n\\t\\t\\t\\t\\tif ( char === '\\\\n' ) {\\n\\n\\t\\t\\t\\t\\t\\toffsetX = 0;\\n\\t\\t\\t\\t\\t\\toffsetY -= line_height;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tvar ret = createPath( char, scale, offsetX, offsetY );\\n\\t\\t\\t\\t\\t\\toffsetX += ret.offsetX;\\n\\t\\t\\t\\t\\t\\tpaths.push( ret.path );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn paths;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction createPath( c, scale, offsetX, offsetY ) {\\n\\n\\t\\t\\t\\tvar glyph = data.glyphs[ c ] || data.glyphs[ '?' ];\\n\\n\\t\\t\\t\\tif ( ! glyph ) return;\\n\\n\\t\\t\\t\\tvar path = new ShapePath();\\n\\n\\t\\t\\t\\tvar pts = [];\\n\\t\\t\\t\\tvar x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;\\n\\n\\t\\t\\t\\tif ( glyph.o ) {\\n\\n\\t\\t\\t\\t\\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = outline.length; i < l; ) {\\n\\n\\t\\t\\t\\t\\t\\tvar action = outline[ i ++ ];\\n\\n\\t\\t\\t\\t\\t\\tswitch ( action ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tcase 'm': // moveTo\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tx = outline[ i ++ ] * scale + offsetX;\\n\\t\\t\\t\\t\\t\\t\\t\\ty = outline[ i ++ ] * scale + offsetY;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tpath.moveTo( x, y );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\tcase 'l': // lineTo\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tx = outline[ i ++ ] * scale + offsetX;\\n\\t\\t\\t\\t\\t\\t\\t\\ty = outline[ i ++ ] * scale + offsetY;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tpath.lineTo( x, y );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\tcase 'q': // quadraticCurveTo\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcpx = outline[ i ++ ] * scale + offsetX;\\n\\t\\t\\t\\t\\t\\t\\t\\tcpy = outline[ i ++ ] * scale + offsetY;\\n\\t\\t\\t\\t\\t\\t\\t\\tcpx1 = outline[ i ++ ] * scale + offsetX;\\n\\t\\t\\t\\t\\t\\t\\t\\tcpy1 = outline[ i ++ ] * scale + offsetY;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tlaste = pts[ pts.length - 1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( laste ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcpx0 = laste.x;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcpy0 = laste.y;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\tcase 'b': // bezierCurveTo\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcpx = outline[ i ++ ] * scale + offsetX;\\n\\t\\t\\t\\t\\t\\t\\t\\tcpy = outline[ i ++ ] * scale + offsetY;\\n\\t\\t\\t\\t\\t\\t\\t\\tcpx1 = outline[ i ++ ] * scale + offsetX;\\n\\t\\t\\t\\t\\t\\t\\t\\tcpy1 = outline[ i ++ ] * scale + offsetY;\\n\\t\\t\\t\\t\\t\\t\\t\\tcpx2 = outline[ i ++ ] * scale + offsetX;\\n\\t\\t\\t\\t\\t\\t\\t\\tcpy2 = outline[ i ++ ] * scale + offsetY;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tlaste = pts[ pts.length - 1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( laste ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcpx0 = laste.x;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcpy0 = laste.y;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn { offsetX: glyph.ha * scale, path: path };\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tif ( size === undefined ) size = 100;\\n\\t\\t\\tif ( divisions === undefined ) divisions = 4;\\n\\n\\t\\t\\tvar data = this.data;\\n\\n\\t\\t\\tvar paths = createPaths( text );\\n\\t\\t\\tvar shapes = [];\\n\\n\\t\\t\\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\\n\\n\\t\\t\\t\\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn shapes;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction FontLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t}\\n\\n\\tObject.assign( FontLoader.prototype, {\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar loader = new FileLoader( this.manager );\\n\\t\\t\\tloader.setPath( this.path );\\n\\t\\t\\tloader.load( url, function ( text ) {\\n\\n\\t\\t\\t\\tvar json;\\n\\n\\t\\t\\t\\ttry {\\n\\n\\t\\t\\t\\t\\tjson = JSON.parse( text );\\n\\n\\t\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\\n\\t\\t\\t\\t\\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar font = scope.parse( json );\\n\\n\\t\\t\\t\\tif ( onLoad ) onLoad( font );\\n\\n\\t\\t\\t}, onProgress, onError );\\n\\n\\t\\t},\\n\\n\\t\\tparse: function ( json ) {\\n\\n\\t\\t\\treturn new Font( json );\\n\\n\\t\\t},\\n\\n\\t\\tsetPath: function ( value ) {\\n\\n\\t\\t\\tthis.path = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tvar context;\\n\\n\\tvar AudioContext = {\\n\\n\\t\\tgetContext: function () {\\n\\n\\t\\t\\tif ( context === undefined ) {\\n\\n\\t\\t\\t\\tcontext = new ( window.AudioContext || window.webkitAudioContext )();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn context;\\n\\n\\t\\t},\\n\\n\\t\\tsetContext: function ( value ) {\\n\\n\\t\\t\\tcontext = value;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\\n\\t */\\n\\n\\tfunction AudioLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t}\\n\\n\\tObject.assign( AudioLoader.prototype, {\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tvar loader = new FileLoader( this.manager );\\n\\t\\t\\tloader.setResponseType( 'arraybuffer' );\\n\\t\\t\\tloader.load( url, function ( buffer ) {\\n\\n\\t\\t\\t\\tvar context = AudioContext.getContext();\\n\\n\\t\\t\\t\\tcontext.decodeAudioData( buffer, function ( audioBuffer ) {\\n\\n\\t\\t\\t\\t\\tonLoad( audioBuffer );\\n\\n\\t\\t\\t\\t} );\\n\\n\\t\\t\\t}, onProgress, onError );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction StereoCamera() {\\n\\n\\t\\tthis.type = 'StereoCamera';\\n\\n\\t\\tthis.aspect = 1;\\n\\n\\t\\tthis.eyeSep = 0.064;\\n\\n\\t\\tthis.cameraL = new PerspectiveCamera();\\n\\t\\tthis.cameraL.layers.enable( 1 );\\n\\t\\tthis.cameraL.matrixAutoUpdate = false;\\n\\n\\t\\tthis.cameraR = new PerspectiveCamera();\\n\\t\\tthis.cameraR.layers.enable( 2 );\\n\\t\\tthis.cameraR.matrixAutoUpdate = false;\\n\\n\\t}\\n\\n\\tObject.assign( StereoCamera.prototype, {\\n\\n\\t\\tupdate: ( function () {\\n\\n\\t\\t\\tvar instance, focus, fov, aspect, near, far, zoom, eyeSep;\\n\\n\\t\\t\\tvar eyeRight = new Matrix4();\\n\\t\\t\\tvar eyeLeft = new Matrix4();\\n\\n\\t\\t\\treturn function update( camera ) {\\n\\n\\t\\t\\t\\tvar needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\taspect !== camera.aspect * this.aspect || near !== camera.near ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfar !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;\\n\\n\\t\\t\\t\\tif ( needsUpdate ) {\\n\\n\\t\\t\\t\\t\\tinstance = this;\\n\\t\\t\\t\\t\\tfocus = camera.focus;\\n\\t\\t\\t\\t\\tfov = camera.fov;\\n\\t\\t\\t\\t\\taspect = camera.aspect * this.aspect;\\n\\t\\t\\t\\t\\tnear = camera.near;\\n\\t\\t\\t\\t\\tfar = camera.far;\\n\\t\\t\\t\\t\\tzoom = camera.zoom;\\n\\n\\t\\t\\t\\t\\t// Off-axis stereoscopic effect based on\\n\\t\\t\\t\\t\\t// http://paulbourke.net/stereographics/stereorender/\\n\\n\\t\\t\\t\\t\\tvar projectionMatrix = camera.projectionMatrix.clone();\\n\\t\\t\\t\\t\\teyeSep = this.eyeSep / 2;\\n\\t\\t\\t\\t\\tvar eyeSepOnProjection = eyeSep * near / focus;\\n\\t\\t\\t\\t\\tvar ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;\\n\\t\\t\\t\\t\\tvar xmin, xmax;\\n\\n\\t\\t\\t\\t\\t// translate xOffset\\n\\n\\t\\t\\t\\t\\teyeLeft.elements[ 12 ] = - eyeSep;\\n\\t\\t\\t\\t\\teyeRight.elements[ 12 ] = eyeSep;\\n\\n\\t\\t\\t\\t\\t// for left eye\\n\\n\\t\\t\\t\\t\\txmin = - ymax * aspect + eyeSepOnProjection;\\n\\t\\t\\t\\t\\txmax = ymax * aspect + eyeSepOnProjection;\\n\\n\\t\\t\\t\\t\\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\\n\\t\\t\\t\\t\\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\\n\\n\\t\\t\\t\\t\\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\\n\\n\\t\\t\\t\\t\\t// for right eye\\n\\n\\t\\t\\t\\t\\txmin = - ymax * aspect - eyeSepOnProjection;\\n\\t\\t\\t\\t\\txmax = ymax * aspect - eyeSepOnProjection;\\n\\n\\t\\t\\t\\t\\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\\n\\t\\t\\t\\t\\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\\n\\n\\t\\t\\t\\t\\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\\n\\t\\t\\t\\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )()\\n\\n\\t} );\\n\\n\\t/**\\n\\t * Camera for rendering cube maps\\n\\t *\\t- renders scene into axis-aligned cube\\n\\t *\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction CubeCamera( near, far, cubeResolution ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'CubeCamera';\\n\\n\\t\\tvar fov = 90, aspect = 1;\\n\\n\\t\\tvar cameraPX = new PerspectiveCamera( fov, aspect, near, far );\\n\\t\\tcameraPX.up.set( 0, - 1, 0 );\\n\\t\\tcameraPX.lookAt( new Vector3( 1, 0, 0 ) );\\n\\t\\tthis.add( cameraPX );\\n\\n\\t\\tvar cameraNX = new PerspectiveCamera( fov, aspect, near, far );\\n\\t\\tcameraNX.up.set( 0, - 1, 0 );\\n\\t\\tcameraNX.lookAt( new Vector3( - 1, 0, 0 ) );\\n\\t\\tthis.add( cameraNX );\\n\\n\\t\\tvar cameraPY = new PerspectiveCamera( fov, aspect, near, far );\\n\\t\\tcameraPY.up.set( 0, 0, 1 );\\n\\t\\tcameraPY.lookAt( new Vector3( 0, 1, 0 ) );\\n\\t\\tthis.add( cameraPY );\\n\\n\\t\\tvar cameraNY = new PerspectiveCamera( fov, aspect, near, far );\\n\\t\\tcameraNY.up.set( 0, 0, - 1 );\\n\\t\\tcameraNY.lookAt( new Vector3( 0, - 1, 0 ) );\\n\\t\\tthis.add( cameraNY );\\n\\n\\t\\tvar cameraPZ = new PerspectiveCamera( fov, aspect, near, far );\\n\\t\\tcameraPZ.up.set( 0, - 1, 0 );\\n\\t\\tcameraPZ.lookAt( new Vector3( 0, 0, 1 ) );\\n\\t\\tthis.add( cameraPZ );\\n\\n\\t\\tvar cameraNZ = new PerspectiveCamera( fov, aspect, near, far );\\n\\t\\tcameraNZ.up.set( 0, - 1, 0 );\\n\\t\\tcameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );\\n\\t\\tthis.add( cameraNZ );\\n\\n\\t\\tvar options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };\\n\\n\\t\\tthis.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\\n\\t\\tthis.renderTarget.texture.name = \\\"CubeCamera\\\";\\n\\n\\t\\tthis.update = function ( renderer, scene ) {\\n\\n\\t\\t\\tif ( this.parent === null ) this.updateMatrixWorld();\\n\\n\\t\\t\\tvar renderTarget = this.renderTarget;\\n\\t\\t\\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\\n\\n\\t\\t\\trenderTarget.texture.generateMipmaps = false;\\n\\n\\t\\t\\trenderTarget.activeCubeFace = 0;\\n\\t\\t\\trenderer.render( scene, cameraPX, renderTarget );\\n\\n\\t\\t\\trenderTarget.activeCubeFace = 1;\\n\\t\\t\\trenderer.render( scene, cameraNX, renderTarget );\\n\\n\\t\\t\\trenderTarget.activeCubeFace = 2;\\n\\t\\t\\trenderer.render( scene, cameraPY, renderTarget );\\n\\n\\t\\t\\trenderTarget.activeCubeFace = 3;\\n\\t\\t\\trenderer.render( scene, cameraNY, renderTarget );\\n\\n\\t\\t\\trenderTarget.activeCubeFace = 4;\\n\\t\\t\\trenderer.render( scene, cameraPZ, renderTarget );\\n\\n\\t\\t\\trenderTarget.texture.generateMipmaps = generateMipmaps;\\n\\n\\t\\t\\trenderTarget.activeCubeFace = 5;\\n\\t\\t\\trenderer.render( scene, cameraNZ, renderTarget );\\n\\n\\t\\t\\trenderer.setRenderTarget( null );\\n\\n\\t\\t};\\n\\n\\t\\tthis.clear = function ( renderer, color, depth, stencil ) {\\n\\n\\t\\t\\tvar renderTarget = this.renderTarget;\\n\\n\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\trenderTarget.activeCubeFace = i;\\n\\t\\t\\t\\trenderer.setRenderTarget( renderTarget );\\n\\n\\t\\t\\t\\trenderer.clear( color, depth, stencil );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\trenderer.setRenderTarget( null );\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\tCubeCamera.prototype = Object.create( Object3D.prototype );\\n\\tCubeCamera.prototype.constructor = CubeCamera;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction AudioListener() {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'AudioListener';\\n\\n\\t\\tthis.context = AudioContext.getContext();\\n\\n\\t\\tthis.gain = this.context.createGain();\\n\\t\\tthis.gain.connect( this.context.destination );\\n\\n\\t\\tthis.filter = null;\\n\\n\\t}\\n\\n\\tAudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: AudioListener,\\n\\n\\t\\tgetInput: function () {\\n\\n\\t\\t\\treturn this.gain;\\n\\n\\t\\t},\\n\\n\\t\\tremoveFilter: function ( ) {\\n\\n\\t\\t\\tif ( this.filter !== null ) {\\n\\n\\t\\t\\t\\tthis.gain.disconnect( this.filter );\\n\\t\\t\\t\\tthis.filter.disconnect( this.context.destination );\\n\\t\\t\\t\\tthis.gain.connect( this.context.destination );\\n\\t\\t\\t\\tthis.filter = null;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tgetFilter: function () {\\n\\n\\t\\t\\treturn this.filter;\\n\\n\\t\\t},\\n\\n\\t\\tsetFilter: function ( value ) {\\n\\n\\t\\t\\tif ( this.filter !== null ) {\\n\\n\\t\\t\\t\\tthis.gain.disconnect( this.filter );\\n\\t\\t\\t\\tthis.filter.disconnect( this.context.destination );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.gain.disconnect( this.context.destination );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.filter = value;\\n\\t\\t\\tthis.gain.connect( this.filter );\\n\\t\\t\\tthis.filter.connect( this.context.destination );\\n\\n\\t\\t},\\n\\n\\t\\tgetMasterVolume: function () {\\n\\n\\t\\t\\treturn this.gain.gain.value;\\n\\n\\t\\t},\\n\\n\\t\\tsetMasterVolume: function ( value ) {\\n\\n\\t\\t\\tthis.gain.gain.value = value;\\n\\n\\t\\t},\\n\\n\\t\\tupdateMatrixWorld: ( function () {\\n\\n\\t\\t\\tvar position = new Vector3();\\n\\t\\t\\tvar quaternion = new Quaternion();\\n\\t\\t\\tvar scale = new Vector3();\\n\\n\\t\\t\\tvar orientation = new Vector3();\\n\\n\\t\\t\\treturn function updateMatrixWorld( force ) {\\n\\n\\t\\t\\t\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\n\\n\\t\\t\\t\\tvar listener = this.context.listener;\\n\\t\\t\\t\\tvar up = this.up;\\n\\n\\t\\t\\t\\tthis.matrixWorld.decompose( position, quaternion, scale );\\n\\n\\t\\t\\t\\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\\n\\n\\t\\t\\t\\tif ( listener.positionX ) {\\n\\n\\t\\t\\t\\t\\tlistener.positionX.setValueAtTime( position.x, this.context.currentTime );\\n\\t\\t\\t\\t\\tlistener.positionY.setValueAtTime( position.y, this.context.currentTime );\\n\\t\\t\\t\\t\\tlistener.positionZ.setValueAtTime( position.z, this.context.currentTime );\\n\\t\\t\\t\\t\\tlistener.forwardX.setValueAtTime( orientation.x, this.context.currentTime );\\n\\t\\t\\t\\t\\tlistener.forwardY.setValueAtTime( orientation.y, this.context.currentTime );\\n\\t\\t\\t\\t\\tlistener.forwardZ.setValueAtTime( orientation.z, this.context.currentTime );\\n\\t\\t\\t\\t\\tlistener.upX.setValueAtTime( up.x, this.context.currentTime );\\n\\t\\t\\t\\t\\tlistener.upY.setValueAtTime( up.y, this.context.currentTime );\\n\\t\\t\\t\\t\\tlistener.upZ.setValueAtTime( up.z, this.context.currentTime );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tlistener.setPosition( position.x, position.y, position.z );\\n\\t\\t\\t\\t\\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )()\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\\n\\t */\\n\\n\\tfunction Audio( listener ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Audio';\\n\\n\\t\\tthis.context = listener.context;\\n\\n\\t\\tthis.gain = this.context.createGain();\\n\\t\\tthis.gain.connect( listener.getInput() );\\n\\n\\t\\tthis.autoplay = false;\\n\\n\\t\\tthis.buffer = null;\\n\\t\\tthis.loop = false;\\n\\t\\tthis.startTime = 0;\\n\\t\\tthis.offset = 0;\\n\\t\\tthis.playbackRate = 1;\\n\\t\\tthis.isPlaying = false;\\n\\t\\tthis.hasPlaybackControl = true;\\n\\t\\tthis.sourceType = 'empty';\\n\\n\\t\\tthis.filters = [];\\n\\n\\t}\\n\\n\\tAudio.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Audio,\\n\\n\\t\\tgetOutput: function () {\\n\\n\\t\\t\\treturn this.gain;\\n\\n\\t\\t},\\n\\n\\t\\tsetNodeSource: function ( audioNode ) {\\n\\n\\t\\t\\tthis.hasPlaybackControl = false;\\n\\t\\t\\tthis.sourceType = 'audioNode';\\n\\t\\t\\tthis.source = audioNode;\\n\\t\\t\\tthis.connect();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetBuffer: function ( audioBuffer ) {\\n\\n\\t\\t\\tthis.buffer = audioBuffer;\\n\\t\\t\\tthis.sourceType = 'buffer';\\n\\n\\t\\t\\tif ( this.autoplay ) this.play();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tplay: function () {\\n\\n\\t\\t\\tif ( this.isPlaying === true ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.hasPlaybackControl === false ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar source = this.context.createBufferSource();\\n\\n\\t\\t\\tsource.buffer = this.buffer;\\n\\t\\t\\tsource.loop = this.loop;\\n\\t\\t\\tsource.onended = this.onEnded.bind( this );\\n\\t\\t\\tsource.playbackRate.setValueAtTime( this.playbackRate, this.startTime );\\n\\t\\t\\tthis.startTime = this.context.currentTime;\\n\\t\\t\\tsource.start( this.startTime, this.offset );\\n\\n\\t\\t\\tthis.isPlaying = true;\\n\\n\\t\\t\\tthis.source = source;\\n\\n\\t\\t\\treturn this.connect();\\n\\n\\t\\t},\\n\\n\\t\\tpause: function () {\\n\\n\\t\\t\\tif ( this.hasPlaybackControl === false ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.isPlaying === true ) {\\n\\n\\t\\t\\t\\tthis.source.stop();\\n\\t\\t\\t\\tthis.offset += ( this.context.currentTime - this.startTime ) * this.playbackRate;\\n\\t\\t\\t\\tthis.isPlaying = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tstop: function () {\\n\\n\\t\\t\\tif ( this.hasPlaybackControl === false ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.source.stop();\\n\\t\\t\\tthis.offset = 0;\\n\\t\\t\\tthis.isPlaying = false;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tconnect: function () {\\n\\n\\t\\t\\tif ( this.filters.length > 0 ) {\\n\\n\\t\\t\\t\\tthis.source.connect( this.filters[ 0 ] );\\n\\n\\t\\t\\t\\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.source.connect( this.getOutput() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdisconnect: function () {\\n\\n\\t\\t\\tif ( this.filters.length > 0 ) {\\n\\n\\t\\t\\t\\tthis.source.disconnect( this.filters[ 0 ] );\\n\\n\\t\\t\\t\\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.source.disconnect( this.getOutput() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetFilters: function () {\\n\\n\\t\\t\\treturn this.filters;\\n\\n\\t\\t},\\n\\n\\t\\tsetFilters: function ( value ) {\\n\\n\\t\\t\\tif ( ! value ) value = [];\\n\\n\\t\\t\\tif ( this.isPlaying === true ) {\\n\\n\\t\\t\\t\\tthis.disconnect();\\n\\t\\t\\t\\tthis.filters = value;\\n\\t\\t\\t\\tthis.connect();\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.filters = value;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetFilter: function () {\\n\\n\\t\\t\\treturn this.getFilters()[ 0 ];\\n\\n\\t\\t},\\n\\n\\t\\tsetFilter: function ( filter ) {\\n\\n\\t\\t\\treturn this.setFilters( filter ? [ filter ] : [] );\\n\\n\\t\\t},\\n\\n\\t\\tsetPlaybackRate: function ( value ) {\\n\\n\\t\\t\\tif ( this.hasPlaybackControl === false ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.playbackRate = value;\\n\\n\\t\\t\\tif ( this.isPlaying === true ) {\\n\\n\\t\\t\\t\\tthis.source.playbackRate.setValueAtTime( this.playbackRate, this.context.currentTime );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetPlaybackRate: function () {\\n\\n\\t\\t\\treturn this.playbackRate;\\n\\n\\t\\t},\\n\\n\\t\\tonEnded: function () {\\n\\n\\t\\t\\tthis.isPlaying = false;\\n\\n\\t\\t},\\n\\n\\t\\tgetLoop: function () {\\n\\n\\t\\t\\tif ( this.hasPlaybackControl === false ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this.loop;\\n\\n\\t\\t},\\n\\n\\t\\tsetLoop: function ( value ) {\\n\\n\\t\\t\\tif ( this.hasPlaybackControl === false ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.loop = value;\\n\\n\\t\\t\\tif ( this.isPlaying === true ) {\\n\\n\\t\\t\\t\\tthis.source.loop = this.loop;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetVolume: function () {\\n\\n\\t\\t\\treturn this.gain.gain.value;\\n\\n\\t\\t},\\n\\n\\t\\tsetVolume: function ( value ) {\\n\\n\\t\\t\\tthis.gain.gain.value = value;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction PositionalAudio( listener ) {\\n\\n\\t\\tAudio.call( this, listener );\\n\\n\\t\\tthis.panner = this.context.createPanner();\\n\\t\\tthis.panner.connect( this.gain );\\n\\n\\t}\\n\\n\\tPositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {\\n\\n\\t\\tconstructor: PositionalAudio,\\n\\n\\t\\tgetOutput: function () {\\n\\n\\t\\t\\treturn this.panner;\\n\\n\\t\\t},\\n\\n\\t\\tgetRefDistance: function () {\\n\\n\\t\\t\\treturn this.panner.refDistance;\\n\\n\\t\\t},\\n\\n\\t\\tsetRefDistance: function ( value ) {\\n\\n\\t\\t\\tthis.panner.refDistance = value;\\n\\n\\t\\t},\\n\\n\\t\\tgetRolloffFactor: function () {\\n\\n\\t\\t\\treturn this.panner.rolloffFactor;\\n\\n\\t\\t},\\n\\n\\t\\tsetRolloffFactor: function ( value ) {\\n\\n\\t\\t\\tthis.panner.rolloffFactor = value;\\n\\n\\t\\t},\\n\\n\\t\\tgetDistanceModel: function () {\\n\\n\\t\\t\\treturn this.panner.distanceModel;\\n\\n\\t\\t},\\n\\n\\t\\tsetDistanceModel: function ( value ) {\\n\\n\\t\\t\\tthis.panner.distanceModel = value;\\n\\n\\t\\t},\\n\\n\\t\\tgetMaxDistance: function () {\\n\\n\\t\\t\\treturn this.panner.maxDistance;\\n\\n\\t\\t},\\n\\n\\t\\tsetMaxDistance: function ( value ) {\\n\\n\\t\\t\\tthis.panner.maxDistance = value;\\n\\n\\t\\t},\\n\\n\\t\\tupdateMatrixWorld: ( function () {\\n\\n\\t\\t\\tvar position = new Vector3();\\n\\n\\t\\t\\treturn function updateMatrixWorld( force ) {\\n\\n\\t\\t\\t\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\n\\n\\t\\t\\t\\tposition.setFromMatrixPosition( this.matrixWorld );\\n\\n\\t\\t\\t\\tthis.panner.setPosition( position.x, position.y, position.z );\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )()\\n\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction AudioAnalyser( audio, fftSize ) {\\n\\n\\t\\tthis.analyser = audio.context.createAnalyser();\\n\\t\\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\\n\\n\\t\\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\\n\\n\\t\\taudio.getOutput().connect( this.analyser );\\n\\n\\t}\\n\\n\\tObject.assign( AudioAnalyser.prototype, {\\n\\n\\t\\tgetFrequencyData: function () {\\n\\n\\t\\t\\tthis.analyser.getByteFrequencyData( this.data );\\n\\n\\t\\t\\treturn this.data;\\n\\n\\t\\t},\\n\\n\\t\\tgetAverageFrequency: function () {\\n\\n\\t\\t\\tvar value = 0, data = this.getFrequencyData();\\n\\n\\t\\t\\tfor ( var i = 0; i < data.length; i ++ ) {\\n\\n\\t\\t\\t\\tvalue += data[ i ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn value / data.length;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * Buffered scene graph property that allows weighted accumulation.\\n\\t *\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction PropertyMixer( binding, typeName, valueSize ) {\\n\\n\\t\\tthis.binding = binding;\\n\\t\\tthis.valueSize = valueSize;\\n\\n\\t\\tvar bufferType = Float64Array,\\n\\t\\t\\tmixFunction;\\n\\n\\t\\tswitch ( typeName ) {\\n\\n\\t\\t\\tcase 'quaternion':\\n\\t\\t\\t\\tmixFunction = this._slerp;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 'string':\\n\\t\\t\\tcase 'bool':\\n\\t\\t\\t\\tbufferType = Array;\\n\\t\\t\\t\\tmixFunction = this._select;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tmixFunction = this._lerp;\\n\\n\\t\\t}\\n\\n\\t\\tthis.buffer = new bufferType( valueSize * 4 );\\n\\t\\t// layout: [ incoming | accu0 | accu1 | orig ]\\n\\t\\t//\\n\\t\\t// interpolators can use .buffer as their .result\\n\\t\\t// the data then goes to 'incoming'\\n\\t\\t//\\n\\t\\t// 'accu0' and 'accu1' are used frame-interleaved for\\n\\t\\t// the cumulative result and are compared to detect\\n\\t\\t// changes\\n\\t\\t//\\n\\t\\t// 'orig' stores the original state of the property\\n\\n\\t\\tthis._mixBufferRegion = mixFunction;\\n\\n\\t\\tthis.cumulativeWeight = 0;\\n\\n\\t\\tthis.useCount = 0;\\n\\t\\tthis.referenceCount = 0;\\n\\n\\t}\\n\\n\\tObject.assign( PropertyMixer.prototype, {\\n\\n\\t\\t// accumulate data in the 'incoming' region into 'accu<i>'\\n\\t\\taccumulate: function ( accuIndex, weight ) {\\n\\n\\t\\t\\t// note: happily accumulating nothing when weight = 0, the caller knows\\n\\t\\t\\t// the weight and shouldn't have made the call in the first place\\n\\n\\t\\t\\tvar buffer = this.buffer,\\n\\t\\t\\t\\tstride = this.valueSize,\\n\\t\\t\\t\\toffset = accuIndex * stride + stride,\\n\\n\\t\\t\\t\\tcurrentWeight = this.cumulativeWeight;\\n\\n\\t\\t\\tif ( currentWeight === 0 ) {\\n\\n\\t\\t\\t\\t// accuN := incoming * weight\\n\\n\\t\\t\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\n\\n\\t\\t\\t\\t\\tbuffer[ offset + i ] = buffer[ i ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcurrentWeight = weight;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// accuN := accuN + incoming * weight\\n\\n\\t\\t\\t\\tcurrentWeight += weight;\\n\\t\\t\\t\\tvar mix = weight / currentWeight;\\n\\t\\t\\t\\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.cumulativeWeight = currentWeight;\\n\\n\\t\\t},\\n\\n\\t\\t// apply the state of 'accu<i>' to the binding when accus differ\\n\\t\\tapply: function ( accuIndex ) {\\n\\n\\t\\t\\tvar stride = this.valueSize,\\n\\t\\t\\t\\tbuffer = this.buffer,\\n\\t\\t\\t\\toffset = accuIndex * stride + stride,\\n\\n\\t\\t\\t\\tweight = this.cumulativeWeight,\\n\\n\\t\\t\\t\\tbinding = this.binding;\\n\\n\\t\\t\\tthis.cumulativeWeight = 0;\\n\\n\\t\\t\\tif ( weight < 1 ) {\\n\\n\\t\\t\\t\\t// accuN := accuN + original * ( 1 - cumulativeWeight )\\n\\n\\t\\t\\t\\tvar originalValueOffset = stride * 3;\\n\\n\\t\\t\\t\\tthis._mixBufferRegion(\\n\\t\\t\\t\\t\\tbuffer, offset, originalValueOffset, 1 - weight, stride );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\\n\\n\\t\\t\\t\\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\\n\\n\\t\\t\\t\\t\\t// value has changed -> update scene graph\\n\\n\\t\\t\\t\\t\\tbinding.setValue( buffer, offset );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t// remember the state of the bound property and copy it to both accus\\n\\t\\tsaveOriginalState: function () {\\n\\n\\t\\t\\tvar binding = this.binding;\\n\\n\\t\\t\\tvar buffer = this.buffer,\\n\\t\\t\\t\\tstride = this.valueSize,\\n\\n\\t\\t\\t\\toriginalValueOffset = stride * 3;\\n\\n\\t\\t\\tbinding.getValue( buffer, originalValueOffset );\\n\\n\\t\\t\\t// accu[0..1] := orig -- initially detect changes against the original\\n\\t\\t\\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\\n\\n\\t\\t\\t\\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.cumulativeWeight = 0;\\n\\n\\t\\t},\\n\\n\\t\\t// apply the state previously taken via 'saveOriginalState' to the binding\\n\\t\\trestoreOriginalState: function () {\\n\\n\\t\\t\\tvar originalValueOffset = this.valueSize * 3;\\n\\t\\t\\tthis.binding.setValue( this.buffer, originalValueOffset );\\n\\n\\t\\t},\\n\\n\\n\\t\\t// mix functions\\n\\n\\t\\t_select: function ( buffer, dstOffset, srcOffset, t, stride ) {\\n\\n\\t\\t\\tif ( t >= 0.5 ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\n\\n\\t\\t\\t\\t\\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t_slerp: function ( buffer, dstOffset, srcOffset, t ) {\\n\\n\\t\\t\\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );\\n\\n\\t\\t},\\n\\n\\t\\t_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {\\n\\n\\t\\t\\tvar s = 1 - t;\\n\\n\\t\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\n\\n\\t\\t\\t\\tvar j = dstOffset + i;\\n\\n\\t\\t\\t\\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * A reference to a real property in the scene graph.\\n\\t *\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction Composite( targetGroup, path, optionalParsedPath ) {\\n\\n\\t\\tvar parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );\\n\\n\\t\\tthis._targetGroup = targetGroup;\\n\\t\\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\\n\\n\\t}\\n\\n\\tObject.assign( Composite.prototype, {\\n\\n\\t\\tgetValue: function ( array, offset ) {\\n\\n\\t\\t\\tthis.bind(); // bind all binding\\n\\n\\t\\t\\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\\n\\t\\t\\t\\tbinding = this._bindings[ firstValidIndex ];\\n\\n\\t\\t\\t// and only call .getValue on the first\\n\\t\\t\\tif ( binding !== undefined ) binding.getValue( array, offset );\\n\\n\\t\\t},\\n\\n\\t\\tsetValue: function ( array, offset ) {\\n\\n\\t\\t\\tvar bindings = this._bindings;\\n\\n\\t\\t\\tfor ( var i = this._targetGroup.nCachedObjects_,\\n\\t\\t\\t\\t\\t  n = bindings.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\tbindings[ i ].setValue( array, offset );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tbind: function () {\\n\\n\\t\\t\\tvar bindings = this._bindings;\\n\\n\\t\\t\\tfor ( var i = this._targetGroup.nCachedObjects_,\\n\\t\\t\\t\\t\\t  n = bindings.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\tbindings[ i ].bind();\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tunbind: function () {\\n\\n\\t\\t\\tvar bindings = this._bindings;\\n\\n\\t\\t\\tfor ( var i = this._targetGroup.nCachedObjects_,\\n\\t\\t\\t\\t\\t  n = bindings.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\tbindings[ i ].unbind();\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\n\\tfunction PropertyBinding( rootNode, path, parsedPath ) {\\n\\n\\t\\tthis.path = path;\\n\\t\\tthis.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );\\n\\n\\t\\tthis.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;\\n\\n\\t\\tthis.rootNode = rootNode;\\n\\n\\t}\\n\\n\\tObject.assign( PropertyBinding, {\\n\\n\\t\\tComposite: Composite,\\n\\n\\t\\tcreate: function ( root, path, parsedPath ) {\\n\\n\\t\\t\\tif ( ! ( root && root.isAnimationObjectGroup ) ) {\\n\\n\\t\\t\\t\\treturn new PropertyBinding( root, path, parsedPath );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\treturn new PropertyBinding.Composite( root, path, parsedPath );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Replaces spaces with underscores and removes unsupported characters from\\n\\t\\t * node names, to ensure compatibility with parseTrackName().\\n\\t\\t *\\n\\t\\t * @param  {string} name Node name to be sanitized.\\n\\t\\t * @return {string}\\n\\t\\t */\\n\\t\\tsanitizeNodeName: function ( name ) {\\n\\n\\t\\t\\treturn name.replace( /\\\\s/g, '_' ).replace( /[^\\\\w-]/g, '' );\\n\\n\\t\\t},\\n\\n\\t\\tparseTrackName: function () {\\n\\n\\t\\t\\t// Parent directories, delimited by '/' or ':'. Currently unused, but must\\n\\t\\t\\t// be matched to parse the rest of the track name.\\n\\t\\t\\tvar directoryRe = /((?:[\\\\w-]+[\\\\/:])*)/;\\n\\n\\t\\t\\t// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\\n\\t\\t\\tvar nodeRe = /([\\\\w-\\\\.]+)?/;\\n\\n\\t\\t\\t// Object on target node, and accessor. Name may contain only word\\n\\t\\t\\t// characters. Accessor may contain any character except closing bracket.\\n\\t\\t\\tvar objectRe = /(?:\\\\.([\\\\w-]+)(?:\\\\[(.+)\\\\])?)?/;\\n\\n\\t\\t\\t// Property and accessor. May contain only word characters. Accessor may\\n\\t\\t\\t// contain any non-bracket characters.\\n\\t\\t\\tvar propertyRe = /\\\\.([\\\\w-]+)(?:\\\\[(.+)\\\\])?/;\\n\\n\\t\\t\\tvar trackRe = new RegExp( ''\\n\\t\\t\\t\\t+ '^'\\n\\t\\t\\t\\t+ directoryRe.source\\n\\t\\t\\t\\t+ nodeRe.source\\n\\t\\t\\t\\t+ objectRe.source\\n\\t\\t\\t\\t+ propertyRe.source\\n\\t\\t\\t\\t+ '$'\\n\\t\\t\\t);\\n\\n\\t\\t\\tvar supportedObjectNames = [ 'material', 'materials', 'bones' ];\\n\\n\\t\\t\\treturn function ( trackName ) {\\n\\n\\t\\t\\t\\tvar matches = trackRe.exec( trackName );\\n\\n\\t\\t\\t\\tif ( ! matches ) {\\n\\n\\t\\t\\t\\t\\tthrow new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar results = {\\n\\t\\t\\t\\t\\t// directoryName: matches[ 1 ], // (tschw) currently unused\\n\\t\\t\\t\\t\\tnodeName: matches[ 2 ],\\n\\t\\t\\t\\t\\tobjectName: matches[ 3 ],\\n\\t\\t\\t\\t\\tobjectIndex: matches[ 4 ],\\n\\t\\t\\t\\t\\tpropertyName: matches[ 5 ], // required\\n\\t\\t\\t\\t\\tpropertyIndex: matches[ 6 ]\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\tvar lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );\\n\\n\\t\\t\\t\\tif ( lastDot !== undefined && lastDot !== - 1 ) {\\n\\n\\t\\t\\t\\t\\tvar objectName = results.nodeName.substring( lastDot + 1 );\\n\\n\\t\\t\\t\\t\\t// Object names must be checked against a whitelist. Otherwise, there\\n\\t\\t\\t\\t\\t// is no way to parse 'foo.bar.baz': 'baz' must be a property, but\\n\\t\\t\\t\\t\\t// 'bar' could be the objectName, or part of a nodeName (which can\\n\\t\\t\\t\\t\\t// include '.' characters).\\n\\t\\t\\t\\t\\tif ( supportedObjectNames.indexOf( objectName ) !== - 1 ) {\\n\\n\\t\\t\\t\\t\\t\\tresults.nodeName = results.nodeName.substring( 0, lastDot );\\n\\t\\t\\t\\t\\t\\tresults.objectName = objectName;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\\n\\n\\t\\t\\t\\t\\tthrow new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn results;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tfindNode: function ( root, nodeName ) {\\n\\n\\t\\t\\tif ( ! nodeName || nodeName === \\\"\\\" || nodeName === \\\"root\\\" || nodeName === \\\".\\\" || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {\\n\\n\\t\\t\\t\\treturn root;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// search into skeleton bones.\\n\\t\\t\\tif ( root.skeleton ) {\\n\\n\\t\\t\\t\\tvar searchSkeleton = function ( skeleton ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < skeleton.bones.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar bone = skeleton.bones[ i ];\\n\\n\\t\\t\\t\\t\\t\\tif ( bone.name === nodeName ) {\\n\\n\\t\\t\\t\\t\\t\\t\\treturn bone;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\tvar bone = searchSkeleton( root.skeleton );\\n\\n\\t\\t\\t\\tif ( bone ) {\\n\\n\\t\\t\\t\\t\\treturn bone;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// search into node subtree.\\n\\t\\t\\tif ( root.children ) {\\n\\n\\t\\t\\t\\tvar searchNodeSubtree = function ( children ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < children.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar childNode = children[ i ];\\n\\n\\t\\t\\t\\t\\t\\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\\n\\n\\t\\t\\t\\t\\t\\t\\treturn childNode;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tvar result = searchNodeSubtree( childNode.children );\\n\\n\\t\\t\\t\\t\\t\\tif ( result ) return result;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\tvar subTreeNode = searchNodeSubtree( root.children );\\n\\n\\t\\t\\t\\tif ( subTreeNode ) {\\n\\n\\t\\t\\t\\t\\treturn subTreeNode;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn null;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( PropertyBinding.prototype, { // prototype, continued\\n\\n\\t\\t// these are used to \\\"bind\\\" a nonexistent property\\n\\t\\t_getValue_unavailable: function () {},\\n\\t\\t_setValue_unavailable: function () {},\\n\\n\\t\\tBindingType: {\\n\\t\\t\\tDirect: 0,\\n\\t\\t\\tEntireArray: 1,\\n\\t\\t\\tArrayElement: 2,\\n\\t\\t\\tHasFromToArray: 3\\n\\t\\t},\\n\\n\\t\\tVersioning: {\\n\\t\\t\\tNone: 0,\\n\\t\\t\\tNeedsUpdate: 1,\\n\\t\\t\\tMatrixWorldNeedsUpdate: 2\\n\\t\\t},\\n\\n\\t\\tGetterByBindingType: [\\n\\n\\t\\t\\tfunction getValue_direct( buffer, offset ) {\\n\\n\\t\\t\\t\\tbuffer[ offset ] = this.node[ this.propertyName ];\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tfunction getValue_array( buffer, offset ) {\\n\\n\\t\\t\\t\\tvar source = this.resolvedProperty;\\n\\n\\t\\t\\t\\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\tbuffer[ offset ++ ] = source[ i ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tfunction getValue_arrayElement( buffer, offset ) {\\n\\n\\t\\t\\t\\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tfunction getValue_toArray( buffer, offset ) {\\n\\n\\t\\t\\t\\tthis.resolvedProperty.toArray( buffer, offset );\\n\\n\\t\\t\\t}\\n\\n\\t\\t],\\n\\n\\t\\tSetterByBindingTypeAndVersioning: [\\n\\n\\t\\t\\t[\\n\\t\\t\\t\\t// Direct\\n\\n\\t\\t\\t\\tfunction setValue_direct( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\\n\\t\\t\\t\\t\\tthis.targetObject.needsUpdate = true;\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\\n\\t\\t\\t\\t\\tthis.targetObject.matrixWorldNeedsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t], [\\n\\n\\t\\t\\t\\t// EntireArray\\n\\n\\t\\t\\t\\tfunction setValue_array( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tvar dest = this.resolvedProperty;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\t\\tdest[ i ] = buffer[ offset ++ ];\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tvar dest = this.resolvedProperty;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\t\\tdest[ i ] = buffer[ offset ++ ];\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tthis.targetObject.needsUpdate = true;\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tvar dest = this.resolvedProperty;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\t\\tdest[ i ] = buffer[ offset ++ ];\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tthis.targetObject.matrixWorldNeedsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t], [\\n\\n\\t\\t\\t\\t// ArrayElement\\n\\n\\t\\t\\t\\tfunction setValue_arrayElement( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\\n\\t\\t\\t\\t\\tthis.targetObject.needsUpdate = true;\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\\n\\t\\t\\t\\t\\tthis.targetObject.matrixWorldNeedsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t], [\\n\\n\\t\\t\\t\\t// HasToFromArray\\n\\n\\t\\t\\t\\tfunction setValue_fromArray( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tthis.resolvedProperty.fromArray( buffer, offset );\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tthis.resolvedProperty.fromArray( buffer, offset );\\n\\t\\t\\t\\t\\tthis.targetObject.needsUpdate = true;\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tthis.resolvedProperty.fromArray( buffer, offset );\\n\\t\\t\\t\\t\\tthis.targetObject.matrixWorldNeedsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t]\\n\\n\\t\\t],\\n\\n\\t\\tgetValue: function getValue_unbound( targetArray, offset ) {\\n\\n\\t\\t\\tthis.bind();\\n\\t\\t\\tthis.getValue( targetArray, offset );\\n\\n\\t\\t\\t// Note: This class uses a State pattern on a per-method basis:\\n\\t\\t\\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\\n\\t\\t\\t// prototype version of these methods with one that represents\\n\\t\\t\\t// the bound state. When the property is not found, the methods\\n\\t\\t\\t// become no-ops.\\n\\n\\t\\t},\\n\\n\\t\\tsetValue: function getValue_unbound( sourceArray, offset ) {\\n\\n\\t\\t\\tthis.bind();\\n\\t\\t\\tthis.setValue( sourceArray, offset );\\n\\n\\t\\t},\\n\\n\\t\\t// create getter / setter pair for a property in the scene graph\\n\\t\\tbind: function () {\\n\\n\\t\\t\\tvar targetObject = this.node,\\n\\t\\t\\t\\tparsedPath = this.parsedPath,\\n\\n\\t\\t\\t\\tobjectName = parsedPath.objectName,\\n\\t\\t\\t\\tpropertyName = parsedPath.propertyName,\\n\\t\\t\\t\\tpropertyIndex = parsedPath.propertyIndex;\\n\\n\\t\\t\\tif ( ! targetObject ) {\\n\\n\\t\\t\\t\\ttargetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;\\n\\n\\t\\t\\t\\tthis.node = targetObject;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// set fail state so we can just 'return' on error\\n\\t\\t\\tthis.getValue = this._getValue_unavailable;\\n\\t\\t\\tthis.setValue = this._setValue_unavailable;\\n\\n\\t\\t\\t// ensure there is a value node\\n\\t\\t\\tif ( ! targetObject ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\\\\'t found.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( objectName ) {\\n\\n\\t\\t\\t\\tvar objectIndex = parsedPath.objectIndex;\\n\\n\\t\\t\\t\\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\\n\\t\\t\\t\\tswitch ( objectName ) {\\n\\n\\t\\t\\t\\t\\tcase 'materials':\\n\\n\\t\\t\\t\\t\\t\\tif ( ! targetObject.material ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif ( ! targetObject.material.materials ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\ttargetObject = targetObject.material.materials;\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'bones':\\n\\n\\t\\t\\t\\t\\t\\tif ( ! targetObject.skeleton ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// potential future optimization: skip this if propertyIndex is already an integer\\n\\t\\t\\t\\t\\t\\t// and convert the integer string to a true integer.\\n\\n\\t\\t\\t\\t\\t\\ttargetObject = targetObject.skeleton.bones;\\n\\n\\t\\t\\t\\t\\t\\t// support resolving morphTarget names into indices.\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < targetObject.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( targetObject[ i ].name === objectIndex ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tobjectIndex = i;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\t\\t\\tif ( targetObject[ objectName ] === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\ttargetObject = targetObject[ objectName ];\\n\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\tif ( objectIndex !== undefined ) {\\n\\n\\t\\t\\t\\t\\tif ( targetObject[ objectIndex ] === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );\\n\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ttargetObject = targetObject[ objectIndex ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// resolve property\\n\\t\\t\\tvar nodeProperty = targetObject[ propertyName ];\\n\\n\\t\\t\\tif ( nodeProperty === undefined ) {\\n\\n\\t\\t\\t\\tvar nodeName = parsedPath.nodeName;\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +\\n\\t\\t\\t\\t\\t'.' + propertyName + ' but it wasn\\\\'t found.', targetObject );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// determine versioning scheme\\n\\t\\t\\tvar versioning = this.Versioning.None;\\n\\n\\t\\t\\tif ( targetObject.needsUpdate !== undefined ) { // material\\n\\n\\t\\t\\t\\tversioning = this.Versioning.NeedsUpdate;\\n\\t\\t\\t\\tthis.targetObject = targetObject;\\n\\n\\t\\t\\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\\n\\n\\t\\t\\t\\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\\n\\t\\t\\t\\tthis.targetObject = targetObject;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// determine how the property gets bound\\n\\t\\t\\tvar bindingType = this.BindingType.Direct;\\n\\n\\t\\t\\tif ( propertyIndex !== undefined ) {\\n\\n\\t\\t\\t\\t// access a sub element of the property array (only primitives are supported right now)\\n\\n\\t\\t\\t\\tif ( propertyName === \\\"morphTargetInfluences\\\" ) {\\n\\n\\t\\t\\t\\t\\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\\n\\n\\t\\t\\t\\t\\t// support resolving morphTarget names into indices.\\n\\t\\t\\t\\t\\tif ( ! targetObject.geometry ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );\\n\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( targetObject.geometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( ! targetObject.geometry.morphAttributes ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tpropertyIndex = i;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tif ( ! targetObject.geometry.morphTargets ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this );\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tpropertyIndex = i;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbindingType = this.BindingType.ArrayElement;\\n\\n\\t\\t\\t\\tthis.resolvedProperty = nodeProperty;\\n\\t\\t\\t\\tthis.propertyIndex = propertyIndex;\\n\\n\\t\\t\\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\\n\\n\\t\\t\\t\\t// must use copy for Object3D.Euler/Quaternion\\n\\n\\t\\t\\t\\tbindingType = this.BindingType.HasFromToArray;\\n\\n\\t\\t\\t\\tthis.resolvedProperty = nodeProperty;\\n\\n\\t\\t\\t} else if ( Array.isArray( nodeProperty ) ) {\\n\\n\\t\\t\\t\\tbindingType = this.BindingType.EntireArray;\\n\\n\\t\\t\\t\\tthis.resolvedProperty = nodeProperty;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.propertyName = propertyName;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// select getter / setter\\n\\t\\t\\tthis.getValue = this.GetterByBindingType[ bindingType ];\\n\\t\\t\\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\\n\\n\\t\\t},\\n\\n\\t\\tunbind: function () {\\n\\n\\t\\t\\tthis.node = null;\\n\\n\\t\\t\\t// back to the prototype version of getValue / setValue\\n\\t\\t\\t// note: avoiding to mutate the shape of 'this' via 'delete'\\n\\t\\t\\tthis.getValue = this._getValue_unbound;\\n\\t\\t\\tthis.setValue = this._setValue_unbound;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//!\\\\ DECLARE ALIAS AFTER assign prototype !\\n\\tObject.assign( PropertyBinding.prototype, {\\n\\n\\t\\t// initial state of these methods that calls 'bind'\\n\\t\\t_getValue_unbound: PropertyBinding.prototype.getValue,\\n\\t\\t_setValue_unbound: PropertyBinding.prototype.setValue,\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * A group of objects that receives a shared animation state.\\n\\t *\\n\\t * Usage:\\n\\t *\\n\\t * \\t-\\tAdd objects you would otherwise pass as 'root' to the\\n\\t * \\t\\tconstructor or the .clipAction method of AnimationMixer.\\n\\t *\\n\\t * \\t-\\tInstead pass this object as 'root'.\\n\\t *\\n\\t * \\t-\\tYou can also add and remove objects later when the mixer\\n\\t * \\t\\tis running.\\n\\t *\\n\\t * Note:\\n\\t *\\n\\t *  \\tObjects of this class appear as one object to the mixer,\\n\\t *  \\tso cache control of the individual objects must be done\\n\\t *  \\ton the group.\\n\\t *\\n\\t * Limitation:\\n\\t *\\n\\t * \\t- \\tThe animated properties must be compatible among the\\n\\t * \\t\\tall objects in the group.\\n\\t *\\n\\t *  -\\tA single property can either be controlled through a\\n\\t *  \\ttarget group or directly, but not both.\\n\\t *\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction AnimationObjectGroup() {\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\t// cached objects followed by the active ones\\n\\t\\tthis._objects = Array.prototype.slice.call( arguments );\\n\\n\\t\\tthis.nCachedObjects_ = 0;\\t\\t\\t// threshold\\n\\t\\t// note: read by PropertyBinding.Composite\\n\\n\\t\\tvar indices = {};\\n\\t\\tthis._indicesByUUID = indices;\\t\\t// for bookkeeping\\n\\n\\t\\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\\n\\n\\t\\t\\tindices[ arguments[ i ].uuid ] = i;\\n\\n\\t\\t}\\n\\n\\t\\tthis._paths = [];\\t\\t\\t\\t\\t// inside: string\\n\\t\\tthis._parsedPaths = [];\\t\\t\\t\\t// inside: { we don't care, here }\\n\\t\\tthis._bindings = []; \\t\\t\\t\\t// inside: Array< PropertyBinding >\\n\\t\\tthis._bindingsIndicesByPath = {}; \\t// inside: indices in these arrays\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\tthis.stats = {\\n\\n\\t\\t\\tobjects: {\\n\\t\\t\\t\\tget total() {\\n\\n\\t\\t\\t\\t\\treturn scope._objects.length;\\n\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tget inUse() {\\n\\n\\t\\t\\t\\t\\treturn this.total - scope.nCachedObjects_;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tget bindingsPerObject() {\\n\\n\\t\\t\\t\\treturn scope._bindings.length;\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\tObject.assign( AnimationObjectGroup.prototype, {\\n\\n\\t\\tisAnimationObjectGroup: true,\\n\\n\\t\\tadd: function () {\\n\\n\\t\\t\\tvar objects = this._objects,\\n\\t\\t\\t\\tnObjects = objects.length,\\n\\t\\t\\t\\tnCachedObjects = this.nCachedObjects_,\\n\\t\\t\\t\\tindicesByUUID = this._indicesByUUID,\\n\\t\\t\\t\\tpaths = this._paths,\\n\\t\\t\\t\\tparsedPaths = this._parsedPaths,\\n\\t\\t\\t\\tbindings = this._bindings,\\n\\t\\t\\t\\tnBindings = bindings.length;\\n\\n\\t\\t\\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\tvar object = arguments[ i ],\\n\\t\\t\\t\\t\\tuuid = object.uuid,\\n\\t\\t\\t\\t\\tindex = indicesByUUID[ uuid ],\\n\\t\\t\\t\\t\\tknownObject = undefined;\\n\\n\\t\\t\\t\\tif ( index === undefined ) {\\n\\n\\t\\t\\t\\t\\t// unknown object -> add it to the ACTIVE region\\n\\n\\t\\t\\t\\t\\tindex = nObjects ++;\\n\\t\\t\\t\\t\\tindicesByUUID[ uuid ] = index;\\n\\t\\t\\t\\t\\tobjects.push( object );\\n\\n\\t\\t\\t\\t\\t// accounting is done, now do the same for all bindings\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\\n\\n\\t\\t\\t\\t\\t\\tbindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( index < nCachedObjects ) {\\n\\n\\t\\t\\t\\t\\tknownObject = objects[ index ];\\n\\n\\t\\t\\t\\t\\t// move existing object to the ACTIVE region\\n\\n\\t\\t\\t\\t\\tvar firstActiveIndex = -- nCachedObjects,\\n\\t\\t\\t\\t\\t\\tlastCachedObject = objects[ firstActiveIndex ];\\n\\n\\t\\t\\t\\t\\tindicesByUUID[ lastCachedObject.uuid ] = index;\\n\\t\\t\\t\\t\\tobjects[ index ] = lastCachedObject;\\n\\n\\t\\t\\t\\t\\tindicesByUUID[ uuid ] = firstActiveIndex;\\n\\t\\t\\t\\t\\tobjects[ firstActiveIndex ] = object;\\n\\n\\t\\t\\t\\t\\t// accounting is done, now do the same for all bindings\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\\n\\n\\t\\t\\t\\t\\t\\tvar bindingsForPath = bindings[ j ],\\n\\t\\t\\t\\t\\t\\t\\tlastCached = bindingsForPath[ firstActiveIndex ],\\n\\t\\t\\t\\t\\t\\t\\tbinding = bindingsForPath[ index ];\\n\\n\\t\\t\\t\\t\\t\\tbindingsForPath[ index ] = lastCached;\\n\\n\\t\\t\\t\\t\\t\\tif ( binding === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// since we do not bother to create new bindings\\n\\t\\t\\t\\t\\t\\t\\t// for objects that are cached, the binding may\\n\\t\\t\\t\\t\\t\\t\\t// or may not exist\\n\\n\\t\\t\\t\\t\\t\\t\\tbinding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tbindingsForPath[ firstActiveIndex ] = binding;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( objects[ index ] !== knownObject ) {\\n\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +\\n\\t\\t\\t\\t\\t\\t\\t'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );\\n\\n\\t\\t\\t\\t} // else the object is already where we want it to be\\n\\n\\t\\t\\t} // for arguments\\n\\n\\t\\t\\tthis.nCachedObjects_ = nCachedObjects;\\n\\n\\t\\t},\\n\\n\\t\\tremove: function () {\\n\\n\\t\\t\\tvar objects = this._objects,\\n\\t\\t\\t\\tnCachedObjects = this.nCachedObjects_,\\n\\t\\t\\t\\tindicesByUUID = this._indicesByUUID,\\n\\t\\t\\t\\tbindings = this._bindings,\\n\\t\\t\\t\\tnBindings = bindings.length;\\n\\n\\t\\t\\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\tvar object = arguments[ i ],\\n\\t\\t\\t\\t\\tuuid = object.uuid,\\n\\t\\t\\t\\t\\tindex = indicesByUUID[ uuid ];\\n\\n\\t\\t\\t\\tif ( index !== undefined && index >= nCachedObjects ) {\\n\\n\\t\\t\\t\\t\\t// move existing object into the CACHED region\\n\\n\\t\\t\\t\\t\\tvar lastCachedIndex = nCachedObjects ++,\\n\\t\\t\\t\\t\\t\\tfirstActiveObject = objects[ lastCachedIndex ];\\n\\n\\t\\t\\t\\t\\tindicesByUUID[ firstActiveObject.uuid ] = index;\\n\\t\\t\\t\\t\\tobjects[ index ] = firstActiveObject;\\n\\n\\t\\t\\t\\t\\tindicesByUUID[ uuid ] = lastCachedIndex;\\n\\t\\t\\t\\t\\tobjects[ lastCachedIndex ] = object;\\n\\n\\t\\t\\t\\t\\t// accounting is done, now do the same for all bindings\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\\n\\n\\t\\t\\t\\t\\t\\tvar bindingsForPath = bindings[ j ],\\n\\t\\t\\t\\t\\t\\t\\tfirstActive = bindingsForPath[ lastCachedIndex ],\\n\\t\\t\\t\\t\\t\\t\\tbinding = bindingsForPath[ index ];\\n\\n\\t\\t\\t\\t\\t\\tbindingsForPath[ index ] = firstActive;\\n\\t\\t\\t\\t\\t\\tbindingsForPath[ lastCachedIndex ] = binding;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} // for arguments\\n\\n\\t\\t\\tthis.nCachedObjects_ = nCachedObjects;\\n\\n\\t\\t},\\n\\n\\t\\t// remove & forget\\n\\t\\tuncache: function () {\\n\\n\\t\\t\\tvar objects = this._objects,\\n\\t\\t\\t\\tnObjects = objects.length,\\n\\t\\t\\t\\tnCachedObjects = this.nCachedObjects_,\\n\\t\\t\\t\\tindicesByUUID = this._indicesByUUID,\\n\\t\\t\\t\\tbindings = this._bindings,\\n\\t\\t\\t\\tnBindings = bindings.length;\\n\\n\\t\\t\\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\tvar object = arguments[ i ],\\n\\t\\t\\t\\t\\tuuid = object.uuid,\\n\\t\\t\\t\\t\\tindex = indicesByUUID[ uuid ];\\n\\n\\t\\t\\t\\tif ( index !== undefined ) {\\n\\n\\t\\t\\t\\t\\tdelete indicesByUUID[ uuid ];\\n\\n\\t\\t\\t\\t\\tif ( index < nCachedObjects ) {\\n\\n\\t\\t\\t\\t\\t\\t// object is cached, shrink the CACHED region\\n\\n\\t\\t\\t\\t\\t\\tvar firstActiveIndex = -- nCachedObjects,\\n\\t\\t\\t\\t\\t\\t\\tlastCachedObject = objects[ firstActiveIndex ],\\n\\t\\t\\t\\t\\t\\t\\tlastIndex = -- nObjects,\\n\\t\\t\\t\\t\\t\\t\\tlastObject = objects[ lastIndex ];\\n\\n\\t\\t\\t\\t\\t\\t// last cached object takes this object's place\\n\\t\\t\\t\\t\\t\\tindicesByUUID[ lastCachedObject.uuid ] = index;\\n\\t\\t\\t\\t\\t\\tobjects[ index ] = lastCachedObject;\\n\\n\\t\\t\\t\\t\\t\\t// last object goes to the activated slot and pop\\n\\t\\t\\t\\t\\t\\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\\n\\t\\t\\t\\t\\t\\tobjects[ firstActiveIndex ] = lastObject;\\n\\t\\t\\t\\t\\t\\tobjects.pop();\\n\\n\\t\\t\\t\\t\\t\\t// accounting is done, now do the same for all bindings\\n\\n\\t\\t\\t\\t\\t\\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar bindingsForPath = bindings[ j ],\\n\\t\\t\\t\\t\\t\\t\\t\\tlastCached = bindingsForPath[ firstActiveIndex ],\\n\\t\\t\\t\\t\\t\\t\\t\\tlast = bindingsForPath[ lastIndex ];\\n\\n\\t\\t\\t\\t\\t\\t\\tbindingsForPath[ index ] = lastCached;\\n\\t\\t\\t\\t\\t\\t\\tbindingsForPath[ firstActiveIndex ] = last;\\n\\t\\t\\t\\t\\t\\t\\tbindingsForPath.pop();\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t// object is active, just swap with the last and pop\\n\\n\\t\\t\\t\\t\\t\\tvar lastIndex = -- nObjects,\\n\\t\\t\\t\\t\\t\\t\\tlastObject = objects[ lastIndex ];\\n\\n\\t\\t\\t\\t\\t\\tindicesByUUID[ lastObject.uuid ] = index;\\n\\t\\t\\t\\t\\t\\tobjects[ index ] = lastObject;\\n\\t\\t\\t\\t\\t\\tobjects.pop();\\n\\n\\t\\t\\t\\t\\t\\t// accounting is done, now do the same for all bindings\\n\\n\\t\\t\\t\\t\\t\\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar bindingsForPath = bindings[ j ];\\n\\n\\t\\t\\t\\t\\t\\t\\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\\n\\t\\t\\t\\t\\t\\t\\tbindingsForPath.pop();\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} // cached or active\\n\\n\\t\\t\\t\\t} // if object is known\\n\\n\\t\\t\\t} // for arguments\\n\\n\\t\\t\\tthis.nCachedObjects_ = nCachedObjects;\\n\\n\\t\\t},\\n\\n\\t\\t// Internal interface used by befriended PropertyBinding.Composite:\\n\\n\\t\\tsubscribe_: function ( path, parsedPath ) {\\n\\n\\t\\t\\t// returns an array of bindings for the given path that is changed\\n\\t\\t\\t// according to the contained objects in the group\\n\\n\\t\\t\\tvar indicesByPath = this._bindingsIndicesByPath,\\n\\t\\t\\t\\tindex = indicesByPath[ path ],\\n\\t\\t\\t\\tbindings = this._bindings;\\n\\n\\t\\t\\tif ( index !== undefined ) return bindings[ index ];\\n\\n\\t\\t\\tvar paths = this._paths,\\n\\t\\t\\t\\tparsedPaths = this._parsedPaths,\\n\\t\\t\\t\\tobjects = this._objects,\\n\\t\\t\\t\\tnObjects = objects.length,\\n\\t\\t\\t\\tnCachedObjects = this.nCachedObjects_,\\n\\t\\t\\t\\tbindingsForPath = new Array( nObjects );\\n\\n\\t\\t\\tindex = bindings.length;\\n\\n\\t\\t\\tindicesByPath[ path ] = index;\\n\\n\\t\\t\\tpaths.push( path );\\n\\t\\t\\tparsedPaths.push( parsedPath );\\n\\t\\t\\tbindings.push( bindingsForPath );\\n\\n\\t\\t\\tfor ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\tvar object = objects[ i ];\\n\\t\\t\\t\\tbindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn bindingsForPath;\\n\\n\\t\\t},\\n\\n\\t\\tunsubscribe_: function ( path ) {\\n\\n\\t\\t\\t// tells the group to forget about a property path and no longer\\n\\t\\t\\t// update the array previously obtained with 'subscribe_'\\n\\n\\t\\t\\tvar indicesByPath = this._bindingsIndicesByPath,\\n\\t\\t\\t\\tindex = indicesByPath[ path ];\\n\\n\\t\\t\\tif ( index !== undefined ) {\\n\\n\\t\\t\\t\\tvar paths = this._paths,\\n\\t\\t\\t\\t\\tparsedPaths = this._parsedPaths,\\n\\t\\t\\t\\t\\tbindings = this._bindings,\\n\\t\\t\\t\\t\\tlastBindingsIndex = bindings.length - 1,\\n\\t\\t\\t\\t\\tlastBindings = bindings[ lastBindingsIndex ],\\n\\t\\t\\t\\t\\tlastBindingsPath = path[ lastBindingsIndex ];\\n\\n\\t\\t\\t\\tindicesByPath[ lastBindingsPath ] = index;\\n\\n\\t\\t\\t\\tbindings[ index ] = lastBindings;\\n\\t\\t\\t\\tbindings.pop();\\n\\n\\t\\t\\t\\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\\n\\t\\t\\t\\tparsedPaths.pop();\\n\\n\\t\\t\\t\\tpaths[ index ] = paths[ lastBindingsIndex ];\\n\\t\\t\\t\\tpaths.pop();\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * Action provided by AnimationMixer for scheduling clip playback on specific\\n\\t * objects.\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t *\\n\\t */\\n\\n\\tfunction AnimationAction( mixer, clip, localRoot ) {\\n\\n\\t\\tthis._mixer = mixer;\\n\\t\\tthis._clip = clip;\\n\\t\\tthis._localRoot = localRoot || null;\\n\\n\\t\\tvar tracks = clip.tracks,\\n\\t\\t\\tnTracks = tracks.length,\\n\\t\\t\\tinterpolants = new Array( nTracks );\\n\\n\\t\\tvar interpolantSettings = {\\n\\t\\t\\tendingStart: ZeroCurvatureEnding,\\n\\t\\t\\tendingEnd: ZeroCurvatureEnding\\n\\t\\t};\\n\\n\\t\\tfor ( var i = 0; i !== nTracks; ++ i ) {\\n\\n\\t\\t\\tvar interpolant = tracks[ i ].createInterpolant( null );\\n\\t\\t\\tinterpolants[ i ] = interpolant;\\n\\t\\t\\tinterpolant.settings = interpolantSettings;\\n\\n\\t\\t}\\n\\n\\t\\tthis._interpolantSettings = interpolantSettings;\\n\\n\\t\\tthis._interpolants = interpolants;\\t// bound by the mixer\\n\\n\\t\\t// inside: PropertyMixer (managed by the mixer)\\n\\t\\tthis._propertyBindings = new Array( nTracks );\\n\\n\\t\\tthis._cacheIndex = null;\\t\\t\\t// for the memory manager\\n\\t\\tthis._byClipCacheIndex = null;\\t\\t// for the memory manager\\n\\n\\t\\tthis._timeScaleInterpolant = null;\\n\\t\\tthis._weightInterpolant = null;\\n\\n\\t\\tthis.loop = LoopRepeat;\\n\\t\\tthis._loopCount = - 1;\\n\\n\\t\\t// global mixer time when the action is to be started\\n\\t\\t// it's set back to 'null' upon start of the action\\n\\t\\tthis._startTime = null;\\n\\n\\t\\t// scaled local time of the action\\n\\t\\t// gets clamped or wrapped to 0..clip.duration according to loop\\n\\t\\tthis.time = 0;\\n\\n\\t\\tthis.timeScale = 1;\\n\\t\\tthis._effectiveTimeScale = 1;\\n\\n\\t\\tthis.weight = 1;\\n\\t\\tthis._effectiveWeight = 1;\\n\\n\\t\\tthis.repetitions = Infinity; \\t\\t// no. of repetitions when looping\\n\\n\\t\\tthis.paused = false;\\t\\t\\t\\t// true -> zero effective time scale\\n\\t\\tthis.enabled = true;\\t\\t\\t\\t// false -> zero effective weight\\n\\n\\t\\tthis.clampWhenFinished \\t= false;\\t// keep feeding the last frame?\\n\\n\\t\\tthis.zeroSlopeAtStart \\t= true;\\t\\t// for smooth interpolation w/o separate\\n\\t\\tthis.zeroSlopeAtEnd\\t\\t= true;\\t\\t// clips for start, loop and end\\n\\n\\t}\\n\\n\\tObject.assign( AnimationAction.prototype, {\\n\\n\\t\\t// State & Scheduling\\n\\n\\t\\tplay: function () {\\n\\n\\t\\t\\tthis._mixer._activateAction( this );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tstop: function () {\\n\\n\\t\\t\\tthis._mixer._deactivateAction( this );\\n\\n\\t\\t\\treturn this.reset();\\n\\n\\t\\t},\\n\\n\\t\\treset: function () {\\n\\n\\t\\t\\tthis.paused = false;\\n\\t\\t\\tthis.enabled = true;\\n\\n\\t\\t\\tthis.time = 0;\\t\\t\\t// restart clip\\n\\t\\t\\tthis._loopCount = - 1;\\t// forget previous loops\\n\\t\\t\\tthis._startTime = null;\\t// forget scheduling\\n\\n\\t\\t\\treturn this.stopFading().stopWarping();\\n\\n\\t\\t},\\n\\n\\t\\tisRunning: function () {\\n\\n\\t\\t\\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\\n\\t\\t\\t\\t\\tthis._startTime === null && this._mixer._isActiveAction( this );\\n\\n\\t\\t},\\n\\n\\t\\t// return true when play has been called\\n\\t\\tisScheduled: function () {\\n\\n\\t\\t\\treturn this._mixer._isActiveAction( this );\\n\\n\\t\\t},\\n\\n\\t\\tstartAt: function ( time ) {\\n\\n\\t\\t\\tthis._startTime = time;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetLoop: function ( mode, repetitions ) {\\n\\n\\t\\t\\tthis.loop = mode;\\n\\t\\t\\tthis.repetitions = repetitions;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t// Weight\\n\\n\\t\\t// set the weight stopping any scheduled fading\\n\\t\\t// although .enabled = false yields an effective weight of zero, this\\n\\t\\t// method does *not* change .enabled, because it would be confusing\\n\\t\\tsetEffectiveWeight: function ( weight ) {\\n\\n\\t\\t\\tthis.weight = weight;\\n\\n\\t\\t\\t// note: same logic as when updated at runtime\\n\\t\\t\\tthis._effectiveWeight = this.enabled ? weight : 0;\\n\\n\\t\\t\\treturn this.stopFading();\\n\\n\\t\\t},\\n\\n\\t\\t// return the weight considering fading and .enabled\\n\\t\\tgetEffectiveWeight: function () {\\n\\n\\t\\t\\treturn this._effectiveWeight;\\n\\n\\t\\t},\\n\\n\\t\\tfadeIn: function ( duration ) {\\n\\n\\t\\t\\treturn this._scheduleFading( duration, 0, 1 );\\n\\n\\t\\t},\\n\\n\\t\\tfadeOut: function ( duration ) {\\n\\n\\t\\t\\treturn this._scheduleFading( duration, 1, 0 );\\n\\n\\t\\t},\\n\\n\\t\\tcrossFadeFrom: function ( fadeOutAction, duration, warp ) {\\n\\n\\t\\t\\tfadeOutAction.fadeOut( duration );\\n\\t\\t\\tthis.fadeIn( duration );\\n\\n\\t\\t\\tif ( warp ) {\\n\\n\\t\\t\\t\\tvar fadeInDuration = this._clip.duration,\\n\\t\\t\\t\\t\\tfadeOutDuration = fadeOutAction._clip.duration,\\n\\n\\t\\t\\t\\t\\tstartEndRatio = fadeOutDuration / fadeInDuration,\\n\\t\\t\\t\\t\\tendStartRatio = fadeInDuration / fadeOutDuration;\\n\\n\\t\\t\\t\\tfadeOutAction.warp( 1.0, startEndRatio, duration );\\n\\t\\t\\t\\tthis.warp( endStartRatio, 1.0, duration );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcrossFadeTo: function ( fadeInAction, duration, warp ) {\\n\\n\\t\\t\\treturn fadeInAction.crossFadeFrom( this, duration, warp );\\n\\n\\t\\t},\\n\\n\\t\\tstopFading: function () {\\n\\n\\t\\t\\tvar weightInterpolant = this._weightInterpolant;\\n\\n\\t\\t\\tif ( weightInterpolant !== null ) {\\n\\n\\t\\t\\t\\tthis._weightInterpolant = null;\\n\\t\\t\\t\\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t// Time Scale Control\\n\\n\\t\\t// set the time scale stopping any scheduled warping\\n\\t\\t// although .paused = true yields an effective time scale of zero, this\\n\\t\\t// method does *not* change .paused, because it would be confusing\\n\\t\\tsetEffectiveTimeScale: function ( timeScale ) {\\n\\n\\t\\t\\tthis.timeScale = timeScale;\\n\\t\\t\\tthis._effectiveTimeScale = this.paused ? 0 : timeScale;\\n\\n\\t\\t\\treturn this.stopWarping();\\n\\n\\t\\t},\\n\\n\\t\\t// return the time scale considering warping and .paused\\n\\t\\tgetEffectiveTimeScale: function () {\\n\\n\\t\\t\\treturn this._effectiveTimeScale;\\n\\n\\t\\t},\\n\\n\\t\\tsetDuration: function ( duration ) {\\n\\n\\t\\t\\tthis.timeScale = this._clip.duration / duration;\\n\\n\\t\\t\\treturn this.stopWarping();\\n\\n\\t\\t},\\n\\n\\t\\tsyncWith: function ( action ) {\\n\\n\\t\\t\\tthis.time = action.time;\\n\\t\\t\\tthis.timeScale = action.timeScale;\\n\\n\\t\\t\\treturn this.stopWarping();\\n\\n\\t\\t},\\n\\n\\t\\thalt: function ( duration ) {\\n\\n\\t\\t\\treturn this.warp( this._effectiveTimeScale, 0, duration );\\n\\n\\t\\t},\\n\\n\\t\\twarp: function ( startTimeScale, endTimeScale, duration ) {\\n\\n\\t\\t\\tvar mixer = this._mixer, now = mixer.time,\\n\\t\\t\\t\\tinterpolant = this._timeScaleInterpolant,\\n\\n\\t\\t\\t\\ttimeScale = this.timeScale;\\n\\n\\t\\t\\tif ( interpolant === null ) {\\n\\n\\t\\t\\t\\tinterpolant = mixer._lendControlInterpolant();\\n\\t\\t\\t\\tthis._timeScaleInterpolant = interpolant;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar times = interpolant.parameterPositions,\\n\\t\\t\\t\\tvalues = interpolant.sampleValues;\\n\\n\\t\\t\\ttimes[ 0 ] = now;\\n\\t\\t\\ttimes[ 1 ] = now + duration;\\n\\n\\t\\t\\tvalues[ 0 ] = startTimeScale / timeScale;\\n\\t\\t\\tvalues[ 1 ] = endTimeScale / timeScale;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tstopWarping: function () {\\n\\n\\t\\t\\tvar timeScaleInterpolant = this._timeScaleInterpolant;\\n\\n\\t\\t\\tif ( timeScaleInterpolant !== null ) {\\n\\n\\t\\t\\t\\tthis._timeScaleInterpolant = null;\\n\\t\\t\\t\\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t// Object Accessors\\n\\n\\t\\tgetMixer: function () {\\n\\n\\t\\t\\treturn this._mixer;\\n\\n\\t\\t},\\n\\n\\t\\tgetClip: function () {\\n\\n\\t\\t\\treturn this._clip;\\n\\n\\t\\t},\\n\\n\\t\\tgetRoot: function () {\\n\\n\\t\\t\\treturn this._localRoot || this._mixer._root;\\n\\n\\t\\t},\\n\\n\\t\\t// Interna\\n\\n\\t\\t_update: function ( time, deltaTime, timeDirection, accuIndex ) {\\n\\n\\t\\t\\t// called by the mixer\\n\\n\\t\\t\\tif ( ! this.enabled ) {\\n\\n\\t\\t\\t\\t// call ._updateWeight() to update ._effectiveWeight\\n\\n\\t\\t\\t\\tthis._updateWeight( time );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar startTime = this._startTime;\\n\\n\\t\\t\\tif ( startTime !== null ) {\\n\\n\\t\\t\\t\\t// check for scheduled start of action\\n\\n\\t\\t\\t\\tvar timeRunning = ( time - startTime ) * timeDirection;\\n\\t\\t\\t\\tif ( timeRunning < 0 || timeDirection === 0 ) {\\n\\n\\t\\t\\t\\t\\treturn; // yet to come / don't decide when delta = 0\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// start\\n\\n\\t\\t\\t\\tthis._startTime = null; // unschedule\\n\\t\\t\\t\\tdeltaTime = timeDirection * timeRunning;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// apply time scale and advance time\\n\\n\\t\\t\\tdeltaTime *= this._updateTimeScale( time );\\n\\t\\t\\tvar clipTime = this._updateTime( deltaTime );\\n\\n\\t\\t\\t// note: _updateTime may disable the action resulting in\\n\\t\\t\\t// an effective weight of 0\\n\\n\\t\\t\\tvar weight = this._updateWeight( time );\\n\\n\\t\\t\\tif ( weight > 0 ) {\\n\\n\\t\\t\\t\\tvar interpolants = this._interpolants;\\n\\t\\t\\t\\tvar propertyMixers = this._propertyBindings;\\n\\n\\t\\t\\t\\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\\n\\n\\t\\t\\t\\t\\tinterpolants[ j ].evaluate( clipTime );\\n\\t\\t\\t\\t\\tpropertyMixers[ j ].accumulate( accuIndex, weight );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t_updateWeight: function ( time ) {\\n\\n\\t\\t\\tvar weight = 0;\\n\\n\\t\\t\\tif ( this.enabled ) {\\n\\n\\t\\t\\t\\tweight = this.weight;\\n\\t\\t\\t\\tvar interpolant = this._weightInterpolant;\\n\\n\\t\\t\\t\\tif ( interpolant !== null ) {\\n\\n\\t\\t\\t\\t\\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\\n\\n\\t\\t\\t\\t\\tweight *= interpolantValue;\\n\\n\\t\\t\\t\\t\\tif ( time > interpolant.parameterPositions[ 1 ] ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.stopFading();\\n\\n\\t\\t\\t\\t\\t\\tif ( interpolantValue === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// faded out, disable\\n\\t\\t\\t\\t\\t\\t\\tthis.enabled = false;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._effectiveWeight = weight;\\n\\t\\t\\treturn weight;\\n\\n\\t\\t},\\n\\n\\t\\t_updateTimeScale: function ( time ) {\\n\\n\\t\\t\\tvar timeScale = 0;\\n\\n\\t\\t\\tif ( ! this.paused ) {\\n\\n\\t\\t\\t\\ttimeScale = this.timeScale;\\n\\n\\t\\t\\t\\tvar interpolant = this._timeScaleInterpolant;\\n\\n\\t\\t\\t\\tif ( interpolant !== null ) {\\n\\n\\t\\t\\t\\t\\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\\n\\n\\t\\t\\t\\t\\ttimeScale *= interpolantValue;\\n\\n\\t\\t\\t\\t\\tif ( time > interpolant.parameterPositions[ 1 ] ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.stopWarping();\\n\\n\\t\\t\\t\\t\\t\\tif ( timeScale === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// motion has halted, pause\\n\\t\\t\\t\\t\\t\\t\\tthis.paused = true;\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t// warp done - apply final time scale\\n\\t\\t\\t\\t\\t\\t\\tthis.timeScale = timeScale;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._effectiveTimeScale = timeScale;\\n\\t\\t\\treturn timeScale;\\n\\n\\t\\t},\\n\\n\\t\\t_updateTime: function ( deltaTime ) {\\n\\n\\t\\t\\tvar time = this.time + deltaTime;\\n\\n\\t\\t\\tif ( deltaTime === 0 ) return time;\\n\\n\\t\\t\\tvar duration = this._clip.duration,\\n\\n\\t\\t\\t\\tloop = this.loop,\\n\\t\\t\\t\\tloopCount = this._loopCount;\\n\\n\\t\\t\\tif ( loop === LoopOnce ) {\\n\\n\\t\\t\\t\\tif ( loopCount === - 1 ) {\\n\\n\\t\\t\\t\\t\\t// just started\\n\\n\\t\\t\\t\\t\\tthis._loopCount = 0;\\n\\t\\t\\t\\t\\tthis._setEndings( true, true, false );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\thandle_stop: {\\n\\n\\t\\t\\t\\t\\tif ( time >= duration ) {\\n\\n\\t\\t\\t\\t\\t\\ttime = duration;\\n\\n\\t\\t\\t\\t\\t} else if ( time < 0 ) {\\n\\n\\t\\t\\t\\t\\t\\ttime = 0;\\n\\n\\t\\t\\t\\t\\t} else break handle_stop;\\n\\n\\t\\t\\t\\t\\tif ( this.clampWhenFinished ) this.paused = true;\\n\\t\\t\\t\\t\\telse this.enabled = false;\\n\\n\\t\\t\\t\\t\\tthis._mixer.dispatchEvent( {\\n\\t\\t\\t\\t\\t\\ttype: 'finished', action: this,\\n\\t\\t\\t\\t\\t\\tdirection: deltaTime < 0 ? - 1 : 1\\n\\t\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else { // repetitive Repeat or PingPong\\n\\n\\t\\t\\t\\tvar pingPong = ( loop === LoopPingPong );\\n\\n\\t\\t\\t\\tif ( loopCount === - 1 ) {\\n\\n\\t\\t\\t\\t\\t// just started\\n\\n\\t\\t\\t\\t\\tif ( deltaTime >= 0 ) {\\n\\n\\t\\t\\t\\t\\t\\tloopCount = 0;\\n\\n\\t\\t\\t\\t\\t\\tthis._setEndings( true, this.repetitions === 0, pingPong );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t// when looping in reverse direction, the initial\\n\\t\\t\\t\\t\\t\\t// transition through zero counts as a repetition,\\n\\t\\t\\t\\t\\t\\t// so leave loopCount at -1\\n\\n\\t\\t\\t\\t\\t\\tthis._setEndings( this.repetitions === 0, true, pingPong );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( time >= duration || time < 0 ) {\\n\\n\\t\\t\\t\\t\\t// wrap around\\n\\n\\t\\t\\t\\t\\tvar loopDelta = Math.floor( time / duration ); // signed\\n\\t\\t\\t\\t\\ttime -= duration * loopDelta;\\n\\n\\t\\t\\t\\t\\tloopCount += Math.abs( loopDelta );\\n\\n\\t\\t\\t\\t\\tvar pending = this.repetitions - loopCount;\\n\\n\\t\\t\\t\\t\\tif ( pending < 0 ) {\\n\\n\\t\\t\\t\\t\\t\\t// have to stop (switch state, clamp time, fire event)\\n\\n\\t\\t\\t\\t\\t\\tif ( this.clampWhenFinished ) this.paused = true;\\n\\t\\t\\t\\t\\t\\telse this.enabled = false;\\n\\n\\t\\t\\t\\t\\t\\ttime = deltaTime > 0 ? duration : 0;\\n\\n\\t\\t\\t\\t\\t\\tthis._mixer.dispatchEvent( {\\n\\t\\t\\t\\t\\t\\t\\ttype: 'finished', action: this,\\n\\t\\t\\t\\t\\t\\t\\tdirection: deltaTime > 0 ? 1 : - 1\\n\\t\\t\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t// keep running\\n\\n\\t\\t\\t\\t\\t\\tif ( pending === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// entering the last round\\n\\n\\t\\t\\t\\t\\t\\t\\tvar atStart = deltaTime < 0;\\n\\t\\t\\t\\t\\t\\t\\tthis._setEndings( atStart, ! atStart, pingPong );\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tthis._setEndings( false, false, pingPong );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tthis._loopCount = loopCount;\\n\\n\\t\\t\\t\\t\\t\\tthis._mixer.dispatchEvent( {\\n\\t\\t\\t\\t\\t\\t\\ttype: 'loop', action: this, loopDelta: loopDelta\\n\\t\\t\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\\n\\n\\t\\t\\t\\t\\t// invert time for the \\\"pong round\\\"\\n\\n\\t\\t\\t\\t\\tthis.time = time;\\n\\t\\t\\t\\t\\treturn duration - time;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.time = time;\\n\\t\\t\\treturn time;\\n\\n\\t\\t},\\n\\n\\t\\t_setEndings: function ( atStart, atEnd, pingPong ) {\\n\\n\\t\\t\\tvar settings = this._interpolantSettings;\\n\\n\\t\\t\\tif ( pingPong ) {\\n\\n\\t\\t\\t\\tsettings.endingStart \\t= ZeroSlopeEnding;\\n\\t\\t\\t\\tsettings.endingEnd\\t\\t= ZeroSlopeEnding;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// assuming for LoopOnce atStart == atEnd == true\\n\\n\\t\\t\\t\\tif ( atStart ) {\\n\\n\\t\\t\\t\\t\\tsettings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tsettings.endingStart = WrapAroundEnding;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( atEnd ) {\\n\\n\\t\\t\\t\\t\\tsettings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tsettings.endingEnd \\t = WrapAroundEnding;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t_scheduleFading: function ( duration, weightNow, weightThen ) {\\n\\n\\t\\t\\tvar mixer = this._mixer, now = mixer.time,\\n\\t\\t\\t\\tinterpolant = this._weightInterpolant;\\n\\n\\t\\t\\tif ( interpolant === null ) {\\n\\n\\t\\t\\t\\tinterpolant = mixer._lendControlInterpolant();\\n\\t\\t\\t\\tthis._weightInterpolant = interpolant;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar times = interpolant.parameterPositions,\\n\\t\\t\\t\\tvalues = interpolant.sampleValues;\\n\\n\\t\\t\\ttimes[ 0 ] = now; \\t\\t\\t\\tvalues[ 0 ] = weightNow;\\n\\t\\t\\ttimes[ 1 ] = now + duration;\\tvalues[ 1 ] = weightThen;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * Player for AnimationClips.\\n\\t *\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction AnimationMixer( root ) {\\n\\n\\t\\tthis._root = root;\\n\\t\\tthis._initMemoryManager();\\n\\t\\tthis._accuIndex = 0;\\n\\n\\t\\tthis.time = 0;\\n\\n\\t\\tthis.timeScale = 1.0;\\n\\n\\t}\\n\\n\\tAnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\n\\n\\t\\tconstructor: AnimationMixer,\\n\\n\\t\\t_bindAction: function ( action, prototypeAction ) {\\n\\n\\t\\t\\tvar root = action._localRoot || this._root,\\n\\t\\t\\t\\ttracks = action._clip.tracks,\\n\\t\\t\\t\\tnTracks = tracks.length,\\n\\t\\t\\t\\tbindings = action._propertyBindings,\\n\\t\\t\\t\\tinterpolants = action._interpolants,\\n\\t\\t\\t\\trootUuid = root.uuid,\\n\\t\\t\\t\\tbindingsByRoot = this._bindingsByRootAndName,\\n\\t\\t\\t\\tbindingsByName = bindingsByRoot[ rootUuid ];\\n\\n\\t\\t\\tif ( bindingsByName === undefined ) {\\n\\n\\t\\t\\t\\tbindingsByName = {};\\n\\t\\t\\t\\tbindingsByRoot[ rootUuid ] = bindingsByName;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var i = 0; i !== nTracks; ++ i ) {\\n\\n\\t\\t\\t\\tvar track = tracks[ i ],\\n\\t\\t\\t\\t\\ttrackName = track.name,\\n\\t\\t\\t\\t\\tbinding = bindingsByName[ trackName ];\\n\\n\\t\\t\\t\\tif ( binding !== undefined ) {\\n\\n\\t\\t\\t\\t\\tbindings[ i ] = binding;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tbinding = bindings[ i ];\\n\\n\\t\\t\\t\\t\\tif ( binding !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t// existing binding, make sure the cache knows\\n\\n\\t\\t\\t\\t\\t\\tif ( binding._cacheIndex === null ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t++ binding.referenceCount;\\n\\t\\t\\t\\t\\t\\t\\tthis._addInactiveBinding( binding, rootUuid, trackName );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvar path = prototypeAction && prototypeAction.\\n\\t\\t\\t\\t\\t\\t_propertyBindings[ i ].binding.parsedPath;\\n\\n\\t\\t\\t\\t\\tbinding = new PropertyMixer(\\n\\t\\t\\t\\t\\t\\tPropertyBinding.create( root, trackName, path ),\\n\\t\\t\\t\\t\\t\\ttrack.ValueTypeName, track.getValueSize() );\\n\\n\\t\\t\\t\\t\\t++ binding.referenceCount;\\n\\t\\t\\t\\t\\tthis._addInactiveBinding( binding, rootUuid, trackName );\\n\\n\\t\\t\\t\\t\\tbindings[ i ] = binding;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tinterpolants[ i ].resultBuffer = binding.buffer;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t_activateAction: function ( action ) {\\n\\n\\t\\t\\tif ( ! this._isActiveAction( action ) ) {\\n\\n\\t\\t\\t\\tif ( action._cacheIndex === null ) {\\n\\n\\t\\t\\t\\t\\t// this action has been forgotten by the cache, but the user\\n\\t\\t\\t\\t\\t// appears to be still using it -> rebind\\n\\n\\t\\t\\t\\t\\tvar rootUuid = ( action._localRoot || this._root ).uuid,\\n\\t\\t\\t\\t\\t\\tclipUuid = action._clip.uuid,\\n\\t\\t\\t\\t\\t\\tactionsForClip = this._actionsByClip[ clipUuid ];\\n\\n\\t\\t\\t\\t\\tthis._bindAction( action,\\n\\t\\t\\t\\t\\t\\tactionsForClip && actionsForClip.knownActions[ 0 ] );\\n\\n\\t\\t\\t\\t\\tthis._addInactiveAction( action, clipUuid, rootUuid );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar bindings = action._propertyBindings;\\n\\n\\t\\t\\t\\t// increment reference counts / sort out state\\n\\t\\t\\t\\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\tvar binding = bindings[ i ];\\n\\n\\t\\t\\t\\t\\tif ( binding.useCount ++ === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\tthis._lendBinding( binding );\\n\\t\\t\\t\\t\\t\\tbinding.saveOriginalState();\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis._lendAction( action );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t_deactivateAction: function ( action ) {\\n\\n\\t\\t\\tif ( this._isActiveAction( action ) ) {\\n\\n\\t\\t\\t\\tvar bindings = action._propertyBindings;\\n\\n\\t\\t\\t\\t// decrement reference counts / sort out state\\n\\t\\t\\t\\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\tvar binding = bindings[ i ];\\n\\n\\t\\t\\t\\t\\tif ( -- binding.useCount === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\tbinding.restoreOriginalState();\\n\\t\\t\\t\\t\\t\\tthis._takeBackBinding( binding );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis._takeBackAction( action );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t// Memory manager\\n\\n\\t\\t_initMemoryManager: function () {\\n\\n\\t\\t\\tthis._actions = []; // 'nActiveActions' followed by inactive ones\\n\\t\\t\\tthis._nActiveActions = 0;\\n\\n\\t\\t\\tthis._actionsByClip = {};\\n\\t\\t\\t// inside:\\n\\t\\t\\t// {\\n\\t\\t\\t// \\t\\tknownActions: Array< AnimationAction >\\t- used as prototypes\\n\\t\\t\\t// \\t\\tactionByRoot: AnimationAction\\t\\t\\t- lookup\\n\\t\\t\\t// }\\n\\n\\n\\t\\t\\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\\n\\t\\t\\tthis._nActiveBindings = 0;\\n\\n\\t\\t\\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\\n\\n\\n\\t\\t\\tthis._controlInterpolants = []; // same game as above\\n\\t\\t\\tthis._nActiveControlInterpolants = 0;\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tthis.stats = {\\n\\n\\t\\t\\t\\tactions: {\\n\\t\\t\\t\\t\\tget total() {\\n\\n\\t\\t\\t\\t\\t\\treturn scope._actions.length;\\n\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\tget inUse() {\\n\\n\\t\\t\\t\\t\\t\\treturn scope._nActiveActions;\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tbindings: {\\n\\t\\t\\t\\t\\tget total() {\\n\\n\\t\\t\\t\\t\\t\\treturn scope._bindings.length;\\n\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\tget inUse() {\\n\\n\\t\\t\\t\\t\\t\\treturn scope._nActiveBindings;\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tcontrolInterpolants: {\\n\\t\\t\\t\\t\\tget total() {\\n\\n\\t\\t\\t\\t\\t\\treturn scope._controlInterpolants.length;\\n\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\tget inUse() {\\n\\n\\t\\t\\t\\t\\t\\treturn scope._nActiveControlInterpolants;\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t},\\n\\n\\t\\t// Memory management for AnimationAction objects\\n\\n\\t\\t_isActiveAction: function ( action ) {\\n\\n\\t\\t\\tvar index = action._cacheIndex;\\n\\t\\t\\treturn index !== null && index < this._nActiveActions;\\n\\n\\t\\t},\\n\\n\\t\\t_addInactiveAction: function ( action, clipUuid, rootUuid ) {\\n\\n\\t\\t\\tvar actions = this._actions,\\n\\t\\t\\t\\tactionsByClip = this._actionsByClip,\\n\\t\\t\\t\\tactionsForClip = actionsByClip[ clipUuid ];\\n\\n\\t\\t\\tif ( actionsForClip === undefined ) {\\n\\n\\t\\t\\t\\tactionsForClip = {\\n\\n\\t\\t\\t\\t\\tknownActions: [ action ],\\n\\t\\t\\t\\t\\tactionByRoot: {}\\n\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\taction._byClipCacheIndex = 0;\\n\\n\\t\\t\\t\\tactionsByClip[ clipUuid ] = actionsForClip;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tvar knownActions = actionsForClip.knownActions;\\n\\n\\t\\t\\t\\taction._byClipCacheIndex = knownActions.length;\\n\\t\\t\\t\\tknownActions.push( action );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\taction._cacheIndex = actions.length;\\n\\t\\t\\tactions.push( action );\\n\\n\\t\\t\\tactionsForClip.actionByRoot[ rootUuid ] = action;\\n\\n\\t\\t},\\n\\n\\t\\t_removeInactiveAction: function ( action ) {\\n\\n\\t\\t\\tvar actions = this._actions,\\n\\t\\t\\t\\tlastInactiveAction = actions[ actions.length - 1 ],\\n\\t\\t\\t\\tcacheIndex = action._cacheIndex;\\n\\n\\t\\t\\tlastInactiveAction._cacheIndex = cacheIndex;\\n\\t\\t\\tactions[ cacheIndex ] = lastInactiveAction;\\n\\t\\t\\tactions.pop();\\n\\n\\t\\t\\taction._cacheIndex = null;\\n\\n\\n\\t\\t\\tvar clipUuid = action._clip.uuid,\\n\\t\\t\\t\\tactionsByClip = this._actionsByClip,\\n\\t\\t\\t\\tactionsForClip = actionsByClip[ clipUuid ],\\n\\t\\t\\t\\tknownActionsForClip = actionsForClip.knownActions,\\n\\n\\t\\t\\t\\tlastKnownAction =\\n\\t\\t\\t\\t\\tknownActionsForClip[ knownActionsForClip.length - 1 ],\\n\\n\\t\\t\\t\\tbyClipCacheIndex = action._byClipCacheIndex;\\n\\n\\t\\t\\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\\n\\t\\t\\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\\n\\t\\t\\tknownActionsForClip.pop();\\n\\n\\t\\t\\taction._byClipCacheIndex = null;\\n\\n\\n\\t\\t\\tvar actionByRoot = actionsForClip.actionByRoot,\\n\\t\\t\\t\\trootUuid = ( action._localRoot || this._root ).uuid;\\n\\n\\t\\t\\tdelete actionByRoot[ rootUuid ];\\n\\n\\t\\t\\tif ( knownActionsForClip.length === 0 ) {\\n\\n\\t\\t\\t\\tdelete actionsByClip[ clipUuid ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._removeInactiveBindingsForAction( action );\\n\\n\\t\\t},\\n\\n\\t\\t_removeInactiveBindingsForAction: function ( action ) {\\n\\n\\t\\t\\tvar bindings = action._propertyBindings;\\n\\t\\t\\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\tvar binding = bindings[ i ];\\n\\n\\t\\t\\t\\tif ( -- binding.referenceCount === 0 ) {\\n\\n\\t\\t\\t\\t\\tthis._removeInactiveBinding( binding );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t_lendAction: function ( action ) {\\n\\n\\t\\t\\t// [ active actions |  inactive actions  ]\\n\\t\\t\\t// [  active actions >| inactive actions ]\\n\\t\\t\\t//                 s        a\\n\\t\\t\\t//                  <-swap->\\n\\t\\t\\t//                 a        s\\n\\n\\t\\t\\tvar actions = this._actions,\\n\\t\\t\\t\\tprevIndex = action._cacheIndex,\\n\\n\\t\\t\\t\\tlastActiveIndex = this._nActiveActions ++,\\n\\n\\t\\t\\t\\tfirstInactiveAction = actions[ lastActiveIndex ];\\n\\n\\t\\t\\taction._cacheIndex = lastActiveIndex;\\n\\t\\t\\tactions[ lastActiveIndex ] = action;\\n\\n\\t\\t\\tfirstInactiveAction._cacheIndex = prevIndex;\\n\\t\\t\\tactions[ prevIndex ] = firstInactiveAction;\\n\\n\\t\\t},\\n\\n\\t\\t_takeBackAction: function ( action ) {\\n\\n\\t\\t\\t// [  active actions  | inactive actions ]\\n\\t\\t\\t// [ active actions |< inactive actions  ]\\n\\t\\t\\t//        a        s\\n\\t\\t\\t//         <-swap->\\n\\t\\t\\t//        s        a\\n\\n\\t\\t\\tvar actions = this._actions,\\n\\t\\t\\t\\tprevIndex = action._cacheIndex,\\n\\n\\t\\t\\t\\tfirstInactiveIndex = -- this._nActiveActions,\\n\\n\\t\\t\\t\\tlastActiveAction = actions[ firstInactiveIndex ];\\n\\n\\t\\t\\taction._cacheIndex = firstInactiveIndex;\\n\\t\\t\\tactions[ firstInactiveIndex ] = action;\\n\\n\\t\\t\\tlastActiveAction._cacheIndex = prevIndex;\\n\\t\\t\\tactions[ prevIndex ] = lastActiveAction;\\n\\n\\t\\t},\\n\\n\\t\\t// Memory management for PropertyMixer objects\\n\\n\\t\\t_addInactiveBinding: function ( binding, rootUuid, trackName ) {\\n\\n\\t\\t\\tvar bindingsByRoot = this._bindingsByRootAndName,\\n\\t\\t\\t\\tbindingByName = bindingsByRoot[ rootUuid ],\\n\\n\\t\\t\\t\\tbindings = this._bindings;\\n\\n\\t\\t\\tif ( bindingByName === undefined ) {\\n\\n\\t\\t\\t\\tbindingByName = {};\\n\\t\\t\\t\\tbindingsByRoot[ rootUuid ] = bindingByName;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tbindingByName[ trackName ] = binding;\\n\\n\\t\\t\\tbinding._cacheIndex = bindings.length;\\n\\t\\t\\tbindings.push( binding );\\n\\n\\t\\t},\\n\\n\\t\\t_removeInactiveBinding: function ( binding ) {\\n\\n\\t\\t\\tvar bindings = this._bindings,\\n\\t\\t\\t\\tpropBinding = binding.binding,\\n\\t\\t\\t\\trootUuid = propBinding.rootNode.uuid,\\n\\t\\t\\t\\ttrackName = propBinding.path,\\n\\t\\t\\t\\tbindingsByRoot = this._bindingsByRootAndName,\\n\\t\\t\\t\\tbindingByName = bindingsByRoot[ rootUuid ],\\n\\n\\t\\t\\t\\tlastInactiveBinding = bindings[ bindings.length - 1 ],\\n\\t\\t\\t\\tcacheIndex = binding._cacheIndex;\\n\\n\\t\\t\\tlastInactiveBinding._cacheIndex = cacheIndex;\\n\\t\\t\\tbindings[ cacheIndex ] = lastInactiveBinding;\\n\\t\\t\\tbindings.pop();\\n\\n\\t\\t\\tdelete bindingByName[ trackName ];\\n\\n\\t\\t\\tremove_empty_map: {\\n\\n\\t\\t\\t\\tfor ( var _ in bindingByName ) break remove_empty_map; // eslint-disable-line no-unused-vars\\n\\n\\t\\t\\t\\tdelete bindingsByRoot[ rootUuid ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t_lendBinding: function ( binding ) {\\n\\n\\t\\t\\tvar bindings = this._bindings,\\n\\t\\t\\t\\tprevIndex = binding._cacheIndex,\\n\\n\\t\\t\\t\\tlastActiveIndex = this._nActiveBindings ++,\\n\\n\\t\\t\\t\\tfirstInactiveBinding = bindings[ lastActiveIndex ];\\n\\n\\t\\t\\tbinding._cacheIndex = lastActiveIndex;\\n\\t\\t\\tbindings[ lastActiveIndex ] = binding;\\n\\n\\t\\t\\tfirstInactiveBinding._cacheIndex = prevIndex;\\n\\t\\t\\tbindings[ prevIndex ] = firstInactiveBinding;\\n\\n\\t\\t},\\n\\n\\t\\t_takeBackBinding: function ( binding ) {\\n\\n\\t\\t\\tvar bindings = this._bindings,\\n\\t\\t\\t\\tprevIndex = binding._cacheIndex,\\n\\n\\t\\t\\t\\tfirstInactiveIndex = -- this._nActiveBindings,\\n\\n\\t\\t\\t\\tlastActiveBinding = bindings[ firstInactiveIndex ];\\n\\n\\t\\t\\tbinding._cacheIndex = firstInactiveIndex;\\n\\t\\t\\tbindings[ firstInactiveIndex ] = binding;\\n\\n\\t\\t\\tlastActiveBinding._cacheIndex = prevIndex;\\n\\t\\t\\tbindings[ prevIndex ] = lastActiveBinding;\\n\\n\\t\\t},\\n\\n\\n\\t\\t// Memory management of Interpolants for weight and time scale\\n\\n\\t\\t_lendControlInterpolant: function () {\\n\\n\\t\\t\\tvar interpolants = this._controlInterpolants,\\n\\t\\t\\t\\tlastActiveIndex = this._nActiveControlInterpolants ++,\\n\\t\\t\\t\\tinterpolant = interpolants[ lastActiveIndex ];\\n\\n\\t\\t\\tif ( interpolant === undefined ) {\\n\\n\\t\\t\\t\\tinterpolant = new LinearInterpolant(\\n\\t\\t\\t\\t\\tnew Float32Array( 2 ), new Float32Array( 2 ),\\n\\t\\t\\t\\t\\t1, this._controlInterpolantsResultBuffer );\\n\\n\\t\\t\\t\\tinterpolant.__cacheIndex = lastActiveIndex;\\n\\t\\t\\t\\tinterpolants[ lastActiveIndex ] = interpolant;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn interpolant;\\n\\n\\t\\t},\\n\\n\\t\\t_takeBackControlInterpolant: function ( interpolant ) {\\n\\n\\t\\t\\tvar interpolants = this._controlInterpolants,\\n\\t\\t\\t\\tprevIndex = interpolant.__cacheIndex,\\n\\n\\t\\t\\t\\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\\n\\n\\t\\t\\t\\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\\n\\n\\t\\t\\tinterpolant.__cacheIndex = firstInactiveIndex;\\n\\t\\t\\tinterpolants[ firstInactiveIndex ] = interpolant;\\n\\n\\t\\t\\tlastActiveInterpolant.__cacheIndex = prevIndex;\\n\\t\\t\\tinterpolants[ prevIndex ] = lastActiveInterpolant;\\n\\n\\t\\t},\\n\\n\\t\\t_controlInterpolantsResultBuffer: new Float32Array( 1 ),\\n\\n\\t\\t// return an action for a clip optionally using a custom root target\\n\\t\\t// object (this method allocates a lot of dynamic memory in case a\\n\\t\\t// previously unknown clip/root combination is specified)\\n\\t\\tclipAction: function ( clip, optionalRoot ) {\\n\\n\\t\\t\\tvar root = optionalRoot || this._root,\\n\\t\\t\\t\\trootUuid = root.uuid,\\n\\n\\t\\t\\t\\tclipObject = typeof clip === 'string' ?\\n\\t\\t\\t\\t\\tAnimationClip.findByName( root, clip ) : clip,\\n\\n\\t\\t\\t\\tclipUuid = clipObject !== null ? clipObject.uuid : clip,\\n\\n\\t\\t\\t\\tactionsForClip = this._actionsByClip[ clipUuid ],\\n\\t\\t\\t\\tprototypeAction = null;\\n\\n\\t\\t\\tif ( actionsForClip !== undefined ) {\\n\\n\\t\\t\\t\\tvar existingAction =\\n\\t\\t\\t\\t\\t\\tactionsForClip.actionByRoot[ rootUuid ];\\n\\n\\t\\t\\t\\tif ( existingAction !== undefined ) {\\n\\n\\t\\t\\t\\t\\treturn existingAction;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// we know the clip, so we don't have to parse all\\n\\t\\t\\t\\t// the bindings again but can just copy\\n\\t\\t\\t\\tprototypeAction = actionsForClip.knownActions[ 0 ];\\n\\n\\t\\t\\t\\t// also, take the clip from the prototype action\\n\\t\\t\\t\\tif ( clipObject === null )\\n\\t\\t\\t\\t\\tclipObject = prototypeAction._clip;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// clip must be known when specified via string\\n\\t\\t\\tif ( clipObject === null ) return null;\\n\\n\\t\\t\\t// allocate all resources required to run it\\n\\t\\t\\tvar newAction = new AnimationAction( this, clipObject, optionalRoot );\\n\\n\\t\\t\\tthis._bindAction( newAction, prototypeAction );\\n\\n\\t\\t\\t// and make the action known to the memory manager\\n\\t\\t\\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\\n\\n\\t\\t\\treturn newAction;\\n\\n\\t\\t},\\n\\n\\t\\t// get an existing action\\n\\t\\texistingAction: function ( clip, optionalRoot ) {\\n\\n\\t\\t\\tvar root = optionalRoot || this._root,\\n\\t\\t\\t\\trootUuid = root.uuid,\\n\\n\\t\\t\\t\\tclipObject = typeof clip === 'string' ?\\n\\t\\t\\t\\t\\tAnimationClip.findByName( root, clip ) : clip,\\n\\n\\t\\t\\t\\tclipUuid = clipObject ? clipObject.uuid : clip,\\n\\n\\t\\t\\t\\tactionsForClip = this._actionsByClip[ clipUuid ];\\n\\n\\t\\t\\tif ( actionsForClip !== undefined ) {\\n\\n\\t\\t\\t\\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn null;\\n\\n\\t\\t},\\n\\n\\t\\t// deactivates all previously scheduled actions\\n\\t\\tstopAllAction: function () {\\n\\n\\t\\t\\tvar actions = this._actions,\\n\\t\\t\\t\\tnActions = this._nActiveActions,\\n\\t\\t\\t\\tbindings = this._bindings,\\n\\t\\t\\t\\tnBindings = this._nActiveBindings;\\n\\n\\t\\t\\tthis._nActiveActions = 0;\\n\\t\\t\\tthis._nActiveBindings = 0;\\n\\n\\t\\t\\tfor ( var i = 0; i !== nActions; ++ i ) {\\n\\n\\t\\t\\t\\tactions[ i ].reset();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var i = 0; i !== nBindings; ++ i ) {\\n\\n\\t\\t\\t\\tbindings[ i ].useCount = 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t// advance the time and update apply the animation\\n\\t\\tupdate: function ( deltaTime ) {\\n\\n\\t\\t\\tdeltaTime *= this.timeScale;\\n\\n\\t\\t\\tvar actions = this._actions,\\n\\t\\t\\t\\tnActions = this._nActiveActions,\\n\\n\\t\\t\\t\\ttime = this.time += deltaTime,\\n\\t\\t\\t\\ttimeDirection = Math.sign( deltaTime ),\\n\\n\\t\\t\\t\\taccuIndex = this._accuIndex ^= 1;\\n\\n\\t\\t\\t// run active actions\\n\\n\\t\\t\\tfor ( var i = 0; i !== nActions; ++ i ) {\\n\\n\\t\\t\\t\\tvar action = actions[ i ];\\n\\n\\t\\t\\t\\taction._update( time, deltaTime, timeDirection, accuIndex );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// update scene graph\\n\\n\\t\\t\\tvar bindings = this._bindings,\\n\\t\\t\\t\\tnBindings = this._nActiveBindings;\\n\\n\\t\\t\\tfor ( var i = 0; i !== nBindings; ++ i ) {\\n\\n\\t\\t\\t\\tbindings[ i ].apply( accuIndex );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t// return this mixer's root target object\\n\\t\\tgetRoot: function () {\\n\\n\\t\\t\\treturn this._root;\\n\\n\\t\\t},\\n\\n\\t\\t// free all resources specific to a particular clip\\n\\t\\tuncacheClip: function ( clip ) {\\n\\n\\t\\t\\tvar actions = this._actions,\\n\\t\\t\\t\\tclipUuid = clip.uuid,\\n\\t\\t\\t\\tactionsByClip = this._actionsByClip,\\n\\t\\t\\t\\tactionsForClip = actionsByClip[ clipUuid ];\\n\\n\\t\\t\\tif ( actionsForClip !== undefined ) {\\n\\n\\t\\t\\t\\t// note: just calling _removeInactiveAction would mess up the\\n\\t\\t\\t\\t// iteration state and also require updating the state we can\\n\\t\\t\\t\\t// just throw away\\n\\n\\t\\t\\t\\tvar actionsToRemove = actionsForClip.knownActions;\\n\\n\\t\\t\\t\\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\tvar action = actionsToRemove[ i ];\\n\\n\\t\\t\\t\\t\\tthis._deactivateAction( action );\\n\\n\\t\\t\\t\\t\\tvar cacheIndex = action._cacheIndex,\\n\\t\\t\\t\\t\\t\\tlastInactiveAction = actions[ actions.length - 1 ];\\n\\n\\t\\t\\t\\t\\taction._cacheIndex = null;\\n\\t\\t\\t\\t\\taction._byClipCacheIndex = null;\\n\\n\\t\\t\\t\\t\\tlastInactiveAction._cacheIndex = cacheIndex;\\n\\t\\t\\t\\t\\tactions[ cacheIndex ] = lastInactiveAction;\\n\\t\\t\\t\\t\\tactions.pop();\\n\\n\\t\\t\\t\\t\\tthis._removeInactiveBindingsForAction( action );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdelete actionsByClip[ clipUuid ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t// free all resources specific to a particular root target object\\n\\t\\tuncacheRoot: function ( root ) {\\n\\n\\t\\t\\tvar rootUuid = root.uuid,\\n\\t\\t\\t\\tactionsByClip = this._actionsByClip;\\n\\n\\t\\t\\tfor ( var clipUuid in actionsByClip ) {\\n\\n\\t\\t\\t\\tvar actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\\n\\t\\t\\t\\t\\taction = actionByRoot[ rootUuid ];\\n\\n\\t\\t\\t\\tif ( action !== undefined ) {\\n\\n\\t\\t\\t\\t\\tthis._deactivateAction( action );\\n\\t\\t\\t\\t\\tthis._removeInactiveAction( action );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar bindingsByRoot = this._bindingsByRootAndName,\\n\\t\\t\\t\\tbindingByName = bindingsByRoot[ rootUuid ];\\n\\n\\t\\t\\tif ( bindingByName !== undefined ) {\\n\\n\\t\\t\\t\\tfor ( var trackName in bindingByName ) {\\n\\n\\t\\t\\t\\t\\tvar binding = bindingByName[ trackName ];\\n\\t\\t\\t\\t\\tbinding.restoreOriginalState();\\n\\t\\t\\t\\t\\tthis._removeInactiveBinding( binding );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t// remove a targeted clip from the cache\\n\\t\\tuncacheAction: function ( clip, optionalRoot ) {\\n\\n\\t\\t\\tvar action = this.existingAction( clip, optionalRoot );\\n\\n\\t\\t\\tif ( action !== null ) {\\n\\n\\t\\t\\t\\tthis._deactivateAction( action );\\n\\t\\t\\t\\tthis._removeInactiveAction( action );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction Uniform( value ) {\\n\\n\\t\\tif ( typeof value === 'string' ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\\n\\t\\t\\tvalue = arguments[ 1 ];\\n\\n\\t\\t}\\n\\n\\t\\tthis.value = value;\\n\\n\\t}\\n\\n\\tUniform.prototype.clone = function () {\\n\\n\\t\\treturn new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author benaadams / https://twitter.com/ben_a_adams\\n\\t */\\n\\n\\tfunction InstancedBufferGeometry() {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'InstancedBufferGeometry';\\n\\t\\tthis.maxInstancedCount = undefined;\\n\\n\\t}\\n\\n\\tInstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {\\n\\n\\t\\tconstructor: InstancedBufferGeometry,\\n\\n\\t\\tisInstancedBufferGeometry: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tBufferGeometry.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.maxInstancedCount = source.maxInstancedCount;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author benaadams / https://twitter.com/ben_a_adams\\n\\t */\\n\\n\\tfunction InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\tthis.data = interleavedBuffer;\\n\\t\\tthis.itemSize = itemSize;\\n\\t\\tthis.offset = offset;\\n\\n\\t\\tthis.normalized = normalized === true;\\n\\n\\t}\\n\\n\\tObject.defineProperties( InterleavedBufferAttribute.prototype, {\\n\\n\\t\\tcount: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this.data.count;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tarray: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this.data.array;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( InterleavedBufferAttribute.prototype, {\\n\\n\\t\\tisInterleavedBufferAttribute: true,\\n\\n\\t\\tsetX: function ( index, x ) {\\n\\n\\t\\t\\tthis.data.array[ index * this.data.stride + this.offset ] = x;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetY: function ( index, y ) {\\n\\n\\t\\t\\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetZ: function ( index, z ) {\\n\\n\\t\\t\\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetW: function ( index, w ) {\\n\\n\\t\\t\\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetX: function ( index ) {\\n\\n\\t\\t\\treturn this.data.array[ index * this.data.stride + this.offset ];\\n\\n\\t\\t},\\n\\n\\t\\tgetY: function ( index ) {\\n\\n\\t\\t\\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\\n\\n\\t\\t},\\n\\n\\t\\tgetZ: function ( index ) {\\n\\n\\t\\t\\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\\n\\n\\t\\t},\\n\\n\\t\\tgetW: function ( index ) {\\n\\n\\t\\t\\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\\n\\n\\t\\t},\\n\\n\\t\\tsetXY: function ( index, x, y ) {\\n\\n\\t\\t\\tindex = index * this.data.stride + this.offset;\\n\\n\\t\\t\\tthis.data.array[ index + 0 ] = x;\\n\\t\\t\\tthis.data.array[ index + 1 ] = y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetXYZ: function ( index, x, y, z ) {\\n\\n\\t\\t\\tindex = index * this.data.stride + this.offset;\\n\\n\\t\\t\\tthis.data.array[ index + 0 ] = x;\\n\\t\\t\\tthis.data.array[ index + 1 ] = y;\\n\\t\\t\\tthis.data.array[ index + 2 ] = z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetXYZW: function ( index, x, y, z, w ) {\\n\\n\\t\\t\\tindex = index * this.data.stride + this.offset;\\n\\n\\t\\t\\tthis.data.array[ index + 0 ] = x;\\n\\t\\t\\tthis.data.array[ index + 1 ] = y;\\n\\t\\t\\tthis.data.array[ index + 2 ] = z;\\n\\t\\t\\tthis.data.array[ index + 3 ] = w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author benaadams / https://twitter.com/ben_a_adams\\n\\t */\\n\\n\\tfunction InterleavedBuffer( array, stride ) {\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\tthis.array = array;\\n\\t\\tthis.stride = stride;\\n\\t\\tthis.count = array !== undefined ? array.length / stride : 0;\\n\\n\\t\\tthis.dynamic = false;\\n\\t\\tthis.updateRange = { offset: 0, count: - 1 };\\n\\n\\t\\tthis.onUploadCallback = function () {};\\n\\n\\t\\tthis.version = 0;\\n\\n\\t}\\n\\n\\tObject.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tif ( value === true ) this.version ++;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( InterleavedBuffer.prototype, {\\n\\n\\t\\tisInterleavedBuffer: true,\\n\\n\\t\\tsetArray: function ( array ) {\\n\\n\\t\\t\\tif ( Array.isArray( array ) ) {\\n\\n\\t\\t\\t\\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.count = array !== undefined ? array.length / this.stride : 0;\\n\\t\\t\\tthis.array = array;\\n\\n\\t\\t},\\n\\n\\t\\tsetDynamic: function ( value ) {\\n\\n\\t\\t\\tthis.dynamic = value;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tthis.array = new source.array.constructor( source.array );\\n\\t\\t\\tthis.count = source.count;\\n\\t\\t\\tthis.stride = source.stride;\\n\\t\\t\\tthis.dynamic = source.dynamic;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyAt: function ( index1, attribute, index2 ) {\\n\\n\\t\\t\\tindex1 *= this.stride;\\n\\t\\t\\tindex2 *= attribute.stride;\\n\\n\\t\\t\\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value, offset ) {\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tthis.array.set( value, offset );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tonUpload: function ( callback ) {\\n\\n\\t\\t\\tthis.onUploadCallback = callback;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author benaadams / https://twitter.com/ben_a_adams\\n\\t */\\n\\n\\tfunction InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {\\n\\n\\t\\tInterleavedBuffer.call( this, array, stride );\\n\\n\\t\\tthis.meshPerAttribute = meshPerAttribute || 1;\\n\\n\\t}\\n\\n\\tInstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {\\n\\n\\t\\tconstructor: InstancedInterleavedBuffer,\\n\\n\\t\\tisInstancedInterleavedBuffer: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tInterleavedBuffer.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.meshPerAttribute = source.meshPerAttribute;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author benaadams / https://twitter.com/ben_a_adams\\n\\t */\\n\\n\\tfunction InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {\\n\\n\\t\\tBufferAttribute.call( this, array, itemSize );\\n\\n\\t\\tthis.meshPerAttribute = meshPerAttribute || 1;\\n\\n\\t}\\n\\n\\tInstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {\\n\\n\\t\\tconstructor: InstancedBufferAttribute,\\n\\n\\t\\tisInstancedBufferAttribute: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tBufferAttribute.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.meshPerAttribute = source.meshPerAttribute;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author bhouston / http://clara.io/\\n\\t * @author stephomi / http://stephaneginier.com/\\n\\t */\\n\\n\\tfunction Raycaster( origin, direction, near, far ) {\\n\\n\\t\\tthis.ray = new Ray( origin, direction );\\n\\t\\t// direction is assumed to be normalized (for accurate distance calculations)\\n\\n\\t\\tthis.near = near || 0;\\n\\t\\tthis.far = far || Infinity;\\n\\n\\t\\tthis.params = {\\n\\t\\t\\tMesh: {},\\n\\t\\t\\tLine: {},\\n\\t\\t\\tLOD: {},\\n\\t\\t\\tPoints: { threshold: 1 },\\n\\t\\t\\tSprite: {}\\n\\t\\t};\\n\\n\\t\\tObject.defineProperties( this.params, {\\n\\t\\t\\tPointCloud: {\\n\\t\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\\n\\t\\t\\t\\t\\treturn this.Points;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} );\\n\\n\\t}\\n\\n\\tfunction ascSort( a, b ) {\\n\\n\\t\\treturn a.distance - b.distance;\\n\\n\\t}\\n\\n\\tfunction intersectObject( object, raycaster, intersects, recursive ) {\\n\\n\\t\\tif ( object.visible === false ) return;\\n\\n\\t\\tobject.raycast( raycaster, intersects );\\n\\n\\t\\tif ( recursive === true ) {\\n\\n\\t\\t\\tvar children = object.children;\\n\\n\\t\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tintersectObject( children[ i ], raycaster, intersects, true );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tObject.assign( Raycaster.prototype, {\\n\\n\\t\\tlinePrecision: 1,\\n\\n\\t\\tset: function ( origin, direction ) {\\n\\n\\t\\t\\t// direction is assumed to be normalized (for accurate distance calculations)\\n\\n\\t\\t\\tthis.ray.set( origin, direction );\\n\\n\\t\\t},\\n\\n\\t\\tsetFromCamera: function ( coords, camera ) {\\n\\n\\t\\t\\tif ( ( camera && camera.isPerspectiveCamera ) ) {\\n\\n\\t\\t\\t\\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\\n\\t\\t\\t\\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\\n\\n\\t\\t\\t} else if ( ( camera && camera.isOrthographicCamera ) ) {\\n\\n\\t\\t\\t\\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\\n\\t\\t\\t\\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tintersectObject: function ( object, recursive ) {\\n\\n\\t\\t\\tvar intersects = [];\\n\\n\\t\\t\\tintersectObject( object, this, intersects, recursive );\\n\\n\\t\\t\\tintersects.sort( ascSort );\\n\\n\\t\\t\\treturn intersects;\\n\\n\\t\\t},\\n\\n\\t\\tintersectObjects: function ( objects, recursive ) {\\n\\n\\t\\t\\tvar intersects = [];\\n\\n\\t\\t\\tif ( Array.isArray( objects ) === false ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\\n\\t\\t\\t\\treturn intersects;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tintersectObject( objects[ i ], this, intersects, recursive );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tintersects.sort( ascSort );\\n\\n\\t\\t\\treturn intersects;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction Clock( autoStart ) {\\n\\n\\t\\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\\n\\n\\t\\tthis.startTime = 0;\\n\\t\\tthis.oldTime = 0;\\n\\t\\tthis.elapsedTime = 0;\\n\\n\\t\\tthis.running = false;\\n\\n\\t}\\n\\n\\tObject.assign( Clock.prototype, {\\n\\n\\t\\tstart: function () {\\n\\n\\t\\t\\tthis.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732\\n\\n\\t\\t\\tthis.oldTime = this.startTime;\\n\\t\\t\\tthis.elapsedTime = 0;\\n\\t\\t\\tthis.running = true;\\n\\n\\t\\t},\\n\\n\\t\\tstop: function () {\\n\\n\\t\\t\\tthis.getElapsedTime();\\n\\t\\t\\tthis.running = false;\\n\\t\\t\\tthis.autoStart = false;\\n\\n\\t\\t},\\n\\n\\t\\tgetElapsedTime: function () {\\n\\n\\t\\t\\tthis.getDelta();\\n\\t\\t\\treturn this.elapsedTime;\\n\\n\\t\\t},\\n\\n\\t\\tgetDelta: function () {\\n\\n\\t\\t\\tvar diff = 0;\\n\\n\\t\\t\\tif ( this.autoStart && ! this.running ) {\\n\\n\\t\\t\\t\\tthis.start();\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.running ) {\\n\\n\\t\\t\\t\\tvar newTime = ( typeof performance === 'undefined' ? Date : performance ).now();\\n\\n\\t\\t\\t\\tdiff = ( newTime - this.oldTime ) / 1000;\\n\\t\\t\\t\\tthis.oldTime = newTime;\\n\\n\\t\\t\\t\\tthis.elapsedTime += diff;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn diff;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author bhouston / http://clara.io\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t *\\n\\t * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\\n\\t *\\n\\t * The poles (phi) are at the positive and negative y axis.\\n\\t * The equator starts at positive z.\\n\\t */\\n\\n\\tfunction Spherical( radius, phi, theta ) {\\n\\n\\t\\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\\n\\t\\tthis.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole\\n\\t\\tthis.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere\\n\\n\\t\\treturn this;\\n\\n\\t}\\n\\n\\tObject.assign( Spherical.prototype, {\\n\\n\\t\\tset: function ( radius, phi, theta ) {\\n\\n\\t\\t\\tthis.radius = radius;\\n\\t\\t\\tthis.phi = phi;\\n\\t\\t\\tthis.theta = theta;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( other ) {\\n\\n\\t\\t\\tthis.radius = other.radius;\\n\\t\\t\\tthis.phi = other.phi;\\n\\t\\t\\tthis.theta = other.theta;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t// restrict phi to be betwee EPS and PI-EPS\\n\\t\\tmakeSafe: function () {\\n\\n\\t\\t\\tvar EPS = 0.000001;\\n\\t\\t\\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromVector3: function ( vec3 ) {\\n\\n\\t\\t\\tthis.radius = vec3.length();\\n\\n\\t\\t\\tif ( this.radius === 0 ) {\\n\\n\\t\\t\\t\\tthis.theta = 0;\\n\\t\\t\\t\\tthis.phi = 0;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis\\n\\t\\t\\t\\tthis.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t *\\n\\t * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system\\n\\t *\\n\\t */\\n\\n\\tfunction Cylindrical( radius, theta, y ) {\\n\\n\\t\\tthis.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane\\n\\t\\tthis.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis\\n\\t\\tthis.y = ( y !== undefined ) ? y : 0; // height above the x-z plane\\n\\n\\t\\treturn this;\\n\\n\\t}\\n\\n\\tObject.assign( Cylindrical.prototype, {\\n\\n\\t\\tset: function ( radius, theta, y ) {\\n\\n\\t\\t\\tthis.radius = radius;\\n\\t\\t\\tthis.theta = theta;\\n\\t\\t\\tthis.y = y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( other ) {\\n\\n\\t\\t\\tthis.radius = other.radius;\\n\\t\\t\\tthis.theta = other.theta;\\n\\t\\t\\tthis.y = other.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromVector3: function ( vec3 ) {\\n\\n\\t\\t\\tthis.radius = Math.sqrt( vec3.x * vec3.x + vec3.z * vec3.z );\\n\\t\\t\\tthis.theta = Math.atan2( vec3.x, vec3.z );\\n\\t\\t\\tthis.y = vec3.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction ImmediateRenderObject( material ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.material = material;\\n\\t\\tthis.render = function ( /* renderCallback */ ) {};\\n\\n\\t}\\n\\n\\tImmediateRenderObject.prototype = Object.create( Object3D.prototype );\\n\\tImmediateRenderObject.prototype.constructor = ImmediateRenderObject;\\n\\n\\tImmediateRenderObject.prototype.isImmediateRenderObject = true;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction VertexNormalsHelper( object, size, hex, linewidth ) {\\n\\n\\t\\tthis.object = object;\\n\\n\\t\\tthis.size = ( size !== undefined ) ? size : 1;\\n\\n\\t\\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\\n\\n\\t\\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\\n\\n\\t\\t//\\n\\n\\t\\tvar nNormals = 0;\\n\\n\\t\\tvar objGeometry = this.object.geometry;\\n\\n\\t\\tif ( objGeometry && objGeometry.isGeometry ) {\\n\\n\\t\\t\\tnNormals = objGeometry.faces.length * 3;\\n\\n\\t\\t} else if ( objGeometry && objGeometry.isBufferGeometry ) {\\n\\n\\t\\t\\tnNormals = objGeometry.attributes.normal.count;\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\n\\t\\tvar positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );\\n\\n\\t\\tgeometry.addAttribute( 'position', positions );\\n\\n\\t\\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\\n\\n\\t\\t//\\n\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\n\\t\\tthis.update();\\n\\n\\t}\\n\\n\\tVertexNormalsHelper.prototype = Object.create( LineSegments.prototype );\\n\\tVertexNormalsHelper.prototype.constructor = VertexNormalsHelper;\\n\\n\\tVertexNormalsHelper.prototype.update = ( function () {\\n\\n\\t\\tvar v1 = new Vector3();\\n\\t\\tvar v2 = new Vector3();\\n\\t\\tvar normalMatrix = new Matrix3();\\n\\n\\t\\treturn function update() {\\n\\n\\t\\t\\tvar keys = [ 'a', 'b', 'c' ];\\n\\n\\t\\t\\tthis.object.updateMatrixWorld( true );\\n\\n\\t\\t\\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\\n\\n\\t\\t\\tvar matrixWorld = this.object.matrixWorld;\\n\\n\\t\\t\\tvar position = this.geometry.attributes.position;\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar objGeometry = this.object.geometry;\\n\\n\\t\\t\\tif ( objGeometry && objGeometry.isGeometry ) {\\n\\n\\t\\t\\t\\tvar vertices = objGeometry.vertices;\\n\\n\\t\\t\\t\\tvar faces = objGeometry.faces;\\n\\n\\t\\t\\t\\tvar idx = 0;\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar face = faces[ i ];\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar vertex = vertices[ face[ keys[ j ] ] ];\\n\\n\\t\\t\\t\\t\\t\\tvar normal = face.vertexNormals[ j ];\\n\\n\\t\\t\\t\\t\\t\\tv1.copy( vertex ).applyMatrix4( matrixWorld );\\n\\n\\t\\t\\t\\t\\t\\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\\n\\n\\t\\t\\t\\t\\t\\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\\n\\n\\t\\t\\t\\t\\t\\tidx = idx + 1;\\n\\n\\t\\t\\t\\t\\t\\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\\n\\n\\t\\t\\t\\t\\t\\tidx = idx + 1;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( objGeometry && objGeometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\tvar objPos = objGeometry.attributes.position;\\n\\n\\t\\t\\t\\tvar objNorm = objGeometry.attributes.normal;\\n\\n\\t\\t\\t\\tvar idx = 0;\\n\\n\\t\\t\\t\\t// for simplicity, ignore index and drawcalls, and render every normal\\n\\n\\t\\t\\t\\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\\n\\n\\t\\t\\t\\t\\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\\n\\n\\t\\t\\t\\t\\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\\n\\n\\t\\t\\t\\t\\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\\n\\n\\t\\t\\t\\t\\tidx = idx + 1;\\n\\n\\t\\t\\t\\t\\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\\n\\n\\t\\t\\t\\t\\tidx = idx + 1;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tposition.needsUpdate = true;\\n\\n\\t\\t};\\n\\n\\t}() );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction SpotLightHelper( light, color ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.light = light;\\n\\t\\tthis.light.updateMatrixWorld();\\n\\n\\t\\tthis.matrix = light.matrixWorld;\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\n\\t\\tthis.color = color;\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\n\\t\\tvar positions = [\\n\\t\\t\\t0, 0, 0, \\t0, 0, 1,\\n\\t\\t\\t0, 0, 0, \\t1, 0, 1,\\n\\t\\t\\t0, 0, 0,\\t- 1, 0, 1,\\n\\t\\t\\t0, 0, 0, \\t0, 1, 1,\\n\\t\\t\\t0, 0, 0, \\t0, - 1, 1\\n\\t\\t];\\n\\n\\t\\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\\n\\n\\t\\t\\tvar p1 = ( i / l ) * Math.PI * 2;\\n\\t\\t\\tvar p2 = ( j / l ) * Math.PI * 2;\\n\\n\\t\\t\\tpositions.push(\\n\\t\\t\\t\\tMath.cos( p1 ), Math.sin( p1 ), 1,\\n\\t\\t\\t\\tMath.cos( p2 ), Math.sin( p2 ), 1\\n\\t\\t\\t);\\n\\n\\t\\t}\\n\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\\n\\n\\t\\tvar material = new LineBasicMaterial( { fog: false } );\\n\\n\\t\\tthis.cone = new LineSegments( geometry, material );\\n\\t\\tthis.add( this.cone );\\n\\n\\t\\tthis.update();\\n\\n\\t}\\n\\n\\tSpotLightHelper.prototype = Object.create( Object3D.prototype );\\n\\tSpotLightHelper.prototype.constructor = SpotLightHelper;\\n\\n\\tSpotLightHelper.prototype.dispose = function () {\\n\\n\\t\\tthis.cone.geometry.dispose();\\n\\t\\tthis.cone.material.dispose();\\n\\n\\t};\\n\\n\\tSpotLightHelper.prototype.update = function () {\\n\\n\\t\\tvar vector = new Vector3();\\n\\t\\tvar vector2 = new Vector3();\\n\\n\\t\\treturn function update() {\\n\\n\\t\\t\\tthis.light.updateMatrixWorld();\\n\\n\\t\\t\\tvar coneLength = this.light.distance ? this.light.distance : 1000;\\n\\t\\t\\tvar coneWidth = coneLength * Math.tan( this.light.angle );\\n\\n\\t\\t\\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\\n\\n\\t\\t\\tvector.setFromMatrixPosition( this.light.matrixWorld );\\n\\t\\t\\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\\n\\n\\t\\t\\tthis.cone.lookAt( vector2.sub( vector ) );\\n\\n\\t\\t\\tif ( this.color !== undefined ) {\\n\\n\\t\\t\\t\\tthis.cone.material.color.set( this.color );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.cone.material.color.copy( this.light.color );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\t/**\\n\\t * @author Sean Griffin / http://twitter.com/sgrif\\n\\t * @author Michael Guerrero / http://realitymeltdown.com\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author ikerr / http://verold.com\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\tfunction getBoneList( object ) {\\n\\n\\t\\tvar boneList = [];\\n\\n\\t\\tif ( object && object.isBone ) {\\n\\n\\t\\t\\tboneList.push( object );\\n\\n\\t\\t}\\n\\n\\t\\tfor ( var i = 0; i < object.children.length; i ++ ) {\\n\\n\\t\\t\\tboneList.push.apply( boneList, getBoneList( object.children[ i ] ) );\\n\\n\\t\\t}\\n\\n\\t\\treturn boneList;\\n\\n\\t}\\n\\n\\tfunction SkeletonHelper( object ) {\\n\\n\\t\\tvar bones = getBoneList( object );\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\n\\t\\tvar vertices = [];\\n\\t\\tvar colors = [];\\n\\n\\t\\tvar color1 = new Color( 0, 0, 1 );\\n\\t\\tvar color2 = new Color( 0, 1, 0 );\\n\\n\\t\\tfor ( var i = 0; i < bones.length; i ++ ) {\\n\\n\\t\\t\\tvar bone = bones[ i ];\\n\\n\\t\\t\\tif ( bone.parent && bone.parent.isBone ) {\\n\\n\\t\\t\\t\\tvertices.push( 0, 0, 0 );\\n\\t\\t\\t\\tvertices.push( 0, 0, 0 );\\n\\t\\t\\t\\tcolors.push( color1.r, color1.g, color1.b );\\n\\t\\t\\t\\tcolors.push( color2.r, color2.g, color2.b );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\\n\\n\\t\\tvar material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );\\n\\n\\t\\tLineSegments.call( this, geometry, material );\\n\\n\\t\\tthis.root = object;\\n\\t\\tthis.bones = bones;\\n\\n\\t\\tthis.matrix = object.matrixWorld;\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\n\\t}\\n\\n\\tSkeletonHelper.prototype = Object.create( LineSegments.prototype );\\n\\tSkeletonHelper.prototype.constructor = SkeletonHelper;\\n\\n\\tSkeletonHelper.prototype.updateMatrixWorld = function () {\\n\\n\\t\\tvar vector = new Vector3();\\n\\n\\t\\tvar boneMatrix = new Matrix4();\\n\\t\\tvar matrixWorldInv = new Matrix4();\\n\\n\\t\\treturn function updateMatrixWorld( force ) {\\n\\n\\t\\t\\tvar bones = this.bones;\\n\\n\\t\\t\\tvar geometry = this.geometry;\\n\\t\\t\\tvar position = geometry.getAttribute( 'position' );\\n\\n\\t\\t\\tmatrixWorldInv.getInverse( this.root.matrixWorld );\\n\\n\\t\\t\\tfor ( var i = 0, j = 0; i < bones.length; i ++ ) {\\n\\n\\t\\t\\t\\tvar bone = bones[ i ];\\n\\n\\t\\t\\t\\tif ( bone.parent && bone.parent.isBone ) {\\n\\n\\t\\t\\t\\t\\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\\n\\t\\t\\t\\t\\tvector.setFromMatrixPosition( boneMatrix );\\n\\t\\t\\t\\t\\tposition.setXYZ( j, vector.x, vector.y, vector.z );\\n\\n\\t\\t\\t\\t\\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\\n\\t\\t\\t\\t\\tvector.setFromMatrixPosition( boneMatrix );\\n\\t\\t\\t\\t\\tposition.setXYZ( j + 1, vector.x, vector.y, vector.z );\\n\\n\\t\\t\\t\\t\\tj += 2;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tgeometry.getAttribute( 'position' ).needsUpdate = true;\\n\\n\\t\\t\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction PointLightHelper( light, sphereSize, color ) {\\n\\n\\t\\tthis.light = light;\\n\\t\\tthis.light.updateMatrixWorld();\\n\\n\\t\\tthis.color = color;\\n\\n\\t\\tvar geometry = new SphereBufferGeometry( sphereSize, 4, 2 );\\n\\t\\tvar material = new MeshBasicMaterial( { wireframe: true, fog: false } );\\n\\n\\t\\tMesh.call( this, geometry, material );\\n\\n\\t\\tthis.matrix = this.light.matrixWorld;\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\n\\t\\tthis.update();\\n\\n\\n\\t\\t/*\\n\\t\\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\\n\\t\\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\\n\\n\\t\\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\\n\\t\\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\\n\\n\\t\\tvar d = light.distance;\\n\\n\\t\\tif ( d === 0.0 ) {\\n\\n\\t\\t\\tthis.lightDistance.visible = false;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tthis.lightDistance.scale.set( d, d, d );\\n\\n\\t\\t}\\n\\n\\t\\tthis.add( this.lightDistance );\\n\\t\\t*/\\n\\n\\t}\\n\\n\\tPointLightHelper.prototype = Object.create( Mesh.prototype );\\n\\tPointLightHelper.prototype.constructor = PointLightHelper;\\n\\n\\tPointLightHelper.prototype.dispose = function () {\\n\\n\\t\\tthis.geometry.dispose();\\n\\t\\tthis.material.dispose();\\n\\n\\t};\\n\\n\\tPointLightHelper.prototype.update = function () {\\n\\n\\t\\tif ( this.color !== undefined ) {\\n\\n\\t\\t\\tthis.material.color.set( this.color );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tthis.material.color.copy( this.light.color );\\n\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\tvar d = this.light.distance;\\n\\n\\t\\tif ( d === 0.0 ) {\\n\\n\\t\\t\\tthis.lightDistance.visible = false;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tthis.lightDistance.visible = true;\\n\\t\\t\\tthis.lightDistance.scale.set( d, d, d );\\n\\n\\t\\t}\\n\\t\\t*/\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author abelnation / http://github.com/abelnation\\n\\t * @author Mugen87 / http://github.com/Mugen87\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction RectAreaLightHelper( light, color ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.light = light;\\n\\t\\tthis.light.updateMatrixWorld();\\n\\n\\t\\tthis.matrix = light.matrixWorld;\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\n\\t\\tthis.color = color;\\n\\n\\t\\tvar material = new LineBasicMaterial( { fog: false } );\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\n\\t\\tgeometry.addAttribute( 'position', new BufferAttribute( new Float32Array( 5 * 3 ), 3 ) );\\n\\n\\t\\tthis.line = new Line( geometry, material );\\n\\t\\tthis.add( this.line );\\n\\n\\n\\t\\tthis.update();\\n\\n\\t}\\n\\n\\tRectAreaLightHelper.prototype = Object.create( Object3D.prototype );\\n\\tRectAreaLightHelper.prototype.constructor = RectAreaLightHelper;\\n\\n\\tRectAreaLightHelper.prototype.dispose = function () {\\n\\n\\t\\tthis.children[ 0 ].geometry.dispose();\\n\\t\\tthis.children[ 0 ].material.dispose();\\n\\n\\t};\\n\\n\\tRectAreaLightHelper.prototype.update = function () {\\n\\n\\t\\t// calculate new dimensions of the helper\\n\\n\\t\\tvar hx = this.light.width * 0.5;\\n\\t\\tvar hy = this.light.height * 0.5;\\n\\n\\t\\tvar position = this.line.geometry.attributes.position;\\n\\t\\tvar array = position.array;\\n\\n\\t\\t// update vertices\\n\\n\\t\\tarray[ 0 ] = hx; array[ 1 ] = - hy; array[ 2 ] = 0;\\n\\t\\tarray[ 3 ] = hx; array[ 4 ] = hy; array[ 5 ] = 0;\\n\\t\\tarray[ 6 ] = - hx; array[ 7 ] = hy; array[ 8 ] = 0;\\n\\t\\tarray[ 9 ] = - hx; array[ 10 ] = - hy; array[ 11 ] = 0;\\n\\t\\tarray[ 12 ] = hx; array[ 13 ] = - hy; array[ 14 ] = 0;\\n\\n\\t\\tposition.needsUpdate = true;\\n\\n\\t\\tif ( this.color !== undefined ) {\\n\\n\\t\\t\\tthis.line.material.color.set( this.color );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tthis.line.material.color.copy( this.light.color );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\tfunction HemisphereLightHelper( light, size, color ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.light = light;\\n\\t\\tthis.light.updateMatrixWorld();\\n\\n\\t\\tthis.matrix = light.matrixWorld;\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\n\\t\\tthis.color = color;\\n\\n\\t\\tvar geometry = new OctahedronBufferGeometry( size );\\n\\t\\tgeometry.rotateY( Math.PI * 0.5 );\\n\\n\\t\\tthis.material = new MeshBasicMaterial( { wireframe: true, fog: false } );\\n\\t\\tif ( this.color === undefined ) this.material.vertexColors = VertexColors;\\n\\n\\t\\tvar position = geometry.getAttribute( 'position' );\\n\\t\\tvar colors = new Float32Array( position.count * 3 );\\n\\n\\t\\tgeometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );\\n\\n\\t\\tthis.add( new Mesh( geometry, this.material ) );\\n\\n\\t\\tthis.update();\\n\\n\\t}\\n\\n\\tHemisphereLightHelper.prototype = Object.create( Object3D.prototype );\\n\\tHemisphereLightHelper.prototype.constructor = HemisphereLightHelper;\\n\\n\\tHemisphereLightHelper.prototype.dispose = function () {\\n\\n\\t\\tthis.children[ 0 ].geometry.dispose();\\n\\t\\tthis.children[ 0 ].material.dispose();\\n\\n\\t};\\n\\n\\tHemisphereLightHelper.prototype.update = function () {\\n\\n\\t\\tvar vector = new Vector3();\\n\\n\\t\\tvar color1 = new Color();\\n\\t\\tvar color2 = new Color();\\n\\n\\t\\treturn function update() {\\n\\n\\t\\t\\tvar mesh = this.children[ 0 ];\\n\\n\\t\\t\\tif ( this.color !== undefined ) {\\n\\n\\t\\t\\t\\tthis.material.color.set( this.color );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tvar colors = mesh.geometry.getAttribute( 'color' );\\n\\n\\t\\t\\t\\tcolor1.copy( this.light.color );\\n\\t\\t\\t\\tcolor2.copy( this.light.groundColor );\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = colors.count; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar color = ( i < ( l / 2 ) ) ? color1 : color2;\\n\\n\\t\\t\\t\\t\\tcolors.setXYZ( i, color.r, color.g, color.b );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcolors.needsUpdate = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tmesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction GridHelper( size, divisions, color1, color2 ) {\\n\\n\\t\\tsize = size || 10;\\n\\t\\tdivisions = divisions || 10;\\n\\t\\tcolor1 = new Color( color1 !== undefined ? color1 : 0x444444 );\\n\\t\\tcolor2 = new Color( color2 !== undefined ? color2 : 0x888888 );\\n\\n\\t\\tvar center = divisions / 2;\\n\\t\\tvar step = size / divisions;\\n\\t\\tvar halfSize = size / 2;\\n\\n\\t\\tvar vertices = [], colors = [];\\n\\n\\t\\tfor ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {\\n\\n\\t\\t\\tvertices.push( - halfSize, 0, k, halfSize, 0, k );\\n\\t\\t\\tvertices.push( k, 0, - halfSize, k, 0, halfSize );\\n\\n\\t\\t\\tvar color = i === center ? color1 : color2;\\n\\n\\t\\t\\tcolor.toArray( colors, j ); j += 3;\\n\\t\\t\\tcolor.toArray( colors, j ); j += 3;\\n\\t\\t\\tcolor.toArray( colors, j ); j += 3;\\n\\t\\t\\tcolor.toArray( colors, j ); j += 3;\\n\\n\\t\\t}\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\\n\\n\\t\\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\\n\\n\\t\\tLineSegments.call( this, geometry, material );\\n\\n\\t}\\n\\n\\tGridHelper.prototype = Object.create( LineSegments.prototype );\\n\\tGridHelper.prototype.constructor = GridHelper;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author Mugen87 / http://github.com/Mugen87\\n\\t * @author Hectate / http://www.github.com/Hectate\\n\\t */\\n\\n\\tfunction PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {\\n\\n\\t\\tradius = radius || 10;\\n\\t\\tradials = radials || 16;\\n\\t\\tcircles = circles || 8;\\n\\t\\tdivisions = divisions || 64;\\n\\t\\tcolor1 = new Color( color1 !== undefined ? color1 : 0x444444 );\\n\\t\\tcolor2 = new Color( color2 !== undefined ? color2 : 0x888888 );\\n\\n\\t\\tvar vertices = [];\\n\\t\\tvar colors = [];\\n\\n\\t\\tvar x, z;\\n\\t\\tvar v, i, j, r, color;\\n\\n\\t\\t// create the radials\\n\\n\\t\\tfor ( i = 0; i <= radials; i ++ ) {\\n\\n\\t\\t\\tv = ( i / radials ) * ( Math.PI * 2 );\\n\\n\\t\\t\\tx = Math.sin( v ) * radius;\\n\\t\\t\\tz = Math.cos( v ) * radius;\\n\\n\\t\\t\\tvertices.push( 0, 0, 0 );\\n\\t\\t\\tvertices.push( x, 0, z );\\n\\n\\t\\t\\tcolor = ( i & 1 ) ? color1 : color2;\\n\\n\\t\\t\\tcolors.push( color.r, color.g, color.b );\\n\\t\\t\\tcolors.push( color.r, color.g, color.b );\\n\\n\\t\\t}\\n\\n\\t\\t// create the circles\\n\\n\\t\\tfor ( i = 0; i <= circles; i ++ ) {\\n\\n\\t\\t\\tcolor = ( i & 1 ) ? color1 : color2;\\n\\n\\t\\t\\tr = radius - ( radius / circles * i );\\n\\n\\t\\t\\tfor ( j = 0; j < divisions; j ++ ) {\\n\\n\\t\\t\\t\\t// first vertex\\n\\n\\t\\t\\t\\tv = ( j / divisions ) * ( Math.PI * 2 );\\n\\n\\t\\t\\t\\tx = Math.sin( v ) * r;\\n\\t\\t\\t\\tz = Math.cos( v ) * r;\\n\\n\\t\\t\\t\\tvertices.push( x, 0, z );\\n\\t\\t\\t\\tcolors.push( color.r, color.g, color.b );\\n\\n\\t\\t\\t\\t// second vertex\\n\\n\\t\\t\\t\\tv = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );\\n\\n\\t\\t\\t\\tx = Math.sin( v ) * r;\\n\\t\\t\\t\\tz = Math.cos( v ) * r;\\n\\n\\t\\t\\t\\tvertices.push( x, 0, z );\\n\\t\\t\\t\\tcolors.push( color.r, color.g, color.b );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\\n\\n\\t\\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\\n\\n\\t\\tLineSegments.call( this, geometry, material );\\n\\n\\t}\\n\\n\\tPolarGridHelper.prototype = Object.create( LineSegments.prototype );\\n\\tPolarGridHelper.prototype.constructor = PolarGridHelper;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction FaceNormalsHelper( object, size, hex, linewidth ) {\\n\\n\\t\\t// FaceNormalsHelper only supports THREE.Geometry\\n\\n\\t\\tthis.object = object;\\n\\n\\t\\tthis.size = ( size !== undefined ) ? size : 1;\\n\\n\\t\\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\\n\\n\\t\\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\\n\\n\\t\\t//\\n\\n\\t\\tvar nNormals = 0;\\n\\n\\t\\tvar objGeometry = this.object.geometry;\\n\\n\\t\\tif ( objGeometry && objGeometry.isGeometry ) {\\n\\n\\t\\t\\tnNormals = objGeometry.faces.length;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\n\\t\\tvar positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );\\n\\n\\t\\tgeometry.addAttribute( 'position', positions );\\n\\n\\t\\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\\n\\n\\t\\t//\\n\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\t\\tthis.update();\\n\\n\\t}\\n\\n\\tFaceNormalsHelper.prototype = Object.create( LineSegments.prototype );\\n\\tFaceNormalsHelper.prototype.constructor = FaceNormalsHelper;\\n\\n\\tFaceNormalsHelper.prototype.update = ( function () {\\n\\n\\t\\tvar v1 = new Vector3();\\n\\t\\tvar v2 = new Vector3();\\n\\t\\tvar normalMatrix = new Matrix3();\\n\\n\\t\\treturn function update() {\\n\\n\\t\\t\\tthis.object.updateMatrixWorld( true );\\n\\n\\t\\t\\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\\n\\n\\t\\t\\tvar matrixWorld = this.object.matrixWorld;\\n\\n\\t\\t\\tvar position = this.geometry.attributes.position;\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar objGeometry = this.object.geometry;\\n\\n\\t\\t\\tvar vertices = objGeometry.vertices;\\n\\n\\t\\t\\tvar faces = objGeometry.faces;\\n\\n\\t\\t\\tvar idx = 0;\\n\\n\\t\\t\\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar face = faces[ i ];\\n\\n\\t\\t\\t\\tvar normal = face.normal;\\n\\n\\t\\t\\t\\tv1.copy( vertices[ face.a ] )\\n\\t\\t\\t\\t\\t.add( vertices[ face.b ] )\\n\\t\\t\\t\\t\\t.add( vertices[ face.c ] )\\n\\t\\t\\t\\t\\t.divideScalar( 3 )\\n\\t\\t\\t\\t\\t.applyMatrix4( matrixWorld );\\n\\n\\t\\t\\t\\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\\n\\n\\t\\t\\t\\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\\n\\n\\t\\t\\t\\tidx = idx + 1;\\n\\n\\t\\t\\t\\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\\n\\n\\t\\t\\t\\tidx = idx + 1;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tposition.needsUpdate = true;\\n\\n\\t\\t};\\n\\n\\t}() );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction DirectionalLightHelper( light, size, color ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.light = light;\\n\\t\\tthis.light.updateMatrixWorld();\\n\\n\\t\\tthis.matrix = light.matrixWorld;\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\n\\t\\tthis.color = color;\\n\\n\\t\\tif ( size === undefined ) size = 1;\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( [\\n\\t\\t\\t- size, size, 0,\\n\\t\\t\\tsize, size, 0,\\n\\t\\t\\tsize, - size, 0,\\n\\t\\t\\t- size, - size, 0,\\n\\t\\t\\t- size, size, 0\\n\\t\\t], 3 ) );\\n\\n\\t\\tvar material = new LineBasicMaterial( { fog: false } );\\n\\n\\t\\tthis.lightPlane = new Line( geometry, material );\\n\\t\\tthis.add( this.lightPlane );\\n\\n\\t\\tgeometry = new BufferGeometry();\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\\n\\n\\t\\tthis.targetLine = new Line( geometry, material );\\n\\t\\tthis.add( this.targetLine );\\n\\n\\t\\tthis.update();\\n\\n\\t}\\n\\n\\tDirectionalLightHelper.prototype = Object.create( Object3D.prototype );\\n\\tDirectionalLightHelper.prototype.constructor = DirectionalLightHelper;\\n\\n\\tDirectionalLightHelper.prototype.dispose = function () {\\n\\n\\t\\tthis.lightPlane.geometry.dispose();\\n\\t\\tthis.lightPlane.material.dispose();\\n\\t\\tthis.targetLine.geometry.dispose();\\n\\t\\tthis.targetLine.material.dispose();\\n\\n\\t};\\n\\n\\tDirectionalLightHelper.prototype.update = function () {\\n\\n\\t\\tvar v1 = new Vector3();\\n\\t\\tvar v2 = new Vector3();\\n\\t\\tvar v3 = new Vector3();\\n\\n\\t\\treturn function update() {\\n\\n\\t\\t\\tv1.setFromMatrixPosition( this.light.matrixWorld );\\n\\t\\t\\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\\n\\t\\t\\tv3.subVectors( v2, v1 );\\n\\n\\t\\t\\tthis.lightPlane.lookAt( v3 );\\n\\n\\t\\t\\tif ( this.color !== undefined ) {\\n\\n\\t\\t\\t\\tthis.lightPlane.material.color.set( this.color );\\n\\t\\t\\t\\tthis.targetLine.material.color.set( this.color );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.lightPlane.material.color.copy( this.light.color );\\n\\t\\t\\t\\tthis.targetLine.material.color.copy( this.light.color );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.targetLine.lookAt( v3 );\\n\\t\\t\\tthis.targetLine.scale.z = v3.length();\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t *\\n\\t *\\t- shows frustum, line of sight and up of the camera\\n\\t *\\t- suitable for fast updates\\n\\t * \\t- based on frustum visualization in lightgl.js shadowmap example\\n\\t *\\t\\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\\n\\t */\\n\\n\\tfunction CameraHelper( camera ) {\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\t\\tvar material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );\\n\\n\\t\\tvar vertices = [];\\n\\t\\tvar colors = [];\\n\\n\\t\\tvar pointMap = {};\\n\\n\\t\\t// colors\\n\\n\\t\\tvar colorFrustum = new Color( 0xffaa00 );\\n\\t\\tvar colorCone = new Color( 0xff0000 );\\n\\t\\tvar colorUp = new Color( 0x00aaff );\\n\\t\\tvar colorTarget = new Color( 0xffffff );\\n\\t\\tvar colorCross = new Color( 0x333333 );\\n\\n\\t\\t// near\\n\\n\\t\\taddLine( 'n1', 'n2', colorFrustum );\\n\\t\\taddLine( 'n2', 'n4', colorFrustum );\\n\\t\\taddLine( 'n4', 'n3', colorFrustum );\\n\\t\\taddLine( 'n3', 'n1', colorFrustum );\\n\\n\\t\\t// far\\n\\n\\t\\taddLine( 'f1', 'f2', colorFrustum );\\n\\t\\taddLine( 'f2', 'f4', colorFrustum );\\n\\t\\taddLine( 'f4', 'f3', colorFrustum );\\n\\t\\taddLine( 'f3', 'f1', colorFrustum );\\n\\n\\t\\t// sides\\n\\n\\t\\taddLine( 'n1', 'f1', colorFrustum );\\n\\t\\taddLine( 'n2', 'f2', colorFrustum );\\n\\t\\taddLine( 'n3', 'f3', colorFrustum );\\n\\t\\taddLine( 'n4', 'f4', colorFrustum );\\n\\n\\t\\t// cone\\n\\n\\t\\taddLine( 'p', 'n1', colorCone );\\n\\t\\taddLine( 'p', 'n2', colorCone );\\n\\t\\taddLine( 'p', 'n3', colorCone );\\n\\t\\taddLine( 'p', 'n4', colorCone );\\n\\n\\t\\t// up\\n\\n\\t\\taddLine( 'u1', 'u2', colorUp );\\n\\t\\taddLine( 'u2', 'u3', colorUp );\\n\\t\\taddLine( 'u3', 'u1', colorUp );\\n\\n\\t\\t// target\\n\\n\\t\\taddLine( 'c', 't', colorTarget );\\n\\t\\taddLine( 'p', 'c', colorCross );\\n\\n\\t\\t// cross\\n\\n\\t\\taddLine( 'cn1', 'cn2', colorCross );\\n\\t\\taddLine( 'cn3', 'cn4', colorCross );\\n\\n\\t\\taddLine( 'cf1', 'cf2', colorCross );\\n\\t\\taddLine( 'cf3', 'cf4', colorCross );\\n\\n\\t\\tfunction addLine( a, b, color ) {\\n\\n\\t\\t\\taddPoint( a, color );\\n\\t\\t\\taddPoint( b, color );\\n\\n\\t\\t}\\n\\n\\t\\tfunction addPoint( id, color ) {\\n\\n\\t\\t\\tvertices.push( 0, 0, 0 );\\n\\t\\t\\tcolors.push( color.r, color.g, color.b );\\n\\n\\t\\t\\tif ( pointMap[ id ] === undefined ) {\\n\\n\\t\\t\\t\\tpointMap[ id ] = [];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tpointMap[ id ].push( ( vertices.length / 3 ) - 1 );\\n\\n\\t\\t}\\n\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\\n\\n\\t\\tLineSegments.call( this, geometry, material );\\n\\n\\t\\tthis.camera = camera;\\n\\t\\tif ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\\n\\n\\t\\tthis.matrix = camera.matrixWorld;\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\n\\t\\tthis.pointMap = pointMap;\\n\\n\\t\\tthis.update();\\n\\n\\t}\\n\\n\\tCameraHelper.prototype = Object.create( LineSegments.prototype );\\n\\tCameraHelper.prototype.constructor = CameraHelper;\\n\\n\\tCameraHelper.prototype.update = function () {\\n\\n\\t\\tvar geometry, pointMap;\\n\\n\\t\\tvar vector = new Vector3();\\n\\t\\tvar camera = new Camera();\\n\\n\\t\\tfunction setPoint( point, x, y, z ) {\\n\\n\\t\\t\\tvector.set( x, y, z ).unproject( camera );\\n\\n\\t\\t\\tvar points = pointMap[ point ];\\n\\n\\t\\t\\tif ( points !== undefined ) {\\n\\n\\t\\t\\t\\tvar position = geometry.getAttribute( 'position' );\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tposition.setXYZ( points[ i ], vector.x, vector.y, vector.z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn function update() {\\n\\n\\t\\t\\tgeometry = this.geometry;\\n\\t\\t\\tpointMap = this.pointMap;\\n\\n\\t\\t\\tvar w = 1, h = 1;\\n\\n\\t\\t\\t// we need just camera projection matrix\\n\\t\\t\\t// world matrix must be identity\\n\\n\\t\\t\\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\\n\\n\\t\\t\\t// center / target\\n\\n\\t\\t\\tsetPoint( 'c', 0, 0, - 1 );\\n\\t\\t\\tsetPoint( 't', 0, 0, 1 );\\n\\n\\t\\t\\t// near\\n\\n\\t\\t\\tsetPoint( 'n1', - w, - h, - 1 );\\n\\t\\t\\tsetPoint( 'n2', w, - h, - 1 );\\n\\t\\t\\tsetPoint( 'n3', - w, h, - 1 );\\n\\t\\t\\tsetPoint( 'n4', w, h, - 1 );\\n\\n\\t\\t\\t// far\\n\\n\\t\\t\\tsetPoint( 'f1', - w, - h, 1 );\\n\\t\\t\\tsetPoint( 'f2', w, - h, 1 );\\n\\t\\t\\tsetPoint( 'f3', - w, h, 1 );\\n\\t\\t\\tsetPoint( 'f4', w, h, 1 );\\n\\n\\t\\t\\t// up\\n\\n\\t\\t\\tsetPoint( 'u1', w * 0.7, h * 1.1, - 1 );\\n\\t\\t\\tsetPoint( 'u2', - w * 0.7, h * 1.1, - 1 );\\n\\t\\t\\tsetPoint( 'u3', 0, h * 2, - 1 );\\n\\n\\t\\t\\t// cross\\n\\n\\t\\t\\tsetPoint( 'cf1', - w, 0, 1 );\\n\\t\\t\\tsetPoint( 'cf2', w, 0, 1 );\\n\\t\\t\\tsetPoint( 'cf3', 0, - h, 1 );\\n\\t\\t\\tsetPoint( 'cf4', 0, h, 1 );\\n\\n\\t\\t\\tsetPoint( 'cn1', - w, 0, - 1 );\\n\\t\\t\\tsetPoint( 'cn2', w, 0, - 1 );\\n\\t\\t\\tsetPoint( 'cn3', 0, - h, - 1 );\\n\\t\\t\\tsetPoint( 'cn4', 0, h, - 1 );\\n\\n\\t\\t\\tgeometry.getAttribute( 'position' ).needsUpdate = true;\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author Mugen87 / http://github.com/Mugen87\\n\\t */\\n\\n\\tfunction BoxHelper( object, color ) {\\n\\n\\t\\tthis.object = object;\\n\\n\\t\\tif ( color === undefined ) color = 0xffff00;\\n\\n\\t\\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\\n\\t\\tvar positions = new Float32Array( 8 * 3 );\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\t\\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\\n\\t\\tgeometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );\\n\\n\\t\\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );\\n\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\n\\t\\tthis.update();\\n\\n\\t}\\n\\n\\tBoxHelper.prototype = Object.create( LineSegments.prototype );\\n\\tBoxHelper.prototype.constructor = BoxHelper;\\n\\n\\tBoxHelper.prototype.update = ( function () {\\n\\n\\t\\tvar box = new Box3();\\n\\n\\t\\treturn function update( object ) {\\n\\n\\t\\t\\tif ( object !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.object !== undefined ) {\\n\\n\\t\\t\\t\\tbox.setFromObject( this.object );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( box.isEmpty() ) return;\\n\\n\\t\\t\\tvar min = box.min;\\n\\t\\t\\tvar max = box.max;\\n\\n\\t\\t\\t/*\\n\\t\\t\\t  5____4\\n\\t\\t\\t1/___0/|\\n\\t\\t\\t| 6__|_7\\n\\t\\t\\t2/___3/\\n\\n\\t\\t\\t0: max.x, max.y, max.z\\n\\t\\t\\t1: min.x, max.y, max.z\\n\\t\\t\\t2: min.x, min.y, max.z\\n\\t\\t\\t3: max.x, min.y, max.z\\n\\t\\t\\t4: max.x, max.y, min.z\\n\\t\\t\\t5: min.x, max.y, min.z\\n\\t\\t\\t6: min.x, min.y, min.z\\n\\t\\t\\t7: max.x, min.y, min.z\\n\\t\\t\\t*/\\n\\n\\t\\t\\tvar position = this.geometry.attributes.position;\\n\\t\\t\\tvar array = position.array;\\n\\n\\t\\t\\tarray[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;\\n\\t\\t\\tarray[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;\\n\\t\\t\\tarray[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;\\n\\t\\t\\tarray[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\\n\\t\\t\\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\\n\\t\\t\\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\\n\\t\\t\\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\\n\\t\\t\\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\\n\\n\\t\\t\\tposition.needsUpdate = true;\\n\\n\\t\\t\\tthis.geometry.computeBoundingSphere();\\n\\n\\t\\t};\\n\\n\\t} )();\\n\\n\\tBoxHelper.prototype.setFromObject = function ( object ) {\\n\\n\\t\\tthis.object = object;\\n\\t\\tthis.update();\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction Box3Helper( box, hex ) {\\n\\n\\t\\tthis.type = 'Box3Helper';\\n\\n\\t\\tthis.box = box;\\n\\n\\t\\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\\n\\n\\t\\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\\n\\n\\t\\tvar positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\n\\t\\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\\n\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\\n\\n\\t\\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );\\n\\n\\t\\tthis.geometry.computeBoundingSphere();\\n\\n\\t}\\n\\n\\tBox3Helper.prototype = Object.create( LineSegments.prototype );\\n\\tBox3Helper.prototype.constructor = Box3Helper;\\n\\n\\tBox3Helper.prototype.updateMatrixWorld = function ( force ) {\\n\\n\\t\\tvar box = this.box;\\n\\n\\t\\tif ( box.isEmpty() ) return;\\n\\n\\t\\tbox.getCenter( this.position );\\n\\n\\t\\tbox.getSize( this.scale );\\n\\n\\t\\tthis.scale.multiplyScalar( 0.5 );\\n\\n\\t\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction PlaneHelper( plane, size, hex ) {\\n\\n\\t\\tthis.type = 'PlaneHelper';\\n\\n\\t\\tthis.plane = plane;\\n\\n\\t\\tthis.size = ( size === undefined ) ? 1 : size;\\n\\n\\t\\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\\n\\n\\t\\tvar positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\\n\\t\\tgeometry.computeBoundingSphere();\\n\\n\\t\\tLine.call( this, geometry, new LineBasicMaterial( { color: color } ) );\\n\\n\\t\\t//\\n\\n\\t\\tvar positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];\\n\\n\\t\\tvar geometry2 = new BufferGeometry();\\n\\t\\tgeometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );\\n\\t\\tgeometry2.computeBoundingSphere();\\n\\n\\t\\tthis.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false } ) ) );\\n\\n\\t}\\n\\n\\tPlaneHelper.prototype = Object.create( Line.prototype );\\n\\tPlaneHelper.prototype.constructor = PlaneHelper;\\n\\n\\tPlaneHelper.prototype.updateMatrixWorld = function ( force ) {\\n\\n\\t\\tvar scale = - this.plane.constant;\\n\\n\\t\\tif ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter\\n\\n\\t\\tthis.scale.set( 0.5 * this.size, 0.5 * this.size, scale );\\n\\n\\t\\tthis.lookAt( this.plane.normal );\\n\\n\\t\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t * @author zz85 / http://github.com/zz85\\n\\t * @author bhouston / http://clara.io\\n\\t *\\n\\t * Creates an arrow for visualizing directions\\n\\t *\\n\\t * Parameters:\\n\\t *  dir - Vector3\\n\\t *  origin - Vector3\\n\\t *  length - Number\\n\\t *  color - color in hex value\\n\\t *  headLength - Number\\n\\t *  headWidth - Number\\n\\t */\\n\\n\\tvar lineGeometry;\\n\\tvar coneGeometry;\\n\\n\\tfunction ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\\n\\n\\t\\t// dir is assumed to be normalized\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tif ( color === undefined ) color = 0xffff00;\\n\\t\\tif ( length === undefined ) length = 1;\\n\\t\\tif ( headLength === undefined ) headLength = 0.2 * length;\\n\\t\\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\\n\\n\\t\\tif ( lineGeometry === undefined ) {\\n\\n\\t\\t\\tlineGeometry = new BufferGeometry();\\n\\t\\t\\tlineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\\n\\n\\t\\t\\tconeGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );\\n\\t\\t\\tconeGeometry.translate( 0, - 0.5, 0 );\\n\\n\\t\\t}\\n\\n\\t\\tthis.position.copy( origin );\\n\\n\\t\\tthis.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );\\n\\t\\tthis.line.matrixAutoUpdate = false;\\n\\t\\tthis.add( this.line );\\n\\n\\t\\tthis.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );\\n\\t\\tthis.cone.matrixAutoUpdate = false;\\n\\t\\tthis.add( this.cone );\\n\\n\\t\\tthis.setDirection( dir );\\n\\t\\tthis.setLength( length, headLength, headWidth );\\n\\n\\t}\\n\\n\\tArrowHelper.prototype = Object.create( Object3D.prototype );\\n\\tArrowHelper.prototype.constructor = ArrowHelper;\\n\\n\\tArrowHelper.prototype.setDirection = ( function () {\\n\\n\\t\\tvar axis = new Vector3();\\n\\t\\tvar radians;\\n\\n\\t\\treturn function setDirection( dir ) {\\n\\n\\t\\t\\t// dir is assumed to be normalized\\n\\n\\t\\t\\tif ( dir.y > 0.99999 ) {\\n\\n\\t\\t\\t\\tthis.quaternion.set( 0, 0, 0, 1 );\\n\\n\\t\\t\\t} else if ( dir.y < - 0.99999 ) {\\n\\n\\t\\t\\t\\tthis.quaternion.set( 1, 0, 0, 0 );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\taxis.set( dir.z, 0, - dir.x ).normalize();\\n\\n\\t\\t\\t\\tradians = Math.acos( dir.y );\\n\\n\\t\\t\\t\\tthis.quaternion.setFromAxisAngle( axis, radians );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}() );\\n\\n\\tArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\\n\\n\\t\\tif ( headLength === undefined ) headLength = 0.2 * length;\\n\\t\\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\\n\\n\\t\\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\\n\\t\\tthis.line.updateMatrix();\\n\\n\\t\\tthis.cone.scale.set( headWidth, headLength, headWidth );\\n\\t\\tthis.cone.position.y = length;\\n\\t\\tthis.cone.updateMatrix();\\n\\n\\t};\\n\\n\\tArrowHelper.prototype.setColor = function ( color ) {\\n\\n\\t\\tthis.line.material.color.copy( color );\\n\\t\\tthis.cone.material.color.copy( color );\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author sroucheray / http://sroucheray.org/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction AxesHelper( size ) {\\n\\n\\t\\tsize = size || 1;\\n\\n\\t\\tvar vertices = [\\n\\t\\t\\t0, 0, 0,\\tsize, 0, 0,\\n\\t\\t\\t0, 0, 0,\\t0, size, 0,\\n\\t\\t\\t0, 0, 0,\\t0, 0, size\\n\\t\\t];\\n\\n\\t\\tvar colors = [\\n\\t\\t\\t1, 0, 0,\\t1, 0.6, 0,\\n\\t\\t\\t0, 1, 0,\\t0.6, 1, 0,\\n\\t\\t\\t0, 0, 1,\\t0, 0.6, 1\\n\\t\\t];\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\\n\\n\\t\\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\\n\\n\\t\\tLineSegments.call( this, geometry, material );\\n\\n\\t}\\n\\n\\tAxesHelper.prototype = Object.create( LineSegments.prototype );\\n\\tAxesHelper.prototype.constructor = AxesHelper;\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tvar SceneUtils = {\\n\\n\\t\\tcreateMultiMaterialObject: function ( geometry, materials ) {\\n\\n\\t\\t\\tvar group = new Group();\\n\\n\\t\\t\\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tgroup.add( new Mesh( geometry, materials[ i ] ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn group;\\n\\n\\t\\t},\\n\\n\\t\\tdetach: function ( child, parent, scene ) {\\n\\n\\t\\t\\tchild.applyMatrix( parent.matrixWorld );\\n\\t\\t\\tparent.remove( child );\\n\\t\\t\\tscene.add( child );\\n\\n\\t\\t},\\n\\n\\t\\tattach: function ( child, scene, parent ) {\\n\\n\\t\\t\\tchild.applyMatrix( new Matrix4().getInverse( parent.matrixWorld ) );\\n\\n\\t\\t\\tscene.remove( child );\\n\\t\\t\\tparent.add( child );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction Face4( a, b, c, d, normal, color, materialIndex ) {\\n\\n\\t\\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\\n\\t\\treturn new Face3( a, b, c, normal, color, materialIndex );\\n\\n\\t}\\n\\n\\tvar LineStrip = 0;\\n\\n\\tvar LinePieces = 1;\\n\\n\\tfunction MeshFaceMaterial( materials ) {\\n\\n\\t\\tconsole.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );\\n\\t\\treturn materials;\\n\\n\\t}\\n\\n\\tfunction MultiMaterial( materials ) {\\n\\n\\t\\tif ( materials === undefined ) materials = [];\\n\\n\\t\\tconsole.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );\\n\\t\\tmaterials.isMultiMaterial = true;\\n\\t\\tmaterials.materials = materials;\\n\\t\\tmaterials.clone = function () {\\n\\n\\t\\t\\treturn materials.slice();\\n\\n\\t\\t};\\n\\t\\treturn materials;\\n\\n\\t}\\n\\n\\tfunction PointCloud( geometry, material ) {\\n\\n\\t\\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\\n\\t\\treturn new Points( geometry, material );\\n\\n\\t}\\n\\n\\tfunction Particle( material ) {\\n\\n\\t\\tconsole.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );\\n\\t\\treturn new Sprite( material );\\n\\n\\t}\\n\\n\\tfunction ParticleSystem( geometry, material ) {\\n\\n\\t\\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\\n\\t\\treturn new Points( geometry, material );\\n\\n\\t}\\n\\n\\tfunction PointCloudMaterial( parameters ) {\\n\\n\\t\\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\\n\\t\\treturn new PointsMaterial( parameters );\\n\\n\\t}\\n\\n\\tfunction ParticleBasicMaterial( parameters ) {\\n\\n\\t\\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\\n\\t\\treturn new PointsMaterial( parameters );\\n\\n\\t}\\n\\n\\tfunction ParticleSystemMaterial( parameters ) {\\n\\n\\t\\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\\n\\t\\treturn new PointsMaterial( parameters );\\n\\n\\t}\\n\\n\\tfunction Vertex( x, y, z ) {\\n\\n\\t\\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\\n\\t\\treturn new Vector3( x, y, z );\\n\\n\\t}\\n\\n\\t//\\n\\n\\tfunction DynamicBufferAttribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\\n\\t\\treturn new BufferAttribute( array, itemSize ).setDynamic( true );\\n\\n\\t}\\n\\n\\tfunction Int8Attribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );\\n\\t\\treturn new Int8BufferAttribute( array, itemSize );\\n\\n\\t}\\n\\n\\tfunction Uint8Attribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );\\n\\t\\treturn new Uint8BufferAttribute( array, itemSize );\\n\\n\\t}\\n\\n\\tfunction Uint8ClampedAttribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );\\n\\t\\treturn new Uint8ClampedBufferAttribute( array, itemSize );\\n\\n\\t}\\n\\n\\tfunction Int16Attribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );\\n\\t\\treturn new Int16BufferAttribute( array, itemSize );\\n\\n\\t}\\n\\n\\tfunction Uint16Attribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );\\n\\t\\treturn new Uint16BufferAttribute( array, itemSize );\\n\\n\\t}\\n\\n\\tfunction Int32Attribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );\\n\\t\\treturn new Int32BufferAttribute( array, itemSize );\\n\\n\\t}\\n\\n\\tfunction Uint32Attribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );\\n\\t\\treturn new Uint32BufferAttribute( array, itemSize );\\n\\n\\t}\\n\\n\\tfunction Float32Attribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );\\n\\t\\treturn new Float32BufferAttribute( array, itemSize );\\n\\n\\t}\\n\\n\\tfunction Float64Attribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );\\n\\t\\treturn new Float64BufferAttribute( array, itemSize );\\n\\n\\t}\\n\\n\\t//\\n\\n\\tCurve.create = function ( construct, getPoint ) {\\n\\n\\t\\tconsole.log( 'THREE.Curve.create() has been deprecated' );\\n\\n\\t\\tconstruct.prototype = Object.create( Curve.prototype );\\n\\t\\tconstruct.prototype.constructor = construct;\\n\\t\\tconstruct.prototype.getPoint = getPoint;\\n\\n\\t\\treturn construct;\\n\\n\\t};\\n\\n\\t//\\n\\n\\tObject.assign( CurvePath.prototype, {\\n\\n\\t\\tcreatePointsGeometry: function ( divisions ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );\\n\\n\\t\\t\\t// generate geometry from path points (for Line or Points objects)\\n\\n\\t\\t\\tvar pts = this.getPoints( divisions );\\n\\t\\t\\treturn this.createGeometry( pts );\\n\\n\\t\\t},\\n\\n\\t\\tcreateSpacedPointsGeometry: function ( divisions ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );\\n\\n\\t\\t\\t// generate geometry from equidistant sampling along the path\\n\\n\\t\\t\\tvar pts = this.getSpacedPoints( divisions );\\n\\t\\t\\treturn this.createGeometry( pts );\\n\\n\\t\\t},\\n\\n\\t\\tcreateGeometry: function ( points ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );\\n\\n\\t\\t\\tvar geometry = new Geometry();\\n\\n\\t\\t\\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar point = points[ i ];\\n\\t\\t\\t\\tgeometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn geometry;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tObject.assign( Path.prototype, {\\n\\n\\t\\tfromPoints: function ( points ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );\\n\\t\\t\\tthis.setFromPoints( points );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tfunction ClosedSplineCurve3( points ) {\\n\\n\\t\\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );\\n\\n\\t\\tCatmullRomCurve3.call( this, points );\\n\\t\\tthis.type = 'catmullrom';\\n\\t\\tthis.closed = true;\\n\\n\\t}\\n\\n\\tClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );\\n\\n\\t//\\n\\n\\tfunction SplineCurve3( points ) {\\n\\n\\t\\tconsole.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );\\n\\n\\t\\tCatmullRomCurve3.call( this, points );\\n\\t\\tthis.type = 'catmullrom';\\n\\n\\t}\\n\\n\\tSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );\\n\\n\\t//\\n\\n\\tfunction Spline( points ) {\\n\\n\\t\\tconsole.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );\\n\\n\\t\\tCatmullRomCurve3.call( this, points );\\n\\t\\tthis.type = 'catmullrom';\\n\\n\\t}\\n\\n\\tSpline.prototype = Object.create( CatmullRomCurve3.prototype );\\n\\n\\tObject.assign( Spline.prototype, {\\n\\n\\t\\tinitFromArray: function ( /* a */ ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.Spline: .initFromArray() has been removed.' );\\n\\n\\t\\t},\\n\\t\\tgetControlPointsArray: function ( /* optionalTarget */ ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );\\n\\n\\t\\t},\\n\\t\\treparametrizeByArcLength: function ( /* samplingCoef */ ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tfunction AxisHelper( size ) {\\n\\n\\t\\tconsole.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );\\n\\t\\treturn new AxesHelper( size );\\n\\n\\t}\\n\\n\\tfunction BoundingBoxHelper( object, color ) {\\n\\n\\t\\tconsole.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );\\n\\t\\treturn new BoxHelper( object, color );\\n\\n\\t}\\n\\n\\tfunction EdgesHelper( object, hex ) {\\n\\n\\t\\tconsole.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );\\n\\t\\treturn new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\\n\\n\\t}\\n\\n\\tGridHelper.prototype.setColors = function () {\\n\\n\\t\\tconsole.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\\n\\n\\t};\\n\\n\\tSkeletonHelper.prototype.update = function () {\\n\\n\\t\\tconsole.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );\\n\\n\\t};\\n\\n\\tfunction WireframeHelper( object, hex ) {\\n\\n\\t\\tconsole.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );\\n\\t\\treturn new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\\n\\n\\t}\\n\\n\\t//\\n\\n\\tObject.assign( Loader.prototype, {\\n\\n\\t\\textractUrlBase: function ( url ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );\\n\\t\\t\\treturn LoaderUtils.extractUrlBase( url );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tfunction XHRLoader( manager ) {\\n\\n\\t\\tconsole.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );\\n\\t\\treturn new FileLoader( manager );\\n\\n\\t}\\n\\n\\tfunction BinaryTextureLoader( manager ) {\\n\\n\\t\\tconsole.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );\\n\\t\\treturn new DataTextureLoader( manager );\\n\\n\\t}\\n\\n\\t//\\n\\n\\tObject.assign( Box2.prototype, {\\n\\n\\t\\tcenter: function ( optionalTarget ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );\\n\\t\\t\\treturn this.getCenter( optionalTarget );\\n\\n\\t\\t},\\n\\t\\tempty: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\\n\\t\\t\\treturn this.isEmpty();\\n\\n\\t\\t},\\n\\t\\tisIntersectionBox: function ( box ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\\n\\t\\t\\treturn this.intersectsBox( box );\\n\\n\\t\\t},\\n\\t\\tsize: function ( optionalTarget ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );\\n\\t\\t\\treturn this.getSize( optionalTarget );\\n\\n\\t\\t}\\n\\t} );\\n\\n\\tObject.assign( Box3.prototype, {\\n\\n\\t\\tcenter: function ( optionalTarget ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );\\n\\t\\t\\treturn this.getCenter( optionalTarget );\\n\\n\\t\\t},\\n\\t\\tempty: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\\n\\t\\t\\treturn this.isEmpty();\\n\\n\\t\\t},\\n\\t\\tisIntersectionBox: function ( box ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\\n\\t\\t\\treturn this.intersectsBox( box );\\n\\n\\t\\t},\\n\\t\\tisIntersectionSphere: function ( sphere ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\\n\\t\\t\\treturn this.intersectsSphere( sphere );\\n\\n\\t\\t},\\n\\t\\tsize: function ( optionalTarget ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );\\n\\t\\t\\treturn this.getSize( optionalTarget );\\n\\n\\t\\t}\\n\\t} );\\n\\n\\tLine3.prototype.center = function ( optionalTarget ) {\\n\\n\\t\\tconsole.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );\\n\\t\\treturn this.getCenter( optionalTarget );\\n\\n\\t};\\n\\n\\tObject.assign( _Math, {\\n\\n\\t\\trandom16: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );\\n\\t\\t\\treturn Math.random();\\n\\n\\t\\t},\\n\\n\\t\\tnearestPowerOfTwo: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );\\n\\t\\t\\treturn _Math.floorPowerOfTwo( value );\\n\\n\\t\\t},\\n\\n\\t\\tnextPowerOfTwo: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );\\n\\t\\t\\treturn _Math.ceilPowerOfTwo( value );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( Matrix3.prototype, {\\n\\n\\t\\tflattenToArrayOffset: function ( array, offset ) {\\n\\n\\t\\t\\tconsole.warn( \\\"THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\\\" );\\n\\t\\t\\treturn this.toArray( array, offset );\\n\\n\\t\\t},\\n\\t\\tmultiplyVector3: function ( vector ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\\n\\t\\t\\treturn vector.applyMatrix3( this );\\n\\n\\t\\t},\\n\\t\\tmultiplyVector3Array: function ( /* a */ ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );\\n\\n\\t\\t},\\n\\t\\tapplyToBuffer: function ( buffer /*, offset, length */ ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );\\n\\t\\t\\treturn this.applyToBufferAttribute( buffer );\\n\\n\\t\\t},\\n\\t\\tapplyToVector3Array: function ( /* array, offset, length */ ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( Matrix4.prototype, {\\n\\n\\t\\textractPosition: function ( m ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\\n\\t\\t\\treturn this.copyPosition( m );\\n\\n\\t\\t},\\n\\t\\tflattenToArrayOffset: function ( array, offset ) {\\n\\n\\t\\t\\tconsole.warn( \\\"THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\\\" );\\n\\t\\t\\treturn this.toArray( array, offset );\\n\\n\\t\\t},\\n\\t\\tgetPosition: function () {\\n\\n\\t\\t\\tvar v1;\\n\\n\\t\\t\\treturn function getPosition() {\\n\\n\\t\\t\\t\\tif ( v1 === undefined ) v1 = new Vector3();\\n\\t\\t\\t\\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\\n\\t\\t\\t\\treturn v1.setFromMatrixColumn( this, 3 );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\t\\tsetRotationFromQuaternion: function ( q ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\\n\\t\\t\\treturn this.makeRotationFromQuaternion( q );\\n\\n\\t\\t},\\n\\t\\tmultiplyToArray: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );\\n\\n\\t\\t},\\n\\t\\tmultiplyVector3: function ( vector ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\\n\\t\\t\\treturn vector.applyMatrix4( this );\\n\\n\\t\\t},\\n\\t\\tmultiplyVector4: function ( vector ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\\n\\t\\t\\treturn vector.applyMatrix4( this );\\n\\n\\t\\t},\\n\\t\\tmultiplyVector3Array: function ( /* a */ ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );\\n\\n\\t\\t},\\n\\t\\trotateAxis: function ( v ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\\n\\t\\t\\tv.transformDirection( this );\\n\\n\\t\\t},\\n\\t\\tcrossVector: function ( vector ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\\n\\t\\t\\treturn vector.applyMatrix4( this );\\n\\n\\t\\t},\\n\\t\\ttranslate: function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\\n\\n\\t\\t},\\n\\t\\trotateX: function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\\n\\n\\t\\t},\\n\\t\\trotateY: function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\\n\\n\\t\\t},\\n\\t\\trotateZ: function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\\n\\n\\t\\t},\\n\\t\\trotateByAxis: function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\\n\\n\\t\\t},\\n\\t\\tapplyToBuffer: function ( buffer /*, offset, length */ ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );\\n\\t\\t\\treturn this.applyToBufferAttribute( buffer );\\n\\n\\t\\t},\\n\\t\\tapplyToVector3Array: function ( /* array, offset, length */ ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );\\n\\n\\t\\t},\\n\\t\\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );\\n\\t\\t\\treturn this.makePerspective( left, right, top, bottom, near, far );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tPlane.prototype.isIntersectionLine = function ( line ) {\\n\\n\\t\\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\\n\\t\\treturn this.intersectsLine( line );\\n\\n\\t};\\n\\n\\tQuaternion.prototype.multiplyVector3 = function ( vector ) {\\n\\n\\t\\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\\n\\t\\treturn vector.applyQuaternion( this );\\n\\n\\t};\\n\\n\\tObject.assign( Ray.prototype, {\\n\\n\\t\\tisIntersectionBox: function ( box ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\\n\\t\\t\\treturn this.intersectsBox( box );\\n\\n\\t\\t},\\n\\t\\tisIntersectionPlane: function ( plane ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\\n\\t\\t\\treturn this.intersectsPlane( plane );\\n\\n\\t\\t},\\n\\t\\tisIntersectionSphere: function ( sphere ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\\n\\t\\t\\treturn this.intersectsSphere( sphere );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( Shape.prototype, {\\n\\n\\t\\textractAllPoints: function ( divisions ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );\\n\\t\\t\\treturn this.extractPoints( divisions );\\n\\n\\t\\t},\\n\\t\\textrude: function ( options ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );\\n\\t\\t\\treturn new ExtrudeGeometry( this, options );\\n\\n\\t\\t},\\n\\t\\tmakeGeometry: function ( options ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );\\n\\t\\t\\treturn new ShapeGeometry( this, options );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( Vector2.prototype, {\\n\\n\\t\\tfromAttribute: function ( attribute, index, offset ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );\\n\\t\\t\\treturn this.fromBufferAttribute( attribute, index, offset );\\n\\n\\t\\t},\\n\\t\\tdistanceToManhattan: function ( v ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );\\n\\t\\t\\treturn this.manhattanDistanceTo( v );\\n\\n\\t\\t},\\n\\t\\tlengthManhattan: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );\\n\\t\\t\\treturn this.manhattanLength();\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( Vector3.prototype, {\\n\\n\\t\\tsetEulerFromRotationMatrix: function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\\n\\n\\t\\t},\\n\\t\\tsetEulerFromQuaternion: function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\\n\\n\\t\\t},\\n\\t\\tgetPositionFromMatrix: function ( m ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\\n\\t\\t\\treturn this.setFromMatrixPosition( m );\\n\\n\\t\\t},\\n\\t\\tgetScaleFromMatrix: function ( m ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\\n\\t\\t\\treturn this.setFromMatrixScale( m );\\n\\n\\t\\t},\\n\\t\\tgetColumnFromMatrix: function ( index, matrix ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\\n\\t\\t\\treturn this.setFromMatrixColumn( matrix, index );\\n\\n\\t\\t},\\n\\t\\tapplyProjection: function ( m ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );\\n\\t\\t\\treturn this.applyMatrix4( m );\\n\\n\\t\\t},\\n\\t\\tfromAttribute: function ( attribute, index, offset ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );\\n\\t\\t\\treturn this.fromBufferAttribute( attribute, index, offset );\\n\\n\\t\\t},\\n\\t\\tdistanceToManhattan: function ( v ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );\\n\\t\\t\\treturn this.manhattanDistanceTo( v );\\n\\n\\t\\t},\\n\\t\\tlengthManhattan: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );\\n\\t\\t\\treturn this.manhattanLength();\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( Vector4.prototype, {\\n\\n\\t\\tfromAttribute: function ( attribute, index, offset ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );\\n\\t\\t\\treturn this.fromBufferAttribute( attribute, index, offset );\\n\\n\\t\\t},\\n\\t\\tlengthManhattan: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );\\n\\t\\t\\treturn this.manhattanLength();\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tGeometry.prototype.computeTangents = function () {\\n\\n\\t\\tconsole.warn( 'THREE.Geometry: .computeTangents() has been removed.' );\\n\\n\\t};\\n\\n\\tObject.assign( Object3D.prototype, {\\n\\n\\t\\tgetChildByName: function ( name ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\\n\\t\\t\\treturn this.getObjectByName( name );\\n\\n\\t\\t},\\n\\t\\trenderDepth: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\\n\\n\\t\\t},\\n\\t\\ttranslate: function ( distance, axis ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\\n\\t\\t\\treturn this.translateOnAxis( axis, distance );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperties( Object3D.prototype, {\\n\\n\\t\\teulerOrder: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\\n\\t\\t\\t\\treturn this.rotation.order;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\\n\\t\\t\\t\\tthis.rotation.order = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tuseQuaternion: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperties( LOD.prototype, {\\n\\n\\t\\tobjects: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\\n\\t\\t\\t\\treturn this.levels;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperty( Skeleton.prototype, 'useVertexTexture', {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );\\n\\n\\t\\t},\\n\\t\\tset: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperty( Curve.prototype, '__arcLengthDivisions', {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );\\n\\t\\t\\treturn this.arcLengthDivisions;\\n\\n\\t\\t},\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );\\n\\t\\t\\tthis.arcLengthDivisions = value;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tPerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\\n\\n\\t\\tconsole.warn( \\\"THREE.PerspectiveCamera.setLens is deprecated. \\\" +\\n\\t\\t\\t\\t\\\"Use .setFocalLength and .filmGauge for a photographic setup.\\\" );\\n\\n\\t\\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\\n\\t\\tthis.setFocalLength( focalLength );\\n\\n\\t};\\n\\n\\t//\\n\\n\\tObject.defineProperties( Light.prototype, {\\n\\t\\tonlyShadow: {\\n\\t\\t\\tset: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowCameraFov: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\\n\\t\\t\\t\\tthis.shadow.camera.fov = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowCameraLeft: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\\n\\t\\t\\t\\tthis.shadow.camera.left = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowCameraRight: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\\n\\t\\t\\t\\tthis.shadow.camera.right = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowCameraTop: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\\n\\t\\t\\t\\tthis.shadow.camera.top = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowCameraBottom: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\\n\\t\\t\\t\\tthis.shadow.camera.bottom = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowCameraNear: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\\n\\t\\t\\t\\tthis.shadow.camera.near = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowCameraFar: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\\n\\t\\t\\t\\tthis.shadow.camera.far = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowCameraVisible: {\\n\\t\\t\\tset: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowBias: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\\n\\t\\t\\t\\tthis.shadow.bias = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowDarkness: {\\n\\t\\t\\tset: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowMapWidth: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\\n\\t\\t\\t\\tthis.shadow.mapSize.width = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowMapHeight: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\\n\\t\\t\\t\\tthis.shadow.mapSize.height = value;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} );\\n\\n\\t//\\n\\n\\tObject.defineProperties( BufferAttribute.prototype, {\\n\\n\\t\\tlength: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );\\n\\t\\t\\t\\treturn this.array.length;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( BufferGeometry.prototype, {\\n\\n\\t\\taddIndex: function ( index ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\\n\\t\\t\\tthis.setIndex( index );\\n\\n\\t\\t},\\n\\t\\taddDrawCall: function ( start, count, indexOffset ) {\\n\\n\\t\\t\\tif ( indexOffset !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\\n\\n\\t\\t\\t}\\n\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\\n\\t\\t\\tthis.addGroup( start, count );\\n\\n\\t\\t},\\n\\t\\tclearDrawCalls: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\\n\\t\\t\\tthis.clearGroups();\\n\\n\\t\\t},\\n\\t\\tcomputeTangents: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\\n\\n\\t\\t},\\n\\t\\tcomputeOffsets: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperties( BufferGeometry.prototype, {\\n\\n\\t\\tdrawcalls: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\\n\\t\\t\\t\\treturn this.groups;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\toffsets: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\\n\\t\\t\\t\\treturn this.groups;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tObject.defineProperties( Uniform.prototype, {\\n\\n\\t\\tdynamic: {\\n\\t\\t\\tset: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tonUpdate: {\\n\\t\\t\\tvalue: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tObject.defineProperties( Material.prototype, {\\n\\n\\t\\twrapAround: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Material: .wrapAround has been removed.' );\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Material: .wrapAround has been removed.' );\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\twrapRGB: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Material: .wrapRGB has been removed.' );\\n\\t\\t\\t\\treturn new Color();\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tshading: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\\n\\t\\t\\t\\tthis.flatShading = ( value === FlatShading );\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperties( MeshPhongMaterial.prototype, {\\n\\n\\t\\tmetal: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperties( ShaderMaterial.prototype, {\\n\\n\\t\\tderivatives: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\\n\\t\\t\\t\\treturn this.extensions.derivatives;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\\n\\t\\t\\t\\tthis.extensions.derivatives = value;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tObject.assign( WebGLRenderer.prototype, {\\n\\n\\t\\tgetCurrentRenderTarget: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );\\n\\t\\t\\treturn this.getRenderTarget();\\n\\n\\t\\t},\\n\\n\\t\\tgetMaxAnisotropy: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );\\n\\t\\t\\treturn this.capabilities.getMaxAnisotropy();\\n\\n\\t\\t},\\n\\n\\t\\tgetPrecision: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );\\n\\t\\t\\treturn this.capabilities.precision;\\n\\n\\t\\t},\\n\\n\\t\\tresetGLState: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );\\n\\t\\t\\treturn this.state.reset();\\n\\n\\t\\t},\\n\\n\\t\\tsupportsFloatTextures: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\\\'OES_texture_float\\\\' ).' );\\n\\t\\t\\treturn this.extensions.get( 'OES_texture_float' );\\n\\n\\t\\t},\\n\\t\\tsupportsHalfFloatTextures: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\\\'OES_texture_half_float\\\\' ).' );\\n\\t\\t\\treturn this.extensions.get( 'OES_texture_half_float' );\\n\\n\\t\\t},\\n\\t\\tsupportsStandardDerivatives: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\\\'OES_standard_derivatives\\\\' ).' );\\n\\t\\t\\treturn this.extensions.get( 'OES_standard_derivatives' );\\n\\n\\t\\t},\\n\\t\\tsupportsCompressedTextureS3TC: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\\\'WEBGL_compressed_texture_s3tc\\\\' ).' );\\n\\t\\t\\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\\n\\n\\t\\t},\\n\\t\\tsupportsCompressedTexturePVRTC: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\\\'WEBGL_compressed_texture_pvrtc\\\\' ).' );\\n\\t\\t\\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\\n\\n\\t\\t},\\n\\t\\tsupportsBlendMinMax: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\\\'EXT_blend_minmax\\\\' ).' );\\n\\t\\t\\treturn this.extensions.get( 'EXT_blend_minmax' );\\n\\n\\t\\t},\\n\\t\\tsupportsVertexTextures: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );\\n\\t\\t\\treturn this.capabilities.vertexTextures;\\n\\n\\t\\t},\\n\\t\\tsupportsInstancedArrays: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\\\'ANGLE_instanced_arrays\\\\' ).' );\\n\\t\\t\\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\\n\\n\\t\\t},\\n\\t\\tenableScissorTest: function ( boolean ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\\n\\t\\t\\tthis.setScissorTest( boolean );\\n\\n\\t\\t},\\n\\t\\tinitMaterial: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\\n\\n\\t\\t},\\n\\t\\taddPrePlugin: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\\n\\n\\t\\t},\\n\\t\\taddPostPlugin: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\\n\\n\\t\\t},\\n\\t\\tupdateShadowMap: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperties( WebGLRenderer.prototype, {\\n\\n\\t\\tshadowMapEnabled: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this.shadowMap.enabled;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\\n\\t\\t\\t\\tthis.shadowMap.enabled = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowMapType: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this.shadowMap.type;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\\n\\t\\t\\t\\tthis.shadowMap.type = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowMapCullFace: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this.shadowMap.cullFace;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );\\n\\t\\t\\t\\tthis.shadowMap.cullFace = value;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} );\\n\\n\\tObject.defineProperties( WebGLShadowMap.prototype, {\\n\\n\\t\\tcullFace: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this.renderReverseSided ? CullFaceFront : CullFaceBack;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( cullFace ) {\\n\\n\\t\\t\\t\\tvar value = ( cullFace !== CullFaceBack );\\n\\t\\t\\t\\tconsole.warn( \\\"WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to \\\" + value + \\\".\\\" );\\n\\t\\t\\t\\tthis.renderReverseSided = value;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tObject.defineProperties( WebGLRenderTarget.prototype, {\\n\\n\\t\\twrapS: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\\n\\t\\t\\t\\treturn this.texture.wrapS;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\\n\\t\\t\\t\\tthis.texture.wrapS = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\twrapT: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\\n\\t\\t\\t\\treturn this.texture.wrapT;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\\n\\t\\t\\t\\tthis.texture.wrapT = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tmagFilter: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\\n\\t\\t\\t\\treturn this.texture.magFilter;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\\n\\t\\t\\t\\tthis.texture.magFilter = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tminFilter: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\\n\\t\\t\\t\\treturn this.texture.minFilter;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\\n\\t\\t\\t\\tthis.texture.minFilter = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tanisotropy: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\\n\\t\\t\\t\\treturn this.texture.anisotropy;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\\n\\t\\t\\t\\tthis.texture.anisotropy = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\toffset: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\\n\\t\\t\\t\\treturn this.texture.offset;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\\n\\t\\t\\t\\tthis.texture.offset = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\trepeat: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\\n\\t\\t\\t\\treturn this.texture.repeat;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\\n\\t\\t\\t\\tthis.texture.repeat = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tformat: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\\n\\t\\t\\t\\treturn this.texture.format;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\\n\\t\\t\\t\\tthis.texture.format = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\ttype: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\\n\\t\\t\\t\\treturn this.texture.type;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\\n\\t\\t\\t\\tthis.texture.type = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tgenerateMipmaps: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\\n\\t\\t\\t\\treturn this.texture.generateMipmaps;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\\n\\t\\t\\t\\tthis.texture.generateMipmaps = value;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tObject.assign( WebVRManager.prototype, {\\n\\n\\t\\tgetStandingMatrix: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebVRManager: .getStandingMatrix() has been removed.' );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperties( WebVRManager.prototype, {\\n\\n\\t\\tstanding: {\\n\\t\\t\\tset: function ( /* value */ ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebVRManager: .standing has been removed.' );\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tAudio.prototype.load = function ( file ) {\\n\\n\\t\\tconsole.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );\\n\\t\\tvar scope = this;\\n\\t\\tvar audioLoader = new AudioLoader();\\n\\t\\taudioLoader.load( file, function ( buffer ) {\\n\\n\\t\\t\\tscope.setBuffer( buffer );\\n\\n\\t\\t} );\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tAudioAnalyser.prototype.getData = function () {\\n\\n\\t\\tconsole.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\\n\\t\\treturn this.getFrequencyData();\\n\\n\\t};\\n\\n\\t//\\n\\n\\tCubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {\\n\\n\\t\\tconsole.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );\\n\\t\\treturn this.update( renderer, scene );\\n\\n\\t};\\n\\n\\t//\\n\\n\\tvar GeometryUtils = {\\n\\n\\t\\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\\n\\t\\t\\tvar matrix;\\n\\n\\t\\t\\tif ( geometry2.isMesh ) {\\n\\n\\t\\t\\t\\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\\n\\n\\t\\t\\t\\tmatrix = geometry2.matrix;\\n\\t\\t\\t\\tgeometry2 = geometry2.geometry;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\\n\\n\\t\\t},\\n\\n\\t\\tcenter: function ( geometry ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\\n\\t\\t\\treturn geometry.center();\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tvar ImageUtils = {\\n\\n\\t\\tcrossOrigin: undefined,\\n\\n\\t\\tloadTexture: function ( url, mapping, onLoad, onError ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\\n\\n\\t\\t\\tvar loader = new TextureLoader();\\n\\t\\t\\tloader.setCrossOrigin( this.crossOrigin );\\n\\n\\t\\t\\tvar texture = loader.load( url, onLoad, undefined, onError );\\n\\n\\t\\t\\tif ( mapping ) texture.mapping = mapping;\\n\\n\\t\\t\\treturn texture;\\n\\n\\t\\t},\\n\\n\\t\\tloadTextureCube: function ( urls, mapping, onLoad, onError ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\\n\\n\\t\\t\\tvar loader = new CubeTextureLoader();\\n\\t\\t\\tloader.setCrossOrigin( this.crossOrigin );\\n\\n\\t\\t\\tvar texture = loader.load( urls, onLoad, undefined, onError );\\n\\n\\t\\t\\tif ( mapping ) texture.mapping = mapping;\\n\\n\\t\\t\\treturn texture;\\n\\n\\t\\t},\\n\\n\\t\\tloadCompressedTexture: function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\\n\\n\\t\\t},\\n\\n\\t\\tloadCompressedTextureCube: function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t//\\n\\n\\tfunction Projector() {\\n\\n\\t\\tconsole.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\\n\\n\\t\\tthis.projectVector = function ( vector, camera ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\\n\\t\\t\\tvector.project( camera );\\n\\n\\t\\t};\\n\\n\\t\\tthis.unprojectVector = function ( vector, camera ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\\n\\t\\t\\tvector.unproject( camera );\\n\\n\\t\\t};\\n\\n\\t\\tthis.pickingRay = function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t//\\n\\n\\tfunction CanvasRenderer() {\\n\\n\\t\\tconsole.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\\n\\n\\t\\tthis.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\\n\\t\\tthis.clear = function () {};\\n\\t\\tthis.render = function () {};\\n\\t\\tthis.setClearColor = function () {};\\n\\t\\tthis.setSize = function () {};\\n\\n\\t}\\n\\n\\texports.WebGLRenderTargetCube = WebGLRenderTargetCube;\\n\\texports.WebGLRenderTarget = WebGLRenderTarget;\\n\\texports.WebGLRenderer = WebGLRenderer;\\n\\texports.ShaderLib = ShaderLib;\\n\\texports.UniformsLib = UniformsLib;\\n\\texports.UniformsUtils = UniformsUtils;\\n\\texports.ShaderChunk = ShaderChunk;\\n\\texports.FogExp2 = FogExp2;\\n\\texports.Fog = Fog;\\n\\texports.Scene = Scene;\\n\\texports.LensFlare = LensFlare;\\n\\texports.Sprite = Sprite;\\n\\texports.LOD = LOD;\\n\\texports.SkinnedMesh = SkinnedMesh;\\n\\texports.Skeleton = Skeleton;\\n\\texports.Bone = Bone;\\n\\texports.Mesh = Mesh;\\n\\texports.LineSegments = LineSegments;\\n\\texports.LineLoop = LineLoop;\\n\\texports.Line = Line;\\n\\texports.Points = Points;\\n\\texports.Group = Group;\\n\\texports.VideoTexture = VideoTexture;\\n\\texports.DataTexture = DataTexture;\\n\\texports.CompressedTexture = CompressedTexture;\\n\\texports.CubeTexture = CubeTexture;\\n\\texports.CanvasTexture = CanvasTexture;\\n\\texports.DepthTexture = DepthTexture;\\n\\texports.Texture = Texture;\\n\\texports.CompressedTextureLoader = CompressedTextureLoader;\\n\\texports.DataTextureLoader = DataTextureLoader;\\n\\texports.CubeTextureLoader = CubeTextureLoader;\\n\\texports.TextureLoader = TextureLoader;\\n\\texports.ObjectLoader = ObjectLoader;\\n\\texports.MaterialLoader = MaterialLoader;\\n\\texports.BufferGeometryLoader = BufferGeometryLoader;\\n\\texports.DefaultLoadingManager = DefaultLoadingManager;\\n\\texports.LoadingManager = LoadingManager;\\n\\texports.JSONLoader = JSONLoader;\\n\\texports.ImageLoader = ImageLoader;\\n\\texports.ImageBitmapLoader = ImageBitmapLoader;\\n\\texports.FontLoader = FontLoader;\\n\\texports.FileLoader = FileLoader;\\n\\texports.Loader = Loader;\\n\\texports.LoaderUtils = LoaderUtils;\\n\\texports.Cache = Cache;\\n\\texports.AudioLoader = AudioLoader;\\n\\texports.SpotLightShadow = SpotLightShadow;\\n\\texports.SpotLight = SpotLight;\\n\\texports.PointLight = PointLight;\\n\\texports.RectAreaLight = RectAreaLight;\\n\\texports.HemisphereLight = HemisphereLight;\\n\\texports.DirectionalLightShadow = DirectionalLightShadow;\\n\\texports.DirectionalLight = DirectionalLight;\\n\\texports.AmbientLight = AmbientLight;\\n\\texports.LightShadow = LightShadow;\\n\\texports.Light = Light;\\n\\texports.StereoCamera = StereoCamera;\\n\\texports.PerspectiveCamera = PerspectiveCamera;\\n\\texports.OrthographicCamera = OrthographicCamera;\\n\\texports.CubeCamera = CubeCamera;\\n\\texports.ArrayCamera = ArrayCamera;\\n\\texports.Camera = Camera;\\n\\texports.AudioListener = AudioListener;\\n\\texports.PositionalAudio = PositionalAudio;\\n\\texports.AudioContext = AudioContext;\\n\\texports.AudioAnalyser = AudioAnalyser;\\n\\texports.Audio = Audio;\\n\\texports.VectorKeyframeTrack = VectorKeyframeTrack;\\n\\texports.StringKeyframeTrack = StringKeyframeTrack;\\n\\texports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;\\n\\texports.NumberKeyframeTrack = NumberKeyframeTrack;\\n\\texports.ColorKeyframeTrack = ColorKeyframeTrack;\\n\\texports.BooleanKeyframeTrack = BooleanKeyframeTrack;\\n\\texports.PropertyMixer = PropertyMixer;\\n\\texports.PropertyBinding = PropertyBinding;\\n\\texports.KeyframeTrack = KeyframeTrack;\\n\\texports.AnimationUtils = AnimationUtils;\\n\\texports.AnimationObjectGroup = AnimationObjectGroup;\\n\\texports.AnimationMixer = AnimationMixer;\\n\\texports.AnimationClip = AnimationClip;\\n\\texports.Uniform = Uniform;\\n\\texports.InstancedBufferGeometry = InstancedBufferGeometry;\\n\\texports.BufferGeometry = BufferGeometry;\\n\\texports.Geometry = Geometry;\\n\\texports.InterleavedBufferAttribute = InterleavedBufferAttribute;\\n\\texports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;\\n\\texports.InterleavedBuffer = InterleavedBuffer;\\n\\texports.InstancedBufferAttribute = InstancedBufferAttribute;\\n\\texports.Face3 = Face3;\\n\\texports.Object3D = Object3D;\\n\\texports.Raycaster = Raycaster;\\n\\texports.Layers = Layers;\\n\\texports.EventDispatcher = EventDispatcher;\\n\\texports.Clock = Clock;\\n\\texports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;\\n\\texports.LinearInterpolant = LinearInterpolant;\\n\\texports.DiscreteInterpolant = DiscreteInterpolant;\\n\\texports.CubicInterpolant = CubicInterpolant;\\n\\texports.Interpolant = Interpolant;\\n\\texports.Triangle = Triangle;\\n\\texports.Math = _Math;\\n\\texports.Spherical = Spherical;\\n\\texports.Cylindrical = Cylindrical;\\n\\texports.Plane = Plane;\\n\\texports.Frustum = Frustum;\\n\\texports.Sphere = Sphere;\\n\\texports.Ray = Ray;\\n\\texports.Matrix4 = Matrix4;\\n\\texports.Matrix3 = Matrix3;\\n\\texports.Box3 = Box3;\\n\\texports.Box2 = Box2;\\n\\texports.Line3 = Line3;\\n\\texports.Euler = Euler;\\n\\texports.Vector4 = Vector4;\\n\\texports.Vector3 = Vector3;\\n\\texports.Vector2 = Vector2;\\n\\texports.Quaternion = Quaternion;\\n\\texports.Color = Color;\\n\\texports.ImmediateRenderObject = ImmediateRenderObject;\\n\\texports.VertexNormalsHelper = VertexNormalsHelper;\\n\\texports.SpotLightHelper = SpotLightHelper;\\n\\texports.SkeletonHelper = SkeletonHelper;\\n\\texports.PointLightHelper = PointLightHelper;\\n\\texports.RectAreaLightHelper = RectAreaLightHelper;\\n\\texports.HemisphereLightHelper = HemisphereLightHelper;\\n\\texports.GridHelper = GridHelper;\\n\\texports.PolarGridHelper = PolarGridHelper;\\n\\texports.FaceNormalsHelper = FaceNormalsHelper;\\n\\texports.DirectionalLightHelper = DirectionalLightHelper;\\n\\texports.CameraHelper = CameraHelper;\\n\\texports.BoxHelper = BoxHelper;\\n\\texports.Box3Helper = Box3Helper;\\n\\texports.PlaneHelper = PlaneHelper;\\n\\texports.ArrowHelper = ArrowHelper;\\n\\texports.AxesHelper = AxesHelper;\\n\\texports.Shape = Shape;\\n\\texports.Path = Path;\\n\\texports.ShapePath = ShapePath;\\n\\texports.Font = Font;\\n\\texports.CurvePath = CurvePath;\\n\\texports.Curve = Curve;\\n\\texports.ShapeUtils = ShapeUtils;\\n\\texports.SceneUtils = SceneUtils;\\n\\texports.WebGLUtils = WebGLUtils;\\n\\texports.WireframeGeometry = WireframeGeometry;\\n\\texports.ParametricGeometry = ParametricGeometry;\\n\\texports.ParametricBufferGeometry = ParametricBufferGeometry;\\n\\texports.TetrahedronGeometry = TetrahedronGeometry;\\n\\texports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;\\n\\texports.OctahedronGeometry = OctahedronGeometry;\\n\\texports.OctahedronBufferGeometry = OctahedronBufferGeometry;\\n\\texports.IcosahedronGeometry = IcosahedronGeometry;\\n\\texports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;\\n\\texports.DodecahedronGeometry = DodecahedronGeometry;\\n\\texports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;\\n\\texports.PolyhedronGeometry = PolyhedronGeometry;\\n\\texports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;\\n\\texports.TubeGeometry = TubeGeometry;\\n\\texports.TubeBufferGeometry = TubeBufferGeometry;\\n\\texports.TorusKnotGeometry = TorusKnotGeometry;\\n\\texports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;\\n\\texports.TorusGeometry = TorusGeometry;\\n\\texports.TorusBufferGeometry = TorusBufferGeometry;\\n\\texports.TextGeometry = TextGeometry;\\n\\texports.TextBufferGeometry = TextBufferGeometry;\\n\\texports.SphereGeometry = SphereGeometry;\\n\\texports.SphereBufferGeometry = SphereBufferGeometry;\\n\\texports.RingGeometry = RingGeometry;\\n\\texports.RingBufferGeometry = RingBufferGeometry;\\n\\texports.PlaneGeometry = PlaneGeometry;\\n\\texports.PlaneBufferGeometry = PlaneBufferGeometry;\\n\\texports.LatheGeometry = LatheGeometry;\\n\\texports.LatheBufferGeometry = LatheBufferGeometry;\\n\\texports.ShapeGeometry = ShapeGeometry;\\n\\texports.ShapeBufferGeometry = ShapeBufferGeometry;\\n\\texports.ExtrudeGeometry = ExtrudeGeometry;\\n\\texports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;\\n\\texports.EdgesGeometry = EdgesGeometry;\\n\\texports.ConeGeometry = ConeGeometry;\\n\\texports.ConeBufferGeometry = ConeBufferGeometry;\\n\\texports.CylinderGeometry = CylinderGeometry;\\n\\texports.CylinderBufferGeometry = CylinderBufferGeometry;\\n\\texports.CircleGeometry = CircleGeometry;\\n\\texports.CircleBufferGeometry = CircleBufferGeometry;\\n\\texports.BoxGeometry = BoxGeometry;\\n\\texports.BoxBufferGeometry = BoxBufferGeometry;\\n\\texports.ShadowMaterial = ShadowMaterial;\\n\\texports.SpriteMaterial = SpriteMaterial;\\n\\texports.RawShaderMaterial = RawShaderMaterial;\\n\\texports.ShaderMaterial = ShaderMaterial;\\n\\texports.PointsMaterial = PointsMaterial;\\n\\texports.MeshPhysicalMaterial = MeshPhysicalMaterial;\\n\\texports.MeshStandardMaterial = MeshStandardMaterial;\\n\\texports.MeshPhongMaterial = MeshPhongMaterial;\\n\\texports.MeshToonMaterial = MeshToonMaterial;\\n\\texports.MeshNormalMaterial = MeshNormalMaterial;\\n\\texports.MeshLambertMaterial = MeshLambertMaterial;\\n\\texports.MeshDepthMaterial = MeshDepthMaterial;\\n\\texports.MeshDistanceMaterial = MeshDistanceMaterial;\\n\\texports.MeshBasicMaterial = MeshBasicMaterial;\\n\\texports.LineDashedMaterial = LineDashedMaterial;\\n\\texports.LineBasicMaterial = LineBasicMaterial;\\n\\texports.Material = Material;\\n\\texports.Float64BufferAttribute = Float64BufferAttribute;\\n\\texports.Float32BufferAttribute = Float32BufferAttribute;\\n\\texports.Uint32BufferAttribute = Uint32BufferAttribute;\\n\\texports.Int32BufferAttribute = Int32BufferAttribute;\\n\\texports.Uint16BufferAttribute = Uint16BufferAttribute;\\n\\texports.Int16BufferAttribute = Int16BufferAttribute;\\n\\texports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;\\n\\texports.Uint8BufferAttribute = Uint8BufferAttribute;\\n\\texports.Int8BufferAttribute = Int8BufferAttribute;\\n\\texports.BufferAttribute = BufferAttribute;\\n\\texports.ArcCurve = ArcCurve;\\n\\texports.CatmullRomCurve3 = CatmullRomCurve3;\\n\\texports.CubicBezierCurve = CubicBezierCurve;\\n\\texports.CubicBezierCurve3 = CubicBezierCurve3;\\n\\texports.EllipseCurve = EllipseCurve;\\n\\texports.LineCurve = LineCurve;\\n\\texports.LineCurve3 = LineCurve3;\\n\\texports.QuadraticBezierCurve = QuadraticBezierCurve;\\n\\texports.QuadraticBezierCurve3 = QuadraticBezierCurve3;\\n\\texports.SplineCurve = SplineCurve;\\n\\texports.REVISION = REVISION;\\n\\texports.MOUSE = MOUSE;\\n\\texports.CullFaceNone = CullFaceNone;\\n\\texports.CullFaceBack = CullFaceBack;\\n\\texports.CullFaceFront = CullFaceFront;\\n\\texports.CullFaceFrontBack = CullFaceFrontBack;\\n\\texports.FrontFaceDirectionCW = FrontFaceDirectionCW;\\n\\texports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;\\n\\texports.BasicShadowMap = BasicShadowMap;\\n\\texports.PCFShadowMap = PCFShadowMap;\\n\\texports.PCFSoftShadowMap = PCFSoftShadowMap;\\n\\texports.FrontSide = FrontSide;\\n\\texports.BackSide = BackSide;\\n\\texports.DoubleSide = DoubleSide;\\n\\texports.FlatShading = FlatShading;\\n\\texports.SmoothShading = SmoothShading;\\n\\texports.NoColors = NoColors;\\n\\texports.FaceColors = FaceColors;\\n\\texports.VertexColors = VertexColors;\\n\\texports.NoBlending = NoBlending;\\n\\texports.NormalBlending = NormalBlending;\\n\\texports.AdditiveBlending = AdditiveBlending;\\n\\texports.SubtractiveBlending = SubtractiveBlending;\\n\\texports.MultiplyBlending = MultiplyBlending;\\n\\texports.CustomBlending = CustomBlending;\\n\\texports.AddEquation = AddEquation;\\n\\texports.SubtractEquation = SubtractEquation;\\n\\texports.ReverseSubtractEquation = ReverseSubtractEquation;\\n\\texports.MinEquation = MinEquation;\\n\\texports.MaxEquation = MaxEquation;\\n\\texports.ZeroFactor = ZeroFactor;\\n\\texports.OneFactor = OneFactor;\\n\\texports.SrcColorFactor = SrcColorFactor;\\n\\texports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;\\n\\texports.SrcAlphaFactor = SrcAlphaFactor;\\n\\texports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;\\n\\texports.DstAlphaFactor = DstAlphaFactor;\\n\\texports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;\\n\\texports.DstColorFactor = DstColorFactor;\\n\\texports.OneMinusDstColorFactor = OneMinusDstColorFactor;\\n\\texports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;\\n\\texports.NeverDepth = NeverDepth;\\n\\texports.AlwaysDepth = AlwaysDepth;\\n\\texports.LessDepth = LessDepth;\\n\\texports.LessEqualDepth = LessEqualDepth;\\n\\texports.EqualDepth = EqualDepth;\\n\\texports.GreaterEqualDepth = GreaterEqualDepth;\\n\\texports.GreaterDepth = GreaterDepth;\\n\\texports.NotEqualDepth = NotEqualDepth;\\n\\texports.MultiplyOperation = MultiplyOperation;\\n\\texports.MixOperation = MixOperation;\\n\\texports.AddOperation = AddOperation;\\n\\texports.NoToneMapping = NoToneMapping;\\n\\texports.LinearToneMapping = LinearToneMapping;\\n\\texports.ReinhardToneMapping = ReinhardToneMapping;\\n\\texports.Uncharted2ToneMapping = Uncharted2ToneMapping;\\n\\texports.CineonToneMapping = CineonToneMapping;\\n\\texports.UVMapping = UVMapping;\\n\\texports.CubeReflectionMapping = CubeReflectionMapping;\\n\\texports.CubeRefractionMapping = CubeRefractionMapping;\\n\\texports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;\\n\\texports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;\\n\\texports.SphericalReflectionMapping = SphericalReflectionMapping;\\n\\texports.CubeUVReflectionMapping = CubeUVReflectionMapping;\\n\\texports.CubeUVRefractionMapping = CubeUVRefractionMapping;\\n\\texports.RepeatWrapping = RepeatWrapping;\\n\\texports.ClampToEdgeWrapping = ClampToEdgeWrapping;\\n\\texports.MirroredRepeatWrapping = MirroredRepeatWrapping;\\n\\texports.NearestFilter = NearestFilter;\\n\\texports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;\\n\\texports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;\\n\\texports.LinearFilter = LinearFilter;\\n\\texports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;\\n\\texports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;\\n\\texports.UnsignedByteType = UnsignedByteType;\\n\\texports.ByteType = ByteType;\\n\\texports.ShortType = ShortType;\\n\\texports.UnsignedShortType = UnsignedShortType;\\n\\texports.IntType = IntType;\\n\\texports.UnsignedIntType = UnsignedIntType;\\n\\texports.FloatType = FloatType;\\n\\texports.HalfFloatType = HalfFloatType;\\n\\texports.UnsignedShort4444Type = UnsignedShort4444Type;\\n\\texports.UnsignedShort5551Type = UnsignedShort5551Type;\\n\\texports.UnsignedShort565Type = UnsignedShort565Type;\\n\\texports.UnsignedInt248Type = UnsignedInt248Type;\\n\\texports.AlphaFormat = AlphaFormat;\\n\\texports.RGBFormat = RGBFormat;\\n\\texports.RGBAFormat = RGBAFormat;\\n\\texports.LuminanceFormat = LuminanceFormat;\\n\\texports.LuminanceAlphaFormat = LuminanceAlphaFormat;\\n\\texports.RGBEFormat = RGBEFormat;\\n\\texports.DepthFormat = DepthFormat;\\n\\texports.DepthStencilFormat = DepthStencilFormat;\\n\\texports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;\\n\\texports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;\\n\\texports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;\\n\\texports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;\\n\\texports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;\\n\\texports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;\\n\\texports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;\\n\\texports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;\\n\\texports.RGB_ETC1_Format = RGB_ETC1_Format;\\n\\texports.LoopOnce = LoopOnce;\\n\\texports.LoopRepeat = LoopRepeat;\\n\\texports.LoopPingPong = LoopPingPong;\\n\\texports.InterpolateDiscrete = InterpolateDiscrete;\\n\\texports.InterpolateLinear = InterpolateLinear;\\n\\texports.InterpolateSmooth = InterpolateSmooth;\\n\\texports.ZeroCurvatureEnding = ZeroCurvatureEnding;\\n\\texports.ZeroSlopeEnding = ZeroSlopeEnding;\\n\\texports.WrapAroundEnding = WrapAroundEnding;\\n\\texports.TrianglesDrawMode = TrianglesDrawMode;\\n\\texports.TriangleStripDrawMode = TriangleStripDrawMode;\\n\\texports.TriangleFanDrawMode = TriangleFanDrawMode;\\n\\texports.LinearEncoding = LinearEncoding;\\n\\texports.sRGBEncoding = sRGBEncoding;\\n\\texports.GammaEncoding = GammaEncoding;\\n\\texports.RGBEEncoding = RGBEEncoding;\\n\\texports.LogLuvEncoding = LogLuvEncoding;\\n\\texports.RGBM7Encoding = RGBM7Encoding;\\n\\texports.RGBM16Encoding = RGBM16Encoding;\\n\\texports.RGBDEncoding = RGBDEncoding;\\n\\texports.BasicDepthPacking = BasicDepthPacking;\\n\\texports.RGBADepthPacking = RGBADepthPacking;\\n\\texports.CubeGeometry = BoxGeometry;\\n\\texports.Face4 = Face4;\\n\\texports.LineStrip = LineStrip;\\n\\texports.LinePieces = LinePieces;\\n\\texports.MeshFaceMaterial = MeshFaceMaterial;\\n\\texports.MultiMaterial = MultiMaterial;\\n\\texports.PointCloud = PointCloud;\\n\\texports.Particle = Particle;\\n\\texports.ParticleSystem = ParticleSystem;\\n\\texports.PointCloudMaterial = PointCloudMaterial;\\n\\texports.ParticleBasicMaterial = ParticleBasicMaterial;\\n\\texports.ParticleSystemMaterial = ParticleSystemMaterial;\\n\\texports.Vertex = Vertex;\\n\\texports.DynamicBufferAttribute = DynamicBufferAttribute;\\n\\texports.Int8Attribute = Int8Attribute;\\n\\texports.Uint8Attribute = Uint8Attribute;\\n\\texports.Uint8ClampedAttribute = Uint8ClampedAttribute;\\n\\texports.Int16Attribute = Int16Attribute;\\n\\texports.Uint16Attribute = Uint16Attribute;\\n\\texports.Int32Attribute = Int32Attribute;\\n\\texports.Uint32Attribute = Uint32Attribute;\\n\\texports.Float32Attribute = Float32Attribute;\\n\\texports.Float64Attribute = Float64Attribute;\\n\\texports.ClosedSplineCurve3 = ClosedSplineCurve3;\\n\\texports.SplineCurve3 = SplineCurve3;\\n\\texports.Spline = Spline;\\n\\texports.AxisHelper = AxisHelper;\\n\\texports.BoundingBoxHelper = BoundingBoxHelper;\\n\\texports.EdgesHelper = EdgesHelper;\\n\\texports.WireframeHelper = WireframeHelper;\\n\\texports.XHRLoader = XHRLoader;\\n\\texports.BinaryTextureLoader = BinaryTextureLoader;\\n\\texports.GeometryUtils = GeometryUtils;\\n\\texports.ImageUtils = ImageUtils;\\n\\texports.Projector = Projector;\\n\\texports.CanvasRenderer = CanvasRenderer;\\n\\n\\tObject.defineProperty(exports, '__esModule', { value: true });\\n\\n})));\\n\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi92ZW5kb3IvdGhyZWUuanM/ZTA2NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwrQ0FBK0MsbU1BQW1NLElBQUksR0FBRyw0QkFBNEIsY0FBYyw2REFBNkQsNkNBQTZDLE9BQU8sNkNBQTZDLGlMQUFpTCxpR0FBaUcsVUFBVSxPQUFPLDhDQUE4Qyx5SUFBeUksdURBQXVELFVBQVUsT0FBTyxxREFBcUQsMkxBQTJMLDRCQUE0QixpRkFBaUYsV0FBVyxTQUFTLEdBQUcsT0FBTywwQ0FBMEMsc0pBQXNKLCtDQUErQyw0REFBNEQsa0ZBQWtGLGFBQWEsMENBQTBDLGdDQUFnQywwQkFBMEIsYUFBYSw4Q0FBOEMsOERBQThELCtDQUErQyxrRkFBa0YsMERBQTBELG1CQUFtQixpQkFBaUIsZUFBZSxhQUFhLDBCQUEwQixZQUFZLFNBQVMsS0FBSyxPQUFPLHVHQUF1RyxpREFBaUQsdURBQXVELG9FQUFvRSwwQ0FBMEMsa0RBQWtELG1DQUFtQyxXQUFXLGdFQUFnRSwrQ0FBK0MsV0FBVyxTQUFTLHdEQUF3RCw0REFBNEQsMENBQTBDLGtHQUFrRyxTQUFTLDJEQUEyRCxzREFBc0QsMENBQTBDLDhDQUE4Qyw4Q0FBOEMsMERBQTBELGtDQUFrQywrQ0FBK0MsYUFBYSxXQUFXLFNBQVMsNENBQTRDLHNEQUFzRCwwQ0FBMEMsb0RBQW9ELDhDQUE4QyxnQ0FBZ0MsaURBQWlELDhDQUE4QyxPQUFPLFNBQVMsNkNBQTZDLGFBQWEsV0FBVyxTQUFTLE9BQU8sR0FBRywwQkFBMEIsaUJBQWlCLGdDQUFnQyx5QkFBeUIseUJBQXlCLDBCQUEwQiw4QkFBOEIsaUNBQWlDLGtDQUFrQywyQkFBMkIseUJBQXlCLDZCQUE2QixzQkFBc0IscUJBQXFCLHVCQUF1Qix3QkFBd0IsMEJBQTBCLHFCQUFxQix1QkFBdUIseUJBQXlCLHVCQUF1QiwyQkFBMkIsNkJBQTZCLGdDQUFnQyw2QkFBNkIsMkJBQTJCLDBCQUEwQiwrQkFBK0Isc0NBQXNDLDBCQUEwQiwwQkFB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QUE4Qiw4Q0FBOEMsa0NBQWtDLDBDQUEwQywwREFBMEQsMERBQTBELHdEQUF3RCxvREFBb0Qsc0NBQXNDLGtDQUFrQyxvQ0FBb0MsOENBQThDLHdEQUF3RCxvQ0FBb0Msc0NBQXNDLG9EQUFvRCx3REFBd0QsMERBQTBELDBEQUEwRCwwREFBMEQsOERBQThELDhEQUE4RCxnRUFBZ0UsZ0VBQWdFLDhDQUE4QyxnQ0FBZ0Msb0NBQW9DLHdDQUF3QyxzREFBc0Qsa0RBQWtELGtEQUFrRCxzREFBc0QsOENBQThDLGdEQUFnRCxrREFBa0QsMERBQTBELHNEQUFzRCw0Q0FBNEMsd0NBQXdDLDBDQUEwQyx3Q0FBd0MsNENBQTRDLDBDQUEwQyw0Q0FBNEMsd0NBQXdDLGtEQUFrRCxnREFBZ0QsdUNBQXVDLDBCQUEwQixrQ0FBa0Msb0NBQW9DLGdEQUFnRCwwQ0FBMEMsb0NBQW9DLGdDQUFnQyw0Q0FBNEMsb0RBQW9ELDBEQUEwRCw0REFBNEQsNEJBQTRCLDREQUE0RCwwQ0FBMEMsNENBQTRDLDBEQUEwRCw0Q0FBNEMsOENBQThDLDRDQUE0Qyw4Q0FBOEMsZ0RBQWdELGdEQUFnRCxvREFBb0Qsd0NBQXdDLDRCQUE0QixvQ0FBb0Msa0RBQWtELHNDQUFzQyw4Q0FBOEMsa0NBQWtDLHNEQUFzRCwwQ0FBMEMsb0NBQW9DLGtDQUFrQyw0Q0FBNEMsb0RBQW9ELGNBQWMsRUFBRSxLQUFLLElBQUkiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcXG5cXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcXG5cXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcXG5cXHQoZmFjdG9yeSgoZ2xvYmFsLlRIUkVFID0ge30pKSk7XFxufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xcblxcblxcdC8vIFBvbHlmaWxsc1xcblxcblxcdGlmICggTnVtYmVyLkVQU0lMT04gPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHROdW1iZXIuRVBTSUxPTiA9IE1hdGgucG93KCAyLCAtIDUyICk7XFxuXFxuXFx0fVxcblxcblxcdGlmICggTnVtYmVyLmlzSW50ZWdlciA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdC8vIE1pc3NpbmcgaW4gSUVcXG5cXHRcXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvaXNJbnRlZ2VyXFxuXFxuXFx0XFx0TnVtYmVyLmlzSW50ZWdlciA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoIHZhbHVlICkgJiYgTWF0aC5mbG9vciggdmFsdWUgKSA9PT0gdmFsdWU7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHR9XFxuXFxuXFx0Ly9cXG5cXG5cXHRpZiAoIE1hdGguc2lnbiA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvc2lnblxcblxcblxcdFxcdE1hdGguc2lnbiA9IGZ1bmN0aW9uICggeCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gKCB4IDwgMCApID8gLSAxIDogKCB4ID4gMCApID8gMSA6ICsgeDtcXG5cXG5cXHRcXHR9O1xcblxcblxcdH1cXG5cXG5cXHRpZiAoICduYW1lJyBpbiBGdW5jdGlvbi5wcm90b3R5cGUgPT09IGZhbHNlICkge1xcblxcblxcdFxcdC8vIE1pc3NpbmcgaW4gSUVcXG5cXHRcXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9uYW1lXFxuXFxuXFx0XFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBGdW5jdGlvbi5wcm90b3R5cGUsICduYW1lJywge1xcblxcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnRvU3RyaW5nKCkubWF0Y2goIC9eXFxcXHMqZnVuY3Rpb25cXFxccyooW15cXFxcKFxcXFxzXSopLyApWyAxIF07XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0gKTtcXG5cXG5cXHR9XFxuXFxuXFx0aWYgKCBPYmplY3QuYXNzaWduID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0Ly8gTWlzc2luZyBpbiBJRVxcblxcdFxcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ25cXG5cXG5cXHRcXHQoIGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRPYmplY3QuYXNzaWduID0gZnVuY3Rpb24gKCB0YXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG91dHB1dCA9IE9iamVjdCggdGFyZ2V0ICk7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgc291cmNlID0gYXJndW1lbnRzWyBpbmRleCBdO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggc291cmNlICE9PSB1bmRlZmluZWQgJiYgc291cmNlICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBuZXh0S2V5IGluIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCggc291cmNlLCBuZXh0S2V5ICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0b3V0cHV0WyBuZXh0S2V5IF0gPSBzb3VyY2VbIG5leHRLZXkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIG91dHB1dDtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0gKSgpO1xcblxcblxcdH1cXG5cXG5cXHQvKipcXG5cXHQgKiBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL2V2ZW50ZGlzcGF0Y2hlci5qcy9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBFdmVudERpc3BhdGNoZXIoKSB7fVxcblxcblxcdE9iamVjdC5hc3NpZ24oIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcXG5cXG5cXHRcXHRcXHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xcblxcblxcdFxcdFxcdGlmICggbGlzdGVuZXJzWyB0eXBlIF0gPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRsaXN0ZW5lcnNbIHR5cGUgXSA9IFtdO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgPT09IC0gMSApIHtcXG5cXG5cXHRcXHRcXHRcXHRsaXN0ZW5lcnNbIHR5cGUgXS5wdXNoKCBsaXN0ZW5lciApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGhhc0V2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybiBmYWxzZTtcXG5cXG5cXHRcXHRcXHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xcblxcblxcdFxcdFxcdHJldHVybiBsaXN0ZW5lcnNbIHR5cGUgXSAhPT0gdW5kZWZpbmVkICYmIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgIT09IC0gMTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHJldHVybjtcXG5cXG5cXHRcXHRcXHR2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xcblxcdFxcdFxcdHZhciBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzWyB0eXBlIF07XFxuXFxuXFx0XFx0XFx0aWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGluZGV4ID0gbGlzdGVuZXJBcnJheS5pbmRleE9mKCBsaXN0ZW5lciApO1xcblxcblxcdFxcdFxcdFxcdGlmICggaW5kZXggIT09IC0gMSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRsaXN0ZW5lckFycmF5LnNwbGljZSggaW5kZXgsIDEgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24gKCBldmVudCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xcblxcblxcdFxcdFxcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XFxuXFx0XFx0XFx0dmFyIGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIGV2ZW50LnR5cGUgXTtcXG5cXG5cXHRcXHRcXHRpZiAoIGxpc3RlbmVyQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRldmVudC50YXJnZXQgPSB0aGlzO1xcblxcblxcdFxcdFxcdFxcdHZhciBhcnJheSA9IGxpc3RlbmVyQXJyYXkuc2xpY2UoIDAgKTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGFycmF5WyBpIF0uY2FsbCggdGhpcywgZXZlbnQgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0dmFyIFJFVklTSU9OID0gJzg5JztcXG5cXHR2YXIgTU9VU0UgPSB7IExFRlQ6IDAsIE1JRERMRTogMSwgUklHSFQ6IDIgfTtcXG5cXHR2YXIgQ3VsbEZhY2VOb25lID0gMDtcXG5cXHR2YXIgQ3VsbEZhY2VCYWNrID0gMTtcXG5cXHR2YXIgQ3VsbEZhY2VGcm9udCA9IDI7XFxuXFx0dmFyIEN1bGxGYWNlRnJvbnRCYWNrID0gMztcXG5cXHR2YXIgRnJvbnRGYWNlRGlyZWN0aW9uQ1cgPSAwO1xcblxcdHZhciBGcm9udEZhY2VEaXJlY3Rpb25DQ1cgPSAxO1xcblxcdHZhciBCYXNpY1NoYWRvd01hcCA9IDA7XFxuXFx0dmFyIFBDRlNoYWRvd01hcCA9IDE7XFxuXFx0dmFyIFBDRlNvZnRTaGFkb3dNYXAgPSAyO1xcblxcdHZhciBGcm9udFNpZGUgPSAwO1xcblxcdHZhciBCYWNrU2lkZSA9IDE7XFxuXFx0dmFyIERvdWJsZVNpZGUgPSAyO1xcblxcdHZhciBGbGF0U2hhZGluZyA9IDE7XFxuXFx0dmFyIFNtb290aFNoYWRpbmcgPSAyO1xcblxcdHZhciBOb0NvbG9ycyA9IDA7XFxuXFx0dmFyIEZhY2VDb2xvcnMgPSAxO1xcblxcdHZhciBWZXJ0ZXhDb2xvcnMgPSAyO1xcblxcdHZhciBOb0JsZW5kaW5nID0gMDtcXG5cXHR2YXIgTm9ybWFsQmxlbmRpbmcgPSAxO1xcblxcdHZhciBBZGRpdGl2ZUJsZW5kaW5nID0gMjtcXG5cXHR2YXIgU3VidHJhY3RpdmVCbGVuZGluZyA9IDM7XFxuXFx0dmFyIE11bHRpcGx5QmxlbmRpbmcgPSA0O1xcblxcdHZhciBDdXN0b21CbGVuZGluZyA9IDU7XFxuXFx0dmFyIEFkZEVxdWF0aW9uID0gMTAwO1xcblxcdHZhciBTdWJ0cmFjdEVxdWF0aW9uID0gMTAxO1xcblxcdHZhciBSZXZlcnNlU3VidHJhY3RFcXVhdGlvbiA9IDEwMjtcXG5cXHR2YXIgTWluRXF1YXRpb24gPSAxMDM7XFxuXFx0dmFyIE1heEVxdWF0aW9uID0gMTA0O1xcblxcdHZhciBaZXJvRmFjdG9yID0gMjAwO1xcblxcdHZhciBPbmVGYWN0b3IgPSAyMDE7XFxuXFx0dmFyIFNyY0NvbG9yRmFjdG9yID0gMjAyO1xcblxcdHZhciBPbmVNaW51c1NyY0NvbG9yRmFjdG9yID0gMjAzO1xcblxcdHZhciBTcmNBbHBoYUZhY3RvciA9IDIwNDtcXG5cXHR2YXIgT25lTWludXNTcmNBbHBoYUZhY3RvciA9IDIwNTtcXG5cXHR2YXIgRHN0QWxwaGFGYWN0b3IgPSAyMDY7XFxuXFx0dmFyIE9uZU1pbnVzRHN0QWxwaGFGYWN0b3IgPSAyMDc7XFxuXFx0dmFyIERzdENvbG9yRmFjdG9yID0gMjA4O1xcblxcdHZhciBPbmVNaW51c0RzdENvbG9yRmFjdG9yID0gMjA5O1xcblxcdHZhciBTcmNBbHBoYVNhdHVyYXRlRmFjdG9yID0gMjEwO1xcblxcdHZhciBOZXZlckRlcHRoID0gMDtcXG5cXHR2YXIgQWx3YXlzRGVwdGggPSAxO1xcblxcdHZhciBMZXNzRGVwdGggPSAyO1xcblxcdHZhciBMZXNzRXF1YWxEZXB0aCA9IDM7XFxuXFx0dmFyIEVxdWFsRGVwdGggPSA0O1xcblxcdHZhciBHcmVhdGVyRXF1YWxEZXB0aCA9IDU7XFxuXFx0dmFyIEdyZWF0ZXJEZXB0aCA9IDY7XFxuXFx0dmFyIE5vdEVxdWFsRGVwdGggPSA3O1xcblxcdHZhciBNdWx0aXBseU9wZXJhdGlvbiA9IDA7XFxuXFx0dmFyIE1peE9wZXJhdGlvbiA9IDE7XFxuXFx0dmFyIEFkZE9wZXJhdGlvbiA9IDI7XFxuXFx0dmFyIE5vVG9uZU1hcHBpbmcgPSAwO1xcblxcdHZhciBMaW5lYXJUb25lTWFwcGluZyA9IDE7XFxuXFx0dmFyIFJlaW5oYXJkVG9uZU1hcHBpbmcgPSAyO1xcblxcdHZhciBVbmNoYXJ0ZWQyVG9uZU1hcHBpbmcgPSAzO1xcblxcdHZhciBDaW5lb25Ub25lTWFwcGluZyA9IDQ7XFxuXFx0dmFyIFVWTWFwcGluZyA9IDMwMDtcXG5cXHR2YXIgQ3ViZVJlZmxlY3Rpb25NYXBwaW5nID0gMzAxO1xcblxcdHZhciBDdWJlUmVmcmFjdGlvbk1hcHBpbmcgPSAzMDI7XFxuXFx0dmFyIEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nID0gMzAzO1xcblxcdHZhciBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyA9IDMwNDtcXG5cXHR2YXIgU3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDU7XFxuXFx0dmFyIEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nID0gMzA2O1xcblxcdHZhciBDdWJlVVZSZWZyYWN0aW9uTWFwcGluZyA9IDMwNztcXG5cXHR2YXIgUmVwZWF0V3JhcHBpbmcgPSAxMDAwO1xcblxcdHZhciBDbGFtcFRvRWRnZVdyYXBwaW5nID0gMTAwMTtcXG5cXHR2YXIgTWlycm9yZWRSZXBlYXRXcmFwcGluZyA9IDEwMDI7XFxuXFx0dmFyIE5lYXJlc3RGaWx0ZXIgPSAxMDAzO1xcblxcdHZhciBOZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciA9IDEwMDQ7XFxuXFx0dmFyIE5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA1O1xcblxcdHZhciBMaW5lYXJGaWx0ZXIgPSAxMDA2O1xcblxcdHZhciBMaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyID0gMTAwNztcXG5cXHR2YXIgTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyID0gMTAwODtcXG5cXHR2YXIgVW5zaWduZWRCeXRlVHlwZSA9IDEwMDk7XFxuXFx0dmFyIEJ5dGVUeXBlID0gMTAxMDtcXG5cXHR2YXIgU2hvcnRUeXBlID0gMTAxMTtcXG5cXHR2YXIgVW5zaWduZWRTaG9ydFR5cGUgPSAxMDEyO1xcblxcdHZhciBJbnRUeXBlID0gMTAxMztcXG5cXHR2YXIgVW5zaWduZWRJbnRUeXBlID0gMTAxNDtcXG5cXHR2YXIgRmxvYXRUeXBlID0gMTAxNTtcXG5cXHR2YXIgSGFsZkZsb2F0VHlwZSA9IDEwMTY7XFxuXFx0dmFyIFVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSA9IDEwMTc7XFxuXFx0dmFyIFVuc2lnbmVkU2hvcnQ1NTUxVHlwZSA9IDEwMTg7XFxuXFx0dmFyIFVuc2lnbmVkU2hvcnQ1NjVUeXBlID0gMTAxOTtcXG5cXHR2YXIgVW5zaWduZWRJbnQyNDhUeXBlID0gMTAyMDtcXG5cXHR2YXIgQWxwaGFGb3JtYXQgPSAxMDIxO1xcblxcdHZhciBSR0JGb3JtYXQgPSAxMDIyO1xcblxcdHZhciBSR0JBRm9ybWF0ID0gMTAyMztcXG5cXHR2YXIgTHVtaW5hbmNlRm9ybWF0ID0gMTAyNDtcXG5cXHR2YXIgTHVtaW5hbmNlQWxwaGFGb3JtYXQgPSAxMDI1O1xcblxcdHZhciBSR0JFRm9ybWF0ID0gUkdCQUZvcm1hdDtcXG5cXHR2YXIgRGVwdGhGb3JtYXQgPSAxMDI2O1xcblxcdHZhciBEZXB0aFN0ZW5jaWxGb3JtYXQgPSAxMDI3O1xcblxcdHZhciBSR0JfUzNUQ19EWFQxX0Zvcm1hdCA9IDIwMDE7XFxuXFx0dmFyIFJHQkFfUzNUQ19EWFQxX0Zvcm1hdCA9IDIwMDI7XFxuXFx0dmFyIFJHQkFfUzNUQ19EWFQzX0Zvcm1hdCA9IDIwMDM7XFxuXFx0dmFyIFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCA9IDIwMDQ7XFxuXFx0dmFyIFJHQl9QVlJUQ180QlBQVjFfRm9ybWF0ID0gMjEwMDtcXG5cXHR2YXIgUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSAyMTAxO1xcblxcdHZhciBSR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQgPSAyMTAyO1xcblxcdHZhciBSR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSAyMTAzO1xcblxcdHZhciBSR0JfRVRDMV9Gb3JtYXQgPSAyMTUxO1xcblxcdHZhciBMb29wT25jZSA9IDIyMDA7XFxuXFx0dmFyIExvb3BSZXBlYXQgPSAyMjAxO1xcblxcdHZhciBMb29wUGluZ1BvbmcgPSAyMjAyO1xcblxcdHZhciBJbnRlcnBvbGF0ZURpc2NyZXRlID0gMjMwMDtcXG5cXHR2YXIgSW50ZXJwb2xhdGVMaW5lYXIgPSAyMzAxO1xcblxcdHZhciBJbnRlcnBvbGF0ZVNtb290aCA9IDIzMDI7XFxuXFx0dmFyIFplcm9DdXJ2YXR1cmVFbmRpbmcgPSAyNDAwO1xcblxcdHZhciBaZXJvU2xvcGVFbmRpbmcgPSAyNDAxO1xcblxcdHZhciBXcmFwQXJvdW5kRW5kaW5nID0gMjQwMjtcXG5cXHR2YXIgVHJpYW5nbGVzRHJhd01vZGUgPSAwO1xcblxcdHZhciBUcmlhbmdsZVN0cmlwRHJhd01vZGUgPSAxO1xcblxcdHZhciBUcmlhbmdsZUZhbkRyYXdNb2RlID0gMjtcXG5cXHR2YXIgTGluZWFyRW5jb2RpbmcgPSAzMDAwO1xcblxcdHZhciBzUkdCRW5jb2RpbmcgPSAzMDAxO1xcblxcdHZhciBHYW1tYUVuY29kaW5nID0gMzAwNztcXG5cXHR2YXIgUkdCRUVuY29kaW5nID0gMzAwMjtcXG5cXHR2YXIgTG9nTHV2RW5jb2RpbmcgPSAzMDAzO1xcblxcdHZhciBSR0JNN0VuY29kaW5nID0gMzAwNDtcXG5cXHR2YXIgUkdCTTE2RW5jb2RpbmcgPSAzMDA1O1xcblxcdHZhciBSR0JERW5jb2RpbmcgPSAzMDA2O1xcblxcdHZhciBCYXNpY0RlcHRoUGFja2luZyA9IDMyMDA7XFxuXFx0dmFyIFJHQkFEZXB0aFBhY2tpbmcgPSAzMjAxO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHR2YXIgX01hdGggPSB7XFxuXFxuXFx0XFx0REVHMlJBRDogTWF0aC5QSSAvIDE4MCxcXG5cXHRcXHRSQUQyREVHOiAxODAgLyBNYXRoLlBJLFxcblxcblxcdFxcdGdlbmVyYXRlVVVJRDogKCBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDUwMzQvaG93LXRvLWNyZWF0ZS1hLWd1aWQtdXVpZC1pbi1qYXZhc2NyaXB0LzIxOTYzMTM2IzIxOTYzMTM2XFxuXFxuXFx0XFx0XFx0dmFyIGx1dCA9IFtdO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IDI1NjsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRsdXRbIGkgXSA9ICggaSA8IDE2ID8gJzAnIDogJycgKSArICggaSApLnRvU3RyaW5nKCAxNiApLnRvVXBwZXJDYXNlKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGQwID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xcblxcdFxcdFxcdFxcdHZhciBkMSA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcXG5cXHRcXHRcXHRcXHR2YXIgZDIgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XFxuXFx0XFx0XFx0XFx0dmFyIGQzID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xcblxcdFxcdFxcdFxcdHJldHVybiBsdXRbIGQwICYgMHhmZiBdICsgbHV0WyBkMCA+PiA4ICYgMHhmZiBdICsgbHV0WyBkMCA+PiAxNiAmIDB4ZmYgXSArIGx1dFsgZDAgPj4gMjQgJiAweGZmIF0gKyAnLScgK1xcblxcdFxcdFxcdFxcdFxcdGx1dFsgZDEgJiAweGZmIF0gKyBsdXRbIGQxID4+IDggJiAweGZmIF0gKyAnLScgKyBsdXRbIGQxID4+IDE2ICYgMHgwZiB8IDB4NDAgXSArIGx1dFsgZDEgPj4gMjQgJiAweGZmIF0gKyAnLScgK1xcblxcdFxcdFxcdFxcdFxcdGx1dFsgZDIgJiAweDNmIHwgMHg4MCBdICsgbHV0WyBkMiA+PiA4ICYgMHhmZiBdICsgJy0nICsgbHV0WyBkMiA+PiAxNiAmIDB4ZmYgXSArIGx1dFsgZDIgPj4gMjQgJiAweGZmIF0gK1xcblxcdFxcdFxcdFxcdFxcdGx1dFsgZDMgJiAweGZmIF0gKyBsdXRbIGQzID4+IDggJiAweGZmIF0gKyBsdXRbIGQzID4+IDE2ICYgMHhmZiBdICsgbHV0WyBkMyA+PiAyNCAmIDB4ZmYgXTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0gKSgpLFxcblxcblxcdFxcdGNsYW1wOiBmdW5jdGlvbiAoIHZhbHVlLCBtaW4sIG1heCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gTWF0aC5tYXgoIG1pbiwgTWF0aC5taW4oIG1heCwgdmFsdWUgKSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gY29tcHV0ZSBldWNsaWRpYW4gbW9kdWxvIG9mIG0gJSBuXFxuXFx0XFx0Ly8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTW9kdWxvX29wZXJhdGlvblxcblxcblxcdFxcdGV1Y2xpZGVhbk1vZHVsbzogZnVuY3Rpb24gKCBuLCBtICkge1xcblxcblxcdFxcdFxcdHJldHVybiAoICggbiAlIG0gKSArIG0gKSAlIG07XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBMaW5lYXIgbWFwcGluZyBmcm9tIHJhbmdlIDxhMSwgYTI+IHRvIHJhbmdlIDxiMSwgYjI+XFxuXFxuXFx0XFx0bWFwTGluZWFyOiBmdW5jdGlvbiAoIHgsIGExLCBhMiwgYjEsIGIyICkge1xcblxcblxcdFxcdFxcdHJldHVybiBiMSArICggeCAtIGExICkgKiAoIGIyIC0gYjEgKSAvICggYTIgLSBhMSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZWFyX2ludGVycG9sYXRpb25cXG5cXG5cXHRcXHRsZXJwOiBmdW5jdGlvbiAoIHgsIHksIHQgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuICggMSAtIHQgKSAqIHggKyB0ICogeTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU21vb3Roc3RlcFxcblxcblxcdFxcdHNtb290aHN0ZXA6IGZ1bmN0aW9uICggeCwgbWluLCBtYXggKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB4IDw9IG1pbiApIHJldHVybiAwO1xcblxcdFxcdFxcdGlmICggeCA+PSBtYXggKSByZXR1cm4gMTtcXG5cXG5cXHRcXHRcXHR4ID0gKCB4IC0gbWluICkgLyAoIG1heCAtIG1pbiApO1xcblxcblxcdFxcdFxcdHJldHVybiB4ICogeCAqICggMyAtIDIgKiB4ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzbW9vdGhlcnN0ZXA6IGZ1bmN0aW9uICggeCwgbWluLCBtYXggKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB4IDw9IG1pbiApIHJldHVybiAwO1xcblxcdFxcdFxcdGlmICggeCA+PSBtYXggKSByZXR1cm4gMTtcXG5cXG5cXHRcXHRcXHR4ID0gKCB4IC0gbWluICkgLyAoIG1heCAtIG1pbiApO1xcblxcblxcdFxcdFxcdHJldHVybiB4ICogeCAqIHggKiAoIHggKiAoIHggKiA2IC0gMTUgKSArIDEwICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBSYW5kb20gaW50ZWdlciBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXFxuXFxuXFx0XFx0cmFuZEludDogZnVuY3Rpb24gKCBsb3csIGhpZ2ggKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGxvdyArIE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKyAxICkgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIFJhbmRvbSBmbG9hdCBmcm9tIDxsb3csIGhpZ2g+IGludGVydmFsXFxuXFxuXFx0XFx0cmFuZEZsb2F0OiBmdW5jdGlvbiAoIGxvdywgaGlnaCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbG93ICsgTWF0aC5yYW5kb20oKSAqICggaGlnaCAtIGxvdyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gUmFuZG9tIGZsb2F0IGZyb20gPC1yYW5nZS8yLCByYW5nZS8yPiBpbnRlcnZhbFxcblxcblxcdFxcdHJhbmRGbG9hdFNwcmVhZDogZnVuY3Rpb24gKCByYW5nZSApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gcmFuZ2UgKiAoIDAuNSAtIE1hdGgucmFuZG9tKCkgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGRlZ1RvUmFkOiBmdW5jdGlvbiAoIGRlZ3JlZXMgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGRlZ3JlZXMgKiBfTWF0aC5ERUcyUkFEO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cmFkVG9EZWc6IGZ1bmN0aW9uICggcmFkaWFucyApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gcmFkaWFucyAqIF9NYXRoLlJBRDJERUc7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRpc1Bvd2VyT2ZUd286IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuICggdmFsdWUgJiAoIHZhbHVlIC0gMSApICkgPT09IDAgJiYgdmFsdWUgIT09IDA7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjZWlsUG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gTWF0aC5wb3coIDIsIE1hdGguY2VpbCggTWF0aC5sb2coIHZhbHVlICkgLyBNYXRoLkxOMiApICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRmbG9vclBvd2VyT2ZUd286IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIE1hdGgucG93KCAyLCBNYXRoLmZsb29yKCBNYXRoLmxvZyggdmFsdWUgKSAvIE1hdGguTE4yICkgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXFxuXFx0ICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cXG5cXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gVmVjdG9yMiggeCwgeSApIHtcXG5cXG5cXHRcXHR0aGlzLnggPSB4IHx8IDA7XFxuXFx0XFx0dGhpcy55ID0geSB8fCAwO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggVmVjdG9yMi5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRcXFwid2lkdGhcXFwiOiB7XFxuXFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMueDtcXG5cXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnggPSB2YWx1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRcXFwiaGVpZ2h0XFxcIjoge1xcblxcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnk7XFxuXFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy55ID0gdmFsdWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggVmVjdG9yMi5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRpc1ZlY3RvcjI6IHRydWUsXFxuXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiAoIHgsIHkgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0geDtcXG5cXHRcXHRcXHR0aGlzLnkgPSB5O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSBzY2FsYXI7XFxuXFx0XFx0XFx0dGhpcy55ID0gc2NhbGFyO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0WDogZnVuY3Rpb24gKCB4ICkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9IHg7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRZOiBmdW5jdGlvbiAoIHkgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy55ID0geTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0c3dpdGNoICggaW5kZXggKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XFxuXFx0XFx0XFx0XFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXggKSB7XFxuXFxuXFx0XFx0XFx0c3dpdGNoICggaW5kZXggKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y2FzZSAwOiByZXR1cm4gdGhpcy54O1xcblxcdFxcdFxcdFxcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcXG5cXHRcXHRcXHRcXHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCB2ICkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9IHYueDtcXG5cXHRcXHRcXHR0aGlzLnkgPSB2Lnk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRhZGQ6IGZ1bmN0aW9uICggdiwgdyApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IyOiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy54ICs9IHYueDtcXG5cXHRcXHRcXHR0aGlzLnkgKz0gdi55O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ICs9IHM7XFxuXFx0XFx0XFx0dGhpcy55ICs9IHM7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRhZGRWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gYS54ICsgYi54O1xcblxcdFxcdFxcdHRoaXMueSA9IGEueSArIGIueTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGFkZFNjYWxlZFZlY3RvcjogZnVuY3Rpb24gKCB2LCBzICkge1xcblxcblxcdFxcdFxcdHRoaXMueCArPSB2LnggKiBzO1xcblxcdFxcdFxcdHRoaXMueSArPSB2LnkgKiBzO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMjogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMueCAtPSB2Lng7XFxuXFx0XFx0XFx0dGhpcy55IC09IHYueTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHN1YlNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xcblxcblxcdFxcdFxcdHRoaXMueCAtPSBzO1xcblxcdFxcdFxcdHRoaXMueSAtPSBzO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9IGEueCAtIGIueDtcXG5cXHRcXHRcXHR0aGlzLnkgPSBhLnkgLSBiLnk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRtdWx0aXBseTogZnVuY3Rpb24gKCB2ICkge1xcblxcblxcdFxcdFxcdHRoaXMueCAqPSB2Lng7XFxuXFx0XFx0XFx0dGhpcy55ICo9IHYueTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggKj0gc2NhbGFyO1xcblxcdFxcdFxcdHRoaXMueSAqPSBzY2FsYXI7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkaXZpZGU6IGZ1bmN0aW9uICggdiApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggLz0gdi54O1xcblxcdFxcdFxcdHRoaXMueSAvPSB2Lnk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gc2NhbGFyICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRhcHBseU1hdHJpeDM6IGZ1bmN0aW9uICggbSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueTtcXG5cXHRcXHRcXHR2YXIgZSA9IG0uZWxlbWVudHM7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gZVsgMCBdICogeCArIGVbIDMgXSAqIHkgKyBlWyA2IF07XFxuXFx0XFx0XFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA3IF07XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRtaW46IGZ1bmN0aW9uICggdiApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSBNYXRoLm1pbiggdGhpcy54LCB2LnggKTtcXG5cXHRcXHRcXHR0aGlzLnkgPSBNYXRoLm1pbiggdGhpcy55LCB2LnkgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG1heDogZnVuY3Rpb24gKCB2ICkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9IE1hdGgubWF4KCB0aGlzLngsIHYueCApO1xcblxcdFxcdFxcdHRoaXMueSA9IE1hdGgubWF4KCB0aGlzLnksIHYueSApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XFxuXFxuXFx0XFx0XFx0Ly8gYXNzdW1lcyBtaW4gPCBtYXgsIGNvbXBvbmVudHdpc2VcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSBNYXRoLm1heCggbWluLngsIE1hdGgubWluKCBtYXgueCwgdGhpcy54ICkgKTtcXG5cXHRcXHRcXHR0aGlzLnkgPSBNYXRoLm1heCggbWluLnksIE1hdGgubWluKCBtYXgueSwgdGhpcy55ICkgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsYW1wU2NhbGFyOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIG1pbiA9IG5ldyBWZWN0b3IyKCk7XFxuXFx0XFx0XFx0dmFyIG1heCA9IG5ldyBWZWN0b3IyKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGNsYW1wU2NhbGFyKCBtaW5WYWwsIG1heFZhbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRtaW4uc2V0KCBtaW5WYWwsIG1pblZhbCApO1xcblxcdFxcdFxcdFxcdG1heC5zZXQoIG1heFZhbCwgbWF4VmFsICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuY2xhbXAoIG1pbiwgbWF4ICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0Y2xhbXBMZW5ndGg6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCBsZW5ndGggfHwgMSApLm11bHRpcGx5U2NhbGFyKCBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCBsZW5ndGggKSApICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRmbG9vcjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xcblxcdFxcdFxcdHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2VpbDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XFxuXFx0XFx0XFx0dGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHJvdW5kOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XFxuXFx0XFx0XFx0dGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyb3VuZFRvWmVybzogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9ICggdGhpcy54IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnggKSA6IE1hdGguZmxvb3IoIHRoaXMueCApO1xcblxcdFxcdFxcdHRoaXMueSA9ICggdGhpcy55IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnkgKSA6IE1hdGguZmxvb3IoIHRoaXMueSApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gLSB0aGlzLng7XFxuXFx0XFx0XFx0dGhpcy55ID0gLSB0aGlzLnk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bGVuZ3RoOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRtYW5oYXR0YW5MZW5ndGg6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpIHx8IDEgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGFuZ2xlOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Ly8gY29tcHV0ZXMgdGhlIGFuZ2xlIGluIHJhZGlhbnMgd2l0aCByZXNwZWN0IHRvIHRoZSBwb3NpdGl2ZSB4LWF4aXNcXG5cXG5cXHRcXHRcXHR2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKCB0aGlzLnksIHRoaXMueCApO1xcblxcblxcdFxcdFxcdGlmICggYW5nbGUgPCAwICkgYW5nbGUgKz0gMiAqIE1hdGguUEk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGFuZ2xlO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGlzdGFuY2VUbzogZnVuY3Rpb24gKCB2ICkge1xcblxcblxcdFxcdFxcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VUb1NxdWFyZWQoIHYgKSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGlzdGFuY2VUb1NxdWFyZWQ6IGZ1bmN0aW9uICggdiApIHtcXG5cXG5cXHRcXHRcXHR2YXIgZHggPSB0aGlzLnggLSB2LngsIGR5ID0gdGhpcy55IC0gdi55O1xcblxcdFxcdFxcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG1hbmhhdHRhbkRpc3RhbmNlVG86IGZ1bmN0aW9uICggdiApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCAtIHYueCApICsgTWF0aC5hYnMoIHRoaXMueSAtIHYueSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0TGVuZ3RoOiBmdW5jdGlvbiAoIGxlbmd0aCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggbGVuZ3RoICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRsZXJwOiBmdW5jdGlvbiAoIHYsIGFscGhhICkge1xcblxcblxcdFxcdFxcdHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XFxuXFx0XFx0XFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGxlcnBWZWN0b3JzOiBmdW5jdGlvbiAoIHYxLCB2MiwgYWxwaGEgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdjIsIHYxICkubXVsdGlwbHlTY2FsYXIoIGFscGhhICkuYWRkKCB2MSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xcblxcdFxcdFxcdHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcXG5cXHRcXHRcXHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcXG5cXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gYXJyYXk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRmcm9tQnVmZmVyQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIG9mZnNldCAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjI6IG9mZnNldCBoYXMgYmVlbiByZW1vdmVkIGZyb20gLmZyb21CdWZmZXJBdHRyaWJ1dGUoKS4nICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMueCA9IGF0dHJpYnV0ZS5nZXRYKCBpbmRleCApO1xcblxcdFxcdFxcdHRoaXMueSA9IGF0dHJpYnV0ZS5nZXRZKCBpbmRleCApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cm90YXRlQXJvdW5kOiBmdW5jdGlvbiAoIGNlbnRlciwgYW5nbGUgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGMgPSBNYXRoLmNvcyggYW5nbGUgKSwgcyA9IE1hdGguc2luKCBhbmdsZSApO1xcblxcblxcdFxcdFxcdHZhciB4ID0gdGhpcy54IC0gY2VudGVyLng7XFxuXFx0XFx0XFx0dmFyIHkgPSB0aGlzLnkgLSBjZW50ZXIueTtcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSB4ICogYyAtIHkgKiBzICsgY2VudGVyLng7XFxuXFx0XFx0XFx0dGhpcy55ID0geCAqIHMgKyB5ICogYyArIGNlbnRlci55O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xcblxcdCAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXFxuXFx0ICogQGF1dGhvciBqb3JkaV9yb3MgLyBodHRwOi8vcGxhdHRzb2Z0LmNvbVxcblxcdCAqIEBhdXRob3IgRDFwbG8xZCAvIGh0dHA6Ly9naXRodWIuY29tL0QxcGxvMWRcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXFxuXFx0ICogQGF1dGhvciB0aW1rbmlwIC8gaHR0cDovL3d3dy5mbG9vcnBsYW5uZXIuY29tL1xcblxcdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cXG5cXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBNYXRyaXg0KCkge1xcblxcblxcdFxcdHRoaXMuZWxlbWVudHMgPSBbXFxuXFxuXFx0XFx0XFx0MSwgMCwgMCwgMCxcXG5cXHRcXHRcXHQwLCAxLCAwLCAwLFxcblxcdFxcdFxcdDAsIDAsIDEsIDAsXFxuXFx0XFx0XFx0MCwgMCwgMCwgMVxcblxcblxcdFxcdF07XFxuXFxuXFx0XFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMCApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogdGhlIGNvbnN0cnVjdG9yIG5vIGxvbmdlciByZWFkcyBhcmd1bWVudHMuIHVzZSAuc2V0KCkgaW5zdGVhZC4nICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBNYXRyaXg0LnByb3RvdHlwZSwge1xcblxcblxcdFxcdGlzTWF0cml4NDogdHJ1ZSxcXG5cXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uICggbjExLCBuMTIsIG4xMywgbjE0LCBuMjEsIG4yMiwgbjIzLCBuMjQsIG4zMSwgbjMyLCBuMzMsIG4zNCwgbjQxLCBuNDIsIG40MywgbjQ0ICkge1xcblxcblxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XFxuXFxuXFx0XFx0XFx0dGVbIDAgXSA9IG4xMTsgdGVbIDQgXSA9IG4xMjsgdGVbIDggXSA9IG4xMzsgdGVbIDEyIF0gPSBuMTQ7XFxuXFx0XFx0XFx0dGVbIDEgXSA9IG4yMTsgdGVbIDUgXSA9IG4yMjsgdGVbIDkgXSA9IG4yMzsgdGVbIDEzIF0gPSBuMjQ7XFxuXFx0XFx0XFx0dGVbIDIgXSA9IG4zMTsgdGVbIDYgXSA9IG4zMjsgdGVbIDEwIF0gPSBuMzM7IHRlWyAxNCBdID0gbjM0O1xcblxcdFxcdFxcdHRlWyAzIF0gPSBuNDE7IHRlWyA3IF0gPSBuNDI7IHRlWyAxMSBdID0gbjQzOyB0ZVsgMTUgXSA9IG40NDtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGlkZW50aXR5OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5zZXQoXFxuXFxuXFx0XFx0XFx0XFx0MSwgMCwgMCwgMCxcXG5cXHRcXHRcXHRcXHQwLCAxLCAwLCAwLFxcblxcdFxcdFxcdFxcdDAsIDAsIDEsIDAsXFxuXFx0XFx0XFx0XFx0MCwgMCwgMCwgMVxcblxcblxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBuZXcgTWF0cml4NCgpLmZyb21BcnJheSggdGhpcy5lbGVtZW50cyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBtICkge1xcblxcblxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XFxuXFx0XFx0XFx0dmFyIG1lID0gbS5lbGVtZW50cztcXG5cXG5cXHRcXHRcXHR0ZVsgMCBdID0gbWVbIDAgXTsgdGVbIDEgXSA9IG1lWyAxIF07IHRlWyAyIF0gPSBtZVsgMiBdOyB0ZVsgMyBdID0gbWVbIDMgXTtcXG5cXHRcXHRcXHR0ZVsgNCBdID0gbWVbIDQgXTsgdGVbIDUgXSA9IG1lWyA1IF07IHRlWyA2IF0gPSBtZVsgNiBdOyB0ZVsgNyBdID0gbWVbIDcgXTtcXG5cXHRcXHRcXHR0ZVsgOCBdID0gbWVbIDggXTsgdGVbIDkgXSA9IG1lWyA5IF07IHRlWyAxMCBdID0gbWVbIDEwIF07IHRlWyAxMSBdID0gbWVbIDExIF07XFxuXFx0XFx0XFx0dGVbIDEyIF0gPSBtZVsgMTIgXTsgdGVbIDEzIF0gPSBtZVsgMTMgXTsgdGVbIDE0IF0gPSBtZVsgMTQgXTsgdGVbIDE1IF0gPSBtZVsgMTUgXTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHlQb3NpdGlvbjogZnVuY3Rpb24gKCBtICkge1xcblxcblxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHMsIG1lID0gbS5lbGVtZW50cztcXG5cXG5cXHRcXHRcXHR0ZVsgMTIgXSA9IG1lWyAxMiBdO1xcblxcdFxcdFxcdHRlWyAxMyBdID0gbWVbIDEzIF07XFxuXFx0XFx0XFx0dGVbIDE0IF0gPSBtZVsgMTQgXTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGV4dHJhY3RCYXNpczogZnVuY3Rpb24gKCB4QXhpcywgeUF4aXMsIHpBeGlzICkge1xcblxcblxcdFxcdFxcdHhBeGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIHRoaXMsIDAgKTtcXG5cXHRcXHRcXHR5QXhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCB0aGlzLCAxICk7XFxuXFx0XFx0XFx0ekF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbiggdGhpcywgMiApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bWFrZUJhc2lzOiBmdW5jdGlvbiAoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5zZXQoXFxuXFx0XFx0XFx0XFx0eEF4aXMueCwgeUF4aXMueCwgekF4aXMueCwgMCxcXG5cXHRcXHRcXHRcXHR4QXhpcy55LCB5QXhpcy55LCB6QXhpcy55LCAwLFxcblxcdFxcdFxcdFxcdHhBeGlzLnosIHlBeGlzLnosIHpBeGlzLnosIDAsXFxuXFx0XFx0XFx0XFx0MCwgMCwgMCwgMVxcblxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRleHRyYWN0Um90YXRpb246IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBleHRyYWN0Um90YXRpb24oIG0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcXG5cXHRcXHRcXHRcXHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xcblxcblxcdFxcdFxcdFxcdHZhciBzY2FsZVggPSAxIC8gdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMCApLmxlbmd0aCgpO1xcblxcdFxcdFxcdFxcdHZhciBzY2FsZVkgPSAxIC8gdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMSApLmxlbmd0aCgpO1xcblxcdFxcdFxcdFxcdHZhciBzY2FsZVogPSAxIC8gdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggbSwgMiApLmxlbmd0aCgpO1xcblxcblxcdFxcdFxcdFxcdHRlWyAwIF0gPSBtZVsgMCBdICogc2NhbGVYO1xcblxcdFxcdFxcdFxcdHRlWyAxIF0gPSBtZVsgMSBdICogc2NhbGVYO1xcblxcdFxcdFxcdFxcdHRlWyAyIF0gPSBtZVsgMiBdICogc2NhbGVYO1xcblxcblxcdFxcdFxcdFxcdHRlWyA0IF0gPSBtZVsgNCBdICogc2NhbGVZO1xcblxcdFxcdFxcdFxcdHRlWyA1IF0gPSBtZVsgNSBdICogc2NhbGVZO1xcblxcdFxcdFxcdFxcdHRlWyA2IF0gPSBtZVsgNiBdICogc2NhbGVZO1xcblxcblxcdFxcdFxcdFxcdHRlWyA4IF0gPSBtZVsgOCBdICogc2NhbGVaO1xcblxcdFxcdFxcdFxcdHRlWyA5IF0gPSBtZVsgOSBdICogc2NhbGVaO1xcblxcdFxcdFxcdFxcdHRlWyAxMCBdID0gbWVbIDEwIF0gKiBzY2FsZVo7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0bWFrZVJvdGF0aW9uRnJvbUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyICkge1xcblxcblxcdFxcdFxcdGlmICggISAoIGV1bGVyICYmIGV1bGVyLmlzRXVsZXIgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLm1ha2VSb3RhdGlvbkZyb21FdWxlcigpIG5vdyBleHBlY3RzIGEgRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XFxuXFxuXFx0XFx0XFx0dmFyIHggPSBldWxlci54LCB5ID0gZXVsZXIueSwgeiA9IGV1bGVyLno7XFxuXFx0XFx0XFx0dmFyIGEgPSBNYXRoLmNvcyggeCApLCBiID0gTWF0aC5zaW4oIHggKTtcXG5cXHRcXHRcXHR2YXIgYyA9IE1hdGguY29zKCB5ICksIGQgPSBNYXRoLnNpbiggeSApO1xcblxcdFxcdFxcdHZhciBlID0gTWF0aC5jb3MoIHogKSwgZiA9IE1hdGguc2luKCB6ICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBldWxlci5vcmRlciA9PT0gJ1hZWicgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGFlID0gYSAqIGUsIGFmID0gYSAqIGYsIGJlID0gYiAqIGUsIGJmID0gYiAqIGY7XFxuXFxuXFx0XFx0XFx0XFx0dGVbIDAgXSA9IGMgKiBlO1xcblxcdFxcdFxcdFxcdHRlWyA0IF0gPSAtIGMgKiBmO1xcblxcdFxcdFxcdFxcdHRlWyA4IF0gPSBkO1xcblxcblxcdFxcdFxcdFxcdHRlWyAxIF0gPSBhZiArIGJlICogZDtcXG5cXHRcXHRcXHRcXHR0ZVsgNSBdID0gYWUgLSBiZiAqIGQ7XFxuXFx0XFx0XFx0XFx0dGVbIDkgXSA9IC0gYiAqIGM7XFxuXFxuXFx0XFx0XFx0XFx0dGVbIDIgXSA9IGJmIC0gYWUgKiBkO1xcblxcdFxcdFxcdFxcdHRlWyA2IF0gPSBiZSArIGFmICogZDtcXG5cXHRcXHRcXHRcXHR0ZVsgMTAgXSA9IGEgKiBjO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWVhaJyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgY2UgPSBjICogZSwgY2YgPSBjICogZiwgZGUgPSBkICogZSwgZGYgPSBkICogZjtcXG5cXG5cXHRcXHRcXHRcXHR0ZVsgMCBdID0gY2UgKyBkZiAqIGI7XFxuXFx0XFx0XFx0XFx0dGVbIDQgXSA9IGRlICogYiAtIGNmO1xcblxcdFxcdFxcdFxcdHRlWyA4IF0gPSBhICogZDtcXG5cXG5cXHRcXHRcXHRcXHR0ZVsgMSBdID0gYSAqIGY7XFxuXFx0XFx0XFx0XFx0dGVbIDUgXSA9IGEgKiBlO1xcblxcdFxcdFxcdFxcdHRlWyA5IF0gPSAtIGI7XFxuXFxuXFx0XFx0XFx0XFx0dGVbIDIgXSA9IGNmICogYiAtIGRlO1xcblxcdFxcdFxcdFxcdHRlWyA2IF0gPSBkZiArIGNlICogYjtcXG5cXHRcXHRcXHRcXHR0ZVsgMTAgXSA9IGEgKiBjO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWlhZJyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgY2UgPSBjICogZSwgY2YgPSBjICogZiwgZGUgPSBkICogZSwgZGYgPSBkICogZjtcXG5cXG5cXHRcXHRcXHRcXHR0ZVsgMCBdID0gY2UgLSBkZiAqIGI7XFxuXFx0XFx0XFx0XFx0dGVbIDQgXSA9IC0gYSAqIGY7XFxuXFx0XFx0XFx0XFx0dGVbIDggXSA9IGRlICsgY2YgKiBiO1xcblxcblxcdFxcdFxcdFxcdHRlWyAxIF0gPSBjZiArIGRlICogYjtcXG5cXHRcXHRcXHRcXHR0ZVsgNSBdID0gYSAqIGU7XFxuXFx0XFx0XFx0XFx0dGVbIDkgXSA9IGRmIC0gY2UgKiBiO1xcblxcblxcdFxcdFxcdFxcdHRlWyAyIF0gPSAtIGEgKiBkO1xcblxcdFxcdFxcdFxcdHRlWyA2IF0gPSBiO1xcblxcdFxcdFxcdFxcdHRlWyAxMCBdID0gYSAqIGM7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWVgnICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBhZSA9IGEgKiBlLCBhZiA9IGEgKiBmLCBiZSA9IGIgKiBlLCBiZiA9IGIgKiBmO1xcblxcblxcdFxcdFxcdFxcdHRlWyAwIF0gPSBjICogZTtcXG5cXHRcXHRcXHRcXHR0ZVsgNCBdID0gYmUgKiBkIC0gYWY7XFxuXFx0XFx0XFx0XFx0dGVbIDggXSA9IGFlICogZCArIGJmO1xcblxcblxcdFxcdFxcdFxcdHRlWyAxIF0gPSBjICogZjtcXG5cXHRcXHRcXHRcXHR0ZVsgNSBdID0gYmYgKiBkICsgYWU7XFxuXFx0XFx0XFx0XFx0dGVbIDkgXSA9IGFmICogZCAtIGJlO1xcblxcblxcdFxcdFxcdFxcdHRlWyAyIF0gPSAtIGQ7XFxuXFx0XFx0XFx0XFx0dGVbIDYgXSA9IGIgKiBjO1xcblxcdFxcdFxcdFxcdHRlWyAxMCBdID0gYSAqIGM7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWlgnICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBhYyA9IGEgKiBjLCBhZCA9IGEgKiBkLCBiYyA9IGIgKiBjLCBiZCA9IGIgKiBkO1xcblxcblxcdFxcdFxcdFxcdHRlWyAwIF0gPSBjICogZTtcXG5cXHRcXHRcXHRcXHR0ZVsgNCBdID0gYmQgLSBhYyAqIGY7XFxuXFx0XFx0XFx0XFx0dGVbIDggXSA9IGJjICogZiArIGFkO1xcblxcblxcdFxcdFxcdFxcdHRlWyAxIF0gPSBmO1xcblxcdFxcdFxcdFxcdHRlWyA1IF0gPSBhICogZTtcXG5cXHRcXHRcXHRcXHR0ZVsgOSBdID0gLSBiICogZTtcXG5cXG5cXHRcXHRcXHRcXHR0ZVsgMiBdID0gLSBkICogZTtcXG5cXHRcXHRcXHRcXHR0ZVsgNiBdID0gYWQgKiBmICsgYmM7XFxuXFx0XFx0XFx0XFx0dGVbIDEwIF0gPSBhYyAtIGJkICogZjtcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1haWScgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XFxuXFxuXFx0XFx0XFx0XFx0dGVbIDAgXSA9IGMgKiBlO1xcblxcdFxcdFxcdFxcdHRlWyA0IF0gPSAtIGY7XFxuXFx0XFx0XFx0XFx0dGVbIDggXSA9IGQgKiBlO1xcblxcblxcdFxcdFxcdFxcdHRlWyAxIF0gPSBhYyAqIGYgKyBiZDtcXG5cXHRcXHRcXHRcXHR0ZVsgNSBdID0gYSAqIGU7XFxuXFx0XFx0XFx0XFx0dGVbIDkgXSA9IGFkICogZiAtIGJjO1xcblxcblxcdFxcdFxcdFxcdHRlWyAyIF0gPSBiYyAqIGYgLSBhZDtcXG5cXHRcXHRcXHRcXHR0ZVsgNiBdID0gYiAqIGU7XFxuXFx0XFx0XFx0XFx0dGVbIDEwIF0gPSBiZCAqIGYgKyBhYztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gbGFzdCBjb2x1bW5cXG5cXHRcXHRcXHR0ZVsgMyBdID0gMDtcXG5cXHRcXHRcXHR0ZVsgNyBdID0gMDtcXG5cXHRcXHRcXHR0ZVsgMTEgXSA9IDA7XFxuXFxuXFx0XFx0XFx0Ly8gYm90dG9tIHJvd1xcblxcdFxcdFxcdHRlWyAxMiBdID0gMDtcXG5cXHRcXHRcXHR0ZVsgMTMgXSA9IDA7XFxuXFx0XFx0XFx0dGVbIDE0IF0gPSAwO1xcblxcdFxcdFxcdHRlWyAxNSBdID0gMTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcXG5cXG5cXHRcXHRcXHR2YXIgeCA9IHEuX3gsIHkgPSBxLl95LCB6ID0gcS5feiwgdyA9IHEuX3c7XFxuXFx0XFx0XFx0dmFyIHgyID0geCArIHgsIHkyID0geSArIHksIHoyID0geiArIHo7XFxuXFx0XFx0XFx0dmFyIHh4ID0geCAqIHgyLCB4eSA9IHggKiB5MiwgeHogPSB4ICogejI7XFxuXFx0XFx0XFx0dmFyIHl5ID0geSAqIHkyLCB5eiA9IHkgKiB6MiwgenogPSB6ICogejI7XFxuXFx0XFx0XFx0dmFyIHd4ID0gdyAqIHgyLCB3eSA9IHcgKiB5Miwgd3ogPSB3ICogejI7XFxuXFxuXFx0XFx0XFx0dGVbIDAgXSA9IDEgLSAoIHl5ICsgenogKTtcXG5cXHRcXHRcXHR0ZVsgNCBdID0geHkgLSB3ejtcXG5cXHRcXHRcXHR0ZVsgOCBdID0geHogKyB3eTtcXG5cXG5cXHRcXHRcXHR0ZVsgMSBdID0geHkgKyB3ejtcXG5cXHRcXHRcXHR0ZVsgNSBdID0gMSAtICggeHggKyB6eiApO1xcblxcdFxcdFxcdHRlWyA5IF0gPSB5eiAtIHd4O1xcblxcblxcdFxcdFxcdHRlWyAyIF0gPSB4eiAtIHd5O1xcblxcdFxcdFxcdHRlWyA2IF0gPSB5eiArIHd4O1xcblxcdFxcdFxcdHRlWyAxMCBdID0gMSAtICggeHggKyB5eSApO1xcblxcblxcdFxcdFxcdC8vIGxhc3QgY29sdW1uXFxuXFx0XFx0XFx0dGVbIDMgXSA9IDA7XFxuXFx0XFx0XFx0dGVbIDcgXSA9IDA7XFxuXFx0XFx0XFx0dGVbIDExIF0gPSAwO1xcblxcblxcdFxcdFxcdC8vIGJvdHRvbSByb3dcXG5cXHRcXHRcXHR0ZVsgMTIgXSA9IDA7XFxuXFx0XFx0XFx0dGVbIDEzIF0gPSAwO1xcblxcdFxcdFxcdHRlWyAxNCBdID0gMDtcXG5cXHRcXHRcXHR0ZVsgMTUgXSA9IDE7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRsb29rQXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgeCA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0dmFyIHkgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdHZhciB6ID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gbG9va0F0KCBleWUsIHRhcmdldCwgdXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcXG5cXG5cXHRcXHRcXHRcXHR6LnN1YlZlY3RvcnMoIGV5ZSwgdGFyZ2V0ICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB6Lmxlbmd0aFNxKCkgPT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gZXllIGFuZCB0YXJnZXQgYXJlIGluIHRoZSBzYW1lIHBvc2l0aW9uXFxuXFxuXFx0XFx0XFx0XFx0XFx0ei56ID0gMTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0ei5ub3JtYWxpemUoKTtcXG5cXHRcXHRcXHRcXHR4LmNyb3NzVmVjdG9ycyggdXAsIHogKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHgubGVuZ3RoU3EoKSA9PT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyB1cCBhbmQgeiBhcmUgcGFyYWxsZWxcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIE1hdGguYWJzKCB1cC56ICkgPT09IDEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0ei54ICs9IDAuMDAwMTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHoueiArPSAwLjAwMDE7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHoubm9ybWFsaXplKCk7XFxuXFx0XFx0XFx0XFx0XFx0eC5jcm9zc1ZlY3RvcnMoIHVwLCB6ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHgubm9ybWFsaXplKCk7XFxuXFx0XFx0XFx0XFx0eS5jcm9zc1ZlY3RvcnMoIHosIHggKTtcXG5cXG5cXHRcXHRcXHRcXHR0ZVsgMCBdID0geC54OyB0ZVsgNCBdID0geS54OyB0ZVsgOCBdID0gei54O1xcblxcdFxcdFxcdFxcdHRlWyAxIF0gPSB4Lnk7IHRlWyA1IF0gPSB5Lnk7IHRlWyA5IF0gPSB6Lnk7XFxuXFx0XFx0XFx0XFx0dGVbIDIgXSA9IHguejsgdGVbIDYgXSA9IHkuejsgdGVbIDEwIF0gPSB6Lno7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0bXVsdGlwbHk6IGZ1bmN0aW9uICggbSwgbiApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIG4gIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseU1hdHJpY2VzKCBhLCBiICkgaW5zdGVhZC4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggbSwgbiApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLCBtICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRwcmVtdWx0aXBseTogZnVuY3Rpb24gKCBtICkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIG0sIHRoaXMgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG11bHRpcGx5TWF0cmljZXM6IGZ1bmN0aW9uICggYSwgYiApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYWUgPSBhLmVsZW1lbnRzO1xcblxcdFxcdFxcdHZhciBiZSA9IGIuZWxlbWVudHM7XFxuXFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcXG5cXG5cXHRcXHRcXHR2YXIgYTExID0gYWVbIDAgXSwgYTEyID0gYWVbIDQgXSwgYTEzID0gYWVbIDggXSwgYTE0ID0gYWVbIDEyIF07XFxuXFx0XFx0XFx0dmFyIGEyMSA9IGFlWyAxIF0sIGEyMiA9IGFlWyA1IF0sIGEyMyA9IGFlWyA5IF0sIGEyNCA9IGFlWyAxMyBdO1xcblxcdFxcdFxcdHZhciBhMzEgPSBhZVsgMiBdLCBhMzIgPSBhZVsgNiBdLCBhMzMgPSBhZVsgMTAgXSwgYTM0ID0gYWVbIDE0IF07XFxuXFx0XFx0XFx0dmFyIGE0MSA9IGFlWyAzIF0sIGE0MiA9IGFlWyA3IF0sIGE0MyA9IGFlWyAxMSBdLCBhNDQgPSBhZVsgMTUgXTtcXG5cXG5cXHRcXHRcXHR2YXIgYjExID0gYmVbIDAgXSwgYjEyID0gYmVbIDQgXSwgYjEzID0gYmVbIDggXSwgYjE0ID0gYmVbIDEyIF07XFxuXFx0XFx0XFx0dmFyIGIyMSA9IGJlWyAxIF0sIGIyMiA9IGJlWyA1IF0sIGIyMyA9IGJlWyA5IF0sIGIyNCA9IGJlWyAxMyBdO1xcblxcdFxcdFxcdHZhciBiMzEgPSBiZVsgMiBdLCBiMzIgPSBiZVsgNiBdLCBiMzMgPSBiZVsgMTAgXSwgYjM0ID0gYmVbIDE0IF07XFxuXFx0XFx0XFx0dmFyIGI0MSA9IGJlWyAzIF0sIGI0MiA9IGJlWyA3IF0sIGI0MyA9IGJlWyAxMSBdLCBiNDQgPSBiZVsgMTUgXTtcXG5cXG5cXHRcXHRcXHR0ZVsgMCBdID0gYTExICogYjExICsgYTEyICogYjIxICsgYTEzICogYjMxICsgYTE0ICogYjQxO1xcblxcdFxcdFxcdHRlWyA0IF0gPSBhMTEgKiBiMTIgKyBhMTIgKiBiMjIgKyBhMTMgKiBiMzIgKyBhMTQgKiBiNDI7XFxuXFx0XFx0XFx0dGVbIDggXSA9IGExMSAqIGIxMyArIGExMiAqIGIyMyArIGExMyAqIGIzMyArIGExNCAqIGI0MztcXG5cXHRcXHRcXHR0ZVsgMTIgXSA9IGExMSAqIGIxNCArIGExMiAqIGIyNCArIGExMyAqIGIzNCArIGExNCAqIGI0NDtcXG5cXG5cXHRcXHRcXHR0ZVsgMSBdID0gYTIxICogYjExICsgYTIyICogYjIxICsgYTIzICogYjMxICsgYTI0ICogYjQxO1xcblxcdFxcdFxcdHRlWyA1IF0gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzIgKyBhMjQgKiBiNDI7XFxuXFx0XFx0XFx0dGVbIDkgXSA9IGEyMSAqIGIxMyArIGEyMiAqIGIyMyArIGEyMyAqIGIzMyArIGEyNCAqIGI0MztcXG5cXHRcXHRcXHR0ZVsgMTMgXSA9IGEyMSAqIGIxNCArIGEyMiAqIGIyNCArIGEyMyAqIGIzNCArIGEyNCAqIGI0NDtcXG5cXG5cXHRcXHRcXHR0ZVsgMiBdID0gYTMxICogYjExICsgYTMyICogYjIxICsgYTMzICogYjMxICsgYTM0ICogYjQxO1xcblxcdFxcdFxcdHRlWyA2IF0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzIgKyBhMzQgKiBiNDI7XFxuXFx0XFx0XFx0dGVbIDEwIF0gPSBhMzEgKiBiMTMgKyBhMzIgKiBiMjMgKyBhMzMgKiBiMzMgKyBhMzQgKiBiNDM7XFxuXFx0XFx0XFx0dGVbIDE0IF0gPSBhMzEgKiBiMTQgKyBhMzIgKiBiMjQgKyBhMzMgKiBiMzQgKyBhMzQgKiBiNDQ7XFxuXFxuXFx0XFx0XFx0dGVbIDMgXSA9IGE0MSAqIGIxMSArIGE0MiAqIGIyMSArIGE0MyAqIGIzMSArIGE0NCAqIGI0MTtcXG5cXHRcXHRcXHR0ZVsgNyBdID0gYTQxICogYjEyICsgYTQyICogYjIyICsgYTQzICogYjMyICsgYTQ0ICogYjQyO1xcblxcdFxcdFxcdHRlWyAxMSBdID0gYTQxICogYjEzICsgYTQyICogYjIzICsgYTQzICogYjMzICsgYTQ0ICogYjQzO1xcblxcdFxcdFxcdHRlWyAxNSBdID0gYTQxICogYjE0ICsgYTQyICogYjI0ICsgYTQzICogYjM0ICsgYTQ0ICogYjQ0O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xcblxcblxcdFxcdFxcdHRlWyAwIF0gKj0gczsgdGVbIDQgXSAqPSBzOyB0ZVsgOCBdICo9IHM7IHRlWyAxMiBdICo9IHM7XFxuXFx0XFx0XFx0dGVbIDEgXSAqPSBzOyB0ZVsgNSBdICo9IHM7IHRlWyA5IF0gKj0gczsgdGVbIDEzIF0gKj0gcztcXG5cXHRcXHRcXHR0ZVsgMiBdICo9IHM7IHRlWyA2IF0gKj0gczsgdGVbIDEwIF0gKj0gczsgdGVbIDE0IF0gKj0gcztcXG5cXHRcXHRcXHR0ZVsgMyBdICo9IHM7IHRlWyA3IF0gKj0gczsgdGVbIDExIF0gKj0gczsgdGVbIDE1IF0gKj0gcztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGFwcGx5VG9CdWZmZXJBdHRyaWJ1dGU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBhcHBseVRvQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYXR0cmlidXRlLmNvdW50OyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2MS54ID0gYXR0cmlidXRlLmdldFgoIGkgKTtcXG5cXHRcXHRcXHRcXHRcXHR2MS55ID0gYXR0cmlidXRlLmdldFkoIGkgKTtcXG5cXHRcXHRcXHRcXHRcXHR2MS56ID0gYXR0cmlidXRlLmdldFooIGkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2MS5hcHBseU1hdHJpeDQoIHRoaXMgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRhdHRyaWJ1dGUuc2V0WFlaKCBpLCB2MS54LCB2MS55LCB2MS56ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiBhdHRyaWJ1dGU7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0ZGV0ZXJtaW5hbnQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xcblxcblxcdFxcdFxcdHZhciBuMTEgPSB0ZVsgMCBdLCBuMTIgPSB0ZVsgNCBdLCBuMTMgPSB0ZVsgOCBdLCBuMTQgPSB0ZVsgMTIgXTtcXG5cXHRcXHRcXHR2YXIgbjIxID0gdGVbIDEgXSwgbjIyID0gdGVbIDUgXSwgbjIzID0gdGVbIDkgXSwgbjI0ID0gdGVbIDEzIF07XFxuXFx0XFx0XFx0dmFyIG4zMSA9IHRlWyAyIF0sIG4zMiA9IHRlWyA2IF0sIG4zMyA9IHRlWyAxMCBdLCBuMzQgPSB0ZVsgMTQgXTtcXG5cXHRcXHRcXHR2YXIgbjQxID0gdGVbIDMgXSwgbjQyID0gdGVbIDcgXSwgbjQzID0gdGVbIDExIF0sIG40NCA9IHRlWyAxNSBdO1xcblxcblxcdFxcdFxcdC8vVE9ETzogbWFrZSB0aGlzIG1vcmUgZWZmaWNpZW50XFxuXFx0XFx0XFx0Ly8oIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bSApXFxuXFxuXFx0XFx0XFx0cmV0dXJuIChcXG5cXHRcXHRcXHRcXHRuNDEgKiAoXFxuXFx0XFx0XFx0XFx0XFx0KyBuMTQgKiBuMjMgKiBuMzJcXG5cXHRcXHRcXHRcXHRcXHQgLSBuMTMgKiBuMjQgKiBuMzJcXG5cXHRcXHRcXHRcXHRcXHQgLSBuMTQgKiBuMjIgKiBuMzNcXG5cXHRcXHRcXHRcXHRcXHQgKyBuMTIgKiBuMjQgKiBuMzNcXG5cXHRcXHRcXHRcXHRcXHQgKyBuMTMgKiBuMjIgKiBuMzRcXG5cXHRcXHRcXHRcXHRcXHQgLSBuMTIgKiBuMjMgKiBuMzRcXG5cXHRcXHRcXHRcXHQpICtcXG5cXHRcXHRcXHRcXHRuNDIgKiAoXFxuXFx0XFx0XFx0XFx0XFx0KyBuMTEgKiBuMjMgKiBuMzRcXG5cXHRcXHRcXHRcXHRcXHQgLSBuMTEgKiBuMjQgKiBuMzNcXG5cXHRcXHRcXHRcXHRcXHQgKyBuMTQgKiBuMjEgKiBuMzNcXG5cXHRcXHRcXHRcXHRcXHQgLSBuMTMgKiBuMjEgKiBuMzRcXG5cXHRcXHRcXHRcXHRcXHQgKyBuMTMgKiBuMjQgKiBuMzFcXG5cXHRcXHRcXHRcXHRcXHQgLSBuMTQgKiBuMjMgKiBuMzFcXG5cXHRcXHRcXHRcXHQpICtcXG5cXHRcXHRcXHRcXHRuNDMgKiAoXFxuXFx0XFx0XFx0XFx0XFx0KyBuMTEgKiBuMjQgKiBuMzJcXG5cXHRcXHRcXHRcXHRcXHQgLSBuMTEgKiBuMjIgKiBuMzRcXG5cXHRcXHRcXHRcXHRcXHQgLSBuMTQgKiBuMjEgKiBuMzJcXG5cXHRcXHRcXHRcXHRcXHQgKyBuMTIgKiBuMjEgKiBuMzRcXG5cXHRcXHRcXHRcXHRcXHQgKyBuMTQgKiBuMjIgKiBuMzFcXG5cXHRcXHRcXHRcXHRcXHQgLSBuMTIgKiBuMjQgKiBuMzFcXG5cXHRcXHRcXHRcXHQpICtcXG5cXHRcXHRcXHRcXHRuNDQgKiAoXFxuXFx0XFx0XFx0XFx0XFx0LSBuMTMgKiBuMjIgKiBuMzFcXG5cXHRcXHRcXHRcXHRcXHQgLSBuMTEgKiBuMjMgKiBuMzJcXG5cXHRcXHRcXHRcXHRcXHQgKyBuMTEgKiBuMjIgKiBuMzNcXG5cXHRcXHRcXHRcXHRcXHQgKyBuMTMgKiBuMjEgKiBuMzJcXG5cXHRcXHRcXHRcXHRcXHQgLSBuMTIgKiBuMjEgKiBuMzNcXG5cXHRcXHRcXHRcXHRcXHQgKyBuMTIgKiBuMjMgKiBuMzFcXG5cXHRcXHRcXHRcXHQpXFxuXFxuXFx0XFx0XFx0KTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHRyYW5zcG9zZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XFxuXFx0XFx0XFx0dmFyIHRtcDtcXG5cXG5cXHRcXHRcXHR0bXAgPSB0ZVsgMSBdOyB0ZVsgMSBdID0gdGVbIDQgXTsgdGVbIDQgXSA9IHRtcDtcXG5cXHRcXHRcXHR0bXAgPSB0ZVsgMiBdOyB0ZVsgMiBdID0gdGVbIDggXTsgdGVbIDggXSA9IHRtcDtcXG5cXHRcXHRcXHR0bXAgPSB0ZVsgNiBdOyB0ZVsgNiBdID0gdGVbIDkgXTsgdGVbIDkgXSA9IHRtcDtcXG5cXG5cXHRcXHRcXHR0bXAgPSB0ZVsgMyBdOyB0ZVsgMyBdID0gdGVbIDEyIF07IHRlWyAxMiBdID0gdG1wO1xcblxcdFxcdFxcdHRtcCA9IHRlWyA3IF07IHRlWyA3IF0gPSB0ZVsgMTMgXTsgdGVbIDEzIF0gPSB0bXA7XFxuXFx0XFx0XFx0dG1wID0gdGVbIDExIF07IHRlWyAxMSBdID0gdGVbIDE0IF07IHRlWyAxNCBdID0gdG1wO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0UG9zaXRpb246IGZ1bmN0aW9uICggdiApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xcblxcblxcdFxcdFxcdHRlWyAxMiBdID0gdi54O1xcblxcdFxcdFxcdHRlWyAxMyBdID0gdi55O1xcblxcdFxcdFxcdHRlWyAxNCBdID0gdi56O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0SW52ZXJzZTogZnVuY3Rpb24gKCBtLCB0aHJvd09uRGVnZW5lcmF0ZSApIHtcXG5cXG5cXHRcXHRcXHQvLyBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG1cXG5cXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzLFxcblxcdFxcdFxcdFxcdG1lID0gbS5lbGVtZW50cyxcXG5cXG5cXHRcXHRcXHRcXHRuMTEgPSBtZVsgMCBdLCBuMjEgPSBtZVsgMSBdLCBuMzEgPSBtZVsgMiBdLCBuNDEgPSBtZVsgMyBdLFxcblxcdFxcdFxcdFxcdG4xMiA9IG1lWyA0IF0sIG4yMiA9IG1lWyA1IF0sIG4zMiA9IG1lWyA2IF0sIG40MiA9IG1lWyA3IF0sXFxuXFx0XFx0XFx0XFx0bjEzID0gbWVbIDggXSwgbjIzID0gbWVbIDkgXSwgbjMzID0gbWVbIDEwIF0sIG40MyA9IG1lWyAxMSBdLFxcblxcdFxcdFxcdFxcdG4xNCA9IG1lWyAxMiBdLCBuMjQgPSBtZVsgMTMgXSwgbjM0ID0gbWVbIDE0IF0sIG40NCA9IG1lWyAxNSBdLFxcblxcblxcdFxcdFxcdFxcdHQxMSA9IG4yMyAqIG4zNCAqIG40MiAtIG4yNCAqIG4zMyAqIG40MiArIG4yNCAqIG4zMiAqIG40MyAtIG4yMiAqIG4zNCAqIG40MyAtIG4yMyAqIG4zMiAqIG40NCArIG4yMiAqIG4zMyAqIG40NCxcXG5cXHRcXHRcXHRcXHR0MTIgPSBuMTQgKiBuMzMgKiBuNDIgLSBuMTMgKiBuMzQgKiBuNDIgLSBuMTQgKiBuMzIgKiBuNDMgKyBuMTIgKiBuMzQgKiBuNDMgKyBuMTMgKiBuMzIgKiBuNDQgLSBuMTIgKiBuMzMgKiBuNDQsXFxuXFx0XFx0XFx0XFx0dDEzID0gbjEzICogbjI0ICogbjQyIC0gbjE0ICogbjIzICogbjQyICsgbjE0ICogbjIyICogbjQzIC0gbjEyICogbjI0ICogbjQzIC0gbjEzICogbjIyICogbjQ0ICsgbjEyICogbjIzICogbjQ0LFxcblxcdFxcdFxcdFxcdHQxNCA9IG4xNCAqIG4yMyAqIG4zMiAtIG4xMyAqIG4yNCAqIG4zMiAtIG4xNCAqIG4yMiAqIG4zMyArIG4xMiAqIG4yNCAqIG4zMyArIG4xMyAqIG4yMiAqIG4zNCAtIG4xMiAqIG4yMyAqIG4zNDtcXG5cXG5cXHRcXHRcXHR2YXIgZGV0ID0gbjExICogdDExICsgbjIxICogdDEyICsgbjMxICogdDEzICsgbjQxICogdDE0O1xcblxcblxcdFxcdFxcdGlmICggZGV0ID09PSAwICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBtc2cgPSBcXFwiVEhSRUUuTWF0cml4NDogLmdldEludmVyc2UoKSBjYW4ndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwXFxcIjtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHRocm93T25EZWdlbmVyYXRlID09PSB0cnVlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRocm93IG5ldyBFcnJvciggbXNnICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oIG1zZyApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5pZGVudGl0eSgpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgZGV0SW52ID0gMSAvIGRldDtcXG5cXG5cXHRcXHRcXHR0ZVsgMCBdID0gdDExICogZGV0SW52O1xcblxcdFxcdFxcdHRlWyAxIF0gPSAoIG4yNCAqIG4zMyAqIG40MSAtIG4yMyAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMSAqIG40MyArIG4yMSAqIG4zNCAqIG40MyArIG4yMyAqIG4zMSAqIG40NCAtIG4yMSAqIG4zMyAqIG40NCApICogZGV0SW52O1xcblxcdFxcdFxcdHRlWyAyIF0gPSAoIG4yMiAqIG4zNCAqIG40MSAtIG4yNCAqIG4zMiAqIG40MSArIG4yNCAqIG4zMSAqIG40MiAtIG4yMSAqIG4zNCAqIG40MiAtIG4yMiAqIG4zMSAqIG40NCArIG4yMSAqIG4zMiAqIG40NCApICogZGV0SW52O1xcblxcdFxcdFxcdHRlWyAzIF0gPSAoIG4yMyAqIG4zMiAqIG40MSAtIG4yMiAqIG4zMyAqIG40MSAtIG4yMyAqIG4zMSAqIG40MiArIG4yMSAqIG4zMyAqIG40MiArIG4yMiAqIG4zMSAqIG40MyAtIG4yMSAqIG4zMiAqIG40MyApICogZGV0SW52O1xcblxcblxcdFxcdFxcdHRlWyA0IF0gPSB0MTIgKiBkZXRJbnY7XFxuXFx0XFx0XFx0dGVbIDUgXSA9ICggbjEzICogbjM0ICogbjQxIC0gbjE0ICogbjMzICogbjQxICsgbjE0ICogbjMxICogbjQzIC0gbjExICogbjM0ICogbjQzIC0gbjEzICogbjMxICogbjQ0ICsgbjExICogbjMzICogbjQ0ICkgKiBkZXRJbnY7XFxuXFx0XFx0XFx0dGVbIDYgXSA9ICggbjE0ICogbjMyICogbjQxIC0gbjEyICogbjM0ICogbjQxIC0gbjE0ICogbjMxICogbjQyICsgbjExICogbjM0ICogbjQyICsgbjEyICogbjMxICogbjQ0IC0gbjExICogbjMyICogbjQ0ICkgKiBkZXRJbnY7XFxuXFx0XFx0XFx0dGVbIDcgXSA9ICggbjEyICogbjMzICogbjQxIC0gbjEzICogbjMyICogbjQxICsgbjEzICogbjMxICogbjQyIC0gbjExICogbjMzICogbjQyIC0gbjEyICogbjMxICogbjQzICsgbjExICogbjMyICogbjQzICkgKiBkZXRJbnY7XFxuXFxuXFx0XFx0XFx0dGVbIDggXSA9IHQxMyAqIGRldEludjtcXG5cXHRcXHRcXHR0ZVsgOSBdID0gKCBuMTQgKiBuMjMgKiBuNDEgLSBuMTMgKiBuMjQgKiBuNDEgLSBuMTQgKiBuMjEgKiBuNDMgKyBuMTEgKiBuMjQgKiBuNDMgKyBuMTMgKiBuMjEgKiBuNDQgLSBuMTEgKiBuMjMgKiBuNDQgKSAqIGRldEludjtcXG5cXHRcXHRcXHR0ZVsgMTAgXSA9ICggbjEyICogbjI0ICogbjQxIC0gbjE0ICogbjIyICogbjQxICsgbjE0ICogbjIxICogbjQyIC0gbjExICogbjI0ICogbjQyIC0gbjEyICogbjIxICogbjQ0ICsgbjExICogbjIyICogbjQ0ICkgKiBkZXRJbnY7XFxuXFx0XFx0XFx0dGVbIDExIF0gPSAoIG4xMyAqIG4yMiAqIG40MSAtIG4xMiAqIG4yMyAqIG40MSAtIG4xMyAqIG4yMSAqIG40MiArIG4xMSAqIG4yMyAqIG40MiArIG4xMiAqIG4yMSAqIG40MyAtIG4xMSAqIG4yMiAqIG40MyApICogZGV0SW52O1xcblxcblxcdFxcdFxcdHRlWyAxMiBdID0gdDE0ICogZGV0SW52O1xcblxcdFxcdFxcdHRlWyAxMyBdID0gKCBuMTMgKiBuMjQgKiBuMzEgLSBuMTQgKiBuMjMgKiBuMzEgKyBuMTQgKiBuMjEgKiBuMzMgLSBuMTEgKiBuMjQgKiBuMzMgLSBuMTMgKiBuMjEgKiBuMzQgKyBuMTEgKiBuMjMgKiBuMzQgKSAqIGRldEludjtcXG5cXHRcXHRcXHR0ZVsgMTQgXSA9ICggbjE0ICogbjIyICogbjMxIC0gbjEyICogbjI0ICogbjMxIC0gbjE0ICogbjIxICogbjMyICsgbjExICogbjI0ICogbjMyICsgbjEyICogbjIxICogbjM0IC0gbjExICogbjIyICogbjM0ICkgKiBkZXRJbnY7XFxuXFx0XFx0XFx0dGVbIDE1IF0gPSAoIG4xMiAqIG4yMyAqIG4zMSAtIG4xMyAqIG4yMiAqIG4zMSArIG4xMyAqIG4yMSAqIG4zMiAtIG4xMSAqIG4yMyAqIG4zMiAtIG4xMiAqIG4yMSAqIG4zMyArIG4xMSAqIG4yMiAqIG4zMyApICogZGV0SW52O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2NhbGU6IGZ1bmN0aW9uICggdiApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xcblxcdFxcdFxcdHZhciB4ID0gdi54LCB5ID0gdi55LCB6ID0gdi56O1xcblxcblxcdFxcdFxcdHRlWyAwIF0gKj0geDsgdGVbIDQgXSAqPSB5OyB0ZVsgOCBdICo9IHo7XFxuXFx0XFx0XFx0dGVbIDEgXSAqPSB4OyB0ZVsgNSBdICo9IHk7IHRlWyA5IF0gKj0gejtcXG5cXHRcXHRcXHR0ZVsgMiBdICo9IHg7IHRlWyA2IF0gKj0geTsgdGVbIDEwIF0gKj0gejtcXG5cXHRcXHRcXHR0ZVsgMyBdICo9IHg7IHRlWyA3IF0gKj0geTsgdGVbIDExIF0gKj0gejtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldE1heFNjYWxlT25BeGlzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcXG5cXG5cXHRcXHRcXHR2YXIgc2NhbGVYU3EgPSB0ZVsgMCBdICogdGVbIDAgXSArIHRlWyAxIF0gKiB0ZVsgMSBdICsgdGVbIDIgXSAqIHRlWyAyIF07XFxuXFx0XFx0XFx0dmFyIHNjYWxlWVNxID0gdGVbIDQgXSAqIHRlWyA0IF0gKyB0ZVsgNSBdICogdGVbIDUgXSArIHRlWyA2IF0gKiB0ZVsgNiBdO1xcblxcdFxcdFxcdHZhciBzY2FsZVpTcSA9IHRlWyA4IF0gKiB0ZVsgOCBdICsgdGVbIDkgXSAqIHRlWyA5IF0gKyB0ZVsgMTAgXSAqIHRlWyAxMCBdO1xcblxcblxcdFxcdFxcdHJldHVybiBNYXRoLnNxcnQoIE1hdGgubWF4KCBzY2FsZVhTcSwgc2NhbGVZU3EsIHNjYWxlWlNxICkgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG1ha2VUcmFuc2xhdGlvbjogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xcblxcblxcdFxcdFxcdHRoaXMuc2V0KFxcblxcblxcdFxcdFxcdFxcdDEsIDAsIDAsIHgsXFxuXFx0XFx0XFx0XFx0MCwgMSwgMCwgeSxcXG5cXHRcXHRcXHRcXHQwLCAwLCAxLCB6LFxcblxcdFxcdFxcdFxcdDAsIDAsIDAsIDFcXG5cXG5cXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bWFrZVJvdGF0aW9uWDogZnVuY3Rpb24gKCB0aGV0YSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XFxuXFxuXFx0XFx0XFx0dGhpcy5zZXQoXFxuXFxuXFx0XFx0XFx0XFx0MSwgMCwgMCwgMCxcXG5cXHRcXHRcXHRcXHQwLCBjLCAtIHMsIDAsXFxuXFx0XFx0XFx0XFx0MCwgcywgYywgMCxcXG5cXHRcXHRcXHRcXHQwLCAwLCAwLCAxXFxuXFxuXFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG1ha2VSb3RhdGlvblk6IGZ1bmN0aW9uICggdGhldGEgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xcblxcblxcdFxcdFxcdHRoaXMuc2V0KFxcblxcblxcdFxcdFxcdFxcdCBjLCAwLCBzLCAwLFxcblxcdFxcdFxcdFxcdCAwLCAxLCAwLCAwLFxcblxcdFxcdFxcdFxcdC0gcywgMCwgYywgMCxcXG5cXHRcXHRcXHRcXHQgMCwgMCwgMCwgMVxcblxcblxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRtYWtlUm90YXRpb25aOiBmdW5jdGlvbiAoIHRoZXRhICkge1xcblxcblxcdFxcdFxcdHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLnNldChcXG5cXG5cXHRcXHRcXHRcXHRjLCAtIHMsIDAsIDAsXFxuXFx0XFx0XFx0XFx0cywgYywgMCwgMCxcXG5cXHRcXHRcXHRcXHQwLCAwLCAxLCAwLFxcblxcdFxcdFxcdFxcdDAsIDAsIDAsIDFcXG5cXG5cXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bWFrZVJvdGF0aW9uQXhpczogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcXG5cXG5cXHRcXHRcXHQvLyBCYXNlZCBvbiBodHRwOi8vd3d3LmdhbWVkZXYubmV0L3JlZmVyZW5jZS9hcnRpY2xlcy9hcnRpY2xlMTE5OS5hc3BcXG5cXG5cXHRcXHRcXHR2YXIgYyA9IE1hdGguY29zKCBhbmdsZSApO1xcblxcdFxcdFxcdHZhciBzID0gTWF0aC5zaW4oIGFuZ2xlICk7XFxuXFx0XFx0XFx0dmFyIHQgPSAxIC0gYztcXG5cXHRcXHRcXHR2YXIgeCA9IGF4aXMueCwgeSA9IGF4aXMueSwgeiA9IGF4aXMuejtcXG5cXHRcXHRcXHR2YXIgdHggPSB0ICogeCwgdHkgPSB0ICogeTtcXG5cXG5cXHRcXHRcXHR0aGlzLnNldChcXG5cXG5cXHRcXHRcXHRcXHR0eCAqIHggKyBjLCB0eCAqIHkgLSBzICogeiwgdHggKiB6ICsgcyAqIHksIDAsXFxuXFx0XFx0XFx0XFx0dHggKiB5ICsgcyAqIHosIHR5ICogeSArIGMsIHR5ICogeiAtIHMgKiB4LCAwLFxcblxcdFxcdFxcdFxcdHR4ICogeiAtIHMgKiB5LCB0eSAqIHogKyBzICogeCwgdCAqIHogKiB6ICsgYywgMCxcXG5cXHRcXHRcXHRcXHQwLCAwLCAwLCAxXFxuXFxuXFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHQgcmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRtYWtlU2NhbGU6IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnNldChcXG5cXG5cXHRcXHRcXHRcXHR4LCAwLCAwLCAwLFxcblxcdFxcdFxcdFxcdDAsIHksIDAsIDAsXFxuXFx0XFx0XFx0XFx0MCwgMCwgeiwgMCxcXG5cXHRcXHRcXHRcXHQwLCAwLCAwLCAxXFxuXFxuXFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG1ha2VTaGVhcjogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xcblxcblxcdFxcdFxcdHRoaXMuc2V0KFxcblxcblxcdFxcdFxcdFxcdDEsIHksIHosIDAsXFxuXFx0XFx0XFx0XFx0eCwgMSwgeiwgMCxcXG5cXHRcXHRcXHRcXHR4LCB5LCAxLCAwLFxcblxcdFxcdFxcdFxcdDAsIDAsIDAsIDFcXG5cXG5cXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29tcG9zZTogZnVuY3Rpb24gKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xcblxcdFxcdFxcdHRoaXMuc2NhbGUoIHNjYWxlICk7XFxuXFx0XFx0XFx0dGhpcy5zZXRQb3NpdGlvbiggcG9zaXRpb24gKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGRlY29tcG9zZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdHZhciBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBkZWNvbXBvc2UoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xcblxcblxcdFxcdFxcdFxcdHZhciBzeCA9IHZlY3Rvci5zZXQoIHRlWyAwIF0sIHRlWyAxIF0sIHRlWyAyIF0gKS5sZW5ndGgoKTtcXG5cXHRcXHRcXHRcXHR2YXIgc3kgPSB2ZWN0b3Iuc2V0KCB0ZVsgNCBdLCB0ZVsgNSBdLCB0ZVsgNiBdICkubGVuZ3RoKCk7XFxuXFx0XFx0XFx0XFx0dmFyIHN6ID0gdmVjdG9yLnNldCggdGVbIDggXSwgdGVbIDkgXSwgdGVbIDEwIF0gKS5sZW5ndGgoKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBpZiBkZXRlcm1pbmUgaXMgbmVnYXRpdmUsIHdlIG5lZWQgdG8gaW52ZXJ0IG9uZSBzY2FsZVxcblxcdFxcdFxcdFxcdHZhciBkZXQgPSB0aGlzLmRldGVybWluYW50KCk7XFxuXFx0XFx0XFx0XFx0aWYgKCBkZXQgPCAwICkgc3ggPSAtIHN4O1xcblxcblxcdFxcdFxcdFxcdHBvc2l0aW9uLnggPSB0ZVsgMTIgXTtcXG5cXHRcXHRcXHRcXHRwb3NpdGlvbi55ID0gdGVbIDEzIF07XFxuXFx0XFx0XFx0XFx0cG9zaXRpb24ueiA9IHRlWyAxNCBdO1xcblxcblxcdFxcdFxcdFxcdC8vIHNjYWxlIHRoZSByb3RhdGlvbiBwYXJ0XFxuXFx0XFx0XFx0XFx0bWF0cml4LmNvcHkoIHRoaXMgKTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgaW52U1ggPSAxIC8gc3g7XFxuXFx0XFx0XFx0XFx0dmFyIGludlNZID0gMSAvIHN5O1xcblxcdFxcdFxcdFxcdHZhciBpbnZTWiA9IDEgLyBzejtcXG5cXG5cXHRcXHRcXHRcXHRtYXRyaXguZWxlbWVudHNbIDAgXSAqPSBpbnZTWDtcXG5cXHRcXHRcXHRcXHRtYXRyaXguZWxlbWVudHNbIDEgXSAqPSBpbnZTWDtcXG5cXHRcXHRcXHRcXHRtYXRyaXguZWxlbWVudHNbIDIgXSAqPSBpbnZTWDtcXG5cXG5cXHRcXHRcXHRcXHRtYXRyaXguZWxlbWVudHNbIDQgXSAqPSBpbnZTWTtcXG5cXHRcXHRcXHRcXHRtYXRyaXguZWxlbWVudHNbIDUgXSAqPSBpbnZTWTtcXG5cXHRcXHRcXHRcXHRtYXRyaXguZWxlbWVudHNbIDYgXSAqPSBpbnZTWTtcXG5cXG5cXHRcXHRcXHRcXHRtYXRyaXguZWxlbWVudHNbIDggXSAqPSBpbnZTWjtcXG5cXHRcXHRcXHRcXHRtYXRyaXguZWxlbWVudHNbIDkgXSAqPSBpbnZTWjtcXG5cXHRcXHRcXHRcXHRtYXRyaXguZWxlbWVudHNbIDEwIF0gKj0gaW52U1o7XFxuXFxuXFx0XFx0XFx0XFx0cXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG1hdHJpeCApO1xcblxcblxcdFxcdFxcdFxcdHNjYWxlLnggPSBzeDtcXG5cXHRcXHRcXHRcXHRzY2FsZS55ID0gc3k7XFxuXFx0XFx0XFx0XFx0c2NhbGUueiA9IHN6O1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdG1ha2VQZXJzcGVjdGl2ZTogZnVuY3Rpb24gKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGZhciA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tYWtlUGVyc3BlY3RpdmUoKSBoYXMgYmVlbiByZWRlZmluZWQgYW5kIGhhcyBhIG5ldyBzaWduYXR1cmUuIFBsZWFzZSBjaGVjayB0aGUgZG9jcy4nICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XFxuXFx0XFx0XFx0dmFyIHggPSAyICogbmVhciAvICggcmlnaHQgLSBsZWZ0ICk7XFxuXFx0XFx0XFx0dmFyIHkgPSAyICogbmVhciAvICggdG9wIC0gYm90dG9tICk7XFxuXFxuXFx0XFx0XFx0dmFyIGEgPSAoIHJpZ2h0ICsgbGVmdCApIC8gKCByaWdodCAtIGxlZnQgKTtcXG5cXHRcXHRcXHR2YXIgYiA9ICggdG9wICsgYm90dG9tICkgLyAoIHRvcCAtIGJvdHRvbSApO1xcblxcdFxcdFxcdHZhciBjID0gLSAoIGZhciArIG5lYXIgKSAvICggZmFyIC0gbmVhciApO1xcblxcdFxcdFxcdHZhciBkID0gLSAyICogZmFyICogbmVhciAvICggZmFyIC0gbmVhciApO1xcblxcblxcdFxcdFxcdHRlWyAwIF0gPSB4O1xcdHRlWyA0IF0gPSAwO1xcdHRlWyA4IF0gPSBhO1xcdHRlWyAxMiBdID0gMDtcXG5cXHRcXHRcXHR0ZVsgMSBdID0gMDtcXHR0ZVsgNSBdID0geTtcXHR0ZVsgOSBdID0gYjtcXHR0ZVsgMTMgXSA9IDA7XFxuXFx0XFx0XFx0dGVbIDIgXSA9IDA7XFx0dGVbIDYgXSA9IDA7XFx0dGVbIDEwIF0gPSBjO1xcdHRlWyAxNCBdID0gZDtcXG5cXHRcXHRcXHR0ZVsgMyBdID0gMDtcXHR0ZVsgNyBdID0gMDtcXHR0ZVsgMTEgXSA9IC0gMTtcXHR0ZVsgMTUgXSA9IDA7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRtYWtlT3J0aG9ncmFwaGljOiBmdW5jdGlvbiAoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkge1xcblxcblxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XFxuXFx0XFx0XFx0dmFyIHcgPSAxLjAgLyAoIHJpZ2h0IC0gbGVmdCApO1xcblxcdFxcdFxcdHZhciBoID0gMS4wIC8gKCB0b3AgLSBib3R0b20gKTtcXG5cXHRcXHRcXHR2YXIgcCA9IDEuMCAvICggZmFyIC0gbmVhciApO1xcblxcblxcdFxcdFxcdHZhciB4ID0gKCByaWdodCArIGxlZnQgKSAqIHc7XFxuXFx0XFx0XFx0dmFyIHkgPSAoIHRvcCArIGJvdHRvbSApICogaDtcXG5cXHRcXHRcXHR2YXIgeiA9ICggZmFyICsgbmVhciApICogcDtcXG5cXG5cXHRcXHRcXHR0ZVsgMCBdID0gMiAqIHc7XFx0dGVbIDQgXSA9IDA7XFx0dGVbIDggXSA9IDA7XFx0dGVbIDEyIF0gPSAtIHg7XFxuXFx0XFx0XFx0dGVbIDEgXSA9IDA7XFx0dGVbIDUgXSA9IDIgKiBoO1xcdHRlWyA5IF0gPSAwO1xcdHRlWyAxMyBdID0gLSB5O1xcblxcdFxcdFxcdHRlWyAyIF0gPSAwO1xcdHRlWyA2IF0gPSAwO1xcdHRlWyAxMCBdID0gLSAyICogcDtcXHR0ZVsgMTQgXSA9IC0gejtcXG5cXHRcXHRcXHR0ZVsgMyBdID0gMDtcXHR0ZVsgNyBdID0gMDtcXHR0ZVsgMTEgXSA9IDA7XFx0dGVbIDE1IF0gPSAxO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZXF1YWxzOiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xcblxcdFxcdFxcdHZhciBtZSA9IG1hdHJpeC5lbGVtZW50cztcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCAxNjsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHRlWyBpIF0gIT09IG1lWyBpIF0gKSByZXR1cm4gZmFsc2U7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgMTY7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50c1sgaSBdID0gYXJyYXlbIGkgKyBvZmZzZXQgXTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcXG5cXHRcXHRcXHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcXG5cXG5cXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xcblxcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgXSA9IHRlWyAwIF07XFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRlWyAxIF07XFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRlWyAyIF07XFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRlWyAzIF07XFxuXFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDUgXSA9IHRlWyA1IF07XFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XFxuXFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDggXSA9IHRlWyA4IF07XFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDkgXSA9IHRlWyA5IF07XFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDEwIF0gPSB0ZVsgMTAgXTtcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgMTEgXSA9IHRlWyAxMSBdO1xcblxcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyAxMiBdID0gdGVbIDEyIF07XFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDEzIF0gPSB0ZVsgMTMgXTtcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgMTQgXSA9IHRlWyAxNCBdO1xcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyAxNSBdID0gdGVbIDE1IF07XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGFycmF5O1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxcblxcdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBRdWF0ZXJuaW9uKCB4LCB5LCB6LCB3ICkge1xcblxcblxcdFxcdHRoaXMuX3ggPSB4IHx8IDA7XFxuXFx0XFx0dGhpcy5feSA9IHkgfHwgMDtcXG5cXHRcXHR0aGlzLl96ID0geiB8fCAwO1xcblxcdFxcdHRoaXMuX3cgPSAoIHcgIT09IHVuZGVmaW5lZCApID8gdyA6IDE7XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5hc3NpZ24oIFF1YXRlcm5pb24sIHtcXG5cXG5cXHRcXHRzbGVycDogZnVuY3Rpb24gKCBxYSwgcWIsIHFtLCB0ICkge1xcblxcblxcdFxcdFxcdHJldHVybiBxbS5jb3B5KCBxYSApLnNsZXJwKCBxYiwgdCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2xlcnBGbGF0OiBmdW5jdGlvbiAoIGRzdCwgZHN0T2Zmc2V0LCBzcmMwLCBzcmNPZmZzZXQwLCBzcmMxLCBzcmNPZmZzZXQxLCB0ICkge1xcblxcblxcdFxcdFxcdC8vIGZ1enotZnJlZSwgYXJyYXktYmFzZWQgUXVhdGVybmlvbiBTTEVSUCBvcGVyYXRpb25cXG5cXG5cXHRcXHRcXHR2YXIgeDAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMCBdLFxcblxcdFxcdFxcdFxcdHkwID0gc3JjMFsgc3JjT2Zmc2V0MCArIDEgXSxcXG5cXHRcXHRcXHRcXHR6MCA9IHNyYzBbIHNyY09mZnNldDAgKyAyIF0sXFxuXFx0XFx0XFx0XFx0dzAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMyBdLFxcblxcblxcdFxcdFxcdFxcdHgxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDAgXSxcXG5cXHRcXHRcXHRcXHR5MSA9IHNyYzFbIHNyY09mZnNldDEgKyAxIF0sXFxuXFx0XFx0XFx0XFx0ejEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMiBdLFxcblxcdFxcdFxcdFxcdHcxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDMgXTtcXG5cXG5cXHRcXHRcXHRpZiAoIHcwICE9PSB3MSB8fCB4MCAhPT0geDEgfHwgeTAgIT09IHkxIHx8IHowICE9PSB6MSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcyA9IDEgLSB0LFxcblxcblxcdFxcdFxcdFxcdFxcdGNvcyA9IHgwICogeDEgKyB5MCAqIHkxICsgejAgKiB6MSArIHcwICogdzEsXFxuXFxuXFx0XFx0XFx0XFx0XFx0ZGlyID0gKCBjb3MgPj0gMCA/IDEgOiAtIDEgKSxcXG5cXHRcXHRcXHRcXHRcXHRzcXJTaW4gPSAxIC0gY29zICogY29zO1xcblxcblxcdFxcdFxcdFxcdC8vIFNraXAgdGhlIFNsZXJwIGZvciB0aW55IHN0ZXBzIHRvIGF2b2lkIG51bWVyaWMgcHJvYmxlbXM6XFxuXFx0XFx0XFx0XFx0aWYgKCBzcXJTaW4gPiBOdW1iZXIuRVBTSUxPTiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgc2luID0gTWF0aC5zcXJ0KCBzcXJTaW4gKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRsZW4gPSBNYXRoLmF0YW4yKCBzaW4sIGNvcyAqIGRpciApO1xcblxcblxcdFxcdFxcdFxcdFxcdHMgPSBNYXRoLnNpbiggcyAqIGxlbiApIC8gc2luO1xcblxcdFxcdFxcdFxcdFxcdHQgPSBNYXRoLnNpbiggdCAqIGxlbiApIC8gc2luO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR2YXIgdERpciA9IHQgKiBkaXI7XFxuXFxuXFx0XFx0XFx0XFx0eDAgPSB4MCAqIHMgKyB4MSAqIHREaXI7XFxuXFx0XFx0XFx0XFx0eTAgPSB5MCAqIHMgKyB5MSAqIHREaXI7XFxuXFx0XFx0XFx0XFx0ejAgPSB6MCAqIHMgKyB6MSAqIHREaXI7XFxuXFx0XFx0XFx0XFx0dzAgPSB3MCAqIHMgKyB3MSAqIHREaXI7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gTm9ybWFsaXplIGluIGNhc2Ugd2UganVzdCBkaWQgYSBsZXJwOlxcblxcdFxcdFxcdFxcdGlmICggcyA9PT0gMSAtIHQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGYgPSAxIC8gTWF0aC5zcXJ0KCB4MCAqIHgwICsgeTAgKiB5MCArIHowICogejAgKyB3MCAqIHcwICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0eDAgKj0gZjtcXG5cXHRcXHRcXHRcXHRcXHR5MCAqPSBmO1xcblxcdFxcdFxcdFxcdFxcdHowICo9IGY7XFxuXFx0XFx0XFx0XFx0XFx0dzAgKj0gZjtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGRzdFsgZHN0T2Zmc2V0IF0gPSB4MDtcXG5cXHRcXHRcXHRkc3RbIGRzdE9mZnNldCArIDEgXSA9IHkwO1xcblxcdFxcdFxcdGRzdFsgZHN0T2Zmc2V0ICsgMiBdID0gejA7XFxuXFx0XFx0XFx0ZHN0WyBkc3RPZmZzZXQgKyAzIF0gPSB3MDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBRdWF0ZXJuaW9uLnByb3RvdHlwZSwge1xcblxcblxcdFxcdHg6IHtcXG5cXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5feDtcXG5cXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl94ID0gdmFsdWU7XFxuXFx0XFx0XFx0XFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0eToge1xcblxcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLl95O1xcblxcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuX3kgPSB2YWx1ZTtcXG5cXHRcXHRcXHRcXHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR6OiB7XFxuXFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuX3o7XFxuXFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5feiA9IHZhbHVlO1xcblxcdFxcdFxcdFxcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHc6IHtcXG5cXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5fdztcXG5cXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl93ID0gdmFsdWU7XFxuXFx0XFx0XFx0XFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggUXVhdGVybmlvbi5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLl94ID0geDtcXG5cXHRcXHRcXHR0aGlzLl95ID0geTtcXG5cXHRcXHRcXHR0aGlzLl96ID0gejtcXG5cXHRcXHRcXHR0aGlzLl93ID0gdztcXG5cXG5cXHRcXHRcXHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl93ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHF1YXRlcm5pb24gKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5feCA9IHF1YXRlcm5pb24ueDtcXG5cXHRcXHRcXHR0aGlzLl95ID0gcXVhdGVybmlvbi55O1xcblxcdFxcdFxcdHRoaXMuX3ogPSBxdWF0ZXJuaW9uLno7XFxuXFx0XFx0XFx0dGhpcy5fdyA9IHF1YXRlcm5pb24udztcXG5cXG5cXHRcXHRcXHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldEZyb21FdWxlcjogZnVuY3Rpb24gKCBldWxlciwgdXBkYXRlICkge1xcblxcblxcdFxcdFxcdGlmICggISAoIGV1bGVyICYmIGV1bGVyLmlzRXVsZXIgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5RdWF0ZXJuaW9uOiAuc2V0RnJvbUV1bGVyKCkgbm93IGV4cGVjdHMgYW4gRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciB4ID0gZXVsZXIuX3gsIHkgPSBldWxlci5feSwgeiA9IGV1bGVyLl96LCBvcmRlciA9IGV1bGVyLm9yZGVyO1xcblxcblxcdFxcdFxcdC8vIGh0dHA6Ly93d3cubWF0aHdvcmtzLmNvbS9tYXRsYWJjZW50cmFsL2ZpbGVleGNoYW5nZS9cXG5cXHRcXHRcXHQvLyBcXHQyMDY5Ni1mdW5jdGlvbi10by1jb252ZXJ0LWJldHdlZW4tZGNtLWV1bGVyLWFuZ2xlcy1xdWF0ZXJuaW9ucy1hbmQtZXVsZXItdmVjdG9ycy9cXG5cXHRcXHRcXHQvL1xcdGNvbnRlbnQvU3BpbkNhbGMubVxcblxcblxcdFxcdFxcdHZhciBjb3MgPSBNYXRoLmNvcztcXG5cXHRcXHRcXHR2YXIgc2luID0gTWF0aC5zaW47XFxuXFxuXFx0XFx0XFx0dmFyIGMxID0gY29zKCB4IC8gMiApO1xcblxcdFxcdFxcdHZhciBjMiA9IGNvcyggeSAvIDIgKTtcXG5cXHRcXHRcXHR2YXIgYzMgPSBjb3MoIHogLyAyICk7XFxuXFxuXFx0XFx0XFx0dmFyIHMxID0gc2luKCB4IC8gMiApO1xcblxcdFxcdFxcdHZhciBzMiA9IHNpbiggeSAvIDIgKTtcXG5cXHRcXHRcXHR2YXIgczMgPSBzaW4oIHogLyAyICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBvcmRlciA9PT0gJ1hZWicgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcXG5cXHRcXHRcXHRcXHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xcblxcdFxcdFxcdFxcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XFxuXFx0XFx0XFx0XFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1lYWicgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcXG5cXHRcXHRcXHRcXHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xcblxcdFxcdFxcdFxcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XFxuXFx0XFx0XFx0XFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pYWScgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcXG5cXHRcXHRcXHRcXHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xcblxcdFxcdFxcdFxcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XFxuXFx0XFx0XFx0XFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pZWCcgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcXG5cXHRcXHRcXHRcXHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xcblxcdFxcdFxcdFxcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XFxuXFx0XFx0XFx0XFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1laWCcgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcXG5cXHRcXHRcXHRcXHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xcblxcdFxcdFxcdFxcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XFxuXFx0XFx0XFx0XFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1haWScgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcXG5cXHRcXHRcXHRcXHR0aGlzLl95ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xcblxcdFxcdFxcdFxcdHRoaXMuX3ogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XFxuXFx0XFx0XFx0XFx0dGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCB1cGRhdGUgIT09IGZhbHNlICkgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRGcm9tQXhpc0FuZ2xlOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xcblxcblxcdFxcdFxcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9hbmdsZVRvUXVhdGVybmlvbi9pbmRleC5odG1cXG5cXG5cXHRcXHRcXHQvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxcblxcblxcdFxcdFxcdHZhciBoYWxmQW5nbGUgPSBhbmdsZSAvIDIsIHMgPSBNYXRoLnNpbiggaGFsZkFuZ2xlICk7XFxuXFxuXFx0XFx0XFx0dGhpcy5feCA9IGF4aXMueCAqIHM7XFxuXFx0XFx0XFx0dGhpcy5feSA9IGF4aXMueSAqIHM7XFxuXFx0XFx0XFx0dGhpcy5feiA9IGF4aXMueiAqIHM7XFxuXFx0XFx0XFx0dGhpcy5fdyA9IE1hdGguY29zKCBoYWxmQW5nbGUgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldEZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xcblxcblxcdFxcdFxcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb1F1YXRlcm5pb24vaW5kZXguaHRtXFxuXFxuXFx0XFx0XFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcXG5cXG5cXHRcXHRcXHR2YXIgdGUgPSBtLmVsZW1lbnRzLFxcblxcblxcdFxcdFxcdFxcdG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF0sXFxuXFx0XFx0XFx0XFx0bTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXSxcXG5cXHRcXHRcXHRcXHRtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXSxcXG5cXG5cXHRcXHRcXHRcXHR0cmFjZSA9IG0xMSArIG0yMiArIG0zMyxcXG5cXHRcXHRcXHRcXHRzO1xcblxcblxcdFxcdFxcdGlmICggdHJhY2UgPiAwICkge1xcblxcblxcdFxcdFxcdFxcdHMgPSAwLjUgLyBNYXRoLnNxcnQoIHRyYWNlICsgMS4wICk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5fdyA9IDAuMjUgLyBzO1xcblxcdFxcdFxcdFxcdHRoaXMuX3ggPSAoIG0zMiAtIG0yMyApICogcztcXG5cXHRcXHRcXHRcXHR0aGlzLl95ID0gKCBtMTMgLSBtMzEgKSAqIHM7XFxuXFx0XFx0XFx0XFx0dGhpcy5feiA9ICggbTIxIC0gbTEyICkgKiBzO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG0xMSA+IG0yMiAmJiBtMTEgPiBtMzMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTExIC0gbTIyIC0gbTMzICk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5fdyA9ICggbTMyIC0gbTIzICkgLyBzO1xcblxcdFxcdFxcdFxcdHRoaXMuX3ggPSAwLjI1ICogcztcXG5cXHRcXHRcXHRcXHR0aGlzLl95ID0gKCBtMTIgKyBtMjEgKSAvIHM7XFxuXFx0XFx0XFx0XFx0dGhpcy5feiA9ICggbTEzICsgbTMxICkgLyBzO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG0yMiA+IG0zMyApIHtcXG5cXG5cXHRcXHRcXHRcXHRzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMjIgLSBtMTEgLSBtMzMgKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl93ID0gKCBtMTMgLSBtMzEgKSAvIHM7XFxuXFx0XFx0XFx0XFx0dGhpcy5feCA9ICggbTEyICsgbTIxICkgLyBzO1xcblxcdFxcdFxcdFxcdHRoaXMuX3kgPSAwLjI1ICogcztcXG5cXHRcXHRcXHRcXHR0aGlzLl96ID0gKCBtMjMgKyBtMzIgKSAvIHM7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMzMgLSBtMTEgLSBtMjIgKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl93ID0gKCBtMjEgLSBtMTIgKSAvIHM7XFxuXFx0XFx0XFx0XFx0dGhpcy5feCA9ICggbTEzICsgbTMxICkgLyBzO1xcblxcdFxcdFxcdFxcdHRoaXMuX3kgPSAoIG0yMyArIG0zMiApIC8gcztcXG5cXHRcXHRcXHRcXHR0aGlzLl96ID0gMC4yNSAqIHM7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0RnJvbVVuaXRWZWN0b3JzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Ly8gYXNzdW1lcyBkaXJlY3Rpb24gdmVjdG9ycyB2RnJvbSBhbmQgdlRvIGFyZSBub3JtYWxpemVkXFxuXFxuXFx0XFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgcjtcXG5cXG5cXHRcXHRcXHR2YXIgRVBTID0gMC4wMDAwMDE7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHNldEZyb21Vbml0VmVjdG9ycyggdkZyb20sIHZUbyApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0XFx0ciA9IHZGcm9tLmRvdCggdlRvICkgKyAxO1xcblxcblxcdFxcdFxcdFxcdGlmICggciA8IEVQUyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyID0gMDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIE1hdGguYWJzKCB2RnJvbS54ICkgPiBNYXRoLmFicyggdkZyb20ueiApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHYxLnNldCggLSB2RnJvbS55LCB2RnJvbS54LCAwICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2MS5zZXQoIDAsIC0gdkZyb20ueiwgdkZyb20ueSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdHYxLmNyb3NzVmVjdG9ycyggdkZyb20sIHZUbyApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl94ID0gdjEueDtcXG5cXHRcXHRcXHRcXHR0aGlzLl95ID0gdjEueTtcXG5cXHRcXHRcXHRcXHR0aGlzLl96ID0gdjEuejtcXG5cXHRcXHRcXHRcXHR0aGlzLl93ID0gcjtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRpbnZlcnNlOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuY29uanVnYXRlKCkubm9ybWFsaXplKCk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb25qdWdhdGU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLl94ICo9IC0gMTtcXG5cXHRcXHRcXHR0aGlzLl95ICo9IC0gMTtcXG5cXHRcXHRcXHR0aGlzLl96ICo9IC0gMTtcXG5cXG5cXHRcXHRcXHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGRvdDogZnVuY3Rpb24gKCB2ICkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLl94ICogdi5feCArIHRoaXMuX3kgKiB2Ll95ICsgdGhpcy5feiAqIHYuX3ogKyB0aGlzLl93ICogdi5fdztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bGVuZ3RoOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5feCAqIHRoaXMuX3ggKyB0aGlzLl95ICogdGhpcy5feSArIHRoaXMuX3ogKiB0aGlzLl96ICsgdGhpcy5fdyAqIHRoaXMuX3cgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBsID0gdGhpcy5sZW5ndGgoKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGwgPT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5feCA9IDA7XFxuXFx0XFx0XFx0XFx0dGhpcy5feSA9IDA7XFxuXFx0XFx0XFx0XFx0dGhpcy5feiA9IDA7XFxuXFx0XFx0XFx0XFx0dGhpcy5fdyA9IDE7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRsID0gMSAvIGw7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5feCA9IHRoaXMuX3ggKiBsO1xcblxcdFxcdFxcdFxcdHRoaXMuX3kgPSB0aGlzLl95ICogbDtcXG5cXHRcXHRcXHRcXHR0aGlzLl96ID0gdGhpcy5feiAqIGw7XFxuXFx0XFx0XFx0XFx0dGhpcy5fdyA9IHRoaXMuX3cgKiBsO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG11bHRpcGx5OiBmdW5jdGlvbiAoIHEsIHAgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBwICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUXVhdGVybmlvbjogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlRdWF0ZXJuaW9ucyggYSwgYiApIGluc3RlYWQuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHEsIHAgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggdGhpcywgcSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cHJlbXVsdGlwbHk6IGZ1bmN0aW9uICggcSApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCBxLCB0aGlzICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRtdWx0aXBseVF1YXRlcm5pb25zOiBmdW5jdGlvbiAoIGEsIGIgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gZnJvbSBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL3JlYWxOb3JtZWRBbGdlYnJhL3F1YXRlcm5pb25zL2NvZGUvaW5kZXguaHRtXFxuXFxuXFx0XFx0XFx0dmFyIHFheCA9IGEuX3gsIHFheSA9IGEuX3ksIHFheiA9IGEuX3osIHFhdyA9IGEuX3c7XFxuXFx0XFx0XFx0dmFyIHFieCA9IGIuX3gsIHFieSA9IGIuX3ksIHFieiA9IGIuX3osIHFidyA9IGIuX3c7XFxuXFxuXFx0XFx0XFx0dGhpcy5feCA9IHFheCAqIHFidyArIHFhdyAqIHFieCArIHFheSAqIHFieiAtIHFheiAqIHFieTtcXG5cXHRcXHRcXHR0aGlzLl95ID0gcWF5ICogcWJ3ICsgcWF3ICogcWJ5ICsgcWF6ICogcWJ4IC0gcWF4ICogcWJ6O1xcblxcdFxcdFxcdHRoaXMuX3ogPSBxYXogKiBxYncgKyBxYXcgKiBxYnogKyBxYXggKiBxYnkgLSBxYXkgKiBxYng7XFxuXFx0XFx0XFx0dGhpcy5fdyA9IHFhdyAqIHFidyAtIHFheCAqIHFieCAtIHFheSAqIHFieSAtIHFheiAqIHFiejtcXG5cXG5cXHRcXHRcXHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNsZXJwOiBmdW5jdGlvbiAoIHFiLCB0ICkge1xcblxcblxcdFxcdFxcdGlmICggdCA9PT0gMCApIHJldHVybiB0aGlzO1xcblxcdFxcdFxcdGlmICggdCA9PT0gMSApIHJldHVybiB0aGlzLmNvcHkoIHFiICk7XFxuXFxuXFx0XFx0XFx0dmFyIHggPSB0aGlzLl94LCB5ID0gdGhpcy5feSwgeiA9IHRoaXMuX3osIHcgPSB0aGlzLl93O1xcblxcblxcdFxcdFxcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvc2xlcnAvXFxuXFxuXFx0XFx0XFx0dmFyIGNvc0hhbGZUaGV0YSA9IHcgKiBxYi5fdyArIHggKiBxYi5feCArIHkgKiBxYi5feSArIHogKiBxYi5fejtcXG5cXG5cXHRcXHRcXHRpZiAoIGNvc0hhbGZUaGV0YSA8IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5fdyA9IC0gcWIuX3c7XFxuXFx0XFx0XFx0XFx0dGhpcy5feCA9IC0gcWIuX3g7XFxuXFx0XFx0XFx0XFx0dGhpcy5feSA9IC0gcWIuX3k7XFxuXFx0XFx0XFx0XFx0dGhpcy5feiA9IC0gcWIuX3o7XFxuXFxuXFx0XFx0XFx0XFx0Y29zSGFsZlRoZXRhID0gLSBjb3NIYWxmVGhldGE7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmNvcHkoIHFiICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggY29zSGFsZlRoZXRhID49IDEuMCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl93ID0gdztcXG5cXHRcXHRcXHRcXHR0aGlzLl94ID0geDtcXG5cXHRcXHRcXHRcXHR0aGlzLl95ID0geTtcXG5cXHRcXHRcXHRcXHR0aGlzLl96ID0gejtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIHNpbkhhbGZUaGV0YSA9IE1hdGguc3FydCggMS4wIC0gY29zSGFsZlRoZXRhICogY29zSGFsZlRoZXRhICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBNYXRoLmFicyggc2luSGFsZlRoZXRhICkgPCAwLjAwMSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl93ID0gMC41ICogKCB3ICsgdGhpcy5fdyApO1xcblxcdFxcdFxcdFxcdHRoaXMuX3ggPSAwLjUgKiAoIHggKyB0aGlzLl94ICk7XFxuXFx0XFx0XFx0XFx0dGhpcy5feSA9IDAuNSAqICggeSArIHRoaXMuX3kgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLl96ID0gMC41ICogKCB6ICsgdGhpcy5feiApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgaGFsZlRoZXRhID0gTWF0aC5hdGFuMiggc2luSGFsZlRoZXRhLCBjb3NIYWxmVGhldGEgKTtcXG5cXHRcXHRcXHR2YXIgcmF0aW9BID0gTWF0aC5zaW4oICggMSAtIHQgKSAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhLFxcblxcdFxcdFxcdFxcdHJhdGlvQiA9IE1hdGguc2luKCB0ICogaGFsZlRoZXRhICkgLyBzaW5IYWxmVGhldGE7XFxuXFxuXFx0XFx0XFx0dGhpcy5fdyA9ICggdyAqIHJhdGlvQSArIHRoaXMuX3cgKiByYXRpb0IgKTtcXG5cXHRcXHRcXHR0aGlzLl94ID0gKCB4ICogcmF0aW9BICsgdGhpcy5feCAqIHJhdGlvQiApO1xcblxcdFxcdFxcdHRoaXMuX3kgPSAoIHkgKiByYXRpb0EgKyB0aGlzLl95ICogcmF0aW9CICk7XFxuXFx0XFx0XFx0dGhpcy5feiA9ICggeiAqIHJhdGlvQSArIHRoaXMuX3ogKiByYXRpb0IgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGVxdWFsczogZnVuY3Rpb24gKCBxdWF0ZXJuaW9uICkge1xcblxcblxcdFxcdFxcdHJldHVybiAoIHF1YXRlcm5pb24uX3ggPT09IHRoaXMuX3ggKSAmJiAoIHF1YXRlcm5pb24uX3kgPT09IHRoaXMuX3kgKSAmJiAoIHF1YXRlcm5pb24uX3ogPT09IHRoaXMuX3ogKSAmJiAoIHF1YXRlcm5pb24uX3cgPT09IHRoaXMuX3cgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xcblxcblxcdFxcdFxcdHRoaXMuX3ggPSBhcnJheVsgb2Zmc2V0IF07XFxuXFx0XFx0XFx0dGhpcy5feSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XFxuXFx0XFx0XFx0dGhpcy5feiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XFxuXFx0XFx0XFx0dGhpcy5fdyA9IGFycmF5WyBvZmZzZXQgKyAzIF07XFxuXFxuXFx0XFx0XFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcXG5cXHRcXHRcXHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcXG5cXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLl94O1xcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLl95O1xcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLl96O1xcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLl93O1xcblxcblxcdFxcdFxcdHJldHVybiBhcnJheTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG9uQ2hhbmdlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xcblxcblxcdFxcdFxcdHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0b25DaGFuZ2VDYWxsYmFjazogZnVuY3Rpb24gKCkge31cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIGtpbGUgLyBodHRwOi8va2lsZS5zdHJhdmFnYW56YS5vcmcvXFxuXFx0ICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cXG5cXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xcblxcdCAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXFxuXFx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gVmVjdG9yMyggeCwgeSwgeiApIHtcXG5cXG5cXHRcXHR0aGlzLnggPSB4IHx8IDA7XFxuXFx0XFx0dGhpcy55ID0geSB8fCAwO1xcblxcdFxcdHRoaXMueiA9IHogfHwgMDtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggVmVjdG9yMy5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRpc1ZlY3RvcjM6IHRydWUsXFxuXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0geDtcXG5cXHRcXHRcXHR0aGlzLnkgPSB5O1xcblxcdFxcdFxcdHRoaXMueiA9IHo7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9IHNjYWxhcjtcXG5cXHRcXHRcXHR0aGlzLnkgPSBzY2FsYXI7XFxuXFx0XFx0XFx0dGhpcy56ID0gc2NhbGFyO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0WDogZnVuY3Rpb24gKCB4ICkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9IHg7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRZOiBmdW5jdGlvbiAoIHkgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy55ID0geTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFo6IGZ1bmN0aW9uICggeiApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnogPSB6O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4LCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRzd2l0Y2ggKCBpbmRleCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcXG5cXHRcXHRcXHRcXHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcXG5cXHRcXHRcXHRcXHRjYXNlIDI6IHRoaXMueiA9IHZhbHVlOyBicmVhaztcXG5cXHRcXHRcXHRcXHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcXG5cXG5cXHRcXHRcXHRzd2l0Y2ggKCBpbmRleCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjYXNlIDA6IHJldHVybiB0aGlzLng7XFxuXFx0XFx0XFx0XFx0Y2FzZSAxOiByZXR1cm4gdGhpcy55O1xcblxcdFxcdFxcdFxcdGNhc2UgMjogcmV0dXJuIHRoaXMuejtcXG5cXHRcXHRcXHRcXHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLngsIHRoaXMueSwgdGhpcy56ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gdi54O1xcblxcdFxcdFxcdHRoaXMueSA9IHYueTtcXG5cXHRcXHRcXHR0aGlzLnogPSB2Lno7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRhZGQ6IGZ1bmN0aW9uICggdiwgdyApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy54ICs9IHYueDtcXG5cXHRcXHRcXHR0aGlzLnkgKz0gdi55O1xcblxcdFxcdFxcdHRoaXMueiArPSB2Lno7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRhZGRTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggKz0gcztcXG5cXHRcXHRcXHR0aGlzLnkgKz0gcztcXG5cXHRcXHRcXHR0aGlzLnogKz0gcztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGFkZFZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSBhLnggKyBiLng7XFxuXFx0XFx0XFx0dGhpcy55ID0gYS55ICsgYi55O1xcblxcdFxcdFxcdHRoaXMueiA9IGEueiArIGIuejtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGFkZFNjYWxlZFZlY3RvcjogZnVuY3Rpb24gKCB2LCBzICkge1xcblxcblxcdFxcdFxcdHRoaXMueCArPSB2LnggKiBzO1xcblxcdFxcdFxcdHRoaXMueSArPSB2LnkgKiBzO1xcblxcdFxcdFxcdHRoaXMueiArPSB2LnogKiBzO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMueCAtPSB2Lng7XFxuXFx0XFx0XFx0dGhpcy55IC09IHYueTtcXG5cXHRcXHRcXHR0aGlzLnogLT0gdi56O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c3ViU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54IC09IHM7XFxuXFx0XFx0XFx0dGhpcy55IC09IHM7XFxuXFx0XFx0XFx0dGhpcy56IC09IHM7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzdWJWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gYS54IC0gYi54O1xcblxcdFxcdFxcdHRoaXMueSA9IGEueSAtIGIueTtcXG5cXHRcXHRcXHR0aGlzLnogPSBhLnogLSBiLno7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRtdWx0aXBseTogZnVuY3Rpb24gKCB2LCB3ICkge1xcblxcblxcdFxcdFxcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5VmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLm11bHRpcGx5VmVjdG9ycyggdiwgdyApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLnggKj0gdi54O1xcblxcdFxcdFxcdHRoaXMueSAqPSB2Lnk7XFxuXFx0XFx0XFx0dGhpcy56ICo9IHYuejtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggKj0gc2NhbGFyO1xcblxcdFxcdFxcdHRoaXMueSAqPSBzY2FsYXI7XFxuXFx0XFx0XFx0dGhpcy56ICo9IHNjYWxhcjtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG11bHRpcGx5VmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9IGEueCAqIGIueDtcXG5cXHRcXHRcXHR0aGlzLnkgPSBhLnkgKiBiLnk7XFxuXFx0XFx0XFx0dGhpcy56ID0gYS56ICogYi56O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YXBwbHlFdWxlcjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlFdWxlciggZXVsZXIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCAhICggZXVsZXIgJiYgZXVsZXIuaXNFdWxlciApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5WZWN0b3IzOiAuYXBwbHlFdWxlcigpIG5vdyBleHBlY3RzIGFuIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciApICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0YXBwbHlBeGlzQW5nbGU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGFwcGx5QXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKSApO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdGFwcGx5TWF0cml4MzogZnVuY3Rpb24gKCBtICkge1xcblxcblxcdFxcdFxcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xcblxcdFxcdFxcdHZhciBlID0gbS5lbGVtZW50cztcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgMyBdICogeSArIGVbIDYgXSAqIHo7XFxuXFx0XFx0XFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA3IF0gKiB6O1xcblxcdFxcdFxcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOCBdICogejtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtICkge1xcblxcblxcdFxcdFxcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xcblxcdFxcdFxcdHZhciBlID0gbS5lbGVtZW50cztcXG5cXG5cXHRcXHRcXHR2YXIgdyA9IDEgLyAoIGVbIDMgXSAqIHggKyBlWyA3IF0gKiB5ICsgZVsgMTEgXSAqIHogKyBlWyAxNSBdICk7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gKCBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAqIHogKyBlWyAxMiBdICkgKiB3O1xcblxcdFxcdFxcdHRoaXMueSA9ICggZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gKiB6ICsgZVsgMTMgXSApICogdztcXG5cXHRcXHRcXHR0aGlzLnogPSAoIGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHogKyBlWyAxNCBdICkgKiB3O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YXBwbHlRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XFxuXFx0XFx0XFx0dmFyIHF4ID0gcS54LCBxeSA9IHEueSwgcXogPSBxLnosIHF3ID0gcS53O1xcblxcblxcdFxcdFxcdC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjdG9yXFxuXFxuXFx0XFx0XFx0dmFyIGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xcblxcdFxcdFxcdHZhciBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogejtcXG5cXHRcXHRcXHR2YXIgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHg7XFxuXFx0XFx0XFx0dmFyIGl3ID0gLSBxeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XFxuXFxuXFx0XFx0XFx0Ly8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxcblxcblxcdFxcdFxcdHRoaXMueCA9IGl4ICogcXcgKyBpdyAqIC0gcXggKyBpeSAqIC0gcXogLSBpeiAqIC0gcXk7XFxuXFx0XFx0XFx0dGhpcy55ID0gaXkgKiBxdyArIGl3ICogLSBxeSArIGl6ICogLSBxeCAtIGl4ICogLSBxejtcXG5cXHRcXHRcXHR0aGlzLnogPSBpeiAqIHF3ICsgaXcgKiAtIHF6ICsgaXggKiAtIHF5IC0gaXkgKiAtIHF4O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cHJvamVjdDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBwcm9qZWN0KCBjYW1lcmEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0bWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBtYXRyaXguZ2V0SW52ZXJzZSggY2FtZXJhLm1hdHJpeFdvcmxkICkgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdHVucHJvamVjdDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiB1bnByb2plY3QoIGNhbWVyYSApIHtcXG5cXG5cXHRcXHRcXHRcXHRtYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkLCBtYXRyaXguZ2V0SW52ZXJzZSggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKSApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0dHJhbnNmb3JtRGlyZWN0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XFxuXFxuXFx0XFx0XFx0Ly8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgYWZmaW5lIG1hdHJpeFxcblxcdFxcdFxcdC8vIHZlY3RvciBpbnRlcnByZXRlZCBhcyBhIGRpcmVjdGlvblxcblxcblxcdFxcdFxcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xcblxcdFxcdFxcdHZhciBlID0gbS5lbGVtZW50cztcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAqIHo7XFxuXFx0XFx0XFx0dGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gKiB6O1xcblxcdFxcdFxcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHo7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkaXZpZGU6IGZ1bmN0aW9uICggdiApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggLz0gdi54O1xcblxcdFxcdFxcdHRoaXMueSAvPSB2Lnk7XFxuXFx0XFx0XFx0dGhpcy56IC89IHYuejtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGRpdmlkZVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBzY2FsYXIgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG1pbjogZnVuY3Rpb24gKCB2ICkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9IE1hdGgubWluKCB0aGlzLngsIHYueCApO1xcblxcdFxcdFxcdHRoaXMueSA9IE1hdGgubWluKCB0aGlzLnksIHYueSApO1xcblxcdFxcdFxcdHRoaXMueiA9IE1hdGgubWluKCB0aGlzLnosIHYueiApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bWF4OiBmdW5jdGlvbiAoIHYgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gTWF0aC5tYXgoIHRoaXMueCwgdi54ICk7XFxuXFx0XFx0XFx0dGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XFxuXFx0XFx0XFx0dGhpcy56ID0gTWF0aC5tYXgoIHRoaXMueiwgdi56ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbGFtcDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcXG5cXG5cXHRcXHRcXHQvLyBhc3N1bWVzIG1pbiA8IG1heCwgY29tcG9uZW50d2lzZVxcblxcblxcdFxcdFxcdHRoaXMueCA9IE1hdGgubWF4KCBtaW4ueCwgTWF0aC5taW4oIG1heC54LCB0aGlzLnggKSApO1xcblxcdFxcdFxcdHRoaXMueSA9IE1hdGgubWF4KCBtaW4ueSwgTWF0aC5taW4oIG1heC55LCB0aGlzLnkgKSApO1xcblxcdFxcdFxcdHRoaXMueiA9IE1hdGgubWF4KCBtaW4ueiwgTWF0aC5taW4oIG1heC56LCB0aGlzLnogKSApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xhbXBTY2FsYXI6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgbWluID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgbWF4ID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gY2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xcblxcblxcdFxcdFxcdFxcdG1pbi5zZXQoIG1pblZhbCwgbWluVmFsLCBtaW5WYWwgKTtcXG5cXHRcXHRcXHRcXHRtYXguc2V0KCBtYXhWYWwsIG1heFZhbCwgbWF4VmFsICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuY2xhbXAoIG1pbiwgbWF4ICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0Y2xhbXBMZW5ndGg6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCBsZW5ndGggfHwgMSApLm11bHRpcGx5U2NhbGFyKCBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCBsZW5ndGggKSApICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRmbG9vcjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xcblxcdFxcdFxcdHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xcblxcdFxcdFxcdHRoaXMueiA9IE1hdGguZmxvb3IoIHRoaXMueiApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2VpbDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XFxuXFx0XFx0XFx0dGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcXG5cXHRcXHRcXHR0aGlzLnogPSBNYXRoLmNlaWwoIHRoaXMueiApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcXG5cXHRcXHRcXHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcXG5cXHRcXHRcXHR0aGlzLnogPSBNYXRoLnJvdW5kKCB0aGlzLnogKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XFxuXFx0XFx0XFx0dGhpcy55ID0gKCB0aGlzLnkgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueSApIDogTWF0aC5mbG9vciggdGhpcy55ICk7XFxuXFx0XFx0XFx0dGhpcy56ID0gKCB0aGlzLnogPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueiApIDogTWF0aC5mbG9vciggdGhpcy56ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSAtIHRoaXMueDtcXG5cXHRcXHRcXHR0aGlzLnkgPSAtIHRoaXMueTtcXG5cXHRcXHRcXHR0aGlzLnogPSAtIHRoaXMuejtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGRvdDogZnVuY3Rpb24gKCB2ICkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2Lno7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBUT0RPIGxlbmd0aFNxdWFyZWQ/XFxuXFxuXFx0XFx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bGVuZ3RoOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRtYW5oYXR0YW5MZW5ndGg6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApICsgTWF0aC5hYnMoIHRoaXMueiApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpIHx8IDEgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldExlbmd0aDogZnVuY3Rpb24gKCBsZW5ndGggKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIGxlbmd0aCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bGVycDogZnVuY3Rpb24gKCB2LCBhbHBoYSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xcblxcdFxcdFxcdHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XFxuXFx0XFx0XFx0dGhpcy56ICs9ICggdi56IC0gdGhpcy56ICkgKiBhbHBoYTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGxlcnBWZWN0b3JzOiBmdW5jdGlvbiAoIHYxLCB2MiwgYWxwaGEgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdjIsIHYxICkubXVsdGlwbHlTY2FsYXIoIGFscGhhICkuYWRkKCB2MSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y3Jvc3M6IGZ1bmN0aW9uICggdiwgdyApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuY3Jvc3MoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5jcm9zc1ZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5jcm9zc1ZlY3RvcnMoIHYsIHcgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuY3Jvc3NWZWN0b3JzKCB0aGlzLCB2ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjcm9zc1ZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYXggPSBhLngsIGF5ID0gYS55LCBheiA9IGEuejtcXG5cXHRcXHRcXHR2YXIgYnggPSBiLngsIGJ5ID0gYi55LCBieiA9IGIuejtcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSBheSAqIGJ6IC0gYXogKiBieTtcXG5cXHRcXHRcXHR0aGlzLnkgPSBheiAqIGJ4IC0gYXggKiBiejtcXG5cXHRcXHRcXHR0aGlzLnogPSBheCAqIGJ5IC0gYXkgKiBieDtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHByb2plY3RPblZlY3RvcjogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHNjYWxhciA9IHZlY3Rvci5kb3QoIHRoaXMgKSAvIHZlY3Rvci5sZW5ndGhTcSgpO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmNvcHkoIHZlY3RvciApLm11bHRpcGx5U2NhbGFyKCBzY2FsYXIgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHByb2plY3RPblBsYW5lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gcHJvamVjdE9uUGxhbmUoIHBsYW5lTm9ybWFsICkge1xcblxcblxcdFxcdFxcdFxcdHYxLmNvcHkoIHRoaXMgKS5wcm9qZWN0T25WZWN0b3IoIHBsYW5lTm9ybWFsICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuc3ViKCB2MSApO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdHJlZmxlY3Q6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHQvLyByZWZsZWN0IGluY2lkZW50IHZlY3RvciBvZmYgcGxhbmUgb3J0aG9nb25hbCB0byBub3JtYWxcXG5cXHRcXHRcXHQvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBoYXZlIHVuaXQgbGVuZ3RoXFxuXFxuXFx0XFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gcmVmbGVjdCggbm9ybWFsICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnN1YiggdjEuY29weSggbm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIDIgKiB0aGlzLmRvdCggbm9ybWFsICkgKSApO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdGFuZ2xlVG86IGZ1bmN0aW9uICggdiApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdGhldGEgPSB0aGlzLmRvdCggdiApIC8gKCBNYXRoLnNxcnQoIHRoaXMubGVuZ3RoU3EoKSAqIHYubGVuZ3RoU3EoKSApICk7XFxuXFxuXFx0XFx0XFx0Ly8gY2xhbXAsIHRvIGhhbmRsZSBudW1lcmljYWwgcHJvYmxlbXNcXG5cXG5cXHRcXHRcXHRyZXR1cm4gTWF0aC5hY29zKCBfTWF0aC5jbGFtcCggdGhldGEsIC0gMSwgMSApICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAoIHYgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVRvU3F1YXJlZCggdiApICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkaXN0YW5jZVRvU3F1YXJlZDogZnVuY3Rpb24gKCB2ICkge1xcblxcblxcdFxcdFxcdHZhciBkeCA9IHRoaXMueCAtIHYueCwgZHkgPSB0aGlzLnkgLSB2LnksIGR6ID0gdGhpcy56IC0gdi56O1xcblxcblxcdFxcdFxcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHo7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRtYW5oYXR0YW5EaXN0YW5jZVRvOiBmdW5jdGlvbiAoIHYgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggLSB2LnggKSArIE1hdGguYWJzKCB0aGlzLnkgLSB2LnkgKSArIE1hdGguYWJzKCB0aGlzLnogLSB2LnogKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldEZyb21TcGhlcmljYWw6IGZ1bmN0aW9uICggcyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgc2luUGhpUmFkaXVzID0gTWF0aC5zaW4oIHMucGhpICkgKiBzLnJhZGl1cztcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSBzaW5QaGlSYWRpdXMgKiBNYXRoLnNpbiggcy50aGV0YSApO1xcblxcdFxcdFxcdHRoaXMueSA9IE1hdGguY29zKCBzLnBoaSApICogcy5yYWRpdXM7XFxuXFx0XFx0XFx0dGhpcy56ID0gc2luUGhpUmFkaXVzICogTWF0aC5jb3MoIHMudGhldGEgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldEZyb21DeWxpbmRyaWNhbDogZnVuY3Rpb24gKCBjICkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9IGMucmFkaXVzICogTWF0aC5zaW4oIGMudGhldGEgKTtcXG5cXHRcXHRcXHR0aGlzLnkgPSBjLnk7XFxuXFx0XFx0XFx0dGhpcy56ID0gYy5yYWRpdXMgKiBNYXRoLmNvcyggYy50aGV0YSApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0RnJvbU1hdHJpeFBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xcblxcblxcdFxcdFxcdHRoaXMueCA9IGVbIDEyIF07XFxuXFx0XFx0XFx0dGhpcy55ID0gZVsgMTMgXTtcXG5cXHRcXHRcXHR0aGlzLnogPSBlWyAxNCBdO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0RnJvbU1hdHJpeFNjYWxlOiBmdW5jdGlvbiAoIG0gKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHN4ID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAwICkubGVuZ3RoKCk7XFxuXFx0XFx0XFx0dmFyIHN5ID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAxICkubGVuZ3RoKCk7XFxuXFx0XFx0XFx0dmFyIHN6ID0gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAyICkubGVuZ3RoKCk7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gc3g7XFxuXFx0XFx0XFx0dGhpcy55ID0gc3k7XFxuXFx0XFx0XFx0dGhpcy56ID0gc3o7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRGcm9tTWF0cml4Q29sdW1uOiBmdW5jdGlvbiAoIG0sIGluZGV4ICkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmZyb21BcnJheSggbS5lbGVtZW50cywgaW5kZXggKiA0ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRlcXVhbHM6IGZ1bmN0aW9uICggdiApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICYmICggdi56ID09PSB0aGlzLnogKSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gYXJyYXlbIG9mZnNldCBdO1xcblxcdFxcdFxcdHRoaXMueSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XFxuXFx0XFx0XFx0dGhpcy56ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xcblxcdFxcdFxcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xcblxcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy55O1xcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLno7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGFycmF5O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZnJvbUJ1ZmZlckF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBvZmZzZXQgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiBvZmZzZXQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIC5mcm9tQnVmZmVyQXR0cmlidXRlKCkuJyApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLnggPSBhdHRyaWJ1dGUuZ2V0WCggaW5kZXggKTtcXG5cXHRcXHRcXHR0aGlzLnkgPSBhdHRyaWJ1dGUuZ2V0WSggaW5kZXggKTtcXG5cXHRcXHRcXHR0aGlzLnogPSBhdHRyaWJ1dGUuZ2V0WiggaW5kZXggKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XFxuXFx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xcblxcdCAqIEBhdXRob3IgdHNjaHdcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBNYXRyaXgzKCkge1xcblxcblxcdFxcdHRoaXMuZWxlbWVudHMgPSBbXFxuXFxuXFx0XFx0XFx0MSwgMCwgMCxcXG5cXHRcXHRcXHQwLCAxLCAwLFxcblxcdFxcdFxcdDAsIDAsIDFcXG5cXG5cXHRcXHRdO1xcblxcblxcdFxcdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDM6IHRoZSBjb25zdHJ1Y3RvciBubyBsb25nZXIgcmVhZHMgYXJndW1lbnRzLiB1c2UgLnNldCgpIGluc3RlYWQuJyApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggTWF0cml4My5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRpc01hdHJpeDM6IHRydWUsXFxuXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiAoIG4xMSwgbjEyLCBuMTMsIG4yMSwgbjIyLCBuMjMsIG4zMSwgbjMyLCBuMzMgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcXG5cXG5cXHRcXHRcXHR0ZVsgMCBdID0gbjExOyB0ZVsgMSBdID0gbjIxOyB0ZVsgMiBdID0gbjMxO1xcblxcdFxcdFxcdHRlWyAzIF0gPSBuMTI7IHRlWyA0IF0gPSBuMjI7IHRlWyA1IF0gPSBuMzI7XFxuXFx0XFx0XFx0dGVbIDYgXSA9IG4xMzsgdGVbIDcgXSA9IG4yMzsgdGVbIDggXSA9IG4zMztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGlkZW50aXR5OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5zZXQoXFxuXFxuXFx0XFx0XFx0XFx0MSwgMCwgMCxcXG5cXHRcXHRcXHRcXHQwLCAxLCAwLFxcblxcdFxcdFxcdFxcdDAsIDAsIDFcXG5cXG5cXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5mcm9tQXJyYXkoIHRoaXMuZWxlbWVudHMgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggbSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xcblxcdFxcdFxcdHZhciBtZSA9IG0uZWxlbWVudHM7XFxuXFxuXFx0XFx0XFx0dGVbIDAgXSA9IG1lWyAwIF07IHRlWyAxIF0gPSBtZVsgMSBdOyB0ZVsgMiBdID0gbWVbIDIgXTtcXG5cXHRcXHRcXHR0ZVsgMyBdID0gbWVbIDMgXTsgdGVbIDQgXSA9IG1lWyA0IF07IHRlWyA1IF0gPSBtZVsgNSBdO1xcblxcdFxcdFxcdHRlWyA2IF0gPSBtZVsgNiBdOyB0ZVsgNyBdID0gbWVbIDcgXTsgdGVbIDggXSA9IG1lWyA4IF07XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRGcm9tTWF0cml4NDogZnVuY3Rpb24gKCBtICkge1xcblxcblxcdFxcdFxcdHZhciBtZSA9IG0uZWxlbWVudHM7XFxuXFxuXFx0XFx0XFx0dGhpcy5zZXQoXFxuXFxuXFx0XFx0XFx0XFx0bWVbIDAgXSwgbWVbIDQgXSwgbWVbIDggXSxcXG5cXHRcXHRcXHRcXHRtZVsgMSBdLCBtZVsgNSBdLCBtZVsgOSBdLFxcblxcdFxcdFxcdFxcdG1lWyAyIF0sIG1lWyA2IF0sIG1lWyAxMCBdXFxuXFxuXFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGFwcGx5VG9CdWZmZXJBdHRyaWJ1dGU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBhcHBseVRvQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYXR0cmlidXRlLmNvdW50OyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2MS54ID0gYXR0cmlidXRlLmdldFgoIGkgKTtcXG5cXHRcXHRcXHRcXHRcXHR2MS55ID0gYXR0cmlidXRlLmdldFkoIGkgKTtcXG5cXHRcXHRcXHRcXHRcXHR2MS56ID0gYXR0cmlidXRlLmdldFooIGkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2MS5hcHBseU1hdHJpeDMoIHRoaXMgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRhdHRyaWJ1dGUuc2V0WFlaKCBpLCB2MS54LCB2MS55LCB2MS56ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiBhdHRyaWJ1dGU7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0bXVsdGlwbHk6IGZ1bmN0aW9uICggbSApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLCBtICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRwcmVtdWx0aXBseTogZnVuY3Rpb24gKCBtICkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIG0sIHRoaXMgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG11bHRpcGx5TWF0cmljZXM6IGZ1bmN0aW9uICggYSwgYiApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYWUgPSBhLmVsZW1lbnRzO1xcblxcdFxcdFxcdHZhciBiZSA9IGIuZWxlbWVudHM7XFxuXFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcXG5cXG5cXHRcXHRcXHR2YXIgYTExID0gYWVbIDAgXSwgYTEyID0gYWVbIDMgXSwgYTEzID0gYWVbIDYgXTtcXG5cXHRcXHRcXHR2YXIgYTIxID0gYWVbIDEgXSwgYTIyID0gYWVbIDQgXSwgYTIzID0gYWVbIDcgXTtcXG5cXHRcXHRcXHR2YXIgYTMxID0gYWVbIDIgXSwgYTMyID0gYWVbIDUgXSwgYTMzID0gYWVbIDggXTtcXG5cXG5cXHRcXHRcXHR2YXIgYjExID0gYmVbIDAgXSwgYjEyID0gYmVbIDMgXSwgYjEzID0gYmVbIDYgXTtcXG5cXHRcXHRcXHR2YXIgYjIxID0gYmVbIDEgXSwgYjIyID0gYmVbIDQgXSwgYjIzID0gYmVbIDcgXTtcXG5cXHRcXHRcXHR2YXIgYjMxID0gYmVbIDIgXSwgYjMyID0gYmVbIDUgXSwgYjMzID0gYmVbIDggXTtcXG5cXG5cXHRcXHRcXHR0ZVsgMCBdID0gYTExICogYjExICsgYTEyICogYjIxICsgYTEzICogYjMxO1xcblxcdFxcdFxcdHRlWyAzIF0gPSBhMTEgKiBiMTIgKyBhMTIgKiBiMjIgKyBhMTMgKiBiMzI7XFxuXFx0XFx0XFx0dGVbIDYgXSA9IGExMSAqIGIxMyArIGExMiAqIGIyMyArIGExMyAqIGIzMztcXG5cXG5cXHRcXHRcXHR0ZVsgMSBdID0gYTIxICogYjExICsgYTIyICogYjIxICsgYTIzICogYjMxO1xcblxcdFxcdFxcdHRlWyA0IF0gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzI7XFxuXFx0XFx0XFx0dGVbIDcgXSA9IGEyMSAqIGIxMyArIGEyMiAqIGIyMyArIGEyMyAqIGIzMztcXG5cXG5cXHRcXHRcXHR0ZVsgMiBdID0gYTMxICogYjExICsgYTMyICogYjIxICsgYTMzICogYjMxO1xcblxcdFxcdFxcdHRlWyA1IF0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzI7XFxuXFx0XFx0XFx0dGVbIDggXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcXG5cXG5cXHRcXHRcXHR0ZVsgMCBdICo9IHM7IHRlWyAzIF0gKj0gczsgdGVbIDYgXSAqPSBzO1xcblxcdFxcdFxcdHRlWyAxIF0gKj0gczsgdGVbIDQgXSAqPSBzOyB0ZVsgNyBdICo9IHM7XFxuXFx0XFx0XFx0dGVbIDIgXSAqPSBzOyB0ZVsgNSBdICo9IHM7IHRlWyA4IF0gKj0gcztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGRldGVybWluYW50OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcXG5cXG5cXHRcXHRcXHR2YXIgYSA9IHRlWyAwIF0sIGIgPSB0ZVsgMSBdLCBjID0gdGVbIDIgXSxcXG5cXHRcXHRcXHRcXHRkID0gdGVbIDMgXSwgZSA9IHRlWyA0IF0sIGYgPSB0ZVsgNSBdLFxcblxcdFxcdFxcdFxcdGcgPSB0ZVsgNiBdLCBoID0gdGVbIDcgXSwgaSA9IHRlWyA4IF07XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGEgKiBlICogaSAtIGEgKiBmICogaCAtIGIgKiBkICogaSArIGIgKiBmICogZyArIGMgKiBkICogaCAtIGMgKiBlICogZztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldEludmVyc2U6IGZ1bmN0aW9uICggbWF0cml4LCB0aHJvd09uRGVnZW5lcmF0ZSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIG1hdHJpeCAmJiBtYXRyaXguaXNNYXRyaXg0ICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoIFxcXCJUSFJFRS5NYXRyaXgzOiAuZ2V0SW52ZXJzZSgpIG5vIGxvbmdlciB0YWtlcyBhIE1hdHJpeDQgYXJndW1lbnQuXFxcIiApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgbWUgPSBtYXRyaXguZWxlbWVudHMsXFxuXFx0XFx0XFx0XFx0dGUgPSB0aGlzLmVsZW1lbnRzLFxcblxcblxcdFxcdFxcdFxcdG4xMSA9IG1lWyAwIF0sIG4yMSA9IG1lWyAxIF0sIG4zMSA9IG1lWyAyIF0sXFxuXFx0XFx0XFx0XFx0bjEyID0gbWVbIDMgXSwgbjIyID0gbWVbIDQgXSwgbjMyID0gbWVbIDUgXSxcXG5cXHRcXHRcXHRcXHRuMTMgPSBtZVsgNiBdLCBuMjMgPSBtZVsgNyBdLCBuMzMgPSBtZVsgOCBdLFxcblxcblxcdFxcdFxcdFxcdHQxMSA9IG4zMyAqIG4yMiAtIG4zMiAqIG4yMyxcXG5cXHRcXHRcXHRcXHR0MTIgPSBuMzIgKiBuMTMgLSBuMzMgKiBuMTIsXFxuXFx0XFx0XFx0XFx0dDEzID0gbjIzICogbjEyIC0gbjIyICogbjEzLFxcblxcblxcdFxcdFxcdFxcdGRldCA9IG4xMSAqIHQxMSArIG4yMSAqIHQxMiArIG4zMSAqIHQxMztcXG5cXG5cXHRcXHRcXHRpZiAoIGRldCA9PT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbXNnID0gXFxcIlRIUkVFLk1hdHJpeDM6IC5nZXRJbnZlcnNlKCkgY2FuJ3QgaW52ZXJ0IG1hdHJpeCwgZGV0ZXJtaW5hbnQgaXMgMFxcXCI7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB0aHJvd09uRGVnZW5lcmF0ZSA9PT0gdHJ1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCBtc2cgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuaWRlbnRpdHkoKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIGRldEludiA9IDEgLyBkZXQ7XFxuXFxuXFx0XFx0XFx0dGVbIDAgXSA9IHQxMSAqIGRldEludjtcXG5cXHRcXHRcXHR0ZVsgMSBdID0gKCBuMzEgKiBuMjMgLSBuMzMgKiBuMjEgKSAqIGRldEludjtcXG5cXHRcXHRcXHR0ZVsgMiBdID0gKCBuMzIgKiBuMjEgLSBuMzEgKiBuMjIgKSAqIGRldEludjtcXG5cXG5cXHRcXHRcXHR0ZVsgMyBdID0gdDEyICogZGV0SW52O1xcblxcdFxcdFxcdHRlWyA0IF0gPSAoIG4zMyAqIG4xMSAtIG4zMSAqIG4xMyApICogZGV0SW52O1xcblxcdFxcdFxcdHRlWyA1IF0gPSAoIG4zMSAqIG4xMiAtIG4zMiAqIG4xMSApICogZGV0SW52O1xcblxcblxcdFxcdFxcdHRlWyA2IF0gPSB0MTMgKiBkZXRJbnY7XFxuXFx0XFx0XFx0dGVbIDcgXSA9ICggbjIxICogbjEzIC0gbjIzICogbjExICkgKiBkZXRJbnY7XFxuXFx0XFx0XFx0dGVbIDggXSA9ICggbjIyICogbjExIC0gbjIxICogbjEyICkgKiBkZXRJbnY7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0cmFuc3Bvc2U6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdG1wLCBtID0gdGhpcy5lbGVtZW50cztcXG5cXG5cXHRcXHRcXHR0bXAgPSBtWyAxIF07IG1bIDEgXSA9IG1bIDMgXTsgbVsgMyBdID0gdG1wO1xcblxcdFxcdFxcdHRtcCA9IG1bIDIgXTsgbVsgMiBdID0gbVsgNiBdOyBtWyA2IF0gPSB0bXA7XFxuXFx0XFx0XFx0dG1wID0gbVsgNSBdOyBtWyA1IF0gPSBtWyA3IF07IG1bIDcgXSA9IHRtcDtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldE5vcm1hbE1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXg0ICkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXg0KCBtYXRyaXg0ICkuZ2V0SW52ZXJzZSggdGhpcyApLnRyYW5zcG9zZSgpO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dHJhbnNwb3NlSW50b0FycmF5OiBmdW5jdGlvbiAoIHIgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIG0gPSB0aGlzLmVsZW1lbnRzO1xcblxcblxcdFxcdFxcdHJbIDAgXSA9IG1bIDAgXTtcXG5cXHRcXHRcXHRyWyAxIF0gPSBtWyAzIF07XFxuXFx0XFx0XFx0clsgMiBdID0gbVsgNiBdO1xcblxcdFxcdFxcdHJbIDMgXSA9IG1bIDEgXTtcXG5cXHRcXHRcXHRyWyA0IF0gPSBtWyA0IF07XFxuXFx0XFx0XFx0clsgNSBdID0gbVsgNyBdO1xcblxcdFxcdFxcdHJbIDYgXSA9IG1bIDIgXTtcXG5cXHRcXHRcXHRyWyA3IF0gPSBtWyA1IF07XFxuXFx0XFx0XFx0clsgOCBdID0gbVsgOCBdO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0VXZUcmFuc2Zvcm06IGZ1bmN0aW9uICggdHgsIHR5LCBzeCwgc3ksIHJvdGF0aW9uLCBjeCwgY3kgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGMgPSBNYXRoLmNvcyggcm90YXRpb24gKTtcXG5cXHRcXHRcXHR2YXIgcyA9IE1hdGguc2luKCByb3RhdGlvbiApO1xcblxcblxcdFxcdFxcdHRoaXMuc2V0KFxcblxcdFxcdFxcdFxcdHN4ICogYywgc3ggKiBzLCAtIHN4ICogKCBjICogY3ggKyBzICogY3kgKSArIGN4ICsgdHgsXFxuXFx0XFx0XFx0XFx0LSBzeSAqIHMsIHN5ICogYywgLSBzeSAqICggLSBzICogY3ggKyBjICogY3kgKSArIGN5ICsgdHksXFxuXFx0XFx0XFx0XFx0MCwgMCwgMVxcblxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzY2FsZTogZnVuY3Rpb24gKCBzeCwgc3kgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcXG5cXG5cXHRcXHRcXHR0ZVsgMCBdICo9IHN4OyB0ZVsgMyBdICo9IHN4OyB0ZVsgNiBdICo9IHN4O1xcblxcdFxcdFxcdHRlWyAxIF0gKj0gc3k7IHRlWyA0IF0gKj0gc3k7IHRlWyA3IF0gKj0gc3k7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyb3RhdGU6IGZ1bmN0aW9uICggdGhldGEgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKTtcXG5cXHRcXHRcXHR2YXIgcyA9IE1hdGguc2luKCB0aGV0YSApO1xcblxcblxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XFxuXFxuXFx0XFx0XFx0dmFyIGExMSA9IHRlWyAwIF0sIGExMiA9IHRlWyAzIF0sIGExMyA9IHRlWyA2IF07XFxuXFx0XFx0XFx0dmFyIGEyMSA9IHRlWyAxIF0sIGEyMiA9IHRlWyA0IF0sIGEyMyA9IHRlWyA3IF07XFxuXFxuXFx0XFx0XFx0dGVbIDAgXSA9IGMgKiBhMTEgKyBzICogYTIxO1xcblxcdFxcdFxcdHRlWyAzIF0gPSBjICogYTEyICsgcyAqIGEyMjtcXG5cXHRcXHRcXHR0ZVsgNiBdID0gYyAqIGExMyArIHMgKiBhMjM7XFxuXFxuXFx0XFx0XFx0dGVbIDEgXSA9IC0gcyAqIGExMSArIGMgKiBhMjE7XFxuXFx0XFx0XFx0dGVbIDQgXSA9IC0gcyAqIGExMiArIGMgKiBhMjI7XFxuXFx0XFx0XFx0dGVbIDcgXSA9IC0gcyAqIGExMyArIGMgKiBhMjM7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggdHgsIHR5ICkge1xcblxcblxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XFxuXFxuXFx0XFx0XFx0dGVbIDAgXSArPSB0eCAqIHRlWyAyIF07IHRlWyAzIF0gKz0gdHggKiB0ZVsgNSBdOyB0ZVsgNiBdICs9IHR4ICogdGVbIDggXTtcXG5cXHRcXHRcXHR0ZVsgMSBdICs9IHR5ICogdGVbIDIgXTsgdGVbIDQgXSArPSB0eSAqIHRlWyA1IF07IHRlWyA3IF0gKz0gdHkgKiB0ZVsgOCBdO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZXF1YWxzOiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xcblxcdFxcdFxcdHZhciBtZSA9IG1hdHJpeC5lbGVtZW50cztcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA5OyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggdGVbIGkgXSAhPT0gbWVbIGkgXSApIHJldHVybiBmYWxzZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA5OyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuZWxlbWVudHNbIGkgXSA9IGFycmF5WyBpICsgb2Zmc2V0IF07XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XFxuXFx0XFx0XFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XFxuXFxuXFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcXG5cXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0IF0gPSB0ZVsgMCBdO1xcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xcblxcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0ZVsgMyBdO1xcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyA0IF0gPSB0ZVsgNCBdO1xcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyA1IF0gPSB0ZVsgNSBdO1xcblxcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyA2IF0gPSB0ZVsgNiBdO1xcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyA3IF0gPSB0ZVsgNyBdO1xcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyA4IF0gPSB0ZVsgOCBdO1xcblxcblxcdFxcdFxcdHJldHVybiBhcnJheTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKiBAYXV0aG9yIHN6aW1layAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvXFxuXFx0ICovXFxuXFxuXFx0dmFyIHRleHR1cmVJZCA9IDA7XFxuXFxuXFx0ZnVuY3Rpb24gVGV4dHVyZSggaW1hZ2UsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSwgZW5jb2RpbmcgKSB7XFxuXFxuXFx0XFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiB0ZXh0dXJlSWQgKysgfSApO1xcblxcblxcdFxcdHRoaXMudXVpZCA9IF9NYXRoLmdlbmVyYXRlVVVJRCgpO1xcblxcblxcdFxcdHRoaXMubmFtZSA9ICcnO1xcblxcblxcdFxcdHRoaXMuaW1hZ2UgPSBpbWFnZSAhPT0gdW5kZWZpbmVkID8gaW1hZ2UgOiBUZXh0dXJlLkRFRkFVTFRfSU1BR0U7XFxuXFx0XFx0dGhpcy5taXBtYXBzID0gW107XFxuXFxuXFx0XFx0dGhpcy5tYXBwaW5nID0gbWFwcGluZyAhPT0gdW5kZWZpbmVkID8gbWFwcGluZyA6IFRleHR1cmUuREVGQVVMVF9NQVBQSU5HO1xcblxcblxcdFxcdHRoaXMud3JhcFMgPSB3cmFwUyAhPT0gdW5kZWZpbmVkID8gd3JhcFMgOiBDbGFtcFRvRWRnZVdyYXBwaW5nO1xcblxcdFxcdHRoaXMud3JhcFQgPSB3cmFwVCAhPT0gdW5kZWZpbmVkID8gd3JhcFQgOiBDbGFtcFRvRWRnZVdyYXBwaW5nO1xcblxcblxcdFxcdHRoaXMubWFnRmlsdGVyID0gbWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtYWdGaWx0ZXIgOiBMaW5lYXJGaWx0ZXI7XFxuXFx0XFx0dGhpcy5taW5GaWx0ZXIgPSBtaW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1pbkZpbHRlciA6IExpbmVhck1pcE1hcExpbmVhckZpbHRlcjtcXG5cXG5cXHRcXHR0aGlzLmFuaXNvdHJvcHkgPSBhbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgPyBhbmlzb3Ryb3B5IDogMTtcXG5cXG5cXHRcXHR0aGlzLmZvcm1hdCA9IGZvcm1hdCAhPT0gdW5kZWZpbmVkID8gZm9ybWF0IDogUkdCQUZvcm1hdDtcXG5cXHRcXHR0aGlzLnR5cGUgPSB0eXBlICE9PSB1bmRlZmluZWQgPyB0eXBlIDogVW5zaWduZWRCeXRlVHlwZTtcXG5cXG5cXHRcXHR0aGlzLm9mZnNldCA9IG5ldyBWZWN0b3IyKCAwLCAwICk7XFxuXFx0XFx0dGhpcy5yZXBlYXQgPSBuZXcgVmVjdG9yMiggMSwgMSApO1xcblxcdFxcdHRoaXMuY2VudGVyID0gbmV3IFZlY3RvcjIoIDAsIDAgKTtcXG5cXHRcXHR0aGlzLnJvdGF0aW9uID0gMDtcXG5cXG5cXHRcXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSB0cnVlO1xcblxcdFxcdHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDMoKTtcXG5cXG5cXHRcXHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IHRydWU7XFxuXFx0XFx0dGhpcy5wcmVtdWx0aXBseUFscGhhID0gZmFsc2U7XFxuXFx0XFx0dGhpcy5mbGlwWSA9IHRydWU7XFxuXFx0XFx0dGhpcy51bnBhY2tBbGlnbm1lbnQgPSA0O1xcdC8vIHZhbGlkIHZhbHVlczogMSwgMiwgNCwgOCAoc2VlIGh0dHA6Ly93d3cua2hyb25vcy5vcmcvb3BlbmdsZXMvc2RrL2RvY3MvbWFuL3hodG1sL2dsUGl4ZWxTdG9yZWkueG1sKVxcblxcblxcdFxcdC8vIFZhbHVlcyBvZiBlbmNvZGluZyAhPT0gVEhSRUUuTGluZWFyRW5jb2Rpbmcgb25seSBzdXBwb3J0ZWQgb24gbWFwLCBlbnZNYXAgYW5kIGVtaXNzaXZlTWFwLlxcblxcdFxcdC8vXFxuXFx0XFx0Ly8gQWxzbyBjaGFuZ2luZyB0aGUgZW5jb2RpbmcgYWZ0ZXIgYWxyZWFkeSB1c2VkIGJ5IGEgTWF0ZXJpYWwgd2lsbCBub3QgYXV0b21hdGljYWxseSBtYWtlIHRoZSBNYXRlcmlhbFxcblxcdFxcdC8vIHVwZGF0ZS4gIFlvdSBuZWVkIHRvIGV4cGxpY2l0bHkgY2FsbCBNYXRlcmlhbC5uZWVkc1VwZGF0ZSB0byB0cmlnZ2VyIGl0IHRvIHJlY29tcGlsZS5cXG5cXHRcXHR0aGlzLmVuY29kaW5nID0gZW5jb2RpbmcgIT09IHVuZGVmaW5lZCA/IGVuY29kaW5nIDogTGluZWFyRW5jb2Rpbmc7XFxuXFxuXFx0XFx0dGhpcy52ZXJzaW9uID0gMDtcXG5cXHRcXHR0aGlzLm9uVXBkYXRlID0gbnVsbDtcXG5cXG5cXHR9XFxuXFxuXFx0VGV4dHVyZS5ERUZBVUxUX0lNQUdFID0gdW5kZWZpbmVkO1xcblxcdFRleHR1cmUuREVGQVVMVF9NQVBQSU5HID0gVVZNYXBwaW5nO1xcblxcblxcdFRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IFRleHR1cmUsXFxuXFxuXFx0XFx0aXNUZXh0dXJlOiB0cnVlLFxcblxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7XFxuXFxuXFx0XFx0XFx0dGhpcy5pbWFnZSA9IHNvdXJjZS5pbWFnZTtcXG5cXHRcXHRcXHR0aGlzLm1pcG1hcHMgPSBzb3VyY2UubWlwbWFwcy5zbGljZSggMCApO1xcblxcblxcdFxcdFxcdHRoaXMubWFwcGluZyA9IHNvdXJjZS5tYXBwaW5nO1xcblxcblxcdFxcdFxcdHRoaXMud3JhcFMgPSBzb3VyY2Uud3JhcFM7XFxuXFx0XFx0XFx0dGhpcy53cmFwVCA9IHNvdXJjZS53cmFwVDtcXG5cXG5cXHRcXHRcXHR0aGlzLm1hZ0ZpbHRlciA9IHNvdXJjZS5tYWdGaWx0ZXI7XFxuXFx0XFx0XFx0dGhpcy5taW5GaWx0ZXIgPSBzb3VyY2UubWluRmlsdGVyO1xcblxcblxcdFxcdFxcdHRoaXMuYW5pc290cm9weSA9IHNvdXJjZS5hbmlzb3Ryb3B5O1xcblxcblxcdFxcdFxcdHRoaXMuZm9ybWF0ID0gc291cmNlLmZvcm1hdDtcXG5cXHRcXHRcXHR0aGlzLnR5cGUgPSBzb3VyY2UudHlwZTtcXG5cXG5cXHRcXHRcXHR0aGlzLm9mZnNldC5jb3B5KCBzb3VyY2Uub2Zmc2V0ICk7XFxuXFx0XFx0XFx0dGhpcy5yZXBlYXQuY29weSggc291cmNlLnJlcGVhdCApO1xcblxcdFxcdFxcdHRoaXMuY2VudGVyLmNvcHkoIHNvdXJjZS5jZW50ZXIgKTtcXG5cXHRcXHRcXHR0aGlzLnJvdGF0aW9uID0gc291cmNlLnJvdGF0aW9uO1xcblxcblxcdFxcdFxcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhBdXRvVXBkYXRlO1xcblxcdFxcdFxcdHRoaXMubWF0cml4LmNvcHkoIHNvdXJjZS5tYXRyaXggKTtcXG5cXG5cXHRcXHRcXHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IHNvdXJjZS5nZW5lcmF0ZU1pcG1hcHM7XFxuXFx0XFx0XFx0dGhpcy5wcmVtdWx0aXBseUFscGhhID0gc291cmNlLnByZW11bHRpcGx5QWxwaGE7XFxuXFx0XFx0XFx0dGhpcy5mbGlwWSA9IHNvdXJjZS5mbGlwWTtcXG5cXHRcXHRcXHR0aGlzLnVucGFja0FsaWdubWVudCA9IHNvdXJjZS51bnBhY2tBbGlnbm1lbnQ7XFxuXFx0XFx0XFx0dGhpcy5lbmNvZGluZyA9IHNvdXJjZS5lbmNvZGluZztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xcblxcblxcdFxcdFxcdHZhciBpc1Jvb3RPYmplY3QgPSAoIG1ldGEgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgbWV0YSA9PT0gJ3N0cmluZycgKTtcXG5cXG5cXHRcXHRcXHRpZiAoICEgaXNSb290T2JqZWN0ICYmIG1ldGEudGV4dHVyZXNbIHRoaXMudXVpZCBdICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIG1ldGEudGV4dHVyZXNbIHRoaXMudXVpZCBdO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmdW5jdGlvbiBnZXREYXRhVVJMKCBpbWFnZSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgY2FudmFzO1xcblxcblxcdFxcdFxcdFxcdGlmICggaW1hZ2UgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYW52YXMgPSBpbWFnZTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCAnY2FudmFzJyApO1xcblxcdFxcdFxcdFxcdFxcdGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xcblxcdFxcdFxcdFxcdFxcdGNhbnZhcy5oZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZURhdGEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29udGV4dC5wdXRJbWFnZURhdGEoIGltYWdlLCAwLCAwICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggY2FudmFzLndpZHRoID4gMjA0OCB8fCBjYW52YXMuaGVpZ2h0ID4gMjA0OCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gY2FudmFzLnRvRGF0YVVSTCggJ2ltYWdlL2pwZWcnLCAwLjYgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBjYW52YXMudG9EYXRhVVJMKCAnaW1hZ2UvcG5nJyApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIG91dHB1dCA9IHtcXG5cXHRcXHRcXHRcXHRtZXRhZGF0YToge1xcblxcdFxcdFxcdFxcdFxcdHZlcnNpb246IDQuNSxcXG5cXHRcXHRcXHRcXHRcXHR0eXBlOiAnVGV4dHVyZScsXFxuXFx0XFx0XFx0XFx0XFx0Z2VuZXJhdG9yOiAnVGV4dHVyZS50b0pTT04nXFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHR1dWlkOiB0aGlzLnV1aWQsXFxuXFx0XFx0XFx0XFx0bmFtZTogdGhpcy5uYW1lLFxcblxcblxcdFxcdFxcdFxcdG1hcHBpbmc6IHRoaXMubWFwcGluZyxcXG5cXG5cXHRcXHRcXHRcXHRyZXBlYXQ6IFsgdGhpcy5yZXBlYXQueCwgdGhpcy5yZXBlYXQueSBdLFxcblxcdFxcdFxcdFxcdG9mZnNldDogWyB0aGlzLm9mZnNldC54LCB0aGlzLm9mZnNldC55IF0sXFxuXFx0XFx0XFx0XFx0Y2VudGVyOiBbIHRoaXMuY2VudGVyLngsIHRoaXMuY2VudGVyLnkgXSxcXG5cXHRcXHRcXHRcXHRyb3RhdGlvbjogdGhpcy5yb3RhdGlvbixcXG5cXG5cXHRcXHRcXHRcXHR3cmFwOiBbIHRoaXMud3JhcFMsIHRoaXMud3JhcFQgXSxcXG5cXG5cXHRcXHRcXHRcXHRtaW5GaWx0ZXI6IHRoaXMubWluRmlsdGVyLFxcblxcdFxcdFxcdFxcdG1hZ0ZpbHRlcjogdGhpcy5tYWdGaWx0ZXIsXFxuXFx0XFx0XFx0XFx0YW5pc290cm9weTogdGhpcy5hbmlzb3Ryb3B5LFxcblxcblxcdFxcdFxcdFxcdGZsaXBZOiB0aGlzLmZsaXBZXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuaW1hZ2UgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBUT0RPOiBNb3ZlIHRvIFRIUkVFLkltYWdlXFxuXFxuXFx0XFx0XFx0XFx0dmFyIGltYWdlID0gdGhpcy5pbWFnZTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGltYWdlLnV1aWQgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpbWFnZS51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7IC8vIFVHSFxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoICEgaXNSb290T2JqZWN0ICYmIG1ldGEuaW1hZ2VzWyBpbWFnZS51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRtZXRhLmltYWdlc1sgaW1hZ2UudXVpZCBdID0ge1xcblxcdFxcdFxcdFxcdFxcdFxcdHV1aWQ6IGltYWdlLnV1aWQsXFxuXFx0XFx0XFx0XFx0XFx0XFx0dXJsOiBnZXREYXRhVVJMKCBpbWFnZSApXFxuXFx0XFx0XFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0b3V0cHV0LmltYWdlID0gaW1hZ2UudXVpZDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCAhIGlzUm9vdE9iamVjdCApIHtcXG5cXG5cXHRcXHRcXHRcXHRtZXRhLnRleHR1cmVzWyB0aGlzLnV1aWQgXSA9IG91dHB1dDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG91dHB1dDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHRyYW5zZm9ybVV2OiBmdW5jdGlvbiAoIHV2ICkge1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5tYXBwaW5nICE9PSBVVk1hcHBpbmcgKSByZXR1cm47XFxuXFxuXFx0XFx0XFx0dXYuYXBwbHlNYXRyaXgzKCB0aGlzLm1hdHJpeCApO1xcblxcblxcdFxcdFxcdGlmICggdXYueCA8IDAgfHwgdXYueCA+IDEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0c3dpdGNoICggdGhpcy53cmFwUyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlIFJlcGVhdFdyYXBwaW5nOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHV2LnggPSB1di54IC0gTWF0aC5mbG9vciggdXYueCApO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdGNhc2UgQ2xhbXBUb0VkZ2VXcmFwcGluZzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR1di54ID0gdXYueCA8IDAgPyAwIDogMTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlIE1pcnJvcmVkUmVwZWF0V3JhcHBpbmc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBNYXRoLmFicyggTWF0aC5mbG9vciggdXYueCApICUgMiApID09PSAxICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHV2LnggPSBNYXRoLmNlaWwoIHV2LnggKSAtIHV2Lng7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR1di54ID0gdXYueCAtIE1hdGguZmxvb3IoIHV2LnggKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHV2LnkgPCAwIHx8IHV2LnkgPiAxICkge1xcblxcblxcdFxcdFxcdFxcdHN3aXRjaCAoIHRoaXMud3JhcFQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSBSZXBlYXRXcmFwcGluZzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR1di55ID0gdXYueSAtIE1hdGguZmxvb3IoIHV2LnkgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlIENsYW1wVG9FZGdlV3JhcHBpbmc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dXYueSA9IHV2LnkgPCAwID8gMCA6IDE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggTWF0aC5hYnMoIE1hdGguZmxvb3IoIHV2LnkgKSAlIDIgKSA9PT0gMSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR1di55ID0gTWF0aC5jZWlsKCB1di55ICkgLSB1di55O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dXYueSA9IHV2LnkgLSBNYXRoLmZsb29yKCB1di55ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmZsaXBZICkge1xcblxcblxcdFxcdFxcdFxcdHV2LnkgPSAxIC0gdXYueTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIFRleHR1cmUucHJvdG90eXBlLCBcXFwibmVlZHNVcGRhdGVcXFwiLCB7XFxuXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24gKys7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xcblxcdCAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXFxuXFx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cXG5cXHQgKiBAYXV0aG9yIGVncmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xcblxcdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFZlY3RvcjQoIHgsIHksIHosIHcgKSB7XFxuXFxuXFx0XFx0dGhpcy54ID0geCB8fCAwO1xcblxcdFxcdHRoaXMueSA9IHkgfHwgMDtcXG5cXHRcXHR0aGlzLnogPSB6IHx8IDA7XFxuXFx0XFx0dGhpcy53ID0gKCB3ICE9PSB1bmRlZmluZWQgKSA/IHcgOiAxO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBWZWN0b3I0LnByb3RvdHlwZSwge1xcblxcblxcdFxcdGlzVmVjdG9yNDogdHJ1ZSxcXG5cXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSB4O1xcblxcdFxcdFxcdHRoaXMueSA9IHk7XFxuXFx0XFx0XFx0dGhpcy56ID0gejtcXG5cXHRcXHRcXHR0aGlzLncgPSB3O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSBzY2FsYXI7XFxuXFx0XFx0XFx0dGhpcy55ID0gc2NhbGFyO1xcblxcdFxcdFxcdHRoaXMueiA9IHNjYWxhcjtcXG5cXHRcXHRcXHR0aGlzLncgPSBzY2FsYXI7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRYOiBmdW5jdGlvbiAoIHggKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0geDtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFk6IGZ1bmN0aW9uICggeSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnkgPSB5O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0WjogZnVuY3Rpb24gKCB6ICkge1xcblxcblxcdFxcdFxcdHRoaXMueiA9IHo7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRXOiBmdW5jdGlvbiAoIHcgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy53ID0gdztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0c3dpdGNoICggaW5kZXggKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSAyOiB0aGlzLnogPSB2YWx1ZTsgYnJlYWs7XFxuXFx0XFx0XFx0XFx0Y2FzZSAzOiB0aGlzLncgPSB2YWx1ZTsgYnJlYWs7XFxuXFx0XFx0XFx0XFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXggKSB7XFxuXFxuXFx0XFx0XFx0c3dpdGNoICggaW5kZXggKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y2FzZSAwOiByZXR1cm4gdGhpcy54O1xcblxcdFxcdFxcdFxcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcXG5cXHRcXHRcXHRcXHRjYXNlIDI6IHJldHVybiB0aGlzLno7XFxuXFx0XFx0XFx0XFx0Y2FzZSAzOiByZXR1cm4gdGhpcy53O1xcblxcdFxcdFxcdFxcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMudyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCB2ICkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9IHYueDtcXG5cXHRcXHRcXHR0aGlzLnkgPSB2Lnk7XFxuXFx0XFx0XFx0dGhpcy56ID0gdi56O1xcblxcdFxcdFxcdHRoaXMudyA9ICggdi53ICE9PSB1bmRlZmluZWQgKSA/IHYudyA6IDE7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRhZGQ6IGZ1bmN0aW9uICggdiwgdyApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3I0OiAuYWRkKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuYWRkVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy54ICs9IHYueDtcXG5cXHRcXHRcXHR0aGlzLnkgKz0gdi55O1xcblxcdFxcdFxcdHRoaXMueiArPSB2Lno7XFxuXFx0XFx0XFx0dGhpcy53ICs9IHYudztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xcblxcblxcdFxcdFxcdHRoaXMueCArPSBzO1xcblxcdFxcdFxcdHRoaXMueSArPSBzO1xcblxcdFxcdFxcdHRoaXMueiArPSBzO1xcblxcdFxcdFxcdHRoaXMudyArPSBzO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9IGEueCArIGIueDtcXG5cXHRcXHRcXHR0aGlzLnkgPSBhLnkgKyBiLnk7XFxuXFx0XFx0XFx0dGhpcy56ID0gYS56ICsgYi56O1xcblxcdFxcdFxcdHRoaXMudyA9IGEudyArIGIudztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGFkZFNjYWxlZFZlY3RvcjogZnVuY3Rpb24gKCB2LCBzICkge1xcblxcblxcdFxcdFxcdHRoaXMueCArPSB2LnggKiBzO1xcblxcdFxcdFxcdHRoaXMueSArPSB2LnkgKiBzO1xcblxcdFxcdFxcdHRoaXMueiArPSB2LnogKiBzO1xcblxcdFxcdFxcdHRoaXMudyArPSB2LncgKiBzO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yNDogLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMueCAtPSB2Lng7XFxuXFx0XFx0XFx0dGhpcy55IC09IHYueTtcXG5cXHRcXHRcXHR0aGlzLnogLT0gdi56O1xcblxcdFxcdFxcdHRoaXMudyAtPSB2Lnc7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzdWJTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggLT0gcztcXG5cXHRcXHRcXHR0aGlzLnkgLT0gcztcXG5cXHRcXHRcXHR0aGlzLnogLT0gcztcXG5cXHRcXHRcXHR0aGlzLncgLT0gcztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHN1YlZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSBhLnggLSBiLng7XFxuXFx0XFx0XFx0dGhpcy55ID0gYS55IC0gYi55O1xcblxcdFxcdFxcdHRoaXMueiA9IGEueiAtIGIuejtcXG5cXHRcXHRcXHR0aGlzLncgPSBhLncgLSBiLnc7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ICo9IHNjYWxhcjtcXG5cXHRcXHRcXHR0aGlzLnkgKj0gc2NhbGFyO1xcblxcdFxcdFxcdHRoaXMueiAqPSBzY2FsYXI7XFxuXFx0XFx0XFx0dGhpcy53ICo9IHNjYWxhcjtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtICkge1xcblxcblxcdFxcdFxcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56LCB3ID0gdGhpcy53O1xcblxcdFxcdFxcdHZhciBlID0gbS5lbGVtZW50cztcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAqIHogKyBlWyAxMiBdICogdztcXG5cXHRcXHRcXHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAqIHogKyBlWyAxMyBdICogdztcXG5cXHRcXHRcXHR0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6ICsgZVsgMTQgXSAqIHc7XFxuXFx0XFx0XFx0dGhpcy53ID0gZVsgMyBdICogeCArIGVbIDcgXSAqIHkgKyBlWyAxMSBdICogeiArIGVbIDE1IF0gKiB3O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggMSAvIHNjYWxhciApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0QXhpc0FuZ2xlRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcXG5cXG5cXHRcXHRcXHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvcXVhdGVybmlvblRvQW5nbGUvaW5kZXguaHRtXFxuXFxuXFx0XFx0XFx0Ly8gcSBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcXG5cXG5cXHRcXHRcXHR0aGlzLncgPSAyICogTWF0aC5hY29zKCBxLncgKTtcXG5cXG5cXHRcXHRcXHR2YXIgcyA9IE1hdGguc3FydCggMSAtIHEudyAqIHEudyApO1xcblxcblxcdFxcdFxcdGlmICggcyA8IDAuMDAwMSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnggPSAxO1xcblxcdFxcdFxcdFxcdHRoaXMueSA9IDA7XFxuXFx0XFx0XFx0XFx0dGhpcy56ID0gMDtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdHRoaXMueCA9IHEueCAvIHM7XFxuXFx0XFx0XFx0XFx0dGhpcy55ID0gcS55IC8gcztcXG5cXHRcXHRcXHRcXHR0aGlzLnogPSBxLnogLyBzO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldEF4aXNBbmdsZUZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xcblxcblxcdFxcdFxcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb0FuZ2xlL2luZGV4Lmh0bVxcblxcblxcdFxcdFxcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXFxuXFxuXFx0XFx0XFx0dmFyIGFuZ2xlLCB4LCB5LCB6LFxcdFxcdC8vIHZhcmlhYmxlcyBmb3IgcmVzdWx0XFxuXFx0XFx0XFx0XFx0ZXBzaWxvbiA9IDAuMDEsXFx0XFx0Ly8gbWFyZ2luIHRvIGFsbG93IGZvciByb3VuZGluZyBlcnJvcnNcXG5cXHRcXHRcXHRcXHRlcHNpbG9uMiA9IDAuMSxcXHRcXHQvLyBtYXJnaW4gdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiAwIGFuZCAxODAgZGVncmVlc1xcblxcblxcdFxcdFxcdFxcdHRlID0gbS5lbGVtZW50cyxcXG5cXG5cXHRcXHRcXHRcXHRtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdLFxcblxcdFxcdFxcdFxcdG0yMSA9IHRlWyAxIF0sIG0yMiA9IHRlWyA1IF0sIG0yMyA9IHRlWyA5IF0sXFxuXFx0XFx0XFx0XFx0bTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF07XFxuXFxuXFx0XFx0XFx0aWYgKCAoIE1hdGguYWJzKCBtMTIgLSBtMjEgKSA8IGVwc2lsb24gKSAmJlxcblxcdFxcdFxcdCAgICAgKCBNYXRoLmFicyggbTEzIC0gbTMxICkgPCBlcHNpbG9uICkgJiZcXG5cXHRcXHRcXHQgICAgICggTWF0aC5hYnMoIG0yMyAtIG0zMiApIDwgZXBzaWxvbiApICkge1xcblxcblxcdFxcdFxcdFxcdC8vIHNpbmd1bGFyaXR5IGZvdW5kXFxuXFx0XFx0XFx0XFx0Ly8gZmlyc3QgY2hlY2sgZm9yIGlkZW50aXR5IG1hdHJpeCB3aGljaCBtdXN0IGhhdmUgKzEgZm9yIGFsbCB0ZXJtc1xcblxcdFxcdFxcdFxcdC8vIGluIGxlYWRpbmcgZGlhZ29uYWwgYW5kIHplcm8gaW4gb3RoZXIgdGVybXNcXG5cXG5cXHRcXHRcXHRcXHRpZiAoICggTWF0aC5hYnMoIG0xMiArIG0yMSApIDwgZXBzaWxvbjIgKSAmJlxcblxcdFxcdFxcdFxcdCAgICAgKCBNYXRoLmFicyggbTEzICsgbTMxICkgPCBlcHNpbG9uMiApICYmXFxuXFx0XFx0XFx0XFx0ICAgICAoIE1hdGguYWJzKCBtMjMgKyBtMzIgKSA8IGVwc2lsb24yICkgJiZcXG5cXHRcXHRcXHRcXHQgICAgICggTWF0aC5hYnMoIG0xMSArIG0yMiArIG0zMyAtIDMgKSA8IGVwc2lsb24yICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdGhpcyBzaW5ndWxhcml0eSBpcyBpZGVudGl0eSBtYXRyaXggc28gYW5nbGUgPSAwXFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5zZXQoIDEsIDAsIDAsIDAgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpczsgLy8gemVybyBhbmdsZSwgYXJiaXRyYXJ5IGF4aXNcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gb3RoZXJ3aXNlIHRoaXMgc2luZ3VsYXJpdHkgaXMgYW5nbGUgPSAxODBcXG5cXG5cXHRcXHRcXHRcXHRhbmdsZSA9IE1hdGguUEk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHh4ID0gKCBtMTEgKyAxICkgLyAyO1xcblxcdFxcdFxcdFxcdHZhciB5eSA9ICggbTIyICsgMSApIC8gMjtcXG5cXHRcXHRcXHRcXHR2YXIgenogPSAoIG0zMyArIDEgKSAvIDI7XFxuXFx0XFx0XFx0XFx0dmFyIHh5ID0gKCBtMTIgKyBtMjEgKSAvIDQ7XFxuXFx0XFx0XFx0XFx0dmFyIHh6ID0gKCBtMTMgKyBtMzEgKSAvIDQ7XFxuXFx0XFx0XFx0XFx0dmFyIHl6ID0gKCBtMjMgKyBtMzIgKSAvIDQ7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCAoIHh4ID4geXkgKSAmJiAoIHh4ID4genogKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBtMTEgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybVxcblxcblxcdFxcdFxcdFxcdFxcdGlmICggeHggPCBlcHNpbG9uICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHggPSAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdHkgPSAwLjcwNzEwNjc4MTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6ID0gMC43MDcxMDY3ODE7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR4ID0gTWF0aC5zcXJ0KCB4eCApO1xcblxcdFxcdFxcdFxcdFxcdFxcdHkgPSB4eSAvIHg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0eiA9IHh6IC8geDtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggeXkgPiB6eiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBtMjIgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybVxcblxcblxcdFxcdFxcdFxcdFxcdGlmICggeXkgPCBlcHNpbG9uICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHggPSAwLjcwNzEwNjc4MTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR5ID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6ID0gMC43MDcxMDY3ODE7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR5ID0gTWF0aC5zcXJ0KCB5eSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdHggPSB4eSAvIHk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0eiA9IHl6IC8geTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBtMzMgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybSBzbyBiYXNlIHJlc3VsdCBvbiB0aGlzXFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB6eiA8IGVwc2lsb24gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0eCA9IDAuNzA3MTA2NzgxO1xcblxcdFxcdFxcdFxcdFxcdFxcdHkgPSAwLjcwNzEwNjc4MTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6ID0gMDtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHogPSBNYXRoLnNxcnQoIHp6ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0eCA9IHh6IC8gejtcXG5cXHRcXHRcXHRcXHRcXHRcXHR5ID0geXogLyB6O1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5zZXQoIHgsIHksIHosIGFuZ2xlICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7IC8vIHJldHVybiAxODAgZGVnIHJvdGF0aW9uXFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGFzIHdlIGhhdmUgcmVhY2hlZCBoZXJlIHRoZXJlIGFyZSBubyBzaW5ndWxhcml0aWVzIHNvIHdlIGNhbiBoYW5kbGUgbm9ybWFsbHlcXG5cXG5cXHRcXHRcXHR2YXIgcyA9IE1hdGguc3FydCggKCBtMzIgLSBtMjMgKSAqICggbTMyIC0gbTIzICkgK1xcblxcdFxcdFxcdCAgICAgICAgICAgICAgICAgICAoIG0xMyAtIG0zMSApICogKCBtMTMgLSBtMzEgKSArXFxuXFx0XFx0XFx0ICAgICAgICAgICAgICAgICAgICggbTIxIC0gbTEyICkgKiAoIG0yMSAtIG0xMiApICk7IC8vIHVzZWQgdG8gbm9ybWFsaXplXFxuXFxuXFx0XFx0XFx0aWYgKCBNYXRoLmFicyggcyApIDwgMC4wMDEgKSBzID0gMTtcXG5cXG5cXHRcXHRcXHQvLyBwcmV2ZW50IGRpdmlkZSBieSB6ZXJvLCBzaG91bGQgbm90IGhhcHBlbiBpZiBtYXRyaXggaXMgb3J0aG9nb25hbCBhbmQgc2hvdWxkIGJlXFxuXFx0XFx0XFx0Ly8gY2F1Z2h0IGJ5IHNpbmd1bGFyaXR5IHRlc3QgYWJvdmUsIGJ1dCBJJ3ZlIGxlZnQgaXQgaW4ganVzdCBpbiBjYXNlXFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gKCBtMzIgLSBtMjMgKSAvIHM7XFxuXFx0XFx0XFx0dGhpcy55ID0gKCBtMTMgLSBtMzEgKSAvIHM7XFxuXFx0XFx0XFx0dGhpcy56ID0gKCBtMjEgLSBtMTIgKSAvIHM7XFxuXFx0XFx0XFx0dGhpcy53ID0gTWF0aC5hY29zKCAoIG0xMSArIG0yMiArIG0zMyAtIDEgKSAvIDIgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG1pbjogZnVuY3Rpb24gKCB2ICkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9IE1hdGgubWluKCB0aGlzLngsIHYueCApO1xcblxcdFxcdFxcdHRoaXMueSA9IE1hdGgubWluKCB0aGlzLnksIHYueSApO1xcblxcdFxcdFxcdHRoaXMueiA9IE1hdGgubWluKCB0aGlzLnosIHYueiApO1xcblxcdFxcdFxcdHRoaXMudyA9IE1hdGgubWluKCB0aGlzLncsIHYudyApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bWF4OiBmdW5jdGlvbiAoIHYgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gTWF0aC5tYXgoIHRoaXMueCwgdi54ICk7XFxuXFx0XFx0XFx0dGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XFxuXFx0XFx0XFx0dGhpcy56ID0gTWF0aC5tYXgoIHRoaXMueiwgdi56ICk7XFxuXFx0XFx0XFx0dGhpcy53ID0gTWF0aC5tYXgoIHRoaXMudywgdi53ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbGFtcDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcXG5cXG5cXHRcXHRcXHQvLyBhc3N1bWVzIG1pbiA8IG1heCwgY29tcG9uZW50d2lzZVxcblxcblxcdFxcdFxcdHRoaXMueCA9IE1hdGgubWF4KCBtaW4ueCwgTWF0aC5taW4oIG1heC54LCB0aGlzLnggKSApO1xcblxcdFxcdFxcdHRoaXMueSA9IE1hdGgubWF4KCBtaW4ueSwgTWF0aC5taW4oIG1heC55LCB0aGlzLnkgKSApO1xcblxcdFxcdFxcdHRoaXMueiA9IE1hdGgubWF4KCBtaW4ueiwgTWF0aC5taW4oIG1heC56LCB0aGlzLnogKSApO1xcblxcdFxcdFxcdHRoaXMudyA9IE1hdGgubWF4KCBtaW4udywgTWF0aC5taW4oIG1heC53LCB0aGlzLncgKSApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xhbXBTY2FsYXI6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgbWluLCBtYXg7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGNsYW1wU2NhbGFyKCBtaW5WYWwsIG1heFZhbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG1pbiA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdG1pbiA9IG5ldyBWZWN0b3I0KCk7XFxuXFx0XFx0XFx0XFx0XFx0bWF4ID0gbmV3IFZlY3RvcjQoKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0bWluLnNldCggbWluVmFsLCBtaW5WYWwsIG1pblZhbCwgbWluVmFsICk7XFxuXFx0XFx0XFx0XFx0bWF4LnNldCggbWF4VmFsLCBtYXhWYWwsIG1heFZhbCwgbWF4VmFsICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuY2xhbXAoIG1pbiwgbWF4ICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0Y2xhbXBMZW5ndGg6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCBsZW5ndGggfHwgMSApLm11bHRpcGx5U2NhbGFyKCBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCBsZW5ndGggKSApICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRmbG9vcjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xcblxcdFxcdFxcdHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xcblxcdFxcdFxcdHRoaXMueiA9IE1hdGguZmxvb3IoIHRoaXMueiApO1xcblxcdFxcdFxcdHRoaXMudyA9IE1hdGguZmxvb3IoIHRoaXMudyApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2VpbDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XFxuXFx0XFx0XFx0dGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcXG5cXHRcXHRcXHR0aGlzLnogPSBNYXRoLmNlaWwoIHRoaXMueiApO1xcblxcdFxcdFxcdHRoaXMudyA9IE1hdGguY2VpbCggdGhpcy53ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyb3VuZDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xcblxcdFxcdFxcdHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xcblxcdFxcdFxcdHRoaXMueiA9IE1hdGgucm91bmQoIHRoaXMueiApO1xcblxcdFxcdFxcdHRoaXMudyA9IE1hdGgucm91bmQoIHRoaXMudyApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cm91bmRUb1plcm86IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcXG5cXHRcXHRcXHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcXG5cXHRcXHRcXHR0aGlzLnogPSAoIHRoaXMueiA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy56ICkgOiBNYXRoLmZsb29yKCB0aGlzLnogKTtcXG5cXHRcXHRcXHR0aGlzLncgPSAoIHRoaXMudyA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy53ICkgOiBNYXRoLmZsb29yKCB0aGlzLncgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9IC0gdGhpcy54O1xcblxcdFxcdFxcdHRoaXMueSA9IC0gdGhpcy55O1xcblxcdFxcdFxcdHRoaXMueiA9IC0gdGhpcy56O1xcblxcdFxcdFxcdHRoaXMudyA9IC0gdGhpcy53O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYueiArIHRoaXMudyAqIHYudztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGxlbmd0aDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bWFuaGF0dGFuTGVuZ3RoOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKSArIE1hdGguYWJzKCB0aGlzLnogKSArIE1hdGguYWJzKCB0aGlzLncgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSB8fCAxICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRMZW5ndGg6IGZ1bmN0aW9uICggbGVuZ3RoICkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCBsZW5ndGggKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGxlcnA6IGZ1bmN0aW9uICggdiwgYWxwaGEgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcXG5cXHRcXHRcXHR0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xcblxcdFxcdFxcdHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XFxuXFx0XFx0XFx0dGhpcy53ICs9ICggdi53IC0gdGhpcy53ICkgKiBhbHBoYTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGxlcnBWZWN0b3JzOiBmdW5jdGlvbiAoIHYxLCB2MiwgYWxwaGEgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdjIsIHYxICkubXVsdGlwbHlTY2FsYXIoIGFscGhhICkuYWRkKCB2MSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSAmJiAoIHYueiA9PT0gdGhpcy56ICkgJiYgKCB2LncgPT09IHRoaXMudyApICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XFxuXFx0XFx0XFx0dGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcXG5cXHRcXHRcXHR0aGlzLnogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xcblxcdFxcdFxcdHRoaXMudyA9IGFycmF5WyBvZmZzZXQgKyAzIF07XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcXG5cXHRcXHRcXHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcXG5cXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy56O1xcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLnc7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGFycmF5O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZnJvbUJ1ZmZlckF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBvZmZzZXQgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3I0OiBvZmZzZXQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIC5mcm9tQnVmZmVyQXR0cmlidXRlKCkuJyApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLnggPSBhdHRyaWJ1dGUuZ2V0WCggaW5kZXggKTtcXG5cXHRcXHRcXHR0aGlzLnkgPSBhdHRyaWJ1dGUuZ2V0WSggaW5kZXggKTtcXG5cXHRcXHRcXHR0aGlzLnogPSBhdHRyaWJ1dGUuZ2V0WiggaW5kZXggKTtcXG5cXHRcXHRcXHR0aGlzLncgPSBhdHRyaWJ1dGUuZ2V0VyggaW5kZXggKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3Igc3ppbWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9cXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqIEBhdXRob3IgTWFyaXVzIEtpbnRlbCAvIGh0dHBzOi8vZ2l0aHViLmNvbS9raW50ZWxcXG5cXHQgKi9cXG5cXG5cXHQvKlxcblxcdCBJbiBvcHRpb25zLCB3ZSBjYW4gc3BlY2lmeTpcXG5cXHQgKiBUZXh0dXJlIHBhcmFtZXRlcnMgZm9yIGFuIGF1dG8tZ2VuZXJhdGVkIHRhcmdldCB0ZXh0dXJlXFxuXFx0ICogZGVwdGhCdWZmZXIvc3RlbmNpbEJ1ZmZlcjogQm9vbGVhbnMgdG8gaW5kaWNhdGUgaWYgd2Ugc2hvdWxkIGdlbmVyYXRlIHRoZXNlIGJ1ZmZlcnNcXG5cXHQqL1xcblxcdGZ1bmN0aW9uIFdlYkdMUmVuZGVyVGFyZ2V0KCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICkge1xcblxcblxcdFxcdHRoaXMudXVpZCA9IF9NYXRoLmdlbmVyYXRlVVVJRCgpO1xcblxcblxcdFxcdHRoaXMud2lkdGggPSB3aWR0aDtcXG5cXHRcXHR0aGlzLmhlaWdodCA9IGhlaWdodDtcXG5cXG5cXHRcXHR0aGlzLnNjaXNzb3IgPSBuZXcgVmVjdG9yNCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xcblxcdFxcdHRoaXMuc2Npc3NvclRlc3QgPSBmYWxzZTtcXG5cXG5cXHRcXHR0aGlzLnZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcXG5cXG5cXHRcXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXG5cXHRcXHRpZiAoIG9wdGlvbnMubWluRmlsdGVyID09PSB1bmRlZmluZWQgKSBvcHRpb25zLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcXG5cXG5cXHRcXHR0aGlzLnRleHR1cmUgPSBuZXcgVGV4dHVyZSggdW5kZWZpbmVkLCB1bmRlZmluZWQsIG9wdGlvbnMud3JhcFMsIG9wdGlvbnMud3JhcFQsIG9wdGlvbnMubWFnRmlsdGVyLCBvcHRpb25zLm1pbkZpbHRlciwgb3B0aW9ucy5mb3JtYXQsIG9wdGlvbnMudHlwZSwgb3B0aW9ucy5hbmlzb3Ryb3B5LCBvcHRpb25zLmVuY29kaW5nICk7XFxuXFxuXFx0XFx0dGhpcy5kZXB0aEJ1ZmZlciA9IG9wdGlvbnMuZGVwdGhCdWZmZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVwdGhCdWZmZXIgOiB0cnVlO1xcblxcdFxcdHRoaXMuc3RlbmNpbEJ1ZmZlciA9IG9wdGlvbnMuc3RlbmNpbEJ1ZmZlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdGVuY2lsQnVmZmVyIDogdHJ1ZTtcXG5cXHRcXHR0aGlzLmRlcHRoVGV4dHVyZSA9IG9wdGlvbnMuZGVwdGhUZXh0dXJlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlcHRoVGV4dHVyZSA6IG51bGw7XFxuXFxuXFx0fVxcblxcblxcdFdlYkdMUmVuZGVyVGFyZ2V0LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBXZWJHTFJlbmRlclRhcmdldCxcXG5cXG5cXHRcXHRpc1dlYkdMUmVuZGVyVGFyZ2V0OiB0cnVlLFxcblxcblxcdFxcdHNldFNpemU6IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMud2lkdGggIT09IHdpZHRoIHx8IHRoaXMuaGVpZ2h0ICE9PSBoZWlnaHQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy53aWR0aCA9IHdpZHRoO1xcblxcdFxcdFxcdFxcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xcblxcblxcdFxcdFxcdFxcdHRoaXMuZGlzcG9zZSgpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLnZpZXdwb3J0LnNldCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xcblxcdFxcdFxcdHRoaXMuc2Npc3Nvci5zZXQoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy53aWR0aCA9IHNvdXJjZS53aWR0aDtcXG5cXHRcXHRcXHR0aGlzLmhlaWdodCA9IHNvdXJjZS5oZWlnaHQ7XFxuXFxuXFx0XFx0XFx0dGhpcy52aWV3cG9ydC5jb3B5KCBzb3VyY2Uudmlld3BvcnQgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLnRleHR1cmUgPSBzb3VyY2UudGV4dHVyZS5jbG9uZSgpO1xcblxcblxcdFxcdFxcdHRoaXMuZGVwdGhCdWZmZXIgPSBzb3VyY2UuZGVwdGhCdWZmZXI7XFxuXFx0XFx0XFx0dGhpcy5zdGVuY2lsQnVmZmVyID0gc291cmNlLnN0ZW5jaWxCdWZmZXI7XFxuXFx0XFx0XFx0dGhpcy5kZXB0aFRleHR1cmUgPSBzb3VyY2UuZGVwdGhUZXh0dXJlO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbVxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZSggd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApIHtcXG5cXG5cXHRcXHRXZWJHTFJlbmRlclRhcmdldC5jYWxsKCB0aGlzLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICk7XFxuXFxuXFx0XFx0dGhpcy5hY3RpdmVDdWJlRmFjZSA9IDA7IC8vIFBYIDAsIE5YIDEsIFBZIDIsIE5ZIDMsIFBaIDQsIE5aIDVcXG5cXHRcXHR0aGlzLmFjdGl2ZU1pcE1hcExldmVsID0gMDtcXG5cXG5cXHR9XFxuXFxuXFx0V2ViR0xSZW5kZXJUYXJnZXRDdWJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFdlYkdMUmVuZGVyVGFyZ2V0LnByb3RvdHlwZSApO1xcblxcdFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBXZWJHTFJlbmRlclRhcmdldEN1YmU7XFxuXFxuXFx0V2ViR0xSZW5kZXJUYXJnZXRDdWJlLnByb3RvdHlwZS5pc1dlYkdMUmVuZGVyVGFyZ2V0Q3ViZSA9IHRydWU7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBEYXRhVGV4dHVyZSggZGF0YSwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBhbmlzb3Ryb3B5LCBlbmNvZGluZyApIHtcXG5cXG5cXHRcXHRUZXh0dXJlLmNhbGwoIHRoaXMsIG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSwgZW5jb2RpbmcgKTtcXG5cXG5cXHRcXHR0aGlzLmltYWdlID0geyBkYXRhOiBkYXRhLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XFxuXFxuXFx0XFx0dGhpcy5tYWdGaWx0ZXIgPSBtYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1hZ0ZpbHRlciA6IE5lYXJlc3RGaWx0ZXI7XFxuXFx0XFx0dGhpcy5taW5GaWx0ZXIgPSBtaW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1pbkZpbHRlciA6IE5lYXJlc3RGaWx0ZXI7XFxuXFxuXFx0XFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLmZsaXBZID0gZmFsc2U7XFxuXFx0XFx0dGhpcy51bnBhY2tBbGlnbm1lbnQgPSAxO1xcblxcblxcdH1cXG5cXG5cXHREYXRhVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUZXh0dXJlLnByb3RvdHlwZSApO1xcblxcdERhdGFUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERhdGFUZXh0dXJlO1xcblxcblxcdERhdGFUZXh0dXJlLnByb3RvdHlwZS5pc0RhdGFUZXh0dXJlID0gdHJ1ZTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEN1YmVUZXh0dXJlKCBpbWFnZXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSwgZW5jb2RpbmcgKSB7XFxuXFxuXFx0XFx0aW1hZ2VzID0gaW1hZ2VzICE9PSB1bmRlZmluZWQgPyBpbWFnZXMgOiBbXTtcXG5cXHRcXHRtYXBwaW5nID0gbWFwcGluZyAhPT0gdW5kZWZpbmVkID8gbWFwcGluZyA6IEN1YmVSZWZsZWN0aW9uTWFwcGluZztcXG5cXG5cXHRcXHRUZXh0dXJlLmNhbGwoIHRoaXMsIGltYWdlcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5LCBlbmNvZGluZyApO1xcblxcblxcdFxcdHRoaXMuZmxpcFkgPSBmYWxzZTtcXG5cXG5cXHR9XFxuXFxuXFx0Q3ViZVRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVGV4dHVyZS5wcm90b3R5cGUgKTtcXG5cXHRDdWJlVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDdWJlVGV4dHVyZTtcXG5cXG5cXHRDdWJlVGV4dHVyZS5wcm90b3R5cGUuaXNDdWJlVGV4dHVyZSA9IHRydWU7XFxuXFxuXFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBDdWJlVGV4dHVyZS5wcm90b3R5cGUsICdpbWFnZXMnLCB7XFxuXFxuXFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuaW1hZ2U7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5pbWFnZSA9IHZhbHVlO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciB0c2Nod1xcblxcdCAqXFxuXFx0ICogVW5pZm9ybXMgb2YgYSBwcm9ncmFtLlxcblxcdCAqIFRob3NlIGZvcm0gYSB0cmVlIHN0cnVjdHVyZSB3aXRoIGEgc3BlY2lhbCB0b3AtbGV2ZWwgY29udGFpbmVyIGZvciB0aGUgcm9vdCxcXG5cXHQgKiB3aGljaCB5b3UgZ2V0IGJ5IGNhbGxpbmcgJ25ldyBXZWJHTFVuaWZvcm1zKCBnbCwgcHJvZ3JhbSwgcmVuZGVyZXIgKScuXFxuXFx0ICpcXG5cXHQgKlxcblxcdCAqIFByb3BlcnRpZXMgb2YgaW5uZXIgbm9kZXMgaW5jbHVkaW5nIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyOlxcblxcdCAqXFxuXFx0ICogLnNlcSAtIGFycmF5IG9mIG5lc3RlZCB1bmlmb3Jtc1xcblxcdCAqIC5tYXAgLSBuZXN0ZWQgdW5pZm9ybXMgYnkgbmFtZVxcblxcdCAqXFxuXFx0ICpcXG5cXHQgKiBNZXRob2RzIG9mIGFsbCBub2RlcyBleGNlcHQgdGhlIHRvcC1sZXZlbCBjb250YWluZXI6XFxuXFx0ICpcXG5cXHQgKiAuc2V0VmFsdWUoIGdsLCB2YWx1ZSwgW3JlbmRlcmVyXSApXFxuXFx0ICpcXG5cXHQgKiBcXHRcXHR1cGxvYWRzIGEgdW5pZm9ybSB2YWx1ZShzKVxcblxcdCAqICBcXHR0aGUgJ3JlbmRlcmVyJyBwYXJhbWV0ZXIgaXMgbmVlZGVkIGZvciBzYW1wbGVyIHVuaWZvcm1zXFxuXFx0ICpcXG5cXHQgKlxcblxcdCAqIFN0YXRpYyBtZXRob2RzIG9mIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyIChyZW5kZXJlciBmYWN0b3JpemF0aW9ucyk6XFxuXFx0ICpcXG5cXHQgKiAudXBsb2FkKCBnbCwgc2VxLCB2YWx1ZXMsIHJlbmRlcmVyIClcXG5cXHQgKlxcblxcdCAqIFxcdFxcdHNldHMgdW5pZm9ybXMgaW4gJ3NlcScgdG8gJ3ZhbHVlc1tpZF0udmFsdWUnXFxuXFx0ICpcXG5cXHQgKiAuc2VxV2l0aFZhbHVlKCBzZXEsIHZhbHVlcyApIDogZmlsdGVyZWRTZXFcXG5cXHQgKlxcblxcdCAqIFxcdFxcdGZpbHRlcnMgJ3NlcScgZW50cmllcyB3aXRoIGNvcnJlc3BvbmRpbmcgZW50cnkgaW4gdmFsdWVzXFxuXFx0ICpcXG5cXHQgKlxcblxcdCAqIE1ldGhvZHMgb2YgdGhlIHRvcC1sZXZlbCBjb250YWluZXIgKHJlbmRlcmVyIGZhY3Rvcml6YXRpb25zKTpcXG5cXHQgKlxcblxcdCAqIC5zZXRWYWx1ZSggZ2wsIG5hbWUsIHZhbHVlIClcXG5cXHQgKlxcblxcdCAqIFxcdFxcdHNldHMgdW5pZm9ybSB3aXRoICBuYW1lICduYW1lJyB0byAndmFsdWUnXFxuXFx0ICpcXG5cXHQgKiAuc2V0KCBnbCwgb2JqLCBwcm9wIClcXG5cXHQgKlxcblxcdCAqIFxcdFxcdHNldHMgdW5pZm9ybSBmcm9tIG9iamVjdCBhbmQgcHJvcGVydHkgd2l0aCBzYW1lIG5hbWUgdGhhbiB1bmlmb3JtXFxuXFx0ICpcXG5cXHQgKiAuc2V0T3B0aW9uYWwoIGdsLCBvYmosIHByb3AgKVxcblxcdCAqXFxuXFx0ICogXFx0XFx0bGlrZSAuc2V0IGZvciBhbiBvcHRpb25hbCBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0XFxuXFx0ICpcXG5cXHQgKi9cXG5cXG5cXHR2YXIgZW1wdHlUZXh0dXJlID0gbmV3IFRleHR1cmUoKTtcXG5cXHR2YXIgZW1wdHlDdWJlVGV4dHVyZSA9IG5ldyBDdWJlVGV4dHVyZSgpO1xcblxcblxcdC8vIC0tLSBCYXNlIGZvciBpbm5lciBub2RlcyAoaW5jbHVkaW5nIHRoZSByb290KSAtLS1cXG5cXG5cXHRmdW5jdGlvbiBVbmlmb3JtQ29udGFpbmVyKCkge1xcblxcblxcdFxcdHRoaXMuc2VxID0gW107XFxuXFx0XFx0dGhpcy5tYXAgPSB7fTtcXG5cXG5cXHR9XFxuXFxuXFx0Ly8gLS0tIFV0aWxpdGllcyAtLS1cXG5cXG5cXHQvLyBBcnJheSBDYWNoZXMgKHByb3ZpZGUgdHlwZWQgYXJyYXlzIGZvciB0ZW1wb3JhcnkgYnkgc2l6ZSlcXG5cXG5cXHR2YXIgYXJyYXlDYWNoZUYzMiA9IFtdO1xcblxcdHZhciBhcnJheUNhY2hlSTMyID0gW107XFxuXFxuXFx0Ly8gRmxvYXQzMkFycmF5IGNhY2hlcyB1c2VkIGZvciB1cGxvYWRpbmcgTWF0cml4IHVuaWZvcm1zXFxuXFxuXFx0dmFyIG1hdDRhcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDE2ICk7XFxuXFx0dmFyIG1hdDNhcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDkgKTtcXG5cXG5cXHQvLyBGbGF0dGVuaW5nIGZvciBhcnJheXMgb2YgdmVjdG9ycyBhbmQgbWF0cmljZXNcXG5cXG5cXHRmdW5jdGlvbiBmbGF0dGVuKCBhcnJheSwgbkJsb2NrcywgYmxvY2tTaXplICkge1xcblxcblxcdFxcdHZhciBmaXJzdEVsZW0gPSBhcnJheVsgMCBdO1xcblxcblxcdFxcdGlmICggZmlyc3RFbGVtIDw9IDAgfHwgZmlyc3RFbGVtID4gMCApIHJldHVybiBhcnJheTtcXG5cXHRcXHQvLyB1bm9wdGltaXplZDogISBpc05hTiggZmlyc3RFbGVtIClcXG5cXHRcXHQvLyBzZWUgaHR0cDovL2phY2tzb25kdW5zdGFuLmNvbS9hcnRpY2xlcy85ODNcXG5cXG5cXHRcXHR2YXIgbiA9IG5CbG9ja3MgKiBibG9ja1NpemUsXFxuXFx0XFx0XFx0ciA9IGFycmF5Q2FjaGVGMzJbIG4gXTtcXG5cXG5cXHRcXHRpZiAoIHIgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRyID0gbmV3IEZsb2F0MzJBcnJheSggbiApO1xcblxcdFxcdFxcdGFycmF5Q2FjaGVGMzJbIG4gXSA9IHI7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggbkJsb2NrcyAhPT0gMCApIHtcXG5cXG5cXHRcXHRcXHRmaXJzdEVsZW0udG9BcnJheSggciwgMCApO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMSwgb2Zmc2V0ID0gMDsgaSAhPT0gbkJsb2NrczsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHRcXHRvZmZzZXQgKz0gYmxvY2tTaXplO1xcblxcdFxcdFxcdFxcdGFycmF5WyBpIF0udG9BcnJheSggciwgb2Zmc2V0ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gcjtcXG5cXG5cXHR9XFxuXFxuXFx0Ly8gVGV4dHVyZSB1bml0IGFsbG9jYXRpb25cXG5cXG5cXHRmdW5jdGlvbiBhbGxvY1RleFVuaXRzKCByZW5kZXJlciwgbiApIHtcXG5cXG5cXHRcXHR2YXIgciA9IGFycmF5Q2FjaGVJMzJbIG4gXTtcXG5cXG5cXHRcXHRpZiAoIHIgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRyID0gbmV3IEludDMyQXJyYXkoIG4gKTtcXG5cXHRcXHRcXHRhcnJheUNhY2hlSTMyWyBuIF0gPSByO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG47ICsrIGkgKVxcblxcdFxcdFxcdHJbIGkgXSA9IHJlbmRlcmVyLmFsbG9jVGV4dHVyZVVuaXQoKTtcXG5cXG5cXHRcXHRyZXR1cm4gcjtcXG5cXG5cXHR9XFxuXFxuXFx0Ly8gLS0tIFNldHRlcnMgLS0tXFxuXFxuXFx0Ly8gTm90ZTogRGVmaW5pbmcgdGhlc2UgbWV0aG9kcyBleHRlcm5hbGx5LCBiZWNhdXNlIHRoZXkgY29tZSBpbiBhIGJ1bmNoXFxuXFx0Ly8gYW5kIHRoaXMgd2F5IHRoZWlyIG5hbWVzIG1pbmlmeS5cXG5cXG5cXHQvLyBTaW5nbGUgc2NhbGFyXFxuXFxuXFx0ZnVuY3Rpb24gc2V0VmFsdWUxZiggZ2wsIHYgKSB7XFxuXFxuXFx0XFx0Z2wudW5pZm9ybTFmKCB0aGlzLmFkZHIsIHYgKTtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gc2V0VmFsdWUxaSggZ2wsIHYgKSB7XFxuXFxuXFx0XFx0Z2wudW5pZm9ybTFpKCB0aGlzLmFkZHIsIHYgKTtcXG5cXG5cXHR9XFxuXFxuXFx0Ly8gU2luZ2xlIGZsb2F0IHZlY3RvciAoZnJvbSBmbGF0IGFycmF5IG9yIFRIUkVFLlZlY3Rvck4pXFxuXFxuXFx0ZnVuY3Rpb24gc2V0VmFsdWUyZnYoIGdsLCB2ICkge1xcblxcblxcdFxcdGlmICggdi54ID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0Z2wudW5pZm9ybTJmdiggdGhpcy5hZGRyLCB2ICk7XFxuXFxuXFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRnbC51bmlmb3JtMmYoIHRoaXMuYWRkciwgdi54LCB2LnkgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIHNldFZhbHVlM2Z2KCBnbCwgdiApIHtcXG5cXG5cXHRcXHRpZiAoIHYueCAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdGdsLnVuaWZvcm0zZiggdGhpcy5hZGRyLCB2LngsIHYueSwgdi56ICk7XFxuXFxuXFx0XFx0fSBlbHNlIGlmICggdi5yICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0Z2wudW5pZm9ybTNmKCB0aGlzLmFkZHIsIHYuciwgdi5nLCB2LmIgKTtcXG5cXG5cXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdGdsLnVuaWZvcm0zZnYoIHRoaXMuYWRkciwgdiApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gc2V0VmFsdWU0ZnYoIGdsLCB2ICkge1xcblxcblxcdFxcdGlmICggdi54ID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0Z2wudW5pZm9ybTRmdiggdGhpcy5hZGRyLCB2ICk7XFxuXFxuXFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHQgZ2wudW5pZm9ybTRmKCB0aGlzLmFkZHIsIHYueCwgdi55LCB2LnosIHYudyApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9XFxuXFxuXFx0Ly8gU2luZ2xlIG1hdHJpeCAoZnJvbSBmbGF0IGFycmF5IG9yIE1hdHJpeE4pXFxuXFxuXFx0ZnVuY3Rpb24gc2V0VmFsdWUyZm0oIGdsLCB2ICkge1xcblxcblxcdFxcdGdsLnVuaWZvcm1NYXRyaXgyZnYoIHRoaXMuYWRkciwgZmFsc2UsIHYuZWxlbWVudHMgfHwgdiApO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBzZXRWYWx1ZTNmbSggZ2wsIHYgKSB7XFxuXFxuXFx0XFx0aWYgKCB2LmVsZW1lbnRzID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0Z2wudW5pZm9ybU1hdHJpeDNmdiggdGhpcy5hZGRyLCBmYWxzZSwgdiApO1xcblxcblxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0bWF0M2FycmF5LnNldCggdi5lbGVtZW50cyApO1xcblxcdFxcdFxcdGdsLnVuaWZvcm1NYXRyaXgzZnYoIHRoaXMuYWRkciwgZmFsc2UsIG1hdDNhcnJheSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gc2V0VmFsdWU0Zm0oIGdsLCB2ICkge1xcblxcblxcdFxcdGlmICggdi5lbGVtZW50cyA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHRoaXMuYWRkciwgZmFsc2UsIHYgKTtcXG5cXG5cXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdG1hdDRhcnJheS5zZXQoIHYuZWxlbWVudHMgKTtcXG5cXHRcXHRcXHRnbC51bmlmb3JtTWF0cml4NGZ2KCB0aGlzLmFkZHIsIGZhbHNlLCBtYXQ0YXJyYXkgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fVxcblxcblxcdC8vIFNpbmdsZSB0ZXh0dXJlICgyRCAvIEN1YmUpXFxuXFxuXFx0ZnVuY3Rpb24gc2V0VmFsdWVUMSggZ2wsIHYsIHJlbmRlcmVyICkge1xcblxcblxcdFxcdHZhciB1bml0ID0gcmVuZGVyZXIuYWxsb2NUZXh0dXJlVW5pdCgpO1xcblxcdFxcdGdsLnVuaWZvcm0xaSggdGhpcy5hZGRyLCB1bml0ICk7XFxuXFx0XFx0cmVuZGVyZXIuc2V0VGV4dHVyZTJEKCB2IHx8IGVtcHR5VGV4dHVyZSwgdW5pdCApO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBzZXRWYWx1ZVQ2KCBnbCwgdiwgcmVuZGVyZXIgKSB7XFxuXFxuXFx0XFx0dmFyIHVuaXQgPSByZW5kZXJlci5hbGxvY1RleHR1cmVVbml0KCk7XFxuXFx0XFx0Z2wudW5pZm9ybTFpKCB0aGlzLmFkZHIsIHVuaXQgKTtcXG5cXHRcXHRyZW5kZXJlci5zZXRUZXh0dXJlQ3ViZSggdiB8fCBlbXB0eUN1YmVUZXh0dXJlLCB1bml0ICk7XFxuXFxuXFx0fVxcblxcblxcdC8vIEludGVnZXIgLyBCb29sZWFuIHZlY3RvcnMgb3IgYXJyYXlzIHRoZXJlb2YgKGFsd2F5cyBmbGF0IGFycmF5cylcXG5cXG5cXHRmdW5jdGlvbiBzZXRWYWx1ZTJpdiggZ2wsIHYgKSB7XFxuXFxuXFx0XFx0Z2wudW5pZm9ybTJpdiggdGhpcy5hZGRyLCB2ICk7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIHNldFZhbHVlM2l2KCBnbCwgdiApIHtcXG5cXG5cXHRcXHRnbC51bmlmb3JtM2l2KCB0aGlzLmFkZHIsIHYgKTtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gc2V0VmFsdWU0aXYoIGdsLCB2ICkge1xcblxcblxcdFxcdGdsLnVuaWZvcm00aXYoIHRoaXMuYWRkciwgdiApO1xcblxcblxcdH1cXG5cXG5cXHQvLyBIZWxwZXIgdG8gcGljayB0aGUgcmlnaHQgc2V0dGVyIGZvciB0aGUgc2luZ3VsYXIgY2FzZVxcblxcblxcdGZ1bmN0aW9uIGdldFNpbmd1bGFyU2V0dGVyKCB0eXBlICkge1xcblxcblxcdFxcdHN3aXRjaCAoIHR5cGUgKSB7XFxuXFxuXFx0XFx0XFx0Y2FzZSAweDE0MDY6IHJldHVybiBzZXRWYWx1ZTFmOyAvLyBGTE9BVFxcblxcdFxcdFxcdGNhc2UgMHg4YjUwOiByZXR1cm4gc2V0VmFsdWUyZnY7IC8vIF9WRUMyXFxuXFx0XFx0XFx0Y2FzZSAweDhiNTE6IHJldHVybiBzZXRWYWx1ZTNmdjsgLy8gX1ZFQzNcXG5cXHRcXHRcXHRjYXNlIDB4OGI1MjogcmV0dXJuIHNldFZhbHVlNGZ2OyAvLyBfVkVDNFxcblxcblxcdFxcdFxcdGNhc2UgMHg4YjVhOiByZXR1cm4gc2V0VmFsdWUyZm07IC8vIF9NQVQyXFxuXFx0XFx0XFx0Y2FzZSAweDhiNWI6IHJldHVybiBzZXRWYWx1ZTNmbTsgLy8gX01BVDNcXG5cXHRcXHRcXHRjYXNlIDB4OGI1YzogcmV0dXJuIHNldFZhbHVlNGZtOyAvLyBfTUFUNFxcblxcblxcdFxcdFxcdGNhc2UgMHg4YjVlOiBjYXNlIDB4OGQ2NjogcmV0dXJuIHNldFZhbHVlVDE7IC8vIFNBTVBMRVJfMkQsIFNBTVBMRVJfRVhURVJOQUxfT0VTXFxuXFx0XFx0XFx0Y2FzZSAweDhiNjA6IHJldHVybiBzZXRWYWx1ZVQ2OyAvLyBTQU1QTEVSX0NVQkVcXG5cXG5cXHRcXHRcXHRjYXNlIDB4MTQwNDogY2FzZSAweDhiNTY6IHJldHVybiBzZXRWYWx1ZTFpOyAvLyBJTlQsIEJPT0xcXG5cXHRcXHRcXHRjYXNlIDB4OGI1MzogY2FzZSAweDhiNTc6IHJldHVybiBzZXRWYWx1ZTJpdjsgLy8gX1ZFQzJcXG5cXHRcXHRcXHRjYXNlIDB4OGI1NDogY2FzZSAweDhiNTg6IHJldHVybiBzZXRWYWx1ZTNpdjsgLy8gX1ZFQzNcXG5cXHRcXHRcXHRjYXNlIDB4OGI1NTogY2FzZSAweDhiNTk6IHJldHVybiBzZXRWYWx1ZTRpdjsgLy8gX1ZFQzRcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fVxcblxcblxcdC8vIEFycmF5IG9mIHNjYWxhcnNcXG5cXG5cXHRmdW5jdGlvbiBzZXRWYWx1ZTFmdiggZ2wsIHYgKSB7XFxuXFxuXFx0XFx0Z2wudW5pZm9ybTFmdiggdGhpcy5hZGRyLCB2ICk7XFxuXFxuXFx0fVxcblxcdGZ1bmN0aW9uIHNldFZhbHVlMWl2KCBnbCwgdiApIHtcXG5cXG5cXHRcXHRnbC51bmlmb3JtMWl2KCB0aGlzLmFkZHIsIHYgKTtcXG5cXG5cXHR9XFxuXFxuXFx0Ly8gQXJyYXkgb2YgdmVjdG9ycyAoZmxhdCBvciBmcm9tIFRIUkVFIGNsYXNzZXMpXFxuXFxuXFx0ZnVuY3Rpb24gc2V0VmFsdWVWMmEoIGdsLCB2ICkge1xcblxcblxcdFxcdGdsLnVuaWZvcm0yZnYoIHRoaXMuYWRkciwgZmxhdHRlbiggdiwgdGhpcy5zaXplLCAyICkgKTtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gc2V0VmFsdWVWM2EoIGdsLCB2ICkge1xcblxcblxcdFxcdGdsLnVuaWZvcm0zZnYoIHRoaXMuYWRkciwgZmxhdHRlbiggdiwgdGhpcy5zaXplLCAzICkgKTtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gc2V0VmFsdWVWNGEoIGdsLCB2ICkge1xcblxcblxcdFxcdGdsLnVuaWZvcm00ZnYoIHRoaXMuYWRkciwgZmxhdHRlbiggdiwgdGhpcy5zaXplLCA0ICkgKTtcXG5cXG5cXHR9XFxuXFxuXFx0Ly8gQXJyYXkgb2YgbWF0cmljZXMgKGZsYXQgb3IgZnJvbSBUSFJFRSBjbGFzZXMpXFxuXFxuXFx0ZnVuY3Rpb24gc2V0VmFsdWVNMmEoIGdsLCB2ICkge1xcblxcblxcdFxcdGdsLnVuaWZvcm1NYXRyaXgyZnYoIHRoaXMuYWRkciwgZmFsc2UsIGZsYXR0ZW4oIHYsIHRoaXMuc2l6ZSwgNCApICk7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIHNldFZhbHVlTTNhKCBnbCwgdiApIHtcXG5cXG5cXHRcXHRnbC51bmlmb3JtTWF0cml4M2Z2KCB0aGlzLmFkZHIsIGZhbHNlLCBmbGF0dGVuKCB2LCB0aGlzLnNpemUsIDkgKSApO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBzZXRWYWx1ZU00YSggZ2wsIHYgKSB7XFxuXFxuXFx0XFx0Z2wudW5pZm9ybU1hdHJpeDRmdiggdGhpcy5hZGRyLCBmYWxzZSwgZmxhdHRlbiggdiwgdGhpcy5zaXplLCAxNiApICk7XFxuXFxuXFx0fVxcblxcblxcdC8vIEFycmF5IG9mIHRleHR1cmVzICgyRCAvIEN1YmUpXFxuXFxuXFx0ZnVuY3Rpb24gc2V0VmFsdWVUMWEoIGdsLCB2LCByZW5kZXJlciApIHtcXG5cXG5cXHRcXHR2YXIgbiA9IHYubGVuZ3RoLFxcblxcdFxcdFxcdHVuaXRzID0gYWxsb2NUZXhVbml0cyggcmVuZGVyZXIsIG4gKTtcXG5cXG5cXHRcXHRnbC51bmlmb3JtMWl2KCB0aGlzLmFkZHIsIHVuaXRzICk7XFxuXFxuXFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuOyArKyBpICkge1xcblxcblxcdFxcdFxcdHJlbmRlcmVyLnNldFRleHR1cmUyRCggdlsgaSBdIHx8IGVtcHR5VGV4dHVyZSwgdW5pdHNbIGkgXSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gc2V0VmFsdWVUNmEoIGdsLCB2LCByZW5kZXJlciApIHtcXG5cXG5cXHRcXHR2YXIgbiA9IHYubGVuZ3RoLFxcblxcdFxcdFxcdHVuaXRzID0gYWxsb2NUZXhVbml0cyggcmVuZGVyZXIsIG4gKTtcXG5cXG5cXHRcXHRnbC51bmlmb3JtMWl2KCB0aGlzLmFkZHIsIHVuaXRzICk7XFxuXFxuXFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuOyArKyBpICkge1xcblxcblxcdFxcdFxcdHJlbmRlcmVyLnNldFRleHR1cmVDdWJlKCB2WyBpIF0gfHwgZW1wdHlDdWJlVGV4dHVyZSwgdW5pdHNbIGkgXSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9XFxuXFxuXFx0Ly8gSGVscGVyIHRvIHBpY2sgdGhlIHJpZ2h0IHNldHRlciBmb3IgYSBwdXJlIChib3R0b20tbGV2ZWwpIGFycmF5XFxuXFxuXFx0ZnVuY3Rpb24gZ2V0UHVyZUFycmF5U2V0dGVyKCB0eXBlICkge1xcblxcblxcdFxcdHN3aXRjaCAoIHR5cGUgKSB7XFxuXFxuXFx0XFx0XFx0Y2FzZSAweDE0MDY6IHJldHVybiBzZXRWYWx1ZTFmdjsgLy8gRkxPQVRcXG5cXHRcXHRcXHRjYXNlIDB4OGI1MDogcmV0dXJuIHNldFZhbHVlVjJhOyAvLyBfVkVDMlxcblxcdFxcdFxcdGNhc2UgMHg4YjUxOiByZXR1cm4gc2V0VmFsdWVWM2E7IC8vIF9WRUMzXFxuXFx0XFx0XFx0Y2FzZSAweDhiNTI6IHJldHVybiBzZXRWYWx1ZVY0YTsgLy8gX1ZFQzRcXG5cXG5cXHRcXHRcXHRjYXNlIDB4OGI1YTogcmV0dXJuIHNldFZhbHVlTTJhOyAvLyBfTUFUMlxcblxcdFxcdFxcdGNhc2UgMHg4YjViOiByZXR1cm4gc2V0VmFsdWVNM2E7IC8vIF9NQVQzXFxuXFx0XFx0XFx0Y2FzZSAweDhiNWM6IHJldHVybiBzZXRWYWx1ZU00YTsgLy8gX01BVDRcXG5cXG5cXHRcXHRcXHRjYXNlIDB4OGI1ZTogcmV0dXJuIHNldFZhbHVlVDFhOyAvLyBTQU1QTEVSXzJEXFxuXFx0XFx0XFx0Y2FzZSAweDhiNjA6IHJldHVybiBzZXRWYWx1ZVQ2YTsgLy8gU0FNUExFUl9DVUJFXFxuXFxuXFx0XFx0XFx0Y2FzZSAweDE0MDQ6IGNhc2UgMHg4YjU2OiByZXR1cm4gc2V0VmFsdWUxaXY7IC8vIElOVCwgQk9PTFxcblxcdFxcdFxcdGNhc2UgMHg4YjUzOiBjYXNlIDB4OGI1NzogcmV0dXJuIHNldFZhbHVlMml2OyAvLyBfVkVDMlxcblxcdFxcdFxcdGNhc2UgMHg4YjU0OiBjYXNlIDB4OGI1ODogcmV0dXJuIHNldFZhbHVlM2l2OyAvLyBfVkVDM1xcblxcdFxcdFxcdGNhc2UgMHg4YjU1OiBjYXNlIDB4OGI1OTogcmV0dXJuIHNldFZhbHVlNGl2OyAvLyBfVkVDNFxcblxcblxcdFxcdH1cXG5cXG5cXHR9XFxuXFxuXFx0Ly8gLS0tIFVuaWZvcm0gQ2xhc3NlcyAtLS1cXG5cXG5cXHRmdW5jdGlvbiBTaW5nbGVVbmlmb3JtKCBpZCwgYWN0aXZlSW5mbywgYWRkciApIHtcXG5cXG5cXHRcXHR0aGlzLmlkID0gaWQ7XFxuXFx0XFx0dGhpcy5hZGRyID0gYWRkcjtcXG5cXHRcXHR0aGlzLnNldFZhbHVlID0gZ2V0U2luZ3VsYXJTZXR0ZXIoIGFjdGl2ZUluZm8udHlwZSApO1xcblxcblxcdFxcdC8vIHRoaXMucGF0aCA9IGFjdGl2ZUluZm8ubmFtZTsgLy8gREVCVUdcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gUHVyZUFycmF5VW5pZm9ybSggaWQsIGFjdGl2ZUluZm8sIGFkZHIgKSB7XFxuXFxuXFx0XFx0dGhpcy5pZCA9IGlkO1xcblxcdFxcdHRoaXMuYWRkciA9IGFkZHI7XFxuXFx0XFx0dGhpcy5zaXplID0gYWN0aXZlSW5mby5zaXplO1xcblxcdFxcdHRoaXMuc2V0VmFsdWUgPSBnZXRQdXJlQXJyYXlTZXR0ZXIoIGFjdGl2ZUluZm8udHlwZSApO1xcblxcblxcdFxcdC8vIHRoaXMucGF0aCA9IGFjdGl2ZUluZm8ubmFtZTsgLy8gREVCVUdcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gU3RydWN0dXJlZFVuaWZvcm0oIGlkICkge1xcblxcblxcdFxcdHRoaXMuaWQgPSBpZDtcXG5cXG5cXHRcXHRVbmlmb3JtQ29udGFpbmVyLmNhbGwoIHRoaXMgKTsgLy8gbWl4LWluXFxuXFxuXFx0fVxcblxcblxcdFN0cnVjdHVyZWRVbmlmb3JtLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICggZ2wsIHZhbHVlICkge1xcblxcblxcdFxcdC8vIE5vdGU6IERvbid0IG5lZWQgYW4gZXh0cmEgJ3JlbmRlcmVyJyBwYXJhbWV0ZXIsIHNpbmNlIHNhbXBsZXJzXFxuXFx0XFx0Ly8gYXJlIG5vdCBhbGxvd2VkIGluIHN0cnVjdHVyZWQgdW5pZm9ybXMuXFxuXFxuXFx0XFx0dmFyIHNlcSA9IHRoaXMuc2VxO1xcblxcblxcdFxcdGZvciAoIHZhciBpID0gMCwgbiA9IHNlcS5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHUgPSBzZXFbIGkgXTtcXG5cXHRcXHRcXHR1LnNldFZhbHVlKCBnbCwgdmFsdWVbIHUuaWQgXSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9O1xcblxcblxcdC8vIC0tLSBUb3AtbGV2ZWwgLS0tXFxuXFxuXFx0Ly8gUGFyc2VyIC0gYnVpbGRzIHVwIHRoZSBwcm9wZXJ0eSB0cmVlIGZyb20gdGhlIHBhdGggc3RyaW5nc1xcblxcblxcdHZhciBSZVBhdGhQYXJ0ID0gLyhbXFxcXHdcXFxcZF9dKykoXFxcXF0pPyhcXFxcW3xcXFxcLik/L2c7XFxuXFxuXFx0Ly8gZXh0cmFjdHNcXG5cXHQvLyBcXHQtIHRoZSBpZGVudGlmaWVyIChtZW1iZXIgbmFtZSBvciBhcnJheSBpbmRleClcXG5cXHQvLyAgLSBmb2xsb3dlZCBieSBhbiBvcHRpb25hbCByaWdodCBicmFja2V0IChmb3VuZCB3aGVuIGFycmF5IGluZGV4KVxcblxcdC8vICAtIGZvbGxvd2VkIGJ5IGFuIG9wdGlvbmFsIGxlZnQgYnJhY2tldCBvciBkb3QgKHR5cGUgb2Ygc3Vic2NyaXB0KVxcblxcdC8vXFxuXFx0Ly8gTm90ZTogVGhlc2UgcG9ydGlvbnMgY2FuIGJlIHJlYWQgaW4gYSBub24tb3ZlcmxhcHBpbmcgZmFzaGlvbiBhbmRcXG5cXHQvLyBhbGxvdyBzdHJhaWdodGZvcndhcmQgcGFyc2luZyBvZiB0aGUgaGllcmFyY2h5IHRoYXQgV2ViR0wgZW5jb2Rlc1xcblxcdC8vIGluIHRoZSB1bmlmb3JtIG5hbWVzLlxcblxcblxcdGZ1bmN0aW9uIGFkZFVuaWZvcm0oIGNvbnRhaW5lciwgdW5pZm9ybU9iamVjdCApIHtcXG5cXG5cXHRcXHRjb250YWluZXIuc2VxLnB1c2goIHVuaWZvcm1PYmplY3QgKTtcXG5cXHRcXHRjb250YWluZXIubWFwWyB1bmlmb3JtT2JqZWN0LmlkIF0gPSB1bmlmb3JtT2JqZWN0O1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBwYXJzZVVuaWZvcm0oIGFjdGl2ZUluZm8sIGFkZHIsIGNvbnRhaW5lciApIHtcXG5cXG5cXHRcXHR2YXIgcGF0aCA9IGFjdGl2ZUluZm8ubmFtZSxcXG5cXHRcXHRcXHRwYXRoTGVuZ3RoID0gcGF0aC5sZW5ndGg7XFxuXFxuXFx0XFx0Ly8gcmVzZXQgUmVnRXhwIG9iamVjdCwgYmVjYXVzZSBvZiB0aGUgZWFybHkgZXhpdCBvZiBhIHByZXZpb3VzIHJ1blxcblxcdFxcdFJlUGF0aFBhcnQubGFzdEluZGV4ID0gMDtcXG5cXG5cXHRcXHRmb3IgKCA7IDsgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIG1hdGNoID0gUmVQYXRoUGFydC5leGVjKCBwYXRoICksXFxuXFx0XFx0XFx0XFx0bWF0Y2hFbmQgPSBSZVBhdGhQYXJ0Lmxhc3RJbmRleCxcXG5cXG5cXHRcXHRcXHRcXHRpZCA9IG1hdGNoWyAxIF0sXFxuXFx0XFx0XFx0XFx0aWRJc0luZGV4ID0gbWF0Y2hbIDIgXSA9PT0gJ10nLFxcblxcdFxcdFxcdFxcdHN1YnNjcmlwdCA9IG1hdGNoWyAzIF07XFxuXFxuXFx0XFx0XFx0aWYgKCBpZElzSW5kZXggKSBpZCA9IGlkIHwgMDsgLy8gY29udmVydCB0byBpbnRlZ2VyXFxuXFxuXFx0XFx0XFx0aWYgKCBzdWJzY3JpcHQgPT09IHVuZGVmaW5lZCB8fCBzdWJzY3JpcHQgPT09ICdbJyAmJiBtYXRjaEVuZCArIDIgPT09IHBhdGhMZW5ndGggKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gYmFyZSBuYW1lIG9yIFxcXCJwdXJlXFxcIiBib3R0b20tbGV2ZWwgYXJyYXkgXFxcIlswXVxcXCIgc3VmZml4XFxuXFxuXFx0XFx0XFx0XFx0YWRkVW5pZm9ybSggY29udGFpbmVyLCBzdWJzY3JpcHQgPT09IHVuZGVmaW5lZCA/XFxuXFx0XFx0XFx0XFx0XFx0bmV3IFNpbmdsZVVuaWZvcm0oIGlkLCBhY3RpdmVJbmZvLCBhZGRyICkgOlxcblxcdFxcdFxcdFxcdFxcdG5ldyBQdXJlQXJyYXlVbmlmb3JtKCBpZCwgYWN0aXZlSW5mbywgYWRkciApICk7XFxuXFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBzdGVwIGludG8gaW5uZXIgbm9kZSAvIGNyZWF0ZSBpdCBpbiBjYXNlIGl0IGRvZXNuJ3QgZXhpc3RcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbWFwID0gY29udGFpbmVyLm1hcCwgbmV4dCA9IG1hcFsgaWQgXTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG5leHQgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRuZXh0ID0gbmV3IFN0cnVjdHVyZWRVbmlmb3JtKCBpZCApO1xcblxcdFxcdFxcdFxcdFxcdGFkZFVuaWZvcm0oIGNvbnRhaW5lciwgbmV4dCApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRjb250YWluZXIgPSBuZXh0O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0fVxcblxcblxcdC8vIFJvb3QgQ29udGFpbmVyXFxuXFxuXFx0ZnVuY3Rpb24gV2ViR0xVbmlmb3JtcyggZ2wsIHByb2dyYW0sIHJlbmRlcmVyICkge1xcblxcblxcdFxcdFVuaWZvcm1Db250YWluZXIuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcXG5cXG5cXHRcXHR2YXIgbiA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLkFDVElWRV9VTklGT1JNUyApO1xcblxcblxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IG47ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGluZm8gPSBnbC5nZXRBY3RpdmVVbmlmb3JtKCBwcm9ncmFtLCBpICksXFxuXFx0XFx0XFx0XFx0cGF0aCA9IGluZm8ubmFtZSxcXG5cXHRcXHRcXHRcXHRhZGRyID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBwYXRoICk7XFxuXFxuXFx0XFx0XFx0cGFyc2VVbmlmb3JtKCBpbmZvLCBhZGRyLCB0aGlzICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH1cXG5cXG5cXHRXZWJHTFVuaWZvcm1zLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uICggZ2wsIG5hbWUsIHZhbHVlICkge1xcblxcblxcdFxcdHZhciB1ID0gdGhpcy5tYXBbIG5hbWUgXTtcXG5cXG5cXHRcXHRpZiAoIHUgIT09IHVuZGVmaW5lZCApIHUuc2V0VmFsdWUoIGdsLCB2YWx1ZSwgdGhpcy5yZW5kZXJlciApO1xcblxcblxcdH07XFxuXFxuXFx0V2ViR0xVbmlmb3Jtcy5wcm90b3R5cGUuc2V0T3B0aW9uYWwgPSBmdW5jdGlvbiAoIGdsLCBvYmplY3QsIG5hbWUgKSB7XFxuXFxuXFx0XFx0dmFyIHYgPSBvYmplY3RbIG5hbWUgXTtcXG5cXG5cXHRcXHRpZiAoIHYgIT09IHVuZGVmaW5lZCApIHRoaXMuc2V0VmFsdWUoIGdsLCBuYW1lLCB2ICk7XFxuXFxuXFx0fTtcXG5cXG5cXG5cXHQvLyBTdGF0aWMgaW50ZXJmYWNlXFxuXFxuXFx0V2ViR0xVbmlmb3Jtcy51cGxvYWQgPSBmdW5jdGlvbiAoIGdsLCBzZXEsIHZhbHVlcywgcmVuZGVyZXIgKSB7XFxuXFxuXFx0XFx0Zm9yICggdmFyIGkgPSAwLCBuID0gc2VxLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdSA9IHNlcVsgaSBdLFxcblxcdFxcdFxcdFxcdHYgPSB2YWx1ZXNbIHUuaWQgXTtcXG5cXG5cXHRcXHRcXHRpZiAoIHYubmVlZHNVcGRhdGUgIT09IGZhbHNlICkge1xcblxcblxcdFxcdFxcdFxcdC8vIG5vdGU6IGFsd2F5cyB1cGRhdGluZyB3aGVuIC5uZWVkc1VwZGF0ZSBpcyB1bmRlZmluZWRcXG5cXHRcXHRcXHRcXHR1LnNldFZhbHVlKCBnbCwgdi52YWx1ZSwgcmVuZGVyZXIgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdH07XFxuXFxuXFx0V2ViR0xVbmlmb3Jtcy5zZXFXaXRoVmFsdWUgPSBmdW5jdGlvbiAoIHNlcSwgdmFsdWVzICkge1xcblxcblxcdFxcdHZhciByID0gW107XFxuXFxuXFx0XFx0Zm9yICggdmFyIGkgPSAwLCBuID0gc2VxLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdSA9IHNlcVsgaSBdO1xcblxcdFxcdFxcdGlmICggdS5pZCBpbiB2YWx1ZXMgKSByLnB1c2goIHUgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHI7XFxuXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdHZhciBDb2xvcktleXdvcmRzID0geyAnYWxpY2VibHVlJzogMHhGMEY4RkYsICdhbnRpcXVld2hpdGUnOiAweEZBRUJENywgJ2FxdWEnOiAweDAwRkZGRiwgJ2FxdWFtYXJpbmUnOiAweDdGRkZENCwgJ2F6dXJlJzogMHhGMEZGRkYsXFxuXFx0XFx0J2JlaWdlJzogMHhGNUY1REMsICdiaXNxdWUnOiAweEZGRTRDNCwgJ2JsYWNrJzogMHgwMDAwMDAsICdibGFuY2hlZGFsbW9uZCc6IDB4RkZFQkNELCAnYmx1ZSc6IDB4MDAwMEZGLCAnYmx1ZXZpb2xldCc6IDB4OEEyQkUyLFxcblxcdFxcdCdicm93bic6IDB4QTUyQTJBLCAnYnVybHl3b29kJzogMHhERUI4ODcsICdjYWRldGJsdWUnOiAweDVGOUVBMCwgJ2NoYXJ0cmV1c2UnOiAweDdGRkYwMCwgJ2Nob2NvbGF0ZSc6IDB4RDI2OTFFLCAnY29yYWwnOiAweEZGN0Y1MCxcXG5cXHRcXHQnY29ybmZsb3dlcmJsdWUnOiAweDY0OTVFRCwgJ2Nvcm5zaWxrJzogMHhGRkY4REMsICdjcmltc29uJzogMHhEQzE0M0MsICdjeWFuJzogMHgwMEZGRkYsICdkYXJrYmx1ZSc6IDB4MDAwMDhCLCAnZGFya2N5YW4nOiAweDAwOEI4QixcXG5cXHRcXHQnZGFya2dvbGRlbnJvZCc6IDB4Qjg4NjBCLCAnZGFya2dyYXknOiAweEE5QTlBOSwgJ2RhcmtncmVlbic6IDB4MDA2NDAwLCAnZGFya2dyZXknOiAweEE5QTlBOSwgJ2RhcmtraGFraSc6IDB4QkRCNzZCLCAnZGFya21hZ2VudGEnOiAweDhCMDA4QixcXG5cXHRcXHQnZGFya29saXZlZ3JlZW4nOiAweDU1NkIyRiwgJ2RhcmtvcmFuZ2UnOiAweEZGOEMwMCwgJ2RhcmtvcmNoaWQnOiAweDk5MzJDQywgJ2RhcmtyZWQnOiAweDhCMDAwMCwgJ2RhcmtzYWxtb24nOiAweEU5OTY3QSwgJ2RhcmtzZWFncmVlbic6IDB4OEZCQzhGLFxcblxcdFxcdCdkYXJrc2xhdGVibHVlJzogMHg0ODNEOEIsICdkYXJrc2xhdGVncmF5JzogMHgyRjRGNEYsICdkYXJrc2xhdGVncmV5JzogMHgyRjRGNEYsICdkYXJrdHVycXVvaXNlJzogMHgwMENFRDEsICdkYXJrdmlvbGV0JzogMHg5NDAwRDMsXFxuXFx0XFx0J2RlZXBwaW5rJzogMHhGRjE0OTMsICdkZWVwc2t5Ymx1ZSc6IDB4MDBCRkZGLCAnZGltZ3JheSc6IDB4Njk2OTY5LCAnZGltZ3JleSc6IDB4Njk2OTY5LCAnZG9kZ2VyYmx1ZSc6IDB4MUU5MEZGLCAnZmlyZWJyaWNrJzogMHhCMjIyMjIsXFxuXFx0XFx0J2Zsb3JhbHdoaXRlJzogMHhGRkZBRjAsICdmb3Jlc3RncmVlbic6IDB4MjI4QjIyLCAnZnVjaHNpYSc6IDB4RkYwMEZGLCAnZ2FpbnNib3JvJzogMHhEQ0RDREMsICdnaG9zdHdoaXRlJzogMHhGOEY4RkYsICdnb2xkJzogMHhGRkQ3MDAsXFxuXFx0XFx0J2dvbGRlbnJvZCc6IDB4REFBNTIwLCAnZ3JheSc6IDB4ODA4MDgwLCAnZ3JlZW4nOiAweDAwODAwMCwgJ2dyZWVueWVsbG93JzogMHhBREZGMkYsICdncmV5JzogMHg4MDgwODAsICdob25leWRldyc6IDB4RjBGRkYwLCAnaG90cGluayc6IDB4RkY2OUI0LFxcblxcdFxcdCdpbmRpYW5yZWQnOiAweENENUM1QywgJ2luZGlnbyc6IDB4NEIwMDgyLCAnaXZvcnknOiAweEZGRkZGMCwgJ2toYWtpJzogMHhGMEU2OEMsICdsYXZlbmRlcic6IDB4RTZFNkZBLCAnbGF2ZW5kZXJibHVzaCc6IDB4RkZGMEY1LCAnbGF3bmdyZWVuJzogMHg3Q0ZDMDAsXFxuXFx0XFx0J2xlbW9uY2hpZmZvbic6IDB4RkZGQUNELCAnbGlnaHRibHVlJzogMHhBREQ4RTYsICdsaWdodGNvcmFsJzogMHhGMDgwODAsICdsaWdodGN5YW4nOiAweEUwRkZGRiwgJ2xpZ2h0Z29sZGVucm9keWVsbG93JzogMHhGQUZBRDIsICdsaWdodGdyYXknOiAweEQzRDNEMyxcXG5cXHRcXHQnbGlnaHRncmVlbic6IDB4OTBFRTkwLCAnbGlnaHRncmV5JzogMHhEM0QzRDMsICdsaWdodHBpbmsnOiAweEZGQjZDMSwgJ2xpZ2h0c2FsbW9uJzogMHhGRkEwN0EsICdsaWdodHNlYWdyZWVuJzogMHgyMEIyQUEsICdsaWdodHNreWJsdWUnOiAweDg3Q0VGQSxcXG5cXHRcXHQnbGlnaHRzbGF0ZWdyYXknOiAweDc3ODg5OSwgJ2xpZ2h0c2xhdGVncmV5JzogMHg3Nzg4OTksICdsaWdodHN0ZWVsYmx1ZSc6IDB4QjBDNERFLCAnbGlnaHR5ZWxsb3cnOiAweEZGRkZFMCwgJ2xpbWUnOiAweDAwRkYwMCwgJ2xpbWVncmVlbic6IDB4MzJDRDMyLFxcblxcdFxcdCdsaW5lbic6IDB4RkFGMEU2LCAnbWFnZW50YSc6IDB4RkYwMEZGLCAnbWFyb29uJzogMHg4MDAwMDAsICdtZWRpdW1hcXVhbWFyaW5lJzogMHg2NkNEQUEsICdtZWRpdW1ibHVlJzogMHgwMDAwQ0QsICdtZWRpdW1vcmNoaWQnOiAweEJBNTVEMyxcXG5cXHRcXHQnbWVkaXVtcHVycGxlJzogMHg5MzcwREIsICdtZWRpdW1zZWFncmVlbic6IDB4M0NCMzcxLCAnbWVkaXVtc2xhdGVibHVlJzogMHg3QjY4RUUsICdtZWRpdW1zcHJpbmdncmVlbic6IDB4MDBGQTlBLCAnbWVkaXVtdHVycXVvaXNlJzogMHg0OEQxQ0MsXFxuXFx0XFx0J21lZGl1bXZpb2xldHJlZCc6IDB4QzcxNTg1LCAnbWlkbmlnaHRibHVlJzogMHgxOTE5NzAsICdtaW50Y3JlYW0nOiAweEY1RkZGQSwgJ21pc3R5cm9zZSc6IDB4RkZFNEUxLCAnbW9jY2FzaW4nOiAweEZGRTRCNSwgJ25hdmFqb3doaXRlJzogMHhGRkRFQUQsXFxuXFx0XFx0J25hdnknOiAweDAwMDA4MCwgJ29sZGxhY2UnOiAweEZERjVFNiwgJ29saXZlJzogMHg4MDgwMDAsICdvbGl2ZWRyYWInOiAweDZCOEUyMywgJ29yYW5nZSc6IDB4RkZBNTAwLCAnb3JhbmdlcmVkJzogMHhGRjQ1MDAsICdvcmNoaWQnOiAweERBNzBENixcXG5cXHRcXHQncGFsZWdvbGRlbnJvZCc6IDB4RUVFOEFBLCAncGFsZWdyZWVuJzogMHg5OEZCOTgsICdwYWxldHVycXVvaXNlJzogMHhBRkVFRUUsICdwYWxldmlvbGV0cmVkJzogMHhEQjcwOTMsICdwYXBheWF3aGlwJzogMHhGRkVGRDUsICdwZWFjaHB1ZmYnOiAweEZGREFCOSxcXG5cXHRcXHQncGVydSc6IDB4Q0Q4NTNGLCAncGluayc6IDB4RkZDMENCLCAncGx1bSc6IDB4RERBMERELCAncG93ZGVyYmx1ZSc6IDB4QjBFMEU2LCAncHVycGxlJzogMHg4MDAwODAsICdyZWJlY2NhcHVycGxlJzogMHg2NjMzOTksICdyZWQnOiAweEZGMDAwMCwgJ3Jvc3licm93bic6IDB4QkM4RjhGLFxcblxcdFxcdCdyb3lhbGJsdWUnOiAweDQxNjlFMSwgJ3NhZGRsZWJyb3duJzogMHg4QjQ1MTMsICdzYWxtb24nOiAweEZBODA3MiwgJ3NhbmR5YnJvd24nOiAweEY0QTQ2MCwgJ3NlYWdyZWVuJzogMHgyRThCNTcsICdzZWFzaGVsbCc6IDB4RkZGNUVFLFxcblxcdFxcdCdzaWVubmEnOiAweEEwNTIyRCwgJ3NpbHZlcic6IDB4QzBDMEMwLCAnc2t5Ymx1ZSc6IDB4ODdDRUVCLCAnc2xhdGVibHVlJzogMHg2QTVBQ0QsICdzbGF0ZWdyYXknOiAweDcwODA5MCwgJ3NsYXRlZ3JleSc6IDB4NzA4MDkwLCAnc25vdyc6IDB4RkZGQUZBLFxcblxcdFxcdCdzcHJpbmdncmVlbic6IDB4MDBGRjdGLCAnc3RlZWxibHVlJzogMHg0NjgyQjQsICd0YW4nOiAweEQyQjQ4QywgJ3RlYWwnOiAweDAwODA4MCwgJ3RoaXN0bGUnOiAweEQ4QkZEOCwgJ3RvbWF0byc6IDB4RkY2MzQ3LCAndHVycXVvaXNlJzogMHg0MEUwRDAsXFxuXFx0XFx0J3Zpb2xldCc6IDB4RUU4MkVFLCAnd2hlYXQnOiAweEY1REVCMywgJ3doaXRlJzogMHhGRkZGRkYsICd3aGl0ZXNtb2tlJzogMHhGNUY1RjUsICd5ZWxsb3cnOiAweEZGRkYwMCwgJ3llbGxvd2dyZWVuJzogMHg5QUNEMzIgfTtcXG5cXG5cXHRmdW5jdGlvbiBDb2xvciggciwgZywgYiApIHtcXG5cXG5cXHRcXHRpZiAoIGcgPT09IHVuZGVmaW5lZCAmJiBiID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gciBpcyBUSFJFRS5Db2xvciwgaGV4IG9yIHN0cmluZ1xcblxcdFxcdFxcdHJldHVybiB0aGlzLnNldCggciApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdGhpcy5zZXRSR0IoIHIsIGcsIGIgKTtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggQ29sb3IucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0aXNDb2xvcjogdHJ1ZSxcXG5cXG5cXHRcXHRyOiAxLCBnOiAxLCBiOiAxLFxcblxcblxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHZhbHVlICYmIHZhbHVlLmlzQ29sb3IgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5jb3B5KCB2YWx1ZSApO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5zZXRIZXgoIHZhbHVlICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnNldFN0eWxlKCB2YWx1ZSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5yID0gc2NhbGFyO1xcblxcdFxcdFxcdHRoaXMuZyA9IHNjYWxhcjtcXG5cXHRcXHRcXHR0aGlzLmIgPSBzY2FsYXI7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRIZXg6IGZ1bmN0aW9uICggaGV4ICkge1xcblxcblxcdFxcdFxcdGhleCA9IE1hdGguZmxvb3IoIGhleCApO1xcblxcblxcdFxcdFxcdHRoaXMuciA9ICggaGV4ID4+IDE2ICYgMjU1ICkgLyAyNTU7XFxuXFx0XFx0XFx0dGhpcy5nID0gKCBoZXggPj4gOCAmIDI1NSApIC8gMjU1O1xcblxcdFxcdFxcdHRoaXMuYiA9ICggaGV4ICYgMjU1ICkgLyAyNTU7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRSR0I6IGZ1bmN0aW9uICggciwgZywgYiApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnIgPSByO1xcblxcdFxcdFxcdHRoaXMuZyA9IGc7XFxuXFx0XFx0XFx0dGhpcy5iID0gYjtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldEhTTDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGZ1bmN0aW9uIGh1ZTJyZ2IoIHAsIHEsIHQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB0IDwgMCApIHQgKz0gMTtcXG5cXHRcXHRcXHRcXHRpZiAoIHQgPiAxICkgdCAtPSAxO1xcblxcdFxcdFxcdFxcdGlmICggdCA8IDEgLyA2ICkgcmV0dXJuIHAgKyAoIHEgLSBwICkgKiA2ICogdDtcXG5cXHRcXHRcXHRcXHRpZiAoIHQgPCAxIC8gMiApIHJldHVybiBxO1xcblxcdFxcdFxcdFxcdGlmICggdCA8IDIgLyAzICkgcmV0dXJuIHAgKyAoIHEgLSBwICkgKiA2ICogKCAyIC8gMyAtIHQgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHNldEhTTCggaCwgcywgbCApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxcblxcdFxcdFxcdFxcdGggPSBfTWF0aC5ldWNsaWRlYW5Nb2R1bG8oIGgsIDEgKTtcXG5cXHRcXHRcXHRcXHRzID0gX01hdGguY2xhbXAoIHMsIDAsIDEgKTtcXG5cXHRcXHRcXHRcXHRsID0gX01hdGguY2xhbXAoIGwsIDAsIDEgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHMgPT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5yID0gdGhpcy5nID0gdGhpcy5iID0gbDtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBwID0gbCA8PSAwLjUgPyBsICogKCAxICsgcyApIDogbCArIHMgLSAoIGwgKiBzICk7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHEgPSAoIDIgKiBsICkgLSBwO1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuciA9IGh1ZTJyZ2IoIHEsIHAsIGggKyAxIC8gMyApO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZyA9IGh1ZTJyZ2IoIHEsIHAsIGggKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmIgPSBodWUycmdiKCBxLCBwLCBoIC0gMSAvIDMgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0c2V0U3R5bGU6IGZ1bmN0aW9uICggc3R5bGUgKSB7XFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gaGFuZGxlQWxwaGEoIHN0cmluZyApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHN0cmluZyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xcblxcblxcdFxcdFxcdFxcdGlmICggcGFyc2VGbG9hdCggc3RyaW5nICkgPCAxICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbG9yOiBBbHBoYSBjb21wb25lbnQgb2YgJyArIHN0eWxlICsgJyB3aWxsIGJlIGlnbm9yZWQuJyApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFxuXFx0XFx0XFx0dmFyIG07XFxuXFxuXFx0XFx0XFx0aWYgKCBtID0gL14oKD86cmdifGhzbClhPylcXFxcKFxcXFxzKihbXlxcXFwpXSopXFxcXCkvLmV4ZWMoIHN0eWxlICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gcmdiIC8gaHNsXFxuXFxuXFx0XFx0XFx0XFx0dmFyIGNvbG9yO1xcblxcdFxcdFxcdFxcdHZhciBuYW1lID0gbVsgMSBdO1xcblxcdFxcdFxcdFxcdHZhciBjb21wb25lbnRzID0gbVsgMiBdO1xcblxcblxcdFxcdFxcdFxcdHN3aXRjaCAoIG5hbWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAncmdiJzpcXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdyZ2JhJzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGNvbG9yID0gL14oXFxcXGQrKVxcXFxzKixcXFxccyooXFxcXGQrKVxcXFxzKixcXFxccyooXFxcXGQrKVxcXFxzKigsXFxcXHMqKFswLTldKlxcXFwuP1swLTldKylcXFxccyopPyQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyByZ2IoMjU1LDAsMCkgcmdiYSgyNTUsMCwwLDAuNSlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnIgPSBNYXRoLm1pbiggMjU1LCBwYXJzZUludCggY29sb3JbIDEgXSwgMTAgKSApIC8gMjU1O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuZyA9IE1hdGgubWluKCAyNTUsIHBhcnNlSW50KCBjb2xvclsgMiBdLCAxMCApICkgLyAyNTU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5iID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDI1NTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRoYW5kbGVBbHBoYSggY29sb3JbIDUgXSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGNvbG9yID0gL14oXFxcXGQrKVxcXFwlXFxcXHMqLFxcXFxzKihcXFxcZCspXFxcXCVcXFxccyosXFxcXHMqKFxcXFxkKylcXFxcJVxcXFxzKigsXFxcXHMqKFswLTldKlxcXFwuP1swLTldKylcXFxccyopPyQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyByZ2IoMTAwJSwwJSwwJSkgcmdiYSgxMDAlLDAlLDAlLDAuNSlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnIgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDEgXSwgMTAgKSApIC8gMTAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuZyA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMiBdLCAxMCApICkgLyAxMDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5iID0gTWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDEwMDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRoYW5kbGVBbHBoYSggY29sb3JbIDUgXSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdoc2wnOlxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ2hzbGEnOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggY29sb3IgPSAvXihbMC05XSpcXFxcLj9bMC05XSspXFxcXHMqLFxcXFxzKihcXFxcZCspXFxcXCVcXFxccyosXFxcXHMqKFxcXFxkKylcXFxcJVxcXFxzKigsXFxcXHMqKFswLTldKlxcXFwuP1swLTldKylcXFxccyopPyQvLmV4ZWMoIGNvbXBvbmVudHMgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBoc2woMTIwLDUwJSw1MCUpIGhzbGEoMTIwLDUwJSw1MCUsMC41KVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBoID0gcGFyc2VGbG9hdCggY29sb3JbIDEgXSApIC8gMzYwO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBzID0gcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgLyAxMDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGwgPSBwYXJzZUludCggY29sb3JbIDMgXSwgMTAgKSAvIDEwMDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRoYW5kbGVBbHBoYSggY29sb3JbIDUgXSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnNldEhTTCggaCwgcywgbCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggbSA9IC9eXFxcXCMoW0EtRmEtZjAtOV0rKSQvLmV4ZWMoIHN0eWxlICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gaGV4IGNvbG9yXFxuXFxuXFx0XFx0XFx0XFx0dmFyIGhleCA9IG1bIDEgXTtcXG5cXHRcXHRcXHRcXHR2YXIgc2l6ZSA9IGhleC5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBzaXplID09PSAzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vICNmZjBcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnIgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMCApICsgaGV4LmNoYXJBdCggMCApLCAxNiApIC8gMjU1O1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZyA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAxICkgKyBoZXguY2hhckF0KCAxICksIDE2ICkgLyAyNTU7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5iID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDIgKSArIGhleC5jaGFyQXQoIDIgKSwgMTYgKSAvIDI1NTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBzaXplID09PSA2ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vICNmZjAwMDBcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnIgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMCApICsgaGV4LmNoYXJBdCggMSApLCAxNiApIC8gMjU1O1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZyA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAyICkgKyBoZXguY2hhckF0KCAzICksIDE2ICkgLyAyNTU7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5iID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDQgKSArIGhleC5jaGFyQXQoIDUgKSwgMTYgKSAvIDI1NTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggc3R5bGUgJiYgc3R5bGUubGVuZ3RoID4gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBjb2xvciBrZXl3b3Jkc1xcblxcdFxcdFxcdFxcdHZhciBoZXggPSBDb2xvcktleXdvcmRzWyBzdHlsZSBdO1xcblxcblxcdFxcdFxcdFxcdGlmICggaGV4ICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gcmVkXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5zZXRIZXgoIGhleCApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdW5rbm93biBjb2xvclxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkNvbG9yOiBVbmtub3duIGNvbG9yICcgKyBzdHlsZSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBjb2xvciApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnIgPSBjb2xvci5yO1xcblxcdFxcdFxcdHRoaXMuZyA9IGNvbG9yLmc7XFxuXFx0XFx0XFx0dGhpcy5iID0gY29sb3IuYjtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHlHYW1tYVRvTGluZWFyOiBmdW5jdGlvbiAoIGNvbG9yLCBnYW1tYUZhY3RvciApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGdhbW1hRmFjdG9yID09PSB1bmRlZmluZWQgKSBnYW1tYUZhY3RvciA9IDIuMDtcXG5cXG5cXHRcXHRcXHR0aGlzLnIgPSBNYXRoLnBvdyggY29sb3IuciwgZ2FtbWFGYWN0b3IgKTtcXG5cXHRcXHRcXHR0aGlzLmcgPSBNYXRoLnBvdyggY29sb3IuZywgZ2FtbWFGYWN0b3IgKTtcXG5cXHRcXHRcXHR0aGlzLmIgPSBNYXRoLnBvdyggY29sb3IuYiwgZ2FtbWFGYWN0b3IgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHlMaW5lYXJUb0dhbW1hOiBmdW5jdGlvbiAoIGNvbG9yLCBnYW1tYUZhY3RvciApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGdhbW1hRmFjdG9yID09PSB1bmRlZmluZWQgKSBnYW1tYUZhY3RvciA9IDIuMDtcXG5cXG5cXHRcXHRcXHR2YXIgc2FmZUludmVyc2UgPSAoIGdhbW1hRmFjdG9yID4gMCApID8gKCAxLjAgLyBnYW1tYUZhY3RvciApIDogMS4wO1xcblxcblxcdFxcdFxcdHRoaXMuciA9IE1hdGgucG93KCBjb2xvci5yLCBzYWZlSW52ZXJzZSApO1xcblxcdFxcdFxcdHRoaXMuZyA9IE1hdGgucG93KCBjb2xvci5nLCBzYWZlSW52ZXJzZSApO1xcblxcdFxcdFxcdHRoaXMuYiA9IE1hdGgucG93KCBjb2xvci5iLCBzYWZlSW52ZXJzZSApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29udmVydEdhbW1hVG9MaW5lYXI6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgciA9IHRoaXMuciwgZyA9IHRoaXMuZywgYiA9IHRoaXMuYjtcXG5cXG5cXHRcXHRcXHR0aGlzLnIgPSByICogcjtcXG5cXHRcXHRcXHR0aGlzLmcgPSBnICogZztcXG5cXHRcXHRcXHR0aGlzLmIgPSBiICogYjtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvbnZlcnRMaW5lYXJUb0dhbW1hOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5yID0gTWF0aC5zcXJ0KCB0aGlzLnIgKTtcXG5cXHRcXHRcXHR0aGlzLmcgPSBNYXRoLnNxcnQoIHRoaXMuZyApO1xcblxcdFxcdFxcdHRoaXMuYiA9IE1hdGguc3FydCggdGhpcy5iICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRIZXg6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gKCB0aGlzLnIgKiAyNTUgKSA8PCAxNiBeICggdGhpcy5nICogMjU1ICkgPDwgOCBeICggdGhpcy5iICogMjU1ICkgPDwgMDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldEhleFN0cmluZzogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiAoICcwMDAwMDAnICsgdGhpcy5nZXRIZXgoKS50b1N0cmluZyggMTYgKSApLnNsaWNlKCAtIDYgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldEhTTDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHQvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxcblxcblxcdFxcdFxcdHZhciBoc2wgPSBvcHRpb25hbFRhcmdldCB8fCB7IGg6IDAsIHM6IDAsIGw6IDAgfTtcXG5cXG5cXHRcXHRcXHR2YXIgciA9IHRoaXMuciwgZyA9IHRoaXMuZywgYiA9IHRoaXMuYjtcXG5cXG5cXHRcXHRcXHR2YXIgbWF4ID0gTWF0aC5tYXgoIHIsIGcsIGIgKTtcXG5cXHRcXHRcXHR2YXIgbWluID0gTWF0aC5taW4oIHIsIGcsIGIgKTtcXG5cXG5cXHRcXHRcXHR2YXIgaHVlLCBzYXR1cmF0aW9uO1xcblxcdFxcdFxcdHZhciBsaWdodG5lc3MgPSAoIG1pbiArIG1heCApIC8gMi4wO1xcblxcblxcdFxcdFxcdGlmICggbWluID09PSBtYXggKSB7XFxuXFxuXFx0XFx0XFx0XFx0aHVlID0gMDtcXG5cXHRcXHRcXHRcXHRzYXR1cmF0aW9uID0gMDtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdHZhciBkZWx0YSA9IG1heCAtIG1pbjtcXG5cXG5cXHRcXHRcXHRcXHRzYXR1cmF0aW9uID0gbGlnaHRuZXNzIDw9IDAuNSA/IGRlbHRhIC8gKCBtYXggKyBtaW4gKSA6IGRlbHRhIC8gKCAyIC0gbWF4IC0gbWluICk7XFxuXFxuXFx0XFx0XFx0XFx0c3dpdGNoICggbWF4ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNhc2UgcjogaHVlID0gKCBnIC0gYiApIC8gZGVsdGEgKyAoIGcgPCBiID8gNiA6IDAgKTsgYnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSBnOiBodWUgPSAoIGIgLSByICkgLyBkZWx0YSArIDI7IGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdGNhc2UgYjogaHVlID0gKCByIC0gZyApIC8gZGVsdGEgKyA0OyBicmVhaztcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aHVlIC89IDY7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGhzbC5oID0gaHVlO1xcblxcdFxcdFxcdGhzbC5zID0gc2F0dXJhdGlvbjtcXG5cXHRcXHRcXHRoc2wubCA9IGxpZ2h0bmVzcztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gaHNsO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0U3R5bGU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gJ3JnYignICsgKCAoIHRoaXMuciAqIDI1NSApIHwgMCApICsgJywnICsgKCAoIHRoaXMuZyAqIDI1NSApIHwgMCApICsgJywnICsgKCAoIHRoaXMuYiAqIDI1NSApIHwgMCApICsgJyknO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0b2Zmc2V0SFNMOiBmdW5jdGlvbiAoIGgsIHMsIGwgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGhzbCA9IHRoaXMuZ2V0SFNMKCk7XFxuXFxuXFx0XFx0XFx0aHNsLmggKz0gaDsgaHNsLnMgKz0gczsgaHNsLmwgKz0gbDtcXG5cXG5cXHRcXHRcXHR0aGlzLnNldEhTTCggaHNsLmgsIGhzbC5zLCBoc2wubCApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YWRkOiBmdW5jdGlvbiAoIGNvbG9yICkge1xcblxcblxcdFxcdFxcdHRoaXMuciArPSBjb2xvci5yO1xcblxcdFxcdFxcdHRoaXMuZyArPSBjb2xvci5nO1xcblxcdFxcdFxcdHRoaXMuYiArPSBjb2xvci5iO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YWRkQ29sb3JzOiBmdW5jdGlvbiAoIGNvbG9yMSwgY29sb3IyICkge1xcblxcblxcdFxcdFxcdHRoaXMuciA9IGNvbG9yMS5yICsgY29sb3IyLnI7XFxuXFx0XFx0XFx0dGhpcy5nID0gY29sb3IxLmcgKyBjb2xvcjIuZztcXG5cXHRcXHRcXHR0aGlzLmIgPSBjb2xvcjEuYiArIGNvbG9yMi5iO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5yICs9IHM7XFxuXFx0XFx0XFx0dGhpcy5nICs9IHM7XFxuXFx0XFx0XFx0dGhpcy5iICs9IHM7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzdWI6IGZ1bmN0aW9uICggY29sb3IgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5yID0gTWF0aC5tYXgoIDAsIHRoaXMuciAtIGNvbG9yLnIgKTtcXG5cXHRcXHRcXHR0aGlzLmcgPSBNYXRoLm1heCggMCwgdGhpcy5nIC0gY29sb3IuZyApO1xcblxcdFxcdFxcdHRoaXMuYiA9IE1hdGgubWF4KCAwLCB0aGlzLmIgLSBjb2xvci5iICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRtdWx0aXBseTogZnVuY3Rpb24gKCBjb2xvciApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnIgKj0gY29sb3IucjtcXG5cXHRcXHRcXHR0aGlzLmcgKj0gY29sb3IuZztcXG5cXHRcXHRcXHR0aGlzLmIgKj0gY29sb3IuYjtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5yICo9IHM7XFxuXFx0XFx0XFx0dGhpcy5nICo9IHM7XFxuXFx0XFx0XFx0dGhpcy5iICo9IHM7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRsZXJwOiBmdW5jdGlvbiAoIGNvbG9yLCBhbHBoYSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnIgKz0gKCBjb2xvci5yIC0gdGhpcy5yICkgKiBhbHBoYTtcXG5cXHRcXHRcXHR0aGlzLmcgKz0gKCBjb2xvci5nIC0gdGhpcy5nICkgKiBhbHBoYTtcXG5cXHRcXHRcXHR0aGlzLmIgKz0gKCBjb2xvci5iIC0gdGhpcy5iICkgKiBhbHBoYTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGVxdWFsczogZnVuY3Rpb24gKCBjICkge1xcblxcblxcdFxcdFxcdHJldHVybiAoIGMuciA9PT0gdGhpcy5yICkgJiYgKCBjLmcgPT09IHRoaXMuZyApICYmICggYy5iID09PSB0aGlzLmIgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xcblxcblxcdFxcdFxcdHRoaXMuciA9IGFycmF5WyBvZmZzZXQgXTtcXG5cXHRcXHRcXHR0aGlzLmcgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xcblxcdFxcdFxcdHRoaXMuYiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcXG5cXHRcXHRcXHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcXG5cXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLnI7XFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuZztcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5iO1xcblxcblxcdFxcdFxcdHJldHVybiBhcnJheTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHRvSlNPTjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmdldEhleCgpO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogVW5pZm9ybXMgbGlicmFyeSBmb3Igc2hhcmVkIHdlYmdsIHNoYWRlcnNcXG5cXHQgKi9cXG5cXG5cXHR2YXIgVW5pZm9ybXNMaWIgPSB7XFxuXFxuXFx0XFx0Y29tbW9uOiB7XFxuXFxuXFx0XFx0XFx0ZGlmZnVzZTogeyB2YWx1ZTogbmV3IENvbG9yKCAweGVlZWVlZSApIH0sXFxuXFx0XFx0XFx0b3BhY2l0eTogeyB2YWx1ZTogMS4wIH0sXFxuXFxuXFx0XFx0XFx0bWFwOiB7IHZhbHVlOiBudWxsIH0sXFxuXFx0XFx0XFx0dXZUcmFuc2Zvcm06IHsgdmFsdWU6IG5ldyBNYXRyaXgzKCkgfSxcXG5cXG5cXHRcXHRcXHRhbHBoYU1hcDogeyB2YWx1ZTogbnVsbCB9LFxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c3BlY3VsYXJtYXA6IHtcXG5cXG5cXHRcXHRcXHRzcGVjdWxhck1hcDogeyB2YWx1ZTogbnVsbCB9LFxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZW52bWFwOiB7XFxuXFxuXFx0XFx0XFx0ZW52TWFwOiB7IHZhbHVlOiBudWxsIH0sXFxuXFx0XFx0XFx0ZmxpcEVudk1hcDogeyB2YWx1ZTogLSAxIH0sXFxuXFx0XFx0XFx0cmVmbGVjdGl2aXR5OiB7IHZhbHVlOiAxLjAgfSxcXG5cXHRcXHRcXHRyZWZyYWN0aW9uUmF0aW86IHsgdmFsdWU6IDAuOTggfVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YW9tYXA6IHtcXG5cXG5cXHRcXHRcXHRhb01hcDogeyB2YWx1ZTogbnVsbCB9LFxcblxcdFxcdFxcdGFvTWFwSW50ZW5zaXR5OiB7IHZhbHVlOiAxIH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGxpZ2h0bWFwOiB7XFxuXFxuXFx0XFx0XFx0bGlnaHRNYXA6IHsgdmFsdWU6IG51bGwgfSxcXG5cXHRcXHRcXHRsaWdodE1hcEludGVuc2l0eTogeyB2YWx1ZTogMSB9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRlbWlzc2l2ZW1hcDoge1xcblxcblxcdFxcdFxcdGVtaXNzaXZlTWFwOiB7IHZhbHVlOiBudWxsIH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGJ1bXBtYXA6IHtcXG5cXG5cXHRcXHRcXHRidW1wTWFwOiB7IHZhbHVlOiBudWxsIH0sXFxuXFx0XFx0XFx0YnVtcFNjYWxlOiB7IHZhbHVlOiAxIH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG5vcm1hbG1hcDoge1xcblxcblxcdFxcdFxcdG5vcm1hbE1hcDogeyB2YWx1ZTogbnVsbCB9LFxcblxcdFxcdFxcdG5vcm1hbFNjYWxlOiB7IHZhbHVlOiBuZXcgVmVjdG9yMiggMSwgMSApIH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGRpc3BsYWNlbWVudG1hcDoge1xcblxcblxcdFxcdFxcdGRpc3BsYWNlbWVudE1hcDogeyB2YWx1ZTogbnVsbCB9LFxcblxcdFxcdFxcdGRpc3BsYWNlbWVudFNjYWxlOiB7IHZhbHVlOiAxIH0sXFxuXFx0XFx0XFx0ZGlzcGxhY2VtZW50QmlhczogeyB2YWx1ZTogMCB9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyb3VnaG5lc3NtYXA6IHtcXG5cXG5cXHRcXHRcXHRyb3VnaG5lc3NNYXA6IHsgdmFsdWU6IG51bGwgfVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bWV0YWxuZXNzbWFwOiB7XFxuXFxuXFx0XFx0XFx0bWV0YWxuZXNzTWFwOiB7IHZhbHVlOiBudWxsIH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdyYWRpZW50bWFwOiB7XFxuXFxuXFx0XFx0XFx0Z3JhZGllbnRNYXA6IHsgdmFsdWU6IG51bGwgfVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Zm9nOiB7XFxuXFxuXFx0XFx0XFx0Zm9nRGVuc2l0eTogeyB2YWx1ZTogMC4wMDAyNSB9LFxcblxcdFxcdFxcdGZvZ05lYXI6IHsgdmFsdWU6IDEgfSxcXG5cXHRcXHRcXHRmb2dGYXI6IHsgdmFsdWU6IDIwMDAgfSxcXG5cXHRcXHRcXHRmb2dDb2xvcjogeyB2YWx1ZTogbmV3IENvbG9yKCAweGZmZmZmZiApIH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGxpZ2h0czoge1xcblxcblxcdFxcdFxcdGFtYmllbnRMaWdodENvbG9yOiB7IHZhbHVlOiBbXSB9LFxcblxcblxcdFxcdFxcdGRpcmVjdGlvbmFsTGlnaHRzOiB7IHZhbHVlOiBbXSwgcHJvcGVydGllczoge1xcblxcdFxcdFxcdFxcdGRpcmVjdGlvbjoge30sXFxuXFx0XFx0XFx0XFx0Y29sb3I6IHt9LFxcblxcblxcdFxcdFxcdFxcdHNoYWRvdzoge30sXFxuXFx0XFx0XFx0XFx0c2hhZG93Qmlhczoge30sXFxuXFx0XFx0XFx0XFx0c2hhZG93UmFkaXVzOiB7fSxcXG5cXHRcXHRcXHRcXHRzaGFkb3dNYXBTaXplOiB7fVxcblxcdFxcdFxcdH0gfSxcXG5cXG5cXHRcXHRcXHRkaXJlY3Rpb25hbFNoYWRvd01hcDogeyB2YWx1ZTogW10gfSxcXG5cXHRcXHRcXHRkaXJlY3Rpb25hbFNoYWRvd01hdHJpeDogeyB2YWx1ZTogW10gfSxcXG5cXG5cXHRcXHRcXHRzcG90TGlnaHRzOiB7IHZhbHVlOiBbXSwgcHJvcGVydGllczoge1xcblxcdFxcdFxcdFxcdGNvbG9yOiB7fSxcXG5cXHRcXHRcXHRcXHRwb3NpdGlvbjoge30sXFxuXFx0XFx0XFx0XFx0ZGlyZWN0aW9uOiB7fSxcXG5cXHRcXHRcXHRcXHRkaXN0YW5jZToge30sXFxuXFx0XFx0XFx0XFx0Y29uZUNvczoge30sXFxuXFx0XFx0XFx0XFx0cGVudW1icmFDb3M6IHt9LFxcblxcdFxcdFxcdFxcdGRlY2F5OiB7fSxcXG5cXG5cXHRcXHRcXHRcXHRzaGFkb3c6IHt9LFxcblxcdFxcdFxcdFxcdHNoYWRvd0JpYXM6IHt9LFxcblxcdFxcdFxcdFxcdHNoYWRvd1JhZGl1czoge30sXFxuXFx0XFx0XFx0XFx0c2hhZG93TWFwU2l6ZToge31cXG5cXHRcXHRcXHR9IH0sXFxuXFxuXFx0XFx0XFx0c3BvdFNoYWRvd01hcDogeyB2YWx1ZTogW10gfSxcXG5cXHRcXHRcXHRzcG90U2hhZG93TWF0cml4OiB7IHZhbHVlOiBbXSB9LFxcblxcblxcdFxcdFxcdHBvaW50TGlnaHRzOiB7IHZhbHVlOiBbXSwgcHJvcGVydGllczoge1xcblxcdFxcdFxcdFxcdGNvbG9yOiB7fSxcXG5cXHRcXHRcXHRcXHRwb3NpdGlvbjoge30sXFxuXFx0XFx0XFx0XFx0ZGVjYXk6IHt9LFxcblxcdFxcdFxcdFxcdGRpc3RhbmNlOiB7fSxcXG5cXG5cXHRcXHRcXHRcXHRzaGFkb3c6IHt9LFxcblxcdFxcdFxcdFxcdHNoYWRvd0JpYXM6IHt9LFxcblxcdFxcdFxcdFxcdHNoYWRvd1JhZGl1czoge30sXFxuXFx0XFx0XFx0XFx0c2hhZG93TWFwU2l6ZToge30sXFxuXFx0XFx0XFx0XFx0c2hhZG93Q2FtZXJhTmVhcjoge30sXFxuXFx0XFx0XFx0XFx0c2hhZG93Q2FtZXJhRmFyOiB7fVxcblxcdFxcdFxcdH0gfSxcXG5cXG5cXHRcXHRcXHRwb2ludFNoYWRvd01hcDogeyB2YWx1ZTogW10gfSxcXG5cXHRcXHRcXHRwb2ludFNoYWRvd01hdHJpeDogeyB2YWx1ZTogW10gfSxcXG5cXG5cXHRcXHRcXHRoZW1pc3BoZXJlTGlnaHRzOiB7IHZhbHVlOiBbXSwgcHJvcGVydGllczoge1xcblxcdFxcdFxcdFxcdGRpcmVjdGlvbjoge30sXFxuXFx0XFx0XFx0XFx0c2t5Q29sb3I6IHt9LFxcblxcdFxcdFxcdFxcdGdyb3VuZENvbG9yOiB7fVxcblxcdFxcdFxcdH0gfSxcXG5cXG5cXHRcXHRcXHQvLyBUT0RPIChhYmVsbmF0aW9uKTogUmVjdEFyZWFMaWdodCBCUkRGIGRhdGEgbmVlZHMgdG8gYmUgbW92ZWQgZnJvbSBleGFtcGxlIHRvIG1haW4gc3JjXFxuXFx0XFx0XFx0cmVjdEFyZWFMaWdodHM6IHsgdmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7XFxuXFx0XFx0XFx0XFx0Y29sb3I6IHt9LFxcblxcdFxcdFxcdFxcdHBvc2l0aW9uOiB7fSxcXG5cXHRcXHRcXHRcXHR3aWR0aDoge30sXFxuXFx0XFx0XFx0XFx0aGVpZ2h0OiB7fVxcblxcdFxcdFxcdH0gfVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cG9pbnRzOiB7XFxuXFxuXFx0XFx0XFx0ZGlmZnVzZTogeyB2YWx1ZTogbmV3IENvbG9yKCAweGVlZWVlZSApIH0sXFxuXFx0XFx0XFx0b3BhY2l0eTogeyB2YWx1ZTogMS4wIH0sXFxuXFx0XFx0XFx0c2l6ZTogeyB2YWx1ZTogMS4wIH0sXFxuXFx0XFx0XFx0c2NhbGU6IHsgdmFsdWU6IDEuMCB9LFxcblxcdFxcdFxcdG1hcDogeyB2YWx1ZTogbnVsbCB9LFxcblxcdFxcdFxcdHV2VHJhbnNmb3JtOiB7IHZhbHVlOiBuZXcgTWF0cml4MygpIH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBVbmlmb3JtIFV0aWxpdGllc1xcblxcdCAqL1xcblxcblxcdHZhciBVbmlmb3Jtc1V0aWxzID0ge1xcblxcblxcdFxcdG1lcmdlOiBmdW5jdGlvbiAoIHVuaWZvcm1zICkge1xcblxcblxcdFxcdFxcdHZhciBtZXJnZWQgPSB7fTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgdSA9IDA7IHUgPCB1bmlmb3Jtcy5sZW5ndGg7IHUgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHRtcCA9IHRoaXMuY2xvbmUoIHVuaWZvcm1zWyB1IF0gKTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgcCBpbiB0bXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bWVyZ2VkWyBwIF0gPSB0bXBbIHAgXTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBtZXJnZWQ7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCB1bmlmb3Jtc19zcmMgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHVuaWZvcm1zX2RzdCA9IHt9O1xcblxcblxcdFxcdFxcdGZvciAoIHZhciB1IGluIHVuaWZvcm1zX3NyYyApIHtcXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3Jtc19kc3RbIHUgXSA9IHt9O1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBwIGluIHVuaWZvcm1zX3NyY1sgdSBdICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBwYXJhbWV0ZXJfc3JjID0gdW5pZm9ybXNfc3JjWyB1IF1bIHAgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHBhcmFtZXRlcl9zcmMgJiYgKCBwYXJhbWV0ZXJfc3JjLmlzQ29sb3IgfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRwYXJhbWV0ZXJfc3JjLmlzTWF0cml4MyB8fCBwYXJhbWV0ZXJfc3JjLmlzTWF0cml4NCB8fFxcblxcdFxcdFxcdFxcdFxcdFxcdHBhcmFtZXRlcl9zcmMuaXNWZWN0b3IyIHx8IHBhcmFtZXRlcl9zcmMuaXNWZWN0b3IzIHx8IHBhcmFtZXRlcl9zcmMuaXNWZWN0b3I0IHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0cGFyYW1ldGVyX3NyYy5pc1RleHR1cmUgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR1bmlmb3Jtc19kc3RbIHUgXVsgcCBdID0gcGFyYW1ldGVyX3NyYy5jbG9uZSgpO1xcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIHBhcmFtZXRlcl9zcmMgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR1bmlmb3Jtc19kc3RbIHUgXVsgcCBdID0gcGFyYW1ldGVyX3NyYy5zbGljZSgpO1xcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHVuaWZvcm1zX2RzdDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fTtcXG5cXG5cXHR2YXIgYWxwaGFtYXBfZnJhZ21lbnQgPSBcXFwiI2lmZGVmIFVTRV9BTFBIQU1BUFxcXFxuXFxcXHRkaWZmdXNlQ29sb3IuYSAqPSB0ZXh0dXJlMkQoIGFscGhhTWFwLCB2VXYgKS5nO1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBhbHBoYW1hcF9wYXJzX2ZyYWdtZW50ID0gXFxcIiNpZmRlZiBVU0VfQUxQSEFNQVBcXFxcblxcXFx0dW5pZm9ybSBzYW1wbGVyMkQgYWxwaGFNYXA7XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIGFscGhhdGVzdF9mcmFnbWVudCA9IFxcXCIjaWZkZWYgQUxQSEFURVNUXFxcXG5cXFxcdGlmICggZGlmZnVzZUNvbG9yLmEgPCBBTFBIQVRFU1QgKSBkaXNjYXJkO1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBhb21hcF9mcmFnbWVudCA9IFxcXCIjaWZkZWYgVVNFX0FPTUFQXFxcXG5cXFxcdGZsb2F0IGFtYmllbnRPY2NsdXNpb24gPSAoIHRleHR1cmUyRCggYW9NYXAsIHZVdjIgKS5yIC0gMS4wICkgKiBhb01hcEludGVuc2l0eSArIDEuMDtcXFxcblxcXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICo9IGFtYmllbnRPY2NsdXNpb247XFxcXG5cXFxcdCNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgZGVmaW5lZCggUEhZU0lDQUwgKVxcXFxuXFxcXHRcXFxcdGZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBnZW9tZXRyeS52aWV3RGlyICkgKTtcXFxcblxcXFx0XFxcXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICo9IGNvbXB1dGVTcGVjdWxhck9jY2x1c2lvbiggZG90TlYsIGFtYmllbnRPY2NsdXNpb24sIG1hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzICk7XFxcXG5cXFxcdCNlbmRpZlxcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBhb21hcF9wYXJzX2ZyYWdtZW50ID0gXFxcIiNpZmRlZiBVU0VfQU9NQVBcXFxcblxcXFx0dW5pZm9ybSBzYW1wbGVyMkQgYW9NYXA7XFxcXG5cXFxcdHVuaWZvcm0gZmxvYXQgYW9NYXBJbnRlbnNpdHk7XFxcXG4jZW5kaWZcXFwiO1xcblxcblxcdHZhciBiZWdpbl92ZXJ0ZXggPSBcXFwiXFxcXG52ZWMzIHRyYW5zZm9ybWVkID0gdmVjMyggcG9zaXRpb24gKTtcXFxcblxcXCI7XFxuXFxuXFx0dmFyIGJlZ2lubm9ybWFsX3ZlcnRleCA9IFxcXCJcXFxcbnZlYzMgb2JqZWN0Tm9ybWFsID0gdmVjMyggbm9ybWFsICk7XFxcXG5cXFwiO1xcblxcblxcdHZhciBic2RmcyA9IFxcXCJmbG9hdCBwdW5jdHVhbExpZ2h0SW50ZW5zaXR5VG9JcnJhZGlhbmNlRmFjdG9yKCBjb25zdCBpbiBmbG9hdCBsaWdodERpc3RhbmNlLCBjb25zdCBpbiBmbG9hdCBjdXRvZmZEaXN0YW5jZSwgY29uc3QgaW4gZmxvYXQgZGVjYXlFeHBvbmVudCApIHtcXFxcblxcXFx0aWYoIGRlY2F5RXhwb25lbnQgPiAwLjAgKSB7XFxcXG4jaWYgZGVmaW5lZCAoIFBIWVNJQ0FMTFlfQ09SUkVDVF9MSUdIVFMgKVxcXFxuXFxcXHRcXFxcdGZsb2F0IGRpc3RhbmNlRmFsbG9mZiA9IDEuMCAvIG1heCggcG93KCBsaWdodERpc3RhbmNlLCBkZWNheUV4cG9uZW50ICksIDAuMDEgKTtcXFxcblxcXFx0XFxcXHRmbG9hdCBtYXhEaXN0YW5jZUN1dG9mZkZhY3RvciA9IHBvdzIoIHNhdHVyYXRlKCAxLjAgLSBwb3c0KCBsaWdodERpc3RhbmNlIC8gY3V0b2ZmRGlzdGFuY2UgKSApICk7XFxcXG5cXFxcdFxcXFx0cmV0dXJuIGRpc3RhbmNlRmFsbG9mZiAqIG1heERpc3RhbmNlQ3V0b2ZmRmFjdG9yO1xcXFxuI2Vsc2VcXFxcblxcXFx0XFxcXHRyZXR1cm4gcG93KCBzYXR1cmF0ZSggLWxpZ2h0RGlzdGFuY2UgLyBjdXRvZmZEaXN0YW5jZSArIDEuMCApLCBkZWNheUV4cG9uZW50ICk7XFxcXG4jZW5kaWZcXFxcblxcXFx0fVxcXFxuXFxcXHRyZXR1cm4gMS4wO1xcXFxufVxcXFxudmVjMyBCUkRGX0RpZmZ1c2VfTGFtYmVydCggY29uc3QgaW4gdmVjMyBkaWZmdXNlQ29sb3IgKSB7XFxcXG5cXFxcdHJldHVybiBSRUNJUFJPQ0FMX1BJICogZGlmZnVzZUNvbG9yO1xcXFxufVxcXFxudmVjMyBGX1NjaGxpY2soIGNvbnN0IGluIHZlYzMgc3BlY3VsYXJDb2xvciwgY29uc3QgaW4gZmxvYXQgZG90TEggKSB7XFxcXG5cXFxcdGZsb2F0IGZyZXNuZWwgPSBleHAyKCAoIC01LjU1NDczICogZG90TEggLSA2Ljk4MzE2ICkgKiBkb3RMSCApO1xcXFxuXFxcXHRyZXR1cm4gKCAxLjAgLSBzcGVjdWxhckNvbG9yICkgKiBmcmVzbmVsICsgc3BlY3VsYXJDb2xvcjtcXFxcbn1cXFxcbmZsb2F0IEdfR0dYX1NtaXRoKCBjb25zdCBpbiBmbG9hdCBhbHBoYSwgY29uc3QgaW4gZmxvYXQgZG90TkwsIGNvbnN0IGluIGZsb2F0IGRvdE5WICkge1xcXFxuXFxcXHRmbG9hdCBhMiA9IHBvdzIoIGFscGhhICk7XFxcXG5cXFxcdGZsb2F0IGdsID0gZG90TkwgKyBzcXJ0KCBhMiArICggMS4wIC0gYTIgKSAqIHBvdzIoIGRvdE5MICkgKTtcXFxcblxcXFx0ZmxvYXQgZ3YgPSBkb3ROViArIHNxcnQoIGEyICsgKCAxLjAgLSBhMiApICogcG93MiggZG90TlYgKSApO1xcXFxuXFxcXHRyZXR1cm4gMS4wIC8gKCBnbCAqIGd2ICk7XFxcXG59XFxcXG5mbG9hdCBHX0dHWF9TbWl0aENvcnJlbGF0ZWQoIGNvbnN0IGluIGZsb2F0IGFscGhhLCBjb25zdCBpbiBmbG9hdCBkb3ROTCwgY29uc3QgaW4gZmxvYXQgZG90TlYgKSB7XFxcXG5cXFxcdGZsb2F0IGEyID0gcG93MiggYWxwaGEgKTtcXFxcblxcXFx0ZmxvYXQgZ3YgPSBkb3ROTCAqIHNxcnQoIGEyICsgKCAxLjAgLSBhMiApICogcG93MiggZG90TlYgKSApO1xcXFxuXFxcXHRmbG9hdCBnbCA9IGRvdE5WICogc3FydCggYTIgKyAoIDEuMCAtIGEyICkgKiBwb3cyKCBkb3ROTCApICk7XFxcXG5cXFxcdHJldHVybiAwLjUgLyBtYXgoIGd2ICsgZ2wsIEVQU0lMT04gKTtcXFxcbn1cXFxcbmZsb2F0IERfR0dYKCBjb25zdCBpbiBmbG9hdCBhbHBoYSwgY29uc3QgaW4gZmxvYXQgZG90TkggKSB7XFxcXG5cXFxcdGZsb2F0IGEyID0gcG93MiggYWxwaGEgKTtcXFxcblxcXFx0ZmxvYXQgZGVub20gPSBwb3cyKCBkb3ROSCApICogKCBhMiAtIDEuMCApICsgMS4wO1xcXFxuXFxcXHRyZXR1cm4gUkVDSVBST0NBTF9QSSAqIGEyIC8gcG93MiggZGVub20gKTtcXFxcbn1cXFxcbnZlYzMgQlJERl9TcGVjdWxhcl9HR1goIGNvbnN0IGluIEluY2lkZW50TGlnaHQgaW5jaWRlbnRMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7XFxcXG5cXFxcdGZsb2F0IGFscGhhID0gcG93Miggcm91Z2huZXNzICk7XFxcXG5cXFxcdHZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggaW5jaWRlbnRMaWdodC5kaXJlY3Rpb24gKyBnZW9tZXRyeS52aWV3RGlyICk7XFxcXG5cXFxcdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBpbmNpZGVudExpZ2h0LmRpcmVjdGlvbiApICk7XFxcXG5cXFxcdGZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBnZW9tZXRyeS52aWV3RGlyICkgKTtcXFxcblxcXFx0ZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGhhbGZEaXIgKSApO1xcXFxuXFxcXHRmbG9hdCBkb3RMSCA9IHNhdHVyYXRlKCBkb3QoIGluY2lkZW50TGlnaHQuZGlyZWN0aW9uLCBoYWxmRGlyICkgKTtcXFxcblxcXFx0dmVjMyBGID0gRl9TY2hsaWNrKCBzcGVjdWxhckNvbG9yLCBkb3RMSCApO1xcXFxuXFxcXHRmbG9hdCBHID0gR19HR1hfU21pdGhDb3JyZWxhdGVkKCBhbHBoYSwgZG90TkwsIGRvdE5WICk7XFxcXG5cXFxcdGZsb2F0IEQgPSBEX0dHWCggYWxwaGEsIGRvdE5IICk7XFxcXG5cXFxcdHJldHVybiBGICogKCBHICogRCApO1xcXFxufVxcXFxudmVjMiBMVENfVXYoIGNvbnN0IGluIHZlYzMgTiwgY29uc3QgaW4gdmVjMyBWLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7XFxcXG5cXFxcdGNvbnN0IGZsb2F0IExVVF9TSVpFICA9IDY0LjA7XFxcXG5cXFxcdGNvbnN0IGZsb2F0IExVVF9TQ0FMRSA9ICggTFVUX1NJWkUgLSAxLjAgKSAvIExVVF9TSVpFO1xcXFxuXFxcXHRjb25zdCBmbG9hdCBMVVRfQklBUyAgPSAwLjUgLyBMVVRfU0laRTtcXFxcblxcXFx0ZmxvYXQgdGhldGEgPSBhY29zKCBkb3QoIE4sIFYgKSApO1xcXFxuXFxcXHR2ZWMyIHV2ID0gdmVjMihcXFxcblxcXFx0XFxcXHRzcXJ0KCBzYXR1cmF0ZSggcm91Z2huZXNzICkgKSxcXFxcblxcXFx0XFxcXHRzYXR1cmF0ZSggdGhldGEgLyAoIDAuNSAqIFBJICkgKSApO1xcXFxuXFxcXHR1diA9IHV2ICogTFVUX1NDQUxFICsgTFVUX0JJQVM7XFxcXG5cXFxcdHJldHVybiB1djtcXFxcbn1cXFxcbmZsb2F0IExUQ19DbGlwcGVkU3BoZXJlRm9ybUZhY3RvciggY29uc3QgaW4gdmVjMyBmICkge1xcXFxuXFxcXHRmbG9hdCBsID0gbGVuZ3RoKCBmICk7XFxcXG5cXFxcdHJldHVybiBtYXgoICggbCAqIGwgKyBmLnogKSAvICggbCArIDEuMCApLCAwLjAgKTtcXFxcbn1cXFxcbnZlYzMgTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCBjb25zdCBpbiB2ZWMzIHYxLCBjb25zdCBpbiB2ZWMzIHYyICkge1xcXFxuXFxcXHRmbG9hdCB4ID0gZG90KCB2MSwgdjIgKTtcXFxcblxcXFx0ZmxvYXQgeSA9IGFicyggeCApO1xcXFxuXFxcXHRmbG9hdCBhID0gMC44NjI2NyArICgwLjQ5Nzg4ICsgMC4wMTQzNiAqIHkgKSAqIHk7XFxcXG5cXFxcdGZsb2F0IGIgPSAzLjQ1MDY4ICsgKDQuMTg4MTQgKyB5KSAqIHk7XFxcXG5cXFxcdGZsb2F0IHYgPSBhIC8gYjtcXFxcblxcXFx0ZmxvYXQgdGhldGFfc2ludGhldGEgPSAoeCA+IDAuMCkgPyB2IDogMC41ICogaW52ZXJzZXNxcnQoIDEuMCAtIHggKiB4ICkgLSB2O1xcXFxuXFxcXHRyZXR1cm4gY3Jvc3MoIHYxLCB2MiApICogdGhldGFfc2ludGhldGE7XFxcXG59XFxcXG52ZWMzIExUQ19FdmFsdWF0ZSggY29uc3QgaW4gdmVjMyBOLCBjb25zdCBpbiB2ZWMzIFYsIGNvbnN0IGluIHZlYzMgUCwgY29uc3QgaW4gbWF0MyBtSW52LCBjb25zdCBpbiB2ZWMzIHJlY3RDb29yZHNbIDQgXSApIHtcXFxcblxcXFx0dmVjMyB2MSA9IHJlY3RDb29yZHNbIDEgXSAtIHJlY3RDb29yZHNbIDAgXTtcXFxcblxcXFx0dmVjMyB2MiA9IHJlY3RDb29yZHNbIDMgXSAtIHJlY3RDb29yZHNbIDAgXTtcXFxcblxcXFx0dmVjMyBsaWdodE5vcm1hbCA9IGNyb3NzKCB2MSwgdjIgKTtcXFxcblxcXFx0aWYoIGRvdCggbGlnaHROb3JtYWwsIFAgLSByZWN0Q29vcmRzWyAwIF0gKSA8IDAuMCApIHJldHVybiB2ZWMzKCAwLjAgKTtcXFxcblxcXFx0dmVjMyBUMSwgVDI7XFxcXG5cXFxcdFQxID0gbm9ybWFsaXplKCBWIC0gTiAqIGRvdCggViwgTiApICk7XFxcXG5cXFxcdFQyID0gLSBjcm9zcyggTiwgVDEgKTtcXFxcblxcXFx0bWF0MyBtYXQgPSBtSW52ICogdHJhbnNwb3NlTWF0MyggbWF0MyggVDEsIFQyLCBOICkgKTtcXFxcblxcXFx0dmVjMyBjb29yZHNbIDQgXTtcXFxcblxcXFx0Y29vcmRzWyAwIF0gPSBtYXQgKiAoIHJlY3RDb29yZHNbIDAgXSAtIFAgKTtcXFxcblxcXFx0Y29vcmRzWyAxIF0gPSBtYXQgKiAoIHJlY3RDb29yZHNbIDEgXSAtIFAgKTtcXFxcblxcXFx0Y29vcmRzWyAyIF0gPSBtYXQgKiAoIHJlY3RDb29yZHNbIDIgXSAtIFAgKTtcXFxcblxcXFx0Y29vcmRzWyAzIF0gPSBtYXQgKiAoIHJlY3RDb29yZHNbIDMgXSAtIFAgKTtcXFxcblxcXFx0Y29vcmRzWyAwIF0gPSBub3JtYWxpemUoIGNvb3Jkc1sgMCBdICk7XFxcXG5cXFxcdGNvb3Jkc1sgMSBdID0gbm9ybWFsaXplKCBjb29yZHNbIDEgXSApO1xcXFxuXFxcXHRjb29yZHNbIDIgXSA9IG5vcm1hbGl6ZSggY29vcmRzWyAyIF0gKTtcXFxcblxcXFx0Y29vcmRzWyAzIF0gPSBub3JtYWxpemUoIGNvb3Jkc1sgMyBdICk7XFxcXG5cXFxcdHZlYzMgdmVjdG9yRm9ybUZhY3RvciA9IHZlYzMoIDAuMCApO1xcXFxuXFxcXHR2ZWN0b3JGb3JtRmFjdG9yICs9IExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29vcmRzWyAwIF0sIGNvb3Jkc1sgMSBdICk7XFxcXG5cXFxcdHZlY3RvckZvcm1GYWN0b3IgKz0gTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCBjb29yZHNbIDEgXSwgY29vcmRzWyAyIF0gKTtcXFxcblxcXFx0dmVjdG9yRm9ybUZhY3RvciArPSBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvb3Jkc1sgMiBdLCBjb29yZHNbIDMgXSApO1xcXFxuXFxcXHR2ZWN0b3JGb3JtRmFjdG9yICs9IExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29vcmRzWyAzIF0sIGNvb3Jkc1sgMCBdICk7XFxcXG5cXFxcdHZlYzMgcmVzdWx0ID0gdmVjMyggTFRDX0NsaXBwZWRTcGhlcmVGb3JtRmFjdG9yKCB2ZWN0b3JGb3JtRmFjdG9yICkgKTtcXFxcblxcXFx0cmV0dXJuIHJlc3VsdDtcXFxcbn1cXFxcbnZlYzMgQlJERl9TcGVjdWxhcl9HR1hfRW52aXJvbm1lbnQoIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIHZlYzMgc3BlY3VsYXJDb2xvciwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xcXFxuXFxcXHRmbG9hdCBkb3ROViA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZ2VvbWV0cnkudmlld0RpciApICk7XFxcXG5cXFxcdGNvbnN0IHZlYzQgYzAgPSB2ZWM0KCAtIDEsIC0gMC4wMjc1LCAtIDAuNTcyLCAwLjAyMiApO1xcXFxuXFxcXHRjb25zdCB2ZWM0IGMxID0gdmVjNCggMSwgMC4wNDI1LCAxLjA0LCAtIDAuMDQgKTtcXFxcblxcXFx0dmVjNCByID0gcm91Z2huZXNzICogYzAgKyBjMTtcXFxcblxcXFx0ZmxvYXQgYTAwNCA9IG1pbiggci54ICogci54LCBleHAyKCAtIDkuMjggKiBkb3ROViApICkgKiByLnggKyByLnk7XFxcXG5cXFxcdHZlYzIgQUIgPSB2ZWMyKCAtMS4wNCwgMS4wNCApICogYTAwNCArIHIuenc7XFxcXG5cXFxcdHJldHVybiBzcGVjdWxhckNvbG9yICogQUIueCArIEFCLnk7XFxcXG59XFxcXG5mbG9hdCBHX0JsaW5uUGhvbmdfSW1wbGljaXQoICkge1xcXFxuXFxcXHRyZXR1cm4gMC4yNTtcXFxcbn1cXFxcbmZsb2F0IERfQmxpbm5QaG9uZyggY29uc3QgaW4gZmxvYXQgc2hpbmluZXNzLCBjb25zdCBpbiBmbG9hdCBkb3ROSCApIHtcXFxcblxcXFx0cmV0dXJuIFJFQ0lQUk9DQUxfUEkgKiAoIHNoaW5pbmVzcyAqIDAuNSArIDEuMCApICogcG93KCBkb3ROSCwgc2hpbmluZXNzICk7XFxcXG59XFxcXG52ZWMzIEJSREZfU3BlY3VsYXJfQmxpbm5QaG9uZyggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBpbmNpZGVudExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHNoaW5pbmVzcyApIHtcXFxcblxcXFx0dmVjMyBoYWxmRGlyID0gbm9ybWFsaXplKCBpbmNpZGVudExpZ2h0LmRpcmVjdGlvbiArIGdlb21ldHJ5LnZpZXdEaXIgKTtcXFxcblxcXFx0ZmxvYXQgZG90TkggPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGhhbGZEaXIgKSApO1xcXFxuXFxcXHRmbG9hdCBkb3RMSCA9IHNhdHVyYXRlKCBkb3QoIGluY2lkZW50TGlnaHQuZGlyZWN0aW9uLCBoYWxmRGlyICkgKTtcXFxcblxcXFx0dmVjMyBGID0gRl9TY2hsaWNrKCBzcGVjdWxhckNvbG9yLCBkb3RMSCApO1xcXFxuXFxcXHRmbG9hdCBHID0gR19CbGlublBob25nX0ltcGxpY2l0KCApO1xcXFxuXFxcXHRmbG9hdCBEID0gRF9CbGlublBob25nKCBzaGluaW5lc3MsIGRvdE5IICk7XFxcXG5cXFxcdHJldHVybiBGICogKCBHICogRCApO1xcXFxufVxcXFxuZmxvYXQgR0dYUm91Z2huZXNzVG9CbGlubkV4cG9uZW50KCBjb25zdCBpbiBmbG9hdCBnZ3hSb3VnaG5lc3MgKSB7XFxcXG5cXFxcdHJldHVybiAoIDIuMCAvIHBvdzIoIGdneFJvdWdobmVzcyArIDAuMDAwMSApIC0gMi4wICk7XFxcXG59XFxcXG5mbG9hdCBCbGlubkV4cG9uZW50VG9HR1hSb3VnaG5lc3MoIGNvbnN0IGluIGZsb2F0IGJsaW5uRXhwb25lbnQgKSB7XFxcXG5cXFxcdHJldHVybiBzcXJ0KCAyLjAgLyAoIGJsaW5uRXhwb25lbnQgKyAyLjAgKSApO1xcXFxufVxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgYnVtcG1hcF9wYXJzX2ZyYWdtZW50ID0gXFxcIiNpZmRlZiBVU0VfQlVNUE1BUFxcXFxuXFxcXHR1bmlmb3JtIHNhbXBsZXIyRCBidW1wTWFwO1xcXFxuXFxcXHR1bmlmb3JtIGZsb2F0IGJ1bXBTY2FsZTtcXFxcblxcXFx0dmVjMiBkSGR4eV9md2QoKSB7XFxcXG5cXFxcdFxcXFx0dmVjMiBkU1RkeCA9IGRGZHgoIHZVdiApO1xcXFxuXFxcXHRcXFxcdHZlYzIgZFNUZHkgPSBkRmR5KCB2VXYgKTtcXFxcblxcXFx0XFxcXHRmbG9hdCBIbGwgPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiApLng7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgZEJ4ID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2VXYgKyBkU1RkeCApLnggLSBIbGw7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgZEJ5ID0gYnVtcFNjYWxlICogdGV4dHVyZTJEKCBidW1wTWFwLCB2VXYgKyBkU1RkeSApLnggLSBIbGw7XFxcXG5cXFxcdFxcXFx0cmV0dXJuIHZlYzIoIGRCeCwgZEJ5ICk7XFxcXG5cXFxcdH1cXFxcblxcXFx0dmVjMyBwZXJ0dXJiTm9ybWFsQXJiKCB2ZWMzIHN1cmZfcG9zLCB2ZWMzIHN1cmZfbm9ybSwgdmVjMiBkSGR4eSApIHtcXFxcblxcXFx0XFxcXHR2ZWMzIHZTaWdtYVggPSB2ZWMzKCBkRmR4KCBzdXJmX3Bvcy54ICksIGRGZHgoIHN1cmZfcG9zLnkgKSwgZEZkeCggc3VyZl9wb3MueiApICk7XFxcXG5cXFxcdFxcXFx0dmVjMyB2U2lnbWFZID0gdmVjMyggZEZkeSggc3VyZl9wb3MueCApLCBkRmR5KCBzdXJmX3Bvcy55ICksIGRGZHkoIHN1cmZfcG9zLnogKSApO1xcXFxuXFxcXHRcXFxcdHZlYzMgdk4gPSBzdXJmX25vcm07XFxcXG5cXFxcdFxcXFx0dmVjMyBSMSA9IGNyb3NzKCB2U2lnbWFZLCB2TiApO1xcXFxuXFxcXHRcXFxcdHZlYzMgUjIgPSBjcm9zcyggdk4sIHZTaWdtYVggKTtcXFxcblxcXFx0XFxcXHRmbG9hdCBmRGV0ID0gZG90KCB2U2lnbWFYLCBSMSApO1xcXFxuXFxcXHRcXFxcdHZlYzMgdkdyYWQgPSBzaWduKCBmRGV0ICkgKiAoIGRIZHh5LnggKiBSMSArIGRIZHh5LnkgKiBSMiApO1xcXFxuXFxcXHRcXFxcdHJldHVybiBub3JtYWxpemUoIGFicyggZkRldCApICogc3VyZl9ub3JtIC0gdkdyYWQgKTtcXFxcblxcXFx0fVxcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQgPSBcXFwiI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwXFxcXG5cXFxcdGZvciAoIGludCBpID0gMDsgaSA8IFVOSU9OX0NMSVBQSU5HX1BMQU5FUzsgKysgaSApIHtcXFxcblxcXFx0XFxcXHR2ZWM0IHBsYW5lID0gY2xpcHBpbmdQbGFuZXNbIGkgXTtcXFxcblxcXFx0XFxcXHRpZiAoIGRvdCggdlZpZXdQb3NpdGlvbiwgcGxhbmUueHl6ICkgPiBwbGFuZS53ICkgZGlzY2FyZDtcXFxcblxcXFx0fVxcXFxuXFxcXHRcXFxcdFxcXFxuXFxcXHQjaWYgVU5JT05fQ0xJUFBJTkdfUExBTkVTIDwgTlVNX0NMSVBQSU5HX1BMQU5FU1xcXFxuXFxcXHRcXFxcdGJvb2wgY2xpcHBlZCA9IHRydWU7XFxcXG5cXFxcdFxcXFx0Zm9yICggaW50IGkgPSBVTklPTl9DTElQUElOR19QTEFORVM7IGkgPCBOVU1fQ0xJUFBJTkdfUExBTkVTOyArKyBpICkge1xcXFxuXFxcXHRcXFxcdFxcXFx0dmVjNCBwbGFuZSA9IGNsaXBwaW5nUGxhbmVzWyBpIF07XFxcXG5cXFxcdFxcXFx0XFxcXHRjbGlwcGVkID0gKCBkb3QoIHZWaWV3UG9zaXRpb24sIHBsYW5lLnh5eiApID4gcGxhbmUudyApICYmIGNsaXBwZWQ7XFxcXG5cXFxcdFxcXFx0fVxcXFxuXFxcXHRcXFxcdGlmICggY2xpcHBlZCApIGRpc2NhcmQ7XFxcXG5cXFxcdFxcXFxuXFxcXHQjZW5kaWZcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgY2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQgPSBcXFwiI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwXFxcXG5cXFxcdCNpZiAhIGRlZmluZWQoIFBIWVNJQ0FMICkgJiYgISBkZWZpbmVkKCBQSE9ORyApXFxcXG5cXFxcdFxcXFx0dmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHR1bmlmb3JtIHZlYzQgY2xpcHBpbmdQbGFuZXNbIE5VTV9DTElQUElOR19QTEFORVMgXTtcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgY2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4ID0gXFxcIiNpZiBOVU1fQ0xJUFBJTkdfUExBTkVTID4gMCAmJiAhIGRlZmluZWQoIFBIWVNJQ0FMICkgJiYgISBkZWZpbmVkKCBQSE9ORyApXFxcXG5cXFxcdHZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBjbGlwcGluZ19wbGFuZXNfdmVydGV4ID0gXFxcIiNpZiBOVU1fQ0xJUFBJTkdfUExBTkVTID4gMCAmJiAhIGRlZmluZWQoIFBIWVNJQ0FMICkgJiYgISBkZWZpbmVkKCBQSE9ORyApXFxcXG5cXFxcdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBjb2xvcl9mcmFnbWVudCA9IFxcXCIjaWZkZWYgVVNFX0NPTE9SXFxcXG5cXFxcdGRpZmZ1c2VDb2xvci5yZ2IgKj0gdkNvbG9yO1xcXFxuI2VuZGlmXFxcIjtcXG5cXG5cXHR2YXIgY29sb3JfcGFyc19mcmFnbWVudCA9IFxcXCIjaWZkZWYgVVNFX0NPTE9SXFxcXG5cXFxcdHZhcnlpbmcgdmVjMyB2Q29sb3I7XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIGNvbG9yX3BhcnNfdmVydGV4ID0gXFxcIiNpZmRlZiBVU0VfQ09MT1JcXFxcblxcXFx0dmFyeWluZyB2ZWMzIHZDb2xvcjtcXFxcbiNlbmRpZlxcXCI7XFxuXFxuXFx0dmFyIGNvbG9yX3ZlcnRleCA9IFxcXCIjaWZkZWYgVVNFX0NPTE9SXFxcXG5cXFxcdHZDb2xvci54eXogPSBjb2xvci54eXo7XFxcXG4jZW5kaWZcXFwiO1xcblxcblxcdHZhciBjb21tb24gPSBcXFwiI2RlZmluZSBQSSAzLjE0MTU5MjY1MzU5XFxcXG4jZGVmaW5lIFBJMiA2LjI4MzE4NTMwNzE4XFxcXG4jZGVmaW5lIFBJX0hBTEYgMS41NzA3OTYzMjY3OTQ5XFxcXG4jZGVmaW5lIFJFQ0lQUk9DQUxfUEkgMC4zMTgzMDk4ODYxOFxcXFxuI2RlZmluZSBSRUNJUFJPQ0FMX1BJMiAwLjE1OTE1NDk0XFxcXG4jZGVmaW5lIExPRzIgMS40NDI2OTVcXFxcbiNkZWZpbmUgRVBTSUxPTiAxZS02XFxcXG4jZGVmaW5lIHNhdHVyYXRlKGEpIGNsYW1wKCBhLCAwLjAsIDEuMCApXFxcXG4jZGVmaW5lIHdoaXRlQ29tcGxpbWVudChhKSAoIDEuMCAtIHNhdHVyYXRlKCBhICkgKVxcXFxuZmxvYXQgcG93MiggY29uc3QgaW4gZmxvYXQgeCApIHsgcmV0dXJuIHgqeDsgfVxcXFxuZmxvYXQgcG93MyggY29uc3QgaW4gZmxvYXQgeCApIHsgcmV0dXJuIHgqeCp4OyB9XFxcXG5mbG9hdCBwb3c0KCBjb25zdCBpbiBmbG9hdCB4ICkgeyBmbG9hdCB4MiA9IHgqeDsgcmV0dXJuIHgyKngyOyB9XFxcXG5mbG9hdCBhdmVyYWdlKCBjb25zdCBpbiB2ZWMzIGNvbG9yICkgeyByZXR1cm4gZG90KCBjb2xvciwgdmVjMyggMC4zMzMzICkgKTsgfVxcXFxuaGlnaHAgZmxvYXQgcmFuZCggY29uc3QgaW4gdmVjMiB1diApIHtcXFxcblxcXFx0Y29uc3QgaGlnaHAgZmxvYXQgYSA9IDEyLjk4OTgsIGIgPSA3OC4yMzMsIGMgPSA0Mzc1OC41NDUzO1xcXFxuXFxcXHRoaWdocCBmbG9hdCBkdCA9IGRvdCggdXYueHksIHZlYzIoIGEsYiApICksIHNuID0gbW9kKCBkdCwgUEkgKTtcXFxcblxcXFx0cmV0dXJuIGZyYWN0KHNpbihzbikgKiBjKTtcXFxcbn1cXFxcbnN0cnVjdCBJbmNpZGVudExpZ2h0IHtcXFxcblxcXFx0dmVjMyBjb2xvcjtcXFxcblxcXFx0dmVjMyBkaXJlY3Rpb247XFxcXG5cXFxcdGJvb2wgdmlzaWJsZTtcXFxcbn07XFxcXG5zdHJ1Y3QgUmVmbGVjdGVkTGlnaHQge1xcXFxuXFxcXHR2ZWMzIGRpcmVjdERpZmZ1c2U7XFxcXG5cXFxcdHZlYzMgZGlyZWN0U3BlY3VsYXI7XFxcXG5cXFxcdHZlYzMgaW5kaXJlY3REaWZmdXNlO1xcXFxuXFxcXHR2ZWMzIGluZGlyZWN0U3BlY3VsYXI7XFxcXG59O1xcXFxuc3RydWN0IEdlb21ldHJpY0NvbnRleHQge1xcXFxuXFxcXHR2ZWMzIHBvc2l0aW9uO1xcXFxuXFxcXHR2ZWMzIG5vcm1hbDtcXFxcblxcXFx0dmVjMyB2aWV3RGlyO1xcXFxufTtcXFxcbnZlYzMgdHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIGRpciwgaW4gbWF0NCBtYXRyaXggKSB7XFxcXG5cXFxcdHJldHVybiBub3JtYWxpemUoICggbWF0cml4ICogdmVjNCggZGlyLCAwLjAgKSApLnh5eiApO1xcXFxufVxcXFxudmVjMyBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBpbiB2ZWMzIGRpciwgaW4gbWF0NCBtYXRyaXggKSB7XFxcXG5cXFxcdHJldHVybiBub3JtYWxpemUoICggdmVjNCggZGlyLCAwLjAgKSAqIG1hdHJpeCApLnh5eiApO1xcXFxufVxcXFxudmVjMyBwcm9qZWN0T25QbGFuZShpbiB2ZWMzIHBvaW50LCBpbiB2ZWMzIHBvaW50T25QbGFuZSwgaW4gdmVjMyBwbGFuZU5vcm1hbCApIHtcXFxcblxcXFx0ZmxvYXQgZGlzdGFuY2UgPSBkb3QoIHBsYW5lTm9ybWFsLCBwb2ludCAtIHBvaW50T25QbGFuZSApO1xcXFxuXFxcXHRyZXR1cm4gLSBkaXN0YW5jZSAqIHBsYW5lTm9ybWFsICsgcG9pbnQ7XFxcXG59XFxcXG5mbG9hdCBzaWRlT2ZQbGFuZSggaW4gdmVjMyBwb2ludCwgaW4gdmVjMyBwb2ludE9uUGxhbmUsIGluIHZlYzMgcGxhbmVOb3JtYWwgKSB7XFxcXG5cXFxcdHJldHVybiBzaWduKCBkb3QoIHBvaW50IC0gcG9pbnRPblBsYW5lLCBwbGFuZU5vcm1hbCApICk7XFxcXG59XFxcXG52ZWMzIGxpbmVQbGFuZUludGVyc2VjdCggaW4gdmVjMyBwb2ludE9uTGluZSwgaW4gdmVjMyBsaW5lRGlyZWN0aW9uLCBpbiB2ZWMzIHBvaW50T25QbGFuZSwgaW4gdmVjMyBwbGFuZU5vcm1hbCApIHtcXFxcblxcXFx0cmV0dXJuIGxpbmVEaXJlY3Rpb24gKiAoIGRvdCggcGxhbmVOb3JtYWwsIHBvaW50T25QbGFuZSAtIHBvaW50T25MaW5lICkgLyBkb3QoIHBsYW5lTm9ybWFsLCBsaW5lRGlyZWN0aW9uICkgKSArIHBvaW50T25MaW5lO1xcXFxufVxcXFxubWF0MyB0cmFuc3Bvc2VNYXQzKCBjb25zdCBpbiBtYXQzIG0gKSB7XFxcXG5cXFxcdG1hdDMgdG1wO1xcXFxuXFxcXHR0bXBbIDAgXSA9IHZlYzMoIG1bIDAgXS54LCBtWyAxIF0ueCwgbVsgMiBdLnggKTtcXFxcblxcXFx0dG1wWyAxIF0gPSB2ZWMzKCBtWyAwIF0ueSwgbVsgMSBdLnksIG1bIDIgXS55ICk7XFxcXG5cXFxcdHRtcFsgMiBdID0gdmVjMyggbVsgMCBdLnosIG1bIDEgXS56LCBtWyAyIF0ueiApO1xcXFxuXFxcXHRyZXR1cm4gdG1wO1xcXFxufVxcXFxuZmxvYXQgbGluZWFyVG9SZWxhdGl2ZUx1bWluYW5jZSggY29uc3QgaW4gdmVjMyBjb2xvciApIHtcXFxcblxcXFx0dmVjMyB3ZWlnaHRzID0gdmVjMyggMC4yMTI2LCAwLjcxNTIsIDAuMDcyMiApO1xcXFxuXFxcXHRyZXR1cm4gZG90KCB3ZWlnaHRzLCBjb2xvci5yZ2IgKTtcXFxcbn1cXFxcblxcXCI7XFxuXFxuXFx0dmFyIGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudCA9IFxcXCIjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRV9VVlxcXFxuI2RlZmluZSBjdWJlVVZfdGV4dHVyZVNpemUgKDEwMjQuMClcXFxcbmludCBnZXRGYWNlRnJvbURpcmVjdGlvbih2ZWMzIGRpcmVjdGlvbikge1xcXFxuXFxcXHR2ZWMzIGFic0RpcmVjdGlvbiA9IGFicyhkaXJlY3Rpb24pO1xcXFxuXFxcXHRpbnQgZmFjZSA9IC0xO1xcXFxuXFxcXHRpZiggYWJzRGlyZWN0aW9uLnggPiBhYnNEaXJlY3Rpb24ueiApIHtcXFxcblxcXFx0XFxcXHRpZihhYnNEaXJlY3Rpb24ueCA+IGFic0RpcmVjdGlvbi55IClcXFxcblxcXFx0XFxcXHRcXFxcdGZhY2UgPSBkaXJlY3Rpb24ueCA+IDAuMCA/IDAgOiAzO1xcXFxuXFxcXHRcXFxcdGVsc2VcXFxcblxcXFx0XFxcXHRcXFxcdGZhY2UgPSBkaXJlY3Rpb24ueSA+IDAuMCA/IDEgOiA0O1xcXFxuXFxcXHR9XFxcXG5cXFxcdGVsc2Uge1xcXFxuXFxcXHRcXFxcdGlmKGFic0RpcmVjdGlvbi56ID4gYWJzRGlyZWN0aW9uLnkgKVxcXFxuXFxcXHRcXFxcdFxcXFx0ZmFjZSA9IGRpcmVjdGlvbi56ID4gMC4wID8gMiA6IDU7XFxcXG5cXFxcdFxcXFx0ZWxzZVxcXFxuXFxcXHRcXFxcdFxcXFx0ZmFjZSA9IGRpcmVjdGlvbi55ID4gMC4wID8gMSA6IDQ7XFxcXG5cXFxcdH1cXFxcblxcXFx0cmV0dXJuIGZhY2U7XFxcXG59XFxcXG4jZGVmaW5lIGN1YmVVVl9tYXhMb2RzMSAgKGxvZzIoY3ViZVVWX3RleHR1cmVTaXplKjAuMjUpIC0gMS4wKVxcXFxuI2RlZmluZSBjdWJlVVZfcmFuZ2VDbGFtcCAoZXhwMigoNi4wIC0gMS4wKSAqIDIuMCkpXFxcXG52ZWMyIE1pcExldmVsSW5mbyggdmVjMyB2ZWMsIGZsb2F0IHJvdWdobmVzc0xldmVsLCBmbG9hdCByb3VnaG5lc3MgKSB7XFxcXG5cXFxcdGZsb2F0IHNjYWxlID0gZXhwMihjdWJlVVZfbWF4TG9kczEgLSByb3VnaG5lc3NMZXZlbCk7XFxcXG5cXFxcdGZsb2F0IGR4Um91Z2huZXNzID0gZEZkeChyb3VnaG5lc3MpO1xcXFxuXFxcXHRmbG9hdCBkeVJvdWdobmVzcyA9IGRGZHkocm91Z2huZXNzKTtcXFxcblxcXFx0dmVjMyBkeCA9IGRGZHgoIHZlYyAqIHNjYWxlICogZHhSb3VnaG5lc3MgKTtcXFxcblxcXFx0dmVjMyBkeSA9IGRGZHkoIHZlYyAqIHNjYWxlICogZHlSb3VnaG5lc3MgKTtcXFxcblxcXFx0ZmxvYXQgZCA9IG1heCggZG90KCBkeCwgZHggKSwgZG90KCBkeSwgZHkgKSApO1xcXFxuXFxcXHRkID0gY2xhbXAoZCwgMS4wLCBjdWJlVVZfcmFuZ2VDbGFtcCk7XFxcXG5cXFxcdGZsb2F0IG1pcExldmVsID0gMC41ICogbG9nMihkKTtcXFxcblxcXFx0cmV0dXJuIHZlYzIoZmxvb3IobWlwTGV2ZWwpLCBmcmFjdChtaXBMZXZlbCkpO1xcXFxufVxcXFxuI2RlZmluZSBjdWJlVVZfbWF4TG9kczIgKGxvZzIoY3ViZVVWX3RleHR1cmVTaXplKjAuMjUpIC0gMi4wKVxcXFxuI2RlZmluZSBjdWJlVVZfcmNwVGV4dHVyZVNpemUgKDEuMCAvIGN1YmVVVl90ZXh0dXJlU2l6ZSlcXFxcbnZlYzIgZ2V0Q3ViZVVWKHZlYzMgZGlyZWN0aW9uLCBmbG9hdCByb3VnaG5lc3NMZXZlbCwgZmxvYXQgbWlwTGV2ZWwpIHtcXFxcblxcXFx0bWlwTGV2ZWwgPSByb3VnaG5lc3NMZXZlbCA+IGN1YmVVVl9tYXhMb2RzMiAtIDMuMCA/IDAuMCA6IG1pcExldmVsO1xcXFxuXFxcXHRmbG9hdCBhID0gMTYuMCAqIGN1YmVVVl9yY3BUZXh0dXJlU2l6ZTtcXFxcblxcXFx0dmVjMiBleHAyX3BhY2tlZCA9IGV4cDIoIHZlYzIoIHJvdWdobmVzc0xldmVsLCBtaXBMZXZlbCApICk7XFxcXG5cXFxcdHZlYzIgcmNwX2V4cDJfcGFja2VkID0gdmVjMiggMS4wICkgLyBleHAyX3BhY2tlZDtcXFxcblxcXFx0ZmxvYXQgcG93U2NhbGUgPSBleHAyX3BhY2tlZC54ICogZXhwMl9wYWNrZWQueTtcXFxcblxcXFx0ZmxvYXQgc2NhbGUgPSByY3BfZXhwMl9wYWNrZWQueCAqIHJjcF9leHAyX3BhY2tlZC55ICogMC4yNTtcXFxcblxcXFx0ZmxvYXQgbWlwT2Zmc2V0ID0gMC43NSooMS4wIC0gcmNwX2V4cDJfcGFja2VkLnkpICogcmNwX2V4cDJfcGFja2VkLng7XFxcXG5cXFxcdGJvb2wgYlJlcyA9IG1pcExldmVsID09IDAuMDtcXFxcblxcXFx0c2NhbGUgPSAgYlJlcyAmJiAoc2NhbGUgPCBhKSA/IGEgOiBzY2FsZTtcXFxcblxcXFx0dmVjMyByO1xcXFxuXFxcXHR2ZWMyIG9mZnNldDtcXFxcblxcXFx0aW50IGZhY2UgPSBnZXRGYWNlRnJvbURpcmVjdGlvbihkaXJlY3Rpb24pO1xcXFxuXFxcXHRmbG9hdCByY3BQb3dTY2FsZSA9IDEuMCAvIHBvd1NjYWxlO1xcXFxuXFxcXHRpZiggZmFjZSA9PSAwKSB7XFxcXG5cXFxcdFxcXFx0ciA9IHZlYzMoZGlyZWN0aW9uLngsIC1kaXJlY3Rpb24ueiwgZGlyZWN0aW9uLnkpO1xcXFxuXFxcXHRcXFxcdG9mZnNldCA9IHZlYzIoMC4wK21pcE9mZnNldCwwLjc1ICogcmNwUG93U2NhbGUpO1xcXFxuXFxcXHRcXFxcdG9mZnNldC55ID0gYlJlcyAmJiAob2Zmc2V0LnkgPCAyLjAqYSkgPyBhIDogb2Zmc2V0Lnk7XFxcXG5cXFxcdH1cXFxcblxcXFx0ZWxzZSBpZiggZmFjZSA9PSAxKSB7XFxcXG5cXFxcdFxcXFx0ciA9IHZlYzMoZGlyZWN0aW9uLnksIGRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueik7XFxcXG5cXFxcdFxcXFx0b2Zmc2V0ID0gdmVjMihzY2FsZSttaXBPZmZzZXQsIDAuNzUgKiByY3BQb3dTY2FsZSk7XFxcXG5cXFxcdFxcXFx0b2Zmc2V0LnkgPSBiUmVzICYmIChvZmZzZXQueSA8IDIuMCphKSA/IGEgOiBvZmZzZXQueTtcXFxcblxcXFx0fVxcXFxuXFxcXHRlbHNlIGlmKCBmYWNlID09IDIpIHtcXFxcblxcXFx0XFxcXHRyID0gdmVjMyhkaXJlY3Rpb24ueiwgZGlyZWN0aW9uLngsIGRpcmVjdGlvbi55KTtcXFxcblxcXFx0XFxcXHRvZmZzZXQgPSB2ZWMyKDIuMCpzY2FsZSttaXBPZmZzZXQsIDAuNzUgKiByY3BQb3dTY2FsZSk7XFxcXG5cXFxcdFxcXFx0b2Zmc2V0LnkgPSBiUmVzICYmIChvZmZzZXQueSA8IDIuMCphKSA/IGEgOiBvZmZzZXQueTtcXFxcblxcXFx0fVxcXFxuXFxcXHRlbHNlIGlmKCBmYWNlID09IDMpIHtcXFxcblxcXFx0XFxcXHRyID0gdmVjMyhkaXJlY3Rpb24ueCwgZGlyZWN0aW9uLnosIGRpcmVjdGlvbi55KTtcXFxcblxcXFx0XFxcXHRvZmZzZXQgPSB2ZWMyKDAuMCttaXBPZmZzZXQsMC41ICogcmNwUG93U2NhbGUpO1xcXFxuXFxcXHRcXFxcdG9mZnNldC55ID0gYlJlcyAmJiAob2Zmc2V0LnkgPCAyLjAqYSkgPyAwLjAgOiBvZmZzZXQueTtcXFxcblxcXFx0fVxcXFxuXFxcXHRlbHNlIGlmKCBmYWNlID09IDQpIHtcXFxcblxcXFx0XFxcXHRyID0gdmVjMyhkaXJlY3Rpb24ueSwgZGlyZWN0aW9uLngsIC1kaXJlY3Rpb24ueik7XFxcXG5cXFxcdFxcXFx0b2Zmc2V0ID0gdmVjMihzY2FsZSttaXBPZmZzZXQsIDAuNSAqIHJjcFBvd1NjYWxlKTtcXFxcblxcXFx0XFxcXHRvZmZzZXQueSA9IGJSZXMgJiYgKG9mZnNldC55IDwgMi4wKmEpID8gMC4wIDogb2Zmc2V0Lnk7XFxcXG5cXFxcdH1cXFxcblxcXFx0ZWxzZSB7XFxcXG5cXFxcdFxcXFx0ciA9IHZlYzMoZGlyZWN0aW9uLnosIC1kaXJlY3Rpb24ueCwgZGlyZWN0aW9uLnkpO1xcXFxuXFxcXHRcXFxcdG9mZnNldCA9IHZlYzIoMi4wKnNjYWxlK21pcE9mZnNldCwgMC41ICogcmNwUG93U2NhbGUpO1xcXFxuXFxcXHRcXFxcdG9mZnNldC55ID0gYlJlcyAmJiAob2Zmc2V0LnkgPCAyLjAqYSkgPyAwLjAgOiBvZmZzZXQueTtcXFxcblxcXFx0fVxcXFxuXFxcXHRyID0gbm9ybWFsaXplKHIpO1xcXFxuXFxcXHRmbG9hdCB0ZXhlbE9mZnNldCA9IDAuNSAqIGN1YmVVVl9yY3BUZXh0dXJlU2l6ZTtcXFxcblxcXFx0dmVjMiBzID0gKCByLnl6IC8gYWJzKCByLnggKSArIHZlYzIoIDEuMCApICkgKiAwLjU7XFxcXG5cXFxcdHZlYzIgYmFzZSA9IG9mZnNldCArIHZlYzIoIHRleGVsT2Zmc2V0ICk7XFxcXG5cXFxcdHJldHVybiBiYXNlICsgcyAqICggc2NhbGUgLSAyLjAgKiB0ZXhlbE9mZnNldCApO1xcXFxufVxcXFxuI2RlZmluZSBjdWJlVVZfbWF4TG9kczMgKGxvZzIoY3ViZVVWX3RleHR1cmVTaXplKjAuMjUpIC0gMy4wKVxcXFxudmVjNCB0ZXh0dXJlQ3ViZVVWKHZlYzMgcmVmbGVjdGVkRGlyZWN0aW9uLCBmbG9hdCByb3VnaG5lc3MgKSB7XFxcXG5cXFxcdGZsb2F0IHJvdWdobmVzc1ZhbCA9IHJvdWdobmVzcyogY3ViZVVWX21heExvZHMzO1xcXFxuXFxcXHRmbG9hdCByMSA9IGZsb29yKHJvdWdobmVzc1ZhbCk7XFxcXG5cXFxcdGZsb2F0IHIyID0gcjEgKyAxLjA7XFxcXG5cXFxcdGZsb2F0IHQgPSBmcmFjdChyb3VnaG5lc3NWYWwpO1xcXFxuXFxcXHR2ZWMyIG1pcEluZm8gPSBNaXBMZXZlbEluZm8ocmVmbGVjdGVkRGlyZWN0aW9uLCByMSwgcm91Z2huZXNzKTtcXFxcblxcXFx0ZmxvYXQgcyA9IG1pcEluZm8ueTtcXFxcblxcXFx0ZmxvYXQgbGV2ZWwwID0gbWlwSW5mby54O1xcXFxuXFxcXHRmbG9hdCBsZXZlbDEgPSBsZXZlbDAgKyAxLjA7XFxcXG5cXFxcdGxldmVsMSA9IGxldmVsMSA+IDUuMCA/IDUuMCA6IGxldmVsMTtcXFxcblxcXFx0bGV2ZWwwICs9IG1pbiggZmxvb3IoIHMgKyAwLjUgKSwgNS4wICk7XFxcXG5cXFxcdHZlYzIgdXZfMTAgPSBnZXRDdWJlVVYocmVmbGVjdGVkRGlyZWN0aW9uLCByMSwgbGV2ZWwwKTtcXFxcblxcXFx0dmVjNCBjb2xvcjEwID0gZW52TWFwVGV4ZWxUb0xpbmVhcih0ZXh0dXJlMkQoZW52TWFwLCB1dl8xMCkpO1xcXFxuXFxcXHR2ZWMyIHV2XzIwID0gZ2V0Q3ViZVVWKHJlZmxlY3RlZERpcmVjdGlvbiwgcjIsIGxldmVsMCk7XFxcXG5cXFxcdHZlYzQgY29sb3IyMCA9IGVudk1hcFRleGVsVG9MaW5lYXIodGV4dHVyZTJEKGVudk1hcCwgdXZfMjApKTtcXFxcblxcXFx0dmVjNCByZXN1bHQgPSBtaXgoY29sb3IxMCwgY29sb3IyMCwgdCk7XFxcXG5cXFxcdHJldHVybiB2ZWM0KHJlc3VsdC5yZ2IsIDEuMCk7XFxcXG59XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIGRlZmF1bHRub3JtYWxfdmVydGV4ID0gXFxcInZlYzMgdHJhbnNmb3JtZWROb3JtYWwgPSBub3JtYWxNYXRyaXggKiBvYmplY3ROb3JtYWw7XFxcXG4jaWZkZWYgRkxJUF9TSURFRFxcXFxuXFxcXHR0cmFuc2Zvcm1lZE5vcm1hbCA9IC0gdHJhbnNmb3JtZWROb3JtYWw7XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleCA9IFxcXCIjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxcXFxuXFxcXHR1bmlmb3JtIHNhbXBsZXIyRCBkaXNwbGFjZW1lbnRNYXA7XFxcXG5cXFxcdHVuaWZvcm0gZmxvYXQgZGlzcGxhY2VtZW50U2NhbGU7XFxcXG5cXFxcdHVuaWZvcm0gZmxvYXQgZGlzcGxhY2VtZW50QmlhcztcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgZGlzcGxhY2VtZW50bWFwX3ZlcnRleCA9IFxcXCIjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxcXFxuXFxcXHR0cmFuc2Zvcm1lZCArPSBub3JtYWxpemUoIG9iamVjdE5vcm1hbCApICogKCB0ZXh0dXJlMkQoIGRpc3BsYWNlbWVudE1hcCwgdXYgKS54ICogZGlzcGxhY2VtZW50U2NhbGUgKyBkaXNwbGFjZW1lbnRCaWFzICk7XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIGVtaXNzaXZlbWFwX2ZyYWdtZW50ID0gXFxcIiNpZmRlZiBVU0VfRU1JU1NJVkVNQVBcXFxcblxcXFx0dmVjNCBlbWlzc2l2ZUNvbG9yID0gdGV4dHVyZTJEKCBlbWlzc2l2ZU1hcCwgdlV2ICk7XFxcXG5cXFxcdGVtaXNzaXZlQ29sb3IucmdiID0gZW1pc3NpdmVNYXBUZXhlbFRvTGluZWFyKCBlbWlzc2l2ZUNvbG9yICkucmdiO1xcXFxuXFxcXHR0b3RhbEVtaXNzaXZlUmFkaWFuY2UgKj0gZW1pc3NpdmVDb2xvci5yZ2I7XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQgPSBcXFwiI2lmZGVmIFVTRV9FTUlTU0lWRU1BUFxcXFxuXFxcXHR1bmlmb3JtIHNhbXBsZXIyRCBlbWlzc2l2ZU1hcDtcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgZW5jb2RpbmdzX2ZyYWdtZW50ID0gXFxcIiAgZ2xfRnJhZ0NvbG9yID0gbGluZWFyVG9PdXRwdXRUZXhlbCggZ2xfRnJhZ0NvbG9yICk7XFxcXG5cXFwiO1xcblxcblxcdHZhciBlbmNvZGluZ3NfcGFyc19mcmFnbWVudCA9IFxcXCJcXFxcbnZlYzQgTGluZWFyVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUgKSB7XFxcXG5cXFxcdHJldHVybiB2YWx1ZTtcXFxcbn1cXFxcbnZlYzQgR2FtbWFUb0xpbmVhciggaW4gdmVjNCB2YWx1ZSwgaW4gZmxvYXQgZ2FtbWFGYWN0b3IgKSB7XFxcXG5cXFxcdHJldHVybiB2ZWM0KCBwb3coIHZhbHVlLnh5eiwgdmVjMyggZ2FtbWFGYWN0b3IgKSApLCB2YWx1ZS53ICk7XFxcXG59XFxcXG52ZWM0IExpbmVhclRvR2FtbWEoIGluIHZlYzQgdmFsdWUsIGluIGZsb2F0IGdhbW1hRmFjdG9yICkge1xcXFxuXFxcXHRyZXR1cm4gdmVjNCggcG93KCB2YWx1ZS54eXosIHZlYzMoIDEuMCAvIGdhbW1hRmFjdG9yICkgKSwgdmFsdWUudyApO1xcXFxufVxcXFxudmVjNCBzUkdCVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUgKSB7XFxcXG5cXFxcdHJldHVybiB2ZWM0KCBtaXgoIHBvdyggdmFsdWUucmdiICogMC45NDc4NjcyOTg2ICsgdmVjMyggMC4wNTIxMzI3MDE0ICksIHZlYzMoIDIuNCApICksIHZhbHVlLnJnYiAqIDAuMDc3Mzk5MzgwOCwgdmVjMyggbGVzc1RoYW5FcXVhbCggdmFsdWUucmdiLCB2ZWMzKCAwLjA0MDQ1ICkgKSApICksIHZhbHVlLncgKTtcXFxcbn1cXFxcbnZlYzQgTGluZWFyVG9zUkdCKCBpbiB2ZWM0IHZhbHVlICkge1xcXFxuXFxcXHRyZXR1cm4gdmVjNCggbWl4KCBwb3coIHZhbHVlLnJnYiwgdmVjMyggMC40MTY2NiApICkgKiAxLjA1NSAtIHZlYzMoIDAuMDU1ICksIHZhbHVlLnJnYiAqIDEyLjkyLCB2ZWMzKCBsZXNzVGhhbkVxdWFsKCB2YWx1ZS5yZ2IsIHZlYzMoIDAuMDAzMTMwOCApICkgKSApLCB2YWx1ZS53ICk7XFxcXG59XFxcXG52ZWM0IFJHQkVUb0xpbmVhciggaW4gdmVjNCB2YWx1ZSApIHtcXFxcblxcXFx0cmV0dXJuIHZlYzQoIHZhbHVlLnJnYiAqIGV4cDIoIHZhbHVlLmEgKiAyNTUuMCAtIDEyOC4wICksIDEuMCApO1xcXFxufVxcXFxudmVjNCBMaW5lYXJUb1JHQkUoIGluIHZlYzQgdmFsdWUgKSB7XFxcXG5cXFxcdGZsb2F0IG1heENvbXBvbmVudCA9IG1heCggbWF4KCB2YWx1ZS5yLCB2YWx1ZS5nICksIHZhbHVlLmIgKTtcXFxcblxcXFx0ZmxvYXQgZkV4cCA9IGNsYW1wKCBjZWlsKCBsb2cyKCBtYXhDb21wb25lbnQgKSApLCAtMTI4LjAsIDEyNy4wICk7XFxcXG5cXFxcdHJldHVybiB2ZWM0KCB2YWx1ZS5yZ2IgLyBleHAyKCBmRXhwICksICggZkV4cCArIDEyOC4wICkgLyAyNTUuMCApO1xcXFxufVxcXFxudmVjNCBSR0JNVG9MaW5lYXIoIGluIHZlYzQgdmFsdWUsIGluIGZsb2F0IG1heFJhbmdlICkge1xcXFxuXFxcXHRyZXR1cm4gdmVjNCggdmFsdWUueHl6ICogdmFsdWUudyAqIG1heFJhbmdlLCAxLjAgKTtcXFxcbn1cXFxcbnZlYzQgTGluZWFyVG9SR0JNKCBpbiB2ZWM0IHZhbHVlLCBpbiBmbG9hdCBtYXhSYW5nZSApIHtcXFxcblxcXFx0ZmxvYXQgbWF4UkdCID0gbWF4KCB2YWx1ZS54LCBtYXgoIHZhbHVlLmcsIHZhbHVlLmIgKSApO1xcXFxuXFxcXHRmbG9hdCBNICAgICAgPSBjbGFtcCggbWF4UkdCIC8gbWF4UmFuZ2UsIDAuMCwgMS4wICk7XFxcXG5cXFxcdE0gICAgICAgICAgICA9IGNlaWwoIE0gKiAyNTUuMCApIC8gMjU1LjA7XFxcXG5cXFxcdHJldHVybiB2ZWM0KCB2YWx1ZS5yZ2IgLyAoIE0gKiBtYXhSYW5nZSApLCBNICk7XFxcXG59XFxcXG52ZWM0IFJHQkRUb0xpbmVhciggaW4gdmVjNCB2YWx1ZSwgaW4gZmxvYXQgbWF4UmFuZ2UgKSB7XFxcXG5cXFxcdHJldHVybiB2ZWM0KCB2YWx1ZS5yZ2IgKiAoICggbWF4UmFuZ2UgLyAyNTUuMCApIC8gdmFsdWUuYSApLCAxLjAgKTtcXFxcbn1cXFxcbnZlYzQgTGluZWFyVG9SR0JEKCBpbiB2ZWM0IHZhbHVlLCBpbiBmbG9hdCBtYXhSYW5nZSApIHtcXFxcblxcXFx0ZmxvYXQgbWF4UkdCID0gbWF4KCB2YWx1ZS54LCBtYXgoIHZhbHVlLmcsIHZhbHVlLmIgKSApO1xcXFxuXFxcXHRmbG9hdCBEICAgICAgPSBtYXgoIG1heFJhbmdlIC8gbWF4UkdCLCAxLjAgKTtcXFxcblxcXFx0RCAgICAgICAgICAgID0gbWluKCBmbG9vciggRCApIC8gMjU1LjAsIDEuMCApO1xcXFxuXFxcXHRyZXR1cm4gdmVjNCggdmFsdWUucmdiICogKCBEICogKCAyNTUuMCAvIG1heFJhbmdlICkgKSwgRCApO1xcXFxufVxcXFxuY29uc3QgbWF0MyBjTG9nTHV2TSA9IG1hdDMoIDAuMjIwOSwgMC4zMzkwLCAwLjQxODQsIDAuMTEzOCwgMC42NzgwLCAwLjczMTksIDAuMDEwMiwgMC4xMTMwLCAwLjI5NjkgKTtcXFxcbnZlYzQgTGluZWFyVG9Mb2dMdXYoIGluIHZlYzQgdmFsdWUgKSAge1xcXFxuXFxcXHR2ZWMzIFhwX1lfWFlacCA9IHZhbHVlLnJnYiAqIGNMb2dMdXZNO1xcXFxuXFxcXHRYcF9ZX1hZWnAgPSBtYXgoWHBfWV9YWVpwLCB2ZWMzKDFlLTYsIDFlLTYsIDFlLTYpKTtcXFxcblxcXFx0dmVjNCB2UmVzdWx0O1xcXFxuXFxcXHR2UmVzdWx0Lnh5ID0gWHBfWV9YWVpwLnh5IC8gWHBfWV9YWVpwLno7XFxcXG5cXFxcdGZsb2F0IExlID0gMi4wICogbG9nMihYcF9ZX1hZWnAueSkgKyAxMjcuMDtcXFxcblxcXFx0dlJlc3VsdC53ID0gZnJhY3QoTGUpO1xcXFxuXFxcXHR2UmVzdWx0LnogPSAoTGUgLSAoZmxvb3IodlJlc3VsdC53KjI1NS4wKSkvMjU1LjApLzI1NS4wO1xcXFxuXFxcXHRyZXR1cm4gdlJlc3VsdDtcXFxcbn1cXFxcbmNvbnN0IG1hdDMgY0xvZ0x1dkludmVyc2VNID0gbWF0MyggNi4wMDE0LCAtMi43MDA4LCAtMS43OTk2LCAtMS4zMzIwLCAzLjEwMjksIC01Ljc3MjEsIDAuMzAwOCwgLTEuMDg4MiwgNS42MjY4ICk7XFxcXG52ZWM0IExvZ0x1dlRvTGluZWFyKCBpbiB2ZWM0IHZhbHVlICkge1xcXFxuXFxcXHRmbG9hdCBMZSA9IHZhbHVlLnogKiAyNTUuMCArIHZhbHVlLnc7XFxcXG5cXFxcdHZlYzMgWHBfWV9YWVpwO1xcXFxuXFxcXHRYcF9ZX1hZWnAueSA9IGV4cDIoKExlIC0gMTI3LjApIC8gMi4wKTtcXFxcblxcXFx0WHBfWV9YWVpwLnogPSBYcF9ZX1hZWnAueSAvIHZhbHVlLnk7XFxcXG5cXFxcdFhwX1lfWFlacC54ID0gdmFsdWUueCAqIFhwX1lfWFlacC56O1xcXFxuXFxcXHR2ZWMzIHZSR0IgPSBYcF9ZX1hZWnAucmdiICogY0xvZ0x1dkludmVyc2VNO1xcXFxuXFxcXHRyZXR1cm4gdmVjNCggbWF4KHZSR0IsIDAuMCksIDEuMCApO1xcXFxufVxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgZW52bWFwX2ZyYWdtZW50ID0gXFxcIiNpZmRlZiBVU0VfRU5WTUFQXFxcXG5cXFxcdCNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApXFxcXG5cXFxcdFxcXFx0dmVjMyBjYW1lcmFUb1ZlcnRleCA9IG5vcm1hbGl6ZSggdldvcmxkUG9zaXRpb24gLSBjYW1lcmFQb3NpdGlvbiApO1xcXFxuXFxcXHRcXFxcdHZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBub3JtYWwsIHZpZXdNYXRyaXggKTtcXFxcblxcXFx0XFxcXHQjaWZkZWYgRU5WTUFQX01PREVfUkVGTEVDVElPTlxcXFxuXFxcXHRcXFxcdFxcXFx0dmVjMyByZWZsZWN0VmVjID0gcmVmbGVjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsICk7XFxcXG5cXFxcdFxcXFx0I2Vsc2VcXFxcblxcXFx0XFxcXHRcXFxcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZnJhY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XFxcXG5cXFxcdFxcXFx0I2VuZGlmXFxcXG5cXFxcdCNlbHNlXFxcXG5cXFxcdFxcXFx0dmVjMyByZWZsZWN0VmVjID0gdlJlZmxlY3Q7XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcXFxuXFxcXHRcXFxcdHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCB2ZWMzKCBmbGlwRW52TWFwICogcmVmbGVjdFZlYy54LCByZWZsZWN0VmVjLnl6ICkgKTtcXFxcblxcXFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfRVFVSVJFQyApXFxcXG5cXFxcdFxcXFx0dmVjMiBzYW1wbGVVVjtcXFxcblxcXFx0XFxcXHRyZWZsZWN0VmVjID0gbm9ybWFsaXplKCByZWZsZWN0VmVjICk7XFxcXG5cXFxcdFxcXFx0c2FtcGxlVVYueSA9IGFzaW4oIGNsYW1wKCByZWZsZWN0VmVjLnksIC0gMS4wLCAxLjAgKSApICogUkVDSVBST0NBTF9QSSArIDAuNTtcXFxcblxcXFx0XFxcXHRzYW1wbGVVVi54ID0gYXRhbiggcmVmbGVjdFZlYy56LCByZWZsZWN0VmVjLnggKSAqIFJFQ0lQUk9DQUxfUEkyICsgMC41O1xcXFxuXFxcXHRcXFxcdHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlMkQoIGVudk1hcCwgc2FtcGxlVVYgKTtcXFxcblxcXFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfU1BIRVJFIClcXFxcblxcXFx0XFxcXHRyZWZsZWN0VmVjID0gbm9ybWFsaXplKCByZWZsZWN0VmVjICk7XFxcXG5cXFxcdFxcXFx0dmVjMyByZWZsZWN0VmlldyA9IG5vcm1hbGl6ZSggKCB2aWV3TWF0cml4ICogdmVjNCggcmVmbGVjdFZlYywgMC4wICkgKS54eXogKyB2ZWMzKCAwLjAsIDAuMCwgMS4wICkgKTtcXFxcblxcXFx0XFxcXHR2ZWM0IGVudkNvbG9yID0gdGV4dHVyZTJEKCBlbnZNYXAsIHJlZmxlY3RWaWV3Lnh5ICogMC41ICsgMC41ICk7XFxcXG5cXFxcdCNlbHNlXFxcXG5cXFxcdFxcXFx0dmVjNCBlbnZDb2xvciA9IHZlYzQoIDAuMCApO1xcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0ZW52Q29sb3IgPSBlbnZNYXBUZXhlbFRvTGluZWFyKCBlbnZDb2xvciApO1xcXFxuXFxcXHQjaWZkZWYgRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZXFxcXG5cXFxcdFxcXFx0b3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgb3V0Z29pbmdMaWdodCAqIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcXFxuXFxcXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfQkxFTkRJTkdfTUlYIClcXFxcblxcXFx0XFxcXHRvdXRnb2luZ0xpZ2h0ID0gbWl4KCBvdXRnb2luZ0xpZ2h0LCBlbnZDb2xvci54eXosIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHkgKTtcXFxcblxcXFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX0JMRU5ESU5HX0FERCApXFxcXG5cXFxcdFxcXFx0b3V0Z29pbmdMaWdodCArPSBlbnZDb2xvci54eXogKiBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5O1xcXFxuXFxcXHQjZW5kaWZcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgZW52bWFwX3BhcnNfZnJhZ21lbnQgPSBcXFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSB8fCBkZWZpbmVkKCBQSFlTSUNBTCApXFxcXG5cXFxcdHVuaWZvcm0gZmxvYXQgcmVmbGVjdGl2aXR5O1xcXFxuXFxcXHR1bmlmb3JtIGZsb2F0IGVudk1hcEludGVuc2l0eTtcXFxcbiNlbmRpZlxcXFxuI2lmZGVmIFVTRV9FTlZNQVBcXFxcblxcXFx0I2lmICEgZGVmaW5lZCggUEhZU0lDQUwgKSAmJiAoIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HICkgKVxcXFxuXFxcXHRcXFxcdHZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXFxcXG5cXFxcdFxcXFx0dW5pZm9ybSBzYW1wbGVyQ3ViZSBlbnZNYXA7XFxcXG5cXFxcdCNlbHNlXFxcXG5cXFxcdFxcXFx0dW5pZm9ybSBzYW1wbGVyMkQgZW52TWFwO1xcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0dW5pZm9ybSBmbG9hdCBmbGlwRW52TWFwO1xcXFxuXFxcXHQjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKSB8fCBkZWZpbmVkKCBQSFlTSUNBTCApXFxcXG5cXFxcdFxcXFx0dW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87XFxcXG5cXFxcdCNlbHNlXFxcXG5cXFxcdFxcXFx0dmFyeWluZyB2ZWMzIHZSZWZsZWN0O1xcXFxuXFxcXHQjZW5kaWZcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgZW52bWFwX3BhcnNfdmVydGV4ID0gXFxcIiNpZmRlZiBVU0VfRU5WTUFQXFxcXG5cXFxcdCNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApXFxcXG5cXFxcdFxcXFx0dmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcXFxuXFxcXHQjZWxzZVxcXFxuXFxcXHRcXFxcdHZhcnlpbmcgdmVjMyB2UmVmbGVjdDtcXFxcblxcXFx0XFxcXHR1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXFxcblxcXFx0I2VuZGlmXFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIGVudm1hcF92ZXJ0ZXggPSBcXFwiI2lmZGVmIFVTRV9FTlZNQVBcXFxcblxcXFx0I2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HIClcXFxcblxcXFx0XFxcXHR2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1xcXFxuXFxcXHQjZWxzZVxcXFxuXFxcXHRcXFxcdHZlYzMgY2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHdvcmxkUG9zaXRpb24ueHl6IC0gY2FtZXJhUG9zaXRpb24gKTtcXFxcblxcXFx0XFxcXHR2ZWMzIHdvcmxkTm9ybWFsID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggdHJhbnNmb3JtZWROb3JtYWwsIHZpZXdNYXRyaXggKTtcXFxcblxcXFx0XFxcXHQjaWZkZWYgRU5WTUFQX01PREVfUkVGTEVDVElPTlxcXFxuXFxcXHRcXFxcdFxcXFx0dlJlZmxlY3QgPSByZWZsZWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwgKTtcXFxcblxcXFx0XFxcXHQjZWxzZVxcXFxuXFxcXHRcXFxcdFxcXFx0dlJlZmxlY3QgPSByZWZyYWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xcXFxuXFxcXHRcXFxcdCNlbmRpZlxcXFxuXFxcXHQjZW5kaWZcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgZm9nX3ZlcnRleCA9IFxcXCJcXFxcbiNpZmRlZiBVU0VfRk9HXFxcXG5mb2dEZXB0aCA9IC1tdlBvc2l0aW9uLno7XFxcXG4jZW5kaWZcXFwiO1xcblxcblxcdHZhciBmb2dfcGFyc192ZXJ0ZXggPSBcXFwiI2lmZGVmIFVTRV9GT0dcXFxcbiAgdmFyeWluZyBmbG9hdCBmb2dEZXB0aDtcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgZm9nX2ZyYWdtZW50ID0gXFxcIiNpZmRlZiBVU0VfRk9HXFxcXG5cXFxcdCNpZmRlZiBGT0dfRVhQMlxcXFxuXFxcXHRcXFxcdGZsb2F0IGZvZ0ZhY3RvciA9IHdoaXRlQ29tcGxpbWVudCggZXhwMiggLSBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSAqIGZvZ0RlcHRoICogZm9nRGVwdGggKiBMT0cyICkgKTtcXFxcblxcXFx0I2Vsc2VcXFxcblxcXFx0XFxcXHRmbG9hdCBmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIGZvZ0RlcHRoICk7XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHRnbF9GcmFnQ29sb3IucmdiID0gbWl4KCBnbF9GcmFnQ29sb3IucmdiLCBmb2dDb2xvciwgZm9nRmFjdG9yICk7XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIGZvZ19wYXJzX2ZyYWdtZW50ID0gXFxcIiNpZmRlZiBVU0VfRk9HXFxcXG5cXFxcdHVuaWZvcm0gdmVjMyBmb2dDb2xvcjtcXFxcblxcXFx0dmFyeWluZyBmbG9hdCBmb2dEZXB0aDtcXFxcblxcXFx0I2lmZGVmIEZPR19FWFAyXFxcXG5cXFxcdFxcXFx0dW5pZm9ybSBmbG9hdCBmb2dEZW5zaXR5O1xcXFxuXFxcXHQjZWxzZVxcXFxuXFxcXHRcXFxcdHVuaWZvcm0gZmxvYXQgZm9nTmVhcjtcXFxcblxcXFx0XFxcXHR1bmlmb3JtIGZsb2F0IGZvZ0ZhcjtcXFxcblxcXFx0I2VuZGlmXFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIGdyYWRpZW50bWFwX3BhcnNfZnJhZ21lbnQgPSBcXFwiI2lmZGVmIFRPT05cXFxcblxcXFx0dW5pZm9ybSBzYW1wbGVyMkQgZ3JhZGllbnRNYXA7XFxcXG5cXFxcdHZlYzMgZ2V0R3JhZGllbnRJcnJhZGlhbmNlKCB2ZWMzIG5vcm1hbCwgdmVjMyBsaWdodERpcmVjdGlvbiApIHtcXFxcblxcXFx0XFxcXHRmbG9hdCBkb3ROTCA9IGRvdCggbm9ybWFsLCBsaWdodERpcmVjdGlvbiApO1xcXFxuXFxcXHRcXFxcdHZlYzIgY29vcmQgPSB2ZWMyKCBkb3ROTCAqIDAuNSArIDAuNSwgMC4wICk7XFxcXG5cXFxcdFxcXFx0I2lmZGVmIFVTRV9HUkFESUVOVE1BUFxcXFxuXFxcXHRcXFxcdFxcXFx0cmV0dXJuIHRleHR1cmUyRCggZ3JhZGllbnRNYXAsIGNvb3JkICkucmdiO1xcXFxuXFxcXHRcXFxcdCNlbHNlXFxcXG5cXFxcdFxcXFx0XFxcXHRyZXR1cm4gKCBjb29yZC54IDwgMC43ICkgPyB2ZWMzKCAwLjcgKSA6IHZlYzMoIDEuMCApO1xcXFxuXFxcXHRcXFxcdCNlbmRpZlxcXFxuXFxcXHR9XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIGxpZ2h0bWFwX2ZyYWdtZW50ID0gXFxcIiNpZmRlZiBVU0VfTElHSFRNQVBcXFxcblxcXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IFBJICogdGV4dHVyZTJEKCBsaWdodE1hcCwgdlV2MiApLnh5eiAqIGxpZ2h0TWFwSW50ZW5zaXR5O1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBsaWdodG1hcF9wYXJzX2ZyYWdtZW50ID0gXFxcIiNpZmRlZiBVU0VfTElHSFRNQVBcXFxcblxcXFx0dW5pZm9ybSBzYW1wbGVyMkQgbGlnaHRNYXA7XFxcXG5cXFxcdHVuaWZvcm0gZmxvYXQgbGlnaHRNYXBJbnRlbnNpdHk7XFxcXG4jZW5kaWZcXFwiO1xcblxcblxcdHZhciBsaWdodHNfbGFtYmVydF92ZXJ0ZXggPSBcXFwidmVjMyBkaWZmdXNlID0gdmVjMyggMS4wICk7XFxcXG5HZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5O1xcXFxuZ2VvbWV0cnkucG9zaXRpb24gPSBtdlBvc2l0aW9uLnh5ejtcXFxcbmdlb21ldHJ5Lm5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcXFxcbmdlb21ldHJ5LnZpZXdEaXIgPSBub3JtYWxpemUoIC1tdlBvc2l0aW9uLnh5eiApO1xcXFxuR2VvbWV0cmljQ29udGV4dCBiYWNrR2VvbWV0cnk7XFxcXG5iYWNrR2VvbWV0cnkucG9zaXRpb24gPSBnZW9tZXRyeS5wb3NpdGlvbjtcXFxcbmJhY2tHZW9tZXRyeS5ub3JtYWwgPSAtZ2VvbWV0cnkubm9ybWFsO1xcXFxuYmFja0dlb21ldHJ5LnZpZXdEaXIgPSBnZW9tZXRyeS52aWV3RGlyO1xcXFxudkxpZ2h0RnJvbnQgPSB2ZWMzKCAwLjAgKTtcXFxcbiNpZmRlZiBET1VCTEVfU0lERURcXFxcblxcXFx0dkxpZ2h0QmFjayA9IHZlYzMoIDAuMCApO1xcXFxuI2VuZGlmXFxcXG5JbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0O1xcXFxuZmxvYXQgZG90Tkw7XFxcXG52ZWMzIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXFxcbiNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxcXFxuXFxcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRTOyBpICsrICkge1xcXFxuXFxcXHRcXFxcdGdldFBvaW50RGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBwb2ludExpZ2h0c1sgaSBdLCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcXFxcblxcXFx0XFxcXHRkb3ROTCA9IGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKTtcXFxcblxcXFx0XFxcXHRkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2UgPSBQSSAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcXFxuXFxcXHRcXFxcdHZMaWdodEZyb250ICs9IHNhdHVyYXRlKCBkb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcXFxuXFxcXHRcXFxcdCNpZmRlZiBET1VCTEVfU0lERURcXFxcblxcXFx0XFxcXHRcXFxcdHZMaWdodEJhY2sgKz0gc2F0dXJhdGUoIC1kb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcXFxuXFxcXHRcXFxcdCNlbmRpZlxcXFxuXFxcXHR9XFxcXG4jZW5kaWZcXFxcbiNpZiBOVU1fU1BPVF9MSUdIVFMgPiAwXFxcXG5cXFxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9TUE9UX0xJR0hUUzsgaSArKyApIHtcXFxcblxcXFx0XFxcXHRnZXRTcG90RGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBzcG90TGlnaHRzWyBpIF0sIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xcXFxuXFxcXHRcXFxcdGRvdE5MID0gZG90KCBnZW9tZXRyeS5ub3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApO1xcXFxuXFxcXHRcXFxcdGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZSA9IFBJICogZGlyZWN0TGlnaHQuY29sb3I7XFxcXG5cXFxcdFxcXFx0dkxpZ2h0RnJvbnQgKz0gc2F0dXJhdGUoIGRvdE5MICkgKiBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxcXG5cXFxcdFxcXFx0I2lmZGVmIERPVUJMRV9TSURFRFxcXFxuXFxcXHRcXFxcdFxcXFx0dkxpZ2h0QmFjayArPSBzYXR1cmF0ZSggLWRvdE5MICkgKiBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxcXG5cXFxcdFxcXFx0I2VuZGlmXFxcXG5cXFxcdH1cXFxcbiNlbmRpZlxcXFxuI2lmIE5VTV9ESVJfTElHSFRTID4gMFxcXFxuXFxcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUUzsgaSArKyApIHtcXFxcblxcXFx0XFxcXHRnZXREaXJlY3Rpb25hbERpcmVjdExpZ2h0SXJyYWRpYW5jZSggZGlyZWN0aW9uYWxMaWdodHNbIGkgXSwgZ2VvbWV0cnksIGRpcmVjdExpZ2h0ICk7XFxcXG5cXFxcdFxcXFx0ZG90TkwgPSBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICk7XFxcXG5cXFxcdFxcXFx0ZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlID0gUEkgKiBkaXJlY3RMaWdodC5jb2xvcjtcXFxcblxcXFx0XFxcXHR2TGlnaHRGcm9udCArPSBzYXR1cmF0ZSggZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXFxcblxcXFx0XFxcXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxcXG5cXFxcdFxcXFx0XFxcXHR2TGlnaHRCYWNrICs9IHNhdHVyYXRlKCAtZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXFxcblxcXFx0XFxcXHQjZW5kaWZcXFxcblxcXFx0fVxcXFxuI2VuZGlmXFxcXG4jaWYgTlVNX0hFTUlfTElHSFRTID4gMFxcXFxuXFxcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fSEVNSV9MSUdIVFM7IGkgKysgKSB7XFxcXG5cXFxcdFxcXFx0dkxpZ2h0RnJvbnQgKz0gZ2V0SGVtaXNwaGVyZUxpZ2h0SXJyYWRpYW5jZSggaGVtaXNwaGVyZUxpZ2h0c1sgaSBdLCBnZW9tZXRyeSApO1xcXFxuXFxcXHRcXFxcdCNpZmRlZiBET1VCTEVfU0lERURcXFxcblxcXFx0XFxcXHRcXFxcdHZMaWdodEJhY2sgKz0gZ2V0SGVtaXNwaGVyZUxpZ2h0SXJyYWRpYW5jZSggaGVtaXNwaGVyZUxpZ2h0c1sgaSBdLCBiYWNrR2VvbWV0cnkgKTtcXFxcblxcXFx0XFxcXHQjZW5kaWZcXFxcblxcXFx0fVxcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBsaWdodHNfcGFycyA9IFxcXCJ1bmlmb3JtIHZlYzMgYW1iaWVudExpZ2h0Q29sb3I7XFxcXG52ZWMzIGdldEFtYmllbnRMaWdodElycmFkaWFuY2UoIGNvbnN0IGluIHZlYzMgYW1iaWVudExpZ2h0Q29sb3IgKSB7XFxcXG5cXFxcdHZlYzMgaXJyYWRpYW5jZSA9IGFtYmllbnRMaWdodENvbG9yO1xcXFxuXFxcXHQjaWZuZGVmIFBIWVNJQ0FMTFlfQ09SUkVDVF9MSUdIVFNcXFxcblxcXFx0XFxcXHRpcnJhZGlhbmNlICo9IFBJO1xcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0cmV0dXJuIGlycmFkaWFuY2U7XFxcXG59XFxcXG4jaWYgTlVNX0RJUl9MSUdIVFMgPiAwXFxcXG5cXFxcdHN0cnVjdCBEaXJlY3Rpb25hbExpZ2h0IHtcXFxcblxcXFx0XFxcXHR2ZWMzIGRpcmVjdGlvbjtcXFxcblxcXFx0XFxcXHR2ZWMzIGNvbG9yO1xcXFxuXFxcXHRcXFxcdGludCBzaGFkb3c7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgc2hhZG93QmlhcztcXFxcblxcXFx0XFxcXHRmbG9hdCBzaGFkb3dSYWRpdXM7XFxcXG5cXFxcdFxcXFx0dmVjMiBzaGFkb3dNYXBTaXplO1xcXFxuXFxcXHR9O1xcXFxuXFxcXHR1bmlmb3JtIERpcmVjdGlvbmFsTGlnaHQgZGlyZWN0aW9uYWxMaWdodHNbIE5VTV9ESVJfTElHSFRTIF07XFxcXG5cXFxcdHZvaWQgZ2V0RGlyZWN0aW9uYWxEaXJlY3RMaWdodElycmFkaWFuY2UoIGNvbnN0IGluIERpcmVjdGlvbmFsTGlnaHQgZGlyZWN0aW9uYWxMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgb3V0IEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQgKSB7XFxcXG5cXFxcdFxcXFx0ZGlyZWN0TGlnaHQuY29sb3IgPSBkaXJlY3Rpb25hbExpZ2h0LmNvbG9yO1xcXFxuXFxcXHRcXFxcdGRpcmVjdExpZ2h0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbmFsTGlnaHQuZGlyZWN0aW9uO1xcXFxuXFxcXHRcXFxcdGRpcmVjdExpZ2h0LnZpc2libGUgPSB0cnVlO1xcXFxuXFxcXHR9XFxcXG4jZW5kaWZcXFxcbiNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxcXFxuXFxcXHRzdHJ1Y3QgUG9pbnRMaWdodCB7XFxcXG5cXFxcdFxcXFx0dmVjMyBwb3NpdGlvbjtcXFxcblxcXFx0XFxcXHR2ZWMzIGNvbG9yO1xcXFxuXFxcXHRcXFxcdGZsb2F0IGRpc3RhbmNlO1xcXFxuXFxcXHRcXFxcdGZsb2F0IGRlY2F5O1xcXFxuXFxcXHRcXFxcdGludCBzaGFkb3c7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgc2hhZG93QmlhcztcXFxcblxcXFx0XFxcXHRmbG9hdCBzaGFkb3dSYWRpdXM7XFxcXG5cXFxcdFxcXFx0dmVjMiBzaGFkb3dNYXBTaXplO1xcXFxuXFxcXHRcXFxcdGZsb2F0IHNoYWRvd0NhbWVyYU5lYXI7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgc2hhZG93Q2FtZXJhRmFyO1xcXFxuXFxcXHR9O1xcXFxuXFxcXHR1bmlmb3JtIFBvaW50TGlnaHQgcG9pbnRMaWdodHNbIE5VTV9QT0lOVF9MSUdIVFMgXTtcXFxcblxcXFx0dm9pZCBnZXRQb2ludERpcmVjdExpZ2h0SXJyYWRpYW5jZSggY29uc3QgaW4gUG9pbnRMaWdodCBwb2ludExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBvdXQgSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCApIHtcXFxcblxcXFx0XFxcXHR2ZWMzIGxWZWN0b3IgPSBwb2ludExpZ2h0LnBvc2l0aW9uIC0gZ2VvbWV0cnkucG9zaXRpb247XFxcXG5cXFxcdFxcXFx0ZGlyZWN0TGlnaHQuZGlyZWN0aW9uID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgbGlnaHREaXN0YW5jZSA9IGxlbmd0aCggbFZlY3RvciApO1xcXFxuXFxcXHRcXFxcdGRpcmVjdExpZ2h0LmNvbG9yID0gcG9pbnRMaWdodC5jb2xvcjtcXFxcblxcXFx0XFxcXHRkaXJlY3RMaWdodC5jb2xvciAqPSBwdW5jdHVhbExpZ2h0SW50ZW5zaXR5VG9JcnJhZGlhbmNlRmFjdG9yKCBsaWdodERpc3RhbmNlLCBwb2ludExpZ2h0LmRpc3RhbmNlLCBwb2ludExpZ2h0LmRlY2F5ICk7XFxcXG5cXFxcdFxcXFx0ZGlyZWN0TGlnaHQudmlzaWJsZSA9ICggZGlyZWN0TGlnaHQuY29sb3IgIT0gdmVjMyggMC4wICkgKTtcXFxcblxcXFx0fVxcXFxuI2VuZGlmXFxcXG4jaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcXFxuXFxcXHRzdHJ1Y3QgU3BvdExpZ2h0IHtcXFxcblxcXFx0XFxcXHR2ZWMzIHBvc2l0aW9uO1xcXFxuXFxcXHRcXFxcdHZlYzMgZGlyZWN0aW9uO1xcXFxuXFxcXHRcXFxcdHZlYzMgY29sb3I7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgZGlzdGFuY2U7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgZGVjYXk7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgY29uZUNvcztcXFxcblxcXFx0XFxcXHRmbG9hdCBwZW51bWJyYUNvcztcXFxcblxcXFx0XFxcXHRpbnQgc2hhZG93O1xcXFxuXFxcXHRcXFxcdGZsb2F0IHNoYWRvd0JpYXM7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgc2hhZG93UmFkaXVzO1xcXFxuXFxcXHRcXFxcdHZlYzIgc2hhZG93TWFwU2l6ZTtcXFxcblxcXFx0fTtcXFxcblxcXFx0dW5pZm9ybSBTcG90TGlnaHQgc3BvdExpZ2h0c1sgTlVNX1NQT1RfTElHSFRTIF07XFxcXG5cXFxcdHZvaWQgZ2V0U3BvdERpcmVjdExpZ2h0SXJyYWRpYW5jZSggY29uc3QgaW4gU3BvdExpZ2h0IHNwb3RMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgb3V0IEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQgICkge1xcXFxuXFxcXHRcXFxcdHZlYzMgbFZlY3RvciA9IHNwb3RMaWdodC5wb3NpdGlvbiAtIGdlb21ldHJ5LnBvc2l0aW9uO1xcXFxuXFxcXHRcXFxcdGRpcmVjdExpZ2h0LmRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcXFxuXFxcXHRcXFxcdGZsb2F0IGxpZ2h0RGlzdGFuY2UgPSBsZW5ndGgoIGxWZWN0b3IgKTtcXFxcblxcXFx0XFxcXHRmbG9hdCBhbmdsZUNvcyA9IGRvdCggZGlyZWN0TGlnaHQuZGlyZWN0aW9uLCBzcG90TGlnaHQuZGlyZWN0aW9uICk7XFxcXG5cXFxcdFxcXFx0aWYgKCBhbmdsZUNvcyA+IHNwb3RMaWdodC5jb25lQ29zICkge1xcXFxuXFxcXHRcXFxcdFxcXFx0ZmxvYXQgc3BvdEVmZmVjdCA9IHNtb290aHN0ZXAoIHNwb3RMaWdodC5jb25lQ29zLCBzcG90TGlnaHQucGVudW1icmFDb3MsIGFuZ2xlQ29zICk7XFxcXG5cXFxcdFxcXFx0XFxcXHRkaXJlY3RMaWdodC5jb2xvciA9IHNwb3RMaWdodC5jb2xvcjtcXFxcblxcXFx0XFxcXHRcXFxcdGRpcmVjdExpZ2h0LmNvbG9yICo9IHNwb3RFZmZlY3QgKiBwdW5jdHVhbExpZ2h0SW50ZW5zaXR5VG9JcnJhZGlhbmNlRmFjdG9yKCBsaWdodERpc3RhbmNlLCBzcG90TGlnaHQuZGlzdGFuY2UsIHNwb3RMaWdodC5kZWNheSApO1xcXFxuXFxcXHRcXFxcdFxcXFx0ZGlyZWN0TGlnaHQudmlzaWJsZSA9IHRydWU7XFxcXG5cXFxcdFxcXFx0fSBlbHNlIHtcXFxcblxcXFx0XFxcXHRcXFxcdGRpcmVjdExpZ2h0LmNvbG9yID0gdmVjMyggMC4wICk7XFxcXG5cXFxcdFxcXFx0XFxcXHRkaXJlY3RMaWdodC52aXNpYmxlID0gZmFsc2U7XFxcXG5cXFxcdFxcXFx0fVxcXFxuXFxcXHR9XFxcXG4jZW5kaWZcXFxcbiNpZiBOVU1fUkVDVF9BUkVBX0xJR0hUUyA+IDBcXFxcblxcXFx0c3RydWN0IFJlY3RBcmVhTGlnaHQge1xcXFxuXFxcXHRcXFxcdHZlYzMgY29sb3I7XFxcXG5cXFxcdFxcXFx0dmVjMyBwb3NpdGlvbjtcXFxcblxcXFx0XFxcXHR2ZWMzIGhhbGZXaWR0aDtcXFxcblxcXFx0XFxcXHR2ZWMzIGhhbGZIZWlnaHQ7XFxcXG5cXFxcdH07XFxcXG5cXFxcdHVuaWZvcm0gc2FtcGxlcjJEIGx0Y01hdDtcXFxcdHVuaWZvcm0gc2FtcGxlcjJEIGx0Y01hZztcXFxcblxcXFx0dW5pZm9ybSBSZWN0QXJlYUxpZ2h0IHJlY3RBcmVhTGlnaHRzWyBOVU1fUkVDVF9BUkVBX0xJR0hUUyBdO1xcXFxuI2VuZGlmXFxcXG4jaWYgTlVNX0hFTUlfTElHSFRTID4gMFxcXFxuXFxcXHRzdHJ1Y3QgSGVtaXNwaGVyZUxpZ2h0IHtcXFxcblxcXFx0XFxcXHR2ZWMzIGRpcmVjdGlvbjtcXFxcblxcXFx0XFxcXHR2ZWMzIHNreUNvbG9yO1xcXFxuXFxcXHRcXFxcdHZlYzMgZ3JvdW5kQ29sb3I7XFxcXG5cXFxcdH07XFxcXG5cXFxcdHVuaWZvcm0gSGVtaXNwaGVyZUxpZ2h0IGhlbWlzcGhlcmVMaWdodHNbIE5VTV9IRU1JX0xJR0hUUyBdO1xcXFxuXFxcXHR2ZWMzIGdldEhlbWlzcGhlcmVMaWdodElycmFkaWFuY2UoIGNvbnN0IGluIEhlbWlzcGhlcmVMaWdodCBoZW1pTGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnkgKSB7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgZG90TkwgPSBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgaGVtaUxpZ2h0LmRpcmVjdGlvbiApO1xcXFxuXFxcXHRcXFxcdGZsb2F0IGhlbWlEaWZmdXNlV2VpZ2h0ID0gMC41ICogZG90TkwgKyAwLjU7XFxcXG5cXFxcdFxcXFx0dmVjMyBpcnJhZGlhbmNlID0gbWl4KCBoZW1pTGlnaHQuZ3JvdW5kQ29sb3IsIGhlbWlMaWdodC5za3lDb2xvciwgaGVtaURpZmZ1c2VXZWlnaHQgKTtcXFxcblxcXFx0XFxcXHQjaWZuZGVmIFBIWVNJQ0FMTFlfQ09SUkVDVF9MSUdIVFNcXFxcblxcXFx0XFxcXHRcXFxcdGlycmFkaWFuY2UgKj0gUEk7XFxcXG5cXFxcdFxcXFx0I2VuZGlmXFxcXG5cXFxcdFxcXFx0cmV0dXJuIGlycmFkaWFuY2U7XFxcXG5cXFxcdH1cXFxcbiNlbmRpZlxcXFxuI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiBkZWZpbmVkKCBQSFlTSUNBTCApXFxcXG5cXFxcdHZlYzMgZ2V0TGlnaHRQcm9iZUluZGlyZWN0SXJyYWRpYW5jZSggY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gaW50IG1heE1JUExldmVsICkge1xcXFxuXFxcXHRcXFxcdHZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCBnZW9tZXRyeS5ub3JtYWwsIHZpZXdNYXRyaXggKTtcXFxcblxcXFx0XFxcXHQjaWZkZWYgRU5WTUFQX1RZUEVfQ1VCRVxcXFxuXFxcXHRcXFxcdFxcXFx0dmVjMyBxdWVyeVZlYyA9IHZlYzMoIGZsaXBFbnZNYXAgKiB3b3JsZE5vcm1hbC54LCB3b3JsZE5vcm1hbC55eiApO1xcXFxuXFxcXHRcXFxcdFxcXFx0I2lmZGVmIFRFWFRVUkVfTE9EX0VYVFxcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmVMb2RFWFQoIGVudk1hcCwgcXVlcnlWZWMsIGZsb2F0KCBtYXhNSVBMZXZlbCApICk7XFxcXG5cXFxcdFxcXFx0XFxcXHQjZWxzZVxcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgcXVlcnlWZWMsIGZsb2F0KCBtYXhNSVBMZXZlbCApICk7XFxcXG5cXFxcdFxcXFx0XFxcXHQjZW5kaWZcXFxcblxcXFx0XFxcXHRcXFxcdGVudk1hcENvbG9yLnJnYiA9IGVudk1hcFRleGVsVG9MaW5lYXIoIGVudk1hcENvbG9yICkucmdiO1xcXFxuXFxcXHRcXFxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX0NVQkVfVVYgKVxcXFxuXFxcXHRcXFxcdFxcXFx0dmVjMyBxdWVyeVZlYyA9IHZlYzMoIGZsaXBFbnZNYXAgKiB3b3JsZE5vcm1hbC54LCB3b3JsZE5vcm1hbC55eiApO1xcXFxuXFxcXHRcXFxcdFxcXFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlVVYoIHF1ZXJ5VmVjLCAxLjAgKTtcXFxcblxcXFx0XFxcXHQjZWxzZVxcXFxuXFxcXHRcXFxcdFxcXFx0dmVjNCBlbnZNYXBDb2xvciA9IHZlYzQoIDAuMCApO1xcXFxuXFxcXHRcXFxcdCNlbmRpZlxcXFxuXFxcXHRcXFxcdHJldHVybiBQSSAqIGVudk1hcENvbG9yLnJnYiAqIGVudk1hcEludGVuc2l0eTtcXFxcblxcXFx0fVxcXFxuXFxcXHRmbG9hdCBnZXRTcGVjdWxhck1JUExldmVsKCBjb25zdCBpbiBmbG9hdCBibGlublNoaW5pbmVzc0V4cG9uZW50LCBjb25zdCBpbiBpbnQgbWF4TUlQTGV2ZWwgKSB7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgbWF4TUlQTGV2ZWxTY2FsYXIgPSBmbG9hdCggbWF4TUlQTGV2ZWwgKTtcXFxcblxcXFx0XFxcXHRmbG9hdCBkZXNpcmVkTUlQTGV2ZWwgPSBtYXhNSVBMZXZlbFNjYWxhciArIDAuNzkyNDggLSAwLjUgKiBsb2cyKCBwb3cyKCBibGlublNoaW5pbmVzc0V4cG9uZW50ICkgKyAxLjAgKTtcXFxcblxcXFx0XFxcXHRyZXR1cm4gY2xhbXAoIGRlc2lyZWRNSVBMZXZlbCwgMC4wLCBtYXhNSVBMZXZlbFNjYWxhciApO1xcXFxuXFxcXHR9XFxcXG5cXFxcdHZlYzMgZ2V0TGlnaHRQcm9iZUluZGlyZWN0UmFkaWFuY2UoIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIGZsb2F0IGJsaW5uU2hpbmluZXNzRXhwb25lbnQsIGNvbnN0IGluIGludCBtYXhNSVBMZXZlbCApIHtcXFxcblxcXFx0XFxcXHQjaWZkZWYgRU5WTUFQX01PREVfUkVGTEVDVElPTlxcXFxuXFxcXHRcXFxcdFxcXFx0dmVjMyByZWZsZWN0VmVjID0gcmVmbGVjdCggLWdlb21ldHJ5LnZpZXdEaXIsIGdlb21ldHJ5Lm5vcm1hbCApO1xcXFxuXFxcXHRcXFxcdCNlbHNlXFxcXG5cXFxcdFxcXFx0XFxcXHR2ZWMzIHJlZmxlY3RWZWMgPSByZWZyYWN0KCAtZ2VvbWV0cnkudmlld0RpciwgZ2VvbWV0cnkubm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTtcXFxcblxcXFx0XFxcXHQjZW5kaWZcXFxcblxcXFx0XFxcXHRyZWZsZWN0VmVjID0gaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggcmVmbGVjdFZlYywgdmlld01hdHJpeCApO1xcXFxuXFxcXHRcXFxcdGZsb2F0IHNwZWN1bGFyTUlQTGV2ZWwgPSBnZXRTcGVjdWxhck1JUExldmVsKCBibGlublNoaW5pbmVzc0V4cG9uZW50LCBtYXhNSVBMZXZlbCApO1xcXFxuXFxcXHRcXFxcdCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXFxcXG5cXFxcdFxcXFx0XFxcXHR2ZWMzIHF1ZXJ5UmVmbGVjdFZlYyA9IHZlYzMoIGZsaXBFbnZNYXAgKiByZWZsZWN0VmVjLngsIHJlZmxlY3RWZWMueXogKTtcXFxcblxcXFx0XFxcXHRcXFxcdCNpZmRlZiBURVhUVVJFX0xPRF9FWFRcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlTG9kRVhUKCBlbnZNYXAsIHF1ZXJ5UmVmbGVjdFZlYywgc3BlY3VsYXJNSVBMZXZlbCApO1xcXFxuXFxcXHRcXFxcdFxcXFx0I2Vsc2VcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIHF1ZXJ5UmVmbGVjdFZlYywgc3BlY3VsYXJNSVBMZXZlbCApO1xcXFxuXFxcXHRcXFxcdFxcXFx0I2VuZGlmXFxcXG5cXFxcdFxcXFx0XFxcXHRlbnZNYXBDb2xvci5yZ2IgPSBlbnZNYXBUZXhlbFRvTGluZWFyKCBlbnZNYXBDb2xvciApLnJnYjtcXFxcblxcXFx0XFxcXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9DVUJFX1VWIClcXFxcblxcXFx0XFxcXHRcXFxcdHZlYzMgcXVlcnlSZWZsZWN0VmVjID0gdmVjMyggZmxpcEVudk1hcCAqIHJlZmxlY3RWZWMueCwgcmVmbGVjdFZlYy55eiApO1xcXFxuXFxcXHRcXFxcdFxcXFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmVDdWJlVVYocXVlcnlSZWZsZWN0VmVjLCBCbGlubkV4cG9uZW50VG9HR1hSb3VnaG5lc3MoYmxpbm5TaGluaW5lc3NFeHBvbmVudCkpO1xcXFxuXFxcXHRcXFxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX0VRVUlSRUMgKVxcXFxuXFxcXHRcXFxcdFxcXFx0dmVjMiBzYW1wbGVVVjtcXFxcblxcXFx0XFxcXHRcXFxcdHNhbXBsZVVWLnkgPSBhc2luKCBjbGFtcCggcmVmbGVjdFZlYy55LCAtIDEuMCwgMS4wICkgKSAqIFJFQ0lQUk9DQUxfUEkgKyAwLjU7XFxcXG5cXFxcdFxcXFx0XFxcXHRzYW1wbGVVVi54ID0gYXRhbiggcmVmbGVjdFZlYy56LCByZWZsZWN0VmVjLnggKSAqIFJFQ0lQUk9DQUxfUEkyICsgMC41O1xcXFxuXFxcXHRcXFxcdFxcXFx0I2lmZGVmIFRFWFRVUkVfTE9EX0VYVFxcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZTJETG9kRVhUKCBlbnZNYXAsIHNhbXBsZVVWLCBzcGVjdWxhck1JUExldmVsICk7XFxcXG5cXFxcdFxcXFx0XFxcXHQjZWxzZVxcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZTJEKCBlbnZNYXAsIHNhbXBsZVVWLCBzcGVjdWxhck1JUExldmVsICk7XFxcXG5cXFxcdFxcXFx0XFxcXHQjZW5kaWZcXFxcblxcXFx0XFxcXHRcXFxcdGVudk1hcENvbG9yLnJnYiA9IGVudk1hcFRleGVsVG9MaW5lYXIoIGVudk1hcENvbG9yICkucmdiO1xcXFxuXFxcXHRcXFxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX1NQSEVSRSApXFxcXG5cXFxcdFxcXFx0XFxcXHR2ZWMzIHJlZmxlY3RWaWV3ID0gbm9ybWFsaXplKCAoIHZpZXdNYXRyaXggKiB2ZWM0KCByZWZsZWN0VmVjLCAwLjAgKSApLnh5eiArIHZlYzMoIDAuMCwwLjAsMS4wICkgKTtcXFxcblxcXFx0XFxcXHRcXFxcdCNpZmRlZiBURVhUVVJFX0xPRF9FWFRcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmUyRExvZEVYVCggZW52TWFwLCByZWZsZWN0Vmlldy54eSAqIDAuNSArIDAuNSwgc3BlY3VsYXJNSVBMZXZlbCApO1xcXFxuXFxcXHRcXFxcdFxcXFx0I2Vsc2VcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dmVjNCBlbnZNYXBDb2xvciA9IHRleHR1cmUyRCggZW52TWFwLCByZWZsZWN0Vmlldy54eSAqIDAuNSArIDAuNSwgc3BlY3VsYXJNSVBMZXZlbCApO1xcXFxuXFxcXHRcXFxcdFxcXFx0I2VuZGlmXFxcXG5cXFxcdFxcXFx0XFxcXHRlbnZNYXBDb2xvci5yZ2IgPSBlbnZNYXBUZXhlbFRvTGluZWFyKCBlbnZNYXBDb2xvciApLnJnYjtcXFxcblxcXFx0XFxcXHQjZW5kaWZcXFxcblxcXFx0XFxcXHRyZXR1cm4gZW52TWFwQ29sb3IucmdiICogZW52TWFwSW50ZW5zaXR5O1xcXFxuXFxcXHR9XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIGxpZ2h0c19waG9uZ19mcmFnbWVudCA9IFxcXCJCbGlublBob25nTWF0ZXJpYWwgbWF0ZXJpYWw7XFxcXG5tYXRlcmlhbC5kaWZmdXNlQ29sb3IgPSBkaWZmdXNlQ29sb3IucmdiO1xcXFxubWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IHNwZWN1bGFyO1xcXFxubWF0ZXJpYWwuc3BlY3VsYXJTaGluaW5lc3MgPSBzaGluaW5lc3M7XFxcXG5tYXRlcmlhbC5zcGVjdWxhclN0cmVuZ3RoID0gc3BlY3VsYXJTdHJlbmd0aDtcXFxcblxcXCI7XFxuXFxuXFx0dmFyIGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50ID0gXFxcInZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcXFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcXFxuXFxcXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXFxcbiNlbmRpZlxcXFxuc3RydWN0IEJsaW5uUGhvbmdNYXRlcmlhbCB7XFxcXG5cXFxcdHZlYzNcXFxcdGRpZmZ1c2VDb2xvcjtcXFxcblxcXFx0dmVjM1xcXFx0c3BlY3VsYXJDb2xvcjtcXFxcblxcXFx0ZmxvYXRcXFxcdHNwZWN1bGFyU2hpbmluZXNzO1xcXFxuXFxcXHRmbG9hdFxcXFx0c3BlY3VsYXJTdHJlbmd0aDtcXFxcbn07XFxcXG52b2lkIFJFX0RpcmVjdF9CbGlublBob25nKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBCbGlublBob25nTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcXFxuXFxcXHQjaWZkZWYgVE9PTlxcXFxuXFxcXHRcXFxcdHZlYzMgaXJyYWRpYW5jZSA9IGdldEdyYWRpZW50SXJyYWRpYW5jZSggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcXFxuXFxcXHQjZWxzZVxcXFxuXFxcXHRcXFxcdGZsb2F0IGRvdE5MID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKSApO1xcXFxuXFxcXHRcXFxcdHZlYzMgaXJyYWRpYW5jZSA9IGRvdE5MICogZGlyZWN0TGlnaHQuY29sb3I7XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHQjaWZuZGVmIFBIWVNJQ0FMTFlfQ09SUkVDVF9MSUdIVFNcXFxcblxcXFx0XFxcXHRpcnJhZGlhbmNlICo9IFBJO1xcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9EaWZmdXNlX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcXFxuXFxcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBpcnJhZGlhbmNlICogQlJERl9TcGVjdWxhcl9CbGlublBob25nKCBkaXJlY3RMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyU2hpbmluZXNzICkgKiBtYXRlcmlhbC5zcGVjdWxhclN0cmVuZ3RoO1xcXFxufVxcXFxudm9pZCBSRV9JbmRpcmVjdERpZmZ1c2VfQmxpbm5QaG9uZyggY29uc3QgaW4gdmVjMyBpcnJhZGlhbmNlLCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBCbGlublBob25nTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcXFxuXFxcXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gaXJyYWRpYW5jZSAqIEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKTtcXFxcbn1cXFxcbiNkZWZpbmUgUkVfRGlyZWN0XFxcXHRcXFxcdFxcXFx0XFxcXHRSRV9EaXJlY3RfQmxpbm5QaG9uZ1xcXFxuI2RlZmluZSBSRV9JbmRpcmVjdERpZmZ1c2VcXFxcdFxcXFx0UkVfSW5kaXJlY3REaWZmdXNlX0JsaW5uUGhvbmdcXFxcbiNkZWZpbmUgTWF0ZXJpYWxfTGlnaHRQcm9iZUxPRCggbWF0ZXJpYWwgKVxcXFx0KDApXFxcXG5cXFwiO1xcblxcblxcdHZhciBsaWdodHNfcGh5c2ljYWxfZnJhZ21lbnQgPSBcXFwiUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbDtcXFxcbm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IGRpZmZ1c2VDb2xvci5yZ2IgKiAoIDEuMCAtIG1ldGFsbmVzc0ZhY3RvciApO1xcXFxubWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MgPSBjbGFtcCggcm91Z2huZXNzRmFjdG9yLCAwLjA0LCAxLjAgKTtcXFxcbiNpZmRlZiBTVEFOREFSRFxcXFxuXFxcXHRtYXRlcmlhbC5zcGVjdWxhckNvbG9yID0gbWl4KCB2ZWMzKCBERUZBVUxUX1NQRUNVTEFSX0NPRUZGSUNJRU5UICksIGRpZmZ1c2VDb2xvci5yZ2IsIG1ldGFsbmVzc0ZhY3RvciApO1xcXFxuI2Vsc2VcXFxcblxcXFx0bWF0ZXJpYWwuc3BlY3VsYXJDb2xvciA9IG1peCggdmVjMyggTUFYSU1VTV9TUEVDVUxBUl9DT0VGRklDSUVOVCAqIHBvdzIoIHJlZmxlY3Rpdml0eSApICksIGRpZmZ1c2VDb2xvci5yZ2IsIG1ldGFsbmVzc0ZhY3RvciApO1xcXFxuXFxcXHRtYXRlcmlhbC5jbGVhckNvYXQgPSBzYXR1cmF0ZSggY2xlYXJDb2F0ICk7XFxcXHRtYXRlcmlhbC5jbGVhckNvYXRSb3VnaG5lc3MgPSBjbGFtcCggY2xlYXJDb2F0Um91Z2huZXNzLCAwLjA0LCAxLjAgKTtcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgbGlnaHRzX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQgPSBcXFwic3RydWN0IFBoeXNpY2FsTWF0ZXJpYWwge1xcXFxuXFxcXHR2ZWMzXFxcXHRkaWZmdXNlQ29sb3I7XFxcXG5cXFxcdGZsb2F0XFxcXHRzcGVjdWxhclJvdWdobmVzcztcXFxcblxcXFx0dmVjM1xcXFx0c3BlY3VsYXJDb2xvcjtcXFxcblxcXFx0I2lmbmRlZiBTVEFOREFSRFxcXFxuXFxcXHRcXFxcdGZsb2F0IGNsZWFyQ29hdDtcXFxcblxcXFx0XFxcXHRmbG9hdCBjbGVhckNvYXRSb3VnaG5lc3M7XFxcXG5cXFxcdCNlbmRpZlxcXFxufTtcXFxcbiNkZWZpbmUgTUFYSU1VTV9TUEVDVUxBUl9DT0VGRklDSUVOVCAwLjE2XFxcXG4jZGVmaW5lIERFRkFVTFRfU1BFQ1VMQVJfQ09FRkZJQ0lFTlQgMC4wNFxcXFxuZmxvYXQgY2xlYXJDb2F0REhSQXBwcm94KCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MsIGNvbnN0IGluIGZsb2F0IGRvdE5MICkge1xcXFxuXFxcXHRyZXR1cm4gREVGQVVMVF9TUEVDVUxBUl9DT0VGRklDSUVOVCArICggMS4wIC0gREVGQVVMVF9TUEVDVUxBUl9DT0VGRklDSUVOVCApICogKCBwb3coIDEuMCAtIGRvdE5MLCA1LjAgKSAqIHBvdyggMS4wIC0gcm91Z2huZXNzLCAyLjAgKSApO1xcXFxufVxcXFxuI2lmIE5VTV9SRUNUX0FSRUFfTElHSFRTID4gMFxcXFxuXFxcXHR2b2lkIFJFX0RpcmVjdF9SZWN0QXJlYV9QaHlzaWNhbCggY29uc3QgaW4gUmVjdEFyZWFMaWdodCByZWN0QXJlYUxpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXFxcblxcXFx0XFxcXHR2ZWMzIG5vcm1hbCA9IGdlb21ldHJ5Lm5vcm1hbDtcXFxcblxcXFx0XFxcXHR2ZWMzIHZpZXdEaXIgPSBnZW9tZXRyeS52aWV3RGlyO1xcXFxuXFxcXHRcXFxcdHZlYzMgcG9zaXRpb24gPSBnZW9tZXRyeS5wb3NpdGlvbjtcXFxcblxcXFx0XFxcXHR2ZWMzIGxpZ2h0UG9zID0gcmVjdEFyZWFMaWdodC5wb3NpdGlvbjtcXFxcblxcXFx0XFxcXHR2ZWMzIGhhbGZXaWR0aCA9IHJlY3RBcmVhTGlnaHQuaGFsZldpZHRoO1xcXFxuXFxcXHRcXFxcdHZlYzMgaGFsZkhlaWdodCA9IHJlY3RBcmVhTGlnaHQuaGFsZkhlaWdodDtcXFxcblxcXFx0XFxcXHR2ZWMzIGxpZ2h0Q29sb3IgPSByZWN0QXJlYUxpZ2h0LmNvbG9yO1xcXFxuXFxcXHRcXFxcdGZsb2F0IHJvdWdobmVzcyA9IG1hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzO1xcXFxuXFxcXHRcXFxcdHZlYzMgcmVjdENvb3Jkc1sgNCBdO1xcXFxuXFxcXHRcXFxcdHJlY3RDb29yZHNbIDAgXSA9IGxpZ2h0UG9zIC0gaGFsZldpZHRoIC0gaGFsZkhlaWdodDtcXFxcdFxcXFx0cmVjdENvb3Jkc1sgMSBdID0gbGlnaHRQb3MgKyBoYWxmV2lkdGggLSBoYWxmSGVpZ2h0O1xcXFxuXFxcXHRcXFxcdHJlY3RDb29yZHNbIDIgXSA9IGxpZ2h0UG9zICsgaGFsZldpZHRoICsgaGFsZkhlaWdodDtcXFxcblxcXFx0XFxcXHRyZWN0Q29vcmRzWyAzIF0gPSBsaWdodFBvcyAtIGhhbGZXaWR0aCArIGhhbGZIZWlnaHQ7XFxcXG5cXFxcdFxcXFx0dmVjMiB1diA9IExUQ19Vdiggbm9ybWFsLCB2aWV3RGlyLCByb3VnaG5lc3MgKTtcXFxcblxcXFx0XFxcXHRmbG9hdCBub3JtID0gdGV4dHVyZTJEKCBsdGNNYWcsIHV2ICkuYTtcXFxcblxcXFx0XFxcXHR2ZWM0IHQgPSB0ZXh0dXJlMkQoIGx0Y01hdCwgdXYgKTtcXFxcblxcXFx0XFxcXHRtYXQzIG1JbnYgPSBtYXQzKFxcXFxuXFxcXHRcXFxcdFxcXFx0dmVjMyggICAxLCAgIDAsIHQueSApLFxcXFxuXFxcXHRcXFxcdFxcXFx0dmVjMyggICAwLCB0LnosICAgMCApLFxcXFxuXFxcXHRcXFxcdFxcXFx0dmVjMyggdC53LCAgIDAsIHQueCApXFxcXG5cXFxcdFxcXFx0KTtcXFxcblxcXFx0XFxcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBsaWdodENvbG9yICogbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciAqIG5vcm0gKiBMVENfRXZhbHVhdGUoIG5vcm1hbCwgdmlld0RpciwgcG9zaXRpb24sIG1JbnYsIHJlY3RDb29yZHMgKTtcXFxcblxcXFx0XFxcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9IGxpZ2h0Q29sb3IgKiBtYXRlcmlhbC5kaWZmdXNlQ29sb3IgKiBMVENfRXZhbHVhdGUoIG5vcm1hbCwgdmlld0RpciwgcG9zaXRpb24sIG1hdDMoIDEgKSwgcmVjdENvb3JkcyApO1xcXFxuXFxcXHR9XFxcXG4jZW5kaWZcXFxcbnZvaWQgUkVfRGlyZWN0X1BoeXNpY2FsKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXFxcblxcXFx0ZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApICk7XFxcXG5cXFxcdHZlYzMgaXJyYWRpYW5jZSA9IGRvdE5MICogZGlyZWN0TGlnaHQuY29sb3I7XFxcXG5cXFxcdCNpZm5kZWYgUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUU1xcXFxuXFxcXHRcXFxcdGlycmFkaWFuY2UgKj0gUEk7XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHQjaWZuZGVmIFNUQU5EQVJEXFxcXG5cXFxcdFxcXFx0ZmxvYXQgY2xlYXJDb2F0REhSID0gbWF0ZXJpYWwuY2xlYXJDb2F0ICogY2xlYXJDb2F0REhSQXBwcm94KCBtYXRlcmlhbC5jbGVhckNvYXRSb3VnaG5lc3MsIGRvdE5MICk7XFxcXG5cXFxcdCNlbHNlXFxcXG5cXFxcdFxcXFx0ZmxvYXQgY2xlYXJDb2F0REhSID0gMC4wO1xcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKz0gKCAxLjAgLSBjbGVhckNvYXRESFIgKSAqIGlycmFkaWFuY2UgKiBCUkRGX1NwZWN1bGFyX0dHWCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhclJvdWdobmVzcyApO1xcXFxuXFxcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9ICggMS4wIC0gY2xlYXJDb2F0REhSICkgKiBpcnJhZGlhbmNlICogQlJERl9EaWZmdXNlX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcXFxuXFxcXHQjaWZuZGVmIFNUQU5EQVJEXFxcXG5cXFxcdFxcXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKz0gaXJyYWRpYW5jZSAqIG1hdGVyaWFsLmNsZWFyQ29hdCAqIEJSREZfU3BlY3VsYXJfR0dYKCBkaXJlY3RMaWdodCwgZ2VvbWV0cnksIHZlYzMoIERFRkFVTFRfU1BFQ1VMQVJfQ09FRkZJQ0lFTlQgKSwgbWF0ZXJpYWwuY2xlYXJDb2F0Um91Z2huZXNzICk7XFxcXG5cXFxcdCNlbmRpZlxcXFxufVxcXFxudm9pZCBSRV9JbmRpcmVjdERpZmZ1c2VfUGh5c2ljYWwoIGNvbnN0IGluIHZlYzMgaXJyYWRpYW5jZSwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gUGh5c2ljYWxNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxcXG5cXFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9EaWZmdXNlX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcXFxufVxcXFxudm9pZCBSRV9JbmRpcmVjdFNwZWN1bGFyX1BoeXNpY2FsKCBjb25zdCBpbiB2ZWMzIHJhZGlhbmNlLCBjb25zdCBpbiB2ZWMzIGNsZWFyQ29hdFJhZGlhbmNlLCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXFxcblxcXFx0I2lmbmRlZiBTVEFOREFSRFxcXFxuXFxcXHRcXFxcdGZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBnZW9tZXRyeS52aWV3RGlyICkgKTtcXFxcblxcXFx0XFxcXHRmbG9hdCBkb3ROTCA9IGRvdE5WO1xcXFxuXFxcXHRcXFxcdGZsb2F0IGNsZWFyQ29hdERIUiA9IG1hdGVyaWFsLmNsZWFyQ29hdCAqIGNsZWFyQ29hdERIUkFwcHJveCggbWF0ZXJpYWwuY2xlYXJDb2F0Um91Z2huZXNzLCBkb3ROTCApO1xcXFxuXFxcXHQjZWxzZVxcXFxuXFxcXHRcXFxcdGZsb2F0IGNsZWFyQ29hdERIUiA9IDAuMDtcXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKz0gKCAxLjAgLSBjbGVhckNvYXRESFIgKSAqIHJhZGlhbmNlICogQlJERl9TcGVjdWxhcl9HR1hfRW52aXJvbm1lbnQoIGdlb21ldHJ5LCBtYXRlcmlhbC5zcGVjdWxhckNvbG9yLCBtYXRlcmlhbC5zcGVjdWxhclJvdWdobmVzcyApO1xcXFxuXFxcXHQjaWZuZGVmIFNUQU5EQVJEXFxcXG5cXFxcdFxcXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciArPSBjbGVhckNvYXRSYWRpYW5jZSAqIG1hdGVyaWFsLmNsZWFyQ29hdCAqIEJSREZfU3BlY3VsYXJfR0dYX0Vudmlyb25tZW50KCBnZW9tZXRyeSwgdmVjMyggREVGQVVMVF9TUEVDVUxBUl9DT0VGRklDSUVOVCApLCBtYXRlcmlhbC5jbGVhckNvYXRSb3VnaG5lc3MgKTtcXFxcblxcXFx0I2VuZGlmXFxcXG59XFxcXG4jZGVmaW5lIFJFX0RpcmVjdFxcXFx0XFxcXHRcXFxcdFxcXFx0UkVfRGlyZWN0X1BoeXNpY2FsXFxcXG4jZGVmaW5lIFJFX0RpcmVjdF9SZWN0QXJlYVxcXFx0XFxcXHRSRV9EaXJlY3RfUmVjdEFyZWFfUGh5c2ljYWxcXFxcbiNkZWZpbmUgUkVfSW5kaXJlY3REaWZmdXNlXFxcXHRcXFxcdFJFX0luZGlyZWN0RGlmZnVzZV9QaHlzaWNhbFxcXFxuI2RlZmluZSBSRV9JbmRpcmVjdFNwZWN1bGFyXFxcXHRcXFxcdFJFX0luZGlyZWN0U3BlY3VsYXJfUGh5c2ljYWxcXFxcbiNkZWZpbmUgTWF0ZXJpYWxfQmxpbm5TaGluaW5lc3NFeHBvbmVudCggbWF0ZXJpYWwgKSAgIEdHWFJvdWdobmVzc1RvQmxpbm5FeHBvbmVudCggbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MgKVxcXFxuI2RlZmluZSBNYXRlcmlhbF9DbGVhckNvYXRfQmxpbm5TaGluaW5lc3NFeHBvbmVudCggbWF0ZXJpYWwgKSAgIEdHWFJvdWdobmVzc1RvQmxpbm5FeHBvbmVudCggbWF0ZXJpYWwuY2xlYXJDb2F0Um91Z2huZXNzIClcXFxcbmZsb2F0IGNvbXB1dGVTcGVjdWxhck9jY2x1c2lvbiggY29uc3QgaW4gZmxvYXQgZG90TlYsIGNvbnN0IGluIGZsb2F0IGFtYmllbnRPY2NsdXNpb24sIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXFxcblxcXFx0cmV0dXJuIHNhdHVyYXRlKCBwb3coIGRvdE5WICsgYW1iaWVudE9jY2x1c2lvbiwgZXhwMiggLSAxNi4wICogcm91Z2huZXNzIC0gMS4wICkgKSAtIDEuMCArIGFtYmllbnRPY2NsdXNpb24gKTtcXFxcbn1cXFxcblxcXCI7XFxuXFxuXFx0dmFyIGxpZ2h0c190ZW1wbGF0ZSA9IFxcXCJcXFxcbkdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnk7XFxcXG5nZW9tZXRyeS5wb3NpdGlvbiA9IC0gdlZpZXdQb3NpdGlvbjtcXFxcbmdlb21ldHJ5Lm5vcm1hbCA9IG5vcm1hbDtcXFxcbmdlb21ldHJ5LnZpZXdEaXIgPSBub3JtYWxpemUoIHZWaWV3UG9zaXRpb24gKTtcXFxcbkluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQ7XFxcXG4jaWYgKCBOVU1fUE9JTlRfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApXFxcXG5cXFxcdFBvaW50TGlnaHQgcG9pbnRMaWdodDtcXFxcblxcXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXFxcblxcXFx0XFxcXHRwb2ludExpZ2h0ID0gcG9pbnRMaWdodHNbIGkgXTtcXFxcblxcXFx0XFxcXHRnZXRQb2ludERpcmVjdExpZ2h0SXJyYWRpYW5jZSggcG9pbnRMaWdodCwgZ2VvbWV0cnksIGRpcmVjdExpZ2h0ICk7XFxcXG5cXFxcdFxcXFx0I2lmZGVmIFVTRV9TSEFET1dNQVBcXFxcblxcXFx0XFxcXHRkaXJlY3RMaWdodC5jb2xvciAqPSBhbGwoIGJ2ZWMyKCBwb2ludExpZ2h0LnNoYWRvdywgZGlyZWN0TGlnaHQudmlzaWJsZSApICkgPyBnZXRQb2ludFNoYWRvdyggcG9pbnRTaGFkb3dNYXBbIGkgXSwgcG9pbnRMaWdodC5zaGFkb3dNYXBTaXplLCBwb2ludExpZ2h0LnNoYWRvd0JpYXMsIHBvaW50TGlnaHQuc2hhZG93UmFkaXVzLCB2UG9pbnRTaGFkb3dDb29yZFsgaSBdLCBwb2ludExpZ2h0LnNoYWRvd0NhbWVyYU5lYXIsIHBvaW50TGlnaHQuc2hhZG93Q2FtZXJhRmFyICkgOiAxLjA7XFxcXG5cXFxcdFxcXFx0I2VuZGlmXFxcXG5cXFxcdFxcXFx0UkVfRGlyZWN0KCBkaXJlY3RMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcXFxuXFxcXHR9XFxcXG4jZW5kaWZcXFxcbiNpZiAoIE5VTV9TUE9UX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3QgKVxcXFxuXFxcXHRTcG90TGlnaHQgc3BvdExpZ2h0O1xcXFxuXFxcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxcXG5cXFxcdFxcXFx0c3BvdExpZ2h0ID0gc3BvdExpZ2h0c1sgaSBdO1xcXFxuXFxcXHRcXFxcdGdldFNwb3REaXJlY3RMaWdodElycmFkaWFuY2UoIHNwb3RMaWdodCwgZ2VvbWV0cnksIGRpcmVjdExpZ2h0ICk7XFxcXG5cXFxcdFxcXFx0I2lmZGVmIFVTRV9TSEFET1dNQVBcXFxcblxcXFx0XFxcXHRkaXJlY3RMaWdodC5jb2xvciAqPSBhbGwoIGJ2ZWMyKCBzcG90TGlnaHQuc2hhZG93LCBkaXJlY3RMaWdodC52aXNpYmxlICkgKSA/IGdldFNoYWRvdyggc3BvdFNoYWRvd01hcFsgaSBdLCBzcG90TGlnaHQuc2hhZG93TWFwU2l6ZSwgc3BvdExpZ2h0LnNoYWRvd0JpYXMsIHNwb3RMaWdodC5zaGFkb3dSYWRpdXMsIHZTcG90U2hhZG93Q29vcmRbIGkgXSApIDogMS4wO1xcXFxuXFxcXHRcXFxcdCNlbmRpZlxcXFxuXFxcXHRcXFxcdFJFX0RpcmVjdCggZGlyZWN0TGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXFxcblxcXFx0fVxcXFxuI2VuZGlmXFxcXG4jaWYgKCBOVU1fRElSX0xJR0hUUyA+IDAgKSAmJiBkZWZpbmVkKCBSRV9EaXJlY3QgKVxcXFxuXFxcXHREaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHQ7XFxcXG5cXFxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRTOyBpICsrICkge1xcXFxuXFxcXHRcXFxcdGRpcmVjdGlvbmFsTGlnaHQgPSBkaXJlY3Rpb25hbExpZ2h0c1sgaSBdO1xcXFxuXFxcXHRcXFxcdGdldERpcmVjdGlvbmFsRGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBkaXJlY3Rpb25hbExpZ2h0LCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcXFxcblxcXFx0XFxcXHQjaWZkZWYgVVNFX1NIQURPV01BUFxcXFxuXFxcXHRcXFxcdGRpcmVjdExpZ2h0LmNvbG9yICo9IGFsbCggYnZlYzIoIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93LCBkaXJlY3RMaWdodC52aXNpYmxlICkgKSA/IGdldFNoYWRvdyggZGlyZWN0aW9uYWxTaGFkb3dNYXBbIGkgXSwgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dNYXBTaXplLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd0JpYXMsIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93UmFkaXVzLCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxcXG5cXFxcdFxcXFx0I2VuZGlmXFxcXG5cXFxcdFxcXFx0UkVfRGlyZWN0KCBkaXJlY3RMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcXFxuXFxcXHR9XFxcXG4jZW5kaWZcXFxcbiNpZiAoIE5VTV9SRUNUX0FSRUFfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdF9SZWN0QXJlYSApXFxcXG5cXFxcdFJlY3RBcmVhTGlnaHQgcmVjdEFyZWFMaWdodDtcXFxcblxcXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1JFQ1RfQVJFQV9MSUdIVFM7IGkgKysgKSB7XFxcXG5cXFxcdFxcXFx0cmVjdEFyZWFMaWdodCA9IHJlY3RBcmVhTGlnaHRzWyBpIF07XFxcXG5cXFxcdFxcXFx0UkVfRGlyZWN0X1JlY3RBcmVhKCByZWN0QXJlYUxpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxcXG5cXFxcdH1cXFxcbiNlbmRpZlxcXFxuI2lmIGRlZmluZWQoIFJFX0luZGlyZWN0RGlmZnVzZSApXFxcXG5cXFxcdHZlYzMgaXJyYWRpYW5jZSA9IGdldEFtYmllbnRMaWdodElycmFkaWFuY2UoIGFtYmllbnRMaWdodENvbG9yICk7XFxcXG5cXFxcdCNpZmRlZiBVU0VfTElHSFRNQVBcXFxcblxcXFx0XFxcXHR2ZWMzIGxpZ2h0TWFwSXJyYWRpYW5jZSA9IHRleHR1cmUyRCggbGlnaHRNYXAsIHZVdjIgKS54eXogKiBsaWdodE1hcEludGVuc2l0eTtcXFxcblxcXFx0XFxcXHQjaWZuZGVmIFBIWVNJQ0FMTFlfQ09SUkVDVF9MSUdIVFNcXFxcblxcXFx0XFxcXHRcXFxcdGxpZ2h0TWFwSXJyYWRpYW5jZSAqPSBQSTtcXFxcblxcXFx0XFxcXHQjZW5kaWZcXFxcblxcXFx0XFxcXHRpcnJhZGlhbmNlICs9IGxpZ2h0TWFwSXJyYWRpYW5jZTtcXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdCNpZiAoIE5VTV9IRU1JX0xJR0hUUyA+IDAgKVxcXFxuXFxcXHRcXFxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9IRU1JX0xJR0hUUzsgaSArKyApIHtcXFxcblxcXFx0XFxcXHRcXFxcdGlycmFkaWFuY2UgKz0gZ2V0SGVtaXNwaGVyZUxpZ2h0SXJyYWRpYW5jZSggaGVtaXNwaGVyZUxpZ2h0c1sgaSBdLCBnZW9tZXRyeSApO1xcXFxuXFxcXHRcXFxcdH1cXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdCNpZiBkZWZpbmVkKCBVU0VfRU5WTUFQICkgJiYgZGVmaW5lZCggUEhZU0lDQUwgKSAmJiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9DVUJFX1VWIClcXFxcblxcXFx0XFxcXHRpcnJhZGlhbmNlICs9IGdldExpZ2h0UHJvYmVJbmRpcmVjdElycmFkaWFuY2UoIGdlb21ldHJ5LCA4ICk7XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHRSRV9JbmRpcmVjdERpZmZ1c2UoIGlycmFkaWFuY2UsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXFxcbiNlbmRpZlxcXFxuI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiBkZWZpbmVkKCBSRV9JbmRpcmVjdFNwZWN1bGFyIClcXFxcblxcXFx0dmVjMyByYWRpYW5jZSA9IGdldExpZ2h0UHJvYmVJbmRpcmVjdFJhZGlhbmNlKCBnZW9tZXRyeSwgTWF0ZXJpYWxfQmxpbm5TaGluaW5lc3NFeHBvbmVudCggbWF0ZXJpYWwgKSwgOCApO1xcXFxuXFxcXHQjaWZuZGVmIFNUQU5EQVJEXFxcXG5cXFxcdFxcXFx0dmVjMyBjbGVhckNvYXRSYWRpYW5jZSA9IGdldExpZ2h0UHJvYmVJbmRpcmVjdFJhZGlhbmNlKCBnZW9tZXRyeSwgTWF0ZXJpYWxfQ2xlYXJDb2F0X0JsaW5uU2hpbmluZXNzRXhwb25lbnQoIG1hdGVyaWFsICksIDggKTtcXFxcblxcXFx0I2Vsc2VcXFxcblxcXFx0XFxcXHR2ZWMzIGNsZWFyQ29hdFJhZGlhbmNlID0gdmVjMyggMC4wICk7XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHRSRV9JbmRpcmVjdFNwZWN1bGFyKCByYWRpYW5jZSwgY2xlYXJDb2F0UmFkaWFuY2UsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgbG9nZGVwdGhidWZfZnJhZ21lbnQgPSBcXFwiI2lmIGRlZmluZWQoIFVTRV9MT0dERVBUSEJVRiApICYmIGRlZmluZWQoIFVTRV9MT0dERVBUSEJVRl9FWFQgKVxcXFxuXFxcXHRnbF9GcmFnRGVwdGhFWFQgPSBsb2cyKCB2RnJhZ0RlcHRoICkgKiBsb2dEZXB0aEJ1ZkZDICogMC41O1xcXFxuI2VuZGlmXFxcIjtcXG5cXG5cXHR2YXIgbG9nZGVwdGhidWZfcGFyc19mcmFnbWVudCA9IFxcXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxcXG5cXFxcdHVuaWZvcm0gZmxvYXQgbG9nRGVwdGhCdWZGQztcXFxcblxcXFx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXFxcblxcXFx0XFxcXHR2YXJ5aW5nIGZsb2F0IHZGcmFnRGVwdGg7XFxcXG5cXFxcdCNlbmRpZlxcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleCA9IFxcXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxcXG5cXFxcdCNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxcXG5cXFxcdFxcXFx0dmFyeWluZyBmbG9hdCB2RnJhZ0RlcHRoO1xcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0dW5pZm9ybSBmbG9hdCBsb2dEZXB0aEJ1ZkZDO1xcXFxuI2VuZGlmXFxcIjtcXG5cXG5cXHR2YXIgbG9nZGVwdGhidWZfdmVydGV4ID0gXFxcIiNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXFxcblxcXFx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXFxcblxcXFx0XFxcXHR2RnJhZ0RlcHRoID0gMS4wICsgZ2xfUG9zaXRpb24udztcXFxcblxcXFx0I2Vsc2VcXFxcblxcXFx0XFxcXHRnbF9Qb3NpdGlvbi56ID0gbG9nMiggbWF4KCBFUFNJTE9OLCBnbF9Qb3NpdGlvbi53ICsgMS4wICkgKSAqIGxvZ0RlcHRoQnVmRkMgLSAxLjA7XFxcXG5cXFxcdFxcXFx0Z2xfUG9zaXRpb24ueiAqPSBnbF9Qb3NpdGlvbi53O1xcXFxuXFxcXHQjZW5kaWZcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgbWFwX2ZyYWdtZW50ID0gXFxcIiNpZmRlZiBVU0VfTUFQXFxcXG5cXFxcdHZlYzQgdGV4ZWxDb2xvciA9IHRleHR1cmUyRCggbWFwLCB2VXYgKTtcXFxcblxcXFx0dGV4ZWxDb2xvciA9IG1hcFRleGVsVG9MaW5lYXIoIHRleGVsQ29sb3IgKTtcXFxcblxcXFx0ZGlmZnVzZUNvbG9yICo9IHRleGVsQ29sb3I7XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIG1hcF9wYXJzX2ZyYWdtZW50ID0gXFxcIiNpZmRlZiBVU0VfTUFQXFxcXG5cXFxcdHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgbWFwX3BhcnRpY2xlX2ZyYWdtZW50ID0gXFxcIiNpZmRlZiBVU0VfTUFQXFxcXG5cXFxcdHZlYzIgdXYgPSAoIHV2VHJhbnNmb3JtICogdmVjMyggZ2xfUG9pbnRDb29yZC54LCAxLjAgLSBnbF9Qb2ludENvb3JkLnksIDEgKSApLnh5O1xcXFxuXFxcXHR2ZWM0IG1hcFRleGVsID0gdGV4dHVyZTJEKCBtYXAsIHV2ICk7XFxcXG5cXFxcdGRpZmZ1c2VDb2xvciAqPSBtYXBUZXhlbFRvTGluZWFyKCBtYXBUZXhlbCApO1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudCA9IFxcXCIjaWZkZWYgVVNFX01BUFxcXFxuXFxcXHR1bmlmb3JtIG1hdDMgdXZUcmFuc2Zvcm07XFxcXG5cXFxcdHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgbWV0YWxuZXNzbWFwX2ZyYWdtZW50ID0gXFxcImZsb2F0IG1ldGFsbmVzc0ZhY3RvciA9IG1ldGFsbmVzcztcXFxcbiNpZmRlZiBVU0VfTUVUQUxORVNTTUFQXFxcXG5cXFxcdHZlYzQgdGV4ZWxNZXRhbG5lc3MgPSB0ZXh0dXJlMkQoIG1ldGFsbmVzc01hcCwgdlV2ICk7XFxcXG5cXFxcdG1ldGFsbmVzc0ZhY3RvciAqPSB0ZXhlbE1ldGFsbmVzcy5iO1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudCA9IFxcXCIjaWZkZWYgVVNFX01FVEFMTkVTU01BUFxcXFxuXFxcXHR1bmlmb3JtIHNhbXBsZXIyRCBtZXRhbG5lc3NNYXA7XFxcXG4jZW5kaWZcXFwiO1xcblxcblxcdHZhciBtb3JwaG5vcm1hbF92ZXJ0ZXggPSBcXFwiI2lmZGVmIFVTRV9NT1JQSE5PUk1BTFNcXFxcblxcXFx0b2JqZWN0Tm9ybWFsICs9ICggbW9ycGhOb3JtYWwwIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDAgXTtcXFxcblxcXFx0b2JqZWN0Tm9ybWFsICs9ICggbW9ycGhOb3JtYWwxIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDEgXTtcXFxcblxcXFx0b2JqZWN0Tm9ybWFsICs9ICggbW9ycGhOb3JtYWwyIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDIgXTtcXFxcblxcXFx0b2JqZWN0Tm9ybWFsICs9ICggbW9ycGhOb3JtYWwzIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDMgXTtcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgbW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXggPSBcXFwiI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFNcXFxcblxcXFx0I2lmbmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxcXG5cXFxcdHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA4IF07XFxcXG5cXFxcdCNlbHNlXFxcXG5cXFxcdHVuaWZvcm0gZmxvYXQgbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA0IF07XFxcXG5cXFxcdCNlbmRpZlxcXFxuI2VuZGlmXFxcIjtcXG5cXG5cXHR2YXIgbW9ycGh0YXJnZXRfdmVydGV4ID0gXFxcIiNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTXFxcXG5cXFxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQwIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMCBdO1xcXFxuXFxcXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0MSAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDEgXTtcXFxcblxcXFx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDIgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAyIF07XFxcXG5cXFxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQzIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMyBdO1xcXFxuXFxcXHQjaWZuZGVmIFVTRV9NT1JQSE5PUk1BTFNcXFxcblxcXFx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDQgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA0IF07XFxcXG5cXFxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ1IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNSBdO1xcXFxuXFxcXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0NiAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDYgXTtcXFxcblxcXFx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDcgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA3IF07XFxcXG5cXFxcdCNlbmRpZlxcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBub3JtYWxfZnJhZ21lbnQgPSBcXFwiI2lmZGVmIEZMQVRfU0hBREVEXFxcXG5cXFxcdHZlYzMgZmR4ID0gdmVjMyggZEZkeCggdlZpZXdQb3NpdGlvbi54ICksIGRGZHgoIHZWaWV3UG9zaXRpb24ueSApLCBkRmR4KCB2Vmlld1Bvc2l0aW9uLnogKSApO1xcXFxuXFxcXHR2ZWMzIGZkeSA9IHZlYzMoIGRGZHkoIHZWaWV3UG9zaXRpb24ueCApLCBkRmR5KCB2Vmlld1Bvc2l0aW9uLnkgKSwgZEZkeSggdlZpZXdQb3NpdGlvbi56ICkgKTtcXFxcblxcXFx0dmVjMyBub3JtYWwgPSBub3JtYWxpemUoIGNyb3NzKCBmZHgsIGZkeSApICk7XFxcXG4jZWxzZVxcXFxuXFxcXHR2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggdk5vcm1hbCApO1xcXFxuXFxcXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxcXG5cXFxcdFxcXFx0bm9ybWFsID0gbm9ybWFsICogKCBmbG9hdCggZ2xfRnJvbnRGYWNpbmcgKSAqIDIuMCAtIDEuMCApO1xcXFxuXFxcXHQjZW5kaWZcXFxcbiNlbmRpZlxcXFxuI2lmZGVmIFVTRV9OT1JNQUxNQVBcXFxcblxcXFx0bm9ybWFsID0gcGVydHVyYk5vcm1hbDJBcmIoIC12Vmlld1Bvc2l0aW9uLCBub3JtYWwgKTtcXFxcbiNlbGlmIGRlZmluZWQoIFVTRV9CVU1QTUFQIClcXFxcblxcXFx0bm9ybWFsID0gcGVydHVyYk5vcm1hbEFyYiggLXZWaWV3UG9zaXRpb24sIG5vcm1hbCwgZEhkeHlfZndkKCkgKTtcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgbm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQgPSBcXFwiI2lmZGVmIFVTRV9OT1JNQUxNQVBcXFxcblxcXFx0dW5pZm9ybSBzYW1wbGVyMkQgbm9ybWFsTWFwO1xcXFxuXFxcXHR1bmlmb3JtIHZlYzIgbm9ybWFsU2NhbGU7XFxcXG5cXFxcdHZlYzMgcGVydHVyYk5vcm1hbDJBcmIoIHZlYzMgZXllX3BvcywgdmVjMyBzdXJmX25vcm0gKSB7XFxcXG5cXFxcdFxcXFx0dmVjMyBxMCA9IHZlYzMoIGRGZHgoIGV5ZV9wb3MueCApLCBkRmR4KCBleWVfcG9zLnkgKSwgZEZkeCggZXllX3Bvcy56ICkgKTtcXFxcblxcXFx0XFxcXHR2ZWMzIHExID0gdmVjMyggZEZkeSggZXllX3Bvcy54ICksIGRGZHkoIGV5ZV9wb3MueSApLCBkRmR5KCBleWVfcG9zLnogKSApO1xcXFxuXFxcXHRcXFxcdHZlYzIgc3QwID0gZEZkeCggdlV2LnN0ICk7XFxcXG5cXFxcdFxcXFx0dmVjMiBzdDEgPSBkRmR5KCB2VXYuc3QgKTtcXFxcblxcXFx0XFxcXHR2ZWMzIFMgPSBub3JtYWxpemUoIHEwICogc3QxLnQgLSBxMSAqIHN0MC50ICk7XFxcXG5cXFxcdFxcXFx0dmVjMyBUID0gbm9ybWFsaXplKCAtcTAgKiBzdDEucyArIHExICogc3QwLnMgKTtcXFxcblxcXFx0XFxcXHR2ZWMzIE4gPSBub3JtYWxpemUoIHN1cmZfbm9ybSApO1xcXFxuXFxcXHRcXFxcdHZlYzMgbWFwTiA9IHRleHR1cmUyRCggbm9ybWFsTWFwLCB2VXYgKS54eXogKiAyLjAgLSAxLjA7XFxcXG5cXFxcdFxcXFx0bWFwTi54eSA9IG5vcm1hbFNjYWxlICogbWFwTi54eTtcXFxcblxcXFx0XFxcXHRtYXQzIHRzbiA9IG1hdDMoIFMsIFQsIE4gKTtcXFxcblxcXFx0XFxcXHRyZXR1cm4gbm9ybWFsaXplKCB0c24gKiBtYXBOICk7XFxcXG5cXFxcdH1cXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgcGFja2luZyA9IFxcXCJ2ZWMzIHBhY2tOb3JtYWxUb1JHQiggY29uc3QgaW4gdmVjMyBub3JtYWwgKSB7XFxcXG5cXFxcdHJldHVybiBub3JtYWxpemUoIG5vcm1hbCApICogMC41ICsgMC41O1xcXFxufVxcXFxudmVjMyB1bnBhY2tSR0JUb05vcm1hbCggY29uc3QgaW4gdmVjMyByZ2IgKSB7XFxcXG5cXFxcdHJldHVybiAyLjAgKiByZ2IueHl6IC0gMS4wO1xcXFxufVxcXFxuY29uc3QgZmxvYXQgUGFja1Vwc2NhbGUgPSAyNTYuIC8gMjU1Ljtjb25zdCBmbG9hdCBVbnBhY2tEb3duc2NhbGUgPSAyNTUuIC8gMjU2LjtcXFxcbmNvbnN0IHZlYzMgUGFja0ZhY3RvcnMgPSB2ZWMzKCAyNTYuICogMjU2LiAqIDI1Ni4sIDI1Ni4gKiAyNTYuLCAgMjU2LiApO1xcXFxuY29uc3QgdmVjNCBVbnBhY2tGYWN0b3JzID0gVW5wYWNrRG93bnNjYWxlIC8gdmVjNCggUGFja0ZhY3RvcnMsIDEuICk7XFxcXG5jb25zdCBmbG9hdCBTaGlmdFJpZ2h0OCA9IDEuIC8gMjU2LjtcXFxcbnZlYzQgcGFja0RlcHRoVG9SR0JBKCBjb25zdCBpbiBmbG9hdCB2ICkge1xcXFxuXFxcXHR2ZWM0IHIgPSB2ZWM0KCBmcmFjdCggdiAqIFBhY2tGYWN0b3JzICksIHYgKTtcXFxcblxcXFx0ci55encgLT0gci54eXogKiBTaGlmdFJpZ2h0ODtcXFxcdHJldHVybiByICogUGFja1Vwc2NhbGU7XFxcXG59XFxcXG5mbG9hdCB1bnBhY2tSR0JBVG9EZXB0aCggY29uc3QgaW4gdmVjNCB2ICkge1xcXFxuXFxcXHRyZXR1cm4gZG90KCB2LCBVbnBhY2tGYWN0b3JzICk7XFxcXG59XFxcXG5mbG9hdCB2aWV3WlRvT3J0aG9ncmFwaGljRGVwdGgoIGNvbnN0IGluIGZsb2F0IHZpZXdaLCBjb25zdCBpbiBmbG9hdCBuZWFyLCBjb25zdCBpbiBmbG9hdCBmYXIgKSB7XFxcXG5cXFxcdHJldHVybiAoIHZpZXdaICsgbmVhciApIC8gKCBuZWFyIC0gZmFyICk7XFxcXG59XFxcXG5mbG9hdCBvcnRob2dyYXBoaWNEZXB0aFRvVmlld1ooIGNvbnN0IGluIGZsb2F0IGxpbmVhckNsaXBaLCBjb25zdCBpbiBmbG9hdCBuZWFyLCBjb25zdCBpbiBmbG9hdCBmYXIgKSB7XFxcXG5cXFxcdHJldHVybiBsaW5lYXJDbGlwWiAqICggbmVhciAtIGZhciApIC0gbmVhcjtcXFxcbn1cXFxcbmZsb2F0IHZpZXdaVG9QZXJzcGVjdGl2ZURlcHRoKCBjb25zdCBpbiBmbG9hdCB2aWV3WiwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkge1xcXFxuXFxcXHRyZXR1cm4gKCggbmVhciArIHZpZXdaICkgKiBmYXIgKSAvICgoIGZhciAtIG5lYXIgKSAqIHZpZXdaICk7XFxcXG59XFxcXG5mbG9hdCBwZXJzcGVjdGl2ZURlcHRoVG9WaWV3WiggY29uc3QgaW4gZmxvYXQgaW52Q2xpcFosIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHtcXFxcblxcXFx0cmV0dXJuICggbmVhciAqIGZhciApIC8gKCAoIGZhciAtIG5lYXIgKSAqIGludkNsaXBaIC0gZmFyICk7XFxcXG59XFxcXG5cXFwiO1xcblxcblxcdHZhciBwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50ID0gXFxcIiNpZmRlZiBQUkVNVUxUSVBMSUVEX0FMUEhBXFxcXG5cXFxcdGdsX0ZyYWdDb2xvci5yZ2IgKj0gZ2xfRnJhZ0NvbG9yLmE7XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIHByb2plY3RfdmVydGV4ID0gXFxcInZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcXFxcbmdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XFxcXG5cXFwiO1xcblxcblxcdHZhciBkaXRoZXJpbmdfZnJhZ21lbnQgPSBcXFwiI2lmIGRlZmluZWQoIERJVEhFUklORyApXFxcXG4gIGdsX0ZyYWdDb2xvci5yZ2IgPSBkaXRoZXJpbmcoIGdsX0ZyYWdDb2xvci5yZ2IgKTtcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQgPSBcXFwiI2lmIGRlZmluZWQoIERJVEhFUklORyApXFxcXG5cXFxcdHZlYzMgZGl0aGVyaW5nKCB2ZWMzIGNvbG9yICkge1xcXFxuXFxcXHRcXFxcdGZsb2F0IGdyaWRfcG9zaXRpb24gPSByYW5kKCBnbF9GcmFnQ29vcmQueHkgKTtcXFxcblxcXFx0XFxcXHR2ZWMzIGRpdGhlcl9zaGlmdF9SR0IgPSB2ZWMzKCAwLjI1IC8gMjU1LjAsIC0wLjI1IC8gMjU1LjAsIDAuMjUgLyAyNTUuMCApO1xcXFxuXFxcXHRcXFxcdGRpdGhlcl9zaGlmdF9SR0IgPSBtaXgoIDIuMCAqIGRpdGhlcl9zaGlmdF9SR0IsIC0yLjAgKiBkaXRoZXJfc2hpZnRfUkdCLCBncmlkX3Bvc2l0aW9uICk7XFxcXG5cXFxcdFxcXFx0cmV0dXJuIGNvbG9yICsgZGl0aGVyX3NoaWZ0X1JHQjtcXFxcblxcXFx0fVxcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciByb3VnaG5lc3NtYXBfZnJhZ21lbnQgPSBcXFwiZmxvYXQgcm91Z2huZXNzRmFjdG9yID0gcm91Z2huZXNzO1xcXFxuI2lmZGVmIFVTRV9ST1VHSE5FU1NNQVBcXFxcblxcXFx0dmVjNCB0ZXhlbFJvdWdobmVzcyA9IHRleHR1cmUyRCggcm91Z2huZXNzTWFwLCB2VXYgKTtcXFxcblxcXFx0cm91Z2huZXNzRmFjdG9yICo9IHRleGVsUm91Z2huZXNzLmc7XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIHJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50ID0gXFxcIiNpZmRlZiBVU0VfUk9VR0hORVNTTUFQXFxcXG5cXFxcdHVuaWZvcm0gc2FtcGxlcjJEIHJvdWdobmVzc01hcDtcXFxcbiNlbmRpZlxcXCI7XFxuXFxuXFx0dmFyIHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50ID0gXFxcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxcXG5cXFxcdCNpZiBOVU1fRElSX0xJR0hUUyA+IDBcXFxcblxcXFx0XFxcXHR1bmlmb3JtIHNhbXBsZXIyRCBkaXJlY3Rpb25hbFNoYWRvd01hcFsgTlVNX0RJUl9MSUdIVFMgXTtcXFxcblxcXFx0XFxcXHR2YXJ5aW5nIHZlYzQgdkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIE5VTV9ESVJfTElHSFRTIF07XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHQjaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcXFxuXFxcXHRcXFxcdHVuaWZvcm0gc2FtcGxlcjJEIHNwb3RTaGFkb3dNYXBbIE5VTV9TUE9UX0xJR0hUUyBdO1xcXFxuXFxcXHRcXFxcdHZhcnlpbmcgdmVjNCB2U3BvdFNoYWRvd0Nvb3JkWyBOVU1fU1BPVF9MSUdIVFMgXTtcXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdCNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxcXFxuXFxcXHRcXFxcdHVuaWZvcm0gc2FtcGxlcjJEIHBvaW50U2hhZG93TWFwWyBOVU1fUE9JTlRfTElHSFRTIF07XFxcXG5cXFxcdFxcXFx0dmFyeWluZyB2ZWM0IHZQb2ludFNoYWRvd0Nvb3JkWyBOVU1fUE9JTlRfTElHSFRTIF07XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHRmbG9hdCB0ZXh0dXJlMkRDb21wYXJlKCBzYW1wbGVyMkQgZGVwdGhzLCB2ZWMyIHV2LCBmbG9hdCBjb21wYXJlICkge1xcXFxuXFxcXHRcXFxcdHJldHVybiBzdGVwKCBjb21wYXJlLCB1bnBhY2tSR0JBVG9EZXB0aCggdGV4dHVyZTJEKCBkZXB0aHMsIHV2ICkgKSApO1xcXFxuXFxcXHR9XFxcXG5cXFxcdGZsb2F0IHRleHR1cmUyRFNoYWRvd0xlcnAoIHNhbXBsZXIyRCBkZXB0aHMsIHZlYzIgc2l6ZSwgdmVjMiB1diwgZmxvYXQgY29tcGFyZSApIHtcXFxcblxcXFx0XFxcXHRjb25zdCB2ZWMyIG9mZnNldCA9IHZlYzIoIDAuMCwgMS4wICk7XFxcXG5cXFxcdFxcXFx0dmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvIHNpemU7XFxcXG5cXFxcdFxcXFx0dmVjMiBjZW50cm9pZFVWID0gZmxvb3IoIHV2ICogc2l6ZSArIDAuNSApIC8gc2l6ZTtcXFxcblxcXFx0XFxcXHRmbG9hdCBsYiA9IHRleHR1cmUyRENvbXBhcmUoIGRlcHRocywgY2VudHJvaWRVViArIHRleGVsU2l6ZSAqIG9mZnNldC54eCwgY29tcGFyZSApO1xcXFxuXFxcXHRcXFxcdGZsb2F0IGx0ID0gdGV4dHVyZTJEQ29tcGFyZSggZGVwdGhzLCBjZW50cm9pZFVWICsgdGV4ZWxTaXplICogb2Zmc2V0Lnh5LCBjb21wYXJlICk7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgcmIgPSB0ZXh0dXJlMkRDb21wYXJlKCBkZXB0aHMsIGNlbnRyb2lkVVYgKyB0ZXhlbFNpemUgKiBvZmZzZXQueXgsIGNvbXBhcmUgKTtcXFxcblxcXFx0XFxcXHRmbG9hdCBydCA9IHRleHR1cmUyRENvbXBhcmUoIGRlcHRocywgY2VudHJvaWRVViArIHRleGVsU2l6ZSAqIG9mZnNldC55eSwgY29tcGFyZSApO1xcXFxuXFxcXHRcXFxcdHZlYzIgZiA9IGZyYWN0KCB1diAqIHNpemUgKyAwLjUgKTtcXFxcblxcXFx0XFxcXHRmbG9hdCBhID0gbWl4KCBsYiwgbHQsIGYueSApO1xcXFxuXFxcXHRcXFxcdGZsb2F0IGIgPSBtaXgoIHJiLCBydCwgZi55ICk7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgYyA9IG1peCggYSwgYiwgZi54ICk7XFxcXG5cXFxcdFxcXFx0cmV0dXJuIGM7XFxcXG5cXFxcdH1cXFxcblxcXFx0ZmxvYXQgZ2V0U2hhZG93KCBzYW1wbGVyMkQgc2hhZG93TWFwLCB2ZWMyIHNoYWRvd01hcFNpemUsIGZsb2F0IHNoYWRvd0JpYXMsIGZsb2F0IHNoYWRvd1JhZGl1cywgdmVjNCBzaGFkb3dDb29yZCApIHtcXFxcblxcXFx0XFxcXHRmbG9hdCBzaGFkb3cgPSAxLjA7XFxcXG5cXFxcdFxcXFx0c2hhZG93Q29vcmQueHl6IC89IHNoYWRvd0Nvb3JkLnc7XFxcXG5cXFxcdFxcXFx0c2hhZG93Q29vcmQueiArPSBzaGFkb3dCaWFzO1xcXFxuXFxcXHRcXFxcdGJ2ZWM0IGluRnJ1c3R1bVZlYyA9IGJ2ZWM0ICggc2hhZG93Q29vcmQueCA+PSAwLjAsIHNoYWRvd0Nvb3JkLnggPD0gMS4wLCBzaGFkb3dDb29yZC55ID49IDAuMCwgc2hhZG93Q29vcmQueSA8PSAxLjAgKTtcXFxcblxcXFx0XFxcXHRib29sIGluRnJ1c3R1bSA9IGFsbCggaW5GcnVzdHVtVmVjICk7XFxcXG5cXFxcdFxcXFx0YnZlYzIgZnJ1c3R1bVRlc3RWZWMgPSBidmVjMiggaW5GcnVzdHVtLCBzaGFkb3dDb29yZC56IDw9IDEuMCApO1xcXFxuXFxcXHRcXFxcdGJvb2wgZnJ1c3R1bVRlc3QgPSBhbGwoIGZydXN0dW1UZXN0VmVjICk7XFxcXG5cXFxcdFxcXFx0aWYgKCBmcnVzdHVtVGVzdCApIHtcXFxcblxcXFx0XFxcXHQjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGIClcXFxcblxcXFx0XFxcXHRcXFxcdHZlYzIgdGV4ZWxTaXplID0gdmVjMiggMS4wICkgLyBzaGFkb3dNYXBTaXplO1xcXFxuXFxcXHRcXFxcdFxcXFx0ZmxvYXQgZHgwID0gLSB0ZXhlbFNpemUueCAqIHNoYWRvd1JhZGl1cztcXFxcblxcXFx0XFxcXHRcXFxcdGZsb2F0IGR5MCA9IC0gdGV4ZWxTaXplLnkgKiBzaGFkb3dSYWRpdXM7XFxcXG5cXFxcdFxcXFx0XFxcXHRmbG9hdCBkeDEgPSArIHRleGVsU2l6ZS54ICogc2hhZG93UmFkaXVzO1xcXFxuXFxcXHRcXFxcdFxcXFx0ZmxvYXQgZHkxID0gKyB0ZXhlbFNpemUueSAqIHNoYWRvd1JhZGl1cztcXFxcblxcXFx0XFxcXHRcXFxcdHNoYWRvdyA9IChcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgK1xcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHksIHNoYWRvd0Nvb3JkLnogKSArXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgK1xcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTEgKSwgc2hhZG93Q29vcmQueiApICtcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkxICksIHNoYWRvd0Nvb3JkLnogKSArXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MSApLCBzaGFkb3dDb29yZC56IClcXFxcblxcXFx0XFxcXHRcXFxcdCkgKiAoIDEuMCAvIDkuMCApO1xcXFxuXFxcXHRcXFxcdCNlbGlmIGRlZmluZWQoIFNIQURPV01BUF9UWVBFX1BDRl9TT0ZUIClcXFxcblxcXFx0XFxcXHRcXFxcdHZlYzIgdGV4ZWxTaXplID0gdmVjMiggMS4wICkgLyBzaGFkb3dNYXBTaXplO1xcXFxuXFxcXHRcXFxcdFxcXFx0ZmxvYXQgZHgwID0gLSB0ZXhlbFNpemUueCAqIHNoYWRvd1JhZGl1cztcXFxcblxcXFx0XFxcXHRcXFxcdGZsb2F0IGR5MCA9IC0gdGV4ZWxTaXplLnkgKiBzaGFkb3dSYWRpdXM7XFxcXG5cXFxcdFxcXFx0XFxcXHRmbG9hdCBkeDEgPSArIHRleGVsU2l6ZS54ICogc2hhZG93UmFkaXVzO1xcXFxuXFxcXHRcXFxcdFxcXFx0ZmxvYXQgZHkxID0gKyB0ZXhlbFNpemUueSAqIHNoYWRvd1JhZGl1cztcXFxcblxcXFx0XFxcXHRcXFxcdHNoYWRvdyA9IChcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHRleHR1cmUyRFNoYWRvd0xlcnAoIHNoYWRvd01hcCwgc2hhZG93TWFwU2l6ZSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgK1xcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHRleHR1cmUyRFNoYWRvd0xlcnAoIHNoYWRvd01hcCwgc2hhZG93TWFwU2l6ZSwgc2hhZG93Q29vcmQueHksIHNoYWRvd0Nvb3JkLnogKSArXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHRleHR1cmUyRFNoYWRvd0xlcnAoIHNoYWRvd01hcCwgc2hhZG93TWFwU2l6ZSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIDAuMCApLCBzaGFkb3dDb29yZC56ICkgK1xcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTEgKSwgc2hhZG93Q29vcmQueiApICtcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkxICksIHNoYWRvd0Nvb3JkLnogKSArXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHRleHR1cmUyRFNoYWRvd0xlcnAoIHNoYWRvd01hcCwgc2hhZG93TWFwU2l6ZSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MSApLCBzaGFkb3dDb29yZC56IClcXFxcblxcXFx0XFxcXHRcXFxcdCkgKiAoIDEuMCAvIDkuMCApO1xcXFxuXFxcXHRcXFxcdCNlbHNlXFxcXG5cXFxcdFxcXFx0XFxcXHRzaGFkb3cgPSB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5LCBzaGFkb3dDb29yZC56ICk7XFxcXG5cXFxcdFxcXFx0I2VuZGlmXFxcXG5cXFxcdFxcXFx0fVxcXFxuXFxcXHRcXFxcdHJldHVybiBzaGFkb3c7XFxcXG5cXFxcdH1cXFxcblxcXFx0dmVjMiBjdWJlVG9VViggdmVjMyB2LCBmbG9hdCB0ZXhlbFNpemVZICkge1xcXFxuXFxcXHRcXFxcdHZlYzMgYWJzViA9IGFicyggdiApO1xcXFxuXFxcXHRcXFxcdGZsb2F0IHNjYWxlVG9DdWJlID0gMS4wIC8gbWF4KCBhYnNWLngsIG1heCggYWJzVi55LCBhYnNWLnogKSApO1xcXFxuXFxcXHRcXFxcdGFic1YgKj0gc2NhbGVUb0N1YmU7XFxcXG5cXFxcdFxcXFx0diAqPSBzY2FsZVRvQ3ViZSAqICggMS4wIC0gMi4wICogdGV4ZWxTaXplWSApO1xcXFxuXFxcXHRcXFxcdHZlYzIgcGxhbmFyID0gdi54eTtcXFxcblxcXFx0XFxcXHRmbG9hdCBhbG1vc3RBVGV4ZWwgPSAxLjUgKiB0ZXhlbFNpemVZO1xcXFxuXFxcXHRcXFxcdGZsb2F0IGFsbW9zdE9uZSA9IDEuMCAtIGFsbW9zdEFUZXhlbDtcXFxcblxcXFx0XFxcXHRpZiAoIGFic1YueiA+PSBhbG1vc3RPbmUgKSB7XFxcXG5cXFxcdFxcXFx0XFxcXHRpZiAoIHYueiA+IDAuMCApXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHBsYW5hci54ID0gNC4wIC0gdi54O1xcXFxuXFxcXHRcXFxcdH0gZWxzZSBpZiAoIGFic1YueCA+PSBhbG1vc3RPbmUgKSB7XFxcXG5cXFxcdFxcXFx0XFxcXHRmbG9hdCBzaWduWCA9IHNpZ24oIHYueCApO1xcXFxuXFxcXHRcXFxcdFxcXFx0cGxhbmFyLnggPSB2LnogKiBzaWduWCArIDIuMCAqIHNpZ25YO1xcXFxuXFxcXHRcXFxcdH0gZWxzZSBpZiAoIGFic1YueSA+PSBhbG1vc3RPbmUgKSB7XFxcXG5cXFxcdFxcXFx0XFxcXHRmbG9hdCBzaWduWSA9IHNpZ24oIHYueSApO1xcXFxuXFxcXHRcXFxcdFxcXFx0cGxhbmFyLnggPSB2LnggKyAyLjAgKiBzaWduWSArIDIuMDtcXFxcblxcXFx0XFxcXHRcXFxcdHBsYW5hci55ID0gdi56ICogc2lnblkgLSAyLjA7XFxcXG5cXFxcdFxcXFx0fVxcXFxuXFxcXHRcXFxcdHJldHVybiB2ZWMyKCAwLjEyNSwgMC4yNSApICogcGxhbmFyICsgdmVjMiggMC4zNzUsIDAuNzUgKTtcXFxcblxcXFx0fVxcXFxuXFxcXHRmbG9hdCBnZXRQb2ludFNoYWRvdyggc2FtcGxlcjJEIHNoYWRvd01hcCwgdmVjMiBzaGFkb3dNYXBTaXplLCBmbG9hdCBzaGFkb3dCaWFzLCBmbG9hdCBzaGFkb3dSYWRpdXMsIHZlYzQgc2hhZG93Q29vcmQsIGZsb2F0IHNoYWRvd0NhbWVyYU5lYXIsIGZsb2F0IHNoYWRvd0NhbWVyYUZhciApIHtcXFxcblxcXFx0XFxcXHR2ZWMyIHRleGVsU2l6ZSA9IHZlYzIoIDEuMCApIC8gKCBzaGFkb3dNYXBTaXplICogdmVjMiggNC4wLCAyLjAgKSApO1xcXFxuXFxcXHRcXFxcdHZlYzMgbGlnaHRUb1Bvc2l0aW9uID0gc2hhZG93Q29vcmQueHl6O1xcXFxuXFxcXHRcXFxcdGZsb2F0IGRwID0gKCBsZW5ndGgoIGxpZ2h0VG9Qb3NpdGlvbiApIC0gc2hhZG93Q2FtZXJhTmVhciApIC8gKCBzaGFkb3dDYW1lcmFGYXIgLSBzaGFkb3dDYW1lcmFOZWFyICk7XFxcXHRcXFxcdGRwICs9IHNoYWRvd0JpYXM7XFxcXG5cXFxcdFxcXFx0dmVjMyBiZDNEID0gbm9ybWFsaXplKCBsaWdodFRvUG9zaXRpb24gKTtcXFxcblxcXFx0XFxcXHQjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGICkgfHwgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQgKVxcXFxuXFxcXHRcXFxcdFxcXFx0dmVjMiBvZmZzZXQgPSB2ZWMyKCAtIDEsIDEgKSAqIHNoYWRvd1JhZGl1cyAqIHRleGVsU2l6ZS55O1xcXFxuXFxcXHRcXFxcdFxcXFx0cmV0dXJuIChcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eXksIHRleGVsU2l6ZS55ICksIGRwICkgK1xcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl5eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHl4LCB0ZXhlbFNpemUueSApLCBkcCApICtcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eXgsIHRleGVsU2l6ZS55ICksIGRwICkgK1xcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNELCB0ZXhlbFNpemUueSApLCBkcCApICtcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eHksIHRleGVsU2l6ZS55ICksIGRwICkgK1xcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl4eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueHh4LCB0ZXhlbFNpemUueSApLCBkcCApICtcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC55eHgsIHRleGVsU2l6ZS55ICksIGRwIClcXFxcblxcXFx0XFxcXHRcXFxcdCkgKiAoIDEuMCAvIDkuMCApO1xcXFxuXFxcXHRcXFxcdCNlbHNlXFxcXG5cXFxcdFxcXFx0XFxcXHRyZXR1cm4gdGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCwgdGV4ZWxTaXplLnkgKSwgZHAgKTtcXFxcblxcXFx0XFxcXHQjZW5kaWZcXFxcblxcXFx0fVxcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBzaGFkb3dtYXBfcGFyc192ZXJ0ZXggPSBcXFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcXFxcblxcXFx0I2lmIE5VTV9ESVJfTElHSFRTID4gMFxcXFxuXFxcXHRcXFxcdHVuaWZvcm0gbWF0NCBkaXJlY3Rpb25hbFNoYWRvd01hdHJpeFsgTlVNX0RJUl9MSUdIVFMgXTtcXFxcblxcXFx0XFxcXHR2YXJ5aW5nIHZlYzQgdkRpcmVjdGlvbmFsU2hhZG93Q29vcmRbIE5VTV9ESVJfTElHSFRTIF07XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHQjaWYgTlVNX1NQT1RfTElHSFRTID4gMFxcXFxuXFxcXHRcXFxcdHVuaWZvcm0gbWF0NCBzcG90U2hhZG93TWF0cml4WyBOVU1fU1BPVF9MSUdIVFMgXTtcXFxcblxcXFx0XFxcXHR2YXJ5aW5nIHZlYzQgdlNwb3RTaGFkb3dDb29yZFsgTlVNX1NQT1RfTElHSFRTIF07XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHQjaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXFxcblxcXFx0XFxcXHR1bmlmb3JtIG1hdDQgcG9pbnRTaGFkb3dNYXRyaXhbIE5VTV9QT0lOVF9MSUdIVFMgXTtcXFxcblxcXFx0XFxcXHR2YXJ5aW5nIHZlYzQgdlBvaW50U2hhZG93Q29vcmRbIE5VTV9QT0lOVF9MSUdIVFMgXTtcXFxcblxcXFx0I2VuZGlmXFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIHNoYWRvd21hcF92ZXJ0ZXggPSBcXFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcXFxcblxcXFx0I2lmIE5VTV9ESVJfTElHSFRTID4gMFxcXFxuXFxcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUUzsgaSArKyApIHtcXFxcblxcXFx0XFxcXHR2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgaSBdID0gZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXhbIGkgXSAqIHdvcmxkUG9zaXRpb247XFxcXG5cXFxcdH1cXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdCNpZiBOVU1fU1BPVF9MSUdIVFMgPiAwXFxcXG5cXFxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9TUE9UX0xJR0hUUzsgaSArKyApIHtcXFxcblxcXFx0XFxcXHR2U3BvdFNoYWRvd0Nvb3JkWyBpIF0gPSBzcG90U2hhZG93TWF0cml4WyBpIF0gKiB3b3JsZFBvc2l0aW9uO1xcXFxuXFxcXHR9XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHQjaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXFxcblxcXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXFxcblxcXFx0XFxcXHR2UG9pbnRTaGFkb3dDb29yZFsgaSBdID0gcG9pbnRTaGFkb3dNYXRyaXhbIGkgXSAqIHdvcmxkUG9zaXRpb247XFxcXG5cXFxcdH1cXFxcblxcXFx0I2VuZGlmXFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIHNoYWRvd21hc2tfcGFyc19mcmFnbWVudCA9IFxcXCJmbG9hdCBnZXRTaGFkb3dNYXNrKCkge1xcXFxuXFxcXHRmbG9hdCBzaGFkb3cgPSAxLjA7XFxcXG5cXFxcdCNpZmRlZiBVU0VfU0hBRE9XTUFQXFxcXG5cXFxcdCNpZiBOVU1fRElSX0xJR0hUUyA+IDBcXFxcblxcXFx0RGlyZWN0aW9uYWxMaWdodCBkaXJlY3Rpb25hbExpZ2h0O1xcXFxuXFxcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fRElSX0xJR0hUUzsgaSArKyApIHtcXFxcblxcXFx0XFxcXHRkaXJlY3Rpb25hbExpZ2h0ID0gZGlyZWN0aW9uYWxMaWdodHNbIGkgXTtcXFxcblxcXFx0XFxcXHRzaGFkb3cgKj0gYm9vbCggZGlyZWN0aW9uYWxMaWdodC5zaGFkb3cgKSA/IGdldFNoYWRvdyggZGlyZWN0aW9uYWxTaGFkb3dNYXBbIGkgXSwgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dNYXBTaXplLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd0JpYXMsIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93UmFkaXVzLCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxcXG5cXFxcdH1cXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdCNpZiBOVU1fU1BPVF9MSUdIVFMgPiAwXFxcXG5cXFxcdFNwb3RMaWdodCBzcG90TGlnaHQ7XFxcXG5cXFxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9TUE9UX0xJR0hUUzsgaSArKyApIHtcXFxcblxcXFx0XFxcXHRzcG90TGlnaHQgPSBzcG90TGlnaHRzWyBpIF07XFxcXG5cXFxcdFxcXFx0c2hhZG93ICo9IGJvb2woIHNwb3RMaWdodC5zaGFkb3cgKSA/IGdldFNoYWRvdyggc3BvdFNoYWRvd01hcFsgaSBdLCBzcG90TGlnaHQuc2hhZG93TWFwU2l6ZSwgc3BvdExpZ2h0LnNoYWRvd0JpYXMsIHNwb3RMaWdodC5zaGFkb3dSYWRpdXMsIHZTcG90U2hhZG93Q29vcmRbIGkgXSApIDogMS4wO1xcXFxuXFxcXHR9XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHQjaWYgTlVNX1BPSU5UX0xJR0hUUyA+IDBcXFxcblxcXFx0UG9pbnRMaWdodCBwb2ludExpZ2h0O1xcXFxuXFxcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRTOyBpICsrICkge1xcXFxuXFxcXHRcXFxcdHBvaW50TGlnaHQgPSBwb2ludExpZ2h0c1sgaSBdO1xcXFxuXFxcXHRcXFxcdHNoYWRvdyAqPSBib29sKCBwb2ludExpZ2h0LnNoYWRvdyApID8gZ2V0UG9pbnRTaGFkb3coIHBvaW50U2hhZG93TWFwWyBpIF0sIHBvaW50TGlnaHQuc2hhZG93TWFwU2l6ZSwgcG9pbnRMaWdodC5zaGFkb3dCaWFzLCBwb2ludExpZ2h0LnNoYWRvd1JhZGl1cywgdlBvaW50U2hhZG93Q29vcmRbIGkgXSwgcG9pbnRMaWdodC5zaGFkb3dDYW1lcmFOZWFyLCBwb2ludExpZ2h0LnNoYWRvd0NhbWVyYUZhciApIDogMS4wO1xcXFxuXFxcXHR9XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0cmV0dXJuIHNoYWRvdztcXFxcbn1cXFxcblxcXCI7XFxuXFxuXFx0dmFyIHNraW5iYXNlX3ZlcnRleCA9IFxcXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxcXG5cXFxcdG1hdDQgYm9uZU1hdFggPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueCApO1xcXFxuXFxcXHRtYXQ0IGJvbmVNYXRZID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnkgKTtcXFxcblxcXFx0bWF0NCBib25lTWF0WiA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC56ICk7XFxcXG5cXFxcdG1hdDQgYm9uZU1hdFcgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgudyApO1xcXFxuI2VuZGlmXFxcIjtcXG5cXG5cXHR2YXIgc2tpbm5pbmdfcGFyc192ZXJ0ZXggPSBcXFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcXFxuXFxcXHR1bmlmb3JtIG1hdDQgYmluZE1hdHJpeDtcXFxcblxcXFx0dW5pZm9ybSBtYXQ0IGJpbmRNYXRyaXhJbnZlcnNlO1xcXFxuXFxcXHQjaWZkZWYgQk9ORV9URVhUVVJFXFxcXG5cXFxcdFxcXFx0dW5pZm9ybSBzYW1wbGVyMkQgYm9uZVRleHR1cmU7XFxcXG5cXFxcdFxcXFx0dW5pZm9ybSBpbnQgYm9uZVRleHR1cmVTaXplO1xcXFxuXFxcXHRcXFxcdG1hdDQgZ2V0Qm9uZU1hdHJpeCggY29uc3QgaW4gZmxvYXQgaSApIHtcXFxcblxcXFx0XFxcXHRcXFxcdGZsb2F0IGogPSBpICogNC4wO1xcXFxuXFxcXHRcXFxcdFxcXFx0ZmxvYXQgeCA9IG1vZCggaiwgZmxvYXQoIGJvbmVUZXh0dXJlU2l6ZSApICk7XFxcXG5cXFxcdFxcXFx0XFxcXHRmbG9hdCB5ID0gZmxvb3IoIGogLyBmbG9hdCggYm9uZVRleHR1cmVTaXplICkgKTtcXFxcblxcXFx0XFxcXHRcXFxcdGZsb2F0IGR4ID0gMS4wIC8gZmxvYXQoIGJvbmVUZXh0dXJlU2l6ZSApO1xcXFxuXFxcXHRcXFxcdFxcXFx0ZmxvYXQgZHkgPSAxLjAgLyBmbG9hdCggYm9uZVRleHR1cmVTaXplICk7XFxcXG5cXFxcdFxcXFx0XFxcXHR5ID0gZHkgKiAoIHkgKyAwLjUgKTtcXFxcblxcXFx0XFxcXHRcXFxcdHZlYzQgdjEgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDAuNSApLCB5ICkgKTtcXFxcblxcXFx0XFxcXHRcXFxcdHZlYzQgdjIgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDEuNSApLCB5ICkgKTtcXFxcblxcXFx0XFxcXHRcXFxcdHZlYzQgdjMgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDIuNSApLCB5ICkgKTtcXFxcblxcXFx0XFxcXHRcXFxcdHZlYzQgdjQgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDMuNSApLCB5ICkgKTtcXFxcblxcXFx0XFxcXHRcXFxcdG1hdDQgYm9uZSA9IG1hdDQoIHYxLCB2MiwgdjMsIHY0ICk7XFxcXG5cXFxcdFxcXFx0XFxcXHRyZXR1cm4gYm9uZTtcXFxcblxcXFx0XFxcXHR9XFxcXG5cXFxcdCNlbHNlXFxcXG5cXFxcdFxcXFx0dW5pZm9ybSBtYXQ0IGJvbmVNYXRyaWNlc1sgTUFYX0JPTkVTIF07XFxcXG5cXFxcdFxcXFx0bWF0NCBnZXRCb25lTWF0cml4KCBjb25zdCBpbiBmbG9hdCBpICkge1xcXFxuXFxcXHRcXFxcdFxcXFx0bWF0NCBib25lID0gYm9uZU1hdHJpY2VzWyBpbnQoaSkgXTtcXFxcblxcXFx0XFxcXHRcXFxcdHJldHVybiBib25lO1xcXFxuXFxcXHRcXFxcdH1cXFxcblxcXFx0I2VuZGlmXFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIHNraW5uaW5nX3ZlcnRleCA9IFxcXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxcXG5cXFxcdHZlYzQgc2tpblZlcnRleCA9IGJpbmRNYXRyaXggKiB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7XFxcXG5cXFxcdHZlYzQgc2tpbm5lZCA9IHZlYzQoIDAuMCApO1xcXFxuXFxcXHRza2lubmVkICs9IGJvbmVNYXRYICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueDtcXFxcblxcXFx0c2tpbm5lZCArPSBib25lTWF0WSAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnk7XFxcXG5cXFxcdHNraW5uZWQgKz0gYm9uZU1hdFogKiBza2luVmVydGV4ICogc2tpbldlaWdodC56O1xcXFxuXFxcXHRza2lubmVkICs9IGJvbmVNYXRXICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQudztcXFxcblxcXFx0dHJhbnNmb3JtZWQgPSAoIGJpbmRNYXRyaXhJbnZlcnNlICogc2tpbm5lZCApLnh5ejtcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgc2tpbm5vcm1hbF92ZXJ0ZXggPSBcXFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcXFxuXFxcXHRtYXQ0IHNraW5NYXRyaXggPSBtYXQ0KCAwLjAgKTtcXFxcblxcXFx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnggKiBib25lTWF0WDtcXFxcblxcXFx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnkgKiBib25lTWF0WTtcXFxcblxcXFx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnogKiBib25lTWF0WjtcXFxcblxcXFx0c2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LncgKiBib25lTWF0VztcXFxcblxcXFx0c2tpbk1hdHJpeCAgPSBiaW5kTWF0cml4SW52ZXJzZSAqIHNraW5NYXRyaXggKiBiaW5kTWF0cml4O1xcXFxuXFxcXHRvYmplY3ROb3JtYWwgPSB2ZWM0KCBza2luTWF0cml4ICogdmVjNCggb2JqZWN0Tm9ybWFsLCAwLjAgKSApLnh5ejtcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgc3BlY3VsYXJtYXBfZnJhZ21lbnQgPSBcXFwiZmxvYXQgc3BlY3VsYXJTdHJlbmd0aDtcXFxcbiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcXFxcblxcXFx0dmVjNCB0ZXhlbFNwZWN1bGFyID0gdGV4dHVyZTJEKCBzcGVjdWxhck1hcCwgdlV2ICk7XFxcXG5cXFxcdHNwZWN1bGFyU3RyZW5ndGggPSB0ZXhlbFNwZWN1bGFyLnI7XFxcXG4jZWxzZVxcXFxuXFxcXHRzcGVjdWxhclN0cmVuZ3RoID0gMS4wO1xcXFxuI2VuZGlmXFxcIjtcXG5cXG5cXHR2YXIgc3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudCA9IFxcXCIjaWZkZWYgVVNFX1NQRUNVTEFSTUFQXFxcXG5cXFxcdHVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFyTWFwO1xcXFxuI2VuZGlmXFxcIjtcXG5cXG5cXHR2YXIgdG9uZW1hcHBpbmdfZnJhZ21lbnQgPSBcXFwiI2lmIGRlZmluZWQoIFRPTkVfTUFQUElORyApXFxcXG4gIGdsX0ZyYWdDb2xvci5yZ2IgPSB0b25lTWFwcGluZyggZ2xfRnJhZ0NvbG9yLnJnYiApO1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciB0b25lbWFwcGluZ19wYXJzX2ZyYWdtZW50ID0gXFxcIiNpZm5kZWYgc2F0dXJhdGVcXFxcblxcXFx0I2RlZmluZSBzYXR1cmF0ZShhKSBjbGFtcCggYSwgMC4wLCAxLjAgKVxcXFxuI2VuZGlmXFxcXG51bmlmb3JtIGZsb2F0IHRvbmVNYXBwaW5nRXhwb3N1cmU7XFxcXG51bmlmb3JtIGZsb2F0IHRvbmVNYXBwaW5nV2hpdGVQb2ludDtcXFxcbnZlYzMgTGluZWFyVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7XFxcXG5cXFxcdHJldHVybiB0b25lTWFwcGluZ0V4cG9zdXJlICogY29sb3I7XFxcXG59XFxcXG52ZWMzIFJlaW5oYXJkVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7XFxcXG5cXFxcdGNvbG9yICo9IHRvbmVNYXBwaW5nRXhwb3N1cmU7XFxcXG5cXFxcdHJldHVybiBzYXR1cmF0ZSggY29sb3IgLyAoIHZlYzMoIDEuMCApICsgY29sb3IgKSApO1xcXFxufVxcXFxuI2RlZmluZSBVbmNoYXJ0ZWQySGVscGVyKCB4ICkgbWF4KCAoICggeCAqICggMC4xNSAqIHggKyAwLjEwICogMC41MCApICsgMC4yMCAqIDAuMDIgKSAvICggeCAqICggMC4xNSAqIHggKyAwLjUwICkgKyAwLjIwICogMC4zMCApICkgLSAwLjAyIC8gMC4zMCwgdmVjMyggMC4wICkgKVxcXFxudmVjMyBVbmNoYXJ0ZWQyVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7XFxcXG5cXFxcdGNvbG9yICo9IHRvbmVNYXBwaW5nRXhwb3N1cmU7XFxcXG5cXFxcdHJldHVybiBzYXR1cmF0ZSggVW5jaGFydGVkMkhlbHBlciggY29sb3IgKSAvIFVuY2hhcnRlZDJIZWxwZXIoIHZlYzMoIHRvbmVNYXBwaW5nV2hpdGVQb2ludCApICkgKTtcXFxcbn1cXFxcbnZlYzMgT3B0aW1pemVkQ2luZW9uVG9uZU1hcHBpbmcoIHZlYzMgY29sb3IgKSB7XFxcXG5cXFxcdGNvbG9yICo9IHRvbmVNYXBwaW5nRXhwb3N1cmU7XFxcXG5cXFxcdGNvbG9yID0gbWF4KCB2ZWMzKCAwLjAgKSwgY29sb3IgLSAwLjAwNCApO1xcXFxuXFxcXHRyZXR1cm4gcG93KCAoIGNvbG9yICogKCA2LjIgKiBjb2xvciArIDAuNSApICkgLyAoIGNvbG9yICogKCA2LjIgKiBjb2xvciArIDEuNyApICsgMC4wNiApLCB2ZWMzKCAyLjIgKSApO1xcXFxufVxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgdXZfcGFyc19mcmFnbWVudCA9IFxcXCIjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFVTRV9TUEVDVUxBUk1BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApIHx8IGRlZmluZWQoIFVTRV9FTUlTU0lWRU1BUCApIHx8IGRlZmluZWQoIFVTRV9ST1VHSE5FU1NNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTUVUQUxORVNTTUFQIClcXFxcblxcXFx0dmFyeWluZyB2ZWMyIHZVdjtcXFxcbiNlbmRpZlxcXCI7XFxuXFxuXFx0dmFyIHV2X3BhcnNfdmVydGV4ID0gXFxcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQICkgfHwgZGVmaW5lZCggVVNFX0VNSVNTSVZFTUFQICkgfHwgZGVmaW5lZCggVVNFX1JPVUdITkVTU01BUCApIHx8IGRlZmluZWQoIFVTRV9NRVRBTE5FU1NNQVAgKVxcXFxuXFxcXHR2YXJ5aW5nIHZlYzIgdlV2O1xcXFxuXFxcXHR1bmlmb3JtIG1hdDMgdXZUcmFuc2Zvcm07XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIHV2X3ZlcnRleCA9IFxcXCIjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFVTRV9TUEVDVUxBUk1BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApIHx8IGRlZmluZWQoIFVTRV9FTUlTU0lWRU1BUCApIHx8IGRlZmluZWQoIFVTRV9ST1VHSE5FU1NNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTUVUQUxORVNTTUFQIClcXFxcblxcXFx0dlV2ID0gKCB1dlRyYW5zZm9ybSAqIHZlYzMoIHV2LCAxICkgKS54eTtcXFxcbiNlbmRpZlxcXCI7XFxuXFxuXFx0dmFyIHV2Ml9wYXJzX2ZyYWdtZW50ID0gXFxcIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxcXFxuXFxcXHR2YXJ5aW5nIHZlYzIgdlV2MjtcXFxcbiNlbmRpZlxcXCI7XFxuXFxuXFx0dmFyIHV2Ml9wYXJzX3ZlcnRleCA9IFxcXCIjaWYgZGVmaW5lZCggVVNFX0xJR0hUTUFQICkgfHwgZGVmaW5lZCggVVNFX0FPTUFQIClcXFxcblxcXFx0YXR0cmlidXRlIHZlYzIgdXYyO1xcXFxuXFxcXHR2YXJ5aW5nIHZlYzIgdlV2MjtcXFxcbiNlbmRpZlxcXCI7XFxuXFxuXFx0dmFyIHV2Ml92ZXJ0ZXggPSBcXFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxcXG5cXFxcdHZVdjIgPSB1djI7XFxcXG4jZW5kaWZcXFwiO1xcblxcblxcdHZhciB3b3JsZHBvc192ZXJ0ZXggPSBcXFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSB8fCBkZWZpbmVkKCBESVNUQU5DRSApIHx8IGRlZmluZWQgKCBVU0VfU0hBRE9XTUFQIClcXFxcblxcXFx0dmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB2ZWM0KCB0cmFuc2Zvcm1lZCwgMS4wICk7XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIGN1YmVfZnJhZyA9IFxcXCJ1bmlmb3JtIHNhbXBsZXJDdWJlIHRDdWJlO1xcXFxudW5pZm9ybSBmbG9hdCB0RmxpcDtcXFxcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXFxcbnZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXFxcbnZvaWQgbWFpbigpIHtcXFxcblxcXFx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZUN1YmUoIHRDdWJlLCB2ZWMzKCB0RmxpcCAqIHZXb3JsZFBvc2l0aW9uLngsIHZXb3JsZFBvc2l0aW9uLnl6ICkgKTtcXFxcblxcXFx0Z2xfRnJhZ0NvbG9yLmEgKj0gb3BhY2l0eTtcXFxcbn1cXFxcblxcXCI7XFxuXFxuXFx0dmFyIGN1YmVfdmVydCA9IFxcXCJ2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxcXG4jaW5jbHVkZSA8Y29tbW9uPlxcXFxudm9pZCBtYWluKCkge1xcXFxuXFxcXHR2V29ybGRQb3NpdGlvbiA9IHRyYW5zZm9ybURpcmVjdGlvbiggcG9zaXRpb24sIG1vZGVsTWF0cml4ICk7XFxcXG5cXFxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXFxcblxcXFx0Z2xfUG9zaXRpb24ueiA9IGdsX1Bvc2l0aW9uLnc7XFxcXG59XFxcXG5cXFwiO1xcblxcblxcdHZhciBkZXB0aF9mcmFnID0gXFxcIiNpZiBERVBUSF9QQUNLSU5HID09IDMyMDBcXFxcblxcXFx0dW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcXFxuI2VuZGlmXFxcXG4jaW5jbHVkZSA8Y29tbW9uPlxcXFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxcXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxcXG52b2lkIG1haW4oKSB7XFxcXG5cXFxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxcXG5cXFxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggMS4wICk7XFxcXG5cXFxcdCNpZiBERVBUSF9QQUNLSU5HID09IDMyMDBcXFxcblxcXFx0XFxcXHRkaWZmdXNlQ29sb3IuYSA9IG9wYWNpdHk7XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXFxcblxcXFx0I2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMFxcXFxuXFxcXHRcXFxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIHZlYzMoIGdsX0ZyYWdDb29yZC56ICksIG9wYWNpdHkgKTtcXFxcblxcXFx0I2VsaWYgREVQVEhfUEFDS0lORyA9PSAzMjAxXFxcXG5cXFxcdFxcXFx0Z2xfRnJhZ0NvbG9yID0gcGFja0RlcHRoVG9SR0JBKCBnbF9GcmFnQ29vcmQueiApO1xcXFxuXFxcXHQjZW5kaWZcXFxcbn1cXFxcblxcXCI7XFxuXFxuXFx0dmFyIGRlcHRoX3ZlcnQgPSBcXFwiI2luY2x1ZGUgPGNvbW1vbj5cXFxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcXFxudm9pZCBtYWluKCkge1xcXFxuXFxcXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcXFxuXFxcXHQjaWZkZWYgVVNFX0RJU1BMQUNFTUVOVE1BUFxcXFxuXFxcXHRcXFxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxcXG5cXFxcdFxcXFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXFxcblxcXFx0XFxcXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXFxcbn1cXFxcblxcXCI7XFxuXFxuXFx0dmFyIGRpc3RhbmNlUkdCQV9mcmFnID0gXFxcIiNkZWZpbmUgRElTVEFOQ0VcXFxcbnVuaWZvcm0gdmVjMyByZWZlcmVuY2VQb3NpdGlvbjtcXFxcbnVuaWZvcm0gZmxvYXQgbmVhckRpc3RhbmNlO1xcXFxudW5pZm9ybSBmbG9hdCBmYXJEaXN0YW5jZTtcXFxcbnZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXFxcbiNpbmNsdWRlIDxjb21tb24+XFxcXG4jaW5jbHVkZSA8cGFja2luZz5cXFxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxcXG52b2lkIG1haW4gKCkge1xcXFxuXFxcXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcXFxuXFxcXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIDEuMCApO1xcXFxuXFxcXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxcXG5cXFxcdGZsb2F0IGRpc3QgPSBsZW5ndGgoIHZXb3JsZFBvc2l0aW9uIC0gcmVmZXJlbmNlUG9zaXRpb24gKTtcXFxcblxcXFx0ZGlzdCA9ICggZGlzdCAtIG5lYXJEaXN0YW5jZSApIC8gKCBmYXJEaXN0YW5jZSAtIG5lYXJEaXN0YW5jZSApO1xcXFxuXFxcXHRkaXN0ID0gc2F0dXJhdGUoIGRpc3QgKTtcXFxcblxcXFx0Z2xfRnJhZ0NvbG9yID0gcGFja0RlcHRoVG9SR0JBKCBkaXN0ICk7XFxcXG59XFxcXG5cXFwiO1xcblxcblxcdHZhciBkaXN0YW5jZVJHQkFfdmVydCA9IFxcXCIjZGVmaW5lIERJU1RBTkNFXFxcXG52YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxcXG4jaW5jbHVkZSA8Y29tbW9uPlxcXFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxcXG52b2lkIG1haW4oKSB7XFxcXG5cXFxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxcXG5cXFxcdCNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXFxcXG5cXFxcdFxcXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXFxcblxcXFx0XFxcXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcXFxuXFxcXHRcXFxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcXFxuXFxcXHR2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1xcXFxufVxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgZXF1aXJlY3RfZnJhZyA9IFxcXCJ1bmlmb3JtIHNhbXBsZXIyRCB0RXF1aXJlY3Q7XFxcXG52YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxcXG4jaW5jbHVkZSA8Y29tbW9uPlxcXFxudm9pZCBtYWluKCkge1xcXFxuXFxcXHR2ZWMzIGRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggdldvcmxkUG9zaXRpb24gKTtcXFxcblxcXFx0dmVjMiBzYW1wbGVVVjtcXFxcblxcXFx0c2FtcGxlVVYueSA9IGFzaW4oIGNsYW1wKCBkaXJlY3Rpb24ueSwgLSAxLjAsIDEuMCApICkgKiBSRUNJUFJPQ0FMX1BJICsgMC41O1xcXFxuXFxcXHRzYW1wbGVVVi54ID0gYXRhbiggZGlyZWN0aW9uLnosIGRpcmVjdGlvbi54ICkgKiBSRUNJUFJPQ0FMX1BJMiArIDAuNTtcXFxcblxcXFx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCB0RXF1aXJlY3QsIHNhbXBsZVVWICk7XFxcXG59XFxcXG5cXFwiO1xcblxcblxcdHZhciBlcXVpcmVjdF92ZXJ0ID0gXFxcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXFxcbiNpbmNsdWRlIDxjb21tb24+XFxcXG52b2lkIG1haW4oKSB7XFxcXG5cXFxcdHZXb3JsZFBvc2l0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBwb3NpdGlvbiwgbW9kZWxNYXRyaXggKTtcXFxcblxcXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcXFxufVxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgbGluZWRhc2hlZF9mcmFnID0gXFxcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcXFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcXFxudW5pZm9ybSBmbG9hdCBkYXNoU2l6ZTtcXFxcbnVuaWZvcm0gZmxvYXQgdG90YWxTaXplO1xcXFxudmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1xcXFxuI2luY2x1ZGUgPGNvbW1vbj5cXFxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxcXG52b2lkIG1haW4oKSB7XFxcXG5cXFxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxcXG5cXFxcdGlmICggbW9kKCB2TGluZURpc3RhbmNlLCB0b3RhbFNpemUgKSA+IGRhc2hTaXplICkge1xcXFxuXFxcXHRcXFxcdGRpc2NhcmQ7XFxcXG5cXFxcdH1cXFxcblxcXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XFxcXG5cXFxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcXFxuXFxcXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXFxcblxcXFx0b3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2I7XFxcXG5cXFxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XFxcXG5cXFxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxcXG59XFxcXG5cXFwiO1xcblxcblxcdHZhciBsaW5lZGFzaGVkX3ZlcnQgPSBcXFwidW5pZm9ybSBmbG9hdCBzY2FsZTtcXFxcbmF0dHJpYnV0ZSBmbG9hdCBsaW5lRGlzdGFuY2U7XFxcXG52YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7XFxcXG4jaW5jbHVkZSA8Y29tbW9uPlxcXFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxcXG52b2lkIG1haW4oKSB7XFxcXG5cXFxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxcXG5cXFxcdHZMaW5lRGlzdGFuY2UgPSBzY2FsZSAqIGxpbmVEaXN0YW5jZTtcXFxcblxcXFx0dmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcXFxuXFxcXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1xcXFxuXFxcXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxcXG59XFxcXG5cXFwiO1xcblxcblxcdHZhciBtZXNoYmFzaWNfZnJhZyA9IFxcXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcXFxcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXFxcbiNpZm5kZWYgRkxBVF9TSEFERURcXFxcblxcXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxcXG4jZW5kaWZcXFxcbiNpbmNsdWRlIDxjb21tb24+XFxcXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPHV2Ml9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXFxcbnZvaWQgbWFpbigpIHtcXFxcblxcXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXFxcblxcXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxcXG5cXFxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxzcGVjdWxhcm1hcF9mcmFnbWVudD5cXFxcblxcXFx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcXFxcblxcXFx0I2lmZGVmIFVTRV9MSUdIVE1BUFxcXFxuXFxcXHRcXFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2VXYyICkueHl6ICogbGlnaHRNYXBJbnRlbnNpdHk7XFxcXG5cXFxcdCNlbHNlXFxcXG5cXFxcdFxcXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IHZlYzMoIDEuMCApO1xcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcXFxuXFxcXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKj0gZGlmZnVzZUNvbG9yLnJnYjtcXFxcblxcXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlO1xcXFxuXFxcXHQjaW5jbHVkZSA8ZW52bWFwX2ZyYWdtZW50PlxcXFxuXFxcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1xcXFxuXFxcXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcXFxufVxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgbWVzaGJhc2ljX3ZlcnQgPSBcXFwiI2luY2x1ZGUgPGNvbW1vbj5cXFxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDx1djJfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxcXG52b2lkIG1haW4oKSB7XFxcXG5cXFxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDx1djJfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcXFxuXFxcXHQjaWZkZWYgVVNFX0VOVk1BUFxcXFxuXFxcXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxlbnZtYXBfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXFxcbn1cXFxcblxcXCI7XFxuXFxuXFx0dmFyIG1lc2hsYW1iZXJ0X2ZyYWcgPSBcXFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxcXG51bmlmb3JtIHZlYzMgZW1pc3NpdmU7XFxcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxcXG52YXJ5aW5nIHZlYzMgdkxpZ2h0RnJvbnQ7XFxcXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxcXG5cXFxcdHZhcnlpbmcgdmVjMyB2TGlnaHRCYWNrO1xcXFxuI2VuZGlmXFxcXG4jaW5jbHVkZSA8Y29tbW9uPlxcXFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxcXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPHV2Ml9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8YnNkZnM+XFxcXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnM+XFxcXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8c2hhZG93bWFza19wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXFxcbnZvaWQgbWFpbigpIHtcXFxcblxcXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXFxcblxcXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxcXG5cXFxcdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XFxcXG5cXFxcdHZlYzMgdG90YWxFbWlzc2l2ZVJhZGlhbmNlID0gZW1pc3NpdmU7XFxcXG5cXFxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxzcGVjdWxhcm1hcF9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGVtaXNzaXZlbWFwX2ZyYWdtZW50PlxcXFxuXFxcXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgPSBnZXRBbWJpZW50TGlnaHRJcnJhZGlhbmNlKCBhbWJpZW50TGlnaHRDb2xvciApO1xcXFxuXFxcXHQjaW5jbHVkZSA8bGlnaHRtYXBfZnJhZ21lbnQ+XFxcXG5cXFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSAqPSBCUkRGX0RpZmZ1c2VfTGFtYmVydCggZGlmZnVzZUNvbG9yLnJnYiApO1xcXFxuXFxcXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxcXG5cXFxcdFxcXFx0cmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSA9ICggZ2xfRnJvbnRGYWNpbmcgKSA/IHZMaWdodEZyb250IDogdkxpZ2h0QmFjaztcXFxcblxcXFx0I2Vsc2VcXFxcblxcXFx0XFxcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlID0gdkxpZ2h0RnJvbnQ7XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICo9IEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBkaWZmdXNlQ29sb3IucmdiICkgKiBnZXRTaGFkb3dNYXNrKCk7XFxcXG5cXFxcdCNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD5cXFxcblxcXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArIHRvdGFsRW1pc3NpdmVSYWRpYW5jZTtcXFxcblxcXFx0I2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD5cXFxcblxcXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcXFxcblxcXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD5cXFxcbn1cXFxcblxcXCI7XFxuXFxuXFx0dmFyIG1lc2hsYW1iZXJ0X3ZlcnQgPSBcXFwiI2RlZmluZSBMQU1CRVJUXFxcXG52YXJ5aW5nIHZlYzMgdkxpZ2h0RnJvbnQ7XFxcXG4jaWZkZWYgRE9VQkxFX1NJREVEXFxcXG5cXFxcdHZhcnlpbmcgdmVjMyB2TGlnaHRCYWNrO1xcXFxuI2VuZGlmXFxcXG4jaW5jbHVkZSA8Y29tbW9uPlxcXFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPHV2Ml9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8YnNkZnM+XFxcXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnM+XFxcXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxcXG52b2lkIG1haW4oKSB7XFxcXG5cXFxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDx1djJfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGVudm1hcF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxsaWdodHNfbGFtYmVydF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXFxcbn1cXFxcblxcXCI7XFxuXFxuXFx0dmFyIG1lc2hwaG9uZ19mcmFnID0gXFxcIiNkZWZpbmUgUEhPTkdcXFxcbnVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcXFxudW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1xcXFxudW5pZm9ybSB2ZWMzIHNwZWN1bGFyO1xcXFxudW5pZm9ybSBmbG9hdCBzaGluaW5lc3M7XFxcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxcXG4jaW5jbHVkZSA8Y29tbW9uPlxcXFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxcXG4jaW5jbHVkZSA8ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPHV2Ml9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8YW9tYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxsaWdodG1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGVtaXNzaXZlbWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8Z3JhZGllbnRtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxic2Rmcz5cXFxcbiNpbmNsdWRlIDxsaWdodHNfcGFycz5cXFxcbiNpbmNsdWRlIDxsaWdodHNfcGhvbmdfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcXFxudm9pZCBtYWluKCkge1xcXFxuXFxcXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcXFxuXFxcXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXFxcblxcXFx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcXFxcblxcXFx0dmVjMyB0b3RhbEVtaXNzaXZlUmFkaWFuY2UgPSBlbWlzc2l2ZTtcXFxcblxcXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPHNwZWN1bGFybWFwX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8ZW1pc3NpdmVtYXBfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxsaWdodHNfcGhvbmdfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxsaWdodHNfdGVtcGxhdGU+XFxcXG5cXFxcdCNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD5cXFxcblxcXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciArIHRvdGFsRW1pc3NpdmVSYWRpYW5jZTtcXFxcblxcXFx0I2luY2x1ZGUgPGVudm1hcF9mcmFnbWVudD5cXFxcblxcXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcXFxcblxcXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD5cXFxcbn1cXFxcblxcXCI7XFxuXFxuXFx0dmFyIG1lc2hwaG9uZ192ZXJ0ID0gXFxcIiNkZWZpbmUgUEhPTkdcXFxcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcXFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcXFxuXFxcXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXFxcbiNlbmRpZlxcXFxuI2luY2x1ZGUgPGNvbW1vbj5cXFxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDx1djJfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXFxcbnZvaWQgbWFpbigpIHtcXFxcblxcXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHV2Ml92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcXFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcXFxuXFxcXHR2Tm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xcXFxuI2VuZGlmXFxcXG5cXFxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcXFxuXFxcXHR2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcXFxcblxcXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGVudm1hcF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXFxcbn1cXFxcblxcXCI7XFxuXFxuXFx0dmFyIG1lc2hwaHlzaWNhbF9mcmFnID0gXFxcIiNkZWZpbmUgUEhZU0lDQUxcXFxcbnVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcXFxudW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1xcXFxudW5pZm9ybSBmbG9hdCByb3VnaG5lc3M7XFxcXG51bmlmb3JtIGZsb2F0IG1ldGFsbmVzcztcXFxcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXFxcbiNpZm5kZWYgU1RBTkRBUkRcXFxcblxcXFx0dW5pZm9ybSBmbG9hdCBjbGVhckNvYXQ7XFxcXG5cXFxcdHVuaWZvcm0gZmxvYXQgY2xlYXJDb2F0Um91Z2huZXNzO1xcXFxuI2VuZGlmXFxcXG52YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXFxcbiNpZm5kZWYgRkxBVF9TSEFERURcXFxcblxcXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxcXG4jZW5kaWZcXFxcbiNpbmNsdWRlIDxjb21tb24+XFxcXG4jaW5jbHVkZSA8cGFja2luZz5cXFxcbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8dXYyX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxic2Rmcz5cXFxcbiNpbmNsdWRlIDxjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8bGlnaHRzX3BhcnM+XFxcXG4jaW5jbHVkZSA8bGlnaHRzX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPHJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPG1ldGFsbmVzc21hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxcXG52b2lkIG1haW4oKSB7XFxcXG5cXFxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxcXG5cXFxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcXFxuXFxcXHRSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApO1xcXFxuXFxcXHR2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlO1xcXFxuXFxcXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8cm91Z2huZXNzbWFwX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8bWV0YWxuZXNzbWFwX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8ZW1pc3NpdmVtYXBfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxsaWdodHNfcGh5c2ljYWxfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxsaWdodHNfdGVtcGxhdGU+XFxcXG5cXFxcdCNpbmNsdWRlIDxhb21hcF9mcmFnbWVudD5cXFxcblxcXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gcmVmbGVjdGVkTGlnaHQuZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArIHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciArIHRvdGFsRW1pc3NpdmVSYWRpYW5jZTtcXFxcblxcXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcXFxcblxcXFx0I2luY2x1ZGUgPHRvbmVtYXBwaW5nX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8ZW5jb2RpbmdzX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGRpdGhlcmluZ19mcmFnbWVudD5cXFxcbn1cXFxcblxcXCI7XFxuXFxuXFx0dmFyIG1lc2hwaHlzaWNhbF92ZXJ0ID0gXFxcIiNkZWZpbmUgUEhZU0lDQUxcXFxcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcXFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcXFxuXFxcXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXFxcbiNlbmRpZlxcXFxuI2luY2x1ZGUgPGNvbW1vbj5cXFxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDx1djJfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcXFxudm9pZCBtYWluKCkge1xcXFxuXFxcXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8dXYyX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxcXG5cXFxcdHZOb3JtYWwgPSBub3JtYWxpemUoIHRyYW5zZm9ybWVkTm9ybWFsICk7XFxcXG4jZW5kaWZcXFxcblxcXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxcXG5cXFxcdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1xcXFxuXFxcXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxcXG59XFxcXG5cXFwiO1xcblxcblxcdHZhciBub3JtYWxfZnJhZyA9IFxcXCIjZGVmaW5lIE5PUk1BTFxcXFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcXFxuI2lmIGRlZmluZWQoIEZMQVRfU0hBREVEICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQIClcXFxcblxcXFx0dmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxcXG4jZW5kaWZcXFxcbiNpZm5kZWYgRkxBVF9TSEFERURcXFxcblxcXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxcXG4jZW5kaWZcXFxcbiNpbmNsdWRlIDxwYWNraW5nPlxcXFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8YnVtcG1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxcXG52b2lkIG1haW4oKSB7XFxcXG5cXFxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPG5vcm1hbF9mcmFnbWVudD5cXFxcblxcXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggcGFja05vcm1hbFRvUkdCKCBub3JtYWwgKSwgb3BhY2l0eSApO1xcXFxufVxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgbm9ybWFsX3ZlcnQgPSBcXFwiI2RlZmluZSBOT1JNQUxcXFxcbiNpZiBkZWZpbmVkKCBGTEFUX1NIQURFRCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApXFxcXG5cXFxcdHZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcXFxuI2VuZGlmXFxcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxcXG5cXFxcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcXFxuI2VuZGlmXFxcXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcXFxudm9pZCBtYWluKCkge1xcXFxuXFxcXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXFxcbiNpZm5kZWYgRkxBVF9TSEFERURcXFxcblxcXFx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcXFxcbiNlbmRpZlxcXFxuXFxcXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcXFxuI2lmIGRlZmluZWQoIEZMQVRfU0hBREVEICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQIClcXFxcblxcXFx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XFxcXG4jZW5kaWZcXFxcbn1cXFxcblxcXCI7XFxuXFxuXFx0dmFyIHBvaW50c19mcmFnID0gXFxcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcXFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcXFxuI2luY2x1ZGUgPGNvbW1vbj5cXFxcbiNpbmNsdWRlIDxwYWNraW5nPlxcXFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8bWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXFxcbnZvaWQgbWFpbigpIHtcXFxcblxcXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXFxcblxcXFx0dmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XFxcXG5cXFxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcXFxuXFxcXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxtYXBfcGFydGljbGVfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXFxcblxcXFx0b3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2I7XFxcXG5cXFxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XFxcXG5cXFxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxcXG59XFxcXG5cXFwiO1xcblxcblxcdHZhciBwb2ludHNfdmVydCA9IFxcXCJ1bmlmb3JtIGZsb2F0IHNpemU7XFxcXG51bmlmb3JtIGZsb2F0IHNjYWxlO1xcXFxuI2luY2x1ZGUgPGNvbW1vbj5cXFxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXFxcbnZvaWQgbWFpbigpIHtcXFxcblxcXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcXFxuXFxcXHQjaWZkZWYgVVNFX1NJWkVBVFRFTlVBVElPTlxcXFxuXFxcXHRcXFxcdGdsX1BvaW50U2l6ZSA9IHNpemUgKiAoIHNjYWxlIC8gLSBtdlBvc2l0aW9uLnogKTtcXFxcblxcXFx0I2Vsc2VcXFxcblxcXFx0XFxcXHRnbF9Qb2ludFNpemUgPSBzaXplO1xcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXFxcbn1cXFxcblxcXCI7XFxuXFxuXFx0dmFyIHNoYWRvd19mcmFnID0gXFxcInVuaWZvcm0gdmVjMyBjb2xvcjtcXFxcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXFxcbiNpbmNsdWRlIDxjb21tb24+XFxcXG4jaW5jbHVkZSA8cGFja2luZz5cXFxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxic2Rmcz5cXFxcbiNpbmNsdWRlIDxsaWdodHNfcGFycz5cXFxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQ+XFxcXG52b2lkIG1haW4oKSB7XFxcXG5cXFxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yLCBvcGFjaXR5ICogKCAxLjAgLSBnZXRTaGFkb3dNYXNrKCkgKSApO1xcXFxuXFxcXHQjaW5jbHVkZSA8Zm9nX2ZyYWdtZW50PlxcXFxufVxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgc2hhZG93X3ZlcnQgPSBcXFwiI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XFxcXG52b2lkIG1haW4oKSB7XFxcXG5cXFxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxmb2dfdmVydGV4PlxcXFxufVxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgU2hhZGVyQ2h1bmsgPSB7XFxuXFx0XFx0YWxwaGFtYXBfZnJhZ21lbnQ6IGFscGhhbWFwX2ZyYWdtZW50LFxcblxcdFxcdGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ6IGFscGhhbWFwX3BhcnNfZnJhZ21lbnQsXFxuXFx0XFx0YWxwaGF0ZXN0X2ZyYWdtZW50OiBhbHBoYXRlc3RfZnJhZ21lbnQsXFxuXFx0XFx0YW9tYXBfZnJhZ21lbnQ6IGFvbWFwX2ZyYWdtZW50LFxcblxcdFxcdGFvbWFwX3BhcnNfZnJhZ21lbnQ6IGFvbWFwX3BhcnNfZnJhZ21lbnQsXFxuXFx0XFx0YmVnaW5fdmVydGV4OiBiZWdpbl92ZXJ0ZXgsXFxuXFx0XFx0YmVnaW5ub3JtYWxfdmVydGV4OiBiZWdpbm5vcm1hbF92ZXJ0ZXgsXFxuXFx0XFx0YnNkZnM6IGJzZGZzLFxcblxcdFxcdGJ1bXBtYXBfcGFyc19mcmFnbWVudDogYnVtcG1hcF9wYXJzX2ZyYWdtZW50LFxcblxcdFxcdGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudDogY2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50LFxcblxcdFxcdGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50OiBjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudCxcXG5cXHRcXHRjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg6IGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleCxcXG5cXHRcXHRjbGlwcGluZ19wbGFuZXNfdmVydGV4OiBjbGlwcGluZ19wbGFuZXNfdmVydGV4LFxcblxcdFxcdGNvbG9yX2ZyYWdtZW50OiBjb2xvcl9mcmFnbWVudCxcXG5cXHRcXHRjb2xvcl9wYXJzX2ZyYWdtZW50OiBjb2xvcl9wYXJzX2ZyYWdtZW50LFxcblxcdFxcdGNvbG9yX3BhcnNfdmVydGV4OiBjb2xvcl9wYXJzX3ZlcnRleCxcXG5cXHRcXHRjb2xvcl92ZXJ0ZXg6IGNvbG9yX3ZlcnRleCxcXG5cXHRcXHRjb21tb246IGNvbW1vbixcXG5cXHRcXHRjdWJlX3V2X3JlZmxlY3Rpb25fZnJhZ21lbnQ6IGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudCxcXG5cXHRcXHRkZWZhdWx0bm9ybWFsX3ZlcnRleDogZGVmYXVsdG5vcm1hbF92ZXJ0ZXgsXFxuXFx0XFx0ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4OiBkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXgsXFxuXFx0XFx0ZGlzcGxhY2VtZW50bWFwX3ZlcnRleDogZGlzcGxhY2VtZW50bWFwX3ZlcnRleCxcXG5cXHRcXHRlbWlzc2l2ZW1hcF9mcmFnbWVudDogZW1pc3NpdmVtYXBfZnJhZ21lbnQsXFxuXFx0XFx0ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudDogZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudCxcXG5cXHRcXHRlbmNvZGluZ3NfZnJhZ21lbnQ6IGVuY29kaW5nc19mcmFnbWVudCxcXG5cXHRcXHRlbmNvZGluZ3NfcGFyc19mcmFnbWVudDogZW5jb2RpbmdzX3BhcnNfZnJhZ21lbnQsXFxuXFx0XFx0ZW52bWFwX2ZyYWdtZW50OiBlbnZtYXBfZnJhZ21lbnQsXFxuXFx0XFx0ZW52bWFwX3BhcnNfZnJhZ21lbnQ6IGVudm1hcF9wYXJzX2ZyYWdtZW50LFxcblxcdFxcdGVudm1hcF9wYXJzX3ZlcnRleDogZW52bWFwX3BhcnNfdmVydGV4LFxcblxcdFxcdGVudm1hcF92ZXJ0ZXg6IGVudm1hcF92ZXJ0ZXgsXFxuXFx0XFx0Zm9nX3ZlcnRleDogZm9nX3ZlcnRleCxcXG5cXHRcXHRmb2dfcGFyc192ZXJ0ZXg6IGZvZ19wYXJzX3ZlcnRleCxcXG5cXHRcXHRmb2dfZnJhZ21lbnQ6IGZvZ19mcmFnbWVudCxcXG5cXHRcXHRmb2dfcGFyc19mcmFnbWVudDogZm9nX3BhcnNfZnJhZ21lbnQsXFxuXFx0XFx0Z3JhZGllbnRtYXBfcGFyc19mcmFnbWVudDogZ3JhZGllbnRtYXBfcGFyc19mcmFnbWVudCxcXG5cXHRcXHRsaWdodG1hcF9mcmFnbWVudDogbGlnaHRtYXBfZnJhZ21lbnQsXFxuXFx0XFx0bGlnaHRtYXBfcGFyc19mcmFnbWVudDogbGlnaHRtYXBfcGFyc19mcmFnbWVudCxcXG5cXHRcXHRsaWdodHNfbGFtYmVydF92ZXJ0ZXg6IGxpZ2h0c19sYW1iZXJ0X3ZlcnRleCxcXG5cXHRcXHRsaWdodHNfcGFyczogbGlnaHRzX3BhcnMsXFxuXFx0XFx0bGlnaHRzX3Bob25nX2ZyYWdtZW50OiBsaWdodHNfcGhvbmdfZnJhZ21lbnQsXFxuXFx0XFx0bGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQ6IGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50LFxcblxcdFxcdGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudDogbGlnaHRzX3BoeXNpY2FsX2ZyYWdtZW50LFxcblxcdFxcdGxpZ2h0c19waHlzaWNhbF9wYXJzX2ZyYWdtZW50OiBsaWdodHNfcGh5c2ljYWxfcGFyc19mcmFnbWVudCxcXG5cXHRcXHRsaWdodHNfdGVtcGxhdGU6IGxpZ2h0c190ZW1wbGF0ZSxcXG5cXHRcXHRsb2dkZXB0aGJ1Zl9mcmFnbWVudDogbG9nZGVwdGhidWZfZnJhZ21lbnQsXFxuXFx0XFx0bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudDogbG9nZGVwdGhidWZfcGFyc19mcmFnbWVudCxcXG5cXHRcXHRsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleDogbG9nZGVwdGhidWZfcGFyc192ZXJ0ZXgsXFxuXFx0XFx0bG9nZGVwdGhidWZfdmVydGV4OiBsb2dkZXB0aGJ1Zl92ZXJ0ZXgsXFxuXFx0XFx0bWFwX2ZyYWdtZW50OiBtYXBfZnJhZ21lbnQsXFxuXFx0XFx0bWFwX3BhcnNfZnJhZ21lbnQ6IG1hcF9wYXJzX2ZyYWdtZW50LFxcblxcdFxcdG1hcF9wYXJ0aWNsZV9mcmFnbWVudDogbWFwX3BhcnRpY2xlX2ZyYWdtZW50LFxcblxcdFxcdG1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50OiBtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudCxcXG5cXHRcXHRtZXRhbG5lc3NtYXBfZnJhZ21lbnQ6IG1ldGFsbmVzc21hcF9mcmFnbWVudCxcXG5cXHRcXHRtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudDogbWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQsXFxuXFx0XFx0bW9ycGhub3JtYWxfdmVydGV4OiBtb3JwaG5vcm1hbF92ZXJ0ZXgsXFxuXFx0XFx0bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg6IG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4LFxcblxcdFxcdG1vcnBodGFyZ2V0X3ZlcnRleDogbW9ycGh0YXJnZXRfdmVydGV4LFxcblxcdFxcdG5vcm1hbF9mcmFnbWVudDogbm9ybWFsX2ZyYWdtZW50LFxcblxcdFxcdG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50OiBub3JtYWxtYXBfcGFyc19mcmFnbWVudCxcXG5cXHRcXHRwYWNraW5nOiBwYWNraW5nLFxcblxcdFxcdHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ6IHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQsXFxuXFx0XFx0cHJvamVjdF92ZXJ0ZXg6IHByb2plY3RfdmVydGV4LFxcblxcdFxcdGRpdGhlcmluZ19mcmFnbWVudDogZGl0aGVyaW5nX2ZyYWdtZW50LFxcblxcdFxcdGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50OiBkaXRoZXJpbmdfcGFyc19mcmFnbWVudCxcXG5cXHRcXHRyb3VnaG5lc3NtYXBfZnJhZ21lbnQ6IHJvdWdobmVzc21hcF9mcmFnbWVudCxcXG5cXHRcXHRyb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudDogcm91Z2huZXNzbWFwX3BhcnNfZnJhZ21lbnQsXFxuXFx0XFx0c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ6IHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50LFxcblxcdFxcdHNoYWRvd21hcF9wYXJzX3ZlcnRleDogc2hhZG93bWFwX3BhcnNfdmVydGV4LFxcblxcdFxcdHNoYWRvd21hcF92ZXJ0ZXg6IHNoYWRvd21hcF92ZXJ0ZXgsXFxuXFx0XFx0c2hhZG93bWFza19wYXJzX2ZyYWdtZW50OiBzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQsXFxuXFx0XFx0c2tpbmJhc2VfdmVydGV4OiBza2luYmFzZV92ZXJ0ZXgsXFxuXFx0XFx0c2tpbm5pbmdfcGFyc192ZXJ0ZXg6IHNraW5uaW5nX3BhcnNfdmVydGV4LFxcblxcdFxcdHNraW5uaW5nX3ZlcnRleDogc2tpbm5pbmdfdmVydGV4LFxcblxcdFxcdHNraW5ub3JtYWxfdmVydGV4OiBza2lubm9ybWFsX3ZlcnRleCxcXG5cXHRcXHRzcGVjdWxhcm1hcF9mcmFnbWVudDogc3BlY3VsYXJtYXBfZnJhZ21lbnQsXFxuXFx0XFx0c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudDogc3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudCxcXG5cXHRcXHR0b25lbWFwcGluZ19mcmFnbWVudDogdG9uZW1hcHBpbmdfZnJhZ21lbnQsXFxuXFx0XFx0dG9uZW1hcHBpbmdfcGFyc19mcmFnbWVudDogdG9uZW1hcHBpbmdfcGFyc19mcmFnbWVudCxcXG5cXHRcXHR1dl9wYXJzX2ZyYWdtZW50OiB1dl9wYXJzX2ZyYWdtZW50LFxcblxcdFxcdHV2X3BhcnNfdmVydGV4OiB1dl9wYXJzX3ZlcnRleCxcXG5cXHRcXHR1dl92ZXJ0ZXg6IHV2X3ZlcnRleCxcXG5cXHRcXHR1djJfcGFyc19mcmFnbWVudDogdXYyX3BhcnNfZnJhZ21lbnQsXFxuXFx0XFx0dXYyX3BhcnNfdmVydGV4OiB1djJfcGFyc192ZXJ0ZXgsXFxuXFx0XFx0dXYyX3ZlcnRleDogdXYyX3ZlcnRleCxcXG5cXHRcXHR3b3JsZHBvc192ZXJ0ZXg6IHdvcmxkcG9zX3ZlcnRleCxcXG5cXG5cXHRcXHRjdWJlX2ZyYWc6IGN1YmVfZnJhZyxcXG5cXHRcXHRjdWJlX3ZlcnQ6IGN1YmVfdmVydCxcXG5cXHRcXHRkZXB0aF9mcmFnOiBkZXB0aF9mcmFnLFxcblxcdFxcdGRlcHRoX3ZlcnQ6IGRlcHRoX3ZlcnQsXFxuXFx0XFx0ZGlzdGFuY2VSR0JBX2ZyYWc6IGRpc3RhbmNlUkdCQV9mcmFnLFxcblxcdFxcdGRpc3RhbmNlUkdCQV92ZXJ0OiBkaXN0YW5jZVJHQkFfdmVydCxcXG5cXHRcXHRlcXVpcmVjdF9mcmFnOiBlcXVpcmVjdF9mcmFnLFxcblxcdFxcdGVxdWlyZWN0X3ZlcnQ6IGVxdWlyZWN0X3ZlcnQsXFxuXFx0XFx0bGluZWRhc2hlZF9mcmFnOiBsaW5lZGFzaGVkX2ZyYWcsXFxuXFx0XFx0bGluZWRhc2hlZF92ZXJ0OiBsaW5lZGFzaGVkX3ZlcnQsXFxuXFx0XFx0bWVzaGJhc2ljX2ZyYWc6IG1lc2hiYXNpY19mcmFnLFxcblxcdFxcdG1lc2hiYXNpY192ZXJ0OiBtZXNoYmFzaWNfdmVydCxcXG5cXHRcXHRtZXNobGFtYmVydF9mcmFnOiBtZXNobGFtYmVydF9mcmFnLFxcblxcdFxcdG1lc2hsYW1iZXJ0X3ZlcnQ6IG1lc2hsYW1iZXJ0X3ZlcnQsXFxuXFx0XFx0bWVzaHBob25nX2ZyYWc6IG1lc2hwaG9uZ19mcmFnLFxcblxcdFxcdG1lc2hwaG9uZ192ZXJ0OiBtZXNocGhvbmdfdmVydCxcXG5cXHRcXHRtZXNocGh5c2ljYWxfZnJhZzogbWVzaHBoeXNpY2FsX2ZyYWcsXFxuXFx0XFx0bWVzaHBoeXNpY2FsX3ZlcnQ6IG1lc2hwaHlzaWNhbF92ZXJ0LFxcblxcdFxcdG5vcm1hbF9mcmFnOiBub3JtYWxfZnJhZyxcXG5cXHRcXHRub3JtYWxfdmVydDogbm9ybWFsX3ZlcnQsXFxuXFx0XFx0cG9pbnRzX2ZyYWc6IHBvaW50c19mcmFnLFxcblxcdFxcdHBvaW50c192ZXJ0OiBwb2ludHNfdmVydCxcXG5cXHRcXHRzaGFkb3dfZnJhZzogc2hhZG93X2ZyYWcsXFxuXFx0XFx0c2hhZG93X3ZlcnQ6IHNoYWRvd192ZXJ0XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cXG5cXHQgKi9cXG5cXG5cXHR2YXIgU2hhZGVyTGliID0ge1xcblxcblxcdFxcdGJhc2ljOiB7XFxuXFxuXFx0XFx0XFx0dW5pZm9ybXM6IFVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5jb21tb24sXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuc3BlY3VsYXJtYXAsXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuZW52bWFwLFxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmFvbWFwLFxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmxpZ2h0bWFwLFxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmZvZ1xcblxcdFxcdFxcdF0gKSxcXG5cXG5cXHRcXHRcXHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hiYXNpY192ZXJ0LFxcblxcdFxcdFxcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNoYmFzaWNfZnJhZ1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bGFtYmVydDoge1xcblxcblxcdFxcdFxcdHVuaWZvcm1zOiBVbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuY29tbW9uLFxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLnNwZWN1bGFybWFwLFxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmVudm1hcCxcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5hb21hcCxcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5saWdodG1hcCxcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5lbWlzc2l2ZW1hcCxcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5mb2csXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIubGlnaHRzLFxcblxcdFxcdFxcdFxcdHtcXG5cXHRcXHRcXHRcXHRcXHRlbWlzc2l2ZTogeyB2YWx1ZTogbmV3IENvbG9yKCAweDAwMDAwMCApIH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XSApLFxcblxcblxcdFxcdFxcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaGxhbWJlcnRfdmVydCxcXG5cXHRcXHRcXHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaGxhbWJlcnRfZnJhZ1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cGhvbmc6IHtcXG5cXG5cXHRcXHRcXHR1bmlmb3JtczogVW5pZm9ybXNVdGlscy5tZXJnZSggW1xcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmNvbW1vbixcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5zcGVjdWxhcm1hcCxcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5lbnZtYXAsXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuYW9tYXAsXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIubGlnaHRtYXAsXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuZW1pc3NpdmVtYXAsXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuYnVtcG1hcCxcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5ub3JtYWxtYXAsXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuZGlzcGxhY2VtZW50bWFwLFxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmdyYWRpZW50bWFwLFxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmZvZyxcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5saWdodHMsXFxuXFx0XFx0XFx0XFx0e1xcblxcdFxcdFxcdFxcdFxcdGVtaXNzaXZlOiB7IHZhbHVlOiBuZXcgQ29sb3IoIDB4MDAwMDAwICkgfSxcXG5cXHRcXHRcXHRcXHRcXHRzcGVjdWxhcjogeyB2YWx1ZTogbmV3IENvbG9yKCAweDExMTExMSApIH0sXFxuXFx0XFx0XFx0XFx0XFx0c2hpbmluZXNzOiB7IHZhbHVlOiAzMCB9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdF0gKSxcXG5cXG5cXHRcXHRcXHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaG9uZ192ZXJ0LFxcblxcdFxcdFxcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNocGhvbmdfZnJhZ1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c3RhbmRhcmQ6IHtcXG5cXG5cXHRcXHRcXHR1bmlmb3JtczogVW5pZm9ybXNVdGlscy5tZXJnZSggW1xcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmNvbW1vbixcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5lbnZtYXAsXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuYW9tYXAsXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIubGlnaHRtYXAsXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuZW1pc3NpdmVtYXAsXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuYnVtcG1hcCxcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5ub3JtYWxtYXAsXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuZGlzcGxhY2VtZW50bWFwLFxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLnJvdWdobmVzc21hcCxcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5tZXRhbG5lc3NtYXAsXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuZm9nLFxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmxpZ2h0cyxcXG5cXHRcXHRcXHRcXHR7XFxuXFx0XFx0XFx0XFx0XFx0ZW1pc3NpdmU6IHsgdmFsdWU6IG5ldyBDb2xvciggMHgwMDAwMDAgKSB9LFxcblxcdFxcdFxcdFxcdFxcdHJvdWdobmVzczogeyB2YWx1ZTogMC41IH0sXFxuXFx0XFx0XFx0XFx0XFx0bWV0YWxuZXNzOiB7IHZhbHVlOiAwLjUgfSxcXG5cXHRcXHRcXHRcXHRcXHRlbnZNYXBJbnRlbnNpdHk6IHsgdmFsdWU6IDEgfSAvLyB0ZW1wb3JhcnlcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XSApLFxcblxcblxcdFxcdFxcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBoeXNpY2FsX3ZlcnQsXFxuXFx0XFx0XFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaHlzaWNhbF9mcmFnXFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRwb2ludHM6IHtcXG5cXG5cXHRcXHRcXHR1bmlmb3JtczogVW5pZm9ybXNVdGlscy5tZXJnZSggW1xcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLnBvaW50cyxcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5mb2dcXG5cXHRcXHRcXHRdICksXFxuXFxuXFx0XFx0XFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5wb2ludHNfdmVydCxcXG5cXHRcXHRcXHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsucG9pbnRzX2ZyYWdcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGRhc2hlZDoge1xcblxcblxcdFxcdFxcdHVuaWZvcm1zOiBVbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuY29tbW9uLFxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmZvZyxcXG5cXHRcXHRcXHRcXHR7XFxuXFx0XFx0XFx0XFx0XFx0c2NhbGU6IHsgdmFsdWU6IDEgfSxcXG5cXHRcXHRcXHRcXHRcXHRkYXNoU2l6ZTogeyB2YWx1ZTogMSB9LFxcblxcdFxcdFxcdFxcdFxcdHRvdGFsU2l6ZTogeyB2YWx1ZTogMiB9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdF0gKSxcXG5cXG5cXHRcXHRcXHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLmxpbmVkYXNoZWRfdmVydCxcXG5cXHRcXHRcXHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubGluZWRhc2hlZF9mcmFnXFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkZXB0aDoge1xcblxcblxcdFxcdFxcdHVuaWZvcm1zOiBVbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuY29tbW9uLFxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmRpc3BsYWNlbWVudG1hcFxcblxcdFxcdFxcdF0gKSxcXG5cXG5cXHRcXHRcXHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLmRlcHRoX3ZlcnQsXFxuXFx0XFx0XFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmRlcHRoX2ZyYWdcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG5vcm1hbDoge1xcblxcblxcdFxcdFxcdHVuaWZvcm1zOiBVbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuY29tbW9uLFxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmJ1bXBtYXAsXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIubm9ybWFsbWFwLFxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmRpc3BsYWNlbWVudG1hcCxcXG5cXHRcXHRcXHRcXHR7XFxuXFx0XFx0XFx0XFx0XFx0b3BhY2l0eTogeyB2YWx1ZTogMS4wIH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XSApLFxcblxcblxcdFxcdFxcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubm9ybWFsX3ZlcnQsXFxuXFx0XFx0XFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm5vcm1hbF9mcmFnXFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFx0XFx0Ly9cXHRDdWJlIG1hcCBzaGFkZXJcXG5cXHRcXHQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xcblxcblxcdFxcdGN1YmU6IHtcXG5cXG5cXHRcXHRcXHR1bmlmb3Jtczoge1xcblxcdFxcdFxcdFxcdHRDdWJlOiB7IHZhbHVlOiBudWxsIH0sXFxuXFx0XFx0XFx0XFx0dEZsaXA6IHsgdmFsdWU6IC0gMSB9LFxcblxcdFxcdFxcdFxcdG9wYWNpdHk6IHsgdmFsdWU6IDEuMCB9XFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLmN1YmVfdmVydCxcXG5cXHRcXHRcXHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsuY3ViZV9mcmFnXFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRlcXVpcmVjdDoge1xcblxcblxcdFxcdFxcdHVuaWZvcm1zOiB7XFxuXFx0XFx0XFx0XFx0dEVxdWlyZWN0OiB7IHZhbHVlOiBudWxsIH0sXFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLmVxdWlyZWN0X3ZlcnQsXFxuXFx0XFx0XFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmVxdWlyZWN0X2ZyYWdcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGRpc3RhbmNlUkdCQToge1xcblxcblxcdFxcdFxcdHVuaWZvcm1zOiBVbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuY29tbW9uLFxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmRpc3BsYWNlbWVudG1hcCxcXG5cXHRcXHRcXHRcXHR7XFxuXFx0XFx0XFx0XFx0XFx0cmVmZXJlbmNlUG9zaXRpb246IHsgdmFsdWU6IG5ldyBWZWN0b3IzKCkgfSxcXG5cXHRcXHRcXHRcXHRcXHRuZWFyRGlzdGFuY2U6IHsgdmFsdWU6IDEgfSxcXG5cXHRcXHRcXHRcXHRcXHRmYXJEaXN0YW5jZTogeyB2YWx1ZTogMTAwMCB9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdF0gKSxcXG5cXG5cXHRcXHRcXHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLmRpc3RhbmNlUkdCQV92ZXJ0LFxcblxcdFxcdFxcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5kaXN0YW5jZVJHQkFfZnJhZ1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2hhZG93OiB7XFxuXFxuXFx0XFx0XFx0dW5pZm9ybXM6IFVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5saWdodHMsXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuZm9nLFxcblxcdFxcdFxcdFxcdHtcXG5cXHRcXHRcXHRcXHRcXHRjb2xvcjogeyB2YWx1ZTogbmV3IENvbG9yKCAweDAwMDAwICkgfSxcXG5cXHRcXHRcXHRcXHRcXHRvcGFjaXR5OiB7IHZhbHVlOiAxLjAgfVxcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XSApLFxcblxcblxcdFxcdFxcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsuc2hhZG93X3ZlcnQsXFxuXFx0XFx0XFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLnNoYWRvd19mcmFnXFxuXFxuXFx0XFx0fVxcblxcblxcdH07XFxuXFxuXFx0U2hhZGVyTGliLnBoeXNpY2FsID0ge1xcblxcblxcdFxcdHVuaWZvcm1zOiBVbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXFxuXFx0XFx0XFx0U2hhZGVyTGliLnN0YW5kYXJkLnVuaWZvcm1zLFxcblxcdFxcdFxcdHtcXG5cXHRcXHRcXHRcXHRjbGVhckNvYXQ6IHsgdmFsdWU6IDAgfSxcXG5cXHRcXHRcXHRcXHRjbGVhckNvYXRSb3VnaG5lc3M6IHsgdmFsdWU6IDAgfVxcblxcdFxcdFxcdH1cXG5cXHRcXHRdICksXFxuXFxuXFx0XFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNocGh5c2ljYWxfdmVydCxcXG5cXHRcXHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBoeXNpY2FsX2ZyYWdcXG5cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBCb3gyKCBtaW4sIG1heCApIHtcXG5cXG5cXHRcXHR0aGlzLm1pbiA9ICggbWluICE9PSB1bmRlZmluZWQgKSA/IG1pbiA6IG5ldyBWZWN0b3IyKCArIEluZmluaXR5LCArIEluZmluaXR5ICk7XFxuXFx0XFx0dGhpcy5tYXggPSAoIG1heCAhPT0gdW5kZWZpbmVkICkgPyBtYXggOiBuZXcgVmVjdG9yMiggLSBJbmZpbml0eSwgLSBJbmZpbml0eSApO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBCb3gyLnByb3RvdHlwZSwge1xcblxcblxcdFxcdHNldDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm1pbi5jb3B5KCBtaW4gKTtcXG5cXHRcXHRcXHR0aGlzLm1heC5jb3B5KCBtYXggKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICggcG9pbnRzICkge1xcblxcblxcdFxcdFxcdHRoaXMubWFrZUVtcHR5KCk7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmV4cGFuZEJ5UG9pbnQoIHBvaW50c1sgaSBdICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0RnJvbUNlbnRlckFuZFNpemU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMigpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBzZXRGcm9tQ2VudGVyQW5kU2l6ZSggY2VudGVyLCBzaXplICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBoYWxmU2l6ZSA9IHYxLmNvcHkoIHNpemUgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XFxuXFx0XFx0XFx0XFx0dGhpcy5taW4uY29weSggY2VudGVyICkuc3ViKCBoYWxmU2l6ZSApO1xcblxcdFxcdFxcdFxcdHRoaXMubWF4LmNvcHkoIGNlbnRlciApLmFkZCggaGFsZlNpemUgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggYm94ICkge1xcblxcblxcdFxcdFxcdHRoaXMubWluLmNvcHkoIGJveC5taW4gKTtcXG5cXHRcXHRcXHR0aGlzLm1heC5jb3B5KCBib3gubWF4ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRtYWtlRW1wdHk6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm1pbi54ID0gdGhpcy5taW4ueSA9ICsgSW5maW5pdHk7XFxuXFx0XFx0XFx0dGhpcy5tYXgueCA9IHRoaXMubWF4LnkgPSAtIEluZmluaXR5O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdC8vIHRoaXMgaXMgYSBtb3JlIHJvYnVzdCBjaGVjayBmb3IgZW1wdHkgdGhhbiAoIHZvbHVtZSA8PSAwICkgYmVjYXVzZSB2b2x1bWUgY2FuIGdldCBwb3NpdGl2ZSB3aXRoIHR3byBuZWdhdGl2ZSBheGVzXFxuXFxuXFx0XFx0XFx0cmV0dXJuICggdGhpcy5tYXgueCA8IHRoaXMubWluLnggKSB8fCAoIHRoaXMubWF4LnkgPCB0aGlzLm1pbi55ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IyKCk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gcmVzdWx0LnNldCggMCwgMCApIDogcmVzdWx0LmFkZFZlY3RvcnMoIHRoaXMubWluLCB0aGlzLm1heCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldFNpemU6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IyKCk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gcmVzdWx0LnNldCggMCwgMCApIDogcmVzdWx0LnN1YlZlY3RvcnMoIHRoaXMubWF4LCB0aGlzLm1pbiApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZXhwYW5kQnlQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm1pbi5taW4oIHBvaW50ICk7XFxuXFx0XFx0XFx0dGhpcy5tYXgubWF4KCBwb2ludCApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZXhwYW5kQnlWZWN0b3I6IGZ1bmN0aW9uICggdmVjdG9yICkge1xcblxcblxcdFxcdFxcdHRoaXMubWluLnN1YiggdmVjdG9yICk7XFxuXFx0XFx0XFx0dGhpcy5tYXguYWRkKCB2ZWN0b3IgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGV4cGFuZEJ5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm1pbi5hZGRTY2FsYXIoIC0gc2NhbGFyICk7XFxuXFx0XFx0XFx0dGhpcy5tYXguYWRkU2NhbGFyKCBzY2FsYXIgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHBvaW50LnggPCB0aGlzLm1pbi54IHx8IHBvaW50LnggPiB0aGlzLm1heC54IHx8XFxuXFx0XFx0XFx0XFx0cG9pbnQueSA8IHRoaXMubWluLnkgfHwgcG9pbnQueSA+IHRoaXMubWF4LnkgPyBmYWxzZSA6IHRydWU7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb250YWluc0JveDogZnVuY3Rpb24gKCBib3ggKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubWluLnggPD0gYm94Lm1pbi54ICYmIGJveC5tYXgueCA8PSB0aGlzLm1heC54ICYmXFxuXFx0XFx0XFx0XFx0dGhpcy5taW4ueSA8PSBib3gubWluLnkgJiYgYm94Lm1heC55IDw9IHRoaXMubWF4Lnk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRQYXJhbWV0ZXI6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdC8vIFRoaXMgY2FuIHBvdGVudGlhbGx5IGhhdmUgYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgYm94XFxuXFx0XFx0XFx0Ly8gaGFzIGEgc2l6ZSBkaW1lbnNpb24gb2YgMC5cXG5cXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjIoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0LnNldChcXG5cXHRcXHRcXHRcXHQoIHBvaW50LnggLSB0aGlzLm1pbi54ICkgLyAoIHRoaXMubWF4LnggLSB0aGlzLm1pbi54ICksXFxuXFx0XFx0XFx0XFx0KCBwb2ludC55IC0gdGhpcy5taW4ueSApIC8gKCB0aGlzLm1heC55IC0gdGhpcy5taW4ueSApXFxuXFx0XFx0XFx0KTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGludGVyc2VjdHNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xcblxcblxcdFxcdFxcdC8vIHVzaW5nIDQgc3BsaXR0aW5nIHBsYW5lcyB0byBydWxlIG91dCBpbnRlcnNlY3Rpb25zXFxuXFxuXFx0XFx0XFx0cmV0dXJuIGJveC5tYXgueCA8IHRoaXMubWluLnggfHwgYm94Lm1pbi54ID4gdGhpcy5tYXgueCB8fFxcblxcdFxcdFxcdFxcdGJveC5tYXgueSA8IHRoaXMubWluLnkgfHwgYm94Lm1pbi55ID4gdGhpcy5tYXgueSA/IGZhbHNlIDogdHJ1ZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsYW1wUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMigpO1xcblxcdFxcdFxcdHJldHVybiByZXN1bHQuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMigpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBkaXN0YW5jZVRvUG9pbnQoIHBvaW50ICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBjbGFtcGVkUG9pbnQgPSB2MS5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gY2xhbXBlZFBvaW50LnN1YiggcG9pbnQgKS5sZW5ndGgoKTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRpbnRlcnNlY3Q6IGZ1bmN0aW9uICggYm94ICkge1xcblxcblxcdFxcdFxcdHRoaXMubWluLm1heCggYm94Lm1pbiApO1xcblxcdFxcdFxcdHRoaXMubWF4Lm1pbiggYm94Lm1heCApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dW5pb246IGZ1bmN0aW9uICggYm94ICkge1xcblxcblxcdFxcdFxcdHRoaXMubWluLm1pbiggYm94Lm1pbiApO1xcblxcdFxcdFxcdHRoaXMubWF4Lm1heCggYm94Lm1heCApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm1pbi5hZGQoIG9mZnNldCApO1xcblxcdFxcdFxcdHRoaXMubWF4LmFkZCggb2Zmc2V0ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRlcXVhbHM6IGZ1bmN0aW9uICggYm94ICkge1xcblxcblxcdFxcdFxcdHJldHVybiBib3gubWluLmVxdWFscyggdGhpcy5taW4gKSAmJiBib3gubWF4LmVxdWFscyggdGhpcy5tYXggKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBXZWJHTEZsYXJlUmVuZGVyZXIoIHJlbmRlcmVyLCBnbCwgc3RhdGUsIHRleHR1cmVzLCBjYXBhYmlsaXRpZXMgKSB7XFxuXFxuXFx0XFx0dmFyIHZlcnRleEJ1ZmZlciwgZWxlbWVudEJ1ZmZlcjtcXG5cXHRcXHR2YXIgc2hhZGVyLCBwcm9ncmFtLCBhdHRyaWJ1dGVzLCB1bmlmb3JtcztcXG5cXG5cXHRcXHR2YXIgdGVtcFRleHR1cmUsIG9jY2x1c2lvblRleHR1cmU7XFxuXFxuXFx0XFx0ZnVuY3Rpb24gaW5pdCgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXFxuXFx0XFx0XFx0XFx0LSAxLCAtIDEsIDAsIDAsXFxuXFx0XFx0XFx0XFx0ICAxLCAtIDEsIDEsIDAsXFxuXFx0XFx0XFx0XFx0ICAxLCAxLCAxLCAxLFxcblxcdFxcdFxcdFxcdC0gMSwgMSwgMCwgMVxcblxcdFxcdFxcdF0gKTtcXG5cXG5cXHRcXHRcXHR2YXIgZmFjZXMgPSBuZXcgVWludDE2QXJyYXkoIFtcXG5cXHRcXHRcXHRcXHQwLCAxLCAyLFxcblxcdFxcdFxcdFxcdDAsIDIsIDNcXG5cXHRcXHRcXHRdICk7XFxuXFxuXFx0XFx0XFx0Ly8gYnVmZmVyc1xcblxcblxcdFxcdFxcdHZlcnRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xcblxcdFxcdFxcdGVsZW1lbnRCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcXG5cXG5cXHRcXHRcXHRnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xcblxcdFxcdFxcdGdsLmJ1ZmZlckRhdGEoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGljZXMsIGdsLlNUQVRJQ19EUkFXICk7XFxuXFxuXFx0XFx0XFx0Z2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1lbnRCdWZmZXIgKTtcXG5cXHRcXHRcXHRnbC5idWZmZXJEYXRhKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZmFjZXMsIGdsLlNUQVRJQ19EUkFXICk7XFxuXFxuXFx0XFx0XFx0Ly8gdGV4dHVyZXNcXG5cXG5cXHRcXHRcXHR0ZW1wVGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcXG5cXHRcXHRcXHRvY2NsdXNpb25UZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xcblxcblxcdFxcdFxcdHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCB0ZW1wVGV4dHVyZSApO1xcblxcdFxcdFxcdGdsLnRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQiwgMTYsIDE2LCAwLCBnbC5SR0IsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwgKTtcXG5cXHRcXHRcXHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSApO1xcblxcdFxcdFxcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFICk7XFxuXFx0XFx0XFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUICk7XFxuXFx0XFx0XFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUICk7XFxuXFxuXFx0XFx0XFx0c3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG9jY2x1c2lvblRleHR1cmUgKTtcXG5cXHRcXHRcXHRnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCAxNiwgMTYsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwgKTtcXG5cXHRcXHRcXHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSApO1xcblxcdFxcdFxcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFICk7XFxuXFx0XFx0XFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUICk7XFxuXFx0XFx0XFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUICk7XFxuXFxuXFx0XFx0XFx0c2hhZGVyID0ge1xcblxcblxcdFxcdFxcdFxcdHZlcnRleFNoYWRlcjogW1xcblxcblxcdFxcdFxcdFxcdFxcdCd1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7JyxcXG5cXG5cXHRcXHRcXHRcXHRcXHQndW5pZm9ybSB2ZWMzIHNjcmVlblBvc2l0aW9uOycsXFxuXFx0XFx0XFx0XFx0XFx0J3VuaWZvcm0gdmVjMiBzY2FsZTsnLFxcblxcdFxcdFxcdFxcdFxcdCd1bmlmb3JtIGZsb2F0IHJvdGF0aW9uOycsXFxuXFxuXFx0XFx0XFx0XFx0XFx0J3VuaWZvcm0gc2FtcGxlcjJEIG9jY2x1c2lvbk1hcDsnLFxcblxcblxcdFxcdFxcdFxcdFxcdCdhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjsnLFxcblxcdFxcdFxcdFxcdFxcdCdhdHRyaWJ1dGUgdmVjMiB1djsnLFxcblxcblxcdFxcdFxcdFxcdFxcdCd2YXJ5aW5nIHZlYzIgdlVWOycsXFxuXFx0XFx0XFx0XFx0XFx0J3ZhcnlpbmcgZmxvYXQgdlZpc2liaWxpdHk7JyxcXG5cXG5cXHRcXHRcXHRcXHRcXHQndm9pZCBtYWluKCkgeycsXFxuXFxuXFx0XFx0XFx0XFx0XFx0J1xcdHZVViA9IHV2OycsXFxuXFxuXFx0XFx0XFx0XFx0XFx0J1xcdHZlYzIgcG9zID0gcG9zaXRpb247JyxcXG5cXG5cXHRcXHRcXHRcXHRcXHQnXFx0aWYgKCByZW5kZXJUeXBlID09IDIgKSB7JyxcXG5cXG5cXHRcXHRcXHRcXHRcXHQnXFx0XFx0dmVjNCB2aXNpYmlsaXR5ID0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC4xICkgKTsnLFxcblxcdFxcdFxcdFxcdFxcdCdcXHRcXHR2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuMSApICk7JyxcXG5cXHRcXHRcXHRcXHRcXHQnXFx0XFx0dmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjEgKSApOycsXFxuXFx0XFx0XFx0XFx0XFx0J1xcdFxcdHZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC41ICkgKTsnLFxcblxcdFxcdFxcdFxcdFxcdCdcXHRcXHR2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuOSApICk7JyxcXG5cXHRcXHRcXHRcXHRcXHQnXFx0XFx0dmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjkgKSApOycsXFxuXFx0XFx0XFx0XFx0XFx0J1xcdFxcdHZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC45ICkgKTsnLFxcblxcdFxcdFxcdFxcdFxcdCdcXHRcXHR2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuNSApICk7JyxcXG5cXHRcXHRcXHRcXHRcXHQnXFx0XFx0dmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjUgKSApOycsXFxuXFxuXFx0XFx0XFx0XFx0XFx0J1xcdFxcdHZWaXNpYmlsaXR5ID0gICAgICAgIHZpc2liaWxpdHkuciAvIDkuMDsnLFxcblxcdFxcdFxcdFxcdFxcdCdcXHRcXHR2VmlzaWJpbGl0eSAqPSAxLjAgLSB2aXNpYmlsaXR5LmcgLyA5LjA7JyxcXG5cXHRcXHRcXHRcXHRcXHQnXFx0XFx0dlZpc2liaWxpdHkgKj0gICAgICAgdmlzaWJpbGl0eS5iIC8gOS4wOycsXFxuXFx0XFx0XFx0XFx0XFx0J1xcdFxcdHZWaXNpYmlsaXR5ICo9IDEuMCAtIHZpc2liaWxpdHkuYSAvIDkuMDsnLFxcblxcblxcdFxcdFxcdFxcdFxcdCdcXHRcXHRwb3MueCA9IGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnggLSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi55OycsXFxuXFx0XFx0XFx0XFx0XFx0J1xcdFxcdHBvcy55ID0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7JyxcXG5cXG5cXHRcXHRcXHRcXHRcXHQnXFx0fScsXFxuXFxuXFx0XFx0XFx0XFx0XFx0J1xcdGdsX1Bvc2l0aW9uID0gdmVjNCggKCBwb3MgKiBzY2FsZSArIHNjcmVlblBvc2l0aW9uLnh5ICkueHksIHNjcmVlblBvc2l0aW9uLnosIDEuMCApOycsXFxuXFxuXFx0XFx0XFx0XFx0XFx0J30nXFxuXFxuXFx0XFx0XFx0XFx0XS5qb2luKCAnXFxcXG4nICksXFxuXFxuXFx0XFx0XFx0XFx0ZnJhZ21lbnRTaGFkZXI6IFtcXG5cXG5cXHRcXHRcXHRcXHRcXHQndW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlOycsXFxuXFxuXFx0XFx0XFx0XFx0XFx0J3VuaWZvcm0gc2FtcGxlcjJEIG1hcDsnLFxcblxcdFxcdFxcdFxcdFxcdCd1bmlmb3JtIGZsb2F0IG9wYWNpdHk7JyxcXG5cXHRcXHRcXHRcXHRcXHQndW5pZm9ybSB2ZWMzIGNvbG9yOycsXFxuXFxuXFx0XFx0XFx0XFx0XFx0J3ZhcnlpbmcgdmVjMiB2VVY7JyxcXG5cXHRcXHRcXHRcXHRcXHQndmFyeWluZyBmbG9hdCB2VmlzaWJpbGl0eTsnLFxcblxcblxcdFxcdFxcdFxcdFxcdCd2b2lkIG1haW4oKSB7JyxcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBwaW5rIHNxdWFyZVxcblxcblxcdFxcdFxcdFxcdFxcdCdcXHRpZiAoIHJlbmRlclR5cGUgPT0gMCApIHsnLFxcblxcblxcdFxcdFxcdFxcdFxcdCdcXHRcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCAxLjAsIDAuMCwgMS4wLCAwLjAgKTsnLFxcblxcblxcdFxcdFxcdFxcdFxcdC8vIHJlc3RvcmVcXG5cXG5cXHRcXHRcXHRcXHRcXHQnXFx0fSBlbHNlIGlmICggcmVuZGVyVHlwZSA9PSAxICkgeycsXFxuXFxuXFx0XFx0XFx0XFx0XFx0J1xcdFxcdGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTsnLFxcblxcblxcdFxcdFxcdFxcdFxcdC8vIGZsYXJlXFxuXFxuXFx0XFx0XFx0XFx0XFx0J1xcdH0gZWxzZSB7JyxcXG5cXG5cXHRcXHRcXHRcXHRcXHQnXFx0XFx0dmVjNCB0ZXh0dXJlID0gdGV4dHVyZTJEKCBtYXAsIHZVViApOycsXFxuXFx0XFx0XFx0XFx0XFx0J1xcdFxcdHRleHR1cmUuYSAqPSBvcGFjaXR5ICogdlZpc2liaWxpdHk7JyxcXG5cXHRcXHRcXHRcXHRcXHQnXFx0XFx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZTsnLFxcblxcdFxcdFxcdFxcdFxcdCdcXHRcXHRnbF9GcmFnQ29sb3IucmdiICo9IGNvbG9yOycsXFxuXFxuXFx0XFx0XFx0XFx0XFx0J1xcdH0nLFxcblxcblxcdFxcdFxcdFxcdFxcdCd9J1xcblxcblxcdFxcdFxcdFxcdF0uam9pbiggJ1xcXFxuJyApXFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHRwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSggc2hhZGVyICk7XFxuXFxuXFx0XFx0XFx0YXR0cmlidXRlcyA9IHtcXG5cXHRcXHRcXHRcXHR2ZXJ0ZXg6IGdsLmdldEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCAncG9zaXRpb24nICksXFxuXFx0XFx0XFx0XFx0dXY6IGdsLmdldEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCAndXYnIClcXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdHVuaWZvcm1zID0ge1xcblxcdFxcdFxcdFxcdHJlbmRlclR5cGU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3JlbmRlclR5cGUnICksXFxuXFx0XFx0XFx0XFx0bWFwOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdtYXAnICksXFxuXFx0XFx0XFx0XFx0b2NjbHVzaW9uTWFwOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdvY2NsdXNpb25NYXAnICksXFxuXFx0XFx0XFx0XFx0b3BhY2l0eTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnb3BhY2l0eScgKSxcXG5cXHRcXHRcXHRcXHRjb2xvcjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnY29sb3InICksXFxuXFx0XFx0XFx0XFx0c2NhbGU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3NjYWxlJyApLFxcblxcdFxcdFxcdFxcdHJvdGF0aW9uOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdyb3RhdGlvbicgKSxcXG5cXHRcXHRcXHRcXHRzY3JlZW5Qb3NpdGlvbjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnc2NyZWVuUG9zaXRpb24nIClcXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvKlxcblxcdFxcdCAqIFJlbmRlciBsZW5zIGZsYXJlc1xcblxcdFxcdCAqIE1ldGhvZDogcmVuZGVycyAxNngxNiAweGZmMDBmZi1jb2xvcmVkIHBvaW50cyBzY2F0dGVyZWQgb3ZlciB0aGUgbGlnaHQgc291cmNlIGFyZWEsXFxuXFx0XFx0ICogICAgICAgICByZWFkcyB0aGVzZSBiYWNrIGFuZCBjYWxjdWxhdGVzIG9jY2x1c2lvbi5cXG5cXHRcXHQgKi9cXG5cXG5cXHRcXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggZmxhcmVzLCBzY2VuZSwgY2FtZXJhLCB2aWV3cG9ydCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGZsYXJlcy5sZW5ndGggPT09IDAgKSByZXR1cm47XFxuXFxuXFx0XFx0XFx0dmFyIHRlbXBQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0dmFyIGludkFzcGVjdCA9IHZpZXdwb3J0LncgLyB2aWV3cG9ydC56LFxcblxcdFxcdFxcdFxcdGhhbGZWaWV3cG9ydFdpZHRoID0gdmlld3BvcnQueiAqIDAuNSxcXG5cXHRcXHRcXHRcXHRoYWxmVmlld3BvcnRIZWlnaHQgPSB2aWV3cG9ydC53ICogMC41O1xcblxcblxcdFxcdFxcdHZhciBzaXplID0gMTYgLyB2aWV3cG9ydC53LFxcblxcdFxcdFxcdFxcdHNjYWxlID0gbmV3IFZlY3RvcjIoIHNpemUgKiBpbnZBc3BlY3QsIHNpemUgKTtcXG5cXG5cXHRcXHRcXHR2YXIgc2NyZWVuUG9zaXRpb24gPSBuZXcgVmVjdG9yMyggMSwgMSwgMCApLFxcblxcdFxcdFxcdFxcdHNjcmVlblBvc2l0aW9uUGl4ZWxzID0gbmV3IFZlY3RvcjIoIDEsIDEgKTtcXG5cXG5cXHRcXHRcXHR2YXIgdmFsaWRBcmVhID0gbmV3IEJveDIoKTtcXG5cXG5cXHRcXHRcXHR2YWxpZEFyZWEubWluLnNldCggdmlld3BvcnQueCwgdmlld3BvcnQueSApO1xcblxcdFxcdFxcdHZhbGlkQXJlYS5tYXguc2V0KCB2aWV3cG9ydC54ICsgKCB2aWV3cG9ydC56IC0gMTYgKSwgdmlld3BvcnQueSArICggdmlld3BvcnQudyAtIDE2ICkgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRpbml0KCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHN0YXRlLnVzZVByb2dyYW0oIHByb2dyYW0gKTtcXG5cXG5cXHRcXHRcXHRzdGF0ZS5pbml0QXR0cmlidXRlcygpO1xcblxcdFxcdFxcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy52ZXJ0ZXggKTtcXG5cXHRcXHRcXHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudXYgKTtcXG5cXHRcXHRcXHRzdGF0ZS5kaXNhYmxlVW51c2VkQXR0cmlidXRlcygpO1xcblxcblxcdFxcdFxcdC8vIGxvb3AgdGhyb3VnaCBhbGwgbGVucyBmbGFyZXMgdG8gdXBkYXRlIHRoZWlyIG9jY2x1c2lvbiBhbmQgcG9zaXRpb25zXFxuXFx0XFx0XFx0Ly8gc2V0dXAgZ2wgYW5kIGNvbW1vbiB1c2VkIGF0dHJpYnMvdW5pZm9ybXNcXG5cXG5cXHRcXHRcXHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLm9jY2x1c2lvbk1hcCwgMCApO1xcblxcdFxcdFxcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMubWFwLCAxICk7XFxuXFxuXFx0XFx0XFx0Z2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIgKTtcXG5cXHRcXHRcXHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnZlcnRleCwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgMCApO1xcblxcdFxcdFxcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudXYsIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDggKTtcXG5cXG5cXHRcXHRcXHRnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xcblxcblxcdFxcdFxcdHN0YXRlLmRpc2FibGUoIGdsLkNVTExfRkFDRSApO1xcblxcdFxcdFxcdHN0YXRlLmJ1ZmZlcnMuZGVwdGguc2V0TWFzayggZmFsc2UgKTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmbGFyZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRzaXplID0gMTYgLyB2aWV3cG9ydC53O1xcblxcdFxcdFxcdFxcdHNjYWxlLnNldCggc2l6ZSAqIGludkFzcGVjdCwgc2l6ZSApO1xcblxcblxcdFxcdFxcdFxcdC8vIGNhbGMgb2JqZWN0IHNjcmVlbiBwb3NpdGlvblxcblxcblxcdFxcdFxcdFxcdHZhciBmbGFyZSA9IGZsYXJlc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdHRlbXBQb3NpdGlvbi5zZXQoIGZsYXJlLm1hdHJpeFdvcmxkLmVsZW1lbnRzWyAxMiBdLCBmbGFyZS5tYXRyaXhXb3JsZC5lbGVtZW50c1sgMTMgXSwgZmxhcmUubWF0cml4V29ybGQuZWxlbWVudHNbIDE0IF0gKTtcXG5cXG5cXHRcXHRcXHRcXHR0ZW1wUG9zaXRpb24uYXBwbHlNYXRyaXg0KCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XFxuXFx0XFx0XFx0XFx0dGVtcFBvc2l0aW9uLmFwcGx5TWF0cml4NCggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBzZXR1cCBhcnJheXMgZm9yIGdsIHByb2dyYW1zXFxuXFxuXFx0XFx0XFx0XFx0c2NyZWVuUG9zaXRpb24uY29weSggdGVtcFBvc2l0aW9uICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgY29vcmRpbmF0ZSBvZiB0aGUgbG93ZXIgbGVmdCBjb3JuZXIgb2YgdGhlIHBpeGVscyB0byBjb3B5XFxuXFxuXFx0XFx0XFx0XFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueCA9IHZpZXdwb3J0LnggKyAoIHNjcmVlblBvc2l0aW9uLnggKiBoYWxmVmlld3BvcnRXaWR0aCApICsgaGFsZlZpZXdwb3J0V2lkdGggLSA4O1xcblxcdFxcdFxcdFxcdHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgPSB2aWV3cG9ydC55ICsgKCBzY3JlZW5Qb3NpdGlvbi55ICogaGFsZlZpZXdwb3J0SGVpZ2h0ICkgKyBoYWxmVmlld3BvcnRIZWlnaHQgLSA4O1xcblxcblxcdFxcdFxcdFxcdC8vIHNjcmVlbiBjdWxsXFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB2YWxpZEFyZWEuY29udGFpbnNQb2ludCggc2NyZWVuUG9zaXRpb25QaXhlbHMgKSA9PT0gdHJ1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBzYXZlIGN1cnJlbnQgUkdCIHRvIHRlbXAgdGV4dHVyZVxcblxcblxcdFxcdFxcdFxcdFxcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUwICk7XFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG51bGwgKTtcXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMSApO1xcblxcdFxcdFxcdFxcdFxcdHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCB0ZW1wVGV4dHVyZSApO1xcblxcdFxcdFxcdFxcdFxcdGdsLmNvcHlUZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0IsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLngsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnksIDE2LCAxNiwgMCApO1xcblxcblxcblxcdFxcdFxcdFxcdFxcdC8vIHJlbmRlciBwaW5rIHF1YWRcXG5cXG5cXHRcXHRcXHRcXHRcXHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLnJlbmRlclR5cGUsIDAgKTtcXG5cXHRcXHRcXHRcXHRcXHRnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnNjYWxlLCBzY2FsZS54LCBzY2FsZS55ICk7XFxuXFx0XFx0XFx0XFx0XFx0Z2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5zY3JlZW5Qb3NpdGlvbiwgc2NyZWVuUG9zaXRpb24ueCwgc2NyZWVuUG9zaXRpb24ueSwgc2NyZWVuUG9zaXRpb24ueiApO1xcblxcblxcdFxcdFxcdFxcdFxcdHN0YXRlLmRpc2FibGUoIGdsLkJMRU5EICk7XFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Z2wuZHJhd0VsZW1lbnRzKCBnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XFxuXFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gY29weSByZXN1bHQgdG8gb2NjbHVzaW9uTWFwXFxuXFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTAgKTtcXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgb2NjbHVzaW9uVGV4dHVyZSApO1xcblxcdFxcdFxcdFxcdFxcdGdsLmNvcHlUZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBzY3JlZW5Qb3NpdGlvblBpeGVscy54LCBzY3JlZW5Qb3NpdGlvblBpeGVscy55LCAxNiwgMTYsIDAgKTtcXG5cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyByZXN0b3JlIGdyYXBoaWNzXFxuXFxuXFx0XFx0XFx0XFx0XFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5yZW5kZXJUeXBlLCAxICk7XFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUuZGlzYWJsZSggZ2wuREVQVEhfVEVTVCApO1xcblxcblxcdFxcdFxcdFxcdFxcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUxICk7XFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIHRlbXBUZXh0dXJlICk7XFxuXFx0XFx0XFx0XFx0XFx0Z2wuZHJhd0VsZW1lbnRzKCBnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XFxuXFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdXBkYXRlIG9iamVjdCBwb3NpdGlvbnNcXG5cXG5cXHRcXHRcXHRcXHRcXHRmbGFyZS5wb3NpdGlvblNjcmVlbi5jb3B5KCBzY3JlZW5Qb3NpdGlvbiApO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggZmxhcmUuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmxhcmUuY3VzdG9tVXBkYXRlQ2FsbGJhY2soIGZsYXJlICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmbGFyZS51cGRhdGVMZW5zRmxhcmVzKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIHJlbmRlciBmbGFyZXNcXG5cXG5cXHRcXHRcXHRcXHRcXHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLnJlbmRlclR5cGUsIDIgKTtcXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS5lbmFibGUoIGdsLkJMRU5EICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZsYXJlLmxlbnNGbGFyZXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHNwcml0ZSA9IGZsYXJlLmxlbnNGbGFyZXNbIGogXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHNwcml0ZS5vcGFjaXR5ID4gMC4wMDEgJiYgc3ByaXRlLnNjYWxlID4gMC4wMDEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2NyZWVuUG9zaXRpb24ueCA9IHNwcml0ZS54O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNjcmVlblBvc2l0aW9uLnkgPSBzcHJpdGUueTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzY3JlZW5Qb3NpdGlvbi56ID0gc3ByaXRlLno7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2l6ZSA9IHNwcml0ZS5zaXplICogc3ByaXRlLnNjYWxlIC8gdmlld3BvcnQudztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzY2FsZS54ID0gc2l6ZSAqIGludkFzcGVjdDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzY2FsZS55ID0gc2l6ZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC51bmlmb3JtM2YoIHVuaWZvcm1zLnNjcmVlblBvc2l0aW9uLCBzY3JlZW5Qb3NpdGlvbi54LCBzY3JlZW5Qb3NpdGlvbi55LCBzY3JlZW5Qb3NpdGlvbi56ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy5zY2FsZSwgc2NhbGUueCwgc2NhbGUueSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMucm90YXRpb24sIHNwcml0ZS5yb3RhdGlvbiApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMub3BhY2l0eSwgc3ByaXRlLm9wYWNpdHkgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmNvbG9yLCBzcHJpdGUuY29sb3Iuciwgc3ByaXRlLmNvbG9yLmcsIHNwcml0ZS5jb2xvci5iICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c3RhdGUuc2V0QmxlbmRpbmcoIHNwcml0ZS5ibGVuZGluZywgc3ByaXRlLmJsZW5kRXF1YXRpb24sIHNwcml0ZS5ibGVuZFNyYywgc3ByaXRlLmJsZW5kRHN0ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGV4dHVyZXMuc2V0VGV4dHVyZTJEKCBzcHJpdGUudGV4dHVyZSwgMSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyByZXN0b3JlIGdsXFxuXFxuXFx0XFx0XFx0c3RhdGUuZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcXG5cXHRcXHRcXHRzdGF0ZS5lbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcXG5cXHRcXHRcXHRzdGF0ZS5idWZmZXJzLmRlcHRoLnNldE1hc2soIHRydWUgKTtcXG5cXG5cXHRcXHRcXHRzdGF0ZS5yZXNldCgpO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0ZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbSggc2hhZGVyICkge1xcblxcblxcdFxcdFxcdHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xcblxcblxcdFxcdFxcdHZhciBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuRlJBR01FTlRfU0hBREVSICk7XFxuXFx0XFx0XFx0dmFyIHZlcnRleFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuVkVSVEVYX1NIQURFUiApO1xcblxcblxcdFxcdFxcdHZhciBwcmVmaXggPSAncHJlY2lzaW9uICcgKyBjYXBhYmlsaXRpZXMucHJlY2lzaW9uICsgJyBmbG9hdDtcXFxcbic7XFxuXFxuXFx0XFx0XFx0Z2wuc2hhZGVyU291cmNlKCBmcmFnbWVudFNoYWRlciwgcHJlZml4ICsgc2hhZGVyLmZyYWdtZW50U2hhZGVyICk7XFxuXFx0XFx0XFx0Z2wuc2hhZGVyU291cmNlKCB2ZXJ0ZXhTaGFkZXIsIHByZWZpeCArIHNoYWRlci52ZXJ0ZXhTaGFkZXIgKTtcXG5cXG5cXHRcXHRcXHRnbC5jb21waWxlU2hhZGVyKCBmcmFnbWVudFNoYWRlciApO1xcblxcdFxcdFxcdGdsLmNvbXBpbGVTaGFkZXIoIHZlcnRleFNoYWRlciApO1xcblxcblxcdFxcdFxcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIgKTtcXG5cXHRcXHRcXHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIHZlcnRleFNoYWRlciApO1xcblxcblxcdFxcdFxcdGdsLmxpbmtQcm9ncmFtKCBwcm9ncmFtICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHByb2dyYW07XFxuXFxuXFx0XFx0fVxcblxcblxcdH1cXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIENhbnZhc1RleHR1cmUoIGNhbnZhcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xcblxcblxcdFxcdFRleHR1cmUuY2FsbCggdGhpcywgY2FudmFzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcXG5cXG5cXHRcXHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXG5cXG5cXHR9XFxuXFxuXFx0Q2FudmFzVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUZXh0dXJlLnByb3RvdHlwZSApO1xcblxcdENhbnZhc1RleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2FudmFzVGV4dHVyZTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gV2ViR0xTcHJpdGVSZW5kZXJlciggcmVuZGVyZXIsIGdsLCBzdGF0ZSwgdGV4dHVyZXMsIGNhcGFiaWxpdGllcyApIHtcXG5cXG5cXHRcXHR2YXIgdmVydGV4QnVmZmVyLCBlbGVtZW50QnVmZmVyO1xcblxcdFxcdHZhciBwcm9ncmFtLCBhdHRyaWJ1dGVzLCB1bmlmb3JtcztcXG5cXG5cXHRcXHR2YXIgdGV4dHVyZTtcXG5cXG5cXHRcXHQvLyBkZWNvbXBvc2UgbWF0cml4V29ybGRcXG5cXG5cXHRcXHR2YXIgc3ByaXRlUG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdHZhciBzcHJpdGVSb3RhdGlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XFxuXFx0XFx0dmFyIHNwcml0ZVNjYWxlID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRmdW5jdGlvbiBpbml0KCkge1xcblxcblxcdFxcdFxcdHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcXG5cXHRcXHRcXHRcXHQtIDAuNSwgLSAwLjUsIDAsIDAsXFxuXFx0XFx0XFx0XFx0ICAwLjUsIC0gMC41LCAxLCAwLFxcblxcdFxcdFxcdFxcdCAgMC41LCAwLjUsIDEsIDEsXFxuXFx0XFx0XFx0XFx0LSAwLjUsIDAuNSwgMCwgMVxcblxcdFxcdFxcdF0gKTtcXG5cXG5cXHRcXHRcXHR2YXIgZmFjZXMgPSBuZXcgVWludDE2QXJyYXkoIFtcXG5cXHRcXHRcXHRcXHQwLCAxLCAyLFxcblxcdFxcdFxcdFxcdDAsIDIsIDNcXG5cXHRcXHRcXHRdICk7XFxuXFxuXFx0XFx0XFx0dmVydGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XFxuXFx0XFx0XFx0ZWxlbWVudEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xcblxcblxcdFxcdFxcdGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XFxuXFx0XFx0XFx0Z2wuYnVmZmVyRGF0YSggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0aWNlcywgZ2wuU1RBVElDX0RSQVcgKTtcXG5cXG5cXHRcXHRcXHRnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xcblxcdFxcdFxcdGdsLmJ1ZmZlckRhdGEoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBmYWNlcywgZ2wuU1RBVElDX0RSQVcgKTtcXG5cXG5cXHRcXHRcXHRwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSgpO1xcblxcblxcdFxcdFxcdGF0dHJpYnV0ZXMgPSB7XFxuXFx0XFx0XFx0XFx0cG9zaXRpb246IGdsLmdldEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCAncG9zaXRpb24nICksXFxuXFx0XFx0XFx0XFx0dXY6IGdsLmdldEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCAndXYnIClcXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdHVuaWZvcm1zID0ge1xcblxcdFxcdFxcdFxcdHV2T2Zmc2V0OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICd1dk9mZnNldCcgKSxcXG5cXHRcXHRcXHRcXHR1dlNjYWxlOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICd1dlNjYWxlJyApLFxcblxcblxcdFxcdFxcdFxcdHJvdGF0aW9uOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdyb3RhdGlvbicgKSxcXG5cXHRcXHRcXHRcXHRzY2FsZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnc2NhbGUnICksXFxuXFxuXFx0XFx0XFx0XFx0Y29sb3I6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2NvbG9yJyApLFxcblxcdFxcdFxcdFxcdG1hcDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnbWFwJyApLFxcblxcdFxcdFxcdFxcdG9wYWNpdHk6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ29wYWNpdHknICksXFxuXFxuXFx0XFx0XFx0XFx0bW9kZWxWaWV3TWF0cml4OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdtb2RlbFZpZXdNYXRyaXgnICksXFxuXFx0XFx0XFx0XFx0cHJvamVjdGlvbk1hdHJpeDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAncHJvamVjdGlvbk1hdHJpeCcgKSxcXG5cXG5cXHRcXHRcXHRcXHRmb2dUeXBlOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dUeXBlJyApLFxcblxcdFxcdFxcdFxcdGZvZ0RlbnNpdHk6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ0RlbnNpdHknICksXFxuXFx0XFx0XFx0XFx0Zm9nTmVhcjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nTmVhcicgKSxcXG5cXHRcXHRcXHRcXHRmb2dGYXI6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ0ZhcicgKSxcXG5cXHRcXHRcXHRcXHRmb2dDb2xvcjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nQ29sb3InICksXFxuXFx0XFx0XFx0XFx0Zm9nRGVwdGg6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ0RlcHRoJyApLFxcblxcblxcdFxcdFxcdFxcdGFscGhhVGVzdDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnYWxwaGFUZXN0JyApXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHR2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsICdjYW52YXMnICk7XFxuXFx0XFx0XFx0Y2FudmFzLndpZHRoID0gODtcXG5cXHRcXHRcXHRjYW52YXMuaGVpZ2h0ID0gODtcXG5cXG5cXHRcXHRcXHR2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XFxuXFx0XFx0XFx0Y29udGV4dC5maWxsU3R5bGUgPSAnd2hpdGUnO1xcblxcdFxcdFxcdGNvbnRleHQuZmlsbFJlY3QoIDAsIDAsIDgsIDggKTtcXG5cXG5cXHRcXHRcXHR0ZXh0dXJlID0gbmV3IENhbnZhc1RleHR1cmUoIGNhbnZhcyApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggc3ByaXRlcywgc2NlbmUsIGNhbWVyYSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHNwcml0ZXMubGVuZ3RoID09PSAwICkgcmV0dXJuO1xcblxcblxcdFxcdFxcdC8vIHNldHVwIGdsXFxuXFxuXFx0XFx0XFx0aWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aW5pdCgpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRzdGF0ZS51c2VQcm9ncmFtKCBwcm9ncmFtICk7XFxuXFxuXFx0XFx0XFx0c3RhdGUuaW5pdEF0dHJpYnV0ZXMoKTtcXG5cXHRcXHRcXHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMucG9zaXRpb24gKTtcXG5cXHRcXHRcXHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudXYgKTtcXG5cXHRcXHRcXHRzdGF0ZS5kaXNhYmxlVW51c2VkQXR0cmlidXRlcygpO1xcblxcblxcdFxcdFxcdHN0YXRlLmRpc2FibGUoIGdsLkNVTExfRkFDRSApO1xcblxcdFxcdFxcdHN0YXRlLmVuYWJsZSggZ2wuQkxFTkQgKTtcXG5cXG5cXHRcXHRcXHRnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xcblxcdFxcdFxcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMucG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDAgKTtcXG5cXHRcXHRcXHRnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCA4ICk7XFxuXFxuXFx0XFx0XFx0Z2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1lbnRCdWZmZXIgKTtcXG5cXG5cXHRcXHRcXHRnbC51bmlmb3JtTWF0cml4NGZ2KCB1bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4LCBmYWxzZSwgY2FtZXJhLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHMgKTtcXG5cXG5cXHRcXHRcXHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMCApO1xcblxcdFxcdFxcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMubWFwLCAwICk7XFxuXFxuXFx0XFx0XFx0dmFyIG9sZEZvZ1R5cGUgPSAwO1xcblxcdFxcdFxcdHZhciBzY2VuZUZvZ1R5cGUgPSAwO1xcblxcdFxcdFxcdHZhciBmb2cgPSBzY2VuZS5mb2c7XFxuXFxuXFx0XFx0XFx0aWYgKCBmb2cgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Z2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5mb2dDb2xvciwgZm9nLmNvbG9yLnIsIGZvZy5jb2xvci5nLCBmb2cuY29sb3IuYiApO1xcblxcblxcdFxcdFxcdFxcdGlmICggZm9nLmlzRm9nICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMuZm9nTmVhciwgZm9nLm5lYXIgKTtcXG5cXHRcXHRcXHRcXHRcXHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLmZvZ0ZhciwgZm9nLmZhciApO1xcblxcblxcdFxcdFxcdFxcdFxcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgMSApO1xcblxcdFxcdFxcdFxcdFxcdG9sZEZvZ1R5cGUgPSAxO1xcblxcdFxcdFxcdFxcdFxcdHNjZW5lRm9nVHlwZSA9IDE7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggZm9nLmlzRm9nRXhwMiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLmZvZ0RlbnNpdHksIGZvZy5kZW5zaXR5ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5mb2dUeXBlLCAyICk7XFxuXFx0XFx0XFx0XFx0XFx0b2xkRm9nVHlwZSA9IDI7XFxuXFx0XFx0XFx0XFx0XFx0c2NlbmVGb2dUeXBlID0gMjtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIDAgKTtcXG5cXHRcXHRcXHRcXHRvbGRGb2dUeXBlID0gMDtcXG5cXHRcXHRcXHRcXHRzY2VuZUZvZ1R5cGUgPSAwO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXG5cXHRcXHRcXHQvLyB1cGRhdGUgcG9zaXRpb25zIGFuZCBzb3J0XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gc3ByaXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBzcHJpdGUgPSBzcHJpdGVzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0c3ByaXRlLm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBzcHJpdGUubWF0cml4V29ybGQgKTtcXG5cXHRcXHRcXHRcXHRzcHJpdGUueiA9IC0gc3ByaXRlLm1vZGVsVmlld01hdHJpeC5lbGVtZW50c1sgMTQgXTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0c3ByaXRlcy5zb3J0KCBwYWludGVyU29ydFN0YWJsZSApO1xcblxcblxcdFxcdFxcdC8vIHJlbmRlciBhbGwgc3ByaXRlc1xcblxcblxcdFxcdFxcdHZhciBzY2FsZSA9IFtdO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHNwcml0ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgc3ByaXRlID0gc3ByaXRlc1sgaSBdO1xcblxcdFxcdFxcdFxcdHZhciBtYXRlcmlhbCA9IHNwcml0ZS5tYXRlcmlhbDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG1hdGVyaWFsLnZpc2libGUgPT09IGZhbHNlICkgY29udGludWU7XFxuXFxuXFx0XFx0XFx0XFx0c3ByaXRlLm9uQmVmb3JlUmVuZGVyKCByZW5kZXJlciwgc2NlbmUsIGNhbWVyYSwgdW5kZWZpbmVkLCBtYXRlcmlhbCwgdW5kZWZpbmVkICk7XFxuXFxuXFx0XFx0XFx0XFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5hbHBoYVRlc3QsIG1hdGVyaWFsLmFscGhhVGVzdCApO1xcblxcdFxcdFxcdFxcdGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHVuaWZvcm1zLm1vZGVsVmlld01hdHJpeCwgZmFsc2UsIHNwcml0ZS5tb2RlbFZpZXdNYXRyaXguZWxlbWVudHMgKTtcXG5cXG5cXHRcXHRcXHRcXHRzcHJpdGUubWF0cml4V29ybGQuZGVjb21wb3NlKCBzcHJpdGVQb3NpdGlvbiwgc3ByaXRlUm90YXRpb24sIHNwcml0ZVNjYWxlICk7XFxuXFxuXFx0XFx0XFx0XFx0c2NhbGVbIDAgXSA9IHNwcml0ZVNjYWxlLng7XFxuXFx0XFx0XFx0XFx0c2NhbGVbIDEgXSA9IHNwcml0ZVNjYWxlLnk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGZvZ1R5cGUgPSAwO1xcblxcblxcdFxcdFxcdFxcdGlmICggc2NlbmUuZm9nICYmIG1hdGVyaWFsLmZvZyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb2dUeXBlID0gc2NlbmVGb2dUeXBlO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG9sZEZvZ1R5cGUgIT09IGZvZ1R5cGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5mb2dUeXBlLCBmb2dUeXBlICk7XFxuXFx0XFx0XFx0XFx0XFx0b2xkRm9nVHlwZSA9IGZvZ1R5cGU7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggbWF0ZXJpYWwubWFwICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGdsLnVuaWZvcm0yZiggdW5pZm9ybXMudXZPZmZzZXQsIG1hdGVyaWFsLm1hcC5vZmZzZXQueCwgbWF0ZXJpYWwubWFwLm9mZnNldC55ICk7XFxuXFx0XFx0XFx0XFx0XFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dlNjYWxlLCBtYXRlcmlhbC5tYXAucmVwZWF0LngsIG1hdGVyaWFsLm1hcC5yZXBlYXQueSApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dk9mZnNldCwgMCwgMCApO1xcblxcdFxcdFxcdFxcdFxcdGdsLnVuaWZvcm0yZiggdW5pZm9ybXMudXZTY2FsZSwgMSwgMSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLm9wYWNpdHksIG1hdGVyaWFsLm9wYWNpdHkgKTtcXG5cXHRcXHRcXHRcXHRnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmNvbG9yLCBtYXRlcmlhbC5jb2xvci5yLCBtYXRlcmlhbC5jb2xvci5nLCBtYXRlcmlhbC5jb2xvci5iICk7XFxuXFxuXFx0XFx0XFx0XFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5yb3RhdGlvbiwgbWF0ZXJpYWwucm90YXRpb24gKTtcXG5cXHRcXHRcXHRcXHRnbC51bmlmb3JtMmZ2KCB1bmlmb3Jtcy5zY2FsZSwgc2NhbGUgKTtcXG5cXG5cXHRcXHRcXHRcXHRzdGF0ZS5zZXRCbGVuZGluZyggbWF0ZXJpYWwuYmxlbmRpbmcsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb24sIG1hdGVyaWFsLmJsZW5kU3JjLCBtYXRlcmlhbC5ibGVuZERzdCwgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbkFscGhhLCBtYXRlcmlhbC5ibGVuZFNyY0FscGhhLCBtYXRlcmlhbC5ibGVuZERzdEFscGhhLCBtYXRlcmlhbC5wcmVtdWx0aXBsaWVkQWxwaGEgKTtcXG5cXHRcXHRcXHRcXHRzdGF0ZS5idWZmZXJzLmRlcHRoLnNldFRlc3QoIG1hdGVyaWFsLmRlcHRoVGVzdCApO1xcblxcdFxcdFxcdFxcdHN0YXRlLmJ1ZmZlcnMuZGVwdGguc2V0TWFzayggbWF0ZXJpYWwuZGVwdGhXcml0ZSApO1xcblxcdFxcdFxcdFxcdHN0YXRlLmJ1ZmZlcnMuY29sb3Iuc2V0TWFzayggbWF0ZXJpYWwuY29sb3JXcml0ZSApO1xcblxcblxcdFxcdFxcdFxcdHRleHR1cmVzLnNldFRleHR1cmUyRCggbWF0ZXJpYWwubWFwIHx8IHRleHR1cmUsIDAgKTtcXG5cXG5cXHRcXHRcXHRcXHRnbC5kcmF3RWxlbWVudHMoIGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcXG5cXG5cXHRcXHRcXHRcXHRzcHJpdGUub25BZnRlclJlbmRlciggcmVuZGVyZXIsIHNjZW5lLCBjYW1lcmEsIHVuZGVmaW5lZCwgbWF0ZXJpYWwsIHVuZGVmaW5lZCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyByZXN0b3JlIGdsXFxuXFxuXFx0XFx0XFx0c3RhdGUuZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcXG5cXG5cXHRcXHRcXHRzdGF0ZS5yZXNldCgpO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0ZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbSgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcXG5cXG5cXHRcXHRcXHR2YXIgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5WRVJURVhfU0hBREVSICk7XFxuXFx0XFx0XFx0dmFyIGZyYWdtZW50U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5GUkFHTUVOVF9TSEFERVIgKTtcXG5cXG5cXHRcXHRcXHRnbC5zaGFkZXJTb3VyY2UoIHZlcnRleFNoYWRlciwgW1xcblxcblxcdFxcdFxcdFxcdCdwcmVjaXNpb24gJyArIGNhcGFiaWxpdGllcy5wcmVjaXNpb24gKyAnIGZsb2F0OycsXFxuXFxuXFx0XFx0XFx0XFx0JyNkZWZpbmUgU0hBREVSX05BTUUgJyArICdTcHJpdGVNYXRlcmlhbCcsXFxuXFxuXFx0XFx0XFx0XFx0J3VuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7JyxcXG5cXHRcXHRcXHRcXHQndW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7JyxcXG5cXHRcXHRcXHRcXHQndW5pZm9ybSBmbG9hdCByb3RhdGlvbjsnLFxcblxcdFxcdFxcdFxcdCd1bmlmb3JtIHZlYzIgc2NhbGU7JyxcXG5cXHRcXHRcXHRcXHQndW5pZm9ybSB2ZWMyIHV2T2Zmc2V0OycsXFxuXFx0XFx0XFx0XFx0J3VuaWZvcm0gdmVjMiB1dlNjYWxlOycsXFxuXFxuXFx0XFx0XFx0XFx0J2F0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uOycsXFxuXFx0XFx0XFx0XFx0J2F0dHJpYnV0ZSB2ZWMyIHV2OycsXFxuXFxuXFx0XFx0XFx0XFx0J3ZhcnlpbmcgdmVjMiB2VVY7JyxcXG5cXHRcXHRcXHRcXHQndmFyeWluZyBmbG9hdCBmb2dEZXB0aDsnLFxcblxcblxcdFxcdFxcdFxcdCd2b2lkIG1haW4oKSB7JyxcXG5cXG5cXHRcXHRcXHRcXHQnXFx0dlVWID0gdXZPZmZzZXQgKyB1diAqIHV2U2NhbGU7JyxcXG5cXG5cXHRcXHRcXHRcXHQnXFx0dmVjMiBhbGlnbmVkUG9zaXRpb24gPSBwb3NpdGlvbiAqIHNjYWxlOycsXFxuXFxuXFx0XFx0XFx0XFx0J1xcdHZlYzIgcm90YXRlZFBvc2l0aW9uOycsXFxuXFx0XFx0XFx0XFx0J1xcdHJvdGF0ZWRQb3NpdGlvbi54ID0gY29zKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnggLSBzaW4oIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueTsnLFxcblxcdFxcdFxcdFxcdCdcXHRyb3RhdGVkUG9zaXRpb24ueSA9IHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnk7JyxcXG5cXG5cXHRcXHRcXHRcXHQnXFx0dmVjNCBtdlBvc2l0aW9uOycsXFxuXFxuXFx0XFx0XFx0XFx0J1xcdG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCAwLjAsIDAuMCwgMC4wLCAxLjAgKTsnLFxcblxcdFxcdFxcdFxcdCdcXHRtdlBvc2l0aW9uLnh5ICs9IHJvdGF0ZWRQb3NpdGlvbjsnLFxcblxcblxcdFxcdFxcdFxcdCdcXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uOycsXFxuXFxuXFx0XFx0XFx0XFx0J1xcdGZvZ0RlcHRoID0gLSBtdlBvc2l0aW9uLno7JyxcXG5cXG5cXHRcXHRcXHRcXHQnfSdcXG5cXG5cXHRcXHRcXHRdLmpvaW4oICdcXFxcbicgKSApO1xcblxcblxcdFxcdFxcdGdsLnNoYWRlclNvdXJjZSggZnJhZ21lbnRTaGFkZXIsIFtcXG5cXG5cXHRcXHRcXHRcXHQncHJlY2lzaW9uICcgKyBjYXBhYmlsaXRpZXMucHJlY2lzaW9uICsgJyBmbG9hdDsnLFxcblxcblxcdFxcdFxcdFxcdCcjZGVmaW5lIFNIQURFUl9OQU1FICcgKyAnU3ByaXRlTWF0ZXJpYWwnLFxcblxcblxcdFxcdFxcdFxcdCd1bmlmb3JtIHZlYzMgY29sb3I7JyxcXG5cXHRcXHRcXHRcXHQndW5pZm9ybSBzYW1wbGVyMkQgbWFwOycsXFxuXFx0XFx0XFx0XFx0J3VuaWZvcm0gZmxvYXQgb3BhY2l0eTsnLFxcblxcblxcdFxcdFxcdFxcdCd1bmlmb3JtIGludCBmb2dUeXBlOycsXFxuXFx0XFx0XFx0XFx0J3VuaWZvcm0gdmVjMyBmb2dDb2xvcjsnLFxcblxcdFxcdFxcdFxcdCd1bmlmb3JtIGZsb2F0IGZvZ0RlbnNpdHk7JyxcXG5cXHRcXHRcXHRcXHQndW5pZm9ybSBmbG9hdCBmb2dOZWFyOycsXFxuXFx0XFx0XFx0XFx0J3VuaWZvcm0gZmxvYXQgZm9nRmFyOycsXFxuXFx0XFx0XFx0XFx0J3VuaWZvcm0gZmxvYXQgYWxwaGFUZXN0OycsXFxuXFxuXFx0XFx0XFx0XFx0J3ZhcnlpbmcgdmVjMiB2VVY7JyxcXG5cXHRcXHRcXHRcXHQndmFyeWluZyBmbG9hdCBmb2dEZXB0aDsnLFxcblxcblxcdFxcdFxcdFxcdCd2b2lkIG1haW4oKSB7JyxcXG5cXG5cXHRcXHRcXHRcXHQnXFx0dmVjNCB0ZXh0dXJlID0gdGV4dHVyZTJEKCBtYXAsIHZVViApOycsXFxuXFxuXFx0XFx0XFx0XFx0J1xcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIGNvbG9yICogdGV4dHVyZS54eXosIHRleHR1cmUuYSAqIG9wYWNpdHkgKTsnLFxcblxcblxcdFxcdFxcdFxcdCdcXHRpZiAoIGdsX0ZyYWdDb2xvci5hIDwgYWxwaGFUZXN0ICkgZGlzY2FyZDsnLFxcblxcblxcdFxcdFxcdFxcdCdcXHRpZiAoIGZvZ1R5cGUgPiAwICkgeycsXFxuXFxuXFx0XFx0XFx0XFx0J1xcdFxcdGZsb2F0IGZvZ0ZhY3RvciA9IDAuMDsnLFxcblxcblxcdFxcdFxcdFxcdCdcXHRcXHRpZiAoIGZvZ1R5cGUgPT0gMSApIHsnLFxcblxcblxcdFxcdFxcdFxcdCdcXHRcXHRcXHRmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIGZvZ0RlcHRoICk7JyxcXG5cXG5cXHRcXHRcXHRcXHQnXFx0XFx0fSBlbHNlIHsnLFxcblxcblxcdFxcdFxcdFxcdCdcXHRcXHRcXHRjb25zdCBmbG9hdCBMT0cyID0gMS40NDI2OTU7JyxcXG5cXHRcXHRcXHRcXHQnXFx0XFx0XFx0Zm9nRmFjdG9yID0gZXhwMiggLSBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSAqIGZvZ0RlcHRoICogZm9nRGVwdGggKiBMT0cyICk7JyxcXG5cXHRcXHRcXHRcXHQnXFx0XFx0XFx0Zm9nRmFjdG9yID0gMS4wIC0gY2xhbXAoIGZvZ0ZhY3RvciwgMC4wLCAxLjAgKTsnLFxcblxcblxcdFxcdFxcdFxcdCdcXHRcXHR9JyxcXG5cXG5cXHRcXHRcXHRcXHQnXFx0XFx0Z2xfRnJhZ0NvbG9yLnJnYiA9IG1peCggZ2xfRnJhZ0NvbG9yLnJnYiwgZm9nQ29sb3IsIGZvZ0ZhY3RvciApOycsXFxuXFxuXFx0XFx0XFx0XFx0J1xcdH0nLFxcblxcblxcdFxcdFxcdFxcdCd9J1xcblxcblxcdFxcdFxcdF0uam9pbiggJ1xcXFxuJyApICk7XFxuXFxuXFx0XFx0XFx0Z2wuY29tcGlsZVNoYWRlciggdmVydGV4U2hhZGVyICk7XFxuXFx0XFx0XFx0Z2wuY29tcGlsZVNoYWRlciggZnJhZ21lbnRTaGFkZXIgKTtcXG5cXG5cXHRcXHRcXHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIHZlcnRleFNoYWRlciApO1xcblxcdFxcdFxcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIgKTtcXG5cXG5cXHRcXHRcXHRnbC5saW5rUHJvZ3JhbSggcHJvZ3JhbSApO1xcblxcblxcdFxcdFxcdHJldHVybiBwcm9ncmFtO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBwYWludGVyU29ydFN0YWJsZSggYSwgYiApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGEucmVuZGVyT3JkZXIgIT09IGIucmVuZGVyT3JkZXIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGEucmVuZGVyT3JkZXIgLSBiLnJlbmRlck9yZGVyO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGEueiAhPT0gYi56ICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBiLnogLSBhLno7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gYi5pZCAtIGEuaWQ7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHR9XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqL1xcblxcblxcdHZhciBtYXRlcmlhbElkID0gMDtcXG5cXG5cXHRmdW5jdGlvbiBNYXRlcmlhbCgpIHtcXG5cXG5cXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IG1hdGVyaWFsSWQgKysgfSApO1xcblxcblxcdFxcdHRoaXMudXVpZCA9IF9NYXRoLmdlbmVyYXRlVVVJRCgpO1xcblxcblxcdFxcdHRoaXMubmFtZSA9ICcnO1xcblxcdFxcdHRoaXMudHlwZSA9ICdNYXRlcmlhbCc7XFxuXFxuXFx0XFx0dGhpcy5mb2cgPSB0cnVlO1xcblxcdFxcdHRoaXMubGlnaHRzID0gdHJ1ZTtcXG5cXG5cXHRcXHR0aGlzLmJsZW5kaW5nID0gTm9ybWFsQmxlbmRpbmc7XFxuXFx0XFx0dGhpcy5zaWRlID0gRnJvbnRTaWRlO1xcblxcdFxcdHRoaXMuZmxhdFNoYWRpbmcgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLnZlcnRleENvbG9ycyA9IE5vQ29sb3JzOyAvLyBUSFJFRS5Ob0NvbG9ycywgVEhSRUUuVmVydGV4Q29sb3JzLCBUSFJFRS5GYWNlQ29sb3JzXFxuXFxuXFx0XFx0dGhpcy5vcGFjaXR5ID0gMTtcXG5cXHRcXHR0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XFxuXFxuXFx0XFx0dGhpcy5ibGVuZFNyYyA9IFNyY0FscGhhRmFjdG9yO1xcblxcdFxcdHRoaXMuYmxlbmREc3QgPSBPbmVNaW51c1NyY0FscGhhRmFjdG9yO1xcblxcdFxcdHRoaXMuYmxlbmRFcXVhdGlvbiA9IEFkZEVxdWF0aW9uO1xcblxcdFxcdHRoaXMuYmxlbmRTcmNBbHBoYSA9IG51bGw7XFxuXFx0XFx0dGhpcy5ibGVuZERzdEFscGhhID0gbnVsbDtcXG5cXHRcXHR0aGlzLmJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XFxuXFxuXFx0XFx0dGhpcy5kZXB0aEZ1bmMgPSBMZXNzRXF1YWxEZXB0aDtcXG5cXHRcXHR0aGlzLmRlcHRoVGVzdCA9IHRydWU7XFxuXFx0XFx0dGhpcy5kZXB0aFdyaXRlID0gdHJ1ZTtcXG5cXG5cXHRcXHR0aGlzLmNsaXBwaW5nUGxhbmVzID0gbnVsbDtcXG5cXHRcXHR0aGlzLmNsaXBJbnRlcnNlY3Rpb24gPSBmYWxzZTtcXG5cXHRcXHR0aGlzLmNsaXBTaGFkb3dzID0gZmFsc2U7XFxuXFxuXFx0XFx0dGhpcy5jb2xvcldyaXRlID0gdHJ1ZTtcXG5cXG5cXHRcXHR0aGlzLnByZWNpc2lvbiA9IG51bGw7IC8vIG92ZXJyaWRlIHRoZSByZW5kZXJlcidzIGRlZmF1bHQgcHJlY2lzaW9uIGZvciB0aGlzIG1hdGVyaWFsXFxuXFxuXFx0XFx0dGhpcy5wb2x5Z29uT2Zmc2V0ID0gZmFsc2U7XFxuXFx0XFx0dGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gMDtcXG5cXHRcXHR0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IDA7XFxuXFxuXFx0XFx0dGhpcy5kaXRoZXJpbmcgPSBmYWxzZTtcXG5cXG5cXHRcXHR0aGlzLmFscGhhVGVzdCA9IDA7XFxuXFx0XFx0dGhpcy5wcmVtdWx0aXBsaWVkQWxwaGEgPSBmYWxzZTtcXG5cXG5cXHRcXHR0aGlzLm92ZXJkcmF3ID0gMDsgLy8gT3ZlcmRyYXduIHBpeGVscyAodHlwaWNhbGx5IGJldHdlZW4gMCBhbmQgMSkgZm9yIGZpeGluZyBhbnRpYWxpYXNpbmcgZ2FwcyBpbiBDYW52YXNSZW5kZXJlclxcblxcblxcdFxcdHRoaXMudmlzaWJsZSA9IHRydWU7XFxuXFxuXFx0XFx0dGhpcy51c2VyRGF0YSA9IHt9O1xcblxcblxcdFxcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdH1cXG5cXG5cXHRNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlICksIHtcXG5cXG5cXHRcXHRjb25zdHJ1Y3RvcjogTWF0ZXJpYWwsXFxuXFxuXFx0XFx0aXNNYXRlcmlhbDogdHJ1ZSxcXG5cXG5cXHRcXHRvbkJlZm9yZUNvbXBpbGU6IGZ1bmN0aW9uICgpIHt9LFxcblxcblxcdFxcdHNldFZhbHVlczogZnVuY3Rpb24gKCB2YWx1ZXMgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB2YWx1ZXMgPT09IHVuZGVmaW5lZCApIHJldHVybjtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIga2V5IGluIHZhbHVlcyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbmV3VmFsdWUgPSB2YWx1ZXNbIGtleSBdO1xcblxcblxcdFxcdFxcdFxcdGlmICggbmV3VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oIFxcXCJUSFJFRS5NYXRlcmlhbDogJ1xcXCIgKyBrZXkgKyBcXFwiJyBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkLlxcXCIgKTtcXG5cXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gZm9yIGJhY2t3YXJkIGNvbXBhdGFiaWxpdHkgaWYgc2hhZGluZyBpcyBzZXQgaW4gdGhlIGNvbnN0cnVjdG9yXFxuXFx0XFx0XFx0XFx0aWYgKCBrZXkgPT09ICdzaGFkaW5nJyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS4nICsgdGhpcy50eXBlICsgJzogLnNoYWRpbmcgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHRoZSBib29sZWFuIC5mbGF0U2hhZGluZyBpbnN0ZWFkLicgKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmZsYXRTaGFkaW5nID0gKCBuZXdWYWx1ZSA9PT0gRmxhdFNoYWRpbmcgKSA/IHRydWUgOiBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGN1cnJlbnRWYWx1ZSA9IHRoaXNbIGtleSBdO1xcblxcblxcdFxcdFxcdFxcdGlmICggY3VycmVudFZhbHVlID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCBcXFwiVEhSRUUuXFxcIiArIHRoaXMudHlwZSArIFxcXCI6ICdcXFwiICsga2V5ICsgXFxcIicgaXMgbm90IGEgcHJvcGVydHkgb2YgdGhpcyBtYXRlcmlhbC5cXFwiICk7XFxuXFx0XFx0XFx0XFx0XFx0Y29udGludWU7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggY3VycmVudFZhbHVlICYmIGN1cnJlbnRWYWx1ZS5pc0NvbG9yICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGN1cnJlbnRWYWx1ZS5zZXQoIG5ld1ZhbHVlICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggKCBjdXJyZW50VmFsdWUgJiYgY3VycmVudFZhbHVlLmlzVmVjdG9yMyApICYmICggbmV3VmFsdWUgJiYgbmV3VmFsdWUuaXNWZWN0b3IzICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y3VycmVudFZhbHVlLmNvcHkoIG5ld1ZhbHVlICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICgga2V5ID09PSAnb3ZlcmRyYXcnICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGVuc3VyZSBvdmVyZHJhdyBpcyBiYWNrd2FyZHMtY29tcGF0aWJsZSB3aXRoIGxlZ2FjeSBib29sZWFuIHR5cGVcXG5cXHRcXHRcXHRcXHRcXHR0aGlzWyBrZXkgXSA9IE51bWJlciggbmV3VmFsdWUgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXNbIGtleSBdID0gbmV3VmFsdWU7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xcblxcblxcdFxcdFxcdHZhciBpc1Jvb3QgPSAoIG1ldGEgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgbWV0YSA9PT0gJ3N0cmluZycgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGlzUm9vdCApIHtcXG5cXG5cXHRcXHRcXHRcXHRtZXRhID0ge1xcblxcdFxcdFxcdFxcdFxcdHRleHR1cmVzOiB7fSxcXG5cXHRcXHRcXHRcXHRcXHRpbWFnZXM6IHt9XFxuXFx0XFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIGRhdGEgPSB7XFxuXFx0XFx0XFx0XFx0bWV0YWRhdGE6IHtcXG5cXHRcXHRcXHRcXHRcXHR2ZXJzaW9uOiA0LjUsXFxuXFx0XFx0XFx0XFx0XFx0dHlwZTogJ01hdGVyaWFsJyxcXG5cXHRcXHRcXHRcXHRcXHRnZW5lcmF0b3I6ICdNYXRlcmlhbC50b0pTT04nXFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0Ly8gc3RhbmRhcmQgTWF0ZXJpYWwgc2VyaWFsaXphdGlvblxcblxcdFxcdFxcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcXG5cXHRcXHRcXHRkYXRhLnR5cGUgPSB0aGlzLnR5cGU7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5jb2xvciAmJiB0aGlzLmNvbG9yLmlzQ29sb3IgKSBkYXRhLmNvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKTtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMucm91Z2huZXNzICE9PSB1bmRlZmluZWQgKSBkYXRhLnJvdWdobmVzcyA9IHRoaXMucm91Z2huZXNzO1xcblxcdFxcdFxcdGlmICggdGhpcy5tZXRhbG5lc3MgIT09IHVuZGVmaW5lZCApIGRhdGEubWV0YWxuZXNzID0gdGhpcy5tZXRhbG5lc3M7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmVtaXNzaXZlICYmIHRoaXMuZW1pc3NpdmUuaXNDb2xvciApIGRhdGEuZW1pc3NpdmUgPSB0aGlzLmVtaXNzaXZlLmdldEhleCgpO1xcblxcdFxcdFxcdGlmICggdGhpcy5lbWlzc2l2ZUludGVuc2l0eSAhPT0gMSApIGRhdGEuZW1pc3NpdmVJbnRlbnNpdHkgPSB0aGlzLmVtaXNzaXZlSW50ZW5zaXR5O1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5zcGVjdWxhciAmJiB0aGlzLnNwZWN1bGFyLmlzQ29sb3IgKSBkYXRhLnNwZWN1bGFyID0gdGhpcy5zcGVjdWxhci5nZXRIZXgoKTtcXG5cXHRcXHRcXHRpZiAoIHRoaXMuc2hpbmluZXNzICE9PSB1bmRlZmluZWQgKSBkYXRhLnNoaW5pbmVzcyA9IHRoaXMuc2hpbmluZXNzO1xcblxcdFxcdFxcdGlmICggdGhpcy5jbGVhckNvYXQgIT09IHVuZGVmaW5lZCApIGRhdGEuY2xlYXJDb2F0ID0gdGhpcy5jbGVhckNvYXQ7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLmNsZWFyQ29hdFJvdWdobmVzcyAhPT0gdW5kZWZpbmVkICkgZGF0YS5jbGVhckNvYXRSb3VnaG5lc3MgPSB0aGlzLmNsZWFyQ29hdFJvdWdobmVzcztcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMubWFwICYmIHRoaXMubWFwLmlzVGV4dHVyZSApIGRhdGEubWFwID0gdGhpcy5tYXAudG9KU09OKCBtZXRhICkudXVpZDtcXG5cXHRcXHRcXHRpZiAoIHRoaXMuYWxwaGFNYXAgJiYgdGhpcy5hbHBoYU1hcC5pc1RleHR1cmUgKSBkYXRhLmFscGhhTWFwID0gdGhpcy5hbHBoYU1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xcblxcdFxcdFxcdGlmICggdGhpcy5saWdodE1hcCAmJiB0aGlzLmxpZ2h0TWFwLmlzVGV4dHVyZSApIGRhdGEubGlnaHRNYXAgPSB0aGlzLmxpZ2h0TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLmJ1bXBNYXAgJiYgdGhpcy5idW1wTWFwLmlzVGV4dHVyZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRkYXRhLmJ1bXBNYXAgPSB0aGlzLmJ1bXBNYXAudG9KU09OKCBtZXRhICkudXVpZDtcXG5cXHRcXHRcXHRcXHRkYXRhLmJ1bXBTY2FsZSA9IHRoaXMuYnVtcFNjYWxlO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIHRoaXMubm9ybWFsTWFwICYmIHRoaXMubm9ybWFsTWFwLmlzVGV4dHVyZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRkYXRhLm5vcm1hbE1hcCA9IHRoaXMubm9ybWFsTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XFxuXFx0XFx0XFx0XFx0ZGF0YS5ub3JtYWxTY2FsZSA9IHRoaXMubm9ybWFsU2NhbGUudG9BcnJheSgpO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIHRoaXMuZGlzcGxhY2VtZW50TWFwICYmIHRoaXMuZGlzcGxhY2VtZW50TWFwLmlzVGV4dHVyZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRkYXRhLmRpc3BsYWNlbWVudE1hcCA9IHRoaXMuZGlzcGxhY2VtZW50TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XFxuXFx0XFx0XFx0XFx0ZGF0YS5kaXNwbGFjZW1lbnRTY2FsZSA9IHRoaXMuZGlzcGxhY2VtZW50U2NhbGU7XFxuXFx0XFx0XFx0XFx0ZGF0YS5kaXNwbGFjZW1lbnRCaWFzID0gdGhpcy5kaXNwbGFjZW1lbnRCaWFzO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoIHRoaXMucm91Z2huZXNzTWFwICYmIHRoaXMucm91Z2huZXNzTWFwLmlzVGV4dHVyZSApIGRhdGEucm91Z2huZXNzTWFwID0gdGhpcy5yb3VnaG5lc3NNYXAudG9KU09OKCBtZXRhICkudXVpZDtcXG5cXHRcXHRcXHRpZiAoIHRoaXMubWV0YWxuZXNzTWFwICYmIHRoaXMubWV0YWxuZXNzTWFwLmlzVGV4dHVyZSApIGRhdGEubWV0YWxuZXNzTWFwID0gdGhpcy5tZXRhbG5lc3NNYXAudG9KU09OKCBtZXRhICkudXVpZDtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuZW1pc3NpdmVNYXAgJiYgdGhpcy5lbWlzc2l2ZU1hcC5pc1RleHR1cmUgKSBkYXRhLmVtaXNzaXZlTWFwID0gdGhpcy5lbWlzc2l2ZU1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xcblxcdFxcdFxcdGlmICggdGhpcy5zcGVjdWxhck1hcCAmJiB0aGlzLnNwZWN1bGFyTWFwLmlzVGV4dHVyZSApIGRhdGEuc3BlY3VsYXJNYXAgPSB0aGlzLnNwZWN1bGFyTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmVudk1hcCAmJiB0aGlzLmVudk1hcC5pc1RleHR1cmUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZGF0YS5lbnZNYXAgPSB0aGlzLmVudk1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xcblxcdFxcdFxcdFxcdGRhdGEucmVmbGVjdGl2aXR5ID0gdGhpcy5yZWZsZWN0aXZpdHk7IC8vIFNjYWxlIGJlaGluZCBlbnZNYXBcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmdyYWRpZW50TWFwICYmIHRoaXMuZ3JhZGllbnRNYXAuaXNUZXh0dXJlICkge1xcblxcblxcdFxcdFxcdFxcdGRhdGEuZ3JhZGllbnRNYXAgPSB0aGlzLmdyYWRpZW50TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggdGhpcy5zaXplICE9PSB1bmRlZmluZWQgKSBkYXRhLnNpemUgPSB0aGlzLnNpemU7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLnNpemVBdHRlbnVhdGlvbiAhPT0gdW5kZWZpbmVkICkgZGF0YS5zaXplQXR0ZW51YXRpb24gPSB0aGlzLnNpemVBdHRlbnVhdGlvbjtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuYmxlbmRpbmcgIT09IE5vcm1hbEJsZW5kaW5nICkgZGF0YS5ibGVuZGluZyA9IHRoaXMuYmxlbmRpbmc7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLmZsYXRTaGFkaW5nID09PSB0cnVlICkgZGF0YS5mbGF0U2hhZGluZyA9IHRoaXMuZmxhdFNoYWRpbmc7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLnNpZGUgIT09IEZyb250U2lkZSApIGRhdGEuc2lkZSA9IHRoaXMuc2lkZTtcXG5cXHRcXHRcXHRpZiAoIHRoaXMudmVydGV4Q29sb3JzICE9PSBOb0NvbG9ycyApIGRhdGEudmVydGV4Q29sb3JzID0gdGhpcy52ZXJ0ZXhDb2xvcnM7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLm9wYWNpdHkgPCAxICkgZGF0YS5vcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xcblxcdFxcdFxcdGlmICggdGhpcy50cmFuc3BhcmVudCA9PT0gdHJ1ZSApIGRhdGEudHJhbnNwYXJlbnQgPSB0aGlzLnRyYW5zcGFyZW50O1xcblxcblxcdFxcdFxcdGRhdGEuZGVwdGhGdW5jID0gdGhpcy5kZXB0aEZ1bmM7XFxuXFx0XFx0XFx0ZGF0YS5kZXB0aFRlc3QgPSB0aGlzLmRlcHRoVGVzdDtcXG5cXHRcXHRcXHRkYXRhLmRlcHRoV3JpdGUgPSB0aGlzLmRlcHRoV3JpdGU7XFxuXFxuXFx0XFx0XFx0Ly8gcm90YXRpb24gKFNwcml0ZU1hdGVyaWFsKVxcblxcdFxcdFxcdGlmICggdGhpcy5yb3RhdGlvbiAhPT0gMCApIGRhdGEucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5saW5ld2lkdGggIT09IDEgKSBkYXRhLmxpbmV3aWR0aCA9IHRoaXMubGluZXdpZHRoO1xcblxcdFxcdFxcdGlmICggdGhpcy5kYXNoU2l6ZSAhPT0gdW5kZWZpbmVkICkgZGF0YS5kYXNoU2l6ZSA9IHRoaXMuZGFzaFNpemU7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLmdhcFNpemUgIT09IHVuZGVmaW5lZCApIGRhdGEuZ2FwU2l6ZSA9IHRoaXMuZ2FwU2l6ZTtcXG5cXHRcXHRcXHRpZiAoIHRoaXMuc2NhbGUgIT09IHVuZGVmaW5lZCApIGRhdGEuc2NhbGUgPSB0aGlzLnNjYWxlO1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5kaXRoZXJpbmcgPT09IHRydWUgKSBkYXRhLmRpdGhlcmluZyA9IHRydWU7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmFscGhhVGVzdCA+IDAgKSBkYXRhLmFscGhhVGVzdCA9IHRoaXMuYWxwaGFUZXN0O1xcblxcdFxcdFxcdGlmICggdGhpcy5wcmVtdWx0aXBsaWVkQWxwaGEgPT09IHRydWUgKSBkYXRhLnByZW11bHRpcGxpZWRBbHBoYSA9IHRoaXMucHJlbXVsdGlwbGllZEFscGhhO1xcblxcblxcdFxcdFxcdGlmICggdGhpcy53aXJlZnJhbWUgPT09IHRydWUgKSBkYXRhLndpcmVmcmFtZSA9IHRoaXMud2lyZWZyYW1lO1xcblxcdFxcdFxcdGlmICggdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPiAxICkgZGF0YS53aXJlZnJhbWVMaW5ld2lkdGggPSB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aDtcXG5cXHRcXHRcXHRpZiAoIHRoaXMud2lyZWZyYW1lTGluZWNhcCAhPT0gJ3JvdW5kJyApIGRhdGEud2lyZWZyYW1lTGluZWNhcCA9IHRoaXMud2lyZWZyYW1lTGluZWNhcDtcXG5cXHRcXHRcXHRpZiAoIHRoaXMud2lyZWZyYW1lTGluZWpvaW4gIT09ICdyb3VuZCcgKSBkYXRhLndpcmVmcmFtZUxpbmVqb2luID0gdGhpcy53aXJlZnJhbWVMaW5lam9pbjtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMubW9ycGhUYXJnZXRzID09PSB0cnVlICkgZGF0YS5tb3JwaFRhcmdldHMgPSB0cnVlO1xcblxcdFxcdFxcdGlmICggdGhpcy5za2lubmluZyA9PT0gdHJ1ZSApIGRhdGEuc2tpbm5pbmcgPSB0cnVlO1xcblxcblxcdFxcdFxcdGlmICggdGhpcy52aXNpYmxlID09PSBmYWxzZSApIGRhdGEudmlzaWJsZSA9IGZhbHNlO1xcblxcdFxcdFxcdGlmICggSlNPTi5zdHJpbmdpZnkoIHRoaXMudXNlckRhdGEgKSAhPT0gJ3t9JyApIGRhdGEudXNlckRhdGEgPSB0aGlzLnVzZXJEYXRhO1xcblxcblxcdFxcdFxcdC8vIFRPRE86IENvcGllZCBmcm9tIE9iamVjdDNELnRvSlNPTlxcblxcblxcdFxcdFxcdGZ1bmN0aW9uIGV4dHJhY3RGcm9tQ2FjaGUoIGNhY2hlICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB2YWx1ZXMgPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIga2V5IGluIGNhY2hlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBkYXRhID0gY2FjaGVbIGtleSBdO1xcblxcdFxcdFxcdFxcdFxcdGRlbGV0ZSBkYXRhLm1ldGFkYXRhO1xcblxcdFxcdFxcdFxcdFxcdHZhbHVlcy5wdXNoKCBkYXRhICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiB2YWx1ZXM7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggaXNSb290ICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB0ZXh0dXJlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEudGV4dHVyZXMgKTtcXG5cXHRcXHRcXHRcXHR2YXIgaW1hZ2VzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5pbWFnZXMgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHRleHR1cmVzLmxlbmd0aCA+IDAgKSBkYXRhLnRleHR1cmVzID0gdGV4dHVyZXM7XFxuXFx0XFx0XFx0XFx0aWYgKCBpbWFnZXMubGVuZ3RoID4gMCApIGRhdGEuaW1hZ2VzID0gaW1hZ2VzO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gZGF0YTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7XFxuXFxuXFx0XFx0XFx0dGhpcy5mb2cgPSBzb3VyY2UuZm9nO1xcblxcdFxcdFxcdHRoaXMubGlnaHRzID0gc291cmNlLmxpZ2h0cztcXG5cXG5cXHRcXHRcXHR0aGlzLmJsZW5kaW5nID0gc291cmNlLmJsZW5kaW5nO1xcblxcdFxcdFxcdHRoaXMuc2lkZSA9IHNvdXJjZS5zaWRlO1xcblxcdFxcdFxcdHRoaXMuZmxhdFNoYWRpbmcgPSBzb3VyY2UuZmxhdFNoYWRpbmc7XFxuXFx0XFx0XFx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBzb3VyY2UudmVydGV4Q29sb3JzO1xcblxcblxcdFxcdFxcdHRoaXMub3BhY2l0eSA9IHNvdXJjZS5vcGFjaXR5O1xcblxcdFxcdFxcdHRoaXMudHJhbnNwYXJlbnQgPSBzb3VyY2UudHJhbnNwYXJlbnQ7XFxuXFxuXFx0XFx0XFx0dGhpcy5ibGVuZFNyYyA9IHNvdXJjZS5ibGVuZFNyYztcXG5cXHRcXHRcXHR0aGlzLmJsZW5kRHN0ID0gc291cmNlLmJsZW5kRHN0O1xcblxcdFxcdFxcdHRoaXMuYmxlbmRFcXVhdGlvbiA9IHNvdXJjZS5ibGVuZEVxdWF0aW9uO1xcblxcdFxcdFxcdHRoaXMuYmxlbmRTcmNBbHBoYSA9IHNvdXJjZS5ibGVuZFNyY0FscGhhO1xcblxcdFxcdFxcdHRoaXMuYmxlbmREc3RBbHBoYSA9IHNvdXJjZS5ibGVuZERzdEFscGhhO1xcblxcdFxcdFxcdHRoaXMuYmxlbmRFcXVhdGlvbkFscGhhID0gc291cmNlLmJsZW5kRXF1YXRpb25BbHBoYTtcXG5cXG5cXHRcXHRcXHR0aGlzLmRlcHRoRnVuYyA9IHNvdXJjZS5kZXB0aEZ1bmM7XFxuXFx0XFx0XFx0dGhpcy5kZXB0aFRlc3QgPSBzb3VyY2UuZGVwdGhUZXN0O1xcblxcdFxcdFxcdHRoaXMuZGVwdGhXcml0ZSA9IHNvdXJjZS5kZXB0aFdyaXRlO1xcblxcblxcdFxcdFxcdHRoaXMuY29sb3JXcml0ZSA9IHNvdXJjZS5jb2xvcldyaXRlO1xcblxcblxcdFxcdFxcdHRoaXMucHJlY2lzaW9uID0gc291cmNlLnByZWNpc2lvbjtcXG5cXG5cXHRcXHRcXHR0aGlzLnBvbHlnb25PZmZzZXQgPSBzb3VyY2UucG9seWdvbk9mZnNldDtcXG5cXHRcXHRcXHR0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgPSBzb3VyY2UucG9seWdvbk9mZnNldEZhY3RvcjtcXG5cXHRcXHRcXHR0aGlzLnBvbHlnb25PZmZzZXRVbml0cyA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0VW5pdHM7XFxuXFxuXFx0XFx0XFx0dGhpcy5kaXRoZXJpbmcgPSBzb3VyY2UuZGl0aGVyaW5nO1xcblxcblxcdFxcdFxcdHRoaXMuYWxwaGFUZXN0ID0gc291cmNlLmFscGhhVGVzdDtcXG5cXHRcXHRcXHR0aGlzLnByZW11bHRpcGxpZWRBbHBoYSA9IHNvdXJjZS5wcmVtdWx0aXBsaWVkQWxwaGE7XFxuXFxuXFx0XFx0XFx0dGhpcy5vdmVyZHJhdyA9IHNvdXJjZS5vdmVyZHJhdztcXG5cXG5cXHRcXHRcXHR0aGlzLnZpc2libGUgPSBzb3VyY2UudmlzaWJsZTtcXG5cXHRcXHRcXHR0aGlzLnVzZXJEYXRhID0gSlNPTi5wYXJzZSggSlNPTi5zdHJpbmdpZnkoIHNvdXJjZS51c2VyRGF0YSApICk7XFxuXFxuXFx0XFx0XFx0dGhpcy5jbGlwU2hhZG93cyA9IHNvdXJjZS5jbGlwU2hhZG93cztcXG5cXHRcXHRcXHR0aGlzLmNsaXBJbnRlcnNlY3Rpb24gPSBzb3VyY2UuY2xpcEludGVyc2VjdGlvbjtcXG5cXG5cXHRcXHRcXHR2YXIgc3JjUGxhbmVzID0gc291cmNlLmNsaXBwaW5nUGxhbmVzLFxcblxcdFxcdFxcdFxcdGRzdFBsYW5lcyA9IG51bGw7XFxuXFxuXFx0XFx0XFx0aWYgKCBzcmNQbGFuZXMgIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG4gPSBzcmNQbGFuZXMubGVuZ3RoO1xcblxcdFxcdFxcdFxcdGRzdFBsYW5lcyA9IG5ldyBBcnJheSggbiApO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbjsgKysgaSApXFxuXFx0XFx0XFx0XFx0XFx0ZHN0UGxhbmVzWyBpIF0gPSBzcmNQbGFuZXNbIGkgXS5jbG9uZSgpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLmNsaXBwaW5nUGxhbmVzID0gZHN0UGxhbmVzO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwczovL2NsYXJhLmlvXFxuXFx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XFxuXFx0ICpcXG5cXHQgKiBwYXJhbWV0ZXJzID0ge1xcblxcdCAqXFxuXFx0ICogIG9wYWNpdHk6IDxmbG9hdD4sXFxuXFx0ICpcXG5cXHQgKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqXFxuXFx0ICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqXFxuXFx0ICogIGRpc3BsYWNlbWVudE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXG5cXHQgKiAgZGlzcGxhY2VtZW50U2NhbGU6IDxmbG9hdD4sXFxuXFx0ICogIGRpc3BsYWNlbWVudEJpYXM6IDxmbG9hdD4sXFxuXFx0ICpcXG5cXHQgKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXFxuXFx0ICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PlxcblxcdCAqIH1cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBNZXNoRGVwdGhNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcXG5cXG5cXHRcXHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ01lc2hEZXB0aE1hdGVyaWFsJztcXG5cXG5cXHRcXHR0aGlzLmRlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nO1xcblxcblxcdFxcdHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xcblxcblxcdFxcdHRoaXMubWFwID0gbnVsbDtcXG5cXG5cXHRcXHR0aGlzLmFscGhhTWFwID0gbnVsbDtcXG5cXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcXG5cXG5cXHRcXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcXG5cXG5cXHRcXHR0aGlzLmZvZyA9IGZhbHNlO1xcblxcdFxcdHRoaXMubGlnaHRzID0gZmFsc2U7XFxuXFxuXFx0XFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcXG5cXG5cXHR9XFxuXFxuXFx0TWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XFxuXFx0TWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWVzaERlcHRoTWF0ZXJpYWw7XFxuXFxuXFx0TWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaERlcHRoTWF0ZXJpYWwgPSB0cnVlO1xcblxcblxcdE1lc2hEZXB0aE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxuXFxuXFx0XFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxuXFxuXFx0XFx0dGhpcy5kZXB0aFBhY2tpbmcgPSBzb3VyY2UuZGVwdGhQYWNraW5nO1xcblxcblxcdFxcdHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XFxuXFx0XFx0dGhpcy5tb3JwaFRhcmdldHMgPSBzb3VyY2UubW9ycGhUYXJnZXRzO1xcblxcblxcdFxcdHRoaXMubWFwID0gc291cmNlLm1hcDtcXG5cXG5cXHRcXHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xcblxcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xcblxcblxcdFxcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcXG5cXHQgKlxcblxcdCAqIHBhcmFtZXRlcnMgPSB7XFxuXFx0ICpcXG5cXHQgKiAgcmVmZXJlbmNlUG9zaXRpb246IDxmbG9hdD4sXFxuXFx0ICogIG5lYXJEaXN0YW5jZTogPGZsb2F0PixcXG5cXHQgKiAgZmFyRGlzdGFuY2U6IDxmbG9hdD4sXFxuXFx0ICpcXG5cXHQgKiAgc2tpbm5pbmc6IDxib29sPixcXG5cXHQgKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXFxuXFx0ICpcXG5cXHQgKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqXFxuXFx0ICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqXFxuXFx0ICogIGRpc3BsYWNlbWVudE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXG5cXHQgKiAgZGlzcGxhY2VtZW50U2NhbGU6IDxmbG9hdD4sXFxuXFx0ICogIGRpc3BsYWNlbWVudEJpYXM6IDxmbG9hdD5cXG5cXHQgKlxcblxcdCAqIH1cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBNZXNoRGlzdGFuY2VNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcXG5cXG5cXHRcXHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ01lc2hEaXN0YW5jZU1hdGVyaWFsJztcXG5cXG5cXHRcXHR0aGlzLnJlZmVyZW5jZVBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHR0aGlzLm5lYXJEaXN0YW5jZSA9IDE7XFxuXFx0XFx0dGhpcy5mYXJEaXN0YW5jZSA9IDEwMDA7XFxuXFxuXFx0XFx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xcblxcdFxcdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XFxuXFxuXFx0XFx0dGhpcy5tYXAgPSBudWxsO1xcblxcblxcdFxcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xcblxcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xcblxcblxcdFxcdHRoaXMuZm9nID0gZmFsc2U7XFxuXFx0XFx0dGhpcy5saWdodHMgPSBmYWxzZTtcXG5cXG5cXHRcXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xcblxcblxcdH1cXG5cXG5cXHRNZXNoRGlzdGFuY2VNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXRlcmlhbC5wcm90b3R5cGUgKTtcXG5cXHRNZXNoRGlzdGFuY2VNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNZXNoRGlzdGFuY2VNYXRlcmlhbDtcXG5cXG5cXHRNZXNoRGlzdGFuY2VNYXRlcmlhbC5wcm90b3R5cGUuaXNNZXNoRGlzdGFuY2VNYXRlcmlhbCA9IHRydWU7XFxuXFxuXFx0TWVzaERpc3RhbmNlTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXG5cXG5cXHRcXHR0aGlzLnJlZmVyZW5jZVBvc2l0aW9uLmNvcHkoIHNvdXJjZS5yZWZlcmVuY2VQb3NpdGlvbiApO1xcblxcdFxcdHRoaXMubmVhckRpc3RhbmNlID0gc291cmNlLm5lYXJEaXN0YW5jZTtcXG5cXHRcXHR0aGlzLmZhckRpc3RhbmNlID0gc291cmNlLmZhckRpc3RhbmNlO1xcblxcblxcdFxcdHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XFxuXFx0XFx0dGhpcy5tb3JwaFRhcmdldHMgPSBzb3VyY2UubW9ycGhUYXJnZXRzO1xcblxcblxcdFxcdHRoaXMubWFwID0gc291cmNlLm1hcDtcXG5cXG5cXHRcXHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xcblxcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xcblxcdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEJveDMoIG1pbiwgbWF4ICkge1xcblxcblxcdFxcdHRoaXMubWluID0gKCBtaW4gIT09IHVuZGVmaW5lZCApID8gbWluIDogbmV3IFZlY3RvcjMoICsgSW5maW5pdHksICsgSW5maW5pdHksICsgSW5maW5pdHkgKTtcXG5cXHRcXHR0aGlzLm1heCA9ICggbWF4ICE9PSB1bmRlZmluZWQgKSA/IG1heCA6IG5ldyBWZWN0b3IzKCAtIEluZmluaXR5LCAtIEluZmluaXR5LCAtIEluZmluaXR5ICk7XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5hc3NpZ24oIEJveDMucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0aXNCb3gzOiB0cnVlLFxcblxcblxcdFxcdHNldDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm1pbi5jb3B5KCBtaW4gKTtcXG5cXHRcXHRcXHR0aGlzLm1heC5jb3B5KCBtYXggKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldEZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgbWluWCA9ICsgSW5maW5pdHk7XFxuXFx0XFx0XFx0dmFyIG1pblkgPSArIEluZmluaXR5O1xcblxcdFxcdFxcdHZhciBtaW5aID0gKyBJbmZpbml0eTtcXG5cXG5cXHRcXHRcXHR2YXIgbWF4WCA9IC0gSW5maW5pdHk7XFxuXFx0XFx0XFx0dmFyIG1heFkgPSAtIEluZmluaXR5O1xcblxcdFxcdFxcdHZhciBtYXhaID0gLSBJbmZpbml0eTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHggPSBhcnJheVsgaSBdO1xcblxcdFxcdFxcdFxcdHZhciB5ID0gYXJyYXlbIGkgKyAxIF07XFxuXFx0XFx0XFx0XFx0dmFyIHogPSBhcnJheVsgaSArIDIgXTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHggPCBtaW5YICkgbWluWCA9IHg7XFxuXFx0XFx0XFx0XFx0aWYgKCB5IDwgbWluWSApIG1pblkgPSB5O1xcblxcdFxcdFxcdFxcdGlmICggeiA8IG1pblogKSBtaW5aID0gejtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHggPiBtYXhYICkgbWF4WCA9IHg7XFxuXFx0XFx0XFx0XFx0aWYgKCB5ID4gbWF4WSApIG1heFkgPSB5O1xcblxcdFxcdFxcdFxcdGlmICggeiA+IG1heFogKSBtYXhaID0gejtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5taW4uc2V0KCBtaW5YLCBtaW5ZLCBtaW5aICk7XFxuXFx0XFx0XFx0dGhpcy5tYXguc2V0KCBtYXhYLCBtYXhZLCBtYXhaICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRGcm9tQnVmZmVyQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgbWluWCA9ICsgSW5maW5pdHk7XFxuXFx0XFx0XFx0dmFyIG1pblkgPSArIEluZmluaXR5O1xcblxcdFxcdFxcdHZhciBtaW5aID0gKyBJbmZpbml0eTtcXG5cXG5cXHRcXHRcXHR2YXIgbWF4WCA9IC0gSW5maW5pdHk7XFxuXFx0XFx0XFx0dmFyIG1heFkgPSAtIEluZmluaXR5O1xcblxcdFxcdFxcdHZhciBtYXhaID0gLSBJbmZpbml0eTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhdHRyaWJ1dGUuY291bnQ7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB4ID0gYXR0cmlidXRlLmdldFgoIGkgKTtcXG5cXHRcXHRcXHRcXHR2YXIgeSA9IGF0dHJpYnV0ZS5nZXRZKCBpICk7XFxuXFx0XFx0XFx0XFx0dmFyIHogPSBhdHRyaWJ1dGUuZ2V0WiggaSApO1xcblxcblxcdFxcdFxcdFxcdGlmICggeCA8IG1pblggKSBtaW5YID0geDtcXG5cXHRcXHRcXHRcXHRpZiAoIHkgPCBtaW5ZICkgbWluWSA9IHk7XFxuXFx0XFx0XFx0XFx0aWYgKCB6IDwgbWluWiApIG1pblogPSB6O1xcblxcblxcdFxcdFxcdFxcdGlmICggeCA+IG1heFggKSBtYXhYID0geDtcXG5cXHRcXHRcXHRcXHRpZiAoIHkgPiBtYXhZICkgbWF4WSA9IHk7XFxuXFx0XFx0XFx0XFx0aWYgKCB6ID4gbWF4WiApIG1heFogPSB6O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLm1pbi5zZXQoIG1pblgsIG1pblksIG1pblogKTtcXG5cXHRcXHRcXHR0aGlzLm1heC5zZXQoIG1heFgsIG1heFksIG1heFogKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICggcG9pbnRzICkge1xcblxcblxcdFxcdFxcdHRoaXMubWFrZUVtcHR5KCk7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmV4cGFuZEJ5UG9pbnQoIHBvaW50c1sgaSBdICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0RnJvbUNlbnRlckFuZFNpemU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBzZXRGcm9tQ2VudGVyQW5kU2l6ZSggY2VudGVyLCBzaXplICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBoYWxmU2l6ZSA9IHYxLmNvcHkoIHNpemUgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5taW4uY29weSggY2VudGVyICkuc3ViKCBoYWxmU2l6ZSApO1xcblxcdFxcdFxcdFxcdHRoaXMubWF4LmNvcHkoIGNlbnRlciApLmFkZCggaGFsZlNpemUgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRzZXRGcm9tT2JqZWN0OiBmdW5jdGlvbiAoIG9iamVjdCApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm1ha2VFbXB0eSgpO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmV4cGFuZEJ5T2JqZWN0KCBvYmplY3QgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBib3ggKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5taW4uY29weSggYm94Lm1pbiApO1xcblxcdFxcdFxcdHRoaXMubWF4LmNvcHkoIGJveC5tYXggKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG1ha2VFbXB0eTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMubWluLnggPSB0aGlzLm1pbi55ID0gdGhpcy5taW4ueiA9ICsgSW5maW5pdHk7XFxuXFx0XFx0XFx0dGhpcy5tYXgueCA9IHRoaXMubWF4LnkgPSB0aGlzLm1heC56ID0gLSBJbmZpbml0eTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGlzRW1wdHk6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHQvLyB0aGlzIGlzIGEgbW9yZSByb2J1c3QgY2hlY2sgZm9yIGVtcHR5IHRoYW4gKCB2b2x1bWUgPD0gMCApIGJlY2F1c2Ugdm9sdW1lIGNhbiBnZXQgcG9zaXRpdmUgd2l0aCB0d28gbmVnYXRpdmUgYXhlc1xcblxcblxcdFxcdFxcdHJldHVybiAoIHRoaXMubWF4LnggPCB0aGlzLm1pbi54ICkgfHwgKCB0aGlzLm1heC55IDwgdGhpcy5taW4ueSApIHx8ICggdGhpcy5tYXgueiA8IHRoaXMubWluLnogKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldENlbnRlcjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyByZXN1bHQuc2V0KCAwLCAwLCAwICkgOiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5taW4sIHRoaXMubWF4ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0U2l6ZTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyByZXN1bHQuc2V0KCAwLCAwLCAwICkgOiByZXN1bHQuc3ViVmVjdG9ycyggdGhpcy5tYXgsIHRoaXMubWluICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRleHBhbmRCeVBvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xcblxcblxcdFxcdFxcdHRoaXMubWluLm1pbiggcG9pbnQgKTtcXG5cXHRcXHRcXHR0aGlzLm1heC5tYXgoIHBvaW50ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRleHBhbmRCeVZlY3RvcjogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5taW4uc3ViKCB2ZWN0b3IgKTtcXG5cXHRcXHRcXHR0aGlzLm1heC5hZGQoIHZlY3RvciApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZXhwYW5kQnlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xcblxcblxcdFxcdFxcdHRoaXMubWluLmFkZFNjYWxhciggLSBzY2FsYXIgKTtcXG5cXHRcXHRcXHR0aGlzLm1heC5hZGRTY2FsYXIoIHNjYWxhciApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZXhwYW5kQnlPYmplY3Q6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHQvLyBDb21wdXRlcyB0aGUgd29ybGQtYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveCBvZiBhbiBvYmplY3QgKGluY2x1ZGluZyBpdHMgY2hpbGRyZW4pLFxcblxcdFxcdFxcdC8vIGFjY291bnRpbmcgZm9yIGJvdGggdGhlIG9iamVjdCdzLCBhbmQgY2hpbGRyZW4ncywgd29ybGQgdHJhbnNmb3Jtc1xcblxcblxcdFxcdFxcdHZhciBzY29wZSwgaSwgbDtcXG5cXG5cXHRcXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdGZ1bmN0aW9uIHRyYXZlcnNlKCBub2RlICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBnZW9tZXRyeSA9IG5vZGUuZ2VvbWV0cnk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cnkuaXNHZW9tZXRyeSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCBpID0gMCwgbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0djEuY29weSggdmVydGljZXNbIGkgXSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHYxLmFwcGx5TWF0cml4NCggbm9kZS5tYXRyaXhXb3JsZCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNjb3BlLmV4cGFuZEJ5UG9pbnQoIHYxICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCBpID0gMCwgbCA9IGF0dHJpYnV0ZS5jb3VudDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0djEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpICkuYXBwbHlNYXRyaXg0KCBub2RlLm1hdHJpeFdvcmxkICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0c2NvcGUuZXhwYW5kQnlQb2ludCggdjEgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBleHBhbmRCeU9iamVjdCggb2JqZWN0ICkge1xcblxcblxcdFxcdFxcdFxcdHNjb3BlID0gdGhpcztcXG5cXG5cXHRcXHRcXHRcXHRvYmplY3QudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcXG5cXG5cXHRcXHRcXHRcXHRvYmplY3QudHJhdmVyc2UoIHRyYXZlcnNlICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gcG9pbnQueCA8IHRoaXMubWluLnggfHwgcG9pbnQueCA+IHRoaXMubWF4LnggfHxcXG5cXHRcXHRcXHRcXHRwb2ludC55IDwgdGhpcy5taW4ueSB8fCBwb2ludC55ID4gdGhpcy5tYXgueSB8fFxcblxcdFxcdFxcdFxcdHBvaW50LnogPCB0aGlzLm1pbi56IHx8IHBvaW50LnogPiB0aGlzLm1heC56ID8gZmFsc2UgOiB0cnVlO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29udGFpbnNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLm1pbi54IDw9IGJveC5taW4ueCAmJiBib3gubWF4LnggPD0gdGhpcy5tYXgueCAmJlxcblxcdFxcdFxcdFxcdHRoaXMubWluLnkgPD0gYm94Lm1pbi55ICYmIGJveC5tYXgueSA8PSB0aGlzLm1heC55ICYmXFxuXFx0XFx0XFx0XFx0dGhpcy5taW4ueiA8PSBib3gubWluLnogJiYgYm94Lm1heC56IDw9IHRoaXMubWF4Lno7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRQYXJhbWV0ZXI6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdC8vIFRoaXMgY2FuIHBvdGVudGlhbGx5IGhhdmUgYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgYm94XFxuXFx0XFx0XFx0Ly8gaGFzIGEgc2l6ZSBkaW1lbnNpb24gb2YgMC5cXG5cXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0LnNldChcXG5cXHRcXHRcXHRcXHQoIHBvaW50LnggLSB0aGlzLm1pbi54ICkgLyAoIHRoaXMubWF4LnggLSB0aGlzLm1pbi54ICksXFxuXFx0XFx0XFx0XFx0KCBwb2ludC55IC0gdGhpcy5taW4ueSApIC8gKCB0aGlzLm1heC55IC0gdGhpcy5taW4ueSApLFxcblxcdFxcdFxcdFxcdCggcG9pbnQueiAtIHRoaXMubWluLnogKSAvICggdGhpcy5tYXgueiAtIHRoaXMubWluLnogKVxcblxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRpbnRlcnNlY3RzQm94OiBmdW5jdGlvbiAoIGJveCApIHtcXG5cXG5cXHRcXHRcXHQvLyB1c2luZyA2IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9ucy5cXG5cXHRcXHRcXHRyZXR1cm4gYm94Lm1heC54IDwgdGhpcy5taW4ueCB8fCBib3gubWluLnggPiB0aGlzLm1heC54IHx8XFxuXFx0XFx0XFx0XFx0Ym94Lm1heC55IDwgdGhpcy5taW4ueSB8fCBib3gubWluLnkgPiB0aGlzLm1heC55IHx8XFxuXFx0XFx0XFx0XFx0Ym94Lm1heC56IDwgdGhpcy5taW4ueiB8fCBib3gubWluLnogPiB0aGlzLm1heC56ID8gZmFsc2UgOiB0cnVlO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0aW50ZXJzZWN0c1NwaGVyZTogKCBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGNsb3Nlc3RQb2ludCA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBGaW5kIHRoZSBwb2ludCBvbiB0aGUgQUFCQiBjbG9zZXN0IHRvIHRoZSBzcGhlcmUgY2VudGVyLlxcblxcdFxcdFxcdFxcdHRoaXMuY2xhbXBQb2ludCggc3BoZXJlLmNlbnRlciwgY2xvc2VzdFBvaW50ICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSWYgdGhhdCBwb2ludCBpcyBpbnNpZGUgdGhlIHNwaGVyZSwgdGhlIEFBQkIgYW5kIHNwaGVyZSBpbnRlcnNlY3QuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNsb3Nlc3RQb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggc3BoZXJlLmNlbnRlciApIDw9ICggc3BoZXJlLnJhZGl1cyAqIHNwaGVyZS5yYWRpdXMgKTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0gKSgpLFxcblxcblxcdFxcdGludGVyc2VjdHNQbGFuZTogZnVuY3Rpb24gKCBwbGFuZSApIHtcXG5cXG5cXHRcXHRcXHQvLyBXZSBjb21wdXRlIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGRvdCBwcm9kdWN0IHZhbHVlcy4gSWYgdGhvc2UgdmFsdWVzXFxuXFx0XFx0XFx0Ly8gYXJlIG9uIHRoZSBzYW1lIHNpZGUgKGJhY2sgb3IgZnJvbnQpIG9mIHRoZSBwbGFuZSwgdGhlbiB0aGVyZSBpcyBubyBpbnRlcnNlY3Rpb24uXFxuXFxuXFx0XFx0XFx0dmFyIG1pbiwgbWF4O1xcblxcblxcdFxcdFxcdGlmICggcGxhbmUubm9ybWFsLnggPiAwICkge1xcblxcblxcdFxcdFxcdFxcdG1pbiA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5taW4ueDtcXG5cXHRcXHRcXHRcXHRtYXggPSBwbGFuZS5ub3JtYWwueCAqIHRoaXMubWF4Lng7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRtaW4gPSBwbGFuZS5ub3JtYWwueCAqIHRoaXMubWF4Lng7XFxuXFx0XFx0XFx0XFx0bWF4ID0gcGxhbmUubm9ybWFsLnggKiB0aGlzLm1pbi54O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHBsYW5lLm5vcm1hbC55ID4gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRtaW4gKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1pbi55O1xcblxcdFxcdFxcdFxcdG1heCArPSBwbGFuZS5ub3JtYWwueSAqIHRoaXMubWF4Lnk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRtaW4gKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1heC55O1xcblxcdFxcdFxcdFxcdG1heCArPSBwbGFuZS5ub3JtYWwueSAqIHRoaXMubWluLnk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggcGxhbmUubm9ybWFsLnogPiAwICkge1xcblxcblxcdFxcdFxcdFxcdG1pbiArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWluLno7XFxuXFx0XFx0XFx0XFx0bWF4ICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5tYXguejtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdG1pbiArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWF4Lno7XFxuXFx0XFx0XFx0XFx0bWF4ICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5taW4uejtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuICggbWluIDw9IHBsYW5lLmNvbnN0YW50ICYmIG1heCA+PSBwbGFuZS5jb25zdGFudCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xhbXBQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGNsYW1wZWRQb2ludCA9IHYxLmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xcblxcdFxcdFxcdFxcdHJldHVybiBjbGFtcGVkUG9pbnQuc3ViKCBwb2ludCApLmxlbmd0aCgpO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdGdldEJvdW5kaW5nU3BoZXJlOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gZ2V0Qm91bmRpbmdTcGhlcmUoIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgU3BoZXJlKCk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5nZXRDZW50ZXIoIHJlc3VsdC5jZW50ZXIgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXN1bHQucmFkaXVzID0gdGhpcy5nZXRTaXplKCB2MSApLmxlbmd0aCgpICogMC41O1xcblxcblxcdFxcdFxcdFxcdHJldHVybiByZXN1bHQ7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0aW50ZXJzZWN0OiBmdW5jdGlvbiAoIGJveCApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm1pbi5tYXgoIGJveC5taW4gKTtcXG5cXHRcXHRcXHR0aGlzLm1heC5taW4oIGJveC5tYXggKTtcXG5cXG5cXHRcXHRcXHQvLyBlbnN1cmUgdGhhdCBpZiB0aGVyZSBpcyBubyBvdmVybGFwLCB0aGUgcmVzdWx0IGlzIGZ1bGx5IGVtcHR5LCBub3Qgc2xpZ2h0bHkgZW1wdHkgd2l0aCBub24taW5mLytpbmYgdmFsdWVzIHRoYXQgd2lsbCBjYXVzZSBzdWJzZXF1ZW5jZSBpbnRlcnNlY3RzIHRvIGVycm9uZW91c2x5IHJldHVybiB2YWxpZCB2YWx1ZXMuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmlzRW1wdHkoKSApIHRoaXMubWFrZUVtcHR5KCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR1bmlvbjogZnVuY3Rpb24gKCBib3ggKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5taW4ubWluKCBib3gubWluICk7XFxuXFx0XFx0XFx0dGhpcy5tYXgubWF4KCBib3gubWF4ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgcG9pbnRzID0gW1xcblxcdFxcdFxcdFxcdG5ldyBWZWN0b3IzKCksXFxuXFx0XFx0XFx0XFx0bmV3IFZlY3RvcjMoKSxcXG5cXHRcXHRcXHRcXHRuZXcgVmVjdG9yMygpLFxcblxcdFxcdFxcdFxcdG5ldyBWZWN0b3IzKCksXFxuXFx0XFx0XFx0XFx0bmV3IFZlY3RvcjMoKSxcXG5cXHRcXHRcXHRcXHRuZXcgVmVjdG9yMygpLFxcblxcdFxcdFxcdFxcdG5ldyBWZWN0b3IzKCksXFxuXFx0XFx0XFx0XFx0bmV3IFZlY3RvcjMoKVxcblxcdFxcdFxcdF07XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGFwcGx5TWF0cml4NCggbWF0cml4ICkge1xcblxcblxcdFxcdFxcdFxcdC8vIHRyYW5zZm9ybSBvZiBlbXB0eSBib3ggaXMgYW4gZW1wdHkgYm94LlxcblxcdFxcdFxcdFxcdGlmICggdGhpcy5pc0VtcHR5KCkgKSByZXR1cm4gdGhpcztcXG5cXG5cXHRcXHRcXHRcXHQvLyBOT1RFOiBJIGFtIHVzaW5nIGEgYmluYXJ5IHBhdHRlcm4gdG8gc3BlY2lmeSBhbGwgMl4zIGNvbWJpbmF0aW9ucyBiZWxvd1xcblxcdFxcdFxcdFxcdHBvaW50c1sgMCBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5taW4ueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAwMFxcblxcdFxcdFxcdFxcdHBvaW50c1sgMSBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5taW4ueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAwMVxcblxcdFxcdFxcdFxcdHBvaW50c1sgMiBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAxMFxcblxcdFxcdFxcdFxcdHBvaW50c1sgMyBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAxMVxcblxcdFxcdFxcdFxcdHBvaW50c1sgNCBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5taW4ueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDEwMFxcblxcdFxcdFxcdFxcdHBvaW50c1sgNSBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5taW4ueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDEwMVxcblxcdFxcdFxcdFxcdHBvaW50c1sgNiBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDExMFxcblxcdFxcdFxcdFxcdHBvaW50c1sgNyBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5tYXgueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XFx0Ly8gMTExXFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdHRoaXMubWluLmFkZCggb2Zmc2V0ICk7XFxuXFx0XFx0XFx0dGhpcy5tYXguYWRkKCBvZmZzZXQgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGVxdWFsczogZnVuY3Rpb24gKCBib3ggKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGJveC5taW4uZXF1YWxzKCB0aGlzLm1pbiApICYmIGJveC5tYXguZXF1YWxzKCB0aGlzLm1heCApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gU3BoZXJlKCBjZW50ZXIsIHJhZGl1cyApIHtcXG5cXG5cXHRcXHR0aGlzLmNlbnRlciA9ICggY2VudGVyICE9PSB1bmRlZmluZWQgKSA/IGNlbnRlciA6IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0dGhpcy5yYWRpdXMgPSAoIHJhZGl1cyAhPT0gdW5kZWZpbmVkICkgPyByYWRpdXMgOiAwO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBTcGhlcmUucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiAoIGNlbnRlciwgcmFkaXVzICkge1xcblxcblxcdFxcdFxcdHRoaXMuY2VudGVyLmNvcHkoIGNlbnRlciApO1xcblxcdFxcdFxcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0RnJvbVBvaW50czogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBib3ggPSBuZXcgQm94MygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBzZXRGcm9tUG9pbnRzKCBwb2ludHMsIG9wdGlvbmFsQ2VudGVyICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBjZW50ZXIgPSB0aGlzLmNlbnRlcjtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG9wdGlvbmFsQ2VudGVyICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2VudGVyLmNvcHkoIG9wdGlvbmFsQ2VudGVyICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRib3guc2V0RnJvbVBvaW50cyggcG9pbnRzICkuZ2V0Q2VudGVyKCBjZW50ZXIgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG1heFJhZGl1c1NxID0gMDtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50c1sgaSBdICkgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5yYWRpdXMgPSBNYXRoLnNxcnQoIG1heFJhZGl1c1NxICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmNlbnRlci5jb3B5KCBzcGhlcmUuY2VudGVyICk7XFxuXFx0XFx0XFx0dGhpcy5yYWRpdXMgPSBzcGhlcmUucmFkaXVzO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZW1wdHk6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gKCB0aGlzLnJhZGl1cyA8PSAwICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xcblxcblxcdFxcdFxcdHJldHVybiAoIHBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmNlbnRlciApIDw9ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuICggcG9pbnQuZGlzdGFuY2VUbyggdGhpcy5jZW50ZXIgKSAtIHRoaXMucmFkaXVzICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcmFkaXVzU3VtID0gdGhpcy5yYWRpdXMgKyBzcGhlcmUucmFkaXVzO1xcblxcblxcdFxcdFxcdHJldHVybiBzcGhlcmUuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmNlbnRlciApIDw9ICggcmFkaXVzU3VtICogcmFkaXVzU3VtICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRpbnRlcnNlY3RzQm94OiBmdW5jdGlvbiAoIGJveCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gYm94LmludGVyc2VjdHNTcGhlcmUoIHRoaXMgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGludGVyc2VjdHNQbGFuZTogZnVuY3Rpb24gKCBwbGFuZSApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gTWF0aC5hYnMoIHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggdGhpcy5jZW50ZXIgKSApIDw9IHRoaXMucmFkaXVzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xhbXBQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGRlbHRhTGVuZ3RoU3EgPSB0aGlzLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcXG5cXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRyZXN1bHQuY29weSggcG9pbnQgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGRlbHRhTGVuZ3RoU3EgPiAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXN1bHQuc3ViKCB0aGlzLmNlbnRlciApLm5vcm1hbGl6ZSgpO1xcblxcdFxcdFxcdFxcdHJlc3VsdC5tdWx0aXBseVNjYWxhciggdGhpcy5yYWRpdXMgKS5hZGQoIHRoaXMuY2VudGVyICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiByZXN1bHQ7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRCb3VuZGluZ0JveDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYm94ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IEJveDMoKTtcXG5cXG5cXHRcXHRcXHRib3guc2V0KCB0aGlzLmNlbnRlciwgdGhpcy5jZW50ZXIgKTtcXG5cXHRcXHRcXHRib3guZXhwYW5kQnlTY2FsYXIoIHRoaXMucmFkaXVzICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGJveDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5jZW50ZXIuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcXG5cXHRcXHRcXHR0aGlzLnJhZGl1cyA9IHRoaXMucmFkaXVzICogbWF0cml4LmdldE1heFNjYWxlT25BeGlzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdHRoaXMuY2VudGVyLmFkZCggb2Zmc2V0ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRlcXVhbHM6IGZ1bmN0aW9uICggc3BoZXJlICkge1xcblxcblxcdFxcdFxcdHJldHVybiBzcGhlcmUuY2VudGVyLmVxdWFscyggdGhpcy5jZW50ZXIgKSAmJiAoIHNwaGVyZS5yYWRpdXMgPT09IHRoaXMucmFkaXVzICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gUGxhbmUoIG5vcm1hbCwgY29uc3RhbnQgKSB7XFxuXFxuXFx0XFx0Ly8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxcblxcblxcdFxcdHRoaXMubm9ybWFsID0gKCBub3JtYWwgIT09IHVuZGVmaW5lZCApID8gbm9ybWFsIDogbmV3IFZlY3RvcjMoIDEsIDAsIDAgKTtcXG5cXHRcXHR0aGlzLmNvbnN0YW50ID0gKCBjb25zdGFudCAhPT0gdW5kZWZpbmVkICkgPyBjb25zdGFudCA6IDA7XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5hc3NpZ24oIFBsYW5lLnByb3RvdHlwZSwge1xcblxcblxcdFxcdHNldDogZnVuY3Rpb24gKCBub3JtYWwsIGNvbnN0YW50ICkge1xcblxcblxcdFxcdFxcdHRoaXMubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xcblxcdFxcdFxcdHRoaXMuY29uc3RhbnQgPSBjb25zdGFudDtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldENvbXBvbmVudHM6IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm5vcm1hbC5zZXQoIHgsIHksIHogKTtcXG5cXHRcXHRcXHR0aGlzLmNvbnN0YW50ID0gdztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50OiBmdW5jdGlvbiAoIG5vcm1hbCwgcG9pbnQgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5ub3JtYWwuY29weSggbm9ybWFsICk7XFxuXFx0XFx0XFx0dGhpcy5jb25zdGFudCA9IC0gcG9pbnQuZG90KCB0aGlzLm5vcm1hbCApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0RnJvbUNvcGxhbmFyUG9pbnRzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgdjIgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBzZXRGcm9tQ29wbGFuYXJQb2ludHMoIGEsIGIsIGMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG5vcm1hbCA9IHYxLnN1YlZlY3RvcnMoIGMsIGIgKS5jcm9zcyggdjIuc3ViVmVjdG9ycyggYSwgYiApICkubm9ybWFsaXplKCk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUTogc2hvdWxkIGFuIGVycm9yIGJlIHRocm93biBpZiBub3JtYWwgaXMgemVybyAoZS5nLiBkZWdlbmVyYXRlIHBsYW5lKT9cXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KCBub3JtYWwsIGEgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggcGxhbmUgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5ub3JtYWwuY29weSggcGxhbmUubm9ybWFsICk7XFxuXFx0XFx0XFx0dGhpcy5jb25zdGFudCA9IHBsYW5lLmNvbnN0YW50O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Ly8gTm90ZTogd2lsbCBsZWFkIHRvIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIHBsYW5lIGlzIGludmFsaWQuXFxuXFxuXFx0XFx0XFx0dmFyIGludmVyc2VOb3JtYWxMZW5ndGggPSAxLjAgLyB0aGlzLm5vcm1hbC5sZW5ndGgoKTtcXG5cXHRcXHRcXHR0aGlzLm5vcm1hbC5tdWx0aXBseVNjYWxhciggaW52ZXJzZU5vcm1hbExlbmd0aCApO1xcblxcdFxcdFxcdHRoaXMuY29uc3RhbnQgKj0gaW52ZXJzZU5vcm1hbExlbmd0aDtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMuY29uc3RhbnQgKj0gLSAxO1xcblxcdFxcdFxcdHRoaXMubm9ybWFsLm5lZ2F0ZSgpO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLm5vcm1hbC5kb3QoIHBvaW50ICkgKyB0aGlzLmNvbnN0YW50O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGlzdGFuY2VUb1NwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KCBzcGhlcmUuY2VudGVyICkgLSBzcGhlcmUucmFkaXVzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cHJvamVjdFBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMubm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIC0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHBvaW50ICkgKS5hZGQoIHBvaW50ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0TGluZSggbGluZSwgb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGRpcmVjdGlvbiA9IGxpbmUuZGVsdGEoIHYxICk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGRlbm9taW5hdG9yID0gdGhpcy5ub3JtYWwuZG90KCBkaXJlY3Rpb24gKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGRlbm9taW5hdG9yID09PSAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGxpbmUgaXMgY29wbGFuYXIsIHJldHVybiBvcmlnaW5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLnN0YXJ0ICkgPT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBsaW5lLnN0YXJ0ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIFVuc3VyZSBpZiB0aGlzIGlzIHRoZSBjb3JyZWN0IG1ldGhvZCB0byBoYW5kbGUgdGhpcyBjYXNlLlxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB1bmRlZmluZWQ7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHZhciB0ID0gLSAoIGxpbmUuc3RhcnQuZG90KCB0aGlzLm5vcm1hbCApICsgdGhpcy5jb25zdGFudCApIC8gZGVub21pbmF0b3I7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB0IDwgMCB8fCB0ID4gMSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdW5kZWZpbmVkO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0LmNvcHkoIGRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCBsaW5lLnN0YXJ0ICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0aW50ZXJzZWN0c0xpbmU6IGZ1bmN0aW9uICggbGluZSApIHtcXG5cXG5cXHRcXHRcXHQvLyBOb3RlOiB0aGlzIHRlc3RzIGlmIGEgbGluZSBpbnRlcnNlY3RzIHRoZSBwbGFuZSwgbm90IHdoZXRoZXIgaXQgKG9yIGl0cyBlbmQtcG9pbnRzKSBhcmUgY29wbGFuYXIgd2l0aCBpdC5cXG5cXG5cXHRcXHRcXHR2YXIgc3RhcnRTaWduID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIGxpbmUuc3RhcnQgKTtcXG5cXHRcXHRcXHR2YXIgZW5kU2lnbiA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLmVuZCApO1xcblxcblxcdFxcdFxcdHJldHVybiAoIHN0YXJ0U2lnbiA8IDAgJiYgZW5kU2lnbiA+IDAgKSB8fCAoIGVuZFNpZ24gPCAwICYmIHN0YXJ0U2lnbiA+IDAgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGludGVyc2VjdHNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xcblxcblxcdFxcdFxcdHJldHVybiBib3guaW50ZXJzZWN0c1BsYW5lKCB0aGlzICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gc3BoZXJlLmludGVyc2VjdHNQbGFuZSggdGhpcyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29wbGFuYXJQb2ludDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMubm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIC0gdGhpcy5jb25zdGFudCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgbTEgPSBuZXcgTWF0cml4MygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBhcHBseU1hdHJpeDQoIG1hdHJpeCwgb3B0aW9uYWxOb3JtYWxNYXRyaXggKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG5vcm1hbE1hdHJpeCA9IG9wdGlvbmFsTm9ybWFsTWF0cml4IHx8IG0xLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHJlZmVyZW5jZVBvaW50ID0gdGhpcy5jb3BsYW5hclBvaW50KCB2MSApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG5vcm1hbCA9IHRoaXMubm9ybWFsLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5jb25zdGFudCA9IC0gcmVmZXJlbmNlUG9pbnQuZG90KCBub3JtYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdHRoaXMuY29uc3RhbnQgLT0gb2Zmc2V0LmRvdCggdGhpcy5ub3JtYWwgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGVxdWFsczogZnVuY3Rpb24gKCBwbGFuZSApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gcGxhbmUubm9ybWFsLmVxdWFscyggdGhpcy5ub3JtYWwgKSAmJiAoIHBsYW5lLmNvbnN0YW50ID09PSB0aGlzLmNvbnN0YW50ICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEZydXN0dW0oIHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUgKSB7XFxuXFxuXFx0XFx0dGhpcy5wbGFuZXMgPSBbXFxuXFxuXFx0XFx0XFx0KCBwMCAhPT0gdW5kZWZpbmVkICkgPyBwMCA6IG5ldyBQbGFuZSgpLFxcblxcdFxcdFxcdCggcDEgIT09IHVuZGVmaW5lZCApID8gcDEgOiBuZXcgUGxhbmUoKSxcXG5cXHRcXHRcXHQoIHAyICE9PSB1bmRlZmluZWQgKSA/IHAyIDogbmV3IFBsYW5lKCksXFxuXFx0XFx0XFx0KCBwMyAhPT0gdW5kZWZpbmVkICkgPyBwMyA6IG5ldyBQbGFuZSgpLFxcblxcdFxcdFxcdCggcDQgIT09IHVuZGVmaW5lZCApID8gcDQgOiBuZXcgUGxhbmUoKSxcXG5cXHRcXHRcXHQoIHA1ICE9PSB1bmRlZmluZWQgKSA/IHA1IDogbmV3IFBsYW5lKClcXG5cXG5cXHRcXHRdO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBGcnVzdHVtLnByb3RvdHlwZSwge1xcblxcblxcdFxcdHNldDogZnVuY3Rpb24gKCBwMCwgcDEsIHAyLCBwMywgcDQsIHA1ICkge1xcblxcblxcdFxcdFxcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcXG5cXG5cXHRcXHRcXHRwbGFuZXNbIDAgXS5jb3B5KCBwMCApO1xcblxcdFxcdFxcdHBsYW5lc1sgMSBdLmNvcHkoIHAxICk7XFxuXFx0XFx0XFx0cGxhbmVzWyAyIF0uY29weSggcDIgKTtcXG5cXHRcXHRcXHRwbGFuZXNbIDMgXS5jb3B5KCBwMyApO1xcblxcdFxcdFxcdHBsYW5lc1sgNCBdLmNvcHkoIHA0ICk7XFxuXFx0XFx0XFx0cGxhbmVzWyA1IF0uY29weSggcDUgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBmcnVzdHVtICkge1xcblxcblxcdFxcdFxcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHBsYW5lc1sgaSBdLmNvcHkoIGZydXN0dW0ucGxhbmVzWyBpIF0gKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRGcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xcblxcdFxcdFxcdHZhciBtZSA9IG0uZWxlbWVudHM7XFxuXFx0XFx0XFx0dmFyIG1lMCA9IG1lWyAwIF0sIG1lMSA9IG1lWyAxIF0sIG1lMiA9IG1lWyAyIF0sIG1lMyA9IG1lWyAzIF07XFxuXFx0XFx0XFx0dmFyIG1lNCA9IG1lWyA0IF0sIG1lNSA9IG1lWyA1IF0sIG1lNiA9IG1lWyA2IF0sIG1lNyA9IG1lWyA3IF07XFxuXFx0XFx0XFx0dmFyIG1lOCA9IG1lWyA4IF0sIG1lOSA9IG1lWyA5IF0sIG1lMTAgPSBtZVsgMTAgXSwgbWUxMSA9IG1lWyAxMSBdO1xcblxcdFxcdFxcdHZhciBtZTEyID0gbWVbIDEyIF0sIG1lMTMgPSBtZVsgMTMgXSwgbWUxNCA9IG1lWyAxNCBdLCBtZTE1ID0gbWVbIDE1IF07XFxuXFxuXFx0XFx0XFx0cGxhbmVzWyAwIF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUwLCBtZTcgLSBtZTQsIG1lMTEgLSBtZTgsIG1lMTUgLSBtZTEyICkubm9ybWFsaXplKCk7XFxuXFx0XFx0XFx0cGxhbmVzWyAxIF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUwLCBtZTcgKyBtZTQsIG1lMTEgKyBtZTgsIG1lMTUgKyBtZTEyICkubm9ybWFsaXplKCk7XFxuXFx0XFx0XFx0cGxhbmVzWyAyIF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUxLCBtZTcgKyBtZTUsIG1lMTEgKyBtZTksIG1lMTUgKyBtZTEzICkubm9ybWFsaXplKCk7XFxuXFx0XFx0XFx0cGxhbmVzWyAzIF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUxLCBtZTcgLSBtZTUsIG1lMTEgLSBtZTksIG1lMTUgLSBtZTEzICkubm9ybWFsaXplKCk7XFxuXFx0XFx0XFx0cGxhbmVzWyA0IF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUyLCBtZTcgLSBtZTYsIG1lMTEgLSBtZTEwLCBtZTE1IC0gbWUxNCApLm5vcm1hbGl6ZSgpO1xcblxcdFxcdFxcdHBsYW5lc1sgNSBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMiwgbWU3ICsgbWU2LCBtZTExICsgbWUxMCwgbWUxNSArIG1lMTQgKS5ub3JtYWxpemUoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGludGVyc2VjdHNPYmplY3Q6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgc3BoZXJlID0gbmV3IFNwaGVyZSgpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RzT2JqZWN0KCBvYmplY3QgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xcblxcblxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKVxcblxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xcblxcblxcdFxcdFxcdFxcdHNwaGVyZS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApXFxuXFx0XFx0XFx0XFx0XFx0LmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0aW50ZXJzZWN0c1Nwcml0ZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBzcGhlcmUgPSBuZXcgU3BoZXJlKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdHNTcHJpdGUoIHNwcml0ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRzcGhlcmUuY2VudGVyLnNldCggMCwgMCwgMCApO1xcblxcdFxcdFxcdFxcdHNwaGVyZS5yYWRpdXMgPSAwLjcwNzEwNjc4MTE4NjU0NzY7XFxuXFx0XFx0XFx0XFx0c3BoZXJlLmFwcGx5TWF0cml4NCggc3ByaXRlLm1hdHJpeFdvcmxkICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0aW50ZXJzZWN0c1NwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xcblxcdFxcdFxcdHZhciBjZW50ZXIgPSBzcGhlcmUuY2VudGVyO1xcblxcdFxcdFxcdHZhciBuZWdSYWRpdXMgPSAtIHNwaGVyZS5yYWRpdXM7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZGlzdGFuY2UgPSBwbGFuZXNbIGkgXS5kaXN0YW5jZVRvUG9pbnQoIGNlbnRlciApO1xcblxcblxcdFxcdFxcdFxcdGlmICggZGlzdGFuY2UgPCBuZWdSYWRpdXMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRpbnRlcnNlY3RzQm94OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHAxID0gbmV3IFZlY3RvcjMoKSxcXG5cXHRcXHRcXHRcXHRwMiA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdHNCb3goIGJveCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgcGxhbmUgPSBwbGFuZXNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRwMS54ID0gcGxhbmUubm9ybWFsLnggPiAwID8gYm94Lm1pbi54IDogYm94Lm1heC54O1xcblxcdFxcdFxcdFxcdFxcdHAyLnggPSBwbGFuZS5ub3JtYWwueCA+IDAgPyBib3gubWF4LnggOiBib3gubWluLng7XFxuXFx0XFx0XFx0XFx0XFx0cDEueSA9IHBsYW5lLm5vcm1hbC55ID4gMCA/IGJveC5taW4ueSA6IGJveC5tYXgueTtcXG5cXHRcXHRcXHRcXHRcXHRwMi55ID0gcGxhbmUubm9ybWFsLnkgPiAwID8gYm94Lm1heC55IDogYm94Lm1pbi55O1xcblxcdFxcdFxcdFxcdFxcdHAxLnogPSBwbGFuZS5ub3JtYWwueiA+IDAgPyBib3gubWluLnogOiBib3gubWF4Lno7XFxuXFx0XFx0XFx0XFx0XFx0cDIueiA9IHBsYW5lLm5vcm1hbC56ID4gMCA/IGJveC5tYXgueiA6IGJveC5taW4uejtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgZDEgPSBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHAxICk7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGQyID0gcGxhbmUuZGlzdGFuY2VUb1BvaW50KCBwMiApO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGlmIGJvdGggb3V0c2lkZSBwbGFuZSwgbm8gaW50ZXJzZWN0aW9uXFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkMSA8IDAgJiYgZDIgPCAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBwbGFuZXNbIGkgXS5kaXN0YW5jZVRvUG9pbnQoIHBvaW50ICkgPCAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFdlYkdMU2hhZG93TWFwKCBfcmVuZGVyZXIsIF9vYmplY3RzLCBtYXhUZXh0dXJlU2l6ZSApIHtcXG5cXG5cXHRcXHR2YXIgX2ZydXN0dW0gPSBuZXcgRnJ1c3R1bSgpLFxcblxcdFxcdFxcdF9wcm9qU2NyZWVuTWF0cml4ID0gbmV3IE1hdHJpeDQoKSxcXG5cXG5cXHRcXHRcXHRfc2hhZG93TWFwU2l6ZSA9IG5ldyBWZWN0b3IyKCksXFxuXFx0XFx0XFx0X21heFNoYWRvd01hcFNpemUgPSBuZXcgVmVjdG9yMiggbWF4VGV4dHVyZVNpemUsIG1heFRleHR1cmVTaXplICksXFxuXFxuXFx0XFx0XFx0X2xvb2tUYXJnZXQgPSBuZXcgVmVjdG9yMygpLFxcblxcdFxcdFxcdF9saWdodFBvc2l0aW9uV29ybGQgPSBuZXcgVmVjdG9yMygpLFxcblxcblxcdFxcdFxcdF9Nb3JwaGluZ0ZsYWcgPSAxLFxcblxcdFxcdFxcdF9Ta2lubmluZ0ZsYWcgPSAyLFxcblxcblxcdFxcdFxcdF9OdW1iZXJPZk1hdGVyaWFsVmFyaWFudHMgPSAoIF9Nb3JwaGluZ0ZsYWcgfCBfU2tpbm5pbmdGbGFnICkgKyAxLFxcblxcblxcdFxcdFxcdF9kZXB0aE1hdGVyaWFscyA9IG5ldyBBcnJheSggX051bWJlck9mTWF0ZXJpYWxWYXJpYW50cyApLFxcblxcdFxcdFxcdF9kaXN0YW5jZU1hdGVyaWFscyA9IG5ldyBBcnJheSggX051bWJlck9mTWF0ZXJpYWxWYXJpYW50cyApLFxcblxcblxcdFxcdFxcdF9tYXRlcmlhbENhY2hlID0ge307XFxuXFxuXFx0XFx0dmFyIGN1YmVEaXJlY3Rpb25zID0gW1xcblxcdFxcdFxcdG5ldyBWZWN0b3IzKCAxLCAwLCAwICksIG5ldyBWZWN0b3IzKCAtIDEsIDAsIDAgKSwgbmV3IFZlY3RvcjMoIDAsIDAsIDEgKSxcXG5cXHRcXHRcXHRuZXcgVmVjdG9yMyggMCwgMCwgLSAxICksIG5ldyBWZWN0b3IzKCAwLCAxLCAwICksIG5ldyBWZWN0b3IzKCAwLCAtIDEsIDAgKVxcblxcdFxcdF07XFxuXFxuXFx0XFx0dmFyIGN1YmVVcHMgPSBbXFxuXFx0XFx0XFx0bmV3IFZlY3RvcjMoIDAsIDEsIDAgKSwgbmV3IFZlY3RvcjMoIDAsIDEsIDAgKSwgbmV3IFZlY3RvcjMoIDAsIDEsIDAgKSxcXG5cXHRcXHRcXHRuZXcgVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVmVjdG9yMyggMCwgMCwgMSApLFxcdG5ldyBWZWN0b3IzKCAwLCAwLCAtIDEgKVxcblxcdFxcdF07XFxuXFxuXFx0XFx0dmFyIGN1YmUyRFZpZXdQb3J0cyA9IFtcXG5cXHRcXHRcXHRuZXcgVmVjdG9yNCgpLCBuZXcgVmVjdG9yNCgpLCBuZXcgVmVjdG9yNCgpLFxcblxcdFxcdFxcdG5ldyBWZWN0b3I0KCksIG5ldyBWZWN0b3I0KCksIG5ldyBWZWN0b3I0KClcXG5cXHRcXHRdO1xcblxcblxcdFxcdC8vIGluaXRcXG5cXG5cXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IF9OdW1iZXJPZk1hdGVyaWFsVmFyaWFudHM7ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHVzZU1vcnBoaW5nID0gKCBpICYgX01vcnBoaW5nRmxhZyApICE9PSAwO1xcblxcdFxcdFxcdHZhciB1c2VTa2lubmluZyA9ICggaSAmIF9Ta2lubmluZ0ZsYWcgKSAhPT0gMDtcXG5cXG5cXHRcXHRcXHR2YXIgZGVwdGhNYXRlcmlhbCA9IG5ldyBNZXNoRGVwdGhNYXRlcmlhbCgge1xcblxcblxcdFxcdFxcdFxcdGRlcHRoUGFja2luZzogUkdCQURlcHRoUGFja2luZyxcXG5cXG5cXHRcXHRcXHRcXHRtb3JwaFRhcmdldHM6IHVzZU1vcnBoaW5nLFxcblxcdFxcdFxcdFxcdHNraW5uaW5nOiB1c2VTa2lubmluZ1xcblxcblxcdFxcdFxcdH0gKTtcXG5cXG5cXHRcXHRcXHRfZGVwdGhNYXRlcmlhbHNbIGkgXSA9IGRlcHRoTWF0ZXJpYWw7XFxuXFxuXFx0XFx0XFx0Ly9cXG5cXG5cXHRcXHRcXHR2YXIgZGlzdGFuY2VNYXRlcmlhbCA9IG5ldyBNZXNoRGlzdGFuY2VNYXRlcmlhbCgge1xcblxcblxcdFxcdFxcdFxcdG1vcnBoVGFyZ2V0czogdXNlTW9ycGhpbmcsXFxuXFx0XFx0XFx0XFx0c2tpbm5pbmc6IHVzZVNraW5uaW5nXFxuXFxuXFx0XFx0XFx0fSApO1xcblxcblxcdFxcdFxcdF9kaXN0YW5jZU1hdGVyaWFsc1sgaSBdID0gZGlzdGFuY2VNYXRlcmlhbDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly9cXG5cXG5cXHRcXHR2YXIgc2NvcGUgPSB0aGlzO1xcblxcblxcdFxcdHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xcblxcblxcdFxcdHRoaXMuYXV0b1VwZGF0ZSA9IHRydWU7XFxuXFx0XFx0dGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xcblxcblxcdFxcdHRoaXMudHlwZSA9IFBDRlNoYWRvd01hcDtcXG5cXG5cXHRcXHR0aGlzLnJlbmRlclJldmVyc2VTaWRlZCA9IHRydWU7XFxuXFx0XFx0dGhpcy5yZW5kZXJTaW5nbGVTaWRlZCA9IHRydWU7XFxuXFxuXFx0XFx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIGxpZ2h0cywgc2NlbmUsIGNhbWVyYSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xcblxcdFxcdFxcdGlmICggc2NvcGUuYXV0b1VwZGF0ZSA9PT0gZmFsc2UgJiYgc2NvcGUubmVlZHNVcGRhdGUgPT09IGZhbHNlICkgcmV0dXJuO1xcblxcblxcdFxcdFxcdGlmICggbGlnaHRzLmxlbmd0aCA9PT0gMCApIHJldHVybjtcXG5cXG5cXHRcXHRcXHQvLyBUT0RPIENsZWFuIHVwIChuZWVkZWQgaW4gY2FzZSBvZiBjb250ZXh0bG9zdClcXG5cXHRcXHRcXHR2YXIgX2dsID0gX3JlbmRlcmVyLmNvbnRleHQ7XFxuXFx0XFx0XFx0dmFyIF9zdGF0ZSA9IF9yZW5kZXJlci5zdGF0ZTtcXG5cXG5cXHRcXHRcXHQvLyBTZXQgR0wgc3RhdGUgZm9yIGRlcHRoIG1hcC5cXG5cXHRcXHRcXHRfc3RhdGUuZGlzYWJsZSggX2dsLkJMRU5EICk7XFxuXFx0XFx0XFx0X3N0YXRlLmJ1ZmZlcnMuY29sb3Iuc2V0Q2xlYXIoIDEsIDEsIDEsIDEgKTtcXG5cXHRcXHRcXHRfc3RhdGUuYnVmZmVycy5kZXB0aC5zZXRUZXN0KCB0cnVlICk7XFxuXFx0XFx0XFx0X3N0YXRlLnNldFNjaXNzb3JUZXN0KCBmYWxzZSApO1xcblxcblxcdFxcdFxcdC8vIHJlbmRlciBkZXB0aCBtYXBcXG5cXG5cXHRcXHRcXHR2YXIgZmFjZUNvdW50O1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSBsaWdodHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGxpZ2h0ID0gbGlnaHRzWyBpIF07XFxuXFx0XFx0XFx0XFx0dmFyIHNoYWRvdyA9IGxpZ2h0LnNoYWRvdztcXG5cXHRcXHRcXHRcXHR2YXIgaXNQb2ludExpZ2h0ID0gbGlnaHQgJiYgbGlnaHQuaXNQb2ludExpZ2h0O1xcblxcblxcdFxcdFxcdFxcdGlmICggc2hhZG93ID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xTaGFkb3dNYXA6JywgbGlnaHQsICdoYXMgbm8gc2hhZG93LicgKTtcXG5cXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHNoYWRvd0NhbWVyYSA9IHNoYWRvdy5jYW1lcmE7XFxuXFxuXFx0XFx0XFx0XFx0X3NoYWRvd01hcFNpemUuY29weSggc2hhZG93Lm1hcFNpemUgKTtcXG5cXHRcXHRcXHRcXHRfc2hhZG93TWFwU2l6ZS5taW4oIF9tYXhTaGFkb3dNYXBTaXplICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBpc1BvaW50TGlnaHQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHZwV2lkdGggPSBfc2hhZG93TWFwU2l6ZS54O1xcblxcdFxcdFxcdFxcdFxcdHZhciB2cEhlaWdodCA9IF9zaGFkb3dNYXBTaXplLnk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gVGhlc2Ugdmlld3BvcnRzIG1hcCBhIGN1YmUtbWFwIG9udG8gYSAyRCB0ZXh0dXJlIHdpdGggdGhlXFxuXFx0XFx0XFx0XFx0XFx0Ly8gZm9sbG93aW5nIG9yaWVudGF0aW9uOlxcblxcdFxcdFxcdFxcdFxcdC8vXFxuXFx0XFx0XFx0XFx0XFx0Ly8gIHh6WFpcXG5cXHRcXHRcXHRcXHRcXHQvLyAgIHkgWVxcblxcdFxcdFxcdFxcdFxcdC8vXFxuXFx0XFx0XFx0XFx0XFx0Ly8gWCAtIFBvc2l0aXZlIHggZGlyZWN0aW9uXFxuXFx0XFx0XFx0XFx0XFx0Ly8geCAtIE5lZ2F0aXZlIHggZGlyZWN0aW9uXFxuXFx0XFx0XFx0XFx0XFx0Ly8gWSAtIFBvc2l0aXZlIHkgZGlyZWN0aW9uXFxuXFx0XFx0XFx0XFx0XFx0Ly8geSAtIE5lZ2F0aXZlIHkgZGlyZWN0aW9uXFxuXFx0XFx0XFx0XFx0XFx0Ly8gWiAtIFBvc2l0aXZlIHogZGlyZWN0aW9uXFxuXFx0XFx0XFx0XFx0XFx0Ly8geiAtIE5lZ2F0aXZlIHogZGlyZWN0aW9uXFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gcG9zaXRpdmUgWFxcblxcdFxcdFxcdFxcdFxcdGN1YmUyRFZpZXdQb3J0c1sgMCBdLnNldCggdnBXaWR0aCAqIDIsIHZwSGVpZ2h0LCB2cFdpZHRoLCB2cEhlaWdodCApO1xcblxcdFxcdFxcdFxcdFxcdC8vIG5lZ2F0aXZlIFhcXG5cXHRcXHRcXHRcXHRcXHRjdWJlMkRWaWV3UG9ydHNbIDEgXS5zZXQoIDAsIHZwSGVpZ2h0LCB2cFdpZHRoLCB2cEhlaWdodCApO1xcblxcdFxcdFxcdFxcdFxcdC8vIHBvc2l0aXZlIFpcXG5cXHRcXHRcXHRcXHRcXHRjdWJlMkRWaWV3UG9ydHNbIDIgXS5zZXQoIHZwV2lkdGggKiAzLCB2cEhlaWdodCwgdnBXaWR0aCwgdnBIZWlnaHQgKTtcXG5cXHRcXHRcXHRcXHRcXHQvLyBuZWdhdGl2ZSBaXFxuXFx0XFx0XFx0XFx0XFx0Y3ViZTJEVmlld1BvcnRzWyAzIF0uc2V0KCB2cFdpZHRoLCB2cEhlaWdodCwgdnBXaWR0aCwgdnBIZWlnaHQgKTtcXG5cXHRcXHRcXHRcXHRcXHQvLyBwb3NpdGl2ZSBZXFxuXFx0XFx0XFx0XFx0XFx0Y3ViZTJEVmlld1BvcnRzWyA0IF0uc2V0KCB2cFdpZHRoICogMywgMCwgdnBXaWR0aCwgdnBIZWlnaHQgKTtcXG5cXHRcXHRcXHRcXHRcXHQvLyBuZWdhdGl2ZSBZXFxuXFx0XFx0XFx0XFx0XFx0Y3ViZTJEVmlld1BvcnRzWyA1IF0uc2V0KCB2cFdpZHRoLCAwLCB2cFdpZHRoLCB2cEhlaWdodCApO1xcblxcblxcdFxcdFxcdFxcdFxcdF9zaGFkb3dNYXBTaXplLnggKj0gNC4wO1xcblxcdFxcdFxcdFxcdFxcdF9zaGFkb3dNYXBTaXplLnkgKj0gMi4wO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHNoYWRvdy5tYXAgPT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHBhcnMgPSB7IG1pbkZpbHRlcjogTmVhcmVzdEZpbHRlciwgbWFnRmlsdGVyOiBOZWFyZXN0RmlsdGVyLCBmb3JtYXQ6IFJHQkFGb3JtYXQgfTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzaGFkb3cubWFwID0gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KCBfc2hhZG93TWFwU2l6ZS54LCBfc2hhZG93TWFwU2l6ZS55LCBwYXJzICk7XFxuXFx0XFx0XFx0XFx0XFx0c2hhZG93Lm1hcC50ZXh0dXJlLm5hbWUgPSBsaWdodC5uYW1lICsgXFxcIi5zaGFkb3dNYXBcXFwiO1xcblxcblxcdFxcdFxcdFxcdFxcdHNoYWRvd0NhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggc2hhZG93LmlzU3BvdExpZ2h0U2hhZG93ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHNoYWRvdy51cGRhdGUoIGxpZ2h0ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHZhciBzaGFkb3dNYXAgPSBzaGFkb3cubWFwO1xcblxcdFxcdFxcdFxcdHZhciBzaGFkb3dNYXRyaXggPSBzaGFkb3cubWF0cml4O1xcblxcblxcdFxcdFxcdFxcdF9saWdodFBvc2l0aW9uV29ybGQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xcblxcdFxcdFxcdFxcdHNoYWRvd0NhbWVyYS5wb3NpdGlvbi5jb3B5KCBfbGlnaHRQb3NpdGlvbldvcmxkICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBpc1BvaW50TGlnaHQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZmFjZUNvdW50ID0gNjtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBmb3IgcG9pbnQgbGlnaHRzIHdlIHNldCB0aGUgc2hhZG93IG1hdHJpeCB0byBiZSBhIHRyYW5zbGF0aW9uLW9ubHkgbWF0cml4XFxuXFx0XFx0XFx0XFx0XFx0Ly8gZXF1YWwgdG8gaW52ZXJzZSBvZiB0aGUgbGlnaHQncyBwb3NpdGlvblxcblxcblxcdFxcdFxcdFxcdFxcdHNoYWRvd01hdHJpeC5tYWtlVHJhbnNsYXRpb24oIC0gX2xpZ2h0UG9zaXRpb25Xb3JsZC54LCAtIF9saWdodFBvc2l0aW9uV29ybGQueSwgLSBfbGlnaHRQb3NpdGlvbldvcmxkLnogKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdGZhY2VDb3VudCA9IDE7XFxuXFxuXFx0XFx0XFx0XFx0XFx0X2xvb2tUYXJnZXQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcXG5cXHRcXHRcXHRcXHRcXHRzaGFkb3dDYW1lcmEubG9va0F0KCBfbG9va1RhcmdldCApO1xcblxcdFxcdFxcdFxcdFxcdHNoYWRvd0NhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGNvbXB1dGUgc2hhZG93IG1hdHJpeFxcblxcblxcdFxcdFxcdFxcdFxcdHNoYWRvd01hdHJpeC5zZXQoXFxuXFx0XFx0XFx0XFx0XFx0XFx0MC41LCAwLjAsIDAuMCwgMC41LFxcblxcdFxcdFxcdFxcdFxcdFxcdDAuMCwgMC41LCAwLjAsIDAuNSxcXG5cXHRcXHRcXHRcXHRcXHRcXHQwLjAsIDAuMCwgMC41LCAwLjUsXFxuXFx0XFx0XFx0XFx0XFx0XFx0MC4wLCAwLjAsIDAuMCwgMS4wXFxuXFx0XFx0XFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzaGFkb3dNYXRyaXgubXVsdGlwbHkoIHNoYWRvd0NhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XFxuXFx0XFx0XFx0XFx0XFx0c2hhZG93TWF0cml4Lm11bHRpcGx5KCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdF9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIHNoYWRvd01hcCApO1xcblxcdFxcdFxcdFxcdF9yZW5kZXJlci5jbGVhcigpO1xcblxcblxcdFxcdFxcdFxcdC8vIHJlbmRlciBzaGFkb3cgbWFwIGZvciBlYWNoIGN1YmUgZmFjZSAoaWYgb21uaS1kaXJlY3Rpb25hbCkgb3JcXG5cXHRcXHRcXHRcXHQvLyBydW4gYSBzaW5nbGUgcGFzcyBpZiBub3RcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgZmFjZSA9IDA7IGZhY2UgPCBmYWNlQ291bnQ7IGZhY2UgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBpc1BvaW50TGlnaHQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0X2xvb2tUYXJnZXQuY29weSggc2hhZG93Q2FtZXJhLnBvc2l0aW9uICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0X2xvb2tUYXJnZXQuYWRkKCBjdWJlRGlyZWN0aW9uc1sgZmFjZSBdICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c2hhZG93Q2FtZXJhLnVwLmNvcHkoIGN1YmVVcHNbIGZhY2UgXSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdHNoYWRvd0NhbWVyYS5sb29rQXQoIF9sb29rVGFyZ2V0ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c2hhZG93Q2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHZwRGltZW5zaW9ucyA9IGN1YmUyRFZpZXdQb3J0c1sgZmFjZSBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdF9zdGF0ZS52aWV3cG9ydCggdnBEaW1lbnNpb25zICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIHVwZGF0ZSBjYW1lcmEgbWF0cmljZXMgYW5kIGZydXN0dW1cXG5cXG5cXHRcXHRcXHRcXHRcXHRfcHJvalNjcmVlbk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBzaGFkb3dDYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xcblxcdFxcdFxcdFxcdFxcdF9mcnVzdHVtLnNldEZyb21NYXRyaXgoIF9wcm9qU2NyZWVuTWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gc2V0IG9iamVjdCBtYXRyaWNlcyAmIGZydXN0dW0gY3VsbGluZ1xcblxcblxcdFxcdFxcdFxcdFxcdHJlbmRlck9iamVjdCggc2NlbmUsIGNhbWVyYSwgc2hhZG93Q2FtZXJhLCBpc1BvaW50TGlnaHQgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHNjb3BlLm5lZWRzVXBkYXRlID0gZmFsc2U7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRmdW5jdGlvbiBnZXREZXB0aE1hdGVyaWFsKCBvYmplY3QsIG1hdGVyaWFsLCBpc1BvaW50TGlnaHQsIGxpZ2h0UG9zaXRpb25Xb3JsZCwgc2hhZG93Q2FtZXJhTmVhciwgc2hhZG93Q2FtZXJhRmFyICkge1xcblxcblxcdFxcdFxcdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcXG5cXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0gbnVsbDtcXG5cXG5cXHRcXHRcXHR2YXIgbWF0ZXJpYWxWYXJpYW50cyA9IF9kZXB0aE1hdGVyaWFscztcXG5cXHRcXHRcXHR2YXIgY3VzdG9tTWF0ZXJpYWwgPSBvYmplY3QuY3VzdG9tRGVwdGhNYXRlcmlhbDtcXG5cXG5cXHRcXHRcXHRpZiAoIGlzUG9pbnRMaWdodCApIHtcXG5cXG5cXHRcXHRcXHRcXHRtYXRlcmlhbFZhcmlhbnRzID0gX2Rpc3RhbmNlTWF0ZXJpYWxzO1xcblxcdFxcdFxcdFxcdGN1c3RvbU1hdGVyaWFsID0gb2JqZWN0LmN1c3RvbURpc3RhbmNlTWF0ZXJpYWw7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggISBjdXN0b21NYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdXNlTW9ycGhpbmcgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dXNlTW9ycGhpbmcgPSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMgJiYgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uICYmIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbi5sZW5ndGggPiAwO1xcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dXNlTW9ycGhpbmcgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHMgJiYgZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aCA+IDA7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG9iamVjdC5pc1NraW5uZWRNZXNoICYmIG1hdGVyaWFsLnNraW5uaW5nID09PSBmYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFNoYWRvd01hcDogVEhSRUUuU2tpbm5lZE1lc2ggd2l0aCBtYXRlcmlhbC5za2lubmluZyBzZXQgdG8gZmFsc2U6Jywgb2JqZWN0ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHZhciB1c2VTa2lubmluZyA9IG9iamVjdC5pc1NraW5uZWRNZXNoICYmIG1hdGVyaWFsLnNraW5uaW5nO1xcblxcblxcdFxcdFxcdFxcdHZhciB2YXJpYW50SW5kZXggPSAwO1xcblxcblxcdFxcdFxcdFxcdGlmICggdXNlTW9ycGhpbmcgKSB2YXJpYW50SW5kZXggfD0gX01vcnBoaW5nRmxhZztcXG5cXHRcXHRcXHRcXHRpZiAoIHVzZVNraW5uaW5nICkgdmFyaWFudEluZGV4IHw9IF9Ta2lubmluZ0ZsYWc7XFxuXFxuXFx0XFx0XFx0XFx0cmVzdWx0ID0gbWF0ZXJpYWxWYXJpYW50c1sgdmFyaWFudEluZGV4IF07XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXN1bHQgPSBjdXN0b21NYXRlcmlhbDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBfcmVuZGVyZXIubG9jYWxDbGlwcGluZ0VuYWJsZWQgJiZcXG5cXHRcXHRcXHRcXHRcXHRtYXRlcmlhbC5jbGlwU2hhZG93cyA9PT0gdHJ1ZSAmJlxcblxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsLmNsaXBwaW5nUGxhbmVzLmxlbmd0aCAhPT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBpbiB0aGlzIGNhc2Ugd2UgbmVlZCBhIHVuaXF1ZSBtYXRlcmlhbCBpbnN0YW5jZSByZWZsZWN0aW5nIHRoZVxcblxcdFxcdFxcdFxcdC8vIGFwcHJvcHJpYXRlIHN0YXRlXFxuXFxuXFx0XFx0XFx0XFx0dmFyIGtleUEgPSByZXN1bHQudXVpZCwga2V5QiA9IG1hdGVyaWFsLnV1aWQ7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG1hdGVyaWFsc0ZvclZhcmlhbnQgPSBfbWF0ZXJpYWxDYWNoZVsga2V5QSBdO1xcblxcblxcdFxcdFxcdFxcdGlmICggbWF0ZXJpYWxzRm9yVmFyaWFudCA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsc0ZvclZhcmlhbnQgPSB7fTtcXG5cXHRcXHRcXHRcXHRcXHRfbWF0ZXJpYWxDYWNoZVsga2V5QSBdID0gbWF0ZXJpYWxzRm9yVmFyaWFudDtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGNhY2hlZE1hdGVyaWFsID0gbWF0ZXJpYWxzRm9yVmFyaWFudFsga2V5QiBdO1xcblxcblxcdFxcdFxcdFxcdGlmICggY2FjaGVkTWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYWNoZWRNYXRlcmlhbCA9IHJlc3VsdC5jbG9uZSgpO1xcblxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsc0ZvclZhcmlhbnRbIGtleUIgXSA9IGNhY2hlZE1hdGVyaWFsO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXN1bHQgPSBjYWNoZWRNYXRlcmlhbDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmVzdWx0LnZpc2libGUgPSBtYXRlcmlhbC52aXNpYmxlO1xcblxcdFxcdFxcdHJlc3VsdC53aXJlZnJhbWUgPSBtYXRlcmlhbC53aXJlZnJhbWU7XFxuXFxuXFx0XFx0XFx0dmFyIHNpZGUgPSBtYXRlcmlhbC5zaWRlO1xcblxcblxcdFxcdFxcdGlmICggc2NvcGUucmVuZGVyU2luZ2xlU2lkZWQgJiYgc2lkZSA9PSBEb3VibGVTaWRlICkge1xcblxcblxcdFxcdFxcdFxcdHNpZGUgPSBGcm9udFNpZGU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggc2NvcGUucmVuZGVyUmV2ZXJzZVNpZGVkICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggc2lkZSA9PT0gRnJvbnRTaWRlICkgc2lkZSA9IEJhY2tTaWRlO1xcblxcdFxcdFxcdFxcdGVsc2UgaWYgKCBzaWRlID09PSBCYWNrU2lkZSApIHNpZGUgPSBGcm9udFNpZGU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJlc3VsdC5zaWRlID0gc2lkZTtcXG5cXG5cXHRcXHRcXHRyZXN1bHQuY2xpcFNoYWRvd3MgPSBtYXRlcmlhbC5jbGlwU2hhZG93cztcXG5cXHRcXHRcXHRyZXN1bHQuY2xpcHBpbmdQbGFuZXMgPSBtYXRlcmlhbC5jbGlwcGluZ1BsYW5lcztcXG5cXHRcXHRcXHRyZXN1bHQuY2xpcEludGVyc2VjdGlvbiA9IG1hdGVyaWFsLmNsaXBJbnRlcnNlY3Rpb247XFxuXFxuXFx0XFx0XFx0cmVzdWx0LndpcmVmcmFtZUxpbmV3aWR0aCA9IG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aDtcXG5cXHRcXHRcXHRyZXN1bHQubGluZXdpZHRoID0gbWF0ZXJpYWwubGluZXdpZHRoO1xcblxcblxcdFxcdFxcdGlmICggaXNQb2ludExpZ2h0ICYmIHJlc3VsdC5pc01lc2hEaXN0YW5jZU1hdGVyaWFsICkge1xcblxcblxcdFxcdFxcdFxcdHJlc3VsdC5yZWZlcmVuY2VQb3NpdGlvbi5jb3B5KCBsaWdodFBvc2l0aW9uV29ybGQgKTtcXG5cXHRcXHRcXHRcXHRyZXN1bHQubmVhckRpc3RhbmNlID0gc2hhZG93Q2FtZXJhTmVhcjtcXG5cXHRcXHRcXHRcXHRyZXN1bHQuZmFyRGlzdGFuY2UgPSBzaGFkb3dDYW1lcmFGYXI7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiByZXN1bHQ7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHJlbmRlck9iamVjdCggb2JqZWN0LCBjYW1lcmEsIHNoYWRvd0NhbWVyYSwgaXNQb2ludExpZ2h0ICkge1xcblxcblxcdFxcdFxcdGlmICggb2JqZWN0LnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xcblxcblxcdFxcdFxcdHZhciB2aXNpYmxlID0gb2JqZWN0LmxheWVycy50ZXN0KCBjYW1lcmEubGF5ZXJzICk7XFxuXFxuXFx0XFx0XFx0aWYgKCB2aXNpYmxlICYmICggb2JqZWN0LmlzTWVzaCB8fCBvYmplY3QuaXNMaW5lIHx8IG9iamVjdC5pc1BvaW50cyApICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggb2JqZWN0LmNhc3RTaGFkb3cgJiYgKCAhIG9iamVjdC5mcnVzdHVtQ3VsbGVkIHx8IF9mcnVzdHVtLmludGVyc2VjdHNPYmplY3QoIG9iamVjdCApICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0b2JqZWN0Lm1vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBvYmplY3QubWF0cml4V29ybGQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgZ2VvbWV0cnkgPSBfb2JqZWN0cy51cGRhdGUoIG9iamVjdCApO1xcblxcdFxcdFxcdFxcdFxcdHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIEFycmF5LmlzQXJyYXkoIG1hdGVyaWFsICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgayA9IDAsIGtsID0gZ3JvdXBzLmxlbmd0aDsgayA8IGtsOyBrICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBncm91cCA9IGdyb3Vwc1sgayBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxbIGdyb3VwLm1hdGVyaWFsSW5kZXggXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGdyb3VwTWF0ZXJpYWwgJiYgZ3JvdXBNYXRlcmlhbC52aXNpYmxlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBkZXB0aE1hdGVyaWFsID0gZ2V0RGVwdGhNYXRlcmlhbCggb2JqZWN0LCBncm91cE1hdGVyaWFsLCBpc1BvaW50TGlnaHQsIF9saWdodFBvc2l0aW9uV29ybGQsIHNoYWRvd0NhbWVyYS5uZWFyLCBzaGFkb3dDYW1lcmEuZmFyICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0X3JlbmRlcmVyLnJlbmRlckJ1ZmZlckRpcmVjdCggc2hhZG93Q2FtZXJhLCBudWxsLCBnZW9tZXRyeSwgZGVwdGhNYXRlcmlhbCwgb2JqZWN0LCBncm91cCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICggbWF0ZXJpYWwudmlzaWJsZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgZGVwdGhNYXRlcmlhbCA9IGdldERlcHRoTWF0ZXJpYWwoIG9iamVjdCwgbWF0ZXJpYWwsIGlzUG9pbnRMaWdodCwgX2xpZ2h0UG9zaXRpb25Xb3JsZCwgc2hhZG93Q2FtZXJhLm5lYXIsIHNoYWRvd0NhbWVyYS5mYXIgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRfcmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KCBzaGFkb3dDYW1lcmEsIG51bGwsIGdlb21ldHJ5LCBkZXB0aE1hdGVyaWFsLCBvYmplY3QsIG51bGwgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZW5kZXJPYmplY3QoIGNoaWxkcmVuWyBpIF0sIGNhbWVyYSwgc2hhZG93Q2FtZXJhLCBpc1BvaW50TGlnaHQgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdH1cXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFdlYkdMQXR0cmlidXRlcyggZ2wgKSB7XFxuXFxuXFx0XFx0dmFyIGJ1ZmZlcnMgPSB7fTtcXG5cXG5cXHRcXHRmdW5jdGlvbiBjcmVhdGVCdWZmZXIoIGF0dHJpYnV0ZSwgYnVmZmVyVHlwZSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XFxuXFx0XFx0XFx0dmFyIHVzYWdlID0gYXR0cmlidXRlLmR5bmFtaWMgPyBnbC5EWU5BTUlDX0RSQVcgOiBnbC5TVEFUSUNfRFJBVztcXG5cXG5cXHRcXHRcXHR2YXIgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XFxuXFxuXFx0XFx0XFx0Z2wuYmluZEJ1ZmZlciggYnVmZmVyVHlwZSwgYnVmZmVyICk7XFxuXFx0XFx0XFx0Z2wuYnVmZmVyRGF0YSggYnVmZmVyVHlwZSwgYXJyYXksIHVzYWdlICk7XFxuXFxuXFx0XFx0XFx0YXR0cmlidXRlLm9uVXBsb2FkQ2FsbGJhY2soKTtcXG5cXG5cXHRcXHRcXHR2YXIgdHlwZSA9IGdsLkZMT0FUO1xcblxcblxcdFxcdFxcdGlmICggYXJyYXkgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dHlwZSA9IGdsLkZMT0FUO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGFycmF5IGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5ICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMQXR0cmlidXRlczogVW5zdXBwb3J0ZWQgZGF0YSBidWZmZXIgZm9ybWF0OiBGbG9hdDY0QXJyYXkuJyApO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGFycmF5IGluc3RhbmNlb2YgVWludDE2QXJyYXkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dHlwZSA9IGdsLlVOU0lHTkVEX1NIT1JUO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGFycmF5IGluc3RhbmNlb2YgSW50MTZBcnJheSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0eXBlID0gZ2wuU0hPUlQ7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0eXBlID0gZ2wuVU5TSUdORURfSU5UO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGFycmF5IGluc3RhbmNlb2YgSW50MzJBcnJheSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0eXBlID0gZ2wuSU5UO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGFycmF5IGluc3RhbmNlb2YgSW50OEFycmF5ICkge1xcblxcblxcdFxcdFxcdFxcdHR5cGUgPSBnbC5CWVRFO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGFycmF5IGluc3RhbmNlb2YgVWludDhBcnJheSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0eXBlID0gZ2wuVU5TSUdORURfQllURTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHRcXHRidWZmZXI6IGJ1ZmZlcixcXG5cXHRcXHRcXHRcXHR0eXBlOiB0eXBlLFxcblxcdFxcdFxcdFxcdGJ5dGVzUGVyRWxlbWVudDogYXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXFxuXFx0XFx0XFx0XFx0dmVyc2lvbjogYXR0cmlidXRlLnZlcnNpb25cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiB1cGRhdGVCdWZmZXIoIGJ1ZmZlciwgYXR0cmlidXRlLCBidWZmZXJUeXBlICkge1xcblxcblxcdFxcdFxcdHZhciBhcnJheSA9IGF0dHJpYnV0ZS5hcnJheTtcXG5cXHRcXHRcXHR2YXIgdXBkYXRlUmFuZ2UgPSBhdHRyaWJ1dGUudXBkYXRlUmFuZ2U7XFxuXFxuXFx0XFx0XFx0Z2wuYmluZEJ1ZmZlciggYnVmZmVyVHlwZSwgYnVmZmVyICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBhdHRyaWJ1dGUuZHluYW1pYyA9PT0gZmFsc2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Z2wuYnVmZmVyRGF0YSggYnVmZmVyVHlwZSwgYXJyYXksIGdsLlNUQVRJQ19EUkFXICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggdXBkYXRlUmFuZ2UuY291bnQgPT09IC0gMSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBOb3QgdXNpbmcgdXBkYXRlIHJhbmdlc1xcblxcblxcdFxcdFxcdFxcdGdsLmJ1ZmZlclN1YkRhdGEoIGJ1ZmZlclR5cGUsIDAsIGFycmF5ICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggdXBkYXRlUmFuZ2UuY291bnQgPT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMT2JqZWN0cy51cGRhdGVCdWZmZXI6IGR5bmFtaWMgVEhSRUUuQnVmZmVyQXR0cmlidXRlIG1hcmtlZCBhcyBuZWVkc1VwZGF0ZSBidXQgdXBkYXRlUmFuZ2UuY291bnQgaXMgMCwgZW5zdXJlIHlvdSBhcmUgdXNpbmcgc2V0IG1ldGhvZHMgb3IgdXBkYXRpbmcgbWFudWFsbHkuJyApO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0Z2wuYnVmZmVyU3ViRGF0YSggYnVmZmVyVHlwZSwgdXBkYXRlUmFuZ2Uub2Zmc2V0ICogYXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXFxuXFx0XFx0XFx0XFx0XFx0YXJyYXkuc3ViYXJyYXkoIHVwZGF0ZVJhbmdlLm9mZnNldCwgdXBkYXRlUmFuZ2Uub2Zmc2V0ICsgdXBkYXRlUmFuZ2UuY291bnQgKSApO1xcblxcblxcdFxcdFxcdFxcdHVwZGF0ZVJhbmdlLmNvdW50ID0gLSAxOyAvLyByZXNldCByYW5nZVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly9cXG5cXG5cXHRcXHRmdW5jdGlvbiBnZXQoIGF0dHJpYnV0ZSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkgYXR0cmlidXRlID0gYXR0cmlidXRlLmRhdGE7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGJ1ZmZlcnNbIGF0dHJpYnV0ZS51dWlkIF07XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHJlbW92ZSggYXR0cmlidXRlICkge1xcblxcblxcdFxcdFxcdGlmICggYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGUuZGF0YTtcXG5cXG5cXHRcXHRcXHR2YXIgZGF0YSA9IGJ1ZmZlcnNbIGF0dHJpYnV0ZS51dWlkIF07XFxuXFxuXFx0XFx0XFx0aWYgKCBkYXRhICkge1xcblxcblxcdFxcdFxcdFxcdGdsLmRlbGV0ZUJ1ZmZlciggZGF0YS5idWZmZXIgKTtcXG5cXG5cXHRcXHRcXHRcXHRkZWxldGUgYnVmZmVyc1sgYXR0cmlidXRlLnV1aWQgXTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHVwZGF0ZSggYXR0cmlidXRlLCBidWZmZXJUeXBlICkge1xcblxcblxcdFxcdFxcdGlmICggYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGUuZGF0YTtcXG5cXG5cXHRcXHRcXHR2YXIgZGF0YSA9IGJ1ZmZlcnNbIGF0dHJpYnV0ZS51dWlkIF07XFxuXFxuXFx0XFx0XFx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0YnVmZmVyc1sgYXR0cmlidXRlLnV1aWQgXSA9IGNyZWF0ZUJ1ZmZlciggYXR0cmlidXRlLCBidWZmZXJUeXBlICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggZGF0YS52ZXJzaW9uIDwgYXR0cmlidXRlLnZlcnNpb24gKSB7XFxuXFxuXFx0XFx0XFx0XFx0dXBkYXRlQnVmZmVyKCBkYXRhLmJ1ZmZlciwgYXR0cmlidXRlLCBidWZmZXJUeXBlICk7XFxuXFxuXFx0XFx0XFx0XFx0ZGF0YS52ZXJzaW9uID0gYXR0cmlidXRlLnZlcnNpb247XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4ge1xcblxcblxcdFxcdFxcdGdldDogZ2V0LFxcblxcdFxcdFxcdHJlbW92ZTogcmVtb3ZlLFxcblxcdFxcdFxcdHVwZGF0ZTogdXBkYXRlXFxuXFxuXFx0XFx0fTtcXG5cXG5cXHR9XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcXG5cXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gRXVsZXIoIHgsIHksIHosIG9yZGVyICkge1xcblxcblxcdFxcdHRoaXMuX3ggPSB4IHx8IDA7XFxuXFx0XFx0dGhpcy5feSA9IHkgfHwgMDtcXG5cXHRcXHR0aGlzLl96ID0geiB8fCAwO1xcblxcdFxcdHRoaXMuX29yZGVyID0gb3JkZXIgfHwgRXVsZXIuRGVmYXVsdE9yZGVyO1xcblxcblxcdH1cXG5cXG5cXHRFdWxlci5Sb3RhdGlvbk9yZGVycyA9IFsgJ1hZWicsICdZWlgnLCAnWlhZJywgJ1haWScsICdZWFonLCAnWllYJyBdO1xcblxcblxcdEV1bGVyLkRlZmF1bHRPcmRlciA9ICdYWVonO1xcblxcblxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBFdWxlci5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHR4OiB7XFxuXFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuX3g7XFxuXFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5feCA9IHZhbHVlO1xcblxcdFxcdFxcdFxcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHk6IHtcXG5cXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5feTtcXG5cXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl95ID0gdmFsdWU7XFxuXFx0XFx0XFx0XFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ejoge1xcblxcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLl96O1xcblxcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuX3ogPSB2YWx1ZTtcXG5cXHRcXHRcXHRcXHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRvcmRlcjoge1xcblxcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLl9vcmRlcjtcXG5cXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl9vcmRlciA9IHZhbHVlO1xcblxcdFxcdFxcdFxcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdE9iamVjdC5hc3NpZ24oIEV1bGVyLnByb3RvdHlwZSwge1xcblxcblxcdFxcdGlzRXVsZXI6IHRydWUsXFxuXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHosIG9yZGVyICkge1xcblxcblxcdFxcdFxcdHRoaXMuX3ggPSB4O1xcblxcdFxcdFxcdHRoaXMuX3kgPSB5O1xcblxcdFxcdFxcdHRoaXMuX3ogPSB6O1xcblxcdFxcdFxcdHRoaXMuX29yZGVyID0gb3JkZXIgfHwgdGhpcy5fb3JkZXI7XFxuXFxuXFx0XFx0XFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fb3JkZXIgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggZXVsZXIgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5feCA9IGV1bGVyLl94O1xcblxcdFxcdFxcdHRoaXMuX3kgPSBldWxlci5feTtcXG5cXHRcXHRcXHR0aGlzLl96ID0gZXVsZXIuX3o7XFxuXFx0XFx0XFx0dGhpcy5fb3JkZXIgPSBldWxlci5fb3JkZXI7XFxuXFxuXFx0XFx0XFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSwgb3JkZXIsIHVwZGF0ZSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgY2xhbXAgPSBfTWF0aC5jbGFtcDtcXG5cXG5cXHRcXHRcXHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxcblxcblxcdFxcdFxcdHZhciB0ZSA9IG0uZWxlbWVudHM7XFxuXFx0XFx0XFx0dmFyIG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF07XFxuXFx0XFx0XFx0dmFyIG0yMSA9IHRlWyAxIF0sIG0yMiA9IHRlWyA1IF0sIG0yMyA9IHRlWyA5IF07XFxuXFx0XFx0XFx0dmFyIG0zMSA9IHRlWyAyIF0sIG0zMiA9IHRlWyA2IF0sIG0zMyA9IHRlWyAxMCBdO1xcblxcblxcdFxcdFxcdG9yZGVyID0gb3JkZXIgfHwgdGhpcy5fb3JkZXI7XFxuXFxuXFx0XFx0XFx0aWYgKCBvcmRlciA9PT0gJ1hZWicgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5feSA9IE1hdGguYXNpbiggY2xhbXAoIG0xMywgLSAxLCAxICkgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIE1hdGguYWJzKCBtMTMgKSA8IDAuOTk5OTkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMzMgKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0xMSApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTIyICk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5feiA9IDA7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVhaJyApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl94ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMjMsIC0gMSwgMSApICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBNYXRoLmFicyggbTIzICkgPCAwLjk5OTk5ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0zMyApO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0yMiApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMTEgKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl96ID0gMDtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWFknICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuX3ggPSBNYXRoLmFzaW4oIGNsYW1wKCBtMzIsIC0gMSwgMSApICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBNYXRoLmFicyggbTMyICkgPCAwLjk5OTk5ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTMzICk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3kgPSAwO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pZWCcgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5feSA9IE1hdGguYXNpbiggLSBjbGFtcCggbTMxLCAtIDEsIDEgKSApO1xcblxcblxcdFxcdFxcdFxcdGlmICggTWF0aC5hYnMoIG0zMSApIDwgMC45OTk5OSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMzMgKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMTEgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3ggPSAwO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTIyICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVpYJyApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl96ID0gTWF0aC5hc2luKCBjbGFtcCggbTIxLCAtIDEsIDEgKSApO1xcblxcblxcdFxcdFxcdFxcdGlmICggTWF0aC5hYnMoIG0yMSApIDwgMC45OTk5OSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0yMiApO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTExICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl94ID0gMDtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdYWlknICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuX3ogPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0xMiwgLSAxLCAxICkgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIE1hdGguYWJzKCBtMTIgKSA8IDAuOTk5OTkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTIyICk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTExICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0zMyApO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3kgPSAwO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkV1bGVyOiAuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCkgZ2l2ZW4gdW5zdXBwb3J0ZWQgb3JkZXI6ICcgKyBvcmRlciApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLl9vcmRlciA9IG9yZGVyO1xcblxcblxcdFxcdFxcdGlmICggdXBkYXRlICE9PSBmYWxzZSApIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0RnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gc2V0RnJvbVF1YXRlcm5pb24oIHEsIG9yZGVyLCB1cGRhdGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0bWF0cml4Lm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtYXRyaXgsIG9yZGVyLCB1cGRhdGUgKTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRzZXRGcm9tVmVjdG9yMzogZnVuY3Rpb24gKCB2LCBvcmRlciApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5zZXQoIHYueCwgdi55LCB2LnosIG9yZGVyIHx8IHRoaXMuX29yZGVyICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyZW9yZGVyOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Ly8gV0FSTklORzogdGhpcyBkaXNjYXJkcyByZXZvbHV0aW9uIGluZm9ybWF0aW9uIC1iaG91c3RvblxcblxcblxcdFxcdFxcdHZhciBxID0gbmV3IFF1YXRlcm5pb24oKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gcmVvcmRlciggbmV3T3JkZXIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cS5zZXRGcm9tRXVsZXIoIHRoaXMgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5zZXRGcm9tUXVhdGVybmlvbiggcSwgbmV3T3JkZXIgKTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRlcXVhbHM6IGZ1bmN0aW9uICggZXVsZXIgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuICggZXVsZXIuX3ggPT09IHRoaXMuX3ggKSAmJiAoIGV1bGVyLl95ID09PSB0aGlzLl95ICkgJiYgKCBldWxlci5feiA9PT0gdGhpcy5feiApICYmICggZXVsZXIuX29yZGVyID09PSB0aGlzLl9vcmRlciApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xcblxcblxcdFxcdFxcdHRoaXMuX3ggPSBhcnJheVsgMCBdO1xcblxcdFxcdFxcdHRoaXMuX3kgPSBhcnJheVsgMSBdO1xcblxcdFxcdFxcdHRoaXMuX3ogPSBhcnJheVsgMiBdO1xcblxcdFxcdFxcdGlmICggYXJyYXlbIDMgXSAhPT0gdW5kZWZpbmVkICkgdGhpcy5fb3JkZXIgPSBhcnJheVsgMyBdO1xcblxcblxcdFxcdFxcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XFxuXFx0XFx0XFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XFxuXFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5feTtcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5fejtcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fb3JkZXI7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGFycmF5O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dG9WZWN0b3IzOiBmdW5jdGlvbiAoIG9wdGlvbmFsUmVzdWx0ICkge1xcblxcblxcdFxcdFxcdGlmICggb3B0aW9uYWxSZXN1bHQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIG9wdGlvbmFsUmVzdWx0LnNldCggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiApO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIG5ldyBWZWN0b3IzKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0b25DaGFuZ2U6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRvbkNoYW5nZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIExheWVycygpIHtcXG5cXG5cXHRcXHR0aGlzLm1hc2sgPSAxIHwgMDtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggTGF5ZXJzLnByb3RvdHlwZSwge1xcblxcblxcdFxcdHNldDogZnVuY3Rpb24gKCBjaGFubmVsICkge1xcblxcblxcdFxcdFxcdHRoaXMubWFzayA9IDEgPDwgY2hhbm5lbCB8IDA7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRlbmFibGU6IGZ1bmN0aW9uICggY2hhbm5lbCApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm1hc2sgfD0gMSA8PCBjaGFubmVsIHwgMDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHRvZ2dsZTogZnVuY3Rpb24gKCBjaGFubmVsICkge1xcblxcblxcdFxcdFxcdHRoaXMubWFzayBePSAxIDw8IGNoYW5uZWwgfCAwO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGlzYWJsZTogZnVuY3Rpb24gKCBjaGFubmVsICkge1xcblxcblxcdFxcdFxcdHRoaXMubWFzayAmPSB+ICggMSA8PCBjaGFubmVsIHwgMCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dGVzdDogZnVuY3Rpb24gKCBsYXllcnMgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuICggdGhpcy5tYXNrICYgbGF5ZXJzLm1hc2sgKSAhPT0gMDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxcblxcdCAqIEBhdXRob3IgZWxlcGhhbnRhdHdvcmsgLyB3d3cuZWxlcGhhbnRhdHdvcmsuY2hcXG5cXHQgKi9cXG5cXG5cXHR2YXIgb2JqZWN0M0RJZCA9IDA7XFxuXFxuXFx0ZnVuY3Rpb24gT2JqZWN0M0QoKSB7XFxuXFxuXFx0XFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBvYmplY3QzRElkICsrIH0gKTtcXG5cXG5cXHRcXHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcXG5cXG5cXHRcXHR0aGlzLm5hbWUgPSAnJztcXG5cXHRcXHR0aGlzLnR5cGUgPSAnT2JqZWN0M0QnO1xcblxcblxcdFxcdHRoaXMucGFyZW50ID0gbnVsbDtcXG5cXHRcXHR0aGlzLmNoaWxkcmVuID0gW107XFxuXFxuXFx0XFx0dGhpcy51cCA9IE9iamVjdDNELkRlZmF1bHRVcC5jbG9uZSgpO1xcblxcblxcdFxcdHZhciBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0dmFyIHJvdGF0aW9uID0gbmV3IEV1bGVyKCk7XFxuXFx0XFx0dmFyIHF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xcblxcdFxcdHZhciBzY2FsZSA9IG5ldyBWZWN0b3IzKCAxLCAxLCAxICk7XFxuXFxuXFx0XFx0ZnVuY3Rpb24gb25Sb3RhdGlvbkNoYW5nZSgpIHtcXG5cXG5cXHRcXHRcXHRxdWF0ZXJuaW9uLnNldEZyb21FdWxlciggcm90YXRpb24sIGZhbHNlICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIG9uUXVhdGVybmlvbkNoYW5nZSgpIHtcXG5cXG5cXHRcXHRcXHRyb3RhdGlvbi5zZXRGcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbiwgdW5kZWZpbmVkLCBmYWxzZSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRyb3RhdGlvbi5vbkNoYW5nZSggb25Sb3RhdGlvbkNoYW5nZSApO1xcblxcdFxcdHF1YXRlcm5pb24ub25DaGFuZ2UoIG9uUXVhdGVybmlvbkNoYW5nZSApO1xcblxcblxcdFxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLCB7XFxuXFx0XFx0XFx0cG9zaXRpb246IHtcXG5cXHRcXHRcXHRcXHRlbnVtZXJhYmxlOiB0cnVlLFxcblxcdFxcdFxcdFxcdHZhbHVlOiBwb3NpdGlvblxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0cm90YXRpb246IHtcXG5cXHRcXHRcXHRcXHRlbnVtZXJhYmxlOiB0cnVlLFxcblxcdFxcdFxcdFxcdHZhbHVlOiByb3RhdGlvblxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0cXVhdGVybmlvbjoge1xcblxcdFxcdFxcdFxcdGVudW1lcmFibGU6IHRydWUsXFxuXFx0XFx0XFx0XFx0dmFsdWU6IHF1YXRlcm5pb25cXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdHNjYWxlOiB7XFxuXFx0XFx0XFx0XFx0ZW51bWVyYWJsZTogdHJ1ZSxcXG5cXHRcXHRcXHRcXHR2YWx1ZTogc2NhbGVcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdG1vZGVsVmlld01hdHJpeDoge1xcblxcdFxcdFxcdFxcdHZhbHVlOiBuZXcgTWF0cml4NCgpXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRub3JtYWxNYXRyaXg6IHtcXG5cXHRcXHRcXHRcXHR2YWx1ZTogbmV3IE1hdHJpeDMoKVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9ICk7XFxuXFxuXFx0XFx0dGhpcy5tYXRyaXggPSBuZXcgTWF0cml4NCgpO1xcblxcdFxcdHRoaXMubWF0cml4V29ybGQgPSBuZXcgTWF0cml4NCgpO1xcblxcblxcdFxcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IE9iamVjdDNELkRlZmF1bHRNYXRyaXhBdXRvVXBkYXRlO1xcblxcdFxcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xcblxcblxcdFxcdHRoaXMubGF5ZXJzID0gbmV3IExheWVycygpO1xcblxcdFxcdHRoaXMudmlzaWJsZSA9IHRydWU7XFxuXFxuXFx0XFx0dGhpcy5jYXN0U2hhZG93ID0gZmFsc2U7XFxuXFx0XFx0dGhpcy5yZWNlaXZlU2hhZG93ID0gZmFsc2U7XFxuXFxuXFx0XFx0dGhpcy5mcnVzdHVtQ3VsbGVkID0gdHJ1ZTtcXG5cXHRcXHR0aGlzLnJlbmRlck9yZGVyID0gMDtcXG5cXG5cXHRcXHR0aGlzLnVzZXJEYXRhID0ge307XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdDNELkRlZmF1bHRVcCA9IG5ldyBWZWN0b3IzKCAwLCAxLCAwICk7XFxuXFx0T2JqZWN0M0QuRGVmYXVsdE1hdHJpeEF1dG9VcGRhdGUgPSB0cnVlO1xcblxcblxcdE9iamVjdDNELnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBPYmplY3QzRCxcXG5cXG5cXHRcXHRpc09iamVjdDNEOiB0cnVlLFxcblxcblxcdFxcdG9uQmVmb3JlUmVuZGVyOiBmdW5jdGlvbiAoKSB7fSxcXG5cXHRcXHRvbkFmdGVyUmVuZGVyOiBmdW5jdGlvbiAoKSB7fSxcXG5cXG5cXHRcXHRhcHBseU1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5tYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4LCB0aGlzLm1hdHJpeCApO1xcblxcblxcdFxcdFxcdHRoaXMubWF0cml4LmRlY29tcG9zZSggdGhpcy5wb3NpdGlvbiwgdGhpcy5xdWF0ZXJuaW9uLCB0aGlzLnNjYWxlICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRhcHBseVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnF1YXRlcm5pb24ucHJlbXVsdGlwbHkoIHEgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFJvdGF0aW9uRnJvbUF4aXNBbmdsZTogZnVuY3Rpb24gKCBheGlzLCBhbmdsZSApIHtcXG5cXG5cXHRcXHRcXHQvLyBhc3N1bWVzIGF4aXMgaXMgbm9ybWFsaXplZFxcblxcblxcdFxcdFxcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0Um90YXRpb25Gcm9tRXVsZXI6IGZ1bmN0aW9uICggZXVsZXIgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21FdWxlciggZXVsZXIsIHRydWUgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFJvdGF0aW9uRnJvbU1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xcblxcblxcdFxcdFxcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXFxuXFxuXFx0XFx0XFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xcblxcblxcdFxcdFxcdC8vIGFzc3VtZXMgcSBpcyBub3JtYWxpemVkXFxuXFxuXFx0XFx0XFx0dGhpcy5xdWF0ZXJuaW9uLmNvcHkoIHEgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHJvdGF0ZU9uQXhpczogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdC8vIHJvdGF0ZSBvYmplY3Qgb24gYXhpcyBpbiBvYmplY3Qgc3BhY2VcXG5cXHRcXHRcXHQvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxcblxcblxcdFxcdFxcdHZhciBxMSA9IG5ldyBRdWF0ZXJuaW9uKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZU9uQXhpcyggYXhpcywgYW5nbGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cTEuc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnF1YXRlcm5pb24ubXVsdGlwbHkoIHExICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0cm90YXRlT25Xb3JsZEF4aXM6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHQvLyByb3RhdGUgb2JqZWN0IG9uIGF4aXMgaW4gd29ybGQgc3BhY2VcXG5cXHRcXHRcXHQvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxcblxcdFxcdFxcdC8vIG1ldGhvZCBhc3N1bWVzIG5vIHJvdGF0ZWQgcGFyZW50XFxuXFxuXFx0XFx0XFx0dmFyIHExID0gbmV3IFF1YXRlcm5pb24oKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlT25Xb3JsZEF4aXMoIGF4aXMsIGFuZ2xlICkge1xcblxcblxcdFxcdFxcdFxcdHExLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5xdWF0ZXJuaW9uLnByZW11bHRpcGx5KCBxMSApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdHJvdGF0ZVg6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMyggMSwgMCwgMCApO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiByb3RhdGVYKCBhbmdsZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIHYxLCBhbmdsZSApO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMyggMCwgMSwgMCApO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiByb3RhdGVZKCBhbmdsZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIHYxLCBhbmdsZSApO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdHJvdGF0ZVo6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMyggMCwgMCwgMSApO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiByb3RhdGVaKCBhbmdsZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoIHYxLCBhbmdsZSApO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdHRyYW5zbGF0ZU9uQXhpczogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdC8vIHRyYW5zbGF0ZSBvYmplY3QgYnkgZGlzdGFuY2UgYWxvbmcgYXhpcyBpbiBvYmplY3Qgc3BhY2VcXG5cXHRcXHRcXHQvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxcblxcblxcdFxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZU9uQXhpcyggYXhpcywgZGlzdGFuY2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0djEuY29weSggYXhpcyApLmFwcGx5UXVhdGVybmlvbiggdGhpcy5xdWF0ZXJuaW9uICk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5wb3NpdGlvbi5hZGQoIHYxLm11bHRpcGx5U2NhbGFyKCBkaXN0YW5jZSApICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0dHJhbnNsYXRlWDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCAxLCAwLCAwICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZVgoIGRpc3RhbmNlICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggdjEsIGRpc3RhbmNlICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0dHJhbnNsYXRlWTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCAwLCAxLCAwICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZVkoIGRpc3RhbmNlICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggdjEsIGRpc3RhbmNlICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0dHJhbnNsYXRlWjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCAwLCAwLCAxICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHRyYW5zbGF0ZVooIGRpc3RhbmNlICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggdjEsIGRpc3RhbmNlICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0bG9jYWxUb1dvcmxkOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0d29ybGRUb0xvY2FsOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gd29ybGRUb0xvY2FsKCB2ZWN0b3IgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIG0xLmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKSApO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdGxvb2tBdDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdC8vIFRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgb2JqZWN0cyB3aXRoIHJvdGF0ZWQgYW5kL29yIHRyYW5zbGF0ZWQgcGFyZW50KHMpXFxuXFxuXFx0XFx0XFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcXG5cXHRcXHRcXHR2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gbG9va0F0KCB4LCB5LCB6ICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggeC5pc1ZlY3RvcjMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmVjdG9yLmNvcHkoIHggKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdHZlY3Rvci5zZXQoIHgsIHksIHogKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB0aGlzLmlzQ2FtZXJhICkge1xcblxcblxcdFxcdFxcdFxcdFxcdG0xLmxvb2tBdCggdGhpcy5wb3NpdGlvbiwgdmVjdG9yLCB0aGlzLnVwICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRtMS5sb29rQXQoIHZlY3RvciwgdGhpcy5wb3NpdGlvbiwgdGhpcy51cCApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtMSApO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdGFkZDogZnVuY3Rpb24gKCBvYmplY3QgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMSApIHtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuYWRkKCBhcmd1bWVudHNbIGkgXSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBvYmplY3QgPT09IHRoaXMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggXFxcIlRIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IGNhbid0IGJlIGFkZGVkIGFzIGEgY2hpbGQgb2YgaXRzZWxmLlxcXCIsIG9iamVjdCApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoICggb2JqZWN0ICYmIG9iamVjdC5pc09iamVjdDNEICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBvYmplY3QucGFyZW50ICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdG9iamVjdC5wYXJlbnQucmVtb3ZlKCBvYmplY3QgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0b2JqZWN0LnBhcmVudCA9IHRoaXM7XFxuXFx0XFx0XFx0XFx0b2JqZWN0LmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2FkZGVkJyB9ICk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5jaGlsZHJlbi5wdXNoKCBvYmplY3QgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoIFxcXCJUSFJFRS5PYmplY3QzRC5hZGQ6IG9iamVjdCBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuT2JqZWN0M0QuXFxcIiwgb2JqZWN0ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cmVtb3ZlOiBmdW5jdGlvbiAoIG9iamVjdCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5yZW1vdmUoIGFyZ3VtZW50c1sgaSBdICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoIG9iamVjdCApO1xcblxcblxcdFxcdFxcdGlmICggaW5kZXggIT09IC0gMSApIHtcXG5cXG5cXHRcXHRcXHRcXHRvYmplY3QucGFyZW50ID0gbnVsbDtcXG5cXG5cXHRcXHRcXHRcXHRvYmplY3QuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAncmVtb3ZlZCcgfSApO1xcblxcblxcdFxcdFxcdFxcdHRoaXMuY2hpbGRyZW4uc3BsaWNlKCBpbmRleCwgMSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldE9iamVjdEJ5SWQ6IGZ1bmN0aW9uICggaWQgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ2lkJywgaWQgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldE9iamVjdEJ5TmFtZTogZnVuY3Rpb24gKCBuYW1lICkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmdldE9iamVjdEJ5UHJvcGVydHkoICduYW1lJywgbmFtZSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0T2JqZWN0QnlQcm9wZXJ0eTogZnVuY3Rpb24gKCBuYW1lLCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXNbIG5hbWUgXSA9PT0gdmFsdWUgKSByZXR1cm4gdGhpcztcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlblsgaSBdO1xcblxcdFxcdFxcdFxcdHZhciBvYmplY3QgPSBjaGlsZC5nZXRPYmplY3RCeVByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xcblxcblxcdFxcdFxcdFxcdGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIG9iamVjdDtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB1bmRlZmluZWQ7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRXb3JsZFBvc2l0aW9uOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0LnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0V29ybGRRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgc2NhbGUgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBnZXRXb3JsZFF1YXRlcm5pb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgUXVhdGVybmlvbigpO1xcblxcblxcdFxcdFxcdFxcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggcG9zaXRpb24sIHJlc3VsdCwgc2NhbGUgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0O1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdGdldFdvcmxkUm90YXRpb246IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGdldFdvcmxkUm90YXRpb24oIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgRXVsZXIoKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmdldFdvcmxkUXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiByZXN1bHQuc2V0RnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24sIHRoaXMucm90YXRpb24ub3JkZXIsIGZhbHNlICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0Z2V0V29ybGRTY2FsZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0dmFyIHF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBnZXRXb3JsZFNjYWxlKCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCByZXN1bHQgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0O1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdGdldFdvcmxkRGlyZWN0aW9uOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBnZXRXb3JsZERpcmVjdGlvbiggb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5nZXRXb3JsZFF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0LnNldCggMCwgMCwgMSApLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdHJheWNhc3Q6IGZ1bmN0aW9uICgpIHt9LFxcblxcblxcdFxcdHRyYXZlcnNlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xcblxcblxcdFxcdFxcdGNhbGxiYWNrKCB0aGlzICk7XFxuXFxuXFx0XFx0XFx0dmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdGNoaWxkcmVuWyBpIF0udHJhdmVyc2UoIGNhbGxiYWNrICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dHJhdmVyc2VWaXNpYmxlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xcblxcblxcdFxcdFxcdGlmICggdGhpcy52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcXG5cXG5cXHRcXHRcXHRjYWxsYmFjayggdGhpcyApO1xcblxcblxcdFxcdFxcdHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRjaGlsZHJlblsgaSBdLnRyYXZlcnNlVmlzaWJsZSggY2FsbGJhY2sgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0cmF2ZXJzZUFuY2VzdG9yczogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XFxuXFxuXFx0XFx0XFx0aWYgKCBwYXJlbnQgIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y2FsbGJhY2soIHBhcmVudCApO1xcblxcblxcdFxcdFxcdFxcdHBhcmVudC50cmF2ZXJzZUFuY2VzdG9ycyggY2FsbGJhY2sgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR1cGRhdGVNYXRyaXg6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm1hdHJpeC5jb21wb3NlKCB0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIHRoaXMuc2NhbGUgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dXBkYXRlTWF0cml4V29ybGQ6IGZ1bmN0aW9uICggZm9yY2UgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgKSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlIHx8IGZvcmNlICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggdGhpcy5wYXJlbnQgPT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLm1hdHJpeCApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXggKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yY2UgPSB0cnVlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyB1cGRhdGUgY2hpbGRyZW5cXG5cXG5cXHRcXHRcXHR2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y2hpbGRyZW5bIGkgXS51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcXG5cXG5cXHRcXHRcXHQvLyBtZXRhIGlzIGEgc3RyaW5nIHdoZW4gY2FsbGVkIGZyb20gSlNPTi5zdHJpbmdpZnlcXG5cXHRcXHRcXHR2YXIgaXNSb290T2JqZWN0ID0gKCBtZXRhID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG1ldGEgPT09ICdzdHJpbmcnICk7XFxuXFxuXFx0XFx0XFx0dmFyIG91dHB1dCA9IHt9O1xcblxcblxcdFxcdFxcdC8vIG1ldGEgaXMgYSBoYXNoIHVzZWQgdG8gY29sbGVjdCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMuXFxuXFx0XFx0XFx0Ly8gbm90IHByb3ZpZGluZyBpdCBpbXBsaWVzIHRoYXQgdGhpcyBpcyB0aGUgcm9vdCBvYmplY3RcXG5cXHRcXHRcXHQvLyBiZWluZyBzZXJpYWxpemVkLlxcblxcdFxcdFxcdGlmICggaXNSb290T2JqZWN0ICkge1xcblxcblxcdFxcdFxcdFxcdC8vIGluaXRpYWxpemUgbWV0YSBvYmpcXG5cXHRcXHRcXHRcXHRtZXRhID0ge1xcblxcdFxcdFxcdFxcdFxcdGdlb21ldHJpZXM6IHt9LFxcblxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsczoge30sXFxuXFx0XFx0XFx0XFx0XFx0dGV4dHVyZXM6IHt9LFxcblxcdFxcdFxcdFxcdFxcdGltYWdlczoge30sXFxuXFx0XFx0XFx0XFx0XFx0c2hhcGVzOiB7fVxcblxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0XFx0b3V0cHV0Lm1ldGFkYXRhID0ge1xcblxcdFxcdFxcdFxcdFxcdHZlcnNpb246IDQuNSxcXG5cXHRcXHRcXHRcXHRcXHR0eXBlOiAnT2JqZWN0JyxcXG5cXHRcXHRcXHRcXHRcXHRnZW5lcmF0b3I6ICdPYmplY3QzRC50b0pTT04nXFxuXFx0XFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gc3RhbmRhcmQgT2JqZWN0M0Qgc2VyaWFsaXphdGlvblxcblxcblxcdFxcdFxcdHZhciBvYmplY3QgPSB7fTtcXG5cXG5cXHRcXHRcXHRvYmplY3QudXVpZCA9IHRoaXMudXVpZDtcXG5cXHRcXHRcXHRvYmplY3QudHlwZSA9IHRoaXMudHlwZTtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBvYmplY3QubmFtZSA9IHRoaXMubmFtZTtcXG5cXHRcXHRcXHRpZiAoIHRoaXMuY2FzdFNoYWRvdyA9PT0gdHJ1ZSApIG9iamVjdC5jYXN0U2hhZG93ID0gdHJ1ZTtcXG5cXHRcXHRcXHRpZiAoIHRoaXMucmVjZWl2ZVNoYWRvdyA9PT0gdHJ1ZSApIG9iamVjdC5yZWNlaXZlU2hhZG93ID0gdHJ1ZTtcXG5cXHRcXHRcXHRpZiAoIHRoaXMudmlzaWJsZSA9PT0gZmFsc2UgKSBvYmplY3QudmlzaWJsZSA9IGZhbHNlO1xcblxcdFxcdFxcdGlmICggSlNPTi5zdHJpbmdpZnkoIHRoaXMudXNlckRhdGEgKSAhPT0gJ3t9JyApIG9iamVjdC51c2VyRGF0YSA9IHRoaXMudXNlckRhdGE7XFxuXFxuXFx0XFx0XFx0b2JqZWN0Lm1hdHJpeCA9IHRoaXMubWF0cml4LnRvQXJyYXkoKTtcXG5cXG5cXHRcXHRcXHQvL1xcblxcblxcdFxcdFxcdGZ1bmN0aW9uIHNlcmlhbGl6ZSggbGlicmFyeSwgZWxlbWVudCApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGxpYnJhcnlbIGVsZW1lbnQudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bGlicmFyeVsgZWxlbWVudC51dWlkIF0gPSBlbGVtZW50LnRvSlNPTiggbWV0YSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gZWxlbWVudC51dWlkO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRvYmplY3QuZ2VvbWV0cnkgPSBzZXJpYWxpemUoIG1ldGEuZ2VvbWV0cmllcywgdGhpcy5nZW9tZXRyeSApO1xcblxcblxcdFxcdFxcdFxcdHZhciBwYXJhbWV0ZXJzID0gdGhpcy5nZW9tZXRyeS5wYXJhbWV0ZXJzO1xcblxcblxcdFxcdFxcdFxcdGlmICggcGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICYmIHBhcmFtZXRlcnMuc2hhcGVzICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHNoYXBlcyA9IHBhcmFtZXRlcnMuc2hhcGVzO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggQXJyYXkuaXNBcnJheSggc2hhcGVzICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gc2hhcGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIHNoYXBlID0gc2hhcGVzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2VyaWFsaXplKCBtZXRhLnNoYXBlcywgc2hhcGUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRzZXJpYWxpemUoIG1ldGEuc2hhcGVzLCBzaGFwZXMgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMubWF0ZXJpYWwgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIEFycmF5LmlzQXJyYXkoIHRoaXMubWF0ZXJpYWwgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgdXVpZHMgPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLm1hdGVyaWFsLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dXVpZHMucHVzaCggc2VyaWFsaXplKCBtZXRhLm1hdGVyaWFscywgdGhpcy5tYXRlcmlhbFsgaSBdICkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0b2JqZWN0Lm1hdGVyaWFsID0gdXVpZHM7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRvYmplY3QubWF0ZXJpYWwgPSBzZXJpYWxpemUoIG1ldGEubWF0ZXJpYWxzLCB0aGlzLm1hdGVyaWFsICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvL1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwICkge1xcblxcblxcdFxcdFxcdFxcdG9iamVjdC5jaGlsZHJlbiA9IFtdO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdG9iamVjdC5jaGlsZHJlbi5wdXNoKCB0aGlzLmNoaWxkcmVuWyBpIF0udG9KU09OKCBtZXRhICkub2JqZWN0ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGlzUm9vdE9iamVjdCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZ2VvbWV0cmllcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuZ2VvbWV0cmllcyApO1xcblxcdFxcdFxcdFxcdHZhciBtYXRlcmlhbHMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLm1hdGVyaWFscyApO1xcblxcdFxcdFxcdFxcdHZhciB0ZXh0dXJlcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEudGV4dHVyZXMgKTtcXG5cXHRcXHRcXHRcXHR2YXIgaW1hZ2VzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5pbWFnZXMgKTtcXG5cXHRcXHRcXHRcXHR2YXIgc2hhcGVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5zaGFwZXMgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJpZXMubGVuZ3RoID4gMCApIG91dHB1dC5nZW9tZXRyaWVzID0gZ2VvbWV0cmllcztcXG5cXHRcXHRcXHRcXHRpZiAoIG1hdGVyaWFscy5sZW5ndGggPiAwICkgb3V0cHV0Lm1hdGVyaWFscyA9IG1hdGVyaWFscztcXG5cXHRcXHRcXHRcXHRpZiAoIHRleHR1cmVzLmxlbmd0aCA+IDAgKSBvdXRwdXQudGV4dHVyZXMgPSB0ZXh0dXJlcztcXG5cXHRcXHRcXHRcXHRpZiAoIGltYWdlcy5sZW5ndGggPiAwICkgb3V0cHV0LmltYWdlcyA9IGltYWdlcztcXG5cXHRcXHRcXHRcXHRpZiAoIHNoYXBlcy5sZW5ndGggPiAwICkgb3V0cHV0LnNoYXBlcyA9IHNoYXBlcztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0b3V0cHV0Lm9iamVjdCA9IG9iamVjdDtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gb3V0cHV0O1xcblxcblxcdFxcdFxcdC8vIGV4dHJhY3QgZGF0YSBmcm9tIHRoZSBjYWNoZSBoYXNoXFxuXFx0XFx0XFx0Ly8gcmVtb3ZlIG1ldGFkYXRhIG9uIGVhY2ggaXRlbVxcblxcdFxcdFxcdC8vIGFuZCByZXR1cm4gYXMgYXJyYXlcXG5cXHRcXHRcXHRmdW5jdGlvbiBleHRyYWN0RnJvbUNhY2hlKCBjYWNoZSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdmFsdWVzID0gW107XFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGtleSBpbiBjYWNoZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgZGF0YSA9IGNhY2hlWyBrZXkgXTtcXG5cXHRcXHRcXHRcXHRcXHRkZWxldGUgZGF0YS5tZXRhZGF0YTtcXG5cXHRcXHRcXHRcXHRcXHR2YWx1ZXMucHVzaCggZGF0YSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdmFsdWVzO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoIHJlY3Vyc2l2ZSApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzLCByZWN1cnNpdmUgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlLCByZWN1cnNpdmUgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCByZWN1cnNpdmUgPT09IHVuZGVmaW5lZCApIHJlY3Vyc2l2ZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7XFxuXFxuXFx0XFx0XFx0dGhpcy51cC5jb3B5KCBzb3VyY2UudXAgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLnBvc2l0aW9uLmNvcHkoIHNvdXJjZS5wb3NpdGlvbiApO1xcblxcdFxcdFxcdHRoaXMucXVhdGVybmlvbi5jb3B5KCBzb3VyY2UucXVhdGVybmlvbiApO1xcblxcdFxcdFxcdHRoaXMuc2NhbGUuY29weSggc291cmNlLnNjYWxlICk7XFxuXFxuXFx0XFx0XFx0dGhpcy5tYXRyaXguY29weSggc291cmNlLm1hdHJpeCApO1xcblxcdFxcdFxcdHRoaXMubWF0cml4V29ybGQuY29weSggc291cmNlLm1hdHJpeFdvcmxkICk7XFxuXFxuXFx0XFx0XFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XFxuXFx0XFx0XFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gc291cmNlLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU7XFxuXFxuXFx0XFx0XFx0dGhpcy5sYXllcnMubWFzayA9IHNvdXJjZS5sYXllcnMubWFzaztcXG5cXHRcXHRcXHR0aGlzLnZpc2libGUgPSBzb3VyY2UudmlzaWJsZTtcXG5cXG5cXHRcXHRcXHR0aGlzLmNhc3RTaGFkb3cgPSBzb3VyY2UuY2FzdFNoYWRvdztcXG5cXHRcXHRcXHR0aGlzLnJlY2VpdmVTaGFkb3cgPSBzb3VyY2UucmVjZWl2ZVNoYWRvdztcXG5cXG5cXHRcXHRcXHR0aGlzLmZydXN0dW1DdWxsZWQgPSBzb3VyY2UuZnJ1c3R1bUN1bGxlZDtcXG5cXHRcXHRcXHR0aGlzLnJlbmRlck9yZGVyID0gc291cmNlLnJlbmRlck9yZGVyO1xcblxcblxcdFxcdFxcdHRoaXMudXNlckRhdGEgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggc291cmNlLnVzZXJEYXRhICkgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIHJlY3Vyc2l2ZSA9PT0gdHJ1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBzb3VyY2UuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBjaGlsZCA9IHNvdXJjZS5jaGlsZHJlblsgaSBdO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuYWRkKCBjaGlsZC5jbG9uZSgpICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cXG5cXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcXG5cXHQqL1xcblxcblxcdGZ1bmN0aW9uIENhbWVyYSgpIHtcXG5cXG5cXHRcXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ0NhbWVyYSc7XFxuXFxuXFx0XFx0dGhpcy5tYXRyaXhXb3JsZEludmVyc2UgPSBuZXcgTWF0cml4NCgpO1xcblxcdFxcdHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XFxuXFxuXFx0fVxcblxcblxcdENhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBDYW1lcmEsXFxuXFxuXFx0XFx0aXNDYW1lcmE6IHRydWUsXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcXG5cXG5cXHRcXHRcXHRPYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xcblxcblxcdFxcdFxcdHRoaXMubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoIHNvdXJjZS5tYXRyaXhXb3JsZEludmVyc2UgKTtcXG5cXHRcXHRcXHR0aGlzLnByb2plY3Rpb25NYXRyaXguY29weSggc291cmNlLnByb2plY3Rpb25NYXRyaXggKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldFdvcmxkRGlyZWN0aW9uOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBnZXRXb3JsZERpcmVjdGlvbiggb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5nZXRXb3JsZFF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0LnNldCggMCwgMCwgLSAxICkuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0dXBkYXRlTWF0cml4V29ybGQ6IGZ1bmN0aW9uICggZm9yY2UgKSB7XFxuXFxuXFx0XFx0XFx0T2JqZWN0M0QucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkLmNhbGwoIHRoaXMsIGZvcmNlICk7XFxuXFxuXFx0XFx0XFx0dGhpcy5tYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqIEBhdXRob3IgYXJvc2UgLyBodHRwOi8vZ2l0aHViLmNvbS9hcm9zZVxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIE9ydGhvZ3JhcGhpY0NhbWVyYSggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKSB7XFxuXFxuXFx0XFx0Q2FtZXJhLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnT3J0aG9ncmFwaGljQ2FtZXJhJztcXG5cXG5cXHRcXHR0aGlzLnpvb20gPSAxO1xcblxcdFxcdHRoaXMudmlldyA9IG51bGw7XFxuXFxuXFx0XFx0dGhpcy5sZWZ0ID0gbGVmdDtcXG5cXHRcXHR0aGlzLnJpZ2h0ID0gcmlnaHQ7XFxuXFx0XFx0dGhpcy50b3AgPSB0b3A7XFxuXFx0XFx0dGhpcy5ib3R0b20gPSBib3R0b207XFxuXFxuXFx0XFx0dGhpcy5uZWFyID0gKCBuZWFyICE9PSB1bmRlZmluZWQgKSA/IG5lYXIgOiAwLjE7XFxuXFx0XFx0dGhpcy5mYXIgPSAoIGZhciAhPT0gdW5kZWZpbmVkICkgPyBmYXIgOiAyMDAwO1xcblxcblxcdFxcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xcblxcblxcdH1cXG5cXG5cXHRPcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggQ2FtZXJhLnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IE9ydGhvZ3JhcGhpY0NhbWVyYSxcXG5cXG5cXHRcXHRpc09ydGhvZ3JhcGhpY0NhbWVyYTogdHJ1ZSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xcblxcblxcdFxcdFxcdENhbWVyYS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xcblxcblxcdFxcdFxcdHRoaXMubGVmdCA9IHNvdXJjZS5sZWZ0O1xcblxcdFxcdFxcdHRoaXMucmlnaHQgPSBzb3VyY2UucmlnaHQ7XFxuXFx0XFx0XFx0dGhpcy50b3AgPSBzb3VyY2UudG9wO1xcblxcdFxcdFxcdHRoaXMuYm90dG9tID0gc291cmNlLmJvdHRvbTtcXG5cXHRcXHRcXHR0aGlzLm5lYXIgPSBzb3VyY2UubmVhcjtcXG5cXHRcXHRcXHR0aGlzLmZhciA9IHNvdXJjZS5mYXI7XFxuXFxuXFx0XFx0XFx0dGhpcy56b29tID0gc291cmNlLnpvb207XFxuXFx0XFx0XFx0dGhpcy52aWV3ID0gc291cmNlLnZpZXcgPT09IG51bGwgPyBudWxsIDogT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS52aWV3ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRWaWV3T2Zmc2V0OiBmdW5jdGlvbiAoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMudmlldyA9PT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnZpZXcgPSB7XFxuXFx0XFx0XFx0XFx0XFx0ZW5hYmxlZDogdHJ1ZSxcXG5cXHRcXHRcXHRcXHRcXHRmdWxsV2lkdGg6IDEsXFxuXFx0XFx0XFx0XFx0XFx0ZnVsbEhlaWdodDogMSxcXG5cXHRcXHRcXHRcXHRcXHRvZmZzZXRYOiAwLFxcblxcdFxcdFxcdFxcdFxcdG9mZnNldFk6IDAsXFxuXFx0XFx0XFx0XFx0XFx0d2lkdGg6IDEsXFxuXFx0XFx0XFx0XFx0XFx0aGVpZ2h0OiAxXFxuXFx0XFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy52aWV3LmVuYWJsZWQgPSB0cnVlO1xcblxcdFxcdFxcdHRoaXMudmlldy5mdWxsV2lkdGggPSBmdWxsV2lkdGg7XFxuXFx0XFx0XFx0dGhpcy52aWV3LmZ1bGxIZWlnaHQgPSBmdWxsSGVpZ2h0O1xcblxcdFxcdFxcdHRoaXMudmlldy5vZmZzZXRYID0geDtcXG5cXHRcXHRcXHR0aGlzLnZpZXcub2Zmc2V0WSA9IHk7XFxuXFx0XFx0XFx0dGhpcy52aWV3LndpZHRoID0gd2lkdGg7XFxuXFx0XFx0XFx0dGhpcy52aWV3LmhlaWdodCA9IGhlaWdodDtcXG5cXG5cXHRcXHRcXHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsZWFyVmlld09mZnNldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGlmICggdGhpcy52aWV3ICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMudmlldy5lbmFibGVkID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dXBkYXRlUHJvamVjdGlvbk1hdHJpeDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBkeCA9ICggdGhpcy5yaWdodCAtIHRoaXMubGVmdCApIC8gKCAyICogdGhpcy56b29tICk7XFxuXFx0XFx0XFx0dmFyIGR5ID0gKCB0aGlzLnRvcCAtIHRoaXMuYm90dG9tICkgLyAoIDIgKiB0aGlzLnpvb20gKTtcXG5cXHRcXHRcXHR2YXIgY3ggPSAoIHRoaXMucmlnaHQgKyB0aGlzLmxlZnQgKSAvIDI7XFxuXFx0XFx0XFx0dmFyIGN5ID0gKCB0aGlzLnRvcCArIHRoaXMuYm90dG9tICkgLyAyO1xcblxcblxcdFxcdFxcdHZhciBsZWZ0ID0gY3ggLSBkeDtcXG5cXHRcXHRcXHR2YXIgcmlnaHQgPSBjeCArIGR4O1xcblxcdFxcdFxcdHZhciB0b3AgPSBjeSArIGR5O1xcblxcdFxcdFxcdHZhciBib3R0b20gPSBjeSAtIGR5O1xcblxcblxcdFxcdFxcdGlmICggdGhpcy52aWV3ICE9PSBudWxsICYmIHRoaXMudmlldy5lbmFibGVkICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB6b29tVyA9IHRoaXMuem9vbSAvICggdGhpcy52aWV3LndpZHRoIC8gdGhpcy52aWV3LmZ1bGxXaWR0aCApO1xcblxcdFxcdFxcdFxcdHZhciB6b29tSCA9IHRoaXMuem9vbSAvICggdGhpcy52aWV3LmhlaWdodCAvIHRoaXMudmlldy5mdWxsSGVpZ2h0ICk7XFxuXFx0XFx0XFx0XFx0dmFyIHNjYWxlVyA9ICggdGhpcy5yaWdodCAtIHRoaXMubGVmdCApIC8gdGhpcy52aWV3LndpZHRoO1xcblxcdFxcdFxcdFxcdHZhciBzY2FsZUggPSAoIHRoaXMudG9wIC0gdGhpcy5ib3R0b20gKSAvIHRoaXMudmlldy5oZWlnaHQ7XFxuXFxuXFx0XFx0XFx0XFx0bGVmdCArPSBzY2FsZVcgKiAoIHRoaXMudmlldy5vZmZzZXRYIC8gem9vbVcgKTtcXG5cXHRcXHRcXHRcXHRyaWdodCA9IGxlZnQgKyBzY2FsZVcgKiAoIHRoaXMudmlldy53aWR0aCAvIHpvb21XICk7XFxuXFx0XFx0XFx0XFx0dG9wIC09IHNjYWxlSCAqICggdGhpcy52aWV3Lm9mZnNldFkgLyB6b29tSCApO1xcblxcdFxcdFxcdFxcdGJvdHRvbSA9IHRvcCAtIHNjYWxlSCAqICggdGhpcy52aWV3LmhlaWdodCAvIHpvb21IICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlT3J0aG9ncmFwaGljKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIHRoaXMubmVhciwgdGhpcy5mYXIgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xcblxcblxcdFxcdFxcdHZhciBkYXRhID0gT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XFxuXFxuXFx0XFx0XFx0ZGF0YS5vYmplY3Quem9vbSA9IHRoaXMuem9vbTtcXG5cXHRcXHRcXHRkYXRhLm9iamVjdC5sZWZ0ID0gdGhpcy5sZWZ0O1xcblxcdFxcdFxcdGRhdGEub2JqZWN0LnJpZ2h0ID0gdGhpcy5yaWdodDtcXG5cXHRcXHRcXHRkYXRhLm9iamVjdC50b3AgPSB0aGlzLnRvcDtcXG5cXHRcXHRcXHRkYXRhLm9iamVjdC5ib3R0b20gPSB0aGlzLmJvdHRvbTtcXG5cXHRcXHRcXHRkYXRhLm9iamVjdC5uZWFyID0gdGhpcy5uZWFyO1xcblxcdFxcdFxcdGRhdGEub2JqZWN0LmZhciA9IHRoaXMuZmFyO1xcblxcblxcdFxcdFxcdGlmICggdGhpcy52aWV3ICE9PSBudWxsICkgZGF0YS5vYmplY3QudmlldyA9IE9iamVjdC5hc3NpZ24oIHt9LCB0aGlzLnZpZXcgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZGF0YTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBGYWNlMyggYSwgYiwgYywgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApIHtcXG5cXG5cXHRcXHR0aGlzLmEgPSBhO1xcblxcdFxcdHRoaXMuYiA9IGI7XFxuXFx0XFx0dGhpcy5jID0gYztcXG5cXG5cXHRcXHR0aGlzLm5vcm1hbCA9ICggbm9ybWFsICYmIG5vcm1hbC5pc1ZlY3RvcjMgKSA/IG5vcm1hbCA6IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0dGhpcy52ZXJ0ZXhOb3JtYWxzID0gQXJyYXkuaXNBcnJheSggbm9ybWFsICkgPyBub3JtYWwgOiBbXTtcXG5cXG5cXHRcXHR0aGlzLmNvbG9yID0gKCBjb2xvciAmJiBjb2xvci5pc0NvbG9yICkgPyBjb2xvciA6IG5ldyBDb2xvcigpO1xcblxcdFxcdHRoaXMudmVydGV4Q29sb3JzID0gQXJyYXkuaXNBcnJheSggY29sb3IgKSA/IGNvbG9yIDogW107XFxuXFxuXFx0XFx0dGhpcy5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWxJbmRleCA6IDA7XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5hc3NpZ24oIEZhY2UzLnByb3RvdHlwZSwge1xcblxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5hID0gc291cmNlLmE7XFxuXFx0XFx0XFx0dGhpcy5iID0gc291cmNlLmI7XFxuXFx0XFx0XFx0dGhpcy5jID0gc291cmNlLmM7XFxuXFxuXFx0XFx0XFx0dGhpcy5ub3JtYWwuY29weSggc291cmNlLm5vcm1hbCApO1xcblxcdFxcdFxcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XFxuXFxuXFx0XFx0XFx0dGhpcy5tYXRlcmlhbEluZGV4ID0gc291cmNlLm1hdGVyaWFsSW5kZXg7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHNvdXJjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMudmVydGV4Tm9ybWFsc1sgaSBdID0gc291cmNlLnZlcnRleE5vcm1hbHNbIGkgXS5jbG9uZSgpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gc291cmNlLnZlcnRleENvbG9ycy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnZlcnRleENvbG9yc1sgaSBdID0gc291cmNlLnZlcnRleENvbG9yc1sgaSBdLmNsb25lKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIGtpbGUgLyBodHRwOi8va2lsZS5zdHJhdmFnYW56YS5vcmcvXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xcblxcdCAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcXG5cXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXFxuXFx0ICovXFxuXFxuXFx0dmFyIGdlb21ldHJ5SWQgPSAwOyAvLyBHZW9tZXRyeSB1c2VzIGV2ZW4gbnVtYmVycyBhcyBJZFxcblxcblxcdGZ1bmN0aW9uIEdlb21ldHJ5KCkge1xcblxcblxcdFxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogZ2VvbWV0cnlJZCArPSAyIH0gKTtcXG5cXG5cXHRcXHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcXG5cXG5cXHRcXHR0aGlzLm5hbWUgPSAnJztcXG5cXHRcXHR0aGlzLnR5cGUgPSAnR2VvbWV0cnknO1xcblxcblxcdFxcdHRoaXMudmVydGljZXMgPSBbXTtcXG5cXHRcXHR0aGlzLmNvbG9ycyA9IFtdO1xcblxcdFxcdHRoaXMuZmFjZXMgPSBbXTtcXG5cXHRcXHR0aGlzLmZhY2VWZXJ0ZXhVdnMgPSBbW11dO1xcblxcblxcdFxcdHRoaXMubW9ycGhUYXJnZXRzID0gW107XFxuXFx0XFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBbXTtcXG5cXG5cXHRcXHR0aGlzLnNraW5XZWlnaHRzID0gW107XFxuXFx0XFx0dGhpcy5za2luSW5kaWNlcyA9IFtdO1xcblxcblxcdFxcdHRoaXMubGluZURpc3RhbmNlcyA9IFtdO1xcblxcblxcdFxcdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xcblxcdFxcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xcblxcblxcdFxcdC8vIHVwZGF0ZSBmbGFnc1xcblxcblxcdFxcdHRoaXMuZWxlbWVudHNOZWVkVXBkYXRlID0gZmFsc2U7XFxuXFx0XFx0dGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XFxuXFx0XFx0dGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XFxuXFx0XFx0dGhpcy5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xcblxcdFxcdHRoaXMuZ3JvdXBzTmVlZFVwZGF0ZSA9IGZhbHNlO1xcblxcblxcdH1cXG5cXG5cXHRHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlICksIHtcXG5cXG5cXHRcXHRjb25zdHJ1Y3RvcjogR2VvbWV0cnksXFxuXFxuXFx0XFx0aXNHZW9tZXRyeTogdHJ1ZSxcXG5cXG5cXHRcXHRhcHBseU1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XFxuXFxuXFx0XFx0XFx0dmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBNYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdmVydGV4ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xcblxcdFxcdFxcdFxcdHZlcnRleC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZmFjZSA9IHRoaXMuZmFjZXNbIGkgXTtcXG5cXHRcXHRcXHRcXHRmYWNlLm5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzWyBqIF0uYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggdGhpcy5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xcblxcdFxcdFxcdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cm90YXRlWDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeC1heGlzXFxuXFxuXFx0XFx0XFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWCggYW5nbGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0bTEubWFrZVJvdGF0aW9uWCggYW5nbGUgKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHktYXhpc1xcblxcblxcdFxcdFxcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVkoIGFuZ2xlICkge1xcblxcblxcdFxcdFxcdFxcdG0xLm1ha2VSb3RhdGlvblkoIGFuZ2xlICk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRyb3RhdGVaOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB6LWF4aXNcXG5cXG5cXHRcXHRcXHR2YXIgbTEgPSBuZXcgTWF0cml4NCgpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiByb3RhdGVaKCBhbmdsZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRtMS5tYWtlUm90YXRpb25aKCBhbmdsZSApO1xcblxcblxcdFxcdFxcdFxcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Ly8gdHJhbnNsYXRlIGdlb21ldHJ5XFxuXFxuXFx0XFx0XFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gdHJhbnNsYXRlKCB4LCB5LCB6ICkge1xcblxcblxcdFxcdFxcdFxcdG0xLm1ha2VUcmFuc2xhdGlvbiggeCwgeSwgeiApO1xcblxcblxcdFxcdFxcdFxcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0c2NhbGU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHQvLyBzY2FsZSBnZW9tZXRyeVxcblxcblxcdFxcdFxcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHNjYWxlKCB4LCB5LCB6ICkge1xcblxcblxcdFxcdFxcdFxcdG0xLm1ha2VTY2FsZSggeCwgeSwgeiApO1xcblxcblxcdFxcdFxcdFxcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0bG9va0F0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIG9iaiA9IG5ldyBPYmplY3QzRCgpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBsb29rQXQoIHZlY3RvciApIHtcXG5cXG5cXHRcXHRcXHRcXHRvYmoubG9va0F0KCB2ZWN0b3IgKTtcXG5cXG5cXHRcXHRcXHRcXHRvYmoudXBkYXRlTWF0cml4KCk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5hcHBseU1hdHJpeCggb2JqLm1hdHJpeCApO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdGZyb21CdWZmZXJHZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgc2NvcGUgPSB0aGlzO1xcblxcblxcdFxcdFxcdHZhciBpbmRpY2VzID0gZ2VvbWV0cnkuaW5kZXggIT09IG51bGwgPyBnZW9tZXRyeS5pbmRleC5hcnJheSA6IHVuZGVmaW5lZDtcXG5cXHRcXHRcXHR2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XFxuXFxuXFx0XFx0XFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XFxuXFx0XFx0XFx0dmFyIG5vcm1hbHMgPSBhdHRyaWJ1dGVzLm5vcm1hbCAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy5ub3JtYWwuYXJyYXkgOiB1bmRlZmluZWQ7XFxuXFx0XFx0XFx0dmFyIGNvbG9ycyA9IGF0dHJpYnV0ZXMuY29sb3IgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMuY29sb3IuYXJyYXkgOiB1bmRlZmluZWQ7XFxuXFx0XFx0XFx0dmFyIHV2cyA9IGF0dHJpYnV0ZXMudXYgIT09IHVuZGVmaW5lZCA/IGF0dHJpYnV0ZXMudXYuYXJyYXkgOiB1bmRlZmluZWQ7XFxuXFx0XFx0XFx0dmFyIHV2czIgPSBhdHRyaWJ1dGVzLnV2MiAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy51djIuYXJyYXkgOiB1bmRlZmluZWQ7XFxuXFxuXFx0XFx0XFx0aWYgKCB1dnMyICE9PSB1bmRlZmluZWQgKSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDEgXSA9IFtdO1xcblxcblxcdFxcdFxcdHZhciB0ZW1wTm9ybWFscyA9IFtdO1xcblxcdFxcdFxcdHZhciB0ZW1wVVZzID0gW107XFxuXFx0XFx0XFx0dmFyIHRlbXBVVnMyID0gW107XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBqID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkgKz0gMywgaiArPSAyICkge1xcblxcblxcdFxcdFxcdFxcdHNjb3BlLnZlcnRpY2VzLnB1c2goIG5ldyBWZWN0b3IzKCBwb3NpdGlvbnNbIGkgXSwgcG9zaXRpb25zWyBpICsgMSBdLCBwb3NpdGlvbnNbIGkgKyAyIF0gKSApO1xcblxcblxcdFxcdFxcdFxcdGlmICggbm9ybWFscyAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRlbXBOb3JtYWxzLnB1c2goIG5ldyBWZWN0b3IzKCBub3JtYWxzWyBpIF0sIG5vcm1hbHNbIGkgKyAxIF0sIG5vcm1hbHNbIGkgKyAyIF0gKSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGNvbG9ycyAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHNjb3BlLmNvbG9ycy5wdXNoKCBuZXcgQ29sb3IoIGNvbG9yc1sgaSBdLCBjb2xvcnNbIGkgKyAxIF0sIGNvbG9yc1sgaSArIDIgXSApICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggdXZzICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGVtcFVWcy5wdXNoKCBuZXcgVmVjdG9yMiggdXZzWyBqIF0sIHV2c1sgaiArIDEgXSApICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggdXZzMiAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRlbXBVVnMyLnB1c2goIG5ldyBWZWN0b3IyKCB1dnMyWyBqIF0sIHV2czJbIGogKyAxIF0gKSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gYWRkRmFjZSggYSwgYiwgYywgbWF0ZXJpYWxJbmRleCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdmVydGV4Tm9ybWFscyA9IG5vcm1hbHMgIT09IHVuZGVmaW5lZCA/IFsgdGVtcE5vcm1hbHNbIGEgXS5jbG9uZSgpLCB0ZW1wTm9ybWFsc1sgYiBdLmNsb25lKCksIHRlbXBOb3JtYWxzWyBjIF0uY2xvbmUoKSBdIDogW107XFxuXFx0XFx0XFx0XFx0dmFyIHZlcnRleENvbG9ycyA9IGNvbG9ycyAhPT0gdW5kZWZpbmVkID8gWyBzY29wZS5jb2xvcnNbIGEgXS5jbG9uZSgpLCBzY29wZS5jb2xvcnNbIGIgXS5jbG9uZSgpLCBzY29wZS5jb2xvcnNbIGMgXS5jbG9uZSgpIF0gOiBbXTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZmFjZSA9IG5ldyBGYWNlMyggYSwgYiwgYywgdmVydGV4Tm9ybWFscywgdmVydGV4Q29sb3JzLCBtYXRlcmlhbEluZGV4ICk7XFxuXFxuXFx0XFx0XFx0XFx0c2NvcGUuZmFjZXMucHVzaCggZmFjZSApO1xcblxcblxcdFxcdFxcdFxcdGlmICggdXZzICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0c2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdGVtcFVWc1sgYSBdLmNsb25lKCksIHRlbXBVVnNbIGIgXS5jbG9uZSgpLCB0ZW1wVVZzWyBjIF0uY2xvbmUoKSBdICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggdXZzMiAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDEgXS5wdXNoKCBbIHRlbXBVVnMyWyBhIF0uY2xvbmUoKSwgdGVtcFVWczJbIGIgXS5jbG9uZSgpLCB0ZW1wVVZzMlsgYyBdLmNsb25lKCkgXSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcXG5cXG5cXHRcXHRcXHRpZiAoIGdyb3Vwcy5sZW5ndGggPiAwICkge1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHN0YXJ0ID0gZ3JvdXAuc3RhcnQ7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGNvdW50ID0gZ3JvdXAuY291bnQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGogPSBzdGFydCwgamwgPSBzdGFydCArIGNvdW50OyBqIDwgamw7IGogKz0gMyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGluZGljZXMgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRhZGRGYWNlKCBpbmRpY2VzWyBqIF0sIGluZGljZXNbIGogKyAxIF0sIGluZGljZXNbIGogKyAyIF0sIGdyb3VwLm1hdGVyaWFsSW5kZXggKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGFkZEZhY2UoIGosIGogKyAxLCBqICsgMiwgZ3JvdXAubWF0ZXJpYWxJbmRleCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBpbmRpY2VzICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkgKz0gMyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRhZGRGYWNlKCBpbmRpY2VzWyBpIF0sIGluZGljZXNbIGkgKyAxIF0sIGluZGljZXNbIGkgKyAyIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoIC8gMzsgaSArPSAzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGFkZEZhY2UoIGksIGkgKyAxLCBpICsgMiApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XFxuXFxuXFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmJvdW5kaW5nQm94ID0gZ2VvbWV0cnkuYm91bmRpbmdCb3guY2xvbmUoKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjZW50ZXI6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xcblxcblxcdFxcdFxcdHZhciBvZmZzZXQgPSB0aGlzLmJvdW5kaW5nQm94LmdldENlbnRlcigpLm5lZ2F0ZSgpO1xcblxcblxcdFxcdFxcdHRoaXMudHJhbnNsYXRlKCBvZmZzZXQueCwgb2Zmc2V0LnksIG9mZnNldC56ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG9mZnNldDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XFxuXFxuXFx0XFx0XFx0dmFyIGNlbnRlciA9IHRoaXMuYm91bmRpbmdTcGhlcmUuY2VudGVyO1xcblxcdFxcdFxcdHZhciByYWRpdXMgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cztcXG5cXG5cXHRcXHRcXHR2YXIgcyA9IHJhZGl1cyA9PT0gMCA/IDEgOiAxLjAgLyByYWRpdXM7XFxuXFxuXFx0XFx0XFx0dmFyIG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XFxuXFx0XFx0XFx0bWF0cml4LnNldChcXG5cXHRcXHRcXHRcXHRzLCAwLCAwLCAtIHMgKiBjZW50ZXIueCxcXG5cXHRcXHRcXHRcXHQwLCBzLCAwLCAtIHMgKiBjZW50ZXIueSxcXG5cXHRcXHRcXHRcXHQwLCAwLCBzLCAtIHMgKiBjZW50ZXIueixcXG5cXHRcXHRcXHRcXHQwLCAwLCAwLCAxXFxuXFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHR0aGlzLmFwcGx5TWF0cml4KCBtYXRyaXggKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvbXB1dGVGYWNlTm9ybWFsczogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBjYiA9IG5ldyBWZWN0b3IzKCksIGFiID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdkEgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmEgXTtcXG5cXHRcXHRcXHRcXHR2YXIgdkIgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmIgXTtcXG5cXHRcXHRcXHRcXHR2YXIgdkMgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmMgXTtcXG5cXG5cXHRcXHRcXHRcXHRjYi5zdWJWZWN0b3JzKCB2QywgdkIgKTtcXG5cXHRcXHRcXHRcXHRhYi5zdWJWZWN0b3JzKCB2QSwgdkIgKTtcXG5cXHRcXHRcXHRcXHRjYi5jcm9zcyggYWIgKTtcXG5cXG5cXHRcXHRcXHRcXHRjYi5ub3JtYWxpemUoKTtcXG5cXG5cXHRcXHRcXHRcXHRmYWNlLm5vcm1hbC5jb3B5KCBjYiApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvbXB1dGVWZXJ0ZXhOb3JtYWxzOiBmdW5jdGlvbiAoIGFyZWFXZWlnaHRlZCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGFyZWFXZWlnaHRlZCA9PT0gdW5kZWZpbmVkICkgYXJlYVdlaWdodGVkID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHR2YXIgdiwgdmwsIGYsIGZsLCBmYWNlLCB2ZXJ0aWNlcztcXG5cXG5cXHRcXHRcXHR2ZXJ0aWNlcyA9IG5ldyBBcnJheSggdGhpcy52ZXJ0aWNlcy5sZW5ndGggKTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2ID0gMCwgdmwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZlcnRpY2VzWyB2IF0gPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGFyZWFXZWlnaHRlZCApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyB2ZXJ0ZXggbm9ybWFscyB3ZWlnaHRlZCBieSB0cmlhbmdsZSBhcmVhc1xcblxcdFxcdFxcdFxcdC8vIGh0dHA6Ly93d3cuaXF1aWxlemxlcy5vcmcvd3d3L2FydGljbGVzL25vcm1hbHMvbm9ybWFscy5odG1cXG5cXG5cXHRcXHRcXHRcXHR2YXIgdkEsIHZCLCB2QztcXG5cXHRcXHRcXHRcXHR2YXIgY2IgPSBuZXcgVmVjdG9yMygpLCBhYiA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xcblxcblxcdFxcdFxcdFxcdFxcdHZBID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5hIF07XFxuXFx0XFx0XFx0XFx0XFx0dkIgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmIgXTtcXG5cXHRcXHRcXHRcXHRcXHR2QyA9IHRoaXMudmVydGljZXNbIGZhY2UuYyBdO1xcblxcblxcdFxcdFxcdFxcdFxcdGNiLnN1YlZlY3RvcnMoIHZDLCB2QiApO1xcblxcdFxcdFxcdFxcdFxcdGFiLnN1YlZlY3RvcnMoIHZBLCB2QiApO1xcblxcdFxcdFxcdFxcdFxcdGNiLmNyb3NzKCBhYiApO1xcblxcblxcdFxcdFxcdFxcdFxcdHZlcnRpY2VzWyBmYWNlLmEgXS5hZGQoIGNiICk7XFxuXFx0XFx0XFx0XFx0XFx0dmVydGljZXNbIGZhY2UuYiBdLmFkZCggY2IgKTtcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0aWNlc1sgZmFjZS5jIF0uYWRkKCBjYiApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xcblxcblxcdFxcdFxcdFxcdFxcdHZlcnRpY2VzWyBmYWNlLmEgXS5hZGQoIGZhY2Uubm9ybWFsICk7XFxuXFx0XFx0XFx0XFx0XFx0dmVydGljZXNbIGZhY2UuYiBdLmFkZCggZmFjZS5ub3JtYWwgKTtcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0aWNlc1sgZmFjZS5jIF0uYWRkKCBmYWNlLm5vcm1hbCApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Zm9yICggdiA9IDAsIHZsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2ZXJ0aWNlc1sgdiBdLm5vcm1hbGl6ZSgpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xcblxcblxcdFxcdFxcdFxcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB2ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA9PT0gMyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0ZXhOb3JtYWxzWyAwIF0uY29weSggdmVydGljZXNbIGZhY2UuYSBdICk7XFxuXFx0XFx0XFx0XFx0XFx0dmVydGV4Tm9ybWFsc1sgMSBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmIgXSApO1xcblxcdFxcdFxcdFxcdFxcdHZlcnRleE5vcm1hbHNbIDIgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5jIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdHZlcnRleE5vcm1hbHNbIDAgXSA9IHZlcnRpY2VzWyBmYWNlLmEgXS5jbG9uZSgpO1xcblxcdFxcdFxcdFxcdFxcdHZlcnRleE5vcm1hbHNbIDEgXSA9IHZlcnRpY2VzWyBmYWNlLmIgXS5jbG9uZSgpO1xcblxcdFxcdFxcdFxcdFxcdHZlcnRleE5vcm1hbHNbIDIgXSA9IHZlcnRpY2VzWyBmYWNlLmMgXS5jbG9uZSgpO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmZhY2VzLmxlbmd0aCA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29tcHV0ZUZsYXRWZXJ0ZXhOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGYsIGZsLCBmYWNlO1xcblxcblxcdFxcdFxcdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XFxuXFxuXFx0XFx0XFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xcblxcblxcdFxcdFxcdFxcdHZhciB2ZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzO1xcblxcblxcdFxcdFxcdFxcdGlmICggdmVydGV4Tm9ybWFscy5sZW5ndGggPT09IDMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmVydGV4Tm9ybWFsc1sgMCBdLmNvcHkoIGZhY2Uubm9ybWFsICk7XFxuXFx0XFx0XFx0XFx0XFx0dmVydGV4Tm9ybWFsc1sgMSBdLmNvcHkoIGZhY2Uubm9ybWFsICk7XFxuXFx0XFx0XFx0XFx0XFx0dmVydGV4Tm9ybWFsc1sgMiBdLmNvcHkoIGZhY2Uubm9ybWFsICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0ZXhOb3JtYWxzWyAwIF0gPSBmYWNlLm5vcm1hbC5jbG9uZSgpO1xcblxcdFxcdFxcdFxcdFxcdHZlcnRleE5vcm1hbHNbIDEgXSA9IGZhY2Uubm9ybWFsLmNsb25lKCk7XFxuXFx0XFx0XFx0XFx0XFx0dmVydGV4Tm9ybWFsc1sgMiBdID0gZmFjZS5ub3JtYWwuY2xvbmUoKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggdGhpcy5mYWNlcy5sZW5ndGggPiAwICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvbXB1dGVNb3JwaE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgaSwgaWwsIGYsIGZsLCBmYWNlO1xcblxcblxcdFxcdFxcdC8vIHNhdmUgb3JpZ2luYWwgbm9ybWFsc1xcblxcdFxcdFxcdC8vIC0gY3JlYXRlIHRlbXAgdmFyaWFibGVzIG9uIGZpcnN0IGFjY2Vzc1xcblxcdFxcdFxcdC8vICAgb3RoZXJ3aXNlIGp1c3QgY29weSAoZm9yIGZhc3RlciByZXBlYXRlZCBjYWxscylcXG5cXG5cXHRcXHRcXHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xcblxcblxcdFxcdFxcdFxcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCAhIGZhY2UuX19vcmlnaW5hbEZhY2VOb3JtYWwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbCA9IGZhY2Uubm9ybWFsLmNsb25lKCk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggISBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzICkgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscyA9IFtdO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIGkgPSAwLCBpbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoICEgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc1sgaSBdICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXSA9IGZhY2UudmVydGV4Tm9ybWFsc1sgaSBdLmNsb25lKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzWyBpIF0uY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyB1c2UgdGVtcCBnZW9tZXRyeSB0byBjb21wdXRlIGZhY2UgYW5kIHZlcnRleCBub3JtYWxzIGZvciBlYWNoIG1vcnBoXFxuXFxuXFx0XFx0XFx0dmFyIHRtcEdlbyA9IG5ldyBHZW9tZXRyeSgpO1xcblxcdFxcdFxcdHRtcEdlby5mYWNlcyA9IHRoaXMuZmFjZXM7XFxuXFxuXFx0XFx0XFx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy5tb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gY3JlYXRlIG9uIGZpcnN0IGFjY2Vzc1xcblxcblxcdFxcdFxcdFxcdGlmICggISB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMubW9ycGhOb3JtYWxzWyBpIF0gPSB7fTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLmZhY2VOb3JtYWxzID0gW107XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5tb3JwaE5vcm1hbHNbIGkgXS52ZXJ0ZXhOb3JtYWxzID0gW107XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGRzdE5vcm1hbHNGYWNlID0gdGhpcy5tb3JwaE5vcm1hbHNbIGkgXS5mYWNlTm9ybWFscztcXG5cXHRcXHRcXHRcXHRcXHR2YXIgZHN0Tm9ybWFsc1ZlcnRleCA9IHRoaXMubW9ycGhOb3JtYWxzWyBpIF0udmVydGV4Tm9ybWFscztcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgZmFjZU5vcm1hbCwgdmVydGV4Tm9ybWFscztcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGZhY2VOb3JtYWwgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZlcnRleE5vcm1hbHMgPSB7IGE6IG5ldyBWZWN0b3IzKCksIGI6IG5ldyBWZWN0b3IzKCksIGM6IG5ldyBWZWN0b3IzKCkgfTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRkc3ROb3JtYWxzRmFjZS5wdXNoKCBmYWNlTm9ybWFsICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZHN0Tm9ybWFsc1ZlcnRleC5wdXNoKCB2ZXJ0ZXhOb3JtYWxzICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR2YXIgbW9ycGhOb3JtYWxzID0gdGhpcy5tb3JwaE5vcm1hbHNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBzZXQgdmVydGljZXMgdG8gbW9ycGggdGFyZ2V0XFxuXFxuXFx0XFx0XFx0XFx0dG1wR2VvLnZlcnRpY2VzID0gdGhpcy5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcztcXG5cXG5cXHRcXHRcXHRcXHQvLyBjb21wdXRlIG1vcnBoIG5vcm1hbHNcXG5cXG5cXHRcXHRcXHRcXHR0bXBHZW8uY29tcHV0ZUZhY2VOb3JtYWxzKCk7XFxuXFx0XFx0XFx0XFx0dG1wR2VvLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gc3RvcmUgbW9ycGggbm9ybWFsc1xcblxcblxcdFxcdFxcdFxcdHZhciBmYWNlTm9ybWFsLCB2ZXJ0ZXhOb3JtYWxzO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmYWNlTm9ybWFsID0gbW9ycGhOb3JtYWxzLmZhY2VOb3JtYWxzWyBmIF07XFxuXFx0XFx0XFx0XFx0XFx0dmVydGV4Tm9ybWFscyA9IG1vcnBoTm9ybWFscy52ZXJ0ZXhOb3JtYWxzWyBmIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZmFjZU5vcm1hbC5jb3B5KCBmYWNlLm5vcm1hbCApO1xcblxcblxcdFxcdFxcdFxcdFxcdHZlcnRleE5vcm1hbHMuYS5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDAgXSApO1xcblxcdFxcdFxcdFxcdFxcdHZlcnRleE5vcm1hbHMuYi5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDEgXSApO1xcblxcdFxcdFxcdFxcdFxcdHZlcnRleE5vcm1hbHMuYy5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDIgXSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gcmVzdG9yZSBvcmlnaW5hbCBub3JtYWxzXFxuXFxuXFx0XFx0XFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xcblxcblxcdFxcdFxcdFxcdGZhY2Uubm9ybWFsID0gZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbDtcXG5cXHRcXHRcXHRcXHRmYWNlLnZlcnRleE5vcm1hbHMgPSBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvbXB1dGVMaW5lRGlzdGFuY2VzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGQgPSAwO1xcblxcdFxcdFxcdHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggaSA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZCArPSB2ZXJ0aWNlc1sgaSBdLmRpc3RhbmNlVG8oIHZlcnRpY2VzWyBpIC0gMSBdICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHRoaXMubGluZURpc3RhbmNlc1sgaSBdID0gZDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb21wdXRlQm91bmRpbmdCb3g6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5ib3VuZGluZ0JveCA9IG5ldyBCb3gzKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuYm91bmRpbmdCb3guc2V0RnJvbVBvaW50cyggdGhpcy52ZXJ0aWNlcyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29tcHV0ZUJvdW5kaW5nU3BoZXJlOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuYm91bmRpbmdTcGhlcmUuc2V0RnJvbVBvaW50cyggdGhpcy52ZXJ0aWNlcyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bWVyZ2U6IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdHJpeCwgbWF0ZXJpYWxJbmRleE9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoICEgKCBnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0dlb21ldHJ5ICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkdlb21ldHJ5Lm1lcmdlKCk6IGdlb21ldHJ5IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5HZW9tZXRyeS4nLCBnZW9tZXRyeSApO1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIG5vcm1hbE1hdHJpeCxcXG5cXHRcXHRcXHRcXHR2ZXJ0ZXhPZmZzZXQgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCxcXG5cXHRcXHRcXHRcXHR2ZXJ0aWNlczEgPSB0aGlzLnZlcnRpY2VzLFxcblxcdFxcdFxcdFxcdHZlcnRpY2VzMiA9IGdlb21ldHJ5LnZlcnRpY2VzLFxcblxcdFxcdFxcdFxcdGZhY2VzMSA9IHRoaXMuZmFjZXMsXFxuXFx0XFx0XFx0XFx0ZmFjZXMyID0gZ2VvbWV0cnkuZmFjZXMsXFxuXFx0XFx0XFx0XFx0dXZzMSA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLFxcblxcdFxcdFxcdFxcdHV2czIgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyAwIF0sXFxuXFx0XFx0XFx0XFx0Y29sb3JzMSA9IHRoaXMuY29sb3JzLFxcblxcdFxcdFxcdFxcdGNvbG9yczIgPSBnZW9tZXRyeS5jb2xvcnM7XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbEluZGV4T2Zmc2V0ID09PSB1bmRlZmluZWQgKSBtYXRlcmlhbEluZGV4T2Zmc2V0ID0gMDtcXG5cXG5cXHRcXHRcXHRpZiAoIG1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdG5vcm1hbE1hdHJpeCA9IG5ldyBNYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gdmVydGljZXNcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmVydGljZXMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlczJbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdmVydGV4Q29weSA9IHZlcnRleC5jbG9uZSgpO1xcblxcblxcdFxcdFxcdFxcdGlmICggbWF0cml4ICE9PSB1bmRlZmluZWQgKSB2ZXJ0ZXhDb3B5LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0XFx0dmVydGljZXMxLnB1c2goIHZlcnRleENvcHkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gY29sb3JzXFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGNvbG9yczIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29sb3JzMS5wdXNoKCBjb2xvcnMyWyBpIF0uY2xvbmUoKSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBmYWNlc1xcblxcblxcdFxcdFxcdGZvciAoIGkgPSAwLCBpbCA9IGZhY2VzMi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZmFjZSA9IGZhY2VzMlsgaSBdLCBmYWNlQ29weSwgbm9ybWFsLCBjb2xvcixcXG5cXHRcXHRcXHRcXHRcXHRmYWNlVmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscyxcXG5cXHRcXHRcXHRcXHRcXHRmYWNlVmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XFxuXFxuXFx0XFx0XFx0XFx0ZmFjZUNvcHkgPSBuZXcgRmFjZTMoIGZhY2UuYSArIHZlcnRleE9mZnNldCwgZmFjZS5iICsgdmVydGV4T2Zmc2V0LCBmYWNlLmMgKyB2ZXJ0ZXhPZmZzZXQgKTtcXG5cXHRcXHRcXHRcXHRmYWNlQ29weS5ub3JtYWwuY29weSggZmFjZS5ub3JtYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG5vcm1hbE1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGZhY2VDb3B5Lm5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZVZlcnRleE5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bm9ybWFsID0gZmFjZVZlcnRleE5vcm1hbHNbIGogXS5jbG9uZSgpO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggbm9ybWFsTWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGZhY2VDb3B5LnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGZhY2VDb3B5LmNvbG9yLmNvcHkoIGZhY2UuY29sb3IgKTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZVZlcnRleENvbG9ycy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb2xvciA9IGZhY2VWZXJ0ZXhDb2xvcnNbIGogXTtcXG5cXHRcXHRcXHRcXHRcXHRmYWNlQ29weS52ZXJ0ZXhDb2xvcnMucHVzaCggY29sb3IuY2xvbmUoKSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRmYWNlQ29weS5tYXRlcmlhbEluZGV4ID0gZmFjZS5tYXRlcmlhbEluZGV4ICsgbWF0ZXJpYWxJbmRleE9mZnNldDtcXG5cXG5cXHRcXHRcXHRcXHRmYWNlczEucHVzaCggZmFjZUNvcHkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gdXZzXFxuXFxuXFx0XFx0XFx0Zm9yICggaSA9IDAsIGlsID0gdXZzMi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdXYgPSB1dnMyWyBpIF0sIHV2Q29weSA9IFtdO1xcblxcblxcdFxcdFxcdFxcdGlmICggdXYgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IHV2Lmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHV2Q29weS5wdXNoKCB1dlsgaiBdLmNsb25lKCkgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dXZzMS5wdXNoKCB1dkNvcHkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRtZXJnZU1lc2g6IGZ1bmN0aW9uICggbWVzaCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoICEgKCBtZXNoICYmIG1lc2guaXNNZXNoICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkdlb21ldHJ5Lm1lcmdlTWVzaCgpOiBtZXNoIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5NZXNoLicsIG1lc2ggKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdG1lc2gubWF0cml4QXV0b1VwZGF0ZSAmJiBtZXNoLnVwZGF0ZU1hdHJpeCgpO1xcblxcblxcdFxcdFxcdHRoaXMubWVyZ2UoIG1lc2guZ2VvbWV0cnksIG1lc2gubWF0cml4ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKlxcblxcdFxcdCAqIENoZWNrcyBmb3IgZHVwbGljYXRlIHZlcnRpY2VzIHdpdGggaGFzaG1hcC5cXG5cXHRcXHQgKiBEdXBsaWNhdGVkIHZlcnRpY2VzIGFyZSByZW1vdmVkXFxuXFx0XFx0ICogYW5kIGZhY2VzJyB2ZXJ0aWNlcyBhcmUgdXBkYXRlZC5cXG5cXHRcXHQgKi9cXG5cXG5cXHRcXHRtZXJnZVZlcnRpY2VzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHZlcnRpY2VzTWFwID0ge307IC8vIEhhc2htYXAgZm9yIGxvb2tpbmcgdXAgdmVydGljZXMgYnkgcG9zaXRpb24gY29vcmRpbmF0ZXMgKGFuZCBtYWtpbmcgc3VyZSB0aGV5IGFyZSB1bmlxdWUpXFxuXFx0XFx0XFx0dmFyIHVuaXF1ZSA9IFtdLCBjaGFuZ2VzID0gW107XFxuXFxuXFx0XFx0XFx0dmFyIHYsIGtleTtcXG5cXHRcXHRcXHR2YXIgcHJlY2lzaW9uUG9pbnRzID0gNDsgLy8gbnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzLCBlLmcuIDQgZm9yIGVwc2lsb24gb2YgMC4wMDAxXFxuXFx0XFx0XFx0dmFyIHByZWNpc2lvbiA9IE1hdGgucG93KCAxMCwgcHJlY2lzaW9uUG9pbnRzICk7XFxuXFx0XFx0XFx0dmFyIGksIGlsLCBmYWNlO1xcblxcdFxcdFxcdHZhciBpbmRpY2VzLCBqLCBqbDtcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHYgPSB0aGlzLnZlcnRpY2VzWyBpIF07XFxuXFx0XFx0XFx0XFx0a2V5ID0gTWF0aC5yb3VuZCggdi54ICogcHJlY2lzaW9uICkgKyAnXycgKyBNYXRoLnJvdW5kKCB2LnkgKiBwcmVjaXNpb24gKSArICdfJyArIE1hdGgucm91bmQoIHYueiAqIHByZWNpc2lvbiApO1xcblxcblxcdFxcdFxcdFxcdGlmICggdmVydGljZXNNYXBbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmVydGljZXNNYXBbIGtleSBdID0gaTtcXG5cXHRcXHRcXHRcXHRcXHR1bmlxdWUucHVzaCggdGhpcy52ZXJ0aWNlc1sgaSBdICk7XFxuXFx0XFx0XFx0XFx0XFx0Y2hhbmdlc1sgaSBdID0gdW5pcXVlLmxlbmd0aCAtIDE7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvL2NvbnNvbGUubG9nKCdEdXBsaWNhdGUgdmVydGV4IGZvdW5kLiAnLCBpLCAnIGNvdWxkIGJlIHVzaW5nICcsIHZlcnRpY2VzTWFwW2tleV0pO1xcblxcdFxcdFxcdFxcdFxcdGNoYW5nZXNbIGkgXSA9IGNoYW5nZXNbIHZlcnRpY2VzTWFwWyBrZXkgXSBdO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFxuXFx0XFx0XFx0Ly8gaWYgZmFjZXMgYXJlIGNvbXBsZXRlbHkgZGVnZW5lcmF0ZSBhZnRlciBtZXJnaW5nIHZlcnRpY2VzLCB3ZVxcblxcdFxcdFxcdC8vIGhhdmUgdG8gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZ2VvbWV0cnkuXFxuXFx0XFx0XFx0dmFyIGZhY2VJbmRpY2VzVG9SZW1vdmUgPSBbXTtcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdGZhY2UgPSB0aGlzLmZhY2VzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0ZmFjZS5hID0gY2hhbmdlc1sgZmFjZS5hIF07XFxuXFx0XFx0XFx0XFx0ZmFjZS5iID0gY2hhbmdlc1sgZmFjZS5iIF07XFxuXFx0XFx0XFx0XFx0ZmFjZS5jID0gY2hhbmdlc1sgZmFjZS5jIF07XFxuXFxuXFx0XFx0XFx0XFx0aW5kaWNlcyA9IFsgZmFjZS5hLCBmYWNlLmIsIGZhY2UuYyBdO1xcblxcblxcdFxcdFxcdFxcdC8vIGlmIGFueSBkdXBsaWNhdGUgdmVydGljZXMgYXJlIGZvdW5kIGluIGEgRmFjZTNcXG5cXHRcXHRcXHRcXHQvLyB3ZSBoYXZlIHRvIHJlbW92ZSB0aGUgZmFjZSBhcyBub3RoaW5nIGNhbiBiZSBzYXZlZFxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBuID0gMDsgbiA8IDM7IG4gKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBpbmRpY2VzWyBuIF0gPT09IGluZGljZXNbICggbiArIDEgKSAlIDMgXSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmYWNlSW5kaWNlc1RvUmVtb3ZlLnB1c2goIGkgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gZmFjZUluZGljZXNUb1JlbW92ZS5sZW5ndGggLSAxOyBpID49IDA7IGkgLS0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGlkeCA9IGZhY2VJbmRpY2VzVG9SZW1vdmVbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmZhY2VzLnNwbGljZSggaWR4LCAxICk7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggaiA9IDAsIGpsID0gdGhpcy5mYWNlVmVydGV4VXZzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuZmFjZVZlcnRleFV2c1sgaiBdLnNwbGljZSggaWR4LCAxICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBVc2UgdW5pcXVlIHNldCBvZiB2ZXJ0aWNlc1xcblxcblxcdFxcdFxcdHZhciBkaWZmID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSB1bmlxdWUubGVuZ3RoO1xcblxcdFxcdFxcdHRoaXMudmVydGljZXMgPSB1bmlxdWU7XFxuXFx0XFx0XFx0cmV0dXJuIGRpZmY7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHBvaW50cyApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnZlcnRpY2VzID0gW107XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHBvaW50ID0gcG9pbnRzWyBpIF07XFxuXFx0XFx0XFx0XFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCBuZXcgVmVjdG9yMyggcG9pbnQueCwgcG9pbnQueSwgcG9pbnQueiB8fCAwICkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzb3J0RmFjZXNCeU1hdGVyaWFsSW5kZXg6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgZmFjZXMgPSB0aGlzLmZhY2VzO1xcblxcdFxcdFxcdHZhciBsZW5ndGggPSBmYWNlcy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0Ly8gdGFnIGZhY2VzXFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdGZhY2VzWyBpIF0uX2lkID0gaTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gc29ydCBmYWNlc1xcblxcblxcdFxcdFxcdGZ1bmN0aW9uIG1hdGVyaWFsSW5kZXhTb3J0KCBhLCBiICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBhLm1hdGVyaWFsSW5kZXggLSBiLm1hdGVyaWFsSW5kZXg7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGZhY2VzLnNvcnQoIG1hdGVyaWFsSW5kZXhTb3J0ICk7XFxuXFxuXFx0XFx0XFx0Ly8gc29ydCB1dnNcXG5cXG5cXHRcXHRcXHR2YXIgdXZzMSA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdO1xcblxcdFxcdFxcdHZhciB1dnMyID0gdGhpcy5mYWNlVmVydGV4VXZzWyAxIF07XFxuXFxuXFx0XFx0XFx0dmFyIG5ld1V2czEsIG5ld1V2czI7XFxuXFxuXFx0XFx0XFx0aWYgKCB1dnMxICYmIHV2czEubGVuZ3RoID09PSBsZW5ndGggKSBuZXdVdnMxID0gW107XFxuXFx0XFx0XFx0aWYgKCB1dnMyICYmIHV2czIubGVuZ3RoID09PSBsZW5ndGggKSBuZXdVdnMyID0gW107XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBpZCA9IGZhY2VzWyBpIF0uX2lkO1xcblxcblxcdFxcdFxcdFxcdGlmICggbmV3VXZzMSApIG5ld1V2czEucHVzaCggdXZzMVsgaWQgXSApO1xcblxcdFxcdFxcdFxcdGlmICggbmV3VXZzMiApIG5ld1V2czIucHVzaCggdXZzMlsgaWQgXSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIG5ld1V2czEgKSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXSA9IG5ld1V2czE7XFxuXFx0XFx0XFx0aWYgKCBuZXdVdnMyICkgdGhpcy5mYWNlVmVydGV4VXZzWyAxIF0gPSBuZXdVdnMyO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGRhdGEgPSB7XFxuXFx0XFx0XFx0XFx0bWV0YWRhdGE6IHtcXG5cXHRcXHRcXHRcXHRcXHR2ZXJzaW9uOiA0LjUsXFxuXFx0XFx0XFx0XFx0XFx0dHlwZTogJ0dlb21ldHJ5JyxcXG5cXHRcXHRcXHRcXHRcXHRnZW5lcmF0b3I6ICdHZW9tZXRyeS50b0pTT04nXFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0Ly8gc3RhbmRhcmQgR2VvbWV0cnkgc2VyaWFsaXphdGlvblxcblxcblxcdFxcdFxcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcXG5cXHRcXHRcXHRkYXRhLnR5cGUgPSB0aGlzLnR5cGU7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5wYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGtleSBpbiBwYXJhbWV0ZXJzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggcGFyYW1ldGVyc1sga2V5IF0gIT09IHVuZGVmaW5lZCApIGRhdGFbIGtleSBdID0gcGFyYW1ldGVyc1sga2V5IF07XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiBkYXRhO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgdmVydGljZXMgPSBbXTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdmVydGV4ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xcblxcdFxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIGZhY2VzID0gW107XFxuXFx0XFx0XFx0dmFyIG5vcm1hbHMgPSBbXTtcXG5cXHRcXHRcXHR2YXIgbm9ybWFsc0hhc2ggPSB7fTtcXG5cXHRcXHRcXHR2YXIgY29sb3JzID0gW107XFxuXFx0XFx0XFx0dmFyIGNvbG9yc0hhc2ggPSB7fTtcXG5cXHRcXHRcXHR2YXIgdXZzID0gW107XFxuXFx0XFx0XFx0dmFyIHV2c0hhc2ggPSB7fTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmZhY2VzLmxlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZmFjZSA9IHRoaXMuZmFjZXNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgaGFzTWF0ZXJpYWwgPSB0cnVlO1xcblxcdFxcdFxcdFxcdHZhciBoYXNGYWNlVXYgPSBmYWxzZTsgLy8gZGVwcmVjYXRlZFxcblxcdFxcdFxcdFxcdHZhciBoYXNGYWNlVmVydGV4VXYgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXVsgaSBdICE9PSB1bmRlZmluZWQ7XFxuXFx0XFx0XFx0XFx0dmFyIGhhc0ZhY2VOb3JtYWwgPSBmYWNlLm5vcm1hbC5sZW5ndGgoKSA+IDA7XFxuXFx0XFx0XFx0XFx0dmFyIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoID4gMDtcXG5cXHRcXHRcXHRcXHR2YXIgaGFzRmFjZUNvbG9yID0gZmFjZS5jb2xvci5yICE9PSAxIHx8IGZhY2UuY29sb3IuZyAhPT0gMSB8fCBmYWNlLmNvbG9yLmIgIT09IDE7XFxuXFx0XFx0XFx0XFx0dmFyIGhhc0ZhY2VWZXJ0ZXhDb2xvciA9IGZhY2UudmVydGV4Q29sb3JzLmxlbmd0aCA+IDA7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGZhY2VUeXBlID0gMDtcXG5cXG5cXHRcXHRcXHRcXHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDAsIDAgKTsgLy8gaXNRdWFkXFxuXFx0XFx0XFx0XFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAxLCBoYXNNYXRlcmlhbCApO1xcblxcdFxcdFxcdFxcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgMiwgaGFzRmFjZVV2ICk7XFxuXFx0XFx0XFx0XFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAzLCBoYXNGYWNlVmVydGV4VXYgKTtcXG5cXHRcXHRcXHRcXHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDQsIGhhc0ZhY2VOb3JtYWwgKTtcXG5cXHRcXHRcXHRcXHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDUsIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgKTtcXG5cXHRcXHRcXHRcXHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDYsIGhhc0ZhY2VDb2xvciApO1xcblxcdFxcdFxcdFxcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNywgaGFzRmFjZVZlcnRleENvbG9yICk7XFxuXFxuXFx0XFx0XFx0XFx0ZmFjZXMucHVzaCggZmFjZVR5cGUgKTtcXG5cXHRcXHRcXHRcXHRmYWNlcy5wdXNoKCBmYWNlLmEsIGZhY2UuYiwgZmFjZS5jICk7XFxuXFx0XFx0XFx0XFx0ZmFjZXMucHVzaCggZmFjZS5tYXRlcmlhbEluZGV4ICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBoYXNGYWNlVmVydGV4VXYgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGZhY2VWZXJ0ZXhVdnMgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXVsgaSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdGZhY2VzLnB1c2goXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2V0VXZJbmRleCggZmFjZVZlcnRleFV2c1sgMCBdICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2V0VXZJbmRleCggZmFjZVZlcnRleFV2c1sgMSBdICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2V0VXZJbmRleCggZmFjZVZlcnRleFV2c1sgMiBdIClcXG5cXHRcXHRcXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGhhc0ZhY2VOb3JtYWwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZmFjZXMucHVzaCggZ2V0Tm9ybWFsSW5kZXgoIGZhY2Uubm9ybWFsICkgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBoYXNGYWNlVmVydGV4Tm9ybWFsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciB2ZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzO1xcblxcblxcdFxcdFxcdFxcdFxcdGZhY2VzLnB1c2goXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2V0Tm9ybWFsSW5kZXgoIHZlcnRleE5vcm1hbHNbIDAgXSApLFxcblxcdFxcdFxcdFxcdFxcdFxcdGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAxIF0gKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRnZXROb3JtYWxJbmRleCggdmVydGV4Tm9ybWFsc1sgMiBdIClcXG5cXHRcXHRcXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGhhc0ZhY2VDb2xvciApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmYWNlcy5wdXNoKCBnZXRDb2xvckluZGV4KCBmYWNlLmNvbG9yICkgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBoYXNGYWNlVmVydGV4Q29sb3IgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHZlcnRleENvbG9ycyA9IGZhY2UudmVydGV4Q29sb3JzO1xcblxcblxcdFxcdFxcdFxcdFxcdGZhY2VzLnB1c2goXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2V0Q29sb3JJbmRleCggdmVydGV4Q29sb3JzWyAwIF0gKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRnZXRDb2xvckluZGV4KCB2ZXJ0ZXhDb2xvcnNbIDEgXSApLFxcblxcdFxcdFxcdFxcdFxcdFxcdGdldENvbG9ySW5kZXgoIHZlcnRleENvbG9yc1sgMiBdIClcXG5cXHRcXHRcXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gc2V0Qml0KCB2YWx1ZSwgcG9zaXRpb24sIGVuYWJsZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGVuYWJsZWQgPyB2YWx1ZSB8ICggMSA8PCBwb3NpdGlvbiApIDogdmFsdWUgJiAoIH4gKCAxIDw8IHBvc2l0aW9uICkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gZ2V0Tm9ybWFsSW5kZXgoIG5vcm1hbCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgaGFzaCA9IG5vcm1hbC54LnRvU3RyaW5nKCkgKyBub3JtYWwueS50b1N0cmluZygpICsgbm9ybWFsLnoudG9TdHJpbmcoKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG5vcm1hbHNIYXNoWyBoYXNoIF0gIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gbm9ybWFsc0hhc2hbIGhhc2ggXTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0bm9ybWFsc0hhc2hbIGhhc2ggXSA9IG5vcm1hbHMubGVuZ3RoIC8gMztcXG5cXHRcXHRcXHRcXHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gbm9ybWFsc0hhc2hbIGhhc2ggXTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gZ2V0Q29sb3JJbmRleCggY29sb3IgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGhhc2ggPSBjb2xvci5yLnRvU3RyaW5nKCkgKyBjb2xvci5nLnRvU3RyaW5nKCkgKyBjb2xvci5iLnRvU3RyaW5nKCk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBjb2xvcnNIYXNoWyBoYXNoIF0gIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gY29sb3JzSGFzaFsgaGFzaCBdO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRjb2xvcnNIYXNoWyBoYXNoIF0gPSBjb2xvcnMubGVuZ3RoO1xcblxcdFxcdFxcdFxcdGNvbG9ycy5wdXNoKCBjb2xvci5nZXRIZXgoKSApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBjb2xvcnNIYXNoWyBoYXNoIF07XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGZ1bmN0aW9uIGdldFV2SW5kZXgoIHV2ICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBoYXNoID0gdXYueC50b1N0cmluZygpICsgdXYueS50b1N0cmluZygpO1xcblxcblxcdFxcdFxcdFxcdGlmICggdXZzSGFzaFsgaGFzaCBdICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHV2c0hhc2hbIGhhc2ggXTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dXZzSGFzaFsgaGFzaCBdID0gdXZzLmxlbmd0aCAvIDI7XFxuXFx0XFx0XFx0XFx0dXZzLnB1c2goIHV2LngsIHV2LnkgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdXZzSGFzaFsgaGFzaCBdO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRkYXRhLmRhdGEgPSB7fTtcXG5cXG5cXHRcXHRcXHRkYXRhLmRhdGEudmVydGljZXMgPSB2ZXJ0aWNlcztcXG5cXHRcXHRcXHRkYXRhLmRhdGEubm9ybWFscyA9IG5vcm1hbHM7XFxuXFx0XFx0XFx0aWYgKCBjb2xvcnMubGVuZ3RoID4gMCApIGRhdGEuZGF0YS5jb2xvcnMgPSBjb2xvcnM7XFxuXFx0XFx0XFx0aWYgKCB1dnMubGVuZ3RoID4gMCApIGRhdGEuZGF0YS51dnMgPSBbIHV2cyBdOyAvLyB0ZW1wb3JhbCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XFxuXFx0XFx0XFx0ZGF0YS5kYXRhLmZhY2VzID0gZmFjZXM7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGRhdGE7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdC8qXFxuXFx0XFx0XFx0IC8vIEhhbmRsZSBwcmltaXRpdmVzXFxuXFxuXFx0XFx0XFx0IHZhciBwYXJhbWV0ZXJzID0gdGhpcy5wYXJhbWV0ZXJzO1xcblxcblxcdFxcdFxcdCBpZiAoIHBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHQgdmFyIHZhbHVlcyA9IFtdO1xcblxcblxcdFxcdFxcdCBmb3IgKCB2YXIga2V5IGluIHBhcmFtZXRlcnMgKSB7XFxuXFxuXFx0XFx0XFx0IHZhbHVlcy5wdXNoKCBwYXJhbWV0ZXJzWyBrZXkgXSApO1xcblxcblxcdFxcdFxcdCB9XFxuXFxuXFx0XFx0XFx0IHZhciBnZW9tZXRyeSA9IE9iamVjdC5jcmVhdGUoIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlICk7XFxuXFx0XFx0XFx0IHRoaXMuY29uc3RydWN0b3IuYXBwbHkoIGdlb21ldHJ5LCB2YWx1ZXMgKTtcXG5cXHRcXHRcXHQgcmV0dXJuIGdlb21ldHJ5O1xcblxcblxcdFxcdFxcdCB9XFxuXFxuXFx0XFx0XFx0IHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcXG5cXHRcXHRcXHQgKi9cXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IEdlb21ldHJ5KCkuY29weSggdGhpcyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGksIGlsLCBqLCBqbCwgaywga2w7XFxuXFxuXFx0XFx0XFx0Ly8gcmVzZXRcXG5cXG5cXHRcXHRcXHR0aGlzLnZlcnRpY2VzID0gW107XFxuXFx0XFx0XFx0dGhpcy5jb2xvcnMgPSBbXTtcXG5cXHRcXHRcXHR0aGlzLmZhY2VzID0gW107XFxuXFx0XFx0XFx0dGhpcy5mYWNlVmVydGV4VXZzID0gW1tdXTtcXG5cXHRcXHRcXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IFtdO1xcblxcdFxcdFxcdHRoaXMubW9ycGhOb3JtYWxzID0gW107XFxuXFx0XFx0XFx0dGhpcy5za2luV2VpZ2h0cyA9IFtdO1xcblxcdFxcdFxcdHRoaXMuc2tpbkluZGljZXMgPSBbXTtcXG5cXHRcXHRcXHR0aGlzLmxpbmVEaXN0YW5jZXMgPSBbXTtcXG5cXHRcXHRcXHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcXG5cXHRcXHRcXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcXG5cXG5cXHRcXHRcXHQvLyBuYW1lXFxuXFxuXFx0XFx0XFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7XFxuXFxuXFx0XFx0XFx0Ly8gdmVydGljZXNcXG5cXG5cXHRcXHRcXHR2YXIgdmVydGljZXMgPSBzb3VyY2UudmVydGljZXM7XFxuXFxuXFx0XFx0XFx0Zm9yICggaSA9IDAsIGlsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1sgaSBdLmNsb25lKCkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gY29sb3JzXFxuXFxuXFx0XFx0XFx0dmFyIGNvbG9ycyA9IHNvdXJjZS5jb2xvcnM7XFxuXFxuXFx0XFx0XFx0Zm9yICggaSA9IDAsIGlsID0gY29sb3JzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuY29sb3JzLnB1c2goIGNvbG9yc1sgaSBdLmNsb25lKCkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gZmFjZXNcXG5cXG5cXHRcXHRcXHR2YXIgZmFjZXMgPSBzb3VyY2UuZmFjZXM7XFxuXFxuXFx0XFx0XFx0Zm9yICggaSA9IDAsIGlsID0gZmFjZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5mYWNlcy5wdXNoKCBmYWNlc1sgaSBdLmNsb25lKCkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gZmFjZSB2ZXJ0ZXggdXZzXFxuXFxuXFx0XFx0XFx0Zm9yICggaSA9IDAsIGlsID0gc291cmNlLmZhY2VWZXJ0ZXhVdnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGZhY2VWZXJ0ZXhVdnMgPSBzb3VyY2UuZmFjZVZlcnRleFV2c1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdGlmICggdGhpcy5mYWNlVmVydGV4VXZzWyBpIF0gPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIGkgXSA9IFtdO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCBqID0gMCwgamwgPSBmYWNlVmVydGV4VXZzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciB1dnMgPSBmYWNlVmVydGV4VXZzWyBqIF0sIHV2c0NvcHkgPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCBrID0gMCwga2wgPSB1dnMubGVuZ3RoOyBrIDwga2w7IGsgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHV2ID0gdXZzWyBrIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dXZzQ29weS5wdXNoKCB1di5jbG9uZSgpICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuZmFjZVZlcnRleFV2c1sgaSBdLnB1c2goIHV2c0NvcHkgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIG1vcnBoIHRhcmdldHNcXG5cXG5cXHRcXHRcXHR2YXIgbW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gMCwgaWwgPSBtb3JwaFRhcmdldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG1vcnBoVGFyZ2V0ID0ge307XFxuXFx0XFx0XFx0XFx0bW9ycGhUYXJnZXQubmFtZSA9IG1vcnBoVGFyZ2V0c1sgaSBdLm5hbWU7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdmVydGljZXNcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bW9ycGhUYXJnZXQudmVydGljZXMgPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCBqID0gMCwgamwgPSBtb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRtb3JwaFRhcmdldC52ZXJ0aWNlcy5wdXNoKCBtb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlc1sgaiBdLmNsb25lKCkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIG5vcm1hbHNcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG1vcnBoVGFyZ2V0c1sgaSBdLm5vcm1hbHMgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRtb3JwaFRhcmdldC5ub3JtYWxzID0gW107XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggaiA9IDAsIGpsID0gbW9ycGhUYXJnZXRzWyBpIF0ubm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRtb3JwaFRhcmdldC5ub3JtYWxzLnB1c2goIG1vcnBoVGFyZ2V0c1sgaSBdLm5vcm1hbHNbIGogXS5jbG9uZSgpICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0aGlzLm1vcnBoVGFyZ2V0cy5wdXNoKCBtb3JwaFRhcmdldCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBtb3JwaCBub3JtYWxzXFxuXFxuXFx0XFx0XFx0dmFyIG1vcnBoTm9ybWFscyA9IHNvdXJjZS5tb3JwaE5vcm1hbHM7XFxuXFxuXFx0XFx0XFx0Zm9yICggaSA9IDAsIGlsID0gbW9ycGhOb3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBtb3JwaE5vcm1hbCA9IHt9O1xcblxcblxcdFxcdFxcdFxcdC8vIHZlcnRleCBub3JtYWxzXFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBtb3JwaE5vcm1hbHNbIGkgXS52ZXJ0ZXhOb3JtYWxzICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bW9ycGhOb3JtYWwudmVydGV4Tm9ybWFscyA9IFtdO1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIGogPSAwLCBqbCA9IG1vcnBoTm9ybWFsc1sgaSBdLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHNyY1ZlcnRleE5vcm1hbCA9IG1vcnBoTm9ybWFsc1sgaSBdLnZlcnRleE5vcm1hbHNbIGogXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgZGVzdFZlcnRleE5vcm1hbCA9IHt9O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGRlc3RWZXJ0ZXhOb3JtYWwuYSA9IHNyY1ZlcnRleE5vcm1hbC5hLmNsb25lKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGVzdFZlcnRleE5vcm1hbC5iID0gc3JjVmVydGV4Tm9ybWFsLmIuY2xvbmUoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkZXN0VmVydGV4Tm9ybWFsLmMgPSBzcmNWZXJ0ZXhOb3JtYWwuYy5jbG9uZSgpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdG1vcnBoTm9ybWFsLnZlcnRleE5vcm1hbHMucHVzaCggZGVzdFZlcnRleE5vcm1hbCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gZmFjZSBub3JtYWxzXFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBtb3JwaE5vcm1hbHNbIGkgXS5mYWNlTm9ybWFscyAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdG1vcnBoTm9ybWFsLmZhY2VOb3JtYWxzID0gW107XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggaiA9IDAsIGpsID0gbW9ycGhOb3JtYWxzWyBpIF0uZmFjZU5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0bW9ycGhOb3JtYWwuZmFjZU5vcm1hbHMucHVzaCggbW9ycGhOb3JtYWxzWyBpIF0uZmFjZU5vcm1hbHNbIGogXS5jbG9uZSgpICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0aGlzLm1vcnBoTm9ybWFscy5wdXNoKCBtb3JwaE5vcm1hbCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBza2luIHdlaWdodHNcXG5cXG5cXHRcXHRcXHR2YXIgc2tpbldlaWdodHMgPSBzb3VyY2Uuc2tpbldlaWdodHM7XFxuXFxuXFx0XFx0XFx0Zm9yICggaSA9IDAsIGlsID0gc2tpbldlaWdodHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5za2luV2VpZ2h0cy5wdXNoKCBza2luV2VpZ2h0c1sgaSBdLmNsb25lKCkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gc2tpbiBpbmRpY2VzXFxuXFxuXFx0XFx0XFx0dmFyIHNraW5JbmRpY2VzID0gc291cmNlLnNraW5JbmRpY2VzO1xcblxcblxcdFxcdFxcdGZvciAoIGkgPSAwLCBpbCA9IHNraW5JbmRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuc2tpbkluZGljZXMucHVzaCggc2tpbkluZGljZXNbIGkgXS5jbG9uZSgpICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGxpbmUgZGlzdGFuY2VzXFxuXFxuXFx0XFx0XFx0dmFyIGxpbmVEaXN0YW5jZXMgPSBzb3VyY2UubGluZURpc3RhbmNlcztcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gMCwgaWwgPSBsaW5lRGlzdGFuY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMubGluZURpc3RhbmNlcy5wdXNoKCBsaW5lRGlzdGFuY2VzWyBpIF0gKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gYm91bmRpbmcgYm94XFxuXFxuXFx0XFx0XFx0dmFyIGJvdW5kaW5nQm94ID0gc291cmNlLmJvdW5kaW5nQm94O1xcblxcblxcdFxcdFxcdGlmICggYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5ib3VuZGluZ0JveCA9IGJvdW5kaW5nQm94LmNsb25lKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGJvdW5kaW5nIHNwaGVyZVxcblxcblxcdFxcdFxcdHZhciBib3VuZGluZ1NwaGVyZSA9IHNvdXJjZS5ib3VuZGluZ1NwaGVyZTtcXG5cXG5cXHRcXHRcXHRpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyB1cGRhdGUgZmxhZ3NcXG5cXG5cXHRcXHRcXHR0aGlzLmVsZW1lbnRzTmVlZFVwZGF0ZSA9IHNvdXJjZS5lbGVtZW50c05lZWRVcGRhdGU7XFxuXFx0XFx0XFx0dGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBzb3VyY2UudmVydGljZXNOZWVkVXBkYXRlO1xcblxcdFxcdFxcdHRoaXMudXZzTmVlZFVwZGF0ZSA9IHNvdXJjZS51dnNOZWVkVXBkYXRlO1xcblxcdFxcdFxcdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSBzb3VyY2Uubm9ybWFsc05lZWRVcGRhdGU7XFxuXFx0XFx0XFx0dGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gc291cmNlLmNvbG9yc05lZWRVcGRhdGU7XFxuXFx0XFx0XFx0dGhpcy5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZSA9IHNvdXJjZS5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZTtcXG5cXHRcXHRcXHR0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSBzb3VyY2UuZ3JvdXBzTmVlZFVwZGF0ZTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XFxuXFxuXFx0XFx0aWYgKCBBcnJheS5pc0FycmF5KCBhcnJheSApICkge1xcblxcblxcdFxcdFxcdHRocm93IG5ldyBUeXBlRXJyb3IoICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IGFycmF5IHNob3VsZCBiZSBhIFR5cGVkIEFycmF5LicgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7XFxuXFx0XFx0dGhpcy5uYW1lID0gJyc7XFxuXFxuXFx0XFx0dGhpcy5hcnJheSA9IGFycmF5O1xcblxcdFxcdHRoaXMuaXRlbVNpemUgPSBpdGVtU2l6ZTtcXG5cXHRcXHR0aGlzLmNvdW50ID0gYXJyYXkgIT09IHVuZGVmaW5lZCA/IGFycmF5Lmxlbmd0aCAvIGl0ZW1TaXplIDogMDtcXG5cXHRcXHR0aGlzLm5vcm1hbGl6ZWQgPSBub3JtYWxpemVkID09PSB0cnVlO1xcblxcblxcdFxcdHRoaXMuZHluYW1pYyA9IGZhbHNlO1xcblxcdFxcdHRoaXMudXBkYXRlUmFuZ2UgPSB7IG9mZnNldDogMCwgY291bnQ6IC0gMSB9O1xcblxcblxcdFxcdHRoaXMub25VcGxvYWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHt9O1xcblxcblxcdFxcdHRoaXMudmVyc2lvbiA9IDA7XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSwgJ25lZWRzVXBkYXRlJywge1xcblxcblxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy52ZXJzaW9uICsrO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSwge1xcblxcblxcdFxcdGlzQnVmZmVyQXR0cmlidXRlOiB0cnVlLFxcblxcblxcdFxcdHNldEFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xcblxcblxcdFxcdFxcdGlmICggQXJyYXkuaXNBcnJheSggYXJyYXkgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlOiBhcnJheSBzaG91bGQgYmUgYSBUeXBlZCBBcnJheS4nICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuY291bnQgPSBhcnJheSAhPT0gdW5kZWZpbmVkID8gYXJyYXkubGVuZ3RoIC8gdGhpcy5pdGVtU2l6ZSA6IDA7XFxuXFx0XFx0XFx0dGhpcy5hcnJheSA9IGFycmF5O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0RHluYW1pYzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmR5bmFtaWMgPSB2YWx1ZTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdFxcdHRoaXMuYXJyYXkgPSBuZXcgc291cmNlLmFycmF5LmNvbnN0cnVjdG9yKCBzb3VyY2UuYXJyYXkgKTtcXG5cXHRcXHRcXHR0aGlzLml0ZW1TaXplID0gc291cmNlLml0ZW1TaXplO1xcblxcdFxcdFxcdHRoaXMuY291bnQgPSBzb3VyY2UuY291bnQ7XFxuXFx0XFx0XFx0dGhpcy5ub3JtYWxpemVkID0gc291cmNlLm5vcm1hbGl6ZWQ7XFxuXFxuXFx0XFx0XFx0dGhpcy5keW5hbWljID0gc291cmNlLmR5bmFtaWM7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb3B5QXQ6IGZ1bmN0aW9uICggaW5kZXgxLCBhdHRyaWJ1dGUsIGluZGV4MiApIHtcXG5cXG5cXHRcXHRcXHRpbmRleDEgKj0gdGhpcy5pdGVtU2l6ZTtcXG5cXHRcXHRcXHRpbmRleDIgKj0gYXR0cmlidXRlLml0ZW1TaXplO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuaXRlbVNpemU7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuYXJyYXlbIGluZGV4MSArIGkgXSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXgyICsgaSBdO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHlBcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmFycmF5LnNldCggYXJyYXkgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHlDb2xvcnNBcnJheTogZnVuY3Rpb24gKCBjb2xvcnMgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjb2xvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgY29sb3IgPSBjb2xvcnNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlDb2xvcnNBcnJheSgpOiBjb2xvciBpcyB1bmRlZmluZWQnLCBpICk7XFxuXFx0XFx0XFx0XFx0XFx0Y29sb3IgPSBuZXcgQ29sb3IoKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0YXJyYXlbIG9mZnNldCArKyBdID0gY29sb3IucjtcXG5cXHRcXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBjb2xvci5nO1xcblxcdFxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKysgXSA9IGNvbG9yLmI7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29weUluZGljZXNBcnJheTogZnVuY3Rpb24gKCBpbmRpY2VzICkge1xcblxcblxcdFxcdFxcdHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBpbmRleCA9IGluZGljZXNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBpbmRleC5hO1xcblxcdFxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKysgXSA9IGluZGV4LmI7XFxuXFx0XFx0XFx0XFx0YXJyYXlbIG9mZnNldCArKyBdID0gaW5kZXguYztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb3B5VmVjdG9yMnNBcnJheTogZnVuY3Rpb24gKCB2ZWN0b3JzICkge1xcblxcblxcdFxcdFxcdHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdmVjdG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB2ZWN0b3IgPSB2ZWN0b3JzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weVZlY3RvcjJzQXJyYXkoKTogdmVjdG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcXG5cXHRcXHRcXHRcXHRcXHR2ZWN0b3IgPSBuZXcgVmVjdG9yMigpO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueDtcXG5cXHRcXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb3B5VmVjdG9yM3NBcnJheTogZnVuY3Rpb24gKCB2ZWN0b3JzICkge1xcblxcblxcdFxcdFxcdHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdmVjdG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB2ZWN0b3IgPSB2ZWN0b3JzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoKTogdmVjdG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcXG5cXHRcXHRcXHRcXHRcXHR2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueDtcXG5cXHRcXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueTtcXG5cXHRcXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IuejtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb3B5VmVjdG9yNHNBcnJheTogZnVuY3Rpb24gKCB2ZWN0b3JzICkge1xcblxcblxcdFxcdFxcdHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdmVjdG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB2ZWN0b3IgPSB2ZWN0b3JzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weVZlY3RvcjRzQXJyYXkoKTogdmVjdG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcXG5cXHRcXHRcXHRcXHRcXHR2ZWN0b3IgPSBuZXcgVmVjdG9yNCgpO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueDtcXG5cXHRcXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueTtcXG5cXHRcXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IuejtcXG5cXHRcXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IudztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUsIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcXG5cXG5cXHRcXHRcXHR0aGlzLmFycmF5LnNldCggdmFsdWUsIG9mZnNldCApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0WDogZnVuY3Rpb24gKCBpbmRleCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplIF07XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRYOiBmdW5jdGlvbiAoIGluZGV4LCB4ICkge1xcblxcblxcdFxcdFxcdHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSBdID0geDtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldFk6IGZ1bmN0aW9uICggaW5kZXggKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFk6IGZ1bmN0aW9uICggaW5kZXgsIHkgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMSBdID0geTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldFo6IGZ1bmN0aW9uICggaW5kZXggKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDIgXTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFo6IGZ1bmN0aW9uICggaW5kZXgsIHogKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdID0gejtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldFc6IGZ1bmN0aW9uICggaW5kZXggKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDMgXTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFc6IGZ1bmN0aW9uICggaW5kZXgsIHcgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMyBdID0gdztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFhZOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5ICkge1xcblxcblxcdFxcdFxcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XFxuXFxuXFx0XFx0XFx0dGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xcblxcdFxcdFxcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFhZWjogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiApIHtcXG5cXG5cXHRcXHRcXHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xcblxcblxcdFxcdFxcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcXG5cXHRcXHRcXHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XFxuXFx0XFx0XFx0dGhpcy5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0WFlaVzogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiwgdyApIHtcXG5cXG5cXHRcXHRcXHRpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xcblxcblxcdFxcdFxcdHRoaXMuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcXG5cXHRcXHRcXHR0aGlzLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XFxuXFx0XFx0XFx0dGhpcy5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xcblxcdFxcdFxcdHRoaXMuYXJyYXlbIGluZGV4ICsgMyBdID0gdztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG9uVXBsb2FkOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xcblxcblxcdFxcdFxcdHRoaXMub25VcGxvYWRDYWxsYmFjayA9IGNhbGxiYWNrO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuYXJyYXksIHRoaXMuaXRlbVNpemUgKS5jb3B5KCB0aGlzICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvL1xcblxcblxcdGZ1bmN0aW9uIEludDhCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcXG5cXG5cXHRcXHRCdWZmZXJBdHRyaWJ1dGUuY2FsbCggdGhpcywgbmV3IEludDhBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcXG5cXG5cXHR9XFxuXFxuXFx0SW50OEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XFxuXFx0SW50OEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbnQ4QnVmZmVyQXR0cmlidXRlO1xcblxcblxcblxcdGZ1bmN0aW9uIFVpbnQ4QnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XFxuXFxuXFx0XFx0QnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIG5ldyBVaW50OEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xcblxcblxcdH1cXG5cXG5cXHRVaW50OEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XFxuXFx0VWludDhCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVWludDhCdWZmZXJBdHRyaWJ1dGU7XFxuXFxuXFxuXFx0ZnVuY3Rpb24gVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XFxuXFxuXFx0XFx0QnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIG5ldyBVaW50OENsYW1wZWRBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcXG5cXG5cXHR9XFxuXFxuXFx0VWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcXG5cXHRVaW50OENsYW1wZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlO1xcblxcblxcblxcdGZ1bmN0aW9uIEludDE2QnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XFxuXFxuXFx0XFx0QnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIG5ldyBJbnQxNkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xcblxcblxcdH1cXG5cXG5cXHRJbnQxNkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XFxuXFx0SW50MTZCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW50MTZCdWZmZXJBdHRyaWJ1dGU7XFxuXFxuXFxuXFx0ZnVuY3Rpb24gVWludDE2QnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XFxuXFxuXFx0XFx0QnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIG5ldyBVaW50MTZBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcXG5cXG5cXHR9XFxuXFxuXFx0VWludDE2QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcXG5cXHRVaW50MTZCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVWludDE2QnVmZmVyQXR0cmlidXRlO1xcblxcblxcblxcdGZ1bmN0aW9uIEludDMyQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XFxuXFxuXFx0XFx0QnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIG5ldyBJbnQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xcblxcblxcdH1cXG5cXG5cXHRJbnQzMkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XFxuXFx0SW50MzJCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW50MzJCdWZmZXJBdHRyaWJ1dGU7XFxuXFxuXFxuXFx0ZnVuY3Rpb24gVWludDMyQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKSB7XFxuXFxuXFx0XFx0QnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIG5ldyBVaW50MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcXG5cXG5cXHR9XFxuXFxuXFx0VWludDMyQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcXG5cXHRVaW50MzJCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVWludDMyQnVmZmVyQXR0cmlidXRlO1xcblxcblxcblxcdGZ1bmN0aW9uIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcXG5cXG5cXHRcXHRCdWZmZXJBdHRyaWJ1dGUuY2FsbCggdGhpcywgbmV3IEZsb2F0MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcXG5cXG5cXHR9XFxuXFxuXFx0RmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XFxuXFx0RmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGbG9hdDMyQnVmZmVyQXR0cmlidXRlO1xcblxcblxcblxcdGZ1bmN0aW9uIEZsb2F0NjRCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcXG5cXG5cXHRcXHRCdWZmZXJBdHRyaWJ1dGUuY2FsbCggdGhpcywgbmV3IEZsb2F0NjRBcnJheSggYXJyYXkgKSwgaXRlbVNpemUsIG5vcm1hbGl6ZWQgKTtcXG5cXG5cXHR9XFxuXFxuXFx0RmxvYXQ2NEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlICk7XFxuXFx0RmxvYXQ2NEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGbG9hdDY0QnVmZmVyQXR0cmlidXRlO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gRGlyZWN0R2VvbWV0cnkoKSB7XFxuXFxuXFx0XFx0dGhpcy5pbmRpY2VzID0gW107XFxuXFx0XFx0dGhpcy52ZXJ0aWNlcyA9IFtdO1xcblxcdFxcdHRoaXMubm9ybWFscyA9IFtdO1xcblxcdFxcdHRoaXMuY29sb3JzID0gW107XFxuXFx0XFx0dGhpcy51dnMgPSBbXTtcXG5cXHRcXHR0aGlzLnV2czIgPSBbXTtcXG5cXG5cXHRcXHR0aGlzLmdyb3VwcyA9IFtdO1xcblxcblxcdFxcdHRoaXMubW9ycGhUYXJnZXRzID0ge307XFxuXFxuXFx0XFx0dGhpcy5za2luV2VpZ2h0cyA9IFtdO1xcblxcdFxcdHRoaXMuc2tpbkluZGljZXMgPSBbXTtcXG5cXG5cXHRcXHQvLyB0aGlzLmxpbmVEaXN0YW5jZXMgPSBbXTtcXG5cXG5cXHRcXHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcXG5cXHRcXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcXG5cXG5cXHRcXHQvLyB1cGRhdGUgZmxhZ3NcXG5cXG5cXHRcXHR0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xcblxcdFxcdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggRGlyZWN0R2VvbWV0cnkucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0Y29tcHV0ZUdyb3VwczogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgZ3JvdXA7XFxuXFx0XFx0XFx0dmFyIGdyb3VwcyA9IFtdO1xcblxcdFxcdFxcdHZhciBtYXRlcmlhbEluZGV4ID0gdW5kZWZpbmVkO1xcblxcblxcdFxcdFxcdHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IGZhY2VzLmxlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0Ly8gbWF0ZXJpYWxzXFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBmYWNlLm1hdGVyaWFsSW5kZXggIT09IG1hdGVyaWFsSW5kZXggKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWxJbmRleCA9IGZhY2UubWF0ZXJpYWxJbmRleDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGdyb3VwICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z3JvdXAuY291bnQgPSAoIGkgKiAzICkgLSBncm91cC5zdGFydDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRncm91cHMucHVzaCggZ3JvdXAgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Z3JvdXAgPSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c3RhcnQ6IGkgKiAzLFxcblxcdFxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsSW5kZXg6IG1hdGVyaWFsSW5kZXhcXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBncm91cCAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGdyb3VwLmNvdW50ID0gKCBpICogMyApIC0gZ3JvdXAuc3RhcnQ7XFxuXFx0XFx0XFx0XFx0Z3JvdXBzLnB1c2goIGdyb3VwICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuZ3JvdXBzID0gZ3JvdXBzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZnJvbUdlb21ldHJ5OiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xcblxcblxcdFxcdFxcdHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xcblxcdFxcdFxcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xcblxcdFxcdFxcdHZhciBmYWNlVmVydGV4VXZzID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2cztcXG5cXG5cXHRcXHRcXHR2YXIgaGFzRmFjZVZlcnRleFV2ID0gZmFjZVZlcnRleFV2c1sgMCBdICYmIGZhY2VWZXJ0ZXhVdnNbIDAgXS5sZW5ndGggPiAwO1xcblxcdFxcdFxcdHZhciBoYXNGYWNlVmVydGV4VXYyID0gZmFjZVZlcnRleFV2c1sgMSBdICYmIGZhY2VWZXJ0ZXhVdnNbIDEgXS5sZW5ndGggPiAwO1xcblxcblxcdFxcdFxcdC8vIG1vcnBoc1xcblxcblxcdFxcdFxcdHZhciBtb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHM7XFxuXFx0XFx0XFx0dmFyIG1vcnBoVGFyZ2V0c0xlbmd0aCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0dmFyIG1vcnBoVGFyZ2V0c1Bvc2l0aW9uO1xcblxcblxcdFxcdFxcdGlmICggbW9ycGhUYXJnZXRzTGVuZ3RoID4gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRtb3JwaFRhcmdldHNQb3NpdGlvbiA9IFtdO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IG1vcnBoVGFyZ2V0c0xlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRtb3JwaFRhcmdldHNQb3NpdGlvblsgaSBdID0gW107XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHRoaXMubW9ycGhUYXJnZXRzLnBvc2l0aW9uID0gbW9ycGhUYXJnZXRzUG9zaXRpb247XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBtb3JwaE5vcm1hbHMgPSBnZW9tZXRyeS5tb3JwaE5vcm1hbHM7XFxuXFx0XFx0XFx0dmFyIG1vcnBoTm9ybWFsc0xlbmd0aCA9IG1vcnBoTm9ybWFscy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0dmFyIG1vcnBoVGFyZ2V0c05vcm1hbDtcXG5cXG5cXHRcXHRcXHRpZiAoIG1vcnBoTm9ybWFsc0xlbmd0aCA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0bW9ycGhUYXJnZXRzTm9ybWFsID0gW107XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbW9ycGhOb3JtYWxzTGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdG1vcnBoVGFyZ2V0c05vcm1hbFsgaSBdID0gW107XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHRoaXMubW9ycGhUYXJnZXRzLm5vcm1hbCA9IG1vcnBoVGFyZ2V0c05vcm1hbDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gc2tpbnNcXG5cXG5cXHRcXHRcXHR2YXIgc2tpbkluZGljZXMgPSBnZW9tZXRyeS5za2luSW5kaWNlcztcXG5cXHRcXHRcXHR2YXIgc2tpbldlaWdodHMgPSBnZW9tZXRyeS5za2luV2VpZ2h0cztcXG5cXG5cXHRcXHRcXHR2YXIgaGFzU2tpbkluZGljZXMgPSBza2luSW5kaWNlcy5sZW5ndGggPT09IHZlcnRpY2VzLmxlbmd0aDtcXG5cXHRcXHRcXHR2YXIgaGFzU2tpbldlaWdodHMgPSBza2luV2VpZ2h0cy5sZW5ndGggPT09IHZlcnRpY2VzLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHQvL1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IGZhY2VzLmxlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1sgZmFjZS5hIF0sIHZlcnRpY2VzWyBmYWNlLmIgXSwgdmVydGljZXNbIGZhY2UuYyBdICk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB2ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA9PT0gMyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLm5vcm1hbHMucHVzaCggdmVydGV4Tm9ybWFsc1sgMCBdLCB2ZXJ0ZXhOb3JtYWxzWyAxIF0sIHZlcnRleE5vcm1hbHNbIDIgXSApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIG5vcm1hbCA9IGZhY2Uubm9ybWFsO1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMubm9ybWFscy5wdXNoKCBub3JtYWwsIG5vcm1hbCwgbm9ybWFsICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHZhciB2ZXJ0ZXhDb2xvcnMgPSBmYWNlLnZlcnRleENvbG9ycztcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHZlcnRleENvbG9ycy5sZW5ndGggPT09IDMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5jb2xvcnMucHVzaCggdmVydGV4Q29sb3JzWyAwIF0sIHZlcnRleENvbG9yc1sgMSBdLCB2ZXJ0ZXhDb2xvcnNbIDIgXSApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGNvbG9yID0gZmFjZS5jb2xvcjtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmNvbG9ycy5wdXNoKCBjb2xvciwgY29sb3IsIGNvbG9yICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggaGFzRmFjZVZlcnRleFV2ID09PSB0cnVlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciB2ZXJ0ZXhVdnMgPSBmYWNlVmVydGV4VXZzWyAwIF1bIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHZlcnRleFV2cyAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMudXZzLnB1c2goIHZlcnRleFV2c1sgMCBdLCB2ZXJ0ZXhVdnNbIDEgXSwgdmVydGV4VXZzWyAyIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkRpcmVjdEdlb21ldHJ5LmZyb21HZW9tZXRyeSgpOiBVbmRlZmluZWQgdmVydGV4VXYgJywgaSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMudXZzLnB1c2goIG5ldyBWZWN0b3IyKCksIG5ldyBWZWN0b3IyKCksIG5ldyBWZWN0b3IyKCkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggaGFzRmFjZVZlcnRleFV2MiA9PT0gdHJ1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgdmVydGV4VXZzID0gZmFjZVZlcnRleFV2c1sgMSBdWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB2ZXJ0ZXhVdnMgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnV2czIucHVzaCggdmVydGV4VXZzWyAwIF0sIHZlcnRleFV2c1sgMSBdLCB2ZXJ0ZXhVdnNbIDIgXSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRGlyZWN0R2VvbWV0cnkuZnJvbUdlb21ldHJ5KCk6IFVuZGVmaW5lZCB2ZXJ0ZXhVdjIgJywgaSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMudXZzMi5wdXNoKCBuZXcgVmVjdG9yMigpLCBuZXcgVmVjdG9yMigpLCBuZXcgVmVjdG9yMigpICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBtb3JwaHNcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaiA9IDA7IGogPCBtb3JwaFRhcmdldHNMZW5ndGg7IGogKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIG1vcnBoVGFyZ2V0ID0gbW9ycGhUYXJnZXRzWyBqIF0udmVydGljZXM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bW9ycGhUYXJnZXRzUG9zaXRpb25bIGogXS5wdXNoKCBtb3JwaFRhcmdldFsgZmFjZS5hIF0sIG1vcnBoVGFyZ2V0WyBmYWNlLmIgXSwgbW9ycGhUYXJnZXRbIGZhY2UuYyBdICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBqID0gMDsgaiA8IG1vcnBoTm9ybWFsc0xlbmd0aDsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgbW9ycGhOb3JtYWwgPSBtb3JwaE5vcm1hbHNbIGogXS52ZXJ0ZXhOb3JtYWxzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0bW9ycGhUYXJnZXRzTm9ybWFsWyBqIF0ucHVzaCggbW9ycGhOb3JtYWwuYSwgbW9ycGhOb3JtYWwuYiwgbW9ycGhOb3JtYWwuYyApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBza2luc1xcblxcblxcdFxcdFxcdFxcdGlmICggaGFzU2tpbkluZGljZXMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5za2luSW5kaWNlcy5wdXNoKCBza2luSW5kaWNlc1sgZmFjZS5hIF0sIHNraW5JbmRpY2VzWyBmYWNlLmIgXSwgc2tpbkluZGljZXNbIGZhY2UuYyBdICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggaGFzU2tpbldlaWdodHMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5za2luV2VpZ2h0cy5wdXNoKCBza2luV2VpZ2h0c1sgZmFjZS5hIF0sIHNraW5XZWlnaHRzWyBmYWNlLmIgXSwgc2tpbldlaWdodHNbIGZhY2UuYyBdICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLmNvbXB1dGVHcm91cHMoIGdlb21ldHJ5ICk7XFxuXFxuXFx0XFx0XFx0dGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGU7XFxuXFx0XFx0XFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlO1xcblxcdFxcdFxcdHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGU7XFxuXFx0XFx0XFx0dGhpcy51dnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudXZzTmVlZFVwZGF0ZTtcXG5cXHRcXHRcXHR0aGlzLmdyb3Vwc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBhcnJheU1heCggYXJyYXkgKSB7XFxuXFxuXFx0XFx0aWYgKCBhcnJheS5sZW5ndGggPT09IDAgKSByZXR1cm4gLSBJbmZpbml0eTtcXG5cXG5cXHRcXHR2YXIgbWF4ID0gYXJyYXlbIDAgXTtcXG5cXG5cXHRcXHRmb3IgKCB2YXIgaSA9IDEsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyArKyBpICkge1xcblxcblxcdFxcdFxcdGlmICggYXJyYXlbIGkgXSA+IG1heCApIG1heCA9IGFycmF5WyBpIF07XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBtYXg7XFxuXFxuXFx0fVxcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHR2YXIgYnVmZmVyR2VvbWV0cnlJZCA9IDE7IC8vIEJ1ZmZlckdlb21ldHJ5IHVzZXMgb2RkIG51bWJlcnMgYXMgSWRcXG5cXG5cXHRmdW5jdGlvbiBCdWZmZXJHZW9tZXRyeSgpIHtcXG5cXG5cXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IGJ1ZmZlckdlb21ldHJ5SWQgKz0gMiB9ICk7XFxuXFxuXFx0XFx0dGhpcy51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7XFxuXFxuXFx0XFx0dGhpcy5uYW1lID0gJyc7XFxuXFx0XFx0dGhpcy50eXBlID0gJ0J1ZmZlckdlb21ldHJ5JztcXG5cXG5cXHRcXHR0aGlzLmluZGV4ID0gbnVsbDtcXG5cXHRcXHR0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcXG5cXG5cXHRcXHR0aGlzLm1vcnBoQXR0cmlidXRlcyA9IHt9O1xcblxcblxcdFxcdHRoaXMuZ3JvdXBzID0gW107XFxuXFxuXFx0XFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XFxuXFx0XFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XFxuXFxuXFx0XFx0dGhpcy5kcmF3UmFuZ2UgPSB7IHN0YXJ0OiAwLCBjb3VudDogSW5maW5pdHkgfTtcXG5cXG5cXHR9XFxuXFxuXFx0QnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IEJ1ZmZlckdlb21ldHJ5LFxcblxcblxcdFxcdGlzQnVmZmVyR2VvbWV0cnk6IHRydWUsXFxuXFxuXFx0XFx0Z2V0SW5kZXg6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5pbmRleDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldEluZGV4OiBmdW5jdGlvbiAoIGluZGV4ICkge1xcblxcblxcdFxcdFxcdGlmICggQXJyYXkuaXNBcnJheSggaW5kZXggKSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmluZGV4ID0gbmV3ICggYXJyYXlNYXgoIGluZGV4ICkgPiA2NTUzNSA/IFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSA6IFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSApKCBpbmRleCwgMSApO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5pbmRleCA9IGluZGV4O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGFkZEF0dHJpYnV0ZTogZnVuY3Rpb24gKCBuYW1lLCBhdHRyaWJ1dGUgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCAhICggYXR0cmlidXRlICYmIGF0dHJpYnV0ZS5pc0J1ZmZlckF0dHJpYnV0ZSApICYmICEgKCBhdHRyaWJ1dGUgJiYgYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZEF0dHJpYnV0ZSgpIG5vdyBleHBlY3RzICggbmFtZSwgYXR0cmlidXRlICkuJyApO1xcblxcblxcdFxcdFxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCBuYW1lLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBhcmd1bWVudHNbIDEgXSwgYXJndW1lbnRzWyAyIF0gKSApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBuYW1lID09PSAnaW5kZXgnICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmFkZEF0dHJpYnV0ZTogVXNlIC5zZXRJbmRleCgpIGZvciBpbmRleCBhdHRyaWJ1dGUuJyApO1xcblxcdFxcdFxcdFxcdHRoaXMuc2V0SW5kZXgoIGF0dHJpYnV0ZSApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF0gPSBhdHRyaWJ1dGU7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uICggbmFtZSApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF07XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyZW1vdmVBdHRyaWJ1dGU6IGZ1bmN0aW9uICggbmFtZSApIHtcXG5cXG5cXHRcXHRcXHRkZWxldGUgdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF07XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRhZGRHcm91cDogZnVuY3Rpb24gKCBzdGFydCwgY291bnQsIG1hdGVyaWFsSW5kZXggKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5ncm91cHMucHVzaCgge1xcblxcblxcdFxcdFxcdFxcdHN0YXJ0OiBzdGFydCxcXG5cXHRcXHRcXHRcXHRjb3VudDogY291bnQsXFxuXFx0XFx0XFx0XFx0bWF0ZXJpYWxJbmRleDogbWF0ZXJpYWxJbmRleCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWxJbmRleCA6IDBcXG5cXG5cXHRcXHRcXHR9ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbGVhckdyb3VwczogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMuZ3JvdXBzID0gW107XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXREcmF3UmFuZ2U6IGZ1bmN0aW9uICggc3RhcnQsIGNvdW50ICkge1xcblxcblxcdFxcdFxcdHRoaXMuZHJhd1JhbmdlLnN0YXJ0ID0gc3RhcnQ7XFxuXFx0XFx0XFx0dGhpcy5kcmF3UmFuZ2UuY291bnQgPSBjb3VudDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGFwcGx5TWF0cml4OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XFxuXFxuXFx0XFx0XFx0aWYgKCBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdG1hdHJpeC5hcHBseVRvQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiApO1xcblxcdFxcdFxcdFxcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIG5vcm1hbCA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWw7XFxuXFxuXFx0XFx0XFx0aWYgKCBub3JtYWwgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbm9ybWFsTWF0cml4ID0gbmV3IE1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xcblxcblxcdFxcdFxcdFxcdG5vcm1hbE1hdHJpeC5hcHBseVRvQnVmZmVyQXR0cmlidXRlKCBub3JtYWwgKTtcXG5cXHRcXHRcXHRcXHRub3JtYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cm90YXRlWDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeC1heGlzXFxuXFxuXFx0XFx0XFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWCggYW5nbGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0bTEubWFrZVJvdGF0aW9uWCggYW5nbGUgKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdHJvdGF0ZVk6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHktYXhpc1xcblxcblxcdFxcdFxcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVkoIGFuZ2xlICkge1xcblxcblxcdFxcdFxcdFxcdG0xLm1ha2VSb3RhdGlvblkoIGFuZ2xlICk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRyb3RhdGVaOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB6LWF4aXNcXG5cXG5cXHRcXHRcXHR2YXIgbTEgPSBuZXcgTWF0cml4NCgpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiByb3RhdGVaKCBhbmdsZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRtMS5tYWtlUm90YXRpb25aKCBhbmdsZSApO1xcblxcblxcdFxcdFxcdFxcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Ly8gdHJhbnNsYXRlIGdlb21ldHJ5XFxuXFxuXFx0XFx0XFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gdHJhbnNsYXRlKCB4LCB5LCB6ICkge1xcblxcblxcdFxcdFxcdFxcdG0xLm1ha2VUcmFuc2xhdGlvbiggeCwgeSwgeiApO1xcblxcblxcdFxcdFxcdFxcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0c2NhbGU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHQvLyBzY2FsZSBnZW9tZXRyeVxcblxcblxcdFxcdFxcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHNjYWxlKCB4LCB5LCB6ICkge1xcblxcblxcdFxcdFxcdFxcdG0xLm1ha2VTY2FsZSggeCwgeSwgeiApO1xcblxcblxcdFxcdFxcdFxcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0bG9va0F0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIG9iaiA9IG5ldyBPYmplY3QzRCgpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBsb29rQXQoIHZlY3RvciApIHtcXG5cXG5cXHRcXHRcXHRcXHRvYmoubG9va0F0KCB2ZWN0b3IgKTtcXG5cXG5cXHRcXHRcXHRcXHRvYmoudXBkYXRlTWF0cml4KCk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5hcHBseU1hdHJpeCggb2JqLm1hdHJpeCApO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdGNlbnRlcjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XFxuXFxuXFx0XFx0XFx0dmFyIG9mZnNldCA9IHRoaXMuYm91bmRpbmdCb3guZ2V0Q2VudGVyKCkubmVnYXRlKCk7XFxuXFxuXFx0XFx0XFx0dGhpcy50cmFuc2xhdGUoIG9mZnNldC54LCBvZmZzZXQueSwgb2Zmc2V0LnogKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gb2Zmc2V0O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0RnJvbU9iamVjdDogZnVuY3Rpb24gKCBvYmplY3QgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gY29uc29sZS5sb2coICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5zZXRGcm9tT2JqZWN0KCkuIENvbnZlcnRpbmcnLCBvYmplY3QsIHRoaXMgKTtcXG5cXG5cXHRcXHRcXHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XFxuXFxuXFx0XFx0XFx0aWYgKCBvYmplY3QuaXNQb2ludHMgfHwgb2JqZWN0LmlzTGluZSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCAqIDMsIDMgKTtcXG5cXHRcXHRcXHRcXHR2YXIgY29sb3JzID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGdlb21ldHJ5LmNvbG9ycy5sZW5ndGggKiAzLCAzICk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9ucy5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkudmVydGljZXMgKSApO1xcblxcdFxcdFxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAnY29sb3InLCBjb2xvcnMuY29weUNvbG9yc0FycmF5KCBnZW9tZXRyeS5jb2xvcnMgKSApO1xcblxcblxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cnkubGluZURpc3RhbmNlcyAmJiBnZW9tZXRyeS5saW5lRGlzdGFuY2VzLmxlbmd0aCA9PT0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBsaW5lRGlzdGFuY2VzID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMubGVuZ3RoLCAxICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdsaW5lRGlzdGFuY2UnLCBsaW5lRGlzdGFuY2VzLmNvcHlBcnJheSggZ2VvbWV0cnkubGluZURpc3RhbmNlcyApICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5ib3VuZGluZ0JveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94LmNsb25lKCk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG9iamVjdC5pc01lc2ggKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0dlb21ldHJ5ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuZnJvbUdlb21ldHJ5KCBnZW9tZXRyeSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHBvaW50cyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcG9zaXRpb24gPSBbXTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcG9pbnQgPSBwb2ludHNbIGkgXTtcXG5cXHRcXHRcXHRcXHRwb3NpdGlvbi5wdXNoKCBwb2ludC54LCBwb2ludC55LCBwb2ludC56IHx8IDAgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgMyApICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR1cGRhdGVGcm9tT2JqZWN0OiBmdW5jdGlvbiAoIG9iamVjdCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XFxuXFxuXFx0XFx0XFx0aWYgKCBvYmplY3QuaXNNZXNoICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBkaXJlY3QgPSBnZW9tZXRyeS5fX2RpcmVjdEdlb21ldHJ5O1xcblxcblxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cnkuZWxlbWVudHNOZWVkVXBkYXRlID09PSB0cnVlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGRpcmVjdCA9IHVuZGVmaW5lZDtcXG5cXHRcXHRcXHRcXHRcXHRnZW9tZXRyeS5lbGVtZW50c05lZWRVcGRhdGUgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBkaXJlY3QgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5mcm9tR2VvbWV0cnkoIGdlb21ldHJ5ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGRpcmVjdC52ZXJ0aWNlc05lZWRVcGRhdGUgPSBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGU7XFxuXFx0XFx0XFx0XFx0ZGlyZWN0Lm5vcm1hbHNOZWVkVXBkYXRlID0gZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGU7XFxuXFx0XFx0XFx0XFx0ZGlyZWN0LmNvbG9yc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlO1xcblxcdFxcdFxcdFxcdGRpcmVjdC51dnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudXZzTmVlZFVwZGF0ZTtcXG5cXHRcXHRcXHRcXHRkaXJlY3QuZ3JvdXBzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGU7XFxuXFxuXFx0XFx0XFx0XFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0Z2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0Z2VvbWV0cnkudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHRcXHRnZW9tZXRyeSA9IGRpcmVjdDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIGF0dHJpYnV0ZTtcXG5cXG5cXHRcXHRcXHRpZiAoIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRhdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzICk7XFxuXFx0XFx0XFx0XFx0XFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgPT09IHRydWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0YXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGF0dHJpYnV0ZS5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkubm9ybWFscyApO1xcblxcdFxcdFxcdFxcdFxcdGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMuY29sb3I7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRhdHRyaWJ1dGUuY29weUNvbG9yc0FycmF5KCBnZW9tZXRyeS5jb2xvcnMgKTtcXG5cXHRcXHRcXHRcXHRcXHRhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggZ2VvbWV0cnkudXZzTmVlZFVwZGF0ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMudXY7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRhdHRyaWJ1dGUuY29weVZlY3RvcjJzQXJyYXkoIGdlb21ldHJ5LnV2cyApO1xcblxcdFxcdFxcdFxcdFxcdGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGdlb21ldHJ5LnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMubGluZURpc3RhbmNlO1xcblxcblxcdFxcdFxcdFxcdGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YXR0cmlidXRlLmNvcHlBcnJheSggZ2VvbWV0cnkubGluZURpc3RhbmNlcyApO1xcblxcdFxcdFxcdFxcdFxcdGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGdlb21ldHJ5LmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggZ2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRnZW9tZXRyeS5jb21wdXRlR3JvdXBzKCBvYmplY3QuZ2VvbWV0cnkgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLmdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcXG5cXG5cXHRcXHRcXHRcXHRnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZnJvbUdlb21ldHJ5OiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xcblxcblxcdFxcdFxcdGdlb21ldHJ5Ll9fZGlyZWN0R2VvbWV0cnkgPSBuZXcgRGlyZWN0R2VvbWV0cnkoKS5mcm9tR2VvbWV0cnkoIGdlb21ldHJ5ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZnJvbURpcmVjdEdlb21ldHJ5KCBnZW9tZXRyeS5fX2RpcmVjdEdlb21ldHJ5ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRmcm9tRGlyZWN0R2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCAqIDMgKTtcXG5cXHRcXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCAzICkuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzICkgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGdlb21ldHJ5Lm5vcm1hbHMubGVuZ3RoID4gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5Lm5vcm1hbHMubGVuZ3RoICogMyApO1xcblxcdFxcdFxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS5ub3JtYWxzICkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5jb2xvcnMubGVuZ3RoID4gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkuY29sb3JzLmxlbmd0aCAqIDMgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkuY29weUNvbG9yc0FycmF5KCBnZW9tZXRyeS5jb2xvcnMgKSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGdlb21ldHJ5LnV2cy5sZW5ndGggPiAwICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS51dnMubGVuZ3RoICogMiApO1xcblxcdFxcdFxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKS5jb3B5VmVjdG9yMnNBcnJheSggZ2VvbWV0cnkudXZzICkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBnZW9tZXRyeS51dnMyLmxlbmd0aCA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHV2czIgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS51dnMyLmxlbmd0aCAqIDIgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2MicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHV2czIsIDIgKS5jb3B5VmVjdG9yMnNBcnJheSggZ2VvbWV0cnkudXZzMiApICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggZ2VvbWV0cnkuaW5kaWNlcy5sZW5ndGggPiAwICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBUeXBlQXJyYXkgPSBhcnJheU1heCggZ2VvbWV0cnkuaW5kaWNlcyApID4gNjU1MzUgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5O1xcblxcdFxcdFxcdFxcdHZhciBpbmRpY2VzID0gbmV3IFR5cGVBcnJheSggZ2VvbWV0cnkuaW5kaWNlcy5sZW5ndGggKiAzICk7XFxuXFx0XFx0XFx0XFx0dGhpcy5zZXRJbmRleCggbmV3IEJ1ZmZlckF0dHJpYnV0ZSggaW5kaWNlcywgMSApLmNvcHlJbmRpY2VzQXJyYXkoIGdlb21ldHJ5LmluZGljZXMgKSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBncm91cHNcXG5cXG5cXHRcXHRcXHR0aGlzLmdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcXG5cXG5cXHRcXHRcXHQvLyBtb3JwaHNcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgbmFtZSBpbiBnZW9tZXRyeS5tb3JwaFRhcmdldHMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGFycmF5ID0gW107XFxuXFx0XFx0XFx0XFx0dmFyIG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgbmFtZSBdO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBtb3JwaFRhcmdldCA9IG1vcnBoVGFyZ2V0c1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBhdHRyaWJ1dGUgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbW9ycGhUYXJnZXQubGVuZ3RoICogMywgMyApO1xcblxcblxcdFxcdFxcdFxcdFxcdGFycmF5LnB1c2goIGF0dHJpYnV0ZS5jb3B5VmVjdG9yM3NBcnJheSggbW9ycGhUYXJnZXQgKSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0aGlzLm1vcnBoQXR0cmlidXRlc1sgbmFtZSBdID0gYXJyYXk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIHNraW5uaW5nXFxuXFxuXFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggPiAwICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBza2luSW5kaWNlcyA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggKiA0LCA0ICk7XFxuXFx0XFx0XFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdza2luSW5kZXgnLCBza2luSW5kaWNlcy5jb3B5VmVjdG9yNHNBcnJheSggZ2VvbWV0cnkuc2tpbkluZGljZXMgKSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHNraW5XZWlnaHRzID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCAqIDQsIDQgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3NraW5XZWlnaHQnLCBza2luV2VpZ2h0cy5jb3B5VmVjdG9yNHNBcnJheSggZ2VvbWV0cnkuc2tpbldlaWdodHMgKSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvL1xcblxcblxcdFxcdFxcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5ib3VuZGluZ0JveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94LmNsb25lKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29tcHV0ZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ID09PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgQm94MygpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XFxuXFxuXFx0XFx0XFx0aWYgKCBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuYm91bmRpbmdCb3guc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24gKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuYm91bmRpbmdCb3gubWFrZUVtcHR5KCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnggKSB8fCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueSApIHx8IGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi56ICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveDogQ29tcHV0ZWQgbWluL21heCBoYXZlIE5hTiB2YWx1ZXMuIFRoZSBcXFwicG9zaXRpb25cXFwiIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb21wdXRlQm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgYm94ID0gbmV3IEJveDMoKTtcXG5cXHRcXHRcXHR2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCkge1xcblxcblxcdFxcdFxcdFxcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSgpO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR2YXIgcG9zaXRpb24gPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb247XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBwb3NpdGlvbiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgY2VudGVyID0gdGhpcy5ib3VuZGluZ1NwaGVyZS5jZW50ZXI7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ym94LnNldEZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uICk7XFxuXFx0XFx0XFx0XFx0XFx0Ym94LmdldENlbnRlciggY2VudGVyICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gaG9waW5nIHRvIGZpbmQgYSBib3VuZGluZ1NwaGVyZSB3aXRoIGEgcmFkaXVzIHNtYWxsZXIgdGhhbiB0aGVcXG5cXHRcXHRcXHRcXHRcXHQvLyBib3VuZGluZ1NwaGVyZSBvZiB0aGUgYm91bmRpbmdCb3g6IHNxcnQoMykgc21hbGxlciBpbiB0aGUgYmVzdCBjYXNlXFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIG1heFJhZGl1c1NxID0gMDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9zaXRpb24uY291bnQ7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2ZWN0b3IueCA9IHBvc2l0aW9uLmdldFgoIGkgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2ZWN0b3IueSA9IHBvc2l0aW9uLmdldFkoIGkgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2ZWN0b3IueiA9IHBvc2l0aW9uLmdldFooIGkgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXhSYWRpdXNTcSA9IE1hdGgubWF4KCBtYXhSYWRpdXNTcSwgY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCB2ZWN0b3IgKSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cyA9IE1hdGguc3FydCggbWF4UmFkaXVzU3EgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGlzTmFOKCB0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cyApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTogQ29tcHV0ZWQgcmFkaXVzIGlzIE5hTi4gVGhlIFxcXCJwb3NpdGlvblxcXCIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJywgdGhpcyApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0Y29tcHV0ZUZhY2VOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Ly8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvbXB1dGVWZXJ0ZXhOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGluZGV4ID0gdGhpcy5pbmRleDtcXG5cXHRcXHRcXHR2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcXG5cXHRcXHRcXHR2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XFxuXFxuXFx0XFx0XFx0aWYgKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xcblxcblxcdFxcdFxcdFxcdGlmICggYXR0cmlidXRlcy5ub3JtYWwgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHBvc2l0aW9ucy5sZW5ndGggKSwgMyApICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyByZXNldCBleGlzdGluZyBub3JtYWxzIHRvIHplcm9cXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgYXJyYXkgPSBhdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gYXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YXJyYXlbIGkgXSA9IDA7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR2YXIgbm9ybWFscyA9IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xcblxcblxcdFxcdFxcdFxcdHZhciB2QSwgdkIsIHZDO1xcblxcdFxcdFxcdFxcdHZhciBwQSA9IG5ldyBWZWN0b3IzKCksIHBCID0gbmV3IFZlY3RvcjMoKSwgcEMgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdFxcdHZhciBjYiA9IG5ldyBWZWN0b3IzKCksIGFiID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBpbmRleGVkIGVsZW1lbnRzXFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBpbmRleCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggZ3JvdXBzLmxlbmd0aCA9PT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmFkZEdyb3VwKCAwLCBpbmRpY2VzLmxlbmd0aCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZ3JvdXBzLmxlbmd0aDsgaiA8IGpsOyArKyBqICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBncm91cCA9IGdyb3Vwc1sgaiBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBzdGFydCA9IGdyb3VwLnN0YXJ0O1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBjb3VudCA9IGdyb3VwLmNvdW50O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gc3RhcnQsIGlsID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsOyBpICs9IDMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dkEgPSBpbmRpY2VzWyBpICsgMCBdICogMztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2QiA9IGluZGljZXNbIGkgKyAxIF0gKiAzO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZDID0gaW5kaWNlc1sgaSArIDIgXSAqIDM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cEEuZnJvbUFycmF5KCBwb3NpdGlvbnMsIHZBICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cEIuZnJvbUFycmF5KCBwb3NpdGlvbnMsIHZCICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cEMuZnJvbUFycmF5KCBwb3NpdGlvbnMsIHZDICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YWIuc3ViVmVjdG9ycyggcEEsIHBCICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2IuY3Jvc3MoIGFiICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgdkEgXSArPSBjYi54O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIHZBICsgMSBdICs9IGNiLnk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgdkEgKyAyIF0gKz0gY2IuejtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyB2QiBdICs9IGNiLng7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgdkIgKyAxIF0gKz0gY2IueTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyB2QiArIDIgXSArPSBjYi56O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIHZDIF0gKz0gY2IueDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyB2QyArIDEgXSArPSBjYi55O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIHZDICsgMiBdICs9IGNiLno7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIG5vbi1pbmRleGVkIGVsZW1lbnRzICh1bmNvbm5lY3RlZCB0cmlhbmdsZSBzb3VwKVxcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gOSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRwQS5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdHBCLmZyb21BcnJheSggcG9zaXRpb25zLCBpICsgMyApO1xcblxcdFxcdFxcdFxcdFxcdFxcdHBDLmZyb21BcnJheSggcG9zaXRpb25zLCBpICsgNiApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNiLnN1YlZlY3RvcnMoIHBDLCBwQiApO1xcblxcdFxcdFxcdFxcdFxcdFxcdGFiLnN1YlZlY3RvcnMoIHBBLCBwQiApO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNiLmNyb3NzKCBhYiApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIGkgXSA9IGNiLng7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgaSArIDEgXSA9IGNiLnk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgaSArIDIgXSA9IGNiLno7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgaSArIDMgXSA9IGNiLng7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgaSArIDQgXSA9IGNiLnk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgaSArIDUgXSA9IGNiLno7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgaSArIDYgXSA9IGNiLng7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgaSArIDcgXSA9IGNiLnk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgaSArIDggXSA9IGNiLno7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0aGlzLm5vcm1hbGl6ZU5vcm1hbHMoKTtcXG5cXG5cXHRcXHRcXHRcXHRhdHRyaWJ1dGVzLm5vcm1hbC5uZWVkc1VwZGF0ZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bWVyZ2U6IGZ1bmN0aW9uICggZ2VvbWV0cnksIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoICEgKCBnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5Lm1lcmdlKCk6IGdlb21ldHJ5IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeS4nLCBnZW9tZXRyeSApO1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XFxuXFxuXFx0XFx0XFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cnkuYXR0cmlidXRlc1sga2V5IF0gPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xcblxcblxcdFxcdFxcdFxcdHZhciBhdHRyaWJ1dGUxID0gYXR0cmlidXRlc1sga2V5IF07XFxuXFx0XFx0XFx0XFx0dmFyIGF0dHJpYnV0ZUFycmF5MSA9IGF0dHJpYnV0ZTEuYXJyYXk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGF0dHJpYnV0ZTIgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBrZXkgXTtcXG5cXHRcXHRcXHRcXHR2YXIgYXR0cmlidXRlQXJyYXkyID0gYXR0cmlidXRlMi5hcnJheTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgYXR0cmlidXRlU2l6ZSA9IGF0dHJpYnV0ZTIuaXRlbVNpemU7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBqID0gYXR0cmlidXRlU2l6ZSAqIG9mZnNldDsgaSA8IGF0dHJpYnV0ZUFycmF5Mi5sZW5ndGg7IGkgKyssIGogKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YXR0cmlidXRlQXJyYXkxWyBqIF0gPSBhdHRyaWJ1dGVBcnJheTJbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bm9ybWFsaXplTm9ybWFsczogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBub3JtYWxpemVOb3JtYWxzKCkge1xcblxcblxcdFxcdFxcdFxcdHZhciBub3JtYWxzID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbm9ybWFscy5jb3VudDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZlY3Rvci54ID0gbm9ybWFscy5nZXRYKCBpICk7XFxuXFx0XFx0XFx0XFx0XFx0dmVjdG9yLnkgPSBub3JtYWxzLmdldFkoIGkgKTtcXG5cXHRcXHRcXHRcXHRcXHR2ZWN0b3IueiA9IG5vcm1hbHMuZ2V0WiggaSApO1xcblxcblxcdFxcdFxcdFxcdFxcdHZlY3Rvci5ub3JtYWxpemUoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRub3JtYWxzLnNldFhZWiggaSwgdmVjdG9yLngsIHZlY3Rvci55LCB2ZWN0b3IueiApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHR0b05vbkluZGV4ZWQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuaW5kZXggPT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkudG9Ob25JbmRleGVkKCk6IEdlb21ldHJ5IGlzIGFscmVhZHkgbm9uLWluZGV4ZWQuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgZ2VvbWV0cnkyID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XFxuXFxuXFx0XFx0XFx0dmFyIGluZGljZXMgPSB0aGlzLmluZGV4LmFycmF5O1xcblxcdFxcdFxcdHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIG5hbWUgXTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgYXJyYXkgPSBhdHRyaWJ1dGUuYXJyYXk7XFxuXFx0XFx0XFx0XFx0dmFyIGl0ZW1TaXplID0gYXR0cmlidXRlLml0ZW1TaXplO1xcblxcblxcdFxcdFxcdFxcdHZhciBhcnJheTIgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IoIGluZGljZXMubGVuZ3RoICogaXRlbVNpemUgKTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgaW5kZXggPSAwLCBpbmRleDIgPSAwO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpbmRleCA9IGluZGljZXNbIGkgXSAqIGl0ZW1TaXplO1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBqID0gMDsgaiA8IGl0ZW1TaXplOyBqICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGFycmF5MlsgaW5kZXgyICsrIF0gPSBhcnJheVsgaW5kZXggKysgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGdlb21ldHJ5Mi5hZGRBdHRyaWJ1dGUoIG5hbWUsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGFycmF5MiwgaXRlbVNpemUgKSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gZ2VvbWV0cnkyO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGRhdGEgPSB7XFxuXFx0XFx0XFx0XFx0bWV0YWRhdGE6IHtcXG5cXHRcXHRcXHRcXHRcXHR2ZXJzaW9uOiA0LjUsXFxuXFx0XFx0XFx0XFx0XFx0dHlwZTogJ0J1ZmZlckdlb21ldHJ5JyxcXG5cXHRcXHRcXHRcXHRcXHRnZW5lcmF0b3I6ICdCdWZmZXJHZW9tZXRyeS50b0pTT04nXFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0Ly8gc3RhbmRhcmQgQnVmZmVyR2VvbWV0cnkgc2VyaWFsaXphdGlvblxcblxcblxcdFxcdFxcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcXG5cXHRcXHRcXHRkYXRhLnR5cGUgPSB0aGlzLnR5cGU7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5wYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGtleSBpbiBwYXJhbWV0ZXJzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggcGFyYW1ldGVyc1sga2V5IF0gIT09IHVuZGVmaW5lZCApIGRhdGFbIGtleSBdID0gcGFyYW1ldGVyc1sga2V5IF07XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiBkYXRhO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRkYXRhLmRhdGEgPSB7IGF0dHJpYnV0ZXM6IHt9IH07XFxuXFxuXFx0XFx0XFx0dmFyIGluZGV4ID0gdGhpcy5pbmRleDtcXG5cXG5cXHRcXHRcXHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBhcnJheSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBpbmRleC5hcnJheSApO1xcblxcblxcdFxcdFxcdFxcdGRhdGEuZGF0YS5pbmRleCA9IHtcXG5cXHRcXHRcXHRcXHRcXHR0eXBlOiBpbmRleC5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLFxcblxcdFxcdFxcdFxcdFxcdGFycmF5OiBhcnJheVxcblxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBrZXkgaW4gYXR0cmlidXRlcyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sga2V5IF07XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGF0dHJpYnV0ZS5hcnJheSApO1xcblxcblxcdFxcdFxcdFxcdGRhdGEuZGF0YS5hdHRyaWJ1dGVzWyBrZXkgXSA9IHtcXG5cXHRcXHRcXHRcXHRcXHRpdGVtU2l6ZTogYXR0cmlidXRlLml0ZW1TaXplLFxcblxcdFxcdFxcdFxcdFxcdHR5cGU6IGF0dHJpYnV0ZS5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLFxcblxcdFxcdFxcdFxcdFxcdGFycmF5OiBhcnJheSxcXG5cXHRcXHRcXHRcXHRcXHRub3JtYWxpemVkOiBhdHRyaWJ1dGUubm9ybWFsaXplZFxcblxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBncm91cHMgPSB0aGlzLmdyb3VwcztcXG5cXG5cXHRcXHRcXHRpZiAoIGdyb3Vwcy5sZW5ndGggPiAwICkge1xcblxcblxcdFxcdFxcdFxcdGRhdGEuZGF0YS5ncm91cHMgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggZ3JvdXBzICkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIGJvdW5kaW5nU3BoZXJlID0gdGhpcy5ib3VuZGluZ1NwaGVyZTtcXG5cXG5cXHRcXHRcXHRpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdGRhdGEuZGF0YS5ib3VuZGluZ1NwaGVyZSA9IHtcXG5cXHRcXHRcXHRcXHRcXHRjZW50ZXI6IGJvdW5kaW5nU3BoZXJlLmNlbnRlci50b0FycmF5KCksXFxuXFx0XFx0XFx0XFx0XFx0cmFkaXVzOiBib3VuZGluZ1NwaGVyZS5yYWRpdXNcXG5cXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gZGF0YTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0LypcXG5cXHRcXHRcXHQgLy8gSGFuZGxlIHByaW1pdGl2ZXNcXG5cXG5cXHRcXHRcXHQgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XFxuXFxuXFx0XFx0XFx0IGlmICggcGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdCB2YXIgdmFsdWVzID0gW107XFxuXFxuXFx0XFx0XFx0IGZvciAoIHZhciBrZXkgaW4gcGFyYW1ldGVycyApIHtcXG5cXG5cXHRcXHRcXHQgdmFsdWVzLnB1c2goIHBhcmFtZXRlcnNbIGtleSBdICk7XFxuXFxuXFx0XFx0XFx0IH1cXG5cXG5cXHRcXHRcXHQgdmFyIGdlb21ldHJ5ID0gT2JqZWN0LmNyZWF0ZSggdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgKTtcXG5cXHRcXHRcXHQgdGhpcy5jb25zdHJ1Y3Rvci5hcHBseSggZ2VvbWV0cnksIHZhbHVlcyApO1xcblxcdFxcdFxcdCByZXR1cm4gZ2VvbWV0cnk7XFxuXFxuXFx0XFx0XFx0IH1cXG5cXG5cXHRcXHRcXHQgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xcblxcdFxcdFxcdCAqL1xcblxcblxcdFxcdFxcdHJldHVybiBuZXcgQnVmZmVyR2VvbWV0cnkoKS5jb3B5KCB0aGlzICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgbmFtZSwgaSwgbDtcXG5cXG5cXHRcXHRcXHQvLyByZXNldFxcblxcblxcdFxcdFxcdHRoaXMuaW5kZXggPSBudWxsO1xcblxcdFxcdFxcdHRoaXMuYXR0cmlidXRlcyA9IHt9O1xcblxcdFxcdFxcdHRoaXMubW9ycGhBdHRyaWJ1dGVzID0ge307XFxuXFx0XFx0XFx0dGhpcy5ncm91cHMgPSBbXTtcXG5cXHRcXHRcXHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcXG5cXHRcXHRcXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcXG5cXG5cXHRcXHRcXHQvLyBuYW1lXFxuXFxuXFx0XFx0XFx0dGhpcy5uYW1lID0gc291cmNlLm5hbWU7XFxuXFxuXFx0XFx0XFx0Ly8gaW5kZXhcXG5cXG5cXHRcXHRcXHR2YXIgaW5kZXggPSBzb3VyY2UuaW5kZXg7XFxuXFxuXFx0XFx0XFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnNldEluZGV4KCBpbmRleC5jbG9uZSgpICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGF0dHJpYnV0ZXNcXG5cXG5cXHRcXHRcXHR2YXIgYXR0cmlidXRlcyA9IHNvdXJjZS5hdHRyaWJ1dGVzO1xcblxcblxcdFxcdFxcdGZvciAoIG5hbWUgaW4gYXR0cmlidXRlcyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sgbmFtZSBdO1xcblxcdFxcdFxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCBuYW1lLCBhdHRyaWJ1dGUuY2xvbmUoKSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBtb3JwaCBhdHRyaWJ1dGVzXFxuXFxuXFx0XFx0XFx0dmFyIG1vcnBoQXR0cmlidXRlcyA9IHNvdXJjZS5tb3JwaEF0dHJpYnV0ZXM7XFxuXFxuXFx0XFx0XFx0Zm9yICggbmFtZSBpbiBtb3JwaEF0dHJpYnV0ZXMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGFycmF5ID0gW107XFxuXFx0XFx0XFx0XFx0dmFyIG1vcnBoQXR0cmlidXRlID0gbW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF07IC8vIG1vcnBoQXR0cmlidXRlOiBhcnJheSBvZiBGbG9hdDMyQnVmZmVyQXR0cmlidXRlc1xcblxcblxcdFxcdFxcdFxcdGZvciAoIGkgPSAwLCBsID0gbW9ycGhBdHRyaWJ1dGUubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRhcnJheS5wdXNoKCBtb3JwaEF0dHJpYnV0ZVsgaSBdLmNsb25lKCkgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5tb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXSA9IGFycmF5O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBncm91cHNcXG5cXG5cXHRcXHRcXHR2YXIgZ3JvdXBzID0gc291cmNlLmdyb3VwcztcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xcblxcdFxcdFxcdFxcdHRoaXMuYWRkR3JvdXAoIGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCwgZ3JvdXAubWF0ZXJpYWxJbmRleCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBib3VuZGluZyBib3hcXG5cXG5cXHRcXHRcXHR2YXIgYm91bmRpbmdCb3ggPSBzb3VyY2UuYm91bmRpbmdCb3g7XFxuXFxuXFx0XFx0XFx0aWYgKCBib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmJvdW5kaW5nQm94ID0gYm91bmRpbmdCb3guY2xvbmUoKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gYm91bmRpbmcgc3BoZXJlXFxuXFxuXFx0XFx0XFx0dmFyIGJvdW5kaW5nU3BoZXJlID0gc291cmNlLmJvdW5kaW5nU3BoZXJlO1xcblxcblxcdFxcdFxcdGlmICggYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IGJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGRyYXcgcmFuZ2VcXG5cXG5cXHRcXHRcXHR0aGlzLmRyYXdSYW5nZS5zdGFydCA9IHNvdXJjZS5kcmF3UmFuZ2Uuc3RhcnQ7XFxuXFx0XFx0XFx0dGhpcy5kcmF3UmFuZ2UuY291bnQgPSBzb3VyY2UuZHJhd1JhbmdlLmNvdW50O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xcblxcdCAqL1xcblxcblxcdC8vIEJveEdlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gQm94R2VvbWV0cnkoIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgZGVwdGhTZWdtZW50cyApIHtcXG5cXG5cXHRcXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ0JveEdlb21ldHJ5JztcXG5cXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxuXFx0XFx0XFx0d2lkdGg6IHdpZHRoLFxcblxcdFxcdFxcdGhlaWdodDogaGVpZ2h0LFxcblxcdFxcdFxcdGRlcHRoOiBkZXB0aCxcXG5cXHRcXHRcXHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxcblxcdFxcdFxcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcXG5cXHRcXHRcXHRkZXB0aFNlZ21lbnRzOiBkZXB0aFNlZ21lbnRzXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IEJveEJ1ZmZlckdlb21ldHJ5KCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIGRlcHRoU2VnbWVudHMgKSApO1xcblxcdFxcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xcblxcblxcdH1cXG5cXG5cXHRCb3hHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcXG5cXHRCb3hHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCb3hHZW9tZXRyeTtcXG5cXG5cXHQvLyBCb3hCdWZmZXJHZW9tZXRyeVxcblxcblxcdGZ1bmN0aW9uIEJveEJ1ZmZlckdlb21ldHJ5KCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIGRlcHRoU2VnbWVudHMgKSB7XFxuXFxuXFx0XFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdCb3hCdWZmZXJHZW9tZXRyeSc7XFxuXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcblxcdFxcdFxcdHdpZHRoOiB3aWR0aCxcXG5cXHRcXHRcXHRoZWlnaHQ6IGhlaWdodCxcXG5cXHRcXHRcXHRkZXB0aDogZGVwdGgsXFxuXFx0XFx0XFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcXG5cXHRcXHRcXHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXFxuXFx0XFx0XFx0ZGVwdGhTZWdtZW50czogZGVwdGhTZWdtZW50c1xcblxcdFxcdH07XFxuXFxuXFx0XFx0dmFyIHNjb3BlID0gdGhpcztcXG5cXG5cXHRcXHR3aWR0aCA9IHdpZHRoIHx8IDE7XFxuXFx0XFx0aGVpZ2h0ID0gaGVpZ2h0IHx8IDE7XFxuXFx0XFx0ZGVwdGggPSBkZXB0aCB8fCAxO1xcblxcblxcdFxcdC8vIHNlZ21lbnRzXFxuXFxuXFx0XFx0d2lkdGhTZWdtZW50cyA9IE1hdGguZmxvb3IoIHdpZHRoU2VnbWVudHMgKSB8fCAxO1xcblxcdFxcdGhlaWdodFNlZ21lbnRzID0gTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKSB8fCAxO1xcblxcdFxcdGRlcHRoU2VnbWVudHMgPSBNYXRoLmZsb29yKCBkZXB0aFNlZ21lbnRzICkgfHwgMTtcXG5cXG5cXHRcXHQvLyBidWZmZXJzXFxuXFxuXFx0XFx0dmFyIGluZGljZXMgPSBbXTtcXG5cXHRcXHR2YXIgdmVydGljZXMgPSBbXTtcXG5cXHRcXHR2YXIgbm9ybWFscyA9IFtdO1xcblxcdFxcdHZhciB1dnMgPSBbXTtcXG5cXG5cXHRcXHQvLyBoZWxwZXIgdmFyaWFibGVzXFxuXFxuXFx0XFx0dmFyIG51bWJlck9mVmVydGljZXMgPSAwO1xcblxcdFxcdHZhciBncm91cFN0YXJ0ID0gMDtcXG5cXG5cXHRcXHQvLyBidWlsZCBlYWNoIHNpZGUgb2YgdGhlIGJveCBnZW9tZXRyeVxcblxcblxcdFxcdGJ1aWxkUGxhbmUoICd6JywgJ3knLCAneCcsIC0gMSwgLSAxLCBkZXB0aCwgaGVpZ2h0LCB3aWR0aCwgZGVwdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIDAgKTsgLy8gcHhcXG5cXHRcXHRidWlsZFBsYW5lKCAneicsICd5JywgJ3gnLCAxLCAtIDEsIGRlcHRoLCBoZWlnaHQsIC0gd2lkdGgsIGRlcHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCAxICk7IC8vIG54XFxuXFx0XFx0YnVpbGRQbGFuZSggJ3gnLCAneicsICd5JywgMSwgMSwgd2lkdGgsIGRlcHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGRlcHRoU2VnbWVudHMsIDIgKTsgLy8gcHlcXG5cXHRcXHRidWlsZFBsYW5lKCAneCcsICd6JywgJ3knLCAxLCAtIDEsIHdpZHRoLCBkZXB0aCwgLSBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGRlcHRoU2VnbWVudHMsIDMgKTsgLy8gbnlcXG5cXHRcXHRidWlsZFBsYW5lKCAneCcsICd5JywgJ3onLCAxLCAtIDEsIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgNCApOyAvLyBwelxcblxcdFxcdGJ1aWxkUGxhbmUoICd4JywgJ3knLCAneicsIC0gMSwgLSAxLCB3aWR0aCwgaGVpZ2h0LCAtIGRlcHRoLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgNSApOyAvLyBuelxcblxcblxcdFxcdC8vIGJ1aWxkIGdlb21ldHJ5XFxuXFxuXFx0XFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcXG5cXG5cXHRcXHRmdW5jdGlvbiBidWlsZFBsYW5lKCB1LCB2LCB3LCB1ZGlyLCB2ZGlyLCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgZ3JpZFgsIGdyaWRZLCBtYXRlcmlhbEluZGV4ICkge1xcblxcblxcdFxcdFxcdHZhciBzZWdtZW50V2lkdGggPSB3aWR0aCAvIGdyaWRYO1xcblxcdFxcdFxcdHZhciBzZWdtZW50SGVpZ2h0ID0gaGVpZ2h0IC8gZ3JpZFk7XFxuXFxuXFx0XFx0XFx0dmFyIHdpZHRoSGFsZiA9IHdpZHRoIC8gMjtcXG5cXHRcXHRcXHR2YXIgaGVpZ2h0SGFsZiA9IGhlaWdodCAvIDI7XFxuXFx0XFx0XFx0dmFyIGRlcHRoSGFsZiA9IGRlcHRoIC8gMjtcXG5cXG5cXHRcXHRcXHR2YXIgZ3JpZFgxID0gZ3JpZFggKyAxO1xcblxcdFxcdFxcdHZhciBncmlkWTEgPSBncmlkWSArIDE7XFxuXFxuXFx0XFx0XFx0dmFyIHZlcnRleENvdW50ZXIgPSAwO1xcblxcdFxcdFxcdHZhciBncm91cENvdW50ID0gMDtcXG5cXG5cXHRcXHRcXHR2YXIgaXgsIGl5O1xcblxcblxcdFxcdFxcdHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcXG5cXG5cXHRcXHRcXHRmb3IgKCBpeSA9IDA7IGl5IDwgZ3JpZFkxOyBpeSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgeSA9IGl5ICogc2VnbWVudEhlaWdodCAtIGhlaWdodEhhbGY7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggaXggPSAwOyBpeCA8IGdyaWRYMTsgaXggKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHggPSBpeCAqIHNlZ21lbnRXaWR0aCAtIHdpZHRoSGFsZjtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBzZXQgdmFsdWVzIHRvIGNvcnJlY3QgdmVjdG9yIGNvbXBvbmVudFxcblxcblxcdFxcdFxcdFxcdFxcdHZlY3RvclsgdSBdID0geCAqIHVkaXI7XFxuXFx0XFx0XFx0XFx0XFx0dmVjdG9yWyB2IF0gPSB5ICogdmRpcjtcXG5cXHRcXHRcXHRcXHRcXHR2ZWN0b3JbIHcgXSA9IGRlcHRoSGFsZjtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBub3cgYXBwbHkgdmVjdG9yIHRvIHZlcnRleCBidWZmZXJcXG5cXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCB2ZWN0b3IueCwgdmVjdG9yLnksIHZlY3Rvci56ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gc2V0IHZhbHVlcyB0byBjb3JyZWN0IHZlY3RvciBjb21wb25lbnRcXG5cXG5cXHRcXHRcXHRcXHRcXHR2ZWN0b3JbIHUgXSA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0dmVjdG9yWyB2IF0gPSAwO1xcblxcdFxcdFxcdFxcdFxcdHZlY3RvclsgdyBdID0gZGVwdGggPiAwID8gMSA6IC0gMTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBub3cgYXBwbHkgdmVjdG9yIHRvIG5vcm1hbCBidWZmZXJcXG5cXG5cXHRcXHRcXHRcXHRcXHRub3JtYWxzLnB1c2goIHZlY3Rvci54LCB2ZWN0b3IueSwgdmVjdG9yLnogKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyB1dnNcXG5cXG5cXHRcXHRcXHRcXHRcXHR1dnMucHVzaCggaXggLyBncmlkWCApO1xcblxcdFxcdFxcdFxcdFxcdHV2cy5wdXNoKCAxIC0gKCBpeSAvIGdyaWRZICkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBjb3VudGVyc1xcblxcblxcdFxcdFxcdFxcdFxcdHZlcnRleENvdW50ZXIgKz0gMTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGluZGljZXNcXG5cXG5cXHRcXHRcXHQvLyAxLiB5b3UgbmVlZCB0aHJlZSBpbmRpY2VzIHRvIGRyYXcgYSBzaW5nbGUgZmFjZVxcblxcdFxcdFxcdC8vIDIuIGEgc2luZ2xlIHNlZ21lbnQgY29uc2lzdHMgb2YgdHdvIGZhY2VzXFxuXFx0XFx0XFx0Ly8gMy4gc28gd2UgbmVlZCB0byBnZW5lcmF0ZSBzaXggKDIqMykgaW5kaWNlcyBwZXIgc2VnbWVudFxcblxcblxcdFxcdFxcdGZvciAoIGl5ID0gMDsgaXkgPCBncmlkWTsgaXkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggaXggPSAwOyBpeCA8IGdyaWRYOyBpeCArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgYSA9IG51bWJlck9mVmVydGljZXMgKyBpeCArIGdyaWRYMSAqIGl5O1xcblxcdFxcdFxcdFxcdFxcdHZhciBiID0gbnVtYmVyT2ZWZXJ0aWNlcyArIGl4ICsgZ3JpZFgxICogKCBpeSArIDEgKTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgYyA9IG51bWJlck9mVmVydGljZXMgKyAoIGl4ICsgMSApICsgZ3JpZFgxICogKCBpeSArIDEgKTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgZCA9IG51bWJlck9mVmVydGljZXMgKyAoIGl4ICsgMSApICsgZ3JpZFgxICogaXk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gZmFjZXNcXG5cXG5cXHRcXHRcXHRcXHRcXHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcXG5cXHRcXHRcXHRcXHRcXHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBpbmNyZWFzZSBjb3VudGVyXFxuXFxuXFx0XFx0XFx0XFx0XFx0Z3JvdXBDb3VudCArPSA2O1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gYWRkIGEgZ3JvdXAgdG8gdGhlIGdlb21ldHJ5LiB0aGlzIHdpbGwgZW5zdXJlIG11bHRpIG1hdGVyaWFsIHN1cHBvcnRcXG5cXG5cXHRcXHRcXHRzY29wZS5hZGRHcm91cCggZ3JvdXBTdGFydCwgZ3JvdXBDb3VudCwgbWF0ZXJpYWxJbmRleCApO1xcblxcblxcdFxcdFxcdC8vIGNhbGN1bGF0ZSBuZXcgc3RhcnQgdmFsdWUgZm9yIGdyb3Vwc1xcblxcblxcdFxcdFxcdGdyb3VwU3RhcnQgKz0gZ3JvdXBDb3VudDtcXG5cXG5cXHRcXHRcXHQvLyB1cGRhdGUgdG90YWwgbnVtYmVyIG9mIHZlcnRpY2VzXFxuXFxuXFx0XFx0XFx0bnVtYmVyT2ZWZXJ0aWNlcyArPSB2ZXJ0ZXhDb3VudGVyO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9XFxuXFxuXFx0Qm94QnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XFxuXFx0Qm94QnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQm94QnVmZmVyR2VvbWV0cnk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xcblxcdCAqL1xcblxcblxcdC8vIFBsYW5lR2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBQbGFuZUdlb21ldHJ5KCB3aWR0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyApIHtcXG5cXG5cXHRcXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1BsYW5lR2VvbWV0cnknO1xcblxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXG5cXHRcXHRcXHR3aWR0aDogd2lkdGgsXFxuXFx0XFx0XFx0aGVpZ2h0OiBoZWlnaHQsXFxuXFx0XFx0XFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcXG5cXHRcXHRcXHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHNcXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgUGxhbmVCdWZmZXJHZW9tZXRyeSggd2lkdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMgKSApO1xcblxcdFxcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xcblxcblxcdH1cXG5cXG5cXHRQbGFuZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xcblxcdFBsYW5lR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGxhbmVHZW9tZXRyeTtcXG5cXG5cXHQvLyBQbGFuZUJ1ZmZlckdlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gUGxhbmVCdWZmZXJHZW9tZXRyeSggd2lkdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMgKSB7XFxuXFxuXFx0XFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdQbGFuZUJ1ZmZlckdlb21ldHJ5JztcXG5cXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxuXFx0XFx0XFx0d2lkdGg6IHdpZHRoLFxcblxcdFxcdFxcdGhlaWdodDogaGVpZ2h0LFxcblxcdFxcdFxcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXFxuXFx0XFx0XFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR3aWR0aCA9IHdpZHRoIHx8IDE7XFxuXFx0XFx0aGVpZ2h0ID0gaGVpZ2h0IHx8IDE7XFxuXFxuXFx0XFx0dmFyIHdpZHRoX2hhbGYgPSB3aWR0aCAvIDI7XFxuXFx0XFx0dmFyIGhlaWdodF9oYWxmID0gaGVpZ2h0IC8gMjtcXG5cXG5cXHRcXHR2YXIgZ3JpZFggPSBNYXRoLmZsb29yKCB3aWR0aFNlZ21lbnRzICkgfHwgMTtcXG5cXHRcXHR2YXIgZ3JpZFkgPSBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApIHx8IDE7XFxuXFxuXFx0XFx0dmFyIGdyaWRYMSA9IGdyaWRYICsgMTtcXG5cXHRcXHR2YXIgZ3JpZFkxID0gZ3JpZFkgKyAxO1xcblxcblxcdFxcdHZhciBzZWdtZW50X3dpZHRoID0gd2lkdGggLyBncmlkWDtcXG5cXHRcXHR2YXIgc2VnbWVudF9oZWlnaHQgPSBoZWlnaHQgLyBncmlkWTtcXG5cXG5cXHRcXHR2YXIgaXgsIGl5O1xcblxcblxcdFxcdC8vIGJ1ZmZlcnNcXG5cXG5cXHRcXHR2YXIgaW5kaWNlcyA9IFtdO1xcblxcdFxcdHZhciB2ZXJ0aWNlcyA9IFtdO1xcblxcdFxcdHZhciBub3JtYWxzID0gW107XFxuXFx0XFx0dmFyIHV2cyA9IFtdO1xcblxcblxcdFxcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcXG5cXG5cXHRcXHRmb3IgKCBpeSA9IDA7IGl5IDwgZ3JpZFkxOyBpeSArKyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgeSA9IGl5ICogc2VnbWVudF9oZWlnaHQgLSBoZWlnaHRfaGFsZjtcXG5cXG5cXHRcXHRcXHRmb3IgKCBpeCA9IDA7IGl4IDwgZ3JpZFgxOyBpeCArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgeCA9IGl4ICogc2VnbWVudF93aWR0aCAtIHdpZHRoX2hhbGY7XFxuXFxuXFx0XFx0XFx0XFx0dmVydGljZXMucHVzaCggeCwgLSB5LCAwICk7XFxuXFxuXFx0XFx0XFx0XFx0bm9ybWFscy5wdXNoKCAwLCAwLCAxICk7XFxuXFxuXFx0XFx0XFx0XFx0dXZzLnB1c2goIGl4IC8gZ3JpZFggKTtcXG5cXHRcXHRcXHRcXHR1dnMucHVzaCggMSAtICggaXkgLyBncmlkWSApICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBpbmRpY2VzXFxuXFxuXFx0XFx0Zm9yICggaXkgPSAwOyBpeSA8IGdyaWRZOyBpeSArKyApIHtcXG5cXG5cXHRcXHRcXHRmb3IgKCBpeCA9IDA7IGl4IDwgZ3JpZFg7IGl4ICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBhID0gaXggKyBncmlkWDEgKiBpeTtcXG5cXHRcXHRcXHRcXHR2YXIgYiA9IGl4ICsgZ3JpZFgxICogKCBpeSArIDEgKTtcXG5cXHRcXHRcXHRcXHR2YXIgYyA9ICggaXggKyAxICkgKyBncmlkWDEgKiAoIGl5ICsgMSApO1xcblxcdFxcdFxcdFxcdHZhciBkID0gKCBpeCArIDEgKSArIGdyaWRYMSAqIGl5O1xcblxcblxcdFxcdFxcdFxcdC8vIGZhY2VzXFxuXFxuXFx0XFx0XFx0XFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XFxuXFx0XFx0XFx0XFx0aW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBidWlsZCBnZW9tZXRyeVxcblxcblxcdFxcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XFxuXFxuXFx0fVxcblxcblxcdFBsYW5lQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XFxuXFx0UGxhbmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQbGFuZUJ1ZmZlckdlb21ldHJ5O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKlxcblxcdCAqIHBhcmFtZXRlcnMgPSB7XFxuXFx0ICogIGNvbG9yOiA8aGV4PixcXG5cXHQgKiAgb3BhY2l0eTogPGZsb2F0PixcXG5cXHQgKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqXFxuXFx0ICogIGxpZ2h0TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqICBsaWdodE1hcEludGVuc2l0eTogPGZsb2F0PlxcblxcdCAqXFxuXFx0ICogIGFvTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqICBhb01hcEludGVuc2l0eTogPGZsb2F0PlxcblxcdCAqXFxuXFx0ICogIHNwZWN1bGFyTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqXFxuXFx0ICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqXFxuXFx0ICogIGVudk1hcDogbmV3IFRIUkVFLlRleHR1cmVDdWJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcXG5cXHQgKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXFxuXFx0ICogIHJlZmxlY3Rpdml0eTogPGZsb2F0PixcXG5cXHQgKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxcblxcdCAqXFxuXFx0ICogIGRlcHRoVGVzdDogPGJvb2w+LFxcblxcdCAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXFxuXFx0ICpcXG5cXHQgKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXFxuXFx0ICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcXG5cXHQgKlxcblxcdCAqICBza2lubmluZzogPGJvb2w+LFxcblxcdCAqICBtb3JwaFRhcmdldHM6IDxib29sPlxcblxcdCAqIH1cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBNZXNoQmFzaWNNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcXG5cXG5cXHRcXHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ01lc2hCYXNpY01hdGVyaWFsJztcXG5cXG5cXHRcXHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApOyAvLyBlbWlzc2l2ZVxcblxcblxcdFxcdHRoaXMubWFwID0gbnVsbDtcXG5cXG5cXHRcXHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcXG5cXHRcXHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMS4wO1xcblxcblxcdFxcdHRoaXMuYW9NYXAgPSBudWxsO1xcblxcdFxcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XFxuXFxuXFx0XFx0dGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XFxuXFxuXFx0XFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XFxuXFxuXFx0XFx0dGhpcy5lbnZNYXAgPSBudWxsO1xcblxcdFxcdHRoaXMuY29tYmluZSA9IE11bHRpcGx5T3BlcmF0aW9uO1xcblxcdFxcdHRoaXMucmVmbGVjdGl2aXR5ID0gMTtcXG5cXHRcXHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XFxuXFxuXFx0XFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcXG5cXG5cXHRcXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7XFxuXFx0XFx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcXG5cXG5cXHRcXHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xcblxcblxcdFxcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XFxuXFxuXFx0fVxcblxcblxcdE1lc2hCYXNpY01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hdGVyaWFsLnByb3RvdHlwZSApO1xcblxcdE1lc2hCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1lc2hCYXNpY01hdGVyaWFsO1xcblxcblxcdE1lc2hCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5pc01lc2hCYXNpY01hdGVyaWFsID0gdHJ1ZTtcXG5cXG5cXHRNZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcblxcblxcdFxcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XFxuXFxuXFx0XFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xcblxcblxcdFxcdHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XFxuXFx0XFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcXG5cXG5cXHRcXHR0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xcblxcdFxcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XFxuXFxuXFx0XFx0dGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcXG5cXG5cXHRcXHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xcblxcblxcdFxcdHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcXG5cXHRcXHR0aGlzLmNvbWJpbmUgPSBzb3VyY2UuY29tYmluZTtcXG5cXHRcXHR0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XFxuXFx0XFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xcblxcblxcdFxcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcXG5cXG5cXHRcXHR0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xcblxcdFxcdHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICpcXG5cXHQgKiBwYXJhbWV0ZXJzID0ge1xcblxcdCAqICBkZWZpbmVzOiB7IFxcXCJsYWJlbFxcXCIgOiBcXFwidmFsdWVcXFwiIH0sXFxuXFx0ICogIHVuaWZvcm1zOiB7IFxcXCJwYXJhbWV0ZXIxXFxcIjogeyB2YWx1ZTogMS4wIH0sIFxcXCJwYXJhbWV0ZXIyXFxcIjogeyB2YWx1ZTI6IDIgfSB9LFxcblxcdCAqXFxuXFx0ICogIGZyYWdtZW50U2hhZGVyOiA8c3RyaW5nPixcXG5cXHQgKiAgdmVydGV4U2hhZGVyOiA8c3RyaW5nPixcXG5cXHQgKlxcblxcdCAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcXG5cXHQgKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxcblxcdCAqXFxuXFx0ICogIGxpZ2h0czogPGJvb2w+LFxcblxcdCAqXFxuXFx0ICogIHNraW5uaW5nOiA8Ym9vbD4sXFxuXFx0ICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxcblxcdCAqICBtb3JwaE5vcm1hbHM6IDxib29sPlxcblxcdCAqIH1cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBTaGFkZXJNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcXG5cXG5cXHRcXHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1NoYWRlck1hdGVyaWFsJztcXG5cXG5cXHRcXHR0aGlzLmRlZmluZXMgPSB7fTtcXG5cXHRcXHR0aGlzLnVuaWZvcm1zID0ge307XFxuXFxuXFx0XFx0dGhpcy52ZXJ0ZXhTaGFkZXIgPSAndm9pZCBtYWluKCkge1xcXFxuXFxcXHRnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxcXG59JztcXG5cXHRcXHR0aGlzLmZyYWdtZW50U2hhZGVyID0gJ3ZvaWQgbWFpbigpIHtcXFxcblxcXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggMS4wLCAwLjAsIDAuMCwgMS4wICk7XFxcXG59JztcXG5cXG5cXHRcXHR0aGlzLmxpbmV3aWR0aCA9IDE7XFxuXFxuXFx0XFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XFxuXFxuXFx0XFx0dGhpcy5mb2cgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBzY2VuZSBmb2dcXG5cXHRcXHR0aGlzLmxpZ2h0cyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHNjZW5lIGxpZ2h0c1xcblxcdFxcdHRoaXMuY2xpcHBpbmcgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSB1c2VyLWRlZmluZWQgY2xpcHBpbmcgcGxhbmVzXFxuXFxuXFx0XFx0dGhpcy5za2lubmluZyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHNraW5uaW5nIGF0dHJpYnV0ZSBzdHJlYW1zXFxuXFx0XFx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBtb3JwaCB0YXJnZXRzXFxuXFx0XFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBtb3JwaCBub3JtYWxzXFxuXFxuXFx0XFx0dGhpcy5leHRlbnNpb25zID0ge1xcblxcdFxcdFxcdGRlcml2YXRpdmVzOiBmYWxzZSwgLy8gc2V0IHRvIHVzZSBkZXJpdmF0aXZlc1xcblxcdFxcdFxcdGZyYWdEZXB0aDogZmFsc2UsIC8vIHNldCB0byB1c2UgZnJhZ21lbnQgZGVwdGggdmFsdWVzXFxuXFx0XFx0XFx0ZHJhd0J1ZmZlcnM6IGZhbHNlLCAvLyBzZXQgdG8gdXNlIGRyYXcgYnVmZmVyc1xcblxcdFxcdFxcdHNoYWRlclRleHR1cmVMT0Q6IGZhbHNlIC8vIHNldCB0byB1c2Ugc2hhZGVyIHRleHR1cmUgTE9EXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBXaGVuIHJlbmRlcmVkIGdlb21ldHJ5IGRvZXNuJ3QgaW5jbHVkZSB0aGVzZSBhdHRyaWJ1dGVzIGJ1dCB0aGUgbWF0ZXJpYWwgZG9lcyxcXG5cXHRcXHQvLyB1c2UgdGhlc2UgZGVmYXVsdCB2YWx1ZXMgaW4gV2ViR0wuIFRoaXMgYXZvaWRzIGVycm9ycyB3aGVuIGJ1ZmZlciBkYXRhIGlzIG1pc3NpbmcuXFxuXFx0XFx0dGhpcy5kZWZhdWx0QXR0cmlidXRlVmFsdWVzID0ge1xcblxcdFxcdFxcdCdjb2xvcic6IFsgMSwgMSwgMSBdLFxcblxcdFxcdFxcdCd1dic6IFsgMCwgMCBdLFxcblxcdFxcdFxcdCd1djInOiBbIDAsIDAgXVxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5pbmRleDBBdHRyaWJ1dGVOYW1lID0gdW5kZWZpbmVkO1xcblxcblxcdFxcdGlmICggcGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdGlmICggcGFyYW1ldGVycy5hdHRyaWJ1dGVzICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlNoYWRlck1hdGVyaWFsOiBhdHRyaWJ1dGVzIHNob3VsZCBub3cgYmUgZGVmaW5lZCBpbiBUSFJFRS5CdWZmZXJHZW9tZXRyeSBpbnN0ZWFkLicgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fVxcblxcblxcdFNoYWRlck1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hdGVyaWFsLnByb3RvdHlwZSApO1xcblxcdFNoYWRlck1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNoYWRlck1hdGVyaWFsO1xcblxcblxcdFNoYWRlck1hdGVyaWFsLnByb3RvdHlwZS5pc1NoYWRlck1hdGVyaWFsID0gdHJ1ZTtcXG5cXG5cXHRTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcblxcblxcdFxcdHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBzb3VyY2UuZnJhZ21lbnRTaGFkZXI7XFxuXFx0XFx0dGhpcy52ZXJ0ZXhTaGFkZXIgPSBzb3VyY2UudmVydGV4U2hhZGVyO1xcblxcblxcdFxcdHRoaXMudW5pZm9ybXMgPSBVbmlmb3Jtc1V0aWxzLmNsb25lKCBzb3VyY2UudW5pZm9ybXMgKTtcXG5cXG5cXHRcXHR0aGlzLmRlZmluZXMgPSBzb3VyY2UuZGVmaW5lcztcXG5cXG5cXHRcXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xcblxcblxcdFxcdHRoaXMubGlnaHRzID0gc291cmNlLmxpZ2h0cztcXG5cXHRcXHR0aGlzLmNsaXBwaW5nID0gc291cmNlLmNsaXBwaW5nO1xcblxcblxcdFxcdHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XFxuXFxuXFx0XFx0dGhpcy5tb3JwaFRhcmdldHMgPSBzb3VyY2UubW9ycGhUYXJnZXRzO1xcblxcdFxcdHRoaXMubW9ycGhOb3JtYWxzID0gc291cmNlLm1vcnBoTm9ybWFscztcXG5cXG5cXHRcXHR0aGlzLmV4dGVuc2lvbnMgPSBzb3VyY2UuZXh0ZW5zaW9ucztcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHR9O1xcblxcblxcdFNoYWRlck1hdGVyaWFsLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIG1ldGEgKSB7XFxuXFxuXFx0XFx0dmFyIGRhdGEgPSBNYXRlcmlhbC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcXG5cXG5cXHRcXHRkYXRhLnVuaWZvcm1zID0gdGhpcy51bmlmb3JtcztcXG5cXHRcXHRkYXRhLnZlcnRleFNoYWRlciA9IHRoaXMudmVydGV4U2hhZGVyO1xcblxcdFxcdGRhdGEuZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmZyYWdtZW50U2hhZGVyO1xcblxcblxcdFxcdHJldHVybiBkYXRhO1xcblxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFJheSggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XFxuXFxuXFx0XFx0dGhpcy5vcmlnaW4gPSAoIG9yaWdpbiAhPT0gdW5kZWZpbmVkICkgPyBvcmlnaW4gOiBuZXcgVmVjdG9yMygpO1xcblxcdFxcdHRoaXMuZGlyZWN0aW9uID0gKCBkaXJlY3Rpb24gIT09IHVuZGVmaW5lZCApID8gZGlyZWN0aW9uIDogbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggUmF5LnByb3RvdHlwZSwge1xcblxcblxcdFxcdHNldDogZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm9yaWdpbi5jb3B5KCBvcmlnaW4gKTtcXG5cXHRcXHRcXHR0aGlzLmRpcmVjdGlvbi5jb3B5KCBkaXJlY3Rpb24gKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCByYXkgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5vcmlnaW4uY29weSggcmF5Lm9yaWdpbiApO1xcblxcdFxcdFxcdHRoaXMuZGlyZWN0aW9uLmNvcHkoIHJheS5kaXJlY3Rpb24gKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGF0OiBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiByZXN1bHQuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy5vcmlnaW4gKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGxvb2tBdDogZnVuY3Rpb24gKCB2ICkge1xcblxcblxcdFxcdFxcdHRoaXMuZGlyZWN0aW9uLmNvcHkoIHYgKS5zdWIoIHRoaXMub3JpZ2luICkubm9ybWFsaXplKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyZWNhc3Q6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiByZWNhc3QoIHQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5vcmlnaW4uY29weSggdGhpcy5hdCggdCwgdjEgKSApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdGNsb3Nlc3RQb2ludFRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdHJlc3VsdC5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5vcmlnaW4gKTtcXG5cXHRcXHRcXHR2YXIgZGlyZWN0aW9uRGlzdGFuY2UgPSByZXN1bHQuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xcblxcblxcdFxcdFxcdGlmICggZGlyZWN0aW9uRGlzdGFuY2UgPCAwICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiByZXN1bHQuY29weSggdGhpcy5vcmlnaW4gKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCBkaXJlY3Rpb25EaXN0YW5jZSApLmFkZCggdGhpcy5vcmlnaW4gKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlU3FUb1BvaW50KCBwb2ludCApICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkaXN0YW5jZVNxVG9Qb2ludDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGRpc3RhbmNlU3FUb1BvaW50KCBwb2ludCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZGlyZWN0aW9uRGlzdGFuY2UgPSB2MS5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5vcmlnaW4gKS5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gcG9pbnQgYmVoaW5kIHRoZSByYXlcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGRpcmVjdGlvbkRpc3RhbmNlIDwgMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5vcmlnaW4uZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHYxLmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIGRpcmVjdGlvbkRpc3RhbmNlICkuYWRkKCB0aGlzLm9yaWdpbiApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB2MS5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRkaXN0YW5jZVNxVG9TZWdtZW50OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHNlZ0NlbnRlciA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0dmFyIHNlZ0RpciA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0dmFyIGRpZmYgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBkaXN0YW5jZVNxVG9TZWdtZW50KCB2MCwgdjEsIG9wdGlvbmFsUG9pbnRPblJheSwgb3B0aW9uYWxQb2ludE9uU2VnbWVudCApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBmcm9tIGh0dHA6Ly93d3cuZ2VvbWV0cmljdG9vbHMuY29tL0dURW5naW5lL0luY2x1ZGUvTWF0aGVtYXRpY3MvR3RlRGlzdFJheVNlZ21lbnQuaFxcblxcdFxcdFxcdFxcdC8vIEl0IHJldHVybnMgdGhlIG1pbiBkaXN0YW5jZSBiZXR3ZWVuIHRoZSByYXkgYW5kIHRoZSBzZWdtZW50XFxuXFx0XFx0XFx0XFx0Ly8gZGVmaW5lZCBieSB2MCBhbmQgdjFcXG5cXHRcXHRcXHRcXHQvLyBJdCBjYW4gYWxzbyBzZXQgdHdvIG9wdGlvbmFsIHRhcmdldHMgOlxcblxcdFxcdFxcdFxcdC8vIC0gVGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIHJheVxcblxcdFxcdFxcdFxcdC8vIC0gVGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIHNlZ21lbnRcXG5cXG5cXHRcXHRcXHRcXHRzZWdDZW50ZXIuY29weSggdjAgKS5hZGQoIHYxICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xcblxcdFxcdFxcdFxcdHNlZ0Rpci5jb3B5KCB2MSApLnN1YiggdjAgKS5ub3JtYWxpemUoKTtcXG5cXHRcXHRcXHRcXHRkaWZmLmNvcHkoIHRoaXMub3JpZ2luICkuc3ViKCBzZWdDZW50ZXIgKTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgc2VnRXh0ZW50ID0gdjAuZGlzdGFuY2VUbyggdjEgKSAqIDAuNTtcXG5cXHRcXHRcXHRcXHR2YXIgYTAxID0gLSB0aGlzLmRpcmVjdGlvbi5kb3QoIHNlZ0RpciApO1xcblxcdFxcdFxcdFxcdHZhciBiMCA9IGRpZmYuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xcblxcdFxcdFxcdFxcdHZhciBiMSA9IC0gZGlmZi5kb3QoIHNlZ0RpciApO1xcblxcdFxcdFxcdFxcdHZhciBjID0gZGlmZi5sZW5ndGhTcSgpO1xcblxcdFxcdFxcdFxcdHZhciBkZXQgPSBNYXRoLmFicyggMSAtIGEwMSAqIGEwMSApO1xcblxcdFxcdFxcdFxcdHZhciBzMCwgczEsIHNxckRpc3QsIGV4dERldDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGRldCA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gVGhlIHJheSBhbmQgc2VnbWVudCBhcmUgbm90IHBhcmFsbGVsLlxcblxcblxcdFxcdFxcdFxcdFxcdHMwID0gYTAxICogYjEgLSBiMDtcXG5cXHRcXHRcXHRcXHRcXHRzMSA9IGEwMSAqIGIwIC0gYjE7XFxuXFx0XFx0XFx0XFx0XFx0ZXh0RGV0ID0gc2VnRXh0ZW50ICogZGV0O1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggczAgPj0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHMxID49IC0gZXh0RGV0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggczEgPD0gZXh0RGV0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHJlZ2lvbiAwXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gTWluaW11bSBhdCBpbnRlcmlvciBwb2ludHMgb2YgcmF5IGFuZCBzZWdtZW50LlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBpbnZEZXQgPSAxIC8gZGV0O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHMwICo9IGludkRldDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzMSAqPSBpbnZEZXQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0c3FyRGlzdCA9IHMwICogKCBzMCArIGEwMSAqIHMxICsgMiAqIGIwICkgKyBzMSAqICggYTAxICogczAgKyBzMSArIDIgKiBiMSApICsgYztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHJlZ2lvbiAxXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0czEgPSBzZWdFeHRlbnQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHMxICsgYjAgKSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gcmVnaW9uIDVcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzMSA9IC0gc2VnRXh0ZW50O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzMSArIGIwICkgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggczEgPD0gLSBleHREZXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gcmVnaW9uIDRcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzMCA9IE1hdGgubWF4KCAwLCAtICggLSBhMDEgKiBzZWdFeHRlbnQgKyBiMCApICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0czEgPSAoIHMwID4gMCApID8gLSBzZWdFeHRlbnQgOiBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICggczEgPD0gZXh0RGV0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHJlZ2lvbiAzXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0czAgPSAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHMxID0gTWF0aC5taW4oIE1hdGgubWF4KCAtIHNlZ0V4dGVudCwgLSBiMSApLCBzZWdFeHRlbnQgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzcXJEaXN0ID0gczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gcmVnaW9uIDJcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogc2VnRXh0ZW50ICsgYjAgKSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHMxID0gKCBzMCA+IDAgKSA/IHNlZ0V4dGVudCA6IE1hdGgubWluKCBNYXRoLm1heCggLSBzZWdFeHRlbnQsIC0gYjEgKSwgc2VnRXh0ZW50ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gUmF5IGFuZCBzZWdtZW50IGFyZSBwYXJhbGxlbC5cXG5cXG5cXHRcXHRcXHRcXHRcXHRzMSA9ICggYTAxID4gMCApID8gLSBzZWdFeHRlbnQgOiBzZWdFeHRlbnQ7XFxuXFx0XFx0XFx0XFx0XFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHMxICsgYjAgKSApO1xcblxcdFxcdFxcdFxcdFxcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggb3B0aW9uYWxQb2ludE9uUmF5ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdG9wdGlvbmFsUG9pbnRPblJheS5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCBzMCApLmFkZCggdGhpcy5vcmlnaW4gKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBvcHRpb25hbFBvaW50T25TZWdtZW50ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdG9wdGlvbmFsUG9pbnRPblNlZ21lbnQuY29weSggc2VnRGlyICkubXVsdGlwbHlTY2FsYXIoIHMxICkuYWRkKCBzZWdDZW50ZXIgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHNxckRpc3Q7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0aW50ZXJzZWN0U3BoZXJlOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0U3BoZXJlKCBzcGhlcmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdFxcdHYxLnN1YlZlY3RvcnMoIHNwaGVyZS5jZW50ZXIsIHRoaXMub3JpZ2luICk7XFxuXFx0XFx0XFx0XFx0dmFyIHRjYSA9IHYxLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcXG5cXHRcXHRcXHRcXHR2YXIgZDIgPSB2MS5kb3QoIHYxICkgLSB0Y2EgKiB0Y2E7XFxuXFx0XFx0XFx0XFx0dmFyIHJhZGl1czIgPSBzcGhlcmUucmFkaXVzICogc3BoZXJlLnJhZGl1cztcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGQyID4gcmFkaXVzMiApIHJldHVybiBudWxsO1xcblxcblxcdFxcdFxcdFxcdHZhciB0aGMgPSBNYXRoLnNxcnQoIHJhZGl1czIgLSBkMiApO1xcblxcblxcdFxcdFxcdFxcdC8vIHQwID0gZmlyc3QgaW50ZXJzZWN0IHBvaW50IC0gZW50cmFuY2Ugb24gZnJvbnQgb2Ygc3BoZXJlXFxuXFx0XFx0XFx0XFx0dmFyIHQwID0gdGNhIC0gdGhjO1xcblxcblxcdFxcdFxcdFxcdC8vIHQxID0gc2Vjb25kIGludGVyc2VjdCBwb2ludCAtIGV4aXQgcG9pbnQgb24gYmFjayBvZiBzcGhlcmVcXG5cXHRcXHRcXHRcXHR2YXIgdDEgPSB0Y2EgKyB0aGM7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdGVzdCB0byBzZWUgaWYgYm90aCB0MCBhbmQgdDEgYXJlIGJlaGluZCB0aGUgcmF5IC0gaWYgc28sIHJldHVybiBudWxsXFxuXFx0XFx0XFx0XFx0aWYgKCB0MCA8IDAgJiYgdDEgPCAwICkgcmV0dXJuIG51bGw7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdGVzdCB0byBzZWUgaWYgdDAgaXMgYmVoaW5kIHRoZSByYXk6XFxuXFx0XFx0XFx0XFx0Ly8gaWYgaXQgaXMsIHRoZSByYXkgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHNvIHJldHVybiB0aGUgc2Vjb25kIGV4aXQgcG9pbnQgc2NhbGVkIGJ5IHQxLFxcblxcdFxcdFxcdFxcdC8vIGluIG9yZGVyIHRvIGFsd2F5cyByZXR1cm4gYW4gaW50ZXJzZWN0IHBvaW50IHRoYXQgaXMgaW4gZnJvbnQgb2YgdGhlIHJheS5cXG5cXHRcXHRcXHRcXHRpZiAoIHQwIDwgMCApIHJldHVybiB0aGlzLmF0KCB0MSwgb3B0aW9uYWxUYXJnZXQgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBlbHNlIHQwIGlzIGluIGZyb250IG9mIHRoZSByYXksIHNvIHJldHVybiB0aGUgZmlyc3QgY29sbGlzaW9uIHBvaW50IHNjYWxlZCBieSB0MFxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmF0KCB0MCwgb3B0aW9uYWxUYXJnZXQgKTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHNwaGVyZS5jZW50ZXIgKSA8PSBzcGhlcmUucmFkaXVzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGlzdGFuY2VUb1BsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xcblxcblxcdFxcdFxcdHZhciBkZW5vbWluYXRvciA9IHBsYW5lLm5vcm1hbC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBkZW5vbWluYXRvciA9PT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBsaW5lIGlzIGNvcGxhbmFyLCByZXR1cm4gb3JpZ2luXFxuXFx0XFx0XFx0XFx0aWYgKCBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMub3JpZ2luICkgPT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIDA7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIE51bGwgaXMgcHJlZmVyYWJsZSB0byB1bmRlZmluZWQgc2luY2UgdW5kZWZpbmVkIG1lYW5zLi4uLiBpdCBpcyB1bmRlZmluZWRcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gbnVsbDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIHQgPSAtICggdGhpcy5vcmlnaW4uZG90KCBwbGFuZS5ub3JtYWwgKSArIHBsYW5lLmNvbnN0YW50ICkgLyBkZW5vbWluYXRvcjtcXG5cXG5cXHRcXHRcXHQvLyBSZXR1cm4gaWYgdGhlIHJheSBuZXZlciBpbnRlcnNlY3RzIHRoZSBwbGFuZVxcblxcblxcdFxcdFxcdHJldHVybiB0ID49IDAgPyB0IDogbnVsbDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGludGVyc2VjdFBsYW5lOiBmdW5jdGlvbiAoIHBsYW5lLCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdCA9IHRoaXMuZGlzdGFuY2VUb1BsYW5lKCBwbGFuZSApO1xcblxcblxcdFxcdFxcdGlmICggdCA9PT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gbnVsbDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuYXQoIHQsIG9wdGlvbmFsVGFyZ2V0ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRpbnRlcnNlY3RzUGxhbmU6IGZ1bmN0aW9uICggcGxhbmUgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gY2hlY2sgaWYgdGhlIHJheSBsaWVzIG9uIHRoZSBwbGFuZSBmaXJzdFxcblxcblxcdFxcdFxcdHZhciBkaXN0VG9Qb2ludCA9IHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggdGhpcy5vcmlnaW4gKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGRpc3RUb1BvaW50ID09PSAwICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgZGVub21pbmF0b3IgPSBwbGFuZS5ub3JtYWwuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xcblxcblxcdFxcdFxcdGlmICggZGVub21pbmF0b3IgKiBkaXN0VG9Qb2ludCA8IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIHJheSBvcmlnaW4gaXMgYmVoaW5kIHRoZSBwbGFuZSAoYW5kIGlzIHBvaW50aW5nIGJlaGluZCBpdClcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRpbnRlcnNlY3RCb3g6IGZ1bmN0aW9uICggYm94LCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdG1pbiwgdG1heCwgdHltaW4sIHR5bWF4LCB0em1pbiwgdHptYXg7XFxuXFxuXFx0XFx0XFx0dmFyIGludmRpcnggPSAxIC8gdGhpcy5kaXJlY3Rpb24ueCxcXG5cXHRcXHRcXHRcXHRpbnZkaXJ5ID0gMSAvIHRoaXMuZGlyZWN0aW9uLnksXFxuXFx0XFx0XFx0XFx0aW52ZGlyeiA9IDEgLyB0aGlzLmRpcmVjdGlvbi56O1xcblxcblxcdFxcdFxcdHZhciBvcmlnaW4gPSB0aGlzLm9yaWdpbjtcXG5cXG5cXHRcXHRcXHRpZiAoIGludmRpcnggPj0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0bWluID0gKCBib3gubWluLnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcXG5cXHRcXHRcXHRcXHR0bWF4ID0gKCBib3gubWF4LnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdHRtaW4gPSAoIGJveC5tYXgueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xcblxcdFxcdFxcdFxcdHRtYXggPSAoIGJveC5taW4ueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGludmRpcnkgPj0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0eW1pbiA9ICggYm94Lm1pbi55IC0gb3JpZ2luLnkgKSAqIGludmRpcnk7XFxuXFx0XFx0XFx0XFx0dHltYXggPSAoIGJveC5tYXgueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0dHltaW4gPSAoIGJveC5tYXgueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xcblxcdFxcdFxcdFxcdHR5bWF4ID0gKCBib3gubWluLnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCAoIHRtaW4gPiB0eW1heCApIHx8ICggdHltaW4gPiB0bWF4ICkgKSByZXR1cm4gbnVsbDtcXG5cXG5cXHRcXHRcXHQvLyBUaGVzZSBsaW5lcyBhbHNvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0bWluIG9yIHRtYXggaXMgTmFOXFxuXFx0XFx0XFx0Ly8gKHJlc3VsdCBvZiAwICogSW5maW5pdHkpLiB4ICE9PSB4IHJldHVybnMgdHJ1ZSBpZiB4IGlzIE5hTlxcblxcblxcdFxcdFxcdGlmICggdHltaW4gPiB0bWluIHx8IHRtaW4gIT09IHRtaW4gKSB0bWluID0gdHltaW47XFxuXFxuXFx0XFx0XFx0aWYgKCB0eW1heCA8IHRtYXggfHwgdG1heCAhPT0gdG1heCApIHRtYXggPSB0eW1heDtcXG5cXG5cXHRcXHRcXHRpZiAoIGludmRpcnogPj0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0em1pbiA9ICggYm94Lm1pbi56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XFxuXFx0XFx0XFx0XFx0dHptYXggPSAoIGJveC5tYXgueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0dHptaW4gPSAoIGJveC5tYXgueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xcblxcdFxcdFxcdFxcdHR6bWF4ID0gKCBib3gubWluLnogLSBvcmlnaW4ueiApICogaW52ZGlyejtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCAoIHRtaW4gPiB0em1heCApIHx8ICggdHptaW4gPiB0bWF4ICkgKSByZXR1cm4gbnVsbDtcXG5cXG5cXHRcXHRcXHRpZiAoIHR6bWluID4gdG1pbiB8fCB0bWluICE9PSB0bWluICkgdG1pbiA9IHR6bWluO1xcblxcblxcdFxcdFxcdGlmICggdHptYXggPCB0bWF4IHx8IHRtYXggIT09IHRtYXggKSB0bWF4ID0gdHptYXg7XFxuXFxuXFx0XFx0XFx0Ly9yZXR1cm4gcG9pbnQgY2xvc2VzdCB0byB0aGUgcmF5IChwb3NpdGl2ZSBzaWRlKVxcblxcblxcdFxcdFxcdGlmICggdG1heCA8IDAgKSByZXR1cm4gbnVsbDtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5hdCggdG1pbiA+PSAwID8gdG1pbiA6IHRtYXgsIG9wdGlvbmFsVGFyZ2V0ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRpbnRlcnNlY3RzQm94OiAoIGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdiA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdHNCb3goIGJveCApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RCb3goIGJveCwgdiApICE9PSBudWxsO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSApKCksXFxuXFxuXFx0XFx0aW50ZXJzZWN0VHJpYW5nbGU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHQvLyBDb21wdXRlIHRoZSBvZmZzZXQgb3JpZ2luLCBlZGdlcywgYW5kIG5vcm1hbC5cXG5cXHRcXHRcXHR2YXIgZGlmZiA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0dmFyIGVkZ2UxID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgZWRnZTIgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdHZhciBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RUcmlhbmdsZSggYSwgYiwgYywgYmFja2ZhY2VDdWxsaW5nLCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBmcm9tIGh0dHA6Ly93d3cuZ2VvbWV0cmljdG9vbHMuY29tL0dURW5naW5lL0luY2x1ZGUvTWF0aGVtYXRpY3MvR3RlSW50clJheTNUcmlhbmdsZTMuaFxcblxcblxcdFxcdFxcdFxcdGVkZ2UxLnN1YlZlY3RvcnMoIGIsIGEgKTtcXG5cXHRcXHRcXHRcXHRlZGdlMi5zdWJWZWN0b3JzKCBjLCBhICk7XFxuXFx0XFx0XFx0XFx0bm9ybWFsLmNyb3NzVmVjdG9ycyggZWRnZTEsIGVkZ2UyICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU29sdmUgUSArIHQqRCA9IGIxKkUxICsgYjIqRTIgKFEgPSBrRGlmZiwgRCA9IHJheSBkaXJlY3Rpb24sXFxuXFx0XFx0XFx0XFx0Ly8gRTEgPSBrRWRnZTEsIEUyID0ga0VkZ2UyLCBOID0gQ3Jvc3MoRTEsRTIpKSBieVxcblxcdFxcdFxcdFxcdC8vICAgfERvdChELE4pfCpiMSA9IHNpZ24oRG90KEQsTikpKkRvdChELENyb3NzKFEsRTIpKVxcblxcdFxcdFxcdFxcdC8vICAgfERvdChELE4pfCpiMiA9IHNpZ24oRG90KEQsTikpKkRvdChELENyb3NzKEUxLFEpKVxcblxcdFxcdFxcdFxcdC8vICAgfERvdChELE4pfCp0ID0gLXNpZ24oRG90KEQsTikpKkRvdChRLE4pXFxuXFx0XFx0XFx0XFx0dmFyIERkTiA9IHRoaXMuZGlyZWN0aW9uLmRvdCggbm9ybWFsICk7XFxuXFx0XFx0XFx0XFx0dmFyIHNpZ247XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBEZE4gPiAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggYmFja2ZhY2VDdWxsaW5nICkgcmV0dXJuIG51bGw7XFxuXFx0XFx0XFx0XFx0XFx0c2lnbiA9IDE7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggRGROIDwgMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzaWduID0gLSAxO1xcblxcdFxcdFxcdFxcdFxcdERkTiA9IC0gRGROO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIG51bGw7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGRpZmYuc3ViVmVjdG9ycyggdGhpcy5vcmlnaW4sIGEgKTtcXG5cXHRcXHRcXHRcXHR2YXIgRGRReEUyID0gc2lnbiAqIHRoaXMuZGlyZWN0aW9uLmRvdCggZWRnZTIuY3Jvc3NWZWN0b3JzKCBkaWZmLCBlZGdlMiApICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gYjEgPCAwLCBubyBpbnRlcnNlY3Rpb25cXG5cXHRcXHRcXHRcXHRpZiAoIERkUXhFMiA8IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIG51bGw7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHZhciBEZEUxeFEgPSBzaWduICogdGhpcy5kaXJlY3Rpb24uZG90KCBlZGdlMS5jcm9zcyggZGlmZiApICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gYjIgPCAwLCBubyBpbnRlcnNlY3Rpb25cXG5cXHRcXHRcXHRcXHRpZiAoIERkRTF4USA8IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIG51bGw7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIGIxK2IyID4gMSwgbm8gaW50ZXJzZWN0aW9uXFxuXFx0XFx0XFx0XFx0aWYgKCBEZFF4RTIgKyBEZEUxeFEgPiBEZE4gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIG51bGw7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIExpbmUgaW50ZXJzZWN0cyB0cmlhbmdsZSwgY2hlY2sgaWYgcmF5IGRvZXMuXFxuXFx0XFx0XFx0XFx0dmFyIFFkTiA9IC0gc2lnbiAqIGRpZmYuZG90KCBub3JtYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyB0IDwgMCwgbm8gaW50ZXJzZWN0aW9uXFxuXFx0XFx0XFx0XFx0aWYgKCBRZE4gPCAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBudWxsO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBSYXkgaW50ZXJzZWN0cyB0cmlhbmdsZS5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5hdCggUWROIC8gRGROLCBvcHRpb25hbFRhcmdldCApO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXg0ICkge1xcblxcblxcdFxcdFxcdHRoaXMub3JpZ2luLmFwcGx5TWF0cml4NCggbWF0cml4NCApO1xcblxcdFxcdFxcdHRoaXMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbiggbWF0cml4NCApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZXF1YWxzOiBmdW5jdGlvbiAoIHJheSApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gcmF5Lm9yaWdpbi5lcXVhbHMoIHRoaXMub3JpZ2luICkgJiYgcmF5LmRpcmVjdGlvbi5lcXVhbHMoIHRoaXMuZGlyZWN0aW9uICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gTGluZTMoIHN0YXJ0LCBlbmQgKSB7XFxuXFxuXFx0XFx0dGhpcy5zdGFydCA9ICggc3RhcnQgIT09IHVuZGVmaW5lZCApID8gc3RhcnQgOiBuZXcgVmVjdG9yMygpO1xcblxcdFxcdHRoaXMuZW5kID0gKCBlbmQgIT09IHVuZGVmaW5lZCApID8gZW5kIDogbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggTGluZTMucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiAoIHN0YXJ0LCBlbmQgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5zdGFydC5jb3B5KCBzdGFydCApO1xcblxcdFxcdFxcdHRoaXMuZW5kLmNvcHkoIGVuZCApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIGxpbmUgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5zdGFydC5jb3B5KCBsaW5lLnN0YXJ0ICk7XFxuXFx0XFx0XFx0dGhpcy5lbmQuY29weSggbGluZS5lbmQgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldENlbnRlcjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0LmFkZFZlY3RvcnMoIHRoaXMuc3RhcnQsIHRoaXMuZW5kICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGVsdGE6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0cmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLmVuZCwgdGhpcy5zdGFydCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGlzdGFuY2VTcTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLnN0YXJ0LmRpc3RhbmNlVG9TcXVhcmVkKCB0aGlzLmVuZCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGlzdGFuY2U6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5zdGFydC5kaXN0YW5jZVRvKCB0aGlzLmVuZCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YXQ6IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZGVsdGEoIHJlc3VsdCApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnN0YXJ0ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHN0YXJ0UCA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0dmFyIHN0YXJ0RW5kID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gY2xvc2VzdFBvaW50VG9Qb2ludFBhcmFtZXRlciggcG9pbnQsIGNsYW1wVG9MaW5lICkge1xcblxcblxcdFxcdFxcdFxcdHN0YXJ0UC5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5zdGFydCApO1xcblxcdFxcdFxcdFxcdHN0YXJ0RW5kLnN1YlZlY3RvcnMoIHRoaXMuZW5kLCB0aGlzLnN0YXJ0ICk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHN0YXJ0RW5kMiA9IHN0YXJ0RW5kLmRvdCggc3RhcnRFbmQgKTtcXG5cXHRcXHRcXHRcXHR2YXIgc3RhcnRFbmRfc3RhcnRQID0gc3RhcnRFbmQuZG90KCBzdGFydFAgKTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdCA9IHN0YXJ0RW5kX3N0YXJ0UCAvIHN0YXJ0RW5kMjtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGNsYW1wVG9MaW5lICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHQgPSBfTWF0aC5jbGFtcCggdCwgMCwgMSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdDtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRjbG9zZXN0UG9pbnRUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBjbGFtcFRvTGluZSwgb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHQgPSB0aGlzLmNsb3Nlc3RQb2ludFRvUG9pbnRQYXJhbWV0ZXIoIHBvaW50LCBjbGFtcFRvTGluZSApO1xcblxcblxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmRlbHRhKCByZXN1bHQgKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy5zdGFydCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnN0YXJ0LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XFxuXFx0XFx0XFx0dGhpcy5lbmQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGVxdWFsczogZnVuY3Rpb24gKCBsaW5lICkge1xcblxcblxcdFxcdFxcdHJldHVybiBsaW5lLnN0YXJ0LmVxdWFscyggdGhpcy5zdGFydCApICYmIGxpbmUuZW5kLmVxdWFscyggdGhpcy5lbmQgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFRyaWFuZ2xlKCBhLCBiLCBjICkge1xcblxcblxcdFxcdHRoaXMuYSA9ICggYSAhPT0gdW5kZWZpbmVkICkgPyBhIDogbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHR0aGlzLmIgPSAoIGIgIT09IHVuZGVmaW5lZCApID8gYiA6IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0dGhpcy5jID0gKCBjICE9PSB1bmRlZmluZWQgKSA/IGMgOiBuZXcgVmVjdG9yMygpO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBUcmlhbmdsZSwge1xcblxcblxcdFxcdG5vcm1hbDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB2MCA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIG5vcm1hbCggYSwgYiwgYywgb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0XFx0cmVzdWx0LnN1YlZlY3RvcnMoIGMsIGIgKTtcXG5cXHRcXHRcXHRcXHR2MC5zdWJWZWN0b3JzKCBhLCBiICk7XFxuXFx0XFx0XFx0XFx0cmVzdWx0LmNyb3NzKCB2MCApO1xcblxcblxcdFxcdFxcdFxcdHZhciByZXN1bHRMZW5ndGhTcSA9IHJlc3VsdC5sZW5ndGhTcSgpO1xcblxcdFxcdFxcdFxcdGlmICggcmVzdWx0TGVuZ3RoU3EgPiAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiByZXN1bHQubXVsdGlwbHlTY2FsYXIoIDEgLyBNYXRoLnNxcnQoIHJlc3VsdExlbmd0aFNxICkgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdC5zZXQoIDAsIDAsIDAgKTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHQvLyBzdGF0aWMvaW5zdGFuY2UgbWV0aG9kIHRvIGNhbGN1bGF0ZSBiYXJ5Y2VudHJpYyBjb29yZGluYXRlc1xcblxcdFxcdC8vIGJhc2VkIG9uOiBodHRwOi8vd3d3LmJsYWNrcGF3bi5jb20vdGV4dHMvcG9pbnRpbnBvbHkvZGVmYXVsdC5odG1sXFxuXFx0XFx0YmFyeWNvb3JkRnJvbVBvaW50OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHYwID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdHZhciB2MiA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGJhcnljb29yZEZyb21Qb2ludCggcG9pbnQsIGEsIGIsIGMsIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdFxcdHYwLnN1YlZlY3RvcnMoIGMsIGEgKTtcXG5cXHRcXHRcXHRcXHR2MS5zdWJWZWN0b3JzKCBiLCBhICk7XFxuXFx0XFx0XFx0XFx0djIuc3ViVmVjdG9ycyggcG9pbnQsIGEgKTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZG90MDAgPSB2MC5kb3QoIHYwICk7XFxuXFx0XFx0XFx0XFx0dmFyIGRvdDAxID0gdjAuZG90KCB2MSApO1xcblxcdFxcdFxcdFxcdHZhciBkb3QwMiA9IHYwLmRvdCggdjIgKTtcXG5cXHRcXHRcXHRcXHR2YXIgZG90MTEgPSB2MS5kb3QoIHYxICk7XFxuXFx0XFx0XFx0XFx0dmFyIGRvdDEyID0gdjEuZG90KCB2MiApO1xcblxcblxcdFxcdFxcdFxcdHZhciBkZW5vbSA9ICggZG90MDAgKiBkb3QxMSAtIGRvdDAxICogZG90MDEgKTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBjb2xsaW5lYXIgb3Igc2luZ3VsYXIgdHJpYW5nbGVcXG5cXHRcXHRcXHRcXHRpZiAoIGRlbm9tID09PSAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGFyYml0cmFyeSBsb2NhdGlvbiBvdXRzaWRlIG9mIHRyaWFuZ2xlP1xcblxcdFxcdFxcdFxcdFxcdC8vIG5vdCBzdXJlIGlmIHRoaXMgaXMgdGhlIGJlc3QgaWRlYSwgbWF5YmUgc2hvdWxkIGJlIHJldHVybmluZyB1bmRlZmluZWRcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0LnNldCggLSAyLCAtIDEsIC0gMSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR2YXIgaW52RGVub20gPSAxIC8gZGVub207XFxuXFx0XFx0XFx0XFx0dmFyIHUgPSAoIGRvdDExICogZG90MDIgLSBkb3QwMSAqIGRvdDEyICkgKiBpbnZEZW5vbTtcXG5cXHRcXHRcXHRcXHR2YXIgdiA9ICggZG90MDAgKiBkb3QxMiAtIGRvdDAxICogZG90MDIgKSAqIGludkRlbm9tO1xcblxcblxcdFxcdFxcdFxcdC8vIGJhcnljZW50cmljIGNvb3JkaW5hdGVzIG11c3QgYWx3YXlzIHN1bSB0byAxXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdC5zZXQoIDEgLSB1IC0gdiwgdiwgdSApO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBjb250YWluc1BvaW50KCBwb2ludCwgYSwgYiwgYyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcmVzdWx0ID0gVHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50KCBwb2ludCwgYSwgYiwgYywgdjEgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gKCByZXN1bHQueCA+PSAwICkgJiYgKCByZXN1bHQueSA+PSAwICkgJiYgKCAoIHJlc3VsdC54ICsgcmVzdWx0LnkgKSA8PSAxICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KClcXG5cXG5cXHR9ICk7XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggVHJpYW5nbGUucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiAoIGEsIGIsIGMgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5hLmNvcHkoIGEgKTtcXG5cXHRcXHRcXHR0aGlzLmIuY29weSggYiApO1xcblxcdFxcdFxcdHRoaXMuYy5jb3B5KCBjICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRGcm9tUG9pbnRzQW5kSW5kaWNlczogZnVuY3Rpb24gKCBwb2ludHMsIGkwLCBpMSwgaTIgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5hLmNvcHkoIHBvaW50c1sgaTAgXSApO1xcblxcdFxcdFxcdHRoaXMuYi5jb3B5KCBwb2ludHNbIGkxIF0gKTtcXG5cXHRcXHRcXHR0aGlzLmMuY29weSggcG9pbnRzWyBpMiBdICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggdHJpYW5nbGUgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5hLmNvcHkoIHRyaWFuZ2xlLmEgKTtcXG5cXHRcXHRcXHR0aGlzLmIuY29weSggdHJpYW5nbGUuYiApO1xcblxcdFxcdFxcdHRoaXMuYy5jb3B5KCB0cmlhbmdsZS5jICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRhcmVhOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHYwID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBhcmVhKCkge1xcblxcblxcdFxcdFxcdFxcdHYwLnN1YlZlY3RvcnMoIHRoaXMuYywgdGhpcy5iICk7XFxuXFx0XFx0XFx0XFx0djEuc3ViVmVjdG9ycyggdGhpcy5hLCB0aGlzLmIgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdjAuY3Jvc3MoIHYxICkubGVuZ3RoKCkgKiAwLjU7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0bWlkcG9pbnQ6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0cmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLmEsIHRoaXMuYiApLmFkZCggdGhpcy5jICkubXVsdGlwbHlTY2FsYXIoIDEgLyAzICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRub3JtYWw6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIFRyaWFuZ2xlLm5vcm1hbCggdGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgb3B0aW9uYWxUYXJnZXQgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHBsYW5lOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgUGxhbmUoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0LnNldEZyb21Db3BsYW5hclBvaW50cyggdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YmFyeWNvb3JkRnJvbVBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gVHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50KCBwb2ludCwgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYywgb3B0aW9uYWxUYXJnZXQgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIFRyaWFuZ2xlLmNvbnRhaW5zUG9pbnQoIHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbG9zZXN0UG9pbnRUb1BvaW50OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHBsYW5lID0gbmV3IFBsYW5lKCk7XFxuXFx0XFx0XFx0dmFyIGVkZ2VMaXN0ID0gWyBuZXcgTGluZTMoKSwgbmV3IExpbmUzKCksIG5ldyBMaW5lMygpIF07XFxuXFx0XFx0XFx0dmFyIHByb2plY3RlZFBvaW50ID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgY2xvc2VzdFBvaW50ID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gY2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdFxcdHZhciBtaW5EaXN0YW5jZSA9IEluZmluaXR5O1xcblxcblxcdFxcdFxcdFxcdC8vIHByb2plY3QgdGhlIHBvaW50IG9udG8gdGhlIHBsYW5lIG9mIHRoZSB0cmlhbmdsZVxcblxcblxcdFxcdFxcdFxcdHBsYW5lLnNldEZyb21Db3BsYW5hclBvaW50cyggdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyApO1xcblxcdFxcdFxcdFxcdHBsYW5lLnByb2plY3RQb2ludCggcG9pbnQsIHByb2plY3RlZFBvaW50ICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gY2hlY2sgaWYgdGhlIHByb2plY3Rpb24gbGllcyB3aXRoaW4gdGhlIHRyaWFuZ2xlXFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB0aGlzLmNvbnRhaW5zUG9pbnQoIHByb2plY3RlZFBvaW50ICkgPT09IHRydWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gaWYgc28sIHRoaXMgaXMgdGhlIGNsb3Nlc3QgcG9pbnRcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXN1bHQuY29weSggcHJvamVjdGVkUG9pbnQgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGlmIG5vdCwgdGhlIHBvaW50IGZhbGxzIG91dHNpZGUgdGhlIHRyaWFuZ2xlLiB0aGUgcmVzdWx0IGlzIHRoZSBjbG9zZXN0IHBvaW50IHRvIHRoZSB0cmlhbmdsZSdzIGVkZ2VzIG9yIHZlcnRpY2VzXFxuXFxuXFx0XFx0XFx0XFx0XFx0ZWRnZUxpc3RbIDAgXS5zZXQoIHRoaXMuYSwgdGhpcy5iICk7XFxuXFx0XFx0XFx0XFx0XFx0ZWRnZUxpc3RbIDEgXS5zZXQoIHRoaXMuYiwgdGhpcy5jICk7XFxuXFx0XFx0XFx0XFx0XFx0ZWRnZUxpc3RbIDIgXS5zZXQoIHRoaXMuYywgdGhpcy5hICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZWRnZUxpc3QubGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGVkZ2VMaXN0WyBpIF0uY2xvc2VzdFBvaW50VG9Qb2ludCggcHJvamVjdGVkUG9pbnQsIHRydWUsIGNsb3Nlc3RQb2ludCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBkaXN0YW5jZSA9IHByb2plY3RlZFBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKCBjbG9zZXN0UG9pbnQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGRpc3RhbmNlIDwgbWluRGlzdGFuY2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXN1bHQuY29weSggY2xvc2VzdFBvaW50ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdDtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRlcXVhbHM6IGZ1bmN0aW9uICggdHJpYW5nbGUgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRyaWFuZ2xlLmEuZXF1YWxzKCB0aGlzLmEgKSAmJiB0cmlhbmdsZS5iLmVxdWFscyggdGhpcy5iICkgJiYgdHJpYW5nbGUuYy5lcXVhbHMoIHRoaXMuYyApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXFxuXFx0ICogQGF1dGhvciBqb25vYnIxIC8gaHR0cDovL2pvbm9icjEuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ01lc2gnO1xcblxcblxcdFxcdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkID8gZ2VvbWV0cnkgOiBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcXG5cXHRcXHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsIDogbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYgfSApO1xcblxcblxcdFxcdHRoaXMuZHJhd01vZGUgPSBUcmlhbmdsZXNEcmF3TW9kZTtcXG5cXG5cXHRcXHR0aGlzLnVwZGF0ZU1vcnBoVGFyZ2V0cygpO1xcblxcblxcdH1cXG5cXG5cXHRNZXNoLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IE1lc2gsXFxuXFxuXFx0XFx0aXNNZXNoOiB0cnVlLFxcblxcblxcdFxcdHNldERyYXdNb2RlOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdHRoaXMuZHJhd01vZGUgPSB2YWx1ZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdFxcdE9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcblxcblxcdFxcdFxcdHRoaXMuZHJhd01vZGUgPSBzb3VyY2UuZHJhd01vZGU7XFxuXFxuXFx0XFx0XFx0aWYgKCBzb3VyY2UubW9ycGhUYXJnZXRJbmZsdWVuY2VzICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBzb3VyY2UubW9ycGhUYXJnZXRJbmZsdWVuY2VzLnNsaWNlKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggc291cmNlLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0gT2JqZWN0LmFzc2lnbigge30sIHNvdXJjZS5tb3JwaFRhcmdldERpY3Rpb25hcnkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR1cGRhdGVNb3JwaFRhcmdldHM6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xcblxcdFxcdFxcdHZhciBtLCBtbCwgbmFtZTtcXG5cXG5cXHRcXHRcXHRpZiAoIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG1vcnBoQXR0cmlidXRlcyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcztcXG5cXHRcXHRcXHRcXHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKCBtb3JwaEF0dHJpYnV0ZXMgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGtleXMubGVuZ3RoID4gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZXNbIGtleXNbIDAgXSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggbW9ycGhBdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IFtdO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0ge307XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggbSA9IDAsIG1sID0gbW9ycGhBdHRyaWJ1dGUubGVuZ3RoOyBtIDwgbWw7IG0gKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bmFtZSA9IG1vcnBoQXR0cmlidXRlWyBtIF0ubmFtZSB8fCBTdHJpbmcoIG0gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5wdXNoKCAwICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIG5hbWUgXSA9IG07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xcblxcblxcdFxcdFxcdFxcdGlmICggbW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgJiYgbW9ycGhUYXJnZXRzLmxlbmd0aCA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBbXTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSA9IHt9O1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIG0gPSAwLCBtbCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gPCBtbDsgbSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRuYW1lID0gbW9ycGhUYXJnZXRzWyBtIF0ubmFtZSB8fCBTdHJpbmcoIG0gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5wdXNoKCAwICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIG5hbWUgXSA9IG07XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyYXljYXN0OiAoIGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgaW52ZXJzZU1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XFxuXFx0XFx0XFx0dmFyIHJheSA9IG5ldyBSYXkoKTtcXG5cXHRcXHRcXHR2YXIgc3BoZXJlID0gbmV3IFNwaGVyZSgpO1xcblxcblxcdFxcdFxcdHZhciB2QSA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0dmFyIHZCID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgdkMgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHZhciB0ZW1wQSA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0dmFyIHRlbXBCID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgdGVtcEMgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHZhciB1dkEgPSBuZXcgVmVjdG9yMigpO1xcblxcdFxcdFxcdHZhciB1dkIgPSBuZXcgVmVjdG9yMigpO1xcblxcdFxcdFxcdHZhciB1dkMgPSBuZXcgVmVjdG9yMigpO1xcblxcblxcdFxcdFxcdHZhciBiYXJ5Y29vcmQgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHZhciBpbnRlcnNlY3Rpb25Qb2ludCA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0dmFyIGludGVyc2VjdGlvblBvaW50V29ybGQgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdGZ1bmN0aW9uIHV2SW50ZXJzZWN0aW9uKCBwb2ludCwgcDEsIHAyLCBwMywgdXYxLCB1djIsIHV2MyApIHtcXG5cXG5cXHRcXHRcXHRcXHRUcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQoIHBvaW50LCBwMSwgcDIsIHAzLCBiYXJ5Y29vcmQgKTtcXG5cXG5cXHRcXHRcXHRcXHR1djEubXVsdGlwbHlTY2FsYXIoIGJhcnljb29yZC54ICk7XFxuXFx0XFx0XFx0XFx0dXYyLm11bHRpcGx5U2NhbGFyKCBiYXJ5Y29vcmQueSApO1xcblxcdFxcdFxcdFxcdHV2My5tdWx0aXBseVNjYWxhciggYmFyeWNvb3JkLnogKTtcXG5cXG5cXHRcXHRcXHRcXHR1djEuYWRkKCB1djIgKS5hZGQoIHV2MyApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB1djEuY2xvbmUoKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gY2hlY2tJbnRlcnNlY3Rpb24oIG9iamVjdCwgbWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5LCBwQSwgcEIsIHBDLCBwb2ludCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgaW50ZXJzZWN0O1xcblxcblxcdFxcdFxcdFxcdGlmICggbWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aW50ZXJzZWN0ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCBwQywgcEIsIHBBLCB0cnVlLCBwb2ludCApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aW50ZXJzZWN0ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCBwQSwgcEIsIHBDLCBtYXRlcmlhbC5zaWRlICE9PSBEb3VibGVTaWRlLCBwb2ludCApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGludGVyc2VjdCA9PT0gbnVsbCApIHJldHVybiBudWxsO1xcblxcblxcdFxcdFxcdFxcdGludGVyc2VjdGlvblBvaW50V29ybGQuY29weSggcG9pbnQgKTtcXG5cXHRcXHRcXHRcXHRpbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJzZWN0aW9uUG9pbnRXb3JsZCApO1xcblxcblxcdFxcdFxcdFxcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSByZXR1cm4gbnVsbDtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdFxcdFxcdGRpc3RhbmNlOiBkaXN0YW5jZSxcXG5cXHRcXHRcXHRcXHRcXHRwb2ludDogaW50ZXJzZWN0aW9uUG9pbnRXb3JsZC5jbG9uZSgpLFxcblxcdFxcdFxcdFxcdFxcdG9iamVjdDogb2JqZWN0XFxuXFx0XFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gY2hlY2tCdWZmZXJHZW9tZXRyeUludGVyc2VjdGlvbiggb2JqZWN0LCByYXljYXN0ZXIsIHJheSwgcG9zaXRpb24sIHV2LCBhLCBiLCBjICkge1xcblxcblxcdFxcdFxcdFxcdHZBLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBhICk7XFxuXFx0XFx0XFx0XFx0dkIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGIgKTtcXG5cXHRcXHRcXHRcXHR2Qy5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgYyApO1xcblxcblxcdFxcdFxcdFxcdHZhciBpbnRlcnNlY3Rpb24gPSBjaGVja0ludGVyc2VjdGlvbiggb2JqZWN0LCBvYmplY3QubWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5LCB2QSwgdkIsIHZDLCBpbnRlcnNlY3Rpb25Qb2ludCApO1xcblxcblxcdFxcdFxcdFxcdGlmICggaW50ZXJzZWN0aW9uICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggdXYgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dXZBLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2LCBhICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dXZCLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2LCBiICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dXZDLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2LCBjICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aW50ZXJzZWN0aW9uLnV2ID0gdXZJbnRlcnNlY3Rpb24oIGludGVyc2VjdGlvblBvaW50LCB2QSwgdkIsIHZDLCB1dkEsIHV2QiwgdXZDICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGludGVyc2VjdGlvbi5mYWNlID0gbmV3IEZhY2UzKCBhLCBiLCBjLCBUcmlhbmdsZS5ub3JtYWwoIHZBLCB2QiwgdkMgKSApO1xcblxcdFxcdFxcdFxcdFxcdGludGVyc2VjdGlvbi5mYWNlSW5kZXggPSBhO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gaW50ZXJzZWN0aW9uO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XFxuXFx0XFx0XFx0XFx0dmFyIG1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcXG5cXHRcXHRcXHRcXHR2YXIgbWF0cml4V29ybGQgPSB0aGlzLm1hdHJpeFdvcmxkO1xcblxcblxcdFxcdFxcdFxcdGlmICggbWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIHJldHVybjtcXG5cXG5cXHRcXHRcXHRcXHQvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZSBkaXN0YW5jZSB0byByYXlcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XFxuXFxuXFx0XFx0XFx0XFx0c3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XFxuXFx0XFx0XFx0XFx0c3BoZXJlLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHJheWNhc3Rlci5yYXkuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkgPT09IGZhbHNlICkgcmV0dXJuO1xcblxcblxcdFxcdFxcdFxcdC8vXFxuXFxuXFx0XFx0XFx0XFx0aW52ZXJzZU1hdHJpeC5nZXRJbnZlcnNlKCBtYXRyaXhXb3JsZCApO1xcblxcdFxcdFxcdFxcdHJheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBpbnZlcnNlTWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2hlY2sgYm91bmRpbmdCb3ggYmVmb3JlIGNvbnRpbnVpbmdcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggcmF5LmludGVyc2VjdHNCb3goIGdlb21ldHJ5LmJvdW5kaW5nQm94ICkgPT09IGZhbHNlICkgcmV0dXJuO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR2YXIgaW50ZXJzZWN0aW9uO1xcblxcblxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgYSwgYiwgYztcXG5cXHRcXHRcXHRcXHRcXHR2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xcblxcdFxcdFxcdFxcdFxcdHZhciB1diA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMudXY7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGksIGw7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBpbmRleGVkIGJ1ZmZlciBnZW9tZXRyeVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIGkgPSAwLCBsID0gaW5kZXguY291bnQ7IGkgPCBsOyBpICs9IDMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YSA9IGluZGV4LmdldFgoIGkgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRiID0gaW5kZXguZ2V0WCggaSArIDEgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjID0gaW5kZXguZ2V0WCggaSArIDIgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpbnRlcnNlY3Rpb24gPSBjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uKCB0aGlzLCByYXljYXN0ZXIsIHJheSwgcG9zaXRpb24sIHV2LCBhLCBiLCBjICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBpbnRlcnNlY3Rpb24gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IE1hdGguZmxvb3IoIGkgLyAzICk7IC8vIHRyaWFuZ2xlIG51bWJlciBpbiBpbmRpY2VzIGJ1ZmZlciBzZW1hbnRpY3NcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpbnRlcnNlY3RzLnB1c2goIGludGVyc2VjdGlvbiApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICggcG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBub24taW5kZXhlZCBidWZmZXIgZ2VvbWV0cnlcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCBpID0gMCwgbCA9IHBvc2l0aW9uLmNvdW50OyBpIDwgbDsgaSArPSAzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGEgPSBpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGIgPSBpICsgMTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjID0gaSArIDI7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aW50ZXJzZWN0aW9uID0gY2hlY2tCdWZmZXJHZW9tZXRyeUludGVyc2VjdGlvbiggdGhpcywgcmF5Y2FzdGVyLCByYXksIHBvc2l0aW9uLCB1diwgYSwgYiwgYyApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggaW50ZXJzZWN0aW9uICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGludGVyc2VjdGlvbi5pbmRleCA9IGE7IC8vIHRyaWFuZ2xlIG51bWJlciBpbiBwb3NpdGlvbnMgYnVmZmVyIHNlbWFudGljc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0aW9uICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggZ2VvbWV0cnkuaXNHZW9tZXRyeSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgZnZBLCBmdkIsIGZ2QztcXG5cXHRcXHRcXHRcXHRcXHR2YXIgaXNNdWx0aU1hdGVyaWFsID0gQXJyYXkuaXNBcnJheSggbWF0ZXJpYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcXG5cXHRcXHRcXHRcXHRcXHR2YXIgZmFjZXMgPSBnZW9tZXRyeS5mYWNlcztcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdXZzO1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBmYWNlVmVydGV4VXZzID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgMCBdO1xcblxcdFxcdFxcdFxcdFxcdGlmICggZmFjZVZlcnRleFV2cy5sZW5ndGggPiAwICkgdXZzID0gZmFjZVZlcnRleFV2cztcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgZiA9IDAsIGZsID0gZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGZhY2UgPSBmYWNlc1sgZiBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBmYWNlTWF0ZXJpYWwgPSBpc011bHRpTWF0ZXJpYWwgPyBtYXRlcmlhbFsgZmFjZS5tYXRlcmlhbEluZGV4IF0gOiBtYXRlcmlhbDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGZhY2VNYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZnZBID0gdmVydGljZXNbIGZhY2UuYSBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdGZ2QiA9IHZlcnRpY2VzWyBmYWNlLmIgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmdkMgPSB2ZXJ0aWNlc1sgZmFjZS5jIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBmYWNlTWF0ZXJpYWwubW9ycGhUYXJnZXRzID09PSB0cnVlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBtb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIG1vcnBoSW5mbHVlbmNlcyA9IHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZBLnNldCggMCwgMCwgMCApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZCLnNldCggMCwgMCwgMCApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZDLnNldCggMCwgMCwgMCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciB0ID0gMCwgdGwgPSBtb3JwaFRhcmdldHMubGVuZ3RoOyB0IDwgdGw7IHQgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGluZmx1ZW5jZSA9IG1vcnBoSW5mbHVlbmNlc1sgdCBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggaW5mbHVlbmNlID09PSAwICkgY29udGludWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIHRhcmdldHMgPSBtb3JwaFRhcmdldHNbIHQgXS52ZXJ0aWNlcztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR2QS5hZGRTY2FsZWRWZWN0b3IoIHRlbXBBLnN1YlZlY3RvcnMoIHRhcmdldHNbIGZhY2UuYSBdLCBmdkEgKSwgaW5mbHVlbmNlICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dkIuYWRkU2NhbGVkVmVjdG9yKCB0ZW1wQi5zdWJWZWN0b3JzKCB0YXJnZXRzWyBmYWNlLmIgXSwgZnZCICksIGluZmx1ZW5jZSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHZDLmFkZFNjYWxlZFZlY3RvciggdGVtcEMuc3ViVmVjdG9ycyggdGFyZ2V0c1sgZmFjZS5jIF0sIGZ2QyApLCBpbmZsdWVuY2UgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dkEuYWRkKCBmdkEgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2Qi5hZGQoIGZ2QiApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZDLmFkZCggZnZDICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZnZBID0gdkE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZnZCID0gdkI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZnZDID0gdkM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGludGVyc2VjdGlvbiA9IGNoZWNrSW50ZXJzZWN0aW9uKCB0aGlzLCBmYWNlTWF0ZXJpYWwsIHJheWNhc3RlciwgcmF5LCBmdkEsIGZ2QiwgZnZDLCBpbnRlcnNlY3Rpb25Qb2ludCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggaW50ZXJzZWN0aW9uICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggdXZzICYmIHV2c1sgZiBdICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciB1dnNfZiA9IHV2c1sgZiBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHV2QS5jb3B5KCB1dnNfZlsgMCBdICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dXZCLmNvcHkoIHV2c19mWyAxIF0gKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR1dkMuY29weSggdXZzX2ZbIDIgXSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGludGVyc2VjdGlvbi51diA9IHV2SW50ZXJzZWN0aW9uKCBpbnRlcnNlY3Rpb25Qb2ludCwgZnZBLCBmdkIsIGZ2QywgdXZBLCB1dkIsIHV2QyApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpbnRlcnNlY3Rpb24uZmFjZSA9IGZhY2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IGY7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3Rpb24gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSApLFxcblxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICkuY29weSggdGhpcyApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBXZWJHTEJhY2tncm91bmQoIHJlbmRlcmVyLCBzdGF0ZSwgZ2VvbWV0cmllcywgcHJlbXVsdGlwbGllZEFscGhhICkge1xcblxcblxcdFxcdHZhciBjbGVhckNvbG9yID0gbmV3IENvbG9yKCAweDAwMDAwMCApO1xcblxcdFxcdHZhciBjbGVhckFscGhhID0gMDtcXG5cXG5cXHRcXHR2YXIgcGxhbmVDYW1lcmEsIHBsYW5lTWVzaDtcXG5cXHRcXHR2YXIgYm94TWVzaDtcXG5cXG5cXHRcXHRmdW5jdGlvbiByZW5kZXIoIHJlbmRlckxpc3QsIHNjZW5lLCBjYW1lcmEsIGZvcmNlQ2xlYXIgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGJhY2tncm91bmQgPSBzY2VuZS5iYWNrZ3JvdW5kO1xcblxcblxcdFxcdFxcdGlmICggYmFja2dyb3VuZCA9PT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRzZXRDbGVhciggY2xlYXJDb2xvciwgY2xlYXJBbHBoYSApO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGJhY2tncm91bmQgJiYgYmFja2dyb3VuZC5pc0NvbG9yICkge1xcblxcblxcdFxcdFxcdFxcdHNldENsZWFyKCBiYWNrZ3JvdW5kLCAxICk7XFxuXFx0XFx0XFx0XFx0Zm9yY2VDbGVhciA9IHRydWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggcmVuZGVyZXIuYXV0b0NsZWFyIHx8IGZvcmNlQ2xlYXIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmVuZGVyZXIuY2xlYXIoIHJlbmRlcmVyLmF1dG9DbGVhckNvbG9yLCByZW5kZXJlci5hdXRvQ2xlYXJEZXB0aCwgcmVuZGVyZXIuYXV0b0NsZWFyU3RlbmNpbCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGJhY2tncm91bmQgJiYgYmFja2dyb3VuZC5pc0N1YmVUZXh0dXJlICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggYm94TWVzaCA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGJveE1lc2ggPSBuZXcgTWVzaChcXG5cXHRcXHRcXHRcXHRcXHRcXHRuZXcgQm94QnVmZmVyR2VvbWV0cnkoIDEsIDEsIDEgKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRuZXcgU2hhZGVyTWF0ZXJpYWwoIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR1bmlmb3JtczogU2hhZGVyTGliLmN1YmUudW5pZm9ybXMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmVydGV4U2hhZGVyOiBTaGFkZXJMaWIuY3ViZS52ZXJ0ZXhTaGFkZXIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckxpYi5jdWJlLmZyYWdtZW50U2hhZGVyLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNpZGU6IEJhY2tTaWRlLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRlcHRoVGVzdDogdHJ1ZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkZXB0aFdyaXRlOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb2c6IGZhbHNlXFxuXFx0XFx0XFx0XFx0XFx0XFx0fSApXFxuXFx0XFx0XFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRib3hNZXNoLmdlb21ldHJ5LnJlbW92ZUF0dHJpYnV0ZSggJ25vcm1hbCcgKTtcXG5cXHRcXHRcXHRcXHRcXHRib3hNZXNoLmdlb21ldHJ5LnJlbW92ZUF0dHJpYnV0ZSggJ3V2JyApO1xcblxcblxcdFxcdFxcdFxcdFxcdGJveE1lc2gub25CZWZvcmVSZW5kZXIgPSBmdW5jdGlvbiAoIHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMubWF0cml4V29ybGQuY29weVBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdFxcdFxcdGdlb21ldHJpZXMudXBkYXRlKCBib3hNZXNoLmdlb21ldHJ5ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGJveE1lc2gubWF0ZXJpYWwudW5pZm9ybXMudEN1YmUudmFsdWUgPSBiYWNrZ3JvdW5kO1xcblxcblxcdFxcdFxcdFxcdHJlbmRlckxpc3QucHVzaCggYm94TWVzaCwgYm94TWVzaC5nZW9tZXRyeSwgYm94TWVzaC5tYXRlcmlhbCwgMCwgbnVsbCApO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGJhY2tncm91bmQgJiYgYmFja2dyb3VuZC5pc1RleHR1cmUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBwbGFuZUNhbWVyYSA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHBsYW5lQ2FtZXJhID0gbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYSggLSAxLCAxLCAxLCAtIDEsIDAsIDEgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRwbGFuZU1lc2ggPSBuZXcgTWVzaChcXG5cXHRcXHRcXHRcXHRcXHRcXHRuZXcgUGxhbmVCdWZmZXJHZW9tZXRyeSggMiwgMiApLFxcblxcdFxcdFxcdFxcdFxcdFxcdG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyBkZXB0aFRlc3Q6IGZhbHNlLCBkZXB0aFdyaXRlOiBmYWxzZSwgZm9nOiBmYWxzZSB9IClcXG5cXHRcXHRcXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdFxcdFxcdGdlb21ldHJpZXMudXBkYXRlKCBwbGFuZU1lc2guZ2VvbWV0cnkgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cGxhbmVNZXNoLm1hdGVyaWFsLm1hcCA9IGJhY2tncm91bmQ7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gVE9ETyBQdXNoIHRoaXMgdG8gcmVuZGVyTGlzdFxcblxcblxcdFxcdFxcdFxcdHJlbmRlcmVyLnJlbmRlckJ1ZmZlckRpcmVjdCggcGxhbmVDYW1lcmEsIG51bGwsIHBsYW5lTWVzaC5nZW9tZXRyeSwgcGxhbmVNZXNoLm1hdGVyaWFsLCBwbGFuZU1lc2gsIG51bGwgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHNldENsZWFyKCBjb2xvciwgYWxwaGEgKSB7XFxuXFxuXFx0XFx0XFx0c3RhdGUuYnVmZmVycy5jb2xvci5zZXRDbGVhciggY29sb3IuciwgY29sb3IuZywgY29sb3IuYiwgYWxwaGEsIHByZW11bHRpcGxpZWRBbHBoYSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4ge1xcblxcblxcdFxcdFxcdGdldENsZWFyQ29sb3I6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gY2xlYXJDb2xvcjtcXG5cXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdHNldENsZWFyQ29sb3I6IGZ1bmN0aW9uICggY29sb3IsIGFscGhhICkge1xcblxcblxcdFxcdFxcdFxcdGNsZWFyQ29sb3Iuc2V0KCBjb2xvciApO1xcblxcdFxcdFxcdFxcdGNsZWFyQWxwaGEgPSBhbHBoYSAhPT0gdW5kZWZpbmVkID8gYWxwaGEgOiAxO1xcblxcdFxcdFxcdFxcdHNldENsZWFyKCBjbGVhckNvbG9yLCBjbGVhckFscGhhICk7XFxuXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRnZXRDbGVhckFscGhhOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNsZWFyQWxwaGE7XFxuXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRzZXRDbGVhckFscGhhOiBmdW5jdGlvbiAoIGFscGhhICkge1xcblxcblxcdFxcdFxcdFxcdGNsZWFyQWxwaGEgPSBhbHBoYTtcXG5cXHRcXHRcXHRcXHRzZXRDbGVhciggY2xlYXJDb2xvciwgY2xlYXJBbHBoYSApO1xcblxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0cmVuZGVyOiByZW5kZXJcXG5cXG5cXHRcXHR9O1xcblxcblxcdH1cXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIHBhaW50ZXJTb3J0U3RhYmxlKCBhLCBiICkge1xcblxcblxcdFxcdGlmICggYS5yZW5kZXJPcmRlciAhPT0gYi5yZW5kZXJPcmRlciApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gYS5yZW5kZXJPcmRlciAtIGIucmVuZGVyT3JkZXI7XFxuXFxuXFx0XFx0fSBlbHNlIGlmICggYS5wcm9ncmFtICYmIGIucHJvZ3JhbSAmJiBhLnByb2dyYW0gIT09IGIucHJvZ3JhbSApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gYS5wcm9ncmFtLmlkIC0gYi5wcm9ncmFtLmlkO1xcblxcblxcdFxcdH0gZWxzZSBpZiAoIGEubWF0ZXJpYWwuaWQgIT09IGIubWF0ZXJpYWwuaWQgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGEubWF0ZXJpYWwuaWQgLSBiLm1hdGVyaWFsLmlkO1xcblxcblxcdFxcdH0gZWxzZSBpZiAoIGEueiAhPT0gYi56ICkge1xcblxcblxcdFxcdFxcdHJldHVybiBhLnogLSBiLno7XFxuXFxuXFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gYS5pZCAtIGIuaWQ7XFxuXFxuXFx0XFx0fVxcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiByZXZlcnNlUGFpbnRlclNvcnRTdGFibGUoIGEsIGIgKSB7XFxuXFxuXFx0XFx0aWYgKCBhLnJlbmRlck9yZGVyICE9PSBiLnJlbmRlck9yZGVyICkge1xcblxcblxcdFxcdFxcdHJldHVybiBhLnJlbmRlck9yZGVyIC0gYi5yZW5kZXJPcmRlcjtcXG5cXG5cXHRcXHR9IGlmICggYS56ICE9PSBiLnogKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGIueiAtIGEuejtcXG5cXG5cXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdHJldHVybiBhLmlkIC0gYi5pZDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIFdlYkdMUmVuZGVyTGlzdCgpIHtcXG5cXG5cXHRcXHR2YXIgcmVuZGVySXRlbXMgPSBbXTtcXG5cXHRcXHR2YXIgcmVuZGVySXRlbXNJbmRleCA9IDA7XFxuXFxuXFx0XFx0dmFyIG9wYXF1ZSA9IFtdO1xcblxcdFxcdHZhciB0cmFuc3BhcmVudCA9IFtdO1xcblxcblxcdFxcdGZ1bmN0aW9uIGluaXQoKSB7XFxuXFxuXFx0XFx0XFx0cmVuZGVySXRlbXNJbmRleCA9IDA7XFxuXFxuXFx0XFx0XFx0b3BhcXVlLmxlbmd0aCA9IDA7XFxuXFx0XFx0XFx0dHJhbnNwYXJlbnQubGVuZ3RoID0gMDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gcHVzaCggb2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHosIGdyb3VwICkge1xcblxcblxcdFxcdFxcdHZhciByZW5kZXJJdGVtID0gcmVuZGVySXRlbXNbIHJlbmRlckl0ZW1zSW5kZXggXTtcXG5cXG5cXHRcXHRcXHRpZiAoIHJlbmRlckl0ZW0gPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZW5kZXJJdGVtID0ge1xcblxcdFxcdFxcdFxcdFxcdGlkOiBvYmplY3QuaWQsXFxuXFx0XFx0XFx0XFx0XFx0b2JqZWN0OiBvYmplY3QsXFxuXFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnk6IGdlb21ldHJ5LFxcblxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsOiBtYXRlcmlhbCxcXG5cXHRcXHRcXHRcXHRcXHRwcm9ncmFtOiBtYXRlcmlhbC5wcm9ncmFtLFxcblxcdFxcdFxcdFxcdFxcdHJlbmRlck9yZGVyOiBvYmplY3QucmVuZGVyT3JkZXIsXFxuXFx0XFx0XFx0XFx0XFx0ejogeixcXG5cXHRcXHRcXHRcXHRcXHRncm91cDogZ3JvdXBcXG5cXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdFxcdHJlbmRlckl0ZW1zWyByZW5kZXJJdGVtc0luZGV4IF0gPSByZW5kZXJJdGVtO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0cmVuZGVySXRlbS5pZCA9IG9iamVjdC5pZDtcXG5cXHRcXHRcXHRcXHRyZW5kZXJJdGVtLm9iamVjdCA9IG9iamVjdDtcXG5cXHRcXHRcXHRcXHRyZW5kZXJJdGVtLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XFxuXFx0XFx0XFx0XFx0cmVuZGVySXRlbS5tYXRlcmlhbCA9IG1hdGVyaWFsO1xcblxcdFxcdFxcdFxcdHJlbmRlckl0ZW0ucHJvZ3JhbSA9IG1hdGVyaWFsLnByb2dyYW07XFxuXFx0XFx0XFx0XFx0cmVuZGVySXRlbS5yZW5kZXJPcmRlciA9IG9iamVjdC5yZW5kZXJPcmRlcjtcXG5cXHRcXHRcXHRcXHRyZW5kZXJJdGVtLnogPSB6O1xcblxcdFxcdFxcdFxcdHJlbmRlckl0ZW0uZ3JvdXAgPSBncm91cDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0KCBtYXRlcmlhbC50cmFuc3BhcmVudCA9PT0gdHJ1ZSA/IHRyYW5zcGFyZW50IDogb3BhcXVlICkucHVzaCggcmVuZGVySXRlbSApO1xcblxcblxcdFxcdFxcdHJlbmRlckl0ZW1zSW5kZXggKys7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHNvcnQoKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBvcGFxdWUubGVuZ3RoID4gMSApIG9wYXF1ZS5zb3J0KCBwYWludGVyU29ydFN0YWJsZSApO1xcblxcdFxcdFxcdGlmICggdHJhbnNwYXJlbnQubGVuZ3RoID4gMSApIHRyYW5zcGFyZW50LnNvcnQoIHJldmVyc2VQYWludGVyU29ydFN0YWJsZSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdG9wYXF1ZTogb3BhcXVlLFxcblxcdFxcdFxcdHRyYW5zcGFyZW50OiB0cmFuc3BhcmVudCxcXG5cXG5cXHRcXHRcXHRpbml0OiBpbml0LFxcblxcdFxcdFxcdHB1c2g6IHB1c2gsXFxuXFxuXFx0XFx0XFx0c29ydDogc29ydFxcblxcdFxcdH07XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIFdlYkdMUmVuZGVyTGlzdHMoKSB7XFxuXFxuXFx0XFx0dmFyIGxpc3RzID0ge307XFxuXFxuXFx0XFx0ZnVuY3Rpb24gZ2V0KCBzY2VuZSwgY2FtZXJhICkge1xcblxcblxcdFxcdFxcdHZhciBoYXNoID0gc2NlbmUuaWQgKyAnLCcgKyBjYW1lcmEuaWQ7XFxuXFx0XFx0XFx0dmFyIGxpc3QgPSBsaXN0c1sgaGFzaCBdO1xcblxcblxcdFxcdFxcdGlmICggbGlzdCA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuV2ViR0xSZW5kZXJMaXN0czonLCBoYXNoICk7XFxuXFxuXFx0XFx0XFx0XFx0bGlzdCA9IG5ldyBXZWJHTFJlbmRlckxpc3QoKTtcXG5cXHRcXHRcXHRcXHRsaXN0c1sgaGFzaCBdID0gbGlzdDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGxpc3Q7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XFxuXFxuXFx0XFx0XFx0bGlzdHMgPSB7fTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHRnZXQ6IGdldCxcXG5cXHRcXHRcXHRkaXNwb3NlOiBkaXNwb3NlXFxuXFx0XFx0fTtcXG5cXG5cXHR9XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBhYnNOdW1lcmljYWxTb3J0KCBhLCBiICkge1xcblxcblxcdFxcdHJldHVybiBNYXRoLmFicyggYlsgMSBdICkgLSBNYXRoLmFicyggYVsgMSBdICk7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIFdlYkdMTW9ycGh0YXJnZXRzKCBnbCApIHtcXG5cXG5cXHRcXHR2YXIgaW5mbHVlbmNlc0xpc3QgPSB7fTtcXG5cXHRcXHR2YXIgbW9ycGhJbmZsdWVuY2VzID0gbmV3IEZsb2F0MzJBcnJheSggOCApO1xcblxcblxcdFxcdGZ1bmN0aW9uIHVwZGF0ZSggb2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHByb2dyYW0gKSB7XFxuXFxuXFx0XFx0XFx0dmFyIG9iamVjdEluZmx1ZW5jZXMgPSBvYmplY3QubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xcblxcblxcdFxcdFxcdHZhciBsZW5ndGggPSBvYmplY3RJbmZsdWVuY2VzLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHR2YXIgaW5mbHVlbmNlcyA9IGluZmx1ZW5jZXNMaXN0WyBnZW9tZXRyeS5pZCBdO1xcblxcblxcdFxcdFxcdGlmICggaW5mbHVlbmNlcyA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdC8vIGluaXRpYWxpc2UgbGlzdFxcblxcblxcdFxcdFxcdFxcdGluZmx1ZW5jZXMgPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aW5mbHVlbmNlc1sgaSBdID0gWyBpLCAwIF07XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGluZmx1ZW5jZXNMaXN0WyBnZW9tZXRyeS5pZCBdID0gaW5mbHVlbmNlcztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIG1vcnBoVGFyZ2V0cyA9IG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyAmJiBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb247XFxuXFx0XFx0XFx0dmFyIG1vcnBoTm9ybWFscyA9IG1hdGVyaWFsLm1vcnBoTm9ybWFscyAmJiBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMubm9ybWFsO1xcblxcblxcdFxcdFxcdC8vIFJlbW92ZSBjdXJyZW50IG1vcnBoQXR0cmlidXRlc1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgaW5mbHVlbmNlID0gaW5mbHVlbmNlc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdGlmICggaW5mbHVlbmNlWyAxIF0gIT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBtb3JwaFRhcmdldHMgKSBnZW9tZXRyeS5yZW1vdmVBdHRyaWJ1dGUoICdtb3JwaFRhcmdldCcgKyBpICk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBtb3JwaE5vcm1hbHMgKSBnZW9tZXRyeS5yZW1vdmVBdHRyaWJ1dGUoICdtb3JwaE5vcm1hbCcgKyBpICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDb2xsZWN0IGluZmx1ZW5jZXNcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGluZmx1ZW5jZSA9IGluZmx1ZW5jZXNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRpbmZsdWVuY2VbIDAgXSA9IGk7XFxuXFx0XFx0XFx0XFx0aW5mbHVlbmNlWyAxIF0gPSBvYmplY3RJbmZsdWVuY2VzWyBpIF07XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGluZmx1ZW5jZXMuc29ydCggYWJzTnVtZXJpY2FsU29ydCApO1xcblxcblxcdFxcdFxcdC8vIEFkZCBtb3JwaEF0dHJpYnV0ZXNcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA4OyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBpbmZsdWVuY2UgPSBpbmZsdWVuY2VzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBpbmZsdWVuY2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGluZGV4ID0gaW5mbHVlbmNlWyAwIF07XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHZhbHVlID0gaW5mbHVlbmNlWyAxIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG1vcnBoVGFyZ2V0cyApIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ21vcnBoVGFyZ2V0JyArIGksIG1vcnBoVGFyZ2V0c1sgaW5kZXggXSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggbW9ycGhOb3JtYWxzICkgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnbW9ycGhOb3JtYWwnICsgaSwgbW9ycGhOb3JtYWxzWyBpbmRleCBdICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0bW9ycGhJbmZsdWVuY2VzWyBpIF0gPSB2YWx1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdG1vcnBoSW5mbHVlbmNlc1sgaSBdID0gMDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cHJvZ3JhbS5nZXRVbmlmb3JtcygpLnNldFZhbHVlKCBnbCwgJ21vcnBoVGFyZ2V0SW5mbHVlbmNlcycsIG1vcnBoSW5mbHVlbmNlcyApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4ge1xcblxcblxcdFxcdFxcdHVwZGF0ZTogdXBkYXRlXFxuXFxuXFx0XFx0fTtcXG5cXG5cXHR9XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBXZWJHTEluZGV4ZWRCdWZmZXJSZW5kZXJlciggZ2wsIGV4dGVuc2lvbnMsIGluZm9SZW5kZXIgKSB7XFxuXFxuXFx0XFx0dmFyIG1vZGU7XFxuXFxuXFx0XFx0ZnVuY3Rpb24gc2V0TW9kZSggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0bW9kZSA9IHZhbHVlO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR2YXIgdHlwZSwgYnl0ZXNQZXJFbGVtZW50O1xcblxcblxcdFxcdGZ1bmN0aW9uIHNldEluZGV4KCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHR0eXBlID0gdmFsdWUudHlwZTtcXG5cXHRcXHRcXHRieXRlc1BlckVsZW1lbnQgPSB2YWx1ZS5ieXRlc1BlckVsZW1lbnQ7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHJlbmRlciggc3RhcnQsIGNvdW50ICkge1xcblxcblxcdFxcdFxcdGdsLmRyYXdFbGVtZW50cyggbW9kZSwgY291bnQsIHR5cGUsIHN0YXJ0ICogYnl0ZXNQZXJFbGVtZW50ICk7XFxuXFxuXFx0XFx0XFx0aW5mb1JlbmRlci5jYWxscyArKztcXG5cXHRcXHRcXHRpbmZvUmVuZGVyLnZlcnRpY2VzICs9IGNvdW50O1xcblxcblxcdFxcdFxcdGlmICggbW9kZSA9PT0gZ2wuVFJJQU5HTEVTICkgaW5mb1JlbmRlci5mYWNlcyArPSBjb3VudCAvIDM7XFxuXFx0XFx0XFx0ZWxzZSBpZiAoIG1vZGUgPT09IGdsLlBPSU5UUyApIGluZm9SZW5kZXIucG9pbnRzICs9IGNvdW50O1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiByZW5kZXJJbnN0YW5jZXMoIGdlb21ldHJ5LCBzdGFydCwgY291bnQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xJbmRleGVkQnVmZmVyUmVuZGVyZXI6IHVzaW5nIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGV4dGVuc2lvbi5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRSggbW9kZSwgY291bnQsIHR5cGUsIHN0YXJ0ICogYnl0ZXNQZXJFbGVtZW50LCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCApO1xcblxcblxcdFxcdFxcdGluZm9SZW5kZXIuY2FsbHMgKys7XFxuXFx0XFx0XFx0aW5mb1JlbmRlci52ZXJ0aWNlcyArPSBjb3VudCAqIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50O1xcblxcblxcdFxcdFxcdGlmICggbW9kZSA9PT0gZ2wuVFJJQU5HTEVTICkgaW5mb1JlbmRlci5mYWNlcyArPSBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCAqIGNvdW50IC8gMztcXG5cXHRcXHRcXHRlbHNlIGlmICggbW9kZSA9PT0gZ2wuUE9JTlRTICkgaW5mb1JlbmRlci5wb2ludHMgKz0gZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKiBjb3VudDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly9cXG5cXG5cXHRcXHR0aGlzLnNldE1vZGUgPSBzZXRNb2RlO1xcblxcdFxcdHRoaXMuc2V0SW5kZXggPSBzZXRJbmRleDtcXG5cXHRcXHR0aGlzLnJlbmRlciA9IHJlbmRlcjtcXG5cXHRcXHR0aGlzLnJlbmRlckluc3RhbmNlcyA9IHJlbmRlckluc3RhbmNlcztcXG5cXG5cXHR9XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBXZWJHTEJ1ZmZlclJlbmRlcmVyKCBnbCwgZXh0ZW5zaW9ucywgaW5mb1JlbmRlciApIHtcXG5cXG5cXHRcXHR2YXIgbW9kZTtcXG5cXG5cXHRcXHRmdW5jdGlvbiBzZXRNb2RlKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRtb2RlID0gdmFsdWU7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHJlbmRlciggc3RhcnQsIGNvdW50ICkge1xcblxcblxcdFxcdFxcdGdsLmRyYXdBcnJheXMoIG1vZGUsIHN0YXJ0LCBjb3VudCApO1xcblxcblxcdFxcdFxcdGluZm9SZW5kZXIuY2FsbHMgKys7XFxuXFx0XFx0XFx0aW5mb1JlbmRlci52ZXJ0aWNlcyArPSBjb3VudDtcXG5cXG5cXHRcXHRcXHRpZiAoIG1vZGUgPT09IGdsLlRSSUFOR0xFUyApIGluZm9SZW5kZXIuZmFjZXMgKz0gY291bnQgLyAzO1xcblxcdFxcdFxcdGVsc2UgaWYgKCBtb2RlID09PSBnbC5QT0lOVFMgKSBpbmZvUmVuZGVyLnBvaW50cyArPSBjb3VudDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gcmVuZGVySW5zdGFuY2VzKCBnZW9tZXRyeSwgc3RhcnQsIGNvdW50ICkge1xcblxcblxcdFxcdFxcdHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMQnVmZmVyUmVuZGVyZXI6IHVzaW5nIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XFxuXFxuXFx0XFx0XFx0aWYgKCBwb3NpdGlvbi5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xcblxcblxcdFxcdFxcdFxcdGNvdW50ID0gcG9zaXRpb24uZGF0YS5jb3VudDtcXG5cXG5cXHRcXHRcXHRcXHRleHRlbnNpb24uZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKCBtb2RlLCAwLCBjb3VudCwgZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdGV4dGVuc2lvbi5kcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUoIG1vZGUsIHN0YXJ0LCBjb3VudCwgZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aW5mb1JlbmRlci5jYWxscyArKztcXG5cXHRcXHRcXHRpbmZvUmVuZGVyLnZlcnRpY2VzICs9IGNvdW50ICogZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQ7XFxuXFxuXFx0XFx0XFx0aWYgKCBtb2RlID09PSBnbC5UUklBTkdMRVMgKSBpbmZvUmVuZGVyLmZhY2VzICs9IGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICogY291bnQgLyAzO1xcblxcdFxcdFxcdGVsc2UgaWYgKCBtb2RlID09PSBnbC5QT0lOVFMgKSBpbmZvUmVuZGVyLnBvaW50cyArPSBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCAqIGNvdW50O1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvL1xcblxcblxcdFxcdHRoaXMuc2V0TW9kZSA9IHNldE1vZGU7XFxuXFx0XFx0dGhpcy5yZW5kZXIgPSByZW5kZXI7XFxuXFx0XFx0dGhpcy5yZW5kZXJJbnN0YW5jZXMgPSByZW5kZXJJbnN0YW5jZXM7XFxuXFxuXFx0fVxcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gV2ViR0xHZW9tZXRyaWVzKCBnbCwgYXR0cmlidXRlcywgaW5mb01lbW9yeSApIHtcXG5cXG5cXHRcXHR2YXIgZ2VvbWV0cmllcyA9IHt9O1xcblxcdFxcdHZhciB3aXJlZnJhbWVBdHRyaWJ1dGVzID0ge307XFxuXFxuXFx0XFx0ZnVuY3Rpb24gb25HZW9tZXRyeURpc3Bvc2UoIGV2ZW50ICkge1xcblxcblxcdFxcdFxcdHZhciBnZW9tZXRyeSA9IGV2ZW50LnRhcmdldDtcXG5cXHRcXHRcXHR2YXIgYnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xcblxcblxcdFxcdFxcdGlmICggYnVmZmVyZ2VvbWV0cnkuaW5kZXggIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0YXR0cmlidXRlcy5yZW1vdmUoIGJ1ZmZlcmdlb21ldHJ5LmluZGV4ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGZvciAoIHZhciBuYW1lIGluIGJ1ZmZlcmdlb21ldHJ5LmF0dHJpYnV0ZXMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0YXR0cmlidXRlcy5yZW1vdmUoIGJ1ZmZlcmdlb21ldHJ5LmF0dHJpYnV0ZXNbIG5hbWUgXSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRnZW9tZXRyeS5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uR2VvbWV0cnlEaXNwb3NlICk7XFxuXFxuXFx0XFx0XFx0ZGVsZXRlIGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF07XFxuXFxuXFx0XFx0XFx0Ly8gVE9ETyBSZW1vdmUgZHVwbGljYXRlIGNvZGVcXG5cXG5cXHRcXHRcXHR2YXIgYXR0cmlidXRlID0gd2lyZWZyYW1lQXR0cmlidXRlc1sgZ2VvbWV0cnkuaWQgXTtcXG5cXG5cXHRcXHRcXHRpZiAoIGF0dHJpYnV0ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRhdHRyaWJ1dGVzLnJlbW92ZSggYXR0cmlidXRlICk7XFxuXFx0XFx0XFx0XFx0ZGVsZXRlIHdpcmVmcmFtZUF0dHJpYnV0ZXNbIGdlb21ldHJ5LmlkIF07XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGF0dHJpYnV0ZSA9IHdpcmVmcmFtZUF0dHJpYnV0ZXNbIGJ1ZmZlcmdlb21ldHJ5LmlkIF07XFxuXFxuXFx0XFx0XFx0aWYgKCBhdHRyaWJ1dGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0YXR0cmlidXRlcy5yZW1vdmUoIGF0dHJpYnV0ZSApO1xcblxcdFxcdFxcdFxcdGRlbGV0ZSB3aXJlZnJhbWVBdHRyaWJ1dGVzWyBidWZmZXJnZW9tZXRyeS5pZCBdO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvL1xcblxcblxcdFxcdFxcdGluZm9NZW1vcnkuZ2VvbWV0cmllcyAtLTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gZ2V0KCBvYmplY3QsIGdlb21ldHJ5ICkge1xcblxcblxcdFxcdFxcdHZhciBidWZmZXJnZW9tZXRyeSA9IGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF07XFxuXFxuXFx0XFx0XFx0aWYgKCBidWZmZXJnZW9tZXRyeSApIHJldHVybiBidWZmZXJnZW9tZXRyeTtcXG5cXG5cXHRcXHRcXHRnZW9tZXRyeS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uR2VvbWV0cnlEaXNwb3NlICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkge1xcblxcblxcdFxcdFxcdFxcdGJ1ZmZlcmdlb21ldHJ5ID0gZ2VvbWV0cnk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggZ2VvbWV0cnkuaXNHZW9tZXRyeSApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJ5Ll9idWZmZXJHZW9tZXRyeSA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5Ll9idWZmZXJHZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpLnNldEZyb21PYmplY3QoIG9iamVjdCApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRidWZmZXJnZW9tZXRyeSA9IGdlb21ldHJ5Ll9idWZmZXJHZW9tZXRyeTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Z2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXSA9IGJ1ZmZlcmdlb21ldHJ5O1xcblxcblxcdFxcdFxcdGluZm9NZW1vcnkuZ2VvbWV0cmllcyArKztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gYnVmZmVyZ2VvbWV0cnk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHVwZGF0ZSggZ2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XFxuXFx0XFx0XFx0dmFyIGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XFxuXFxuXFx0XFx0XFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRhdHRyaWJ1dGVzLnVwZGF0ZSggaW5kZXgsIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGZvciAoIHZhciBuYW1lIGluIGdlb21ldHJ5QXR0cmlidXRlcyApIHtcXG5cXG5cXHRcXHRcXHRcXHRhdHRyaWJ1dGVzLnVwZGF0ZSggZ2VvbWV0cnlBdHRyaWJ1dGVzWyBuYW1lIF0sIGdsLkFSUkFZX0JVRkZFUiApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBtb3JwaCB0YXJnZXRzXFxuXFxuXFx0XFx0XFx0dmFyIG1vcnBoQXR0cmlidXRlcyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcztcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgbmFtZSBpbiBtb3JwaEF0dHJpYnV0ZXMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGFycmF5ID0gbW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF07XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRhdHRyaWJ1dGVzLnVwZGF0ZSggYXJyYXlbIGkgXSwgZ2wuQVJSQVlfQlVGRkVSICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gZ2V0V2lyZWZyYW1lQXR0cmlidXRlKCBnZW9tZXRyeSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYXR0cmlidXRlID0gd2lyZWZyYW1lQXR0cmlidXRlc1sgZ2VvbWV0cnkuaWQgXTtcXG5cXG5cXHRcXHRcXHRpZiAoIGF0dHJpYnV0ZSApIHJldHVybiBhdHRyaWJ1dGU7XFxuXFxuXFx0XFx0XFx0dmFyIGluZGljZXMgPSBbXTtcXG5cXG5cXHRcXHRcXHR2YXIgZ2VvbWV0cnlJbmRleCA9IGdlb21ldHJ5LmluZGV4O1xcblxcdFxcdFxcdHZhciBnZW9tZXRyeUF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xcblxcblxcdFxcdFxcdC8vIGNvbnNvbGUudGltZSggJ3dpcmVmcmFtZScgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGdlb21ldHJ5SW5kZXggIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGFycmF5ID0gZ2VvbWV0cnlJbmRleC5hcnJheTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpICs9IDMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGEgPSBhcnJheVsgaSArIDAgXTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgYiA9IGFycmF5WyBpICsgMSBdO1xcblxcdFxcdFxcdFxcdFxcdHZhciBjID0gYXJyYXlbIGkgKyAyIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBiLCBjLCBjLCBhICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGFycmF5ID0gZ2VvbWV0cnlBdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9ICggYXJyYXkubGVuZ3RoIC8gMyApIC0gMTsgaSA8IGw7IGkgKz0gMyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgYSA9IGkgKyAwO1xcblxcdFxcdFxcdFxcdFxcdHZhciBiID0gaSArIDE7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGMgPSBpICsgMjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpbmRpY2VzLnB1c2goIGEsIGIsIGIsIGMsIGMsIGEgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGNvbnNvbGUudGltZUVuZCggJ3dpcmVmcmFtZScgKTtcXG5cXG5cXHRcXHRcXHRhdHRyaWJ1dGUgPSBuZXcgKCBhcnJheU1heCggaW5kaWNlcyApID4gNjU1MzUgPyBVaW50MzJCdWZmZXJBdHRyaWJ1dGUgOiBVaW50MTZCdWZmZXJBdHRyaWJ1dGUgKSggaW5kaWNlcywgMSApO1xcblxcblxcdFxcdFxcdGF0dHJpYnV0ZXMudXBkYXRlKCBhdHRyaWJ1dGUsIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSICk7XFxuXFxuXFx0XFx0XFx0d2lyZWZyYW1lQXR0cmlidXRlc1sgZ2VvbWV0cnkuaWQgXSA9IGF0dHJpYnV0ZTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gYXR0cmlidXRlO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4ge1xcblxcblxcdFxcdFxcdGdldDogZ2V0LFxcblxcdFxcdFxcdHVwZGF0ZTogdXBkYXRlLFxcblxcblxcdFxcdFxcdGdldFdpcmVmcmFtZUF0dHJpYnV0ZTogZ2V0V2lyZWZyYW1lQXR0cmlidXRlXFxuXFxuXFx0XFx0fTtcXG5cXG5cXHR9XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBVbmlmb3Jtc0NhY2hlKCkge1xcblxcblxcdFxcdHZhciBsaWdodHMgPSB7fTtcXG5cXG5cXHRcXHRyZXR1cm4ge1xcblxcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCBsaWdodCApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGxpZ2h0c1sgbGlnaHQuaWQgXSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBsaWdodHNbIGxpZ2h0LmlkIF07XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHZhciB1bmlmb3JtcztcXG5cXG5cXHRcXHRcXHRcXHRzd2l0Y2ggKCBsaWdodC50eXBlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ0RpcmVjdGlvbmFsTGlnaHQnOlxcblxcdFxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zID0ge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRpcmVjdGlvbjogbmV3IFZlY3RvcjMoKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb2xvcjogbmV3IENvbG9yKCksXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2hhZG93OiBmYWxzZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzaGFkb3dCaWFzOiAwLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNoYWRvd1JhZGl1czogMSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzaGFkb3dNYXBTaXplOiBuZXcgVmVjdG9yMigpXFxuXFx0XFx0XFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdTcG90TGlnaHQnOlxcblxcdFxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zID0ge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uOiBuZXcgVmVjdG9yMygpLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRpcmVjdGlvbjogbmV3IFZlY3RvcjMoKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb2xvcjogbmV3IENvbG9yKCksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGlzdGFuY2U6IDAsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29uZUNvczogMCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwZW51bWJyYUNvczogMCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkZWNheTogMCxcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzaGFkb3c6IGZhbHNlLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNoYWRvd0JpYXM6IDAsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2hhZG93UmFkaXVzOiAxLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNoYWRvd01hcFNpemU6IG5ldyBWZWN0b3IyKClcXG5cXHRcXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ1BvaW50TGlnaHQnOlxcblxcdFxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zID0ge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uOiBuZXcgVmVjdG9yMygpLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbG9yOiBuZXcgQ29sb3IoKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkaXN0YW5jZTogMCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkZWNheTogMCxcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzaGFkb3c6IGZhbHNlLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNoYWRvd0JpYXM6IDAsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2hhZG93UmFkaXVzOiAxLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNoYWRvd01hcFNpemU6IG5ldyBWZWN0b3IyKCksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2hhZG93Q2FtZXJhTmVhcjogMSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzaGFkb3dDYW1lcmFGYXI6IDEwMDBcXG5cXHRcXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ0hlbWlzcGhlcmVMaWdodCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMgPSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGlyZWN0aW9uOiBuZXcgVmVjdG9yMygpLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNreUNvbG9yOiBuZXcgQ29sb3IoKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRncm91bmRDb2xvcjogbmV3IENvbG9yKClcXG5cXHRcXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ1JlY3RBcmVhTGlnaHQnOlxcblxcdFxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zID0ge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbG9yOiBuZXcgQ29sb3IoKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwb3NpdGlvbjogbmV3IFZlY3RvcjMoKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRoYWxmV2lkdGg6IG5ldyBWZWN0b3IzKCksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aGFsZkhlaWdodDogbmV3IFZlY3RvcjMoKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFRPRE8gKGFiZWxuYXRpb24pOiBzZXQgUmVjdEFyZWFMaWdodCBzaGFkb3cgdW5pZm9ybXNcXG5cXHRcXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRsaWdodHNbIGxpZ2h0LmlkIF0gPSB1bmlmb3JtcztcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdW5pZm9ybXM7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH07XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIFdlYkdMTGlnaHRzKCkge1xcblxcblxcdFxcdHZhciBjYWNoZSA9IG5ldyBVbmlmb3Jtc0NhY2hlKCk7XFxuXFxuXFx0XFx0dmFyIHN0YXRlID0ge1xcblxcblxcdFxcdFxcdGhhc2g6ICcnLFxcblxcblxcdFxcdFxcdGFtYmllbnQ6IFsgMCwgMCwgMCBdLFxcblxcdFxcdFxcdGRpcmVjdGlvbmFsOiBbXSxcXG5cXHRcXHRcXHRkaXJlY3Rpb25hbFNoYWRvd01hcDogW10sXFxuXFx0XFx0XFx0ZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXg6IFtdLFxcblxcdFxcdFxcdHNwb3Q6IFtdLFxcblxcdFxcdFxcdHNwb3RTaGFkb3dNYXA6IFtdLFxcblxcdFxcdFxcdHNwb3RTaGFkb3dNYXRyaXg6IFtdLFxcblxcdFxcdFxcdHJlY3RBcmVhOiBbXSxcXG5cXHRcXHRcXHRwb2ludDogW10sXFxuXFx0XFx0XFx0cG9pbnRTaGFkb3dNYXA6IFtdLFxcblxcdFxcdFxcdHBvaW50U2hhZG93TWF0cml4OiBbXSxcXG5cXHRcXHRcXHRoZW1pOiBbXVxcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dmFyIHZlY3RvcjMgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdHZhciBtYXRyaXg0ID0gbmV3IE1hdHJpeDQoKTtcXG5cXHRcXHR2YXIgbWF0cml4NDIgPSBuZXcgTWF0cml4NCgpO1xcblxcblxcdFxcdGZ1bmN0aW9uIHNldHVwKCBsaWdodHMsIHNoYWRvd3MsIGNhbWVyYSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgciA9IDAsIGcgPSAwLCBiID0gMDtcXG5cXG5cXHRcXHRcXHR2YXIgZGlyZWN0aW9uYWxMZW5ndGggPSAwO1xcblxcdFxcdFxcdHZhciBwb2ludExlbmd0aCA9IDA7XFxuXFx0XFx0XFx0dmFyIHNwb3RMZW5ndGggPSAwO1xcblxcdFxcdFxcdHZhciByZWN0QXJlYUxlbmd0aCA9IDA7XFxuXFx0XFx0XFx0dmFyIGhlbWlMZW5ndGggPSAwO1xcblxcblxcdFxcdFxcdHZhciB2aWV3TWF0cml4ID0gY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBsaWdodHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbGlnaHQgPSBsaWdodHNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgY29sb3IgPSBsaWdodC5jb2xvcjtcXG5cXHRcXHRcXHRcXHR2YXIgaW50ZW5zaXR5ID0gbGlnaHQuaW50ZW5zaXR5O1xcblxcdFxcdFxcdFxcdHZhciBkaXN0YW5jZSA9IGxpZ2h0LmRpc3RhbmNlO1xcblxcblxcdFxcdFxcdFxcdHZhciBzaGFkb3dNYXAgPSAoIGxpZ2h0LnNoYWRvdyAmJiBsaWdodC5zaGFkb3cubWFwICkgPyBsaWdodC5zaGFkb3cubWFwLnRleHR1cmUgOiBudWxsO1xcblxcblxcdFxcdFxcdFxcdGlmICggbGlnaHQuaXNBbWJpZW50TGlnaHQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ciArPSBjb2xvci5yICogaW50ZW5zaXR5O1xcblxcdFxcdFxcdFxcdFxcdGcgKz0gY29sb3IuZyAqIGludGVuc2l0eTtcXG5cXHRcXHRcXHRcXHRcXHRiICs9IGNvbG9yLmIgKiBpbnRlbnNpdHk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggbGlnaHQuaXNEaXJlY3Rpb25hbExpZ2h0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciB1bmlmb3JtcyA9IGNhY2hlLmdldCggbGlnaHQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5jb2xvci5jb3B5KCBsaWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCBsaWdodC5pbnRlbnNpdHkgKTtcXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaXJlY3Rpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xcblxcdFxcdFxcdFxcdFxcdHZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaXJlY3Rpb24uc3ViKCB2ZWN0b3IzICk7XFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbiggdmlld01hdHJpeCApO1xcblxcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLnNoYWRvdyA9IGxpZ2h0LmNhc3RTaGFkb3c7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBsaWdodC5jYXN0U2hhZG93ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBzaGFkb3cgPSBsaWdodC5zaGFkb3c7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuc2hhZG93QmlhcyA9IHNoYWRvdy5iaWFzO1xcblxcdFxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLnNoYWRvd1JhZGl1cyA9IHNoYWRvdy5yYWRpdXM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuc2hhZG93TWFwU2l6ZSA9IHNoYWRvdy5tYXBTaXplO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS5kaXJlY3Rpb25hbFNoYWRvd01hcFsgZGlyZWN0aW9uYWxMZW5ndGggXSA9IHNoYWRvd01hcDtcXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS5kaXJlY3Rpb25hbFNoYWRvd01hdHJpeFsgZGlyZWN0aW9uYWxMZW5ndGggXSA9IGxpZ2h0LnNoYWRvdy5tYXRyaXg7XFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUuZGlyZWN0aW9uYWxbIGRpcmVjdGlvbmFsTGVuZ3RoIF0gPSB1bmlmb3JtcztcXG5cXG5cXHRcXHRcXHRcXHRcXHRkaXJlY3Rpb25hbExlbmd0aCArKztcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBsaWdodC5pc1Nwb3RMaWdodCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgdW5pZm9ybXMgPSBjYWNoZS5nZXQoIGxpZ2h0ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLnBvc2l0aW9uLmFwcGx5TWF0cml4NCggdmlld01hdHJpeCApO1xcblxcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLmNvbG9yLmNvcHkoIGNvbG9yICkubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSApO1xcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpc3RhbmNlID0gZGlzdGFuY2U7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcXG5cXHRcXHRcXHRcXHRcXHR2ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlyZWN0aW9uLnN1YiggdmVjdG9yMyApO1xcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24oIHZpZXdNYXRyaXggKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5jb25lQ29zID0gTWF0aC5jb3MoIGxpZ2h0LmFuZ2xlICk7XFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMucGVudW1icmFDb3MgPSBNYXRoLmNvcyggbGlnaHQuYW5nbGUgKiAoIDEgLSBsaWdodC5wZW51bWJyYSApICk7XFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuZGVjYXkgPSAoIGxpZ2h0LmRpc3RhbmNlID09PSAwICkgPyAwLjAgOiBsaWdodC5kZWNheTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5zaGFkb3cgPSBsaWdodC5jYXN0U2hhZG93O1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggbGlnaHQuY2FzdFNoYWRvdyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgc2hhZG93ID0gbGlnaHQuc2hhZG93O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLnNoYWRvd0JpYXMgPSBzaGFkb3cuYmlhcztcXG5cXHRcXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5zaGFkb3dSYWRpdXMgPSBzaGFkb3cucmFkaXVzO1xcblxcdFxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLnNoYWRvd01hcFNpemUgPSBzaGFkb3cubWFwU2l6ZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUuc3BvdFNoYWRvd01hcFsgc3BvdExlbmd0aCBdID0gc2hhZG93TWFwO1xcblxcdFxcdFxcdFxcdFxcdHN0YXRlLnNwb3RTaGFkb3dNYXRyaXhbIHNwb3RMZW5ndGggXSA9IGxpZ2h0LnNoYWRvdy5tYXRyaXg7XFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUuc3BvdFsgc3BvdExlbmd0aCBdID0gdW5pZm9ybXM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0c3BvdExlbmd0aCArKztcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBsaWdodC5pc1JlY3RBcmVhTGlnaHQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHVuaWZvcm1zID0gY2FjaGUuZ2V0KCBsaWdodCApO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIChhKSBpbnRlbnNpdHkgY29udHJvbHMgaXJyYWRpYW5jZSBvZiBlbnRpcmUgbGlnaHRcXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5jb2xvclxcblxcdFxcdFxcdFxcdFxcdFxcdC5jb3B5KCBjb2xvciApXFxuXFx0XFx0XFx0XFx0XFx0XFx0Lm11bHRpcGx5U2NhbGFyKCBpbnRlbnNpdHkgLyAoIGxpZ2h0LndpZHRoICogbGlnaHQuaGVpZ2h0ICkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyAoYikgaW50ZW5zaXR5IGNvbnRyb2xzIHRoZSByYWRpYW5jZSBwZXIgbGlnaHQgYXJlYVxcblxcdFxcdFxcdFxcdFxcdC8vIHVuaWZvcm1zLmNvbG9yLmNvcHkoIGNvbG9yICkubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSApO1xcblxcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5wb3NpdGlvbi5hcHBseU1hdHJpeDQoIHZpZXdNYXRyaXggKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBleHRyYWN0IGxvY2FsIHJvdGF0aW9uIG9mIGxpZ2h0IHRvIGRlcml2ZSB3aWR0aC9oZWlnaHQgaGFsZiB2ZWN0b3JzXFxuXFx0XFx0XFx0XFx0XFx0bWF0cml4NDIuaWRlbnRpdHkoKTtcXG5cXHRcXHRcXHRcXHRcXHRtYXRyaXg0LmNvcHkoIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XFxuXFx0XFx0XFx0XFx0XFx0bWF0cml4NC5wcmVtdWx0aXBseSggdmlld01hdHJpeCApO1xcblxcdFxcdFxcdFxcdFxcdG1hdHJpeDQyLmV4dHJhY3RSb3RhdGlvbiggbWF0cml4NCApO1xcblxcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLmhhbGZXaWR0aC5zZXQoIGxpZ2h0LndpZHRoICogMC41LCAwLjAsIDAuMCApO1xcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLmhhbGZIZWlnaHQuc2V0KCAwLjAsIGxpZ2h0LmhlaWdodCAqIDAuNSwgMC4wICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuaGFsZldpZHRoLmFwcGx5TWF0cml4NCggbWF0cml4NDIgKTtcXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5oYWxmSGVpZ2h0LmFwcGx5TWF0cml4NCggbWF0cml4NDIgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBUT0RPIChhYmVsbmF0aW9uKTogUmVjdEFyZWFMaWdodCBkaXN0YW5jZT9cXG5cXHRcXHRcXHRcXHRcXHQvLyB1bmlmb3Jtcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xcblxcblxcdFxcdFxcdFxcdFxcdHN0YXRlLnJlY3RBcmVhWyByZWN0QXJlYUxlbmd0aCBdID0gdW5pZm9ybXM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmVjdEFyZWFMZW5ndGggKys7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggbGlnaHQuaXNQb2ludExpZ2h0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciB1bmlmb3JtcyA9IGNhY2hlLmdldCggbGlnaHQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5wb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMucG9zaXRpb24uYXBwbHlNYXRyaXg0KCB2aWV3TWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuY29sb3IuY29weSggbGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggbGlnaHQuaW50ZW5zaXR5ICk7XFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlzdGFuY2UgPSBsaWdodC5kaXN0YW5jZTtcXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5kZWNheSA9ICggbGlnaHQuZGlzdGFuY2UgPT09IDAgKSA/IDAuMCA6IGxpZ2h0LmRlY2F5O1xcblxcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLnNoYWRvdyA9IGxpZ2h0LmNhc3RTaGFkb3c7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBsaWdodC5jYXN0U2hhZG93ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBzaGFkb3cgPSBsaWdodC5zaGFkb3c7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuc2hhZG93QmlhcyA9IHNoYWRvdy5iaWFzO1xcblxcdFxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLnNoYWRvd1JhZGl1cyA9IHNoYWRvdy5yYWRpdXM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuc2hhZG93TWFwU2l6ZSA9IHNoYWRvdy5tYXBTaXplO1xcblxcdFxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLnNoYWRvd0NhbWVyYU5lYXIgPSBzaGFkb3cuY2FtZXJhLm5lYXI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuc2hhZG93Q2FtZXJhRmFyID0gc2hhZG93LmNhbWVyYS5mYXI7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHN0YXRlLnBvaW50U2hhZG93TWFwWyBwb2ludExlbmd0aCBdID0gc2hhZG93TWFwO1xcblxcdFxcdFxcdFxcdFxcdHN0YXRlLnBvaW50U2hhZG93TWF0cml4WyBwb2ludExlbmd0aCBdID0gbGlnaHQuc2hhZG93Lm1hdHJpeDtcXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS5wb2ludFsgcG9pbnRMZW5ndGggXSA9IHVuaWZvcm1zO1xcblxcblxcdFxcdFxcdFxcdFxcdHBvaW50TGVuZ3RoICsrO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIGxpZ2h0LmlzSGVtaXNwaGVyZUxpZ2h0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciB1bmlmb3JtcyA9IGNhY2hlLmdldCggbGlnaHQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaXJlY3Rpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpcmVjdGlvbi50cmFuc2Zvcm1EaXJlY3Rpb24oIHZpZXdNYXRyaXggKTtcXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaXJlY3Rpb24ubm9ybWFsaXplKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuc2t5Q29sb3IuY29weSggbGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggaW50ZW5zaXR5ICk7XFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuZ3JvdW5kQ29sb3IuY29weSggbGlnaHQuZ3JvdW5kQ29sb3IgKS5tdWx0aXBseVNjYWxhciggaW50ZW5zaXR5ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUuaGVtaVsgaGVtaUxlbmd0aCBdID0gdW5pZm9ybXM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aGVtaUxlbmd0aCArKztcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHN0YXRlLmFtYmllbnRbIDAgXSA9IHI7XFxuXFx0XFx0XFx0c3RhdGUuYW1iaWVudFsgMSBdID0gZztcXG5cXHRcXHRcXHRzdGF0ZS5hbWJpZW50WyAyIF0gPSBiO1xcblxcblxcdFxcdFxcdHN0YXRlLmRpcmVjdGlvbmFsLmxlbmd0aCA9IGRpcmVjdGlvbmFsTGVuZ3RoO1xcblxcdFxcdFxcdHN0YXRlLnNwb3QubGVuZ3RoID0gc3BvdExlbmd0aDtcXG5cXHRcXHRcXHRzdGF0ZS5yZWN0QXJlYS5sZW5ndGggPSByZWN0QXJlYUxlbmd0aDtcXG5cXHRcXHRcXHRzdGF0ZS5wb2ludC5sZW5ndGggPSBwb2ludExlbmd0aDtcXG5cXHRcXHRcXHRzdGF0ZS5oZW1pLmxlbmd0aCA9IGhlbWlMZW5ndGg7XFxuXFxuXFx0XFx0XFx0Ly8gVE9ETyAoc2FtLWctc3RlZWwpIHdoeSBhcmVuJ3Qgd2UgdXNpbmcgam9pblxcblxcdFxcdFxcdHN0YXRlLmhhc2ggPSBkaXJlY3Rpb25hbExlbmd0aCArICcsJyArIHBvaW50TGVuZ3RoICsgJywnICsgc3BvdExlbmd0aCArICcsJyArIHJlY3RBcmVhTGVuZ3RoICsgJywnICsgaGVtaUxlbmd0aCArICcsJyArIHNoYWRvd3MubGVuZ3RoO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdHNldHVwOiBzZXR1cCxcXG5cXHRcXHRcXHRzdGF0ZTogc3RhdGVcXG5cXHRcXHR9O1xcblxcblxcdH1cXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFdlYkdMT2JqZWN0cyggZ2VvbWV0cmllcywgaW5mb1JlbmRlciApIHtcXG5cXG5cXHRcXHR2YXIgdXBkYXRlTGlzdCA9IHt9O1xcblxcblxcdFxcdGZ1bmN0aW9uIHVwZGF0ZSggb2JqZWN0ICkge1xcblxcblxcdFxcdFxcdHZhciBmcmFtZSA9IGluZm9SZW5kZXIuZnJhbWU7XFxuXFxuXFx0XFx0XFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xcblxcdFxcdFxcdHZhciBidWZmZXJnZW9tZXRyeSA9IGdlb21ldHJpZXMuZ2V0KCBvYmplY3QsIGdlb21ldHJ5ICk7XFxuXFxuXFx0XFx0XFx0Ly8gVXBkYXRlIG9uY2UgcGVyIGZyYW1lXFxuXFxuXFx0XFx0XFx0aWYgKCB1cGRhdGVMaXN0WyBidWZmZXJnZW9tZXRyeS5pZCBdICE9PSBmcmFtZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YnVmZmVyZ2VvbWV0cnkudXBkYXRlRnJvbU9iamVjdCggb2JqZWN0ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGdlb21ldHJpZXMudXBkYXRlKCBidWZmZXJnZW9tZXRyeSApO1xcblxcblxcdFxcdFxcdFxcdHVwZGF0ZUxpc3RbIGJ1ZmZlcmdlb21ldHJ5LmlkIF0gPSBmcmFtZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGJ1ZmZlcmdlb21ldHJ5O1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBjbGVhcigpIHtcXG5cXG5cXHRcXHRcXHR1cGRhdGVMaXN0ID0ge307XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB7XFxuXFxuXFx0XFx0XFx0dXBkYXRlOiB1cGRhdGUsXFxuXFx0XFx0XFx0Y2xlYXI6IGNsZWFyXFxuXFxuXFx0XFx0fTtcXG5cXG5cXHR9XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBhZGRMaW5lTnVtYmVycyggc3RyaW5nICkge1xcblxcblxcdFxcdHZhciBsaW5lcyA9IHN0cmluZy5zcGxpdCggJ1xcXFxuJyApO1xcblxcblxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRsaW5lc1sgaSBdID0gKCBpICsgMSApICsgJzogJyArIGxpbmVzWyBpIF07XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBsaW5lcy5qb2luKCAnXFxcXG4nICk7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIFdlYkdMU2hhZGVyKCBnbCwgdHlwZSwgc3RyaW5nICkge1xcblxcblxcdFxcdHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIHR5cGUgKTtcXG5cXG5cXHRcXHRnbC5zaGFkZXJTb3VyY2UoIHNoYWRlciwgc3RyaW5nICk7XFxuXFx0XFx0Z2wuY29tcGlsZVNoYWRlciggc2hhZGVyICk7XFxuXFxuXFx0XFx0aWYgKCBnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoIHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMgKSA9PT0gZmFsc2UgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMU2hhZGVyOiBTaGFkZXIgY291bGRuXFxcXCd0IGNvbXBpbGUuJyApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIGdsLmdldFNoYWRlckluZm9Mb2coIHNoYWRlciApICE9PSAnJyApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFNoYWRlcjogZ2wuZ2V0U2hhZGVySW5mb0xvZygpJywgdHlwZSA9PT0gZ2wuVkVSVEVYX1NIQURFUiA/ICd2ZXJ0ZXgnIDogJ2ZyYWdtZW50JywgZ2wuZ2V0U2hhZGVySW5mb0xvZyggc2hhZGVyICksIGFkZExpbmVOdW1iZXJzKCBzdHJpbmcgKSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyAtLWVuYWJsZS1wcml2aWxlZ2VkLXdlYmdsLWV4dGVuc2lvblxcblxcdFxcdC8vIGNvbnNvbGUubG9nKCB0eXBlLCBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9kZWJ1Z19zaGFkZXJzJyApLmdldFRyYW5zbGF0ZWRTaGFkZXJTb3VyY2UoIHNoYWRlciApICk7XFxuXFxuXFx0XFx0cmV0dXJuIHNoYWRlcjtcXG5cXG5cXHR9XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHR2YXIgcHJvZ3JhbUlkQ291bnQgPSAwO1xcblxcblxcdGZ1bmN0aW9uIGdldEVuY29kaW5nQ29tcG9uZW50cyggZW5jb2RpbmcgKSB7XFxuXFxuXFx0XFx0c3dpdGNoICggZW5jb2RpbmcgKSB7XFxuXFxuXFx0XFx0XFx0Y2FzZSBMaW5lYXJFbmNvZGluZzpcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWyAnTGluZWFyJywgJyggdmFsdWUgKScgXTtcXG5cXHRcXHRcXHRjYXNlIHNSR0JFbmNvZGluZzpcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWyAnc1JHQicsICcoIHZhbHVlICknIF07XFxuXFx0XFx0XFx0Y2FzZSBSR0JFRW5jb2Rpbmc6XFxuXFx0XFx0XFx0XFx0cmV0dXJuIFsgJ1JHQkUnLCAnKCB2YWx1ZSApJyBdO1xcblxcdFxcdFxcdGNhc2UgUkdCTTdFbmNvZGluZzpcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWyAnUkdCTScsICcoIHZhbHVlLCA3LjAgKScgXTtcXG5cXHRcXHRcXHRjYXNlIFJHQk0xNkVuY29kaW5nOlxcblxcdFxcdFxcdFxcdHJldHVybiBbICdSR0JNJywgJyggdmFsdWUsIDE2LjAgKScgXTtcXG5cXHRcXHRcXHRjYXNlIFJHQkRFbmNvZGluZzpcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWyAnUkdCRCcsICcoIHZhbHVlLCAyNTYuMCApJyBdO1xcblxcdFxcdFxcdGNhc2UgR2FtbWFFbmNvZGluZzpcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWyAnR2FtbWEnLCAnKCB2YWx1ZSwgZmxvYXQoIEdBTU1BX0ZBQ1RPUiApICknIF07XFxuXFx0XFx0XFx0ZGVmYXVsdDpcXG5cXHRcXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoICd1bnN1cHBvcnRlZCBlbmNvZGluZzogJyArIGVuY29kaW5nICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBnZXRUZXhlbERlY29kaW5nRnVuY3Rpb24oIGZ1bmN0aW9uTmFtZSwgZW5jb2RpbmcgKSB7XFxuXFxuXFx0XFx0dmFyIGNvbXBvbmVudHMgPSBnZXRFbmNvZGluZ0NvbXBvbmVudHMoIGVuY29kaW5nICk7XFxuXFx0XFx0cmV0dXJuICd2ZWM0ICcgKyBmdW5jdGlvbk5hbWUgKyAnKCB2ZWM0IHZhbHVlICkgeyByZXR1cm4gJyArIGNvbXBvbmVudHNbIDAgXSArICdUb0xpbmVhcicgKyBjb21wb25lbnRzWyAxIF0gKyAnOyB9JztcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gZ2V0VGV4ZWxFbmNvZGluZ0Z1bmN0aW9uKCBmdW5jdGlvbk5hbWUsIGVuY29kaW5nICkge1xcblxcblxcdFxcdHZhciBjb21wb25lbnRzID0gZ2V0RW5jb2RpbmdDb21wb25lbnRzKCBlbmNvZGluZyApO1xcblxcdFxcdHJldHVybiAndmVjNCAnICsgZnVuY3Rpb25OYW1lICsgJyggdmVjNCB2YWx1ZSApIHsgcmV0dXJuIExpbmVhclRvJyArIGNvbXBvbmVudHNbIDAgXSArIGNvbXBvbmVudHNbIDEgXSArICc7IH0nO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBnZXRUb25lTWFwcGluZ0Z1bmN0aW9uKCBmdW5jdGlvbk5hbWUsIHRvbmVNYXBwaW5nICkge1xcblxcblxcdFxcdHZhciB0b25lTWFwcGluZ05hbWU7XFxuXFxuXFx0XFx0c3dpdGNoICggdG9uZU1hcHBpbmcgKSB7XFxuXFxuXFx0XFx0XFx0Y2FzZSBMaW5lYXJUb25lTWFwcGluZzpcXG5cXHRcXHRcXHRcXHR0b25lTWFwcGluZ05hbWUgPSAnTGluZWFyJztcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRjYXNlIFJlaW5oYXJkVG9uZU1hcHBpbmc6XFxuXFx0XFx0XFx0XFx0dG9uZU1hcHBpbmdOYW1lID0gJ1JlaW5oYXJkJztcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRjYXNlIFVuY2hhcnRlZDJUb25lTWFwcGluZzpcXG5cXHRcXHRcXHRcXHR0b25lTWFwcGluZ05hbWUgPSAnVW5jaGFydGVkMic7XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0Y2FzZSBDaW5lb25Ub25lTWFwcGluZzpcXG5cXHRcXHRcXHRcXHR0b25lTWFwcGluZ05hbWUgPSAnT3B0aW1pemVkQ2luZW9uJztcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRkZWZhdWx0OlxcblxcdFxcdFxcdFxcdHRocm93IG5ldyBFcnJvciggJ3Vuc3VwcG9ydGVkIHRvbmVNYXBwaW5nOiAnICsgdG9uZU1hcHBpbmcgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuICd2ZWMzICcgKyBmdW5jdGlvbk5hbWUgKyAnKCB2ZWMzIGNvbG9yICkgeyByZXR1cm4gJyArIHRvbmVNYXBwaW5nTmFtZSArICdUb25lTWFwcGluZyggY29sb3IgKTsgfSc7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGdlbmVyYXRlRXh0ZW5zaW9ucyggZXh0ZW5zaW9ucywgcGFyYW1ldGVycywgcmVuZGVyZXJFeHRlbnNpb25zICkge1xcblxcblxcdFxcdGV4dGVuc2lvbnMgPSBleHRlbnNpb25zIHx8IHt9O1xcblxcblxcdFxcdHZhciBjaHVua3MgPSBbXFxuXFx0XFx0XFx0KCBleHRlbnNpb25zLmRlcml2YXRpdmVzIHx8IHBhcmFtZXRlcnMuZW52TWFwQ3ViZVVWIHx8IHBhcmFtZXRlcnMuYnVtcE1hcCB8fCBwYXJhbWV0ZXJzLm5vcm1hbE1hcCB8fCBwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nICkgPyAnI2V4dGVuc2lvbiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMgOiBlbmFibGUnIDogJycsXFxuXFx0XFx0XFx0KCBleHRlbnNpb25zLmZyYWdEZXB0aCB8fCBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgKSAmJiByZW5kZXJlckV4dGVuc2lvbnMuZ2V0KCAnRVhUX2ZyYWdfZGVwdGgnICkgPyAnI2V4dGVuc2lvbiBHTF9FWFRfZnJhZ19kZXB0aCA6IGVuYWJsZScgOiAnJyxcXG5cXHRcXHRcXHQoIGV4dGVuc2lvbnMuZHJhd0J1ZmZlcnMgKSAmJiByZW5kZXJlckV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfZHJhd19idWZmZXJzJyApID8gJyNleHRlbnNpb24gR0xfRVhUX2RyYXdfYnVmZmVycyA6IHJlcXVpcmUnIDogJycsXFxuXFx0XFx0XFx0KCBleHRlbnNpb25zLnNoYWRlclRleHR1cmVMT0QgfHwgcGFyYW1ldGVycy5lbnZNYXAgKSAmJiByZW5kZXJlckV4dGVuc2lvbnMuZ2V0KCAnRVhUX3NoYWRlcl90ZXh0dXJlX2xvZCcgKSA/ICcjZXh0ZW5zaW9uIEdMX0VYVF9zaGFkZXJfdGV4dHVyZV9sb2QgOiBlbmFibGUnIDogJydcXG5cXHRcXHRdO1xcblxcblxcdFxcdHJldHVybiBjaHVua3MuZmlsdGVyKCBmaWx0ZXJFbXB0eUxpbmUgKS5qb2luKCAnXFxcXG4nICk7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGdlbmVyYXRlRGVmaW5lcyggZGVmaW5lcyApIHtcXG5cXG5cXHRcXHR2YXIgY2h1bmtzID0gW107XFxuXFxuXFx0XFx0Zm9yICggdmFyIG5hbWUgaW4gZGVmaW5lcyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdmFsdWUgPSBkZWZpbmVzWyBuYW1lIF07XFxuXFxuXFx0XFx0XFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSBjb250aW51ZTtcXG5cXG5cXHRcXHRcXHRjaHVua3MucHVzaCggJyNkZWZpbmUgJyArIG5hbWUgKyAnICcgKyB2YWx1ZSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gY2h1bmtzLmpvaW4oICdcXFxcbicgKTtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gZmV0Y2hBdHRyaWJ1dGVMb2NhdGlvbnMoIGdsLCBwcm9ncmFtICkge1xcblxcblxcdFxcdHZhciBhdHRyaWJ1dGVzID0ge307XFxuXFxuXFx0XFx0dmFyIG4gPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5BQ1RJVkVfQVRUUklCVVRFUyApO1xcblxcblxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IG47IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGluZm8gPSBnbC5nZXRBY3RpdmVBdHRyaWIoIHByb2dyYW0sIGkgKTtcXG5cXHRcXHRcXHR2YXIgbmFtZSA9IGluZm8ubmFtZTtcXG5cXG5cXHRcXHRcXHQvLyBjb25zb2xlLmxvZyggJ1RIUkVFLldlYkdMUHJvZ3JhbTogQUNUSVZFIFZFUlRFWCBBVFRSSUJVVEU6JywgbmFtZSwgaSApO1xcblxcblxcdFxcdFxcdGF0dHJpYnV0ZXNbIG5hbWUgXSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCBuYW1lICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBhdHRyaWJ1dGVzO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBmaWx0ZXJFbXB0eUxpbmUoIHN0cmluZyApIHtcXG5cXG5cXHRcXHRyZXR1cm4gc3RyaW5nICE9PSAnJztcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gcmVwbGFjZUxpZ2h0TnVtcyggc3RyaW5nLCBwYXJhbWV0ZXJzICkge1xcblxcblxcdFxcdHJldHVybiBzdHJpbmdcXG5cXHRcXHRcXHQucmVwbGFjZSggL05VTV9ESVJfTElHSFRTL2csIHBhcmFtZXRlcnMubnVtRGlyTGlnaHRzIClcXG5cXHRcXHRcXHQucmVwbGFjZSggL05VTV9TUE9UX0xJR0hUUy9nLCBwYXJhbWV0ZXJzLm51bVNwb3RMaWdodHMgKVxcblxcdFxcdFxcdC5yZXBsYWNlKCAvTlVNX1JFQ1RfQVJFQV9MSUdIVFMvZywgcGFyYW1ldGVycy5udW1SZWN0QXJlYUxpZ2h0cyApXFxuXFx0XFx0XFx0LnJlcGxhY2UoIC9OVU1fUE9JTlRfTElHSFRTL2csIHBhcmFtZXRlcnMubnVtUG9pbnRMaWdodHMgKVxcblxcdFxcdFxcdC5yZXBsYWNlKCAvTlVNX0hFTUlfTElHSFRTL2csIHBhcmFtZXRlcnMubnVtSGVtaUxpZ2h0cyApO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBwYXJzZUluY2x1ZGVzKCBzdHJpbmcgKSB7XFxuXFxuXFx0XFx0dmFyIHBhdHRlcm4gPSAvXlsgXFxcXHRdKiNpbmNsdWRlICs8KFtcXFxcd1xcXFxkLl0rKT4vZ207XFxuXFxuXFx0XFx0ZnVuY3Rpb24gcmVwbGFjZSggbWF0Y2gsIGluY2x1ZGUgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHJlcGxhY2UgPSBTaGFkZXJDaHVua1sgaW5jbHVkZSBdO1xcblxcblxcdFxcdFxcdGlmICggcmVwbGFjZSA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdHRocm93IG5ldyBFcnJvciggJ0NhbiBub3QgcmVzb2x2ZSAjaW5jbHVkZSA8JyArIGluY2x1ZGUgKyAnPicgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHBhcnNlSW5jbHVkZXMoIHJlcGxhY2UgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBwYXR0ZXJuLCByZXBsYWNlICk7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIHVucm9sbExvb3BzKCBzdHJpbmcgKSB7XFxuXFxuXFx0XFx0dmFyIHBhdHRlcm4gPSAvZm9yIFxcXFwoIGludCBpIFxcXFw9IChcXFxcZCspXFxcXDsgaSA8IChcXFxcZCspXFxcXDsgaSBcXFxcK1xcXFwrIFxcXFwpIFxcXFx7KFtcXFxcc1xcXFxTXSs/KSg/PVxcXFx9KVxcXFx9L2c7XFxuXFxuXFx0XFx0ZnVuY3Rpb24gcmVwbGFjZSggbWF0Y2gsIHN0YXJ0LCBlbmQsIHNuaXBwZXQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHVucm9sbCA9ICcnO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gcGFyc2VJbnQoIHN0YXJ0ICk7IGkgPCBwYXJzZUludCggZW5kICk7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dW5yb2xsICs9IHNuaXBwZXQucmVwbGFjZSggL1xcXFxbIGkgXFxcXF0vZywgJ1sgJyArIGkgKyAnIF0nICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB1bnJvbGw7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcGF0dGVybiwgcmVwbGFjZSApO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBXZWJHTFByb2dyYW0oIHJlbmRlcmVyLCBleHRlbnNpb25zLCBjb2RlLCBtYXRlcmlhbCwgc2hhZGVyLCBwYXJhbWV0ZXJzICkge1xcblxcblxcdFxcdHZhciBnbCA9IHJlbmRlcmVyLmNvbnRleHQ7XFxuXFxuXFx0XFx0dmFyIGRlZmluZXMgPSBtYXRlcmlhbC5kZWZpbmVzO1xcblxcblxcdFxcdHZhciB2ZXJ0ZXhTaGFkZXIgPSBzaGFkZXIudmVydGV4U2hhZGVyO1xcblxcdFxcdHZhciBmcmFnbWVudFNoYWRlciA9IHNoYWRlci5mcmFnbWVudFNoYWRlcjtcXG5cXG5cXHRcXHR2YXIgc2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9CQVNJQyc7XFxuXFxuXFx0XFx0aWYgKCBwYXJhbWV0ZXJzLnNoYWRvd01hcFR5cGUgPT09IFBDRlNoYWRvd01hcCApIHtcXG5cXG5cXHRcXHRcXHRzaGFkb3dNYXBUeXBlRGVmaW5lID0gJ1NIQURPV01BUF9UWVBFX1BDRic7XFxuXFxuXFx0XFx0fSBlbHNlIGlmICggcGFyYW1ldGVycy5zaGFkb3dNYXBUeXBlID09PSBQQ0ZTb2Z0U2hhZG93TWFwICkge1xcblxcblxcdFxcdFxcdHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQnO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR2YXIgZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9DVUJFJztcXG5cXHRcXHR2YXIgZW52TWFwTW9kZURlZmluZSA9ICdFTlZNQVBfTU9ERV9SRUZMRUNUSU9OJztcXG5cXHRcXHR2YXIgZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZJztcXG5cXG5cXHRcXHRpZiAoIHBhcmFtZXRlcnMuZW52TWFwICkge1xcblxcblxcdFxcdFxcdHN3aXRjaCAoIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nICkge1xcblxcblxcdFxcdFxcdFxcdGNhc2UgQ3ViZVJlZmxlY3Rpb25NYXBwaW5nOlxcblxcdFxcdFxcdFxcdGNhc2UgQ3ViZVJlZnJhY3Rpb25NYXBwaW5nOlxcblxcdFxcdFxcdFxcdFxcdGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfQ1VCRSc7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0Y2FzZSBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZzpcXG5cXHRcXHRcXHRcXHRjYXNlIEN1YmVVVlJlZnJhY3Rpb25NYXBwaW5nOlxcblxcdFxcdFxcdFxcdFxcdGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfQ1VCRV9VVic7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0Y2FzZSBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZzpcXG5cXHRcXHRcXHRcXHRjYXNlIEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nOlxcblxcdFxcdFxcdFxcdFxcdGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfRVFVSVJFQyc7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0Y2FzZSBTcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZzpcXG5cXHRcXHRcXHRcXHRcXHRlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX1NQSEVSRSc7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHN3aXRjaCAoIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nICkge1xcblxcblxcdFxcdFxcdFxcdGNhc2UgQ3ViZVJlZnJhY3Rpb25NYXBwaW5nOlxcblxcdFxcdFxcdFxcdGNhc2UgRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmc6XFxuXFx0XFx0XFx0XFx0XFx0ZW52TWFwTW9kZURlZmluZSA9ICdFTlZNQVBfTU9ERV9SRUZSQUNUSU9OJztcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0c3dpdGNoICggbWF0ZXJpYWwuY29tYmluZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjYXNlIE11bHRpcGx5T3BlcmF0aW9uOlxcblxcdFxcdFxcdFxcdFxcdGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19NVUxUSVBMWSc7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0Y2FzZSBNaXhPcGVyYXRpb246XFxuXFx0XFx0XFx0XFx0XFx0ZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX01JWCc7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0Y2FzZSBBZGRPcGVyYXRpb246XFxuXFx0XFx0XFx0XFx0XFx0ZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX0FERCc7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR2YXIgZ2FtbWFGYWN0b3JEZWZpbmUgPSAoIHJlbmRlcmVyLmdhbW1hRmFjdG9yID4gMCApID8gcmVuZGVyZXIuZ2FtbWFGYWN0b3IgOiAxLjA7XFxuXFxuXFx0XFx0Ly8gY29uc29sZS5sb2coICdidWlsZGluZyBuZXcgcHJvZ3JhbSAnICk7XFxuXFxuXFx0XFx0Ly9cXG5cXG5cXHRcXHR2YXIgY3VzdG9tRXh0ZW5zaW9ucyA9IGdlbmVyYXRlRXh0ZW5zaW9ucyggbWF0ZXJpYWwuZXh0ZW5zaW9ucywgcGFyYW1ldGVycywgZXh0ZW5zaW9ucyApO1xcblxcblxcdFxcdHZhciBjdXN0b21EZWZpbmVzID0gZ2VuZXJhdGVEZWZpbmVzKCBkZWZpbmVzICk7XFxuXFxuXFx0XFx0Ly9cXG5cXG5cXHRcXHR2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcXG5cXG5cXHRcXHR2YXIgcHJlZml4VmVydGV4LCBwcmVmaXhGcmFnbWVudDtcXG5cXG5cXHRcXHRpZiAoIG1hdGVyaWFsLmlzUmF3U2hhZGVyTWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0cHJlZml4VmVydGV4ID0gW1xcblxcblxcdFxcdFxcdFxcdGN1c3RvbURlZmluZXNcXG5cXG5cXHRcXHRcXHRdLmZpbHRlciggZmlsdGVyRW1wdHlMaW5lICkuam9pbiggJ1xcXFxuJyApO1xcblxcblxcdFxcdFxcdGlmICggcHJlZml4VmVydGV4Lmxlbmd0aCA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cHJlZml4VmVydGV4ICs9ICdcXFxcbic7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHByZWZpeEZyYWdtZW50ID0gW1xcblxcblxcdFxcdFxcdFxcdGN1c3RvbUV4dGVuc2lvbnMsXFxuXFx0XFx0XFx0XFx0Y3VzdG9tRGVmaW5lc1xcblxcblxcdFxcdFxcdF0uZmlsdGVyKCBmaWx0ZXJFbXB0eUxpbmUgKS5qb2luKCAnXFxcXG4nICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBwcmVmaXhGcmFnbWVudC5sZW5ndGggPiAwICkge1xcblxcblxcdFxcdFxcdFxcdHByZWZpeEZyYWdtZW50ICs9ICdcXFxcbic7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0cHJlZml4VmVydGV4ID0gW1xcblxcblxcdFxcdFxcdFxcdCdwcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBmbG9hdDsnLFxcblxcdFxcdFxcdFxcdCdwcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBpbnQ7JyxcXG5cXG5cXHRcXHRcXHRcXHQnI2RlZmluZSBTSEFERVJfTkFNRSAnICsgc2hhZGVyLm5hbWUsXFxuXFxuXFx0XFx0XFx0XFx0Y3VzdG9tRGVmaW5lcyxcXG5cXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMgPyAnI2RlZmluZSBWRVJURVhfVEVYVFVSRVMnIDogJycsXFxuXFxuXFx0XFx0XFx0XFx0JyNkZWZpbmUgR0FNTUFfRkFDVE9SICcgKyBnYW1tYUZhY3RvckRlZmluZSxcXG5cXG5cXHRcXHRcXHRcXHQnI2RlZmluZSBNQVhfQk9ORVMgJyArIHBhcmFtZXRlcnMubWF4Qm9uZXMsXFxuXFx0XFx0XFx0XFx0KCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZyApID8gJyNkZWZpbmUgVVNFX0ZPRycgOiAnJyxcXG5cXHRcXHRcXHRcXHQoIHBhcmFtZXRlcnMudXNlRm9nICYmIHBhcmFtZXRlcnMuZm9nRXhwICkgPyAnI2RlZmluZSBGT0dfRVhQMicgOiAnJyxcXG5cXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLm1hcCA/ICcjZGVmaW5lIFVTRV9NQVAnIDogJycsXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSBVU0VfRU5WTUFQJyA6ICcnLFxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcE1vZGVEZWZpbmUgOiAnJyxcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmxpZ2h0TWFwID8gJyNkZWZpbmUgVVNFX0xJR0hUTUFQJyA6ICcnLFxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuYW9NYXAgPyAnI2RlZmluZSBVU0VfQU9NQVAnIDogJycsXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5lbWlzc2l2ZU1hcCA/ICcjZGVmaW5lIFVTRV9FTUlTU0lWRU1BUCcgOiAnJyxcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmJ1bXBNYXAgPyAnI2RlZmluZSBVU0VfQlVNUE1BUCcgOiAnJyxcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLm5vcm1hbE1hcCA/ICcjZGVmaW5lIFVTRV9OT1JNQUxNQVAnIDogJycsXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5kaXNwbGFjZW1lbnRNYXAgJiYgcGFyYW1ldGVycy5zdXBwb3J0c1ZlcnRleFRleHR1cmVzID8gJyNkZWZpbmUgVVNFX0RJU1BMQUNFTUVOVE1BUCcgOiAnJyxcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwID8gJyNkZWZpbmUgVVNFX1NQRUNVTEFSTUFQJyA6ICcnLFxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMucm91Z2huZXNzTWFwID8gJyNkZWZpbmUgVVNFX1JPVUdITkVTU01BUCcgOiAnJyxcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLm1ldGFsbmVzc01hcCA/ICcjZGVmaW5lIFVTRV9NRVRBTE5FU1NNQVAnIDogJycsXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5hbHBoYU1hcCA/ICcjZGVmaW5lIFVTRV9BTFBIQU1BUCcgOiAnJyxcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLnZlcnRleENvbG9ycyA/ICcjZGVmaW5lIFVTRV9DT0xPUicgOiAnJyxcXG5cXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID8gJyNkZWZpbmUgRkxBVF9TSEFERUQnIDogJycsXFxuXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5za2lubmluZyA/ICcjZGVmaW5lIFVTRV9TS0lOTklORycgOiAnJyxcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLnVzZVZlcnRleFRleHR1cmUgPyAnI2RlZmluZSBCT05FX1RFWFRVUkUnIDogJycsXFxuXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5tb3JwaFRhcmdldHMgPyAnI2RlZmluZSBVU0VfTU9SUEhUQVJHRVRTJyA6ICcnLFxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMubW9ycGhOb3JtYWxzICYmIHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPT09IGZhbHNlID8gJyNkZWZpbmUgVVNFX01PUlBITk9STUFMUycgOiAnJyxcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmRvdWJsZVNpZGVkID8gJyNkZWZpbmUgRE9VQkxFX1NJREVEJyA6ICcnLFxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuZmxpcFNpZGVkID8gJyNkZWZpbmUgRkxJUF9TSURFRCcgOiAnJyxcXG5cXG5cXHRcXHRcXHRcXHQnI2RlZmluZSBOVU1fQ0xJUFBJTkdfUExBTkVTICcgKyBwYXJhbWV0ZXJzLm51bUNsaXBwaW5nUGxhbmVzLFxcblxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lIFVTRV9TSEFET1dNQVAnIDogJycsXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gJyNkZWZpbmUgJyArIHNoYWRvd01hcFR5cGVEZWZpbmUgOiAnJyxcXG5cXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLnNpemVBdHRlbnVhdGlvbiA/ICcjZGVmaW5lIFVTRV9TSVpFQVRURU5VQVRJT04nIDogJycsXFxuXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGJyA6ICcnLFxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiBleHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGX0VYVCcgOiAnJyxcXG5cXG5cXHRcXHRcXHRcXHQndW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4OycsXFxuXFx0XFx0XFx0XFx0J3VuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7JyxcXG5cXHRcXHRcXHRcXHQndW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7JyxcXG5cXHRcXHRcXHRcXHQndW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7JyxcXG5cXHRcXHRcXHRcXHQndW5pZm9ybSBtYXQzIG5vcm1hbE1hdHJpeDsnLFxcblxcdFxcdFxcdFxcdCd1bmlmb3JtIHZlYzMgY2FtZXJhUG9zaXRpb247JyxcXG5cXG5cXHRcXHRcXHRcXHQnYXR0cmlidXRlIHZlYzMgcG9zaXRpb247JyxcXG5cXHRcXHRcXHRcXHQnYXR0cmlidXRlIHZlYzMgbm9ybWFsOycsXFxuXFx0XFx0XFx0XFx0J2F0dHJpYnV0ZSB2ZWMyIHV2OycsXFxuXFxuXFx0XFx0XFx0XFx0JyNpZmRlZiBVU0VfQ09MT1InLFxcblxcblxcdFxcdFxcdFxcdCdcXHRhdHRyaWJ1dGUgdmVjMyBjb2xvcjsnLFxcblxcblxcdFxcdFxcdFxcdCcjZW5kaWYnLFxcblxcblxcdFxcdFxcdFxcdCcjaWZkZWYgVVNFX01PUlBIVEFSR0VUUycsXFxuXFxuXFx0XFx0XFx0XFx0J1xcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MDsnLFxcblxcdFxcdFxcdFxcdCdcXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDE7JyxcXG5cXHRcXHRcXHRcXHQnXFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQyOycsXFxuXFx0XFx0XFx0XFx0J1xcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MzsnLFxcblxcblxcdFxcdFxcdFxcdCdcXHQjaWZkZWYgVVNFX01PUlBITk9STUFMUycsXFxuXFxuXFx0XFx0XFx0XFx0J1xcdFxcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMDsnLFxcblxcdFxcdFxcdFxcdCdcXHRcXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDE7JyxcXG5cXHRcXHRcXHRcXHQnXFx0XFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwyOycsXFxuXFx0XFx0XFx0XFx0J1xcdFxcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMzsnLFxcblxcblxcdFxcdFxcdFxcdCdcXHQjZWxzZScsXFxuXFxuXFx0XFx0XFx0XFx0J1xcdFxcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NDsnLFxcblxcdFxcdFxcdFxcdCdcXHRcXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDU7JyxcXG5cXHRcXHRcXHRcXHQnXFx0XFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ2OycsXFxuXFx0XFx0XFx0XFx0J1xcdFxcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NzsnLFxcblxcblxcdFxcdFxcdFxcdCdcXHQjZW5kaWYnLFxcblxcblxcdFxcdFxcdFxcdCcjZW5kaWYnLFxcblxcblxcdFxcdFxcdFxcdCcjaWZkZWYgVVNFX1NLSU5OSU5HJyxcXG5cXG5cXHRcXHRcXHRcXHQnXFx0YXR0cmlidXRlIHZlYzQgc2tpbkluZGV4OycsXFxuXFx0XFx0XFx0XFx0J1xcdGF0dHJpYnV0ZSB2ZWM0IHNraW5XZWlnaHQ7JyxcXG5cXG5cXHRcXHRcXHRcXHQnI2VuZGlmJyxcXG5cXG5cXHRcXHRcXHRcXHQnXFxcXG4nXFxuXFxuXFx0XFx0XFx0XS5maWx0ZXIoIGZpbHRlckVtcHR5TGluZSApLmpvaW4oICdcXFxcbicgKTtcXG5cXG5cXHRcXHRcXHRwcmVmaXhGcmFnbWVudCA9IFtcXG5cXG5cXHRcXHRcXHRcXHRjdXN0b21FeHRlbnNpb25zLFxcblxcblxcdFxcdFxcdFxcdCdwcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBmbG9hdDsnLFxcblxcdFxcdFxcdFxcdCdwcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBpbnQ7JyxcXG5cXG5cXHRcXHRcXHRcXHQnI2RlZmluZSBTSEFERVJfTkFNRSAnICsgc2hhZGVyLm5hbWUsXFxuXFxuXFx0XFx0XFx0XFx0Y3VzdG9tRGVmaW5lcyxcXG5cXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmFscGhhVGVzdCA/ICcjZGVmaW5lIEFMUEhBVEVTVCAnICsgcGFyYW1ldGVycy5hbHBoYVRlc3QgOiAnJyxcXG5cXG5cXHRcXHRcXHRcXHQnI2RlZmluZSBHQU1NQV9GQUNUT1IgJyArIGdhbW1hRmFjdG9yRGVmaW5lLFxcblxcblxcdFxcdFxcdFxcdCggcGFyYW1ldGVycy51c2VGb2cgJiYgcGFyYW1ldGVycy5mb2cgKSA/ICcjZGVmaW5lIFVTRV9GT0cnIDogJycsXFxuXFx0XFx0XFx0XFx0KCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZ0V4cCApID8gJyNkZWZpbmUgRk9HX0VYUDInIDogJycsXFxuXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5tYXAgPyAnI2RlZmluZSBVU0VfTUFQJyA6ICcnLFxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgVVNFX0VOVk1BUCcgOiAnJyxcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBUeXBlRGVmaW5lIDogJycsXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwTW9kZURlZmluZSA6ICcnLFxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcEJsZW5kaW5nRGVmaW5lIDogJycsXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5saWdodE1hcCA/ICcjZGVmaW5lIFVTRV9MSUdIVE1BUCcgOiAnJyxcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmFvTWFwID8gJyNkZWZpbmUgVVNFX0FPTUFQJyA6ICcnLFxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuZW1pc3NpdmVNYXAgPyAnI2RlZmluZSBVU0VfRU1JU1NJVkVNQVAnIDogJycsXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5idW1wTWFwID8gJyNkZWZpbmUgVVNFX0JVTVBNQVAnIDogJycsXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5ub3JtYWxNYXAgPyAnI2RlZmluZSBVU0VfTk9STUFMTUFQJyA6ICcnLFxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuc3BlY3VsYXJNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVAnIDogJycsXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5yb3VnaG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfUk9VR0hORVNTTUFQJyA6ICcnLFxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMubWV0YWxuZXNzTWFwID8gJyNkZWZpbmUgVVNFX01FVEFMTkVTU01BUCcgOiAnJyxcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmFscGhhTWFwID8gJyNkZWZpbmUgVVNFX0FMUEhBTUFQJyA6ICcnLFxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMudmVydGV4Q29sb3JzID8gJyNkZWZpbmUgVVNFX0NPTE9SJyA6ICcnLFxcblxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuZ3JhZGllbnRNYXAgPyAnI2RlZmluZSBVU0VfR1JBRElFTlRNQVAnIDogJycsXFxuXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5mbGF0U2hhZGluZyA/ICcjZGVmaW5lIEZMQVRfU0hBREVEJyA6ICcnLFxcblxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuZG91YmxlU2lkZWQgPyAnI2RlZmluZSBET1VCTEVfU0lERUQnIDogJycsXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5mbGlwU2lkZWQgPyAnI2RlZmluZSBGTElQX1NJREVEJyA6ICcnLFxcblxcblxcdFxcdFxcdFxcdCcjZGVmaW5lIE5VTV9DTElQUElOR19QTEFORVMgJyArIHBhcmFtZXRlcnMubnVtQ2xpcHBpbmdQbGFuZXMsXFxuXFx0XFx0XFx0XFx0JyNkZWZpbmUgVU5JT05fQ0xJUFBJTkdfUExBTkVTICcgKyAoIHBhcmFtZXRlcnMubnVtQ2xpcHBpbmdQbGFuZXMgLSBwYXJhbWV0ZXJzLm51bUNsaXBJbnRlcnNlY3Rpb24gKSxcXG5cXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSBVU0VfU0hBRE9XTUFQJyA6ICcnLFxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lICcgKyBzaGFkb3dNYXBUeXBlRGVmaW5lIDogJycsXFxuXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5wcmVtdWx0aXBsaWVkQWxwaGEgPyAnI2RlZmluZSBQUkVNVUxUSVBMSUVEX0FMUEhBJyA6ICcnLFxcblxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMucGh5c2ljYWxseUNvcnJlY3RMaWdodHMgPyAnI2RlZmluZSBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTJyA6ICcnLFxcblxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciA/ICcjZGVmaW5lIFVTRV9MT0dERVBUSEJVRicgOiAnJyxcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgJiYgZXh0ZW5zaW9ucy5nZXQoICdFWFRfZnJhZ19kZXB0aCcgKSA/ICcjZGVmaW5lIFVTRV9MT0dERVBUSEJVRl9FWFQnIDogJycsXFxuXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5lbnZNYXAgJiYgZXh0ZW5zaW9ucy5nZXQoICdFWFRfc2hhZGVyX3RleHR1cmVfbG9kJyApID8gJyNkZWZpbmUgVEVYVFVSRV9MT0RfRVhUJyA6ICcnLFxcblxcblxcdFxcdFxcdFxcdCd1bmlmb3JtIG1hdDQgdmlld01hdHJpeDsnLFxcblxcdFxcdFxcdFxcdCd1bmlmb3JtIHZlYzMgY2FtZXJhUG9zaXRpb247JyxcXG5cXG5cXHRcXHRcXHRcXHQoIHBhcmFtZXRlcnMudG9uZU1hcHBpbmcgIT09IE5vVG9uZU1hcHBpbmcgKSA/ICcjZGVmaW5lIFRPTkVfTUFQUElORycgOiAnJyxcXG5cXHRcXHRcXHRcXHQoIHBhcmFtZXRlcnMudG9uZU1hcHBpbmcgIT09IE5vVG9uZU1hcHBpbmcgKSA/IFNoYWRlckNodW5rWyAndG9uZW1hcHBpbmdfcGFyc19mcmFnbWVudCcgXSA6ICcnLCAvLyB0aGlzIGNvZGUgaXMgcmVxdWlyZWQgaGVyZSBiZWNhdXNlIGl0IGlzIHVzZWQgYnkgdGhlIHRvbmVNYXBwaW5nKCkgZnVuY3Rpb24gZGVmaW5lZCBiZWxvd1xcblxcdFxcdFxcdFxcdCggcGFyYW1ldGVycy50b25lTWFwcGluZyAhPT0gTm9Ub25lTWFwcGluZyApID8gZ2V0VG9uZU1hcHBpbmdGdW5jdGlvbiggJ3RvbmVNYXBwaW5nJywgcGFyYW1ldGVycy50b25lTWFwcGluZyApIDogJycsXFxuXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5kaXRoZXJpbmcgPyAnI2RlZmluZSBESVRIRVJJTkcnIDogJycsXFxuXFxuXFx0XFx0XFx0XFx0KCBwYXJhbWV0ZXJzLm91dHB1dEVuY29kaW5nIHx8IHBhcmFtZXRlcnMubWFwRW5jb2RpbmcgfHwgcGFyYW1ldGVycy5lbnZNYXBFbmNvZGluZyB8fCBwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwRW5jb2RpbmcgKSA/IFNoYWRlckNodW5rWyAnZW5jb2RpbmdzX3BhcnNfZnJhZ21lbnQnIF0gOiAnJywgLy8gdGhpcyBjb2RlIGlzIHJlcXVpcmVkIGhlcmUgYmVjYXVzZSBpdCBpcyB1c2VkIGJ5IHRoZSB2YXJpb3VzIGVuY29kaW5nL2RlY29kaW5nIGZ1bmN0aW9uIGRlZmluZWQgYmVsb3dcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLm1hcEVuY29kaW5nID8gZ2V0VGV4ZWxEZWNvZGluZ0Z1bmN0aW9uKCAnbWFwVGV4ZWxUb0xpbmVhcicsIHBhcmFtZXRlcnMubWFwRW5jb2RpbmcgKSA6ICcnLFxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuZW52TWFwRW5jb2RpbmcgPyBnZXRUZXhlbERlY29kaW5nRnVuY3Rpb24oICdlbnZNYXBUZXhlbFRvTGluZWFyJywgcGFyYW1ldGVycy5lbnZNYXBFbmNvZGluZyApIDogJycsXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5lbWlzc2l2ZU1hcEVuY29kaW5nID8gZ2V0VGV4ZWxEZWNvZGluZ0Z1bmN0aW9uKCAnZW1pc3NpdmVNYXBUZXhlbFRvTGluZWFyJywgcGFyYW1ldGVycy5lbWlzc2l2ZU1hcEVuY29kaW5nICkgOiAnJyxcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLm91dHB1dEVuY29kaW5nID8gZ2V0VGV4ZWxFbmNvZGluZ0Z1bmN0aW9uKCAnbGluZWFyVG9PdXRwdXRUZXhlbCcsIHBhcmFtZXRlcnMub3V0cHV0RW5jb2RpbmcgKSA6ICcnLFxcblxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuZGVwdGhQYWNraW5nID8gJyNkZWZpbmUgREVQVEhfUEFDS0lORyAnICsgbWF0ZXJpYWwuZGVwdGhQYWNraW5nIDogJycsXFxuXFxuXFx0XFx0XFx0XFx0J1xcXFxuJ1xcblxcblxcdFxcdFxcdF0uZmlsdGVyKCBmaWx0ZXJFbXB0eUxpbmUgKS5qb2luKCAnXFxcXG4nICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHZlcnRleFNoYWRlciA9IHBhcnNlSW5jbHVkZXMoIHZlcnRleFNoYWRlciApO1xcblxcdFxcdHZlcnRleFNoYWRlciA9IHJlcGxhY2VMaWdodE51bXMoIHZlcnRleFNoYWRlciwgcGFyYW1ldGVycyApO1xcblxcblxcdFxcdGZyYWdtZW50U2hhZGVyID0gcGFyc2VJbmNsdWRlcyggZnJhZ21lbnRTaGFkZXIgKTtcXG5cXHRcXHRmcmFnbWVudFNoYWRlciA9IHJlcGxhY2VMaWdodE51bXMoIGZyYWdtZW50U2hhZGVyLCBwYXJhbWV0ZXJzICk7XFxuXFxuXFx0XFx0aWYgKCAhIG1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0dmVydGV4U2hhZGVyID0gdW5yb2xsTG9vcHMoIHZlcnRleFNoYWRlciApO1xcblxcdFxcdFxcdGZyYWdtZW50U2hhZGVyID0gdW5yb2xsTG9vcHMoIGZyYWdtZW50U2hhZGVyICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHZhciB2ZXJ0ZXhHbHNsID0gcHJlZml4VmVydGV4ICsgdmVydGV4U2hhZGVyO1xcblxcdFxcdHZhciBmcmFnbWVudEdsc2wgPSBwcmVmaXhGcmFnbWVudCArIGZyYWdtZW50U2hhZGVyO1xcblxcblxcdFxcdC8vIGNvbnNvbGUubG9nKCAnKlZFUlRFWConLCB2ZXJ0ZXhHbHNsICk7XFxuXFx0XFx0Ly8gY29uc29sZS5sb2coICcqRlJBR01FTlQqJywgZnJhZ21lbnRHbHNsICk7XFxuXFxuXFx0XFx0dmFyIGdsVmVydGV4U2hhZGVyID0gV2ViR0xTaGFkZXIoIGdsLCBnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhHbHNsICk7XFxuXFx0XFx0dmFyIGdsRnJhZ21lbnRTaGFkZXIgPSBXZWJHTFNoYWRlciggZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ21lbnRHbHNsICk7XFxuXFxuXFx0XFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBnbFZlcnRleFNoYWRlciApO1xcblxcdFxcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZ2xGcmFnbWVudFNoYWRlciApO1xcblxcblxcdFxcdC8vIEZvcmNlIGEgcGFydGljdWxhciBhdHRyaWJ1dGUgdG8gaW5kZXggMC5cXG5cXG5cXHRcXHRpZiAoIG1hdGVyaWFsLmluZGV4MEF0dHJpYnV0ZU5hbWUgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRnbC5iaW5kQXR0cmliTG9jYXRpb24oIHByb2dyYW0sIDAsIG1hdGVyaWFsLmluZGV4MEF0dHJpYnV0ZU5hbWUgKTtcXG5cXG5cXHRcXHR9IGVsc2UgaWYgKCBwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0cyA9PT0gdHJ1ZSApIHtcXG5cXG5cXHRcXHRcXHQvLyBwcm9ncmFtcyB3aXRoIG1vcnBoVGFyZ2V0cyBkaXNwbGFjZSBwb3NpdGlvbiBvdXQgb2YgYXR0cmlidXRlIDBcXG5cXHRcXHRcXHRnbC5iaW5kQXR0cmliTG9jYXRpb24oIHByb2dyYW0sIDAsICdwb3NpdGlvbicgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Z2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcXG5cXG5cXHRcXHR2YXIgcHJvZ3JhbUxvZyA9IGdsLmdldFByb2dyYW1JbmZvTG9nKCBwcm9ncmFtICk7XFxuXFx0XFx0dmFyIHZlcnRleExvZyA9IGdsLmdldFNoYWRlckluZm9Mb2coIGdsVmVydGV4U2hhZGVyICk7XFxuXFx0XFx0dmFyIGZyYWdtZW50TG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyggZ2xGcmFnbWVudFNoYWRlciApO1xcblxcblxcdFxcdHZhciBydW5uYWJsZSA9IHRydWU7XFxuXFx0XFx0dmFyIGhhdmVEaWFnbm9zdGljcyA9IHRydWU7XFxuXFxuXFx0XFx0Ly8gY29uc29sZS5sb2coICcqKlZFUlRFWCoqJywgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfZGVidWdfc2hhZGVycycgKS5nZXRUcmFuc2xhdGVkU2hhZGVyU291cmNlKCBnbFZlcnRleFNoYWRlciApICk7XFxuXFx0XFx0Ly8gY29uc29sZS5sb2coICcqKkZSQUdNRU5UKionLCBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9kZWJ1Z19zaGFkZXJzJyApLmdldFRyYW5zbGF0ZWRTaGFkZXJTb3VyY2UoIGdsRnJhZ21lbnRTaGFkZXIgKSApO1xcblxcblxcdFxcdGlmICggZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMgKSA9PT0gZmFsc2UgKSB7XFxuXFxuXFx0XFx0XFx0cnVubmFibGUgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xQcm9ncmFtOiBzaGFkZXIgZXJyb3I6ICcsIGdsLmdldEVycm9yKCksICdnbC5WQUxJREFURV9TVEFUVVMnLCBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5WQUxJREFURV9TVEFUVVMgKSwgJ2dsLmdldFByb2dyYW1JbmZvTG9nJywgcHJvZ3JhbUxvZywgdmVydGV4TG9nLCBmcmFnbWVudExvZyApO1xcblxcblxcdFxcdH0gZWxzZSBpZiAoIHByb2dyYW1Mb2cgIT09ICcnICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbTogZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coKScsIHByb2dyYW1Mb2cgKTtcXG5cXG5cXHRcXHR9IGVsc2UgaWYgKCB2ZXJ0ZXhMb2cgPT09ICcnIHx8IGZyYWdtZW50TG9nID09PSAnJyApIHtcXG5cXG5cXHRcXHRcXHRoYXZlRGlhZ25vc3RpY3MgPSBmYWxzZTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBoYXZlRGlhZ25vc3RpY3MgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5kaWFnbm9zdGljcyA9IHtcXG5cXG5cXHRcXHRcXHRcXHRydW5uYWJsZTogcnVubmFibGUsXFxuXFx0XFx0XFx0XFx0bWF0ZXJpYWw6IG1hdGVyaWFsLFxcblxcblxcdFxcdFxcdFxcdHByb2dyYW1Mb2c6IHByb2dyYW1Mb2csXFxuXFxuXFx0XFx0XFx0XFx0dmVydGV4U2hhZGVyOiB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bG9nOiB2ZXJ0ZXhMb2csXFxuXFx0XFx0XFx0XFx0XFx0cHJlZml4OiBwcmVmaXhWZXJ0ZXhcXG5cXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdGZyYWdtZW50U2hhZGVyOiB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bG9nOiBmcmFnbWVudExvZyxcXG5cXHRcXHRcXHRcXHRcXHRwcmVmaXg6IHByZWZpeEZyYWdtZW50XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGNsZWFuIHVwXFxuXFxuXFx0XFx0Z2wuZGVsZXRlU2hhZGVyKCBnbFZlcnRleFNoYWRlciApO1xcblxcdFxcdGdsLmRlbGV0ZVNoYWRlciggZ2xGcmFnbWVudFNoYWRlciApO1xcblxcblxcdFxcdC8vIHNldCB1cCBjYWNoaW5nIGZvciB1bmlmb3JtIGxvY2F0aW9uc1xcblxcblxcdFxcdHZhciBjYWNoZWRVbmlmb3JtcztcXG5cXG5cXHRcXHR0aGlzLmdldFVuaWZvcm1zID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGlmICggY2FjaGVkVW5pZm9ybXMgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjYWNoZWRVbmlmb3JtcyA9IG5ldyBXZWJHTFVuaWZvcm1zKCBnbCwgcHJvZ3JhbSwgcmVuZGVyZXIgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGNhY2hlZFVuaWZvcm1zO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gc2V0IHVwIGNhY2hpbmcgZm9yIGF0dHJpYnV0ZSBsb2NhdGlvbnNcXG5cXG5cXHRcXHR2YXIgY2FjaGVkQXR0cmlidXRlcztcXG5cXG5cXHRcXHR0aGlzLmdldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBjYWNoZWRBdHRyaWJ1dGVzID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y2FjaGVkQXR0cmlidXRlcyA9IGZldGNoQXR0cmlidXRlTG9jYXRpb25zKCBnbCwgcHJvZ3JhbSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gY2FjaGVkQXR0cmlidXRlcztcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIGZyZWUgcmVzb3VyY2VcXG5cXG5cXHRcXHR0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Z2wuZGVsZXRlUHJvZ3JhbSggcHJvZ3JhbSApO1xcblxcdFxcdFxcdHRoaXMucHJvZ3JhbSA9IHVuZGVmaW5lZDtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIERFUFJFQ0FURURcXG5cXG5cXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xcblxcblxcdFxcdFxcdHVuaWZvcm1zOiB7XFxuXFx0XFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xQcm9ncmFtOiAudW5pZm9ybXMgaXMgbm93IC5nZXRVbmlmb3JtcygpLicgKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5nZXRVbmlmb3JtcygpO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdGF0dHJpYnV0ZXM6IHtcXG5cXHRcXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW06IC5hdHRyaWJ1dGVzIGlzIG5vdyAuZ2V0QXR0cmlidXRlcygpLicgKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGVzKCk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9ICk7XFxuXFxuXFxuXFx0XFx0Ly9cXG5cXG5cXHRcXHR0aGlzLmlkID0gcHJvZ3JhbUlkQ291bnQgKys7XFxuXFx0XFx0dGhpcy5jb2RlID0gY29kZTtcXG5cXHRcXHR0aGlzLnVzZWRUaW1lcyA9IDE7XFxuXFx0XFx0dGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcXG5cXHRcXHR0aGlzLnZlcnRleFNoYWRlciA9IGdsVmVydGV4U2hhZGVyO1xcblxcdFxcdHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBnbEZyYWdtZW50U2hhZGVyO1xcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdH1cXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFdlYkdMUHJvZ3JhbXMoIHJlbmRlcmVyLCBleHRlbnNpb25zLCBjYXBhYmlsaXRpZXMgKSB7XFxuXFxuXFx0XFx0dmFyIHByb2dyYW1zID0gW107XFxuXFxuXFx0XFx0dmFyIHNoYWRlcklEcyA9IHtcXG5cXHRcXHRcXHRNZXNoRGVwdGhNYXRlcmlhbDogJ2RlcHRoJyxcXG5cXHRcXHRcXHRNZXNoRGlzdGFuY2VNYXRlcmlhbDogJ2Rpc3RhbmNlUkdCQScsXFxuXFx0XFx0XFx0TWVzaE5vcm1hbE1hdGVyaWFsOiAnbm9ybWFsJyxcXG5cXHRcXHRcXHRNZXNoQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcXG5cXHRcXHRcXHRNZXNoTGFtYmVydE1hdGVyaWFsOiAnbGFtYmVydCcsXFxuXFx0XFx0XFx0TWVzaFBob25nTWF0ZXJpYWw6ICdwaG9uZycsXFxuXFx0XFx0XFx0TWVzaFRvb25NYXRlcmlhbDogJ3Bob25nJyxcXG5cXHRcXHRcXHRNZXNoU3RhbmRhcmRNYXRlcmlhbDogJ3BoeXNpY2FsJyxcXG5cXHRcXHRcXHRNZXNoUGh5c2ljYWxNYXRlcmlhbDogJ3BoeXNpY2FsJyxcXG5cXHRcXHRcXHRMaW5lQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcXG5cXHRcXHRcXHRMaW5lRGFzaGVkTWF0ZXJpYWw6ICdkYXNoZWQnLFxcblxcdFxcdFxcdFBvaW50c01hdGVyaWFsOiAncG9pbnRzJyxcXG5cXHRcXHRcXHRTaGFkb3dNYXRlcmlhbDogJ3NoYWRvdydcXG5cXHRcXHR9O1xcblxcblxcdFxcdHZhciBwYXJhbWV0ZXJOYW1lcyA9IFtcXG5cXHRcXHRcXHRcXFwicHJlY2lzaW9uXFxcIiwgXFxcInN1cHBvcnRzVmVydGV4VGV4dHVyZXNcXFwiLCBcXFwibWFwXFxcIiwgXFxcIm1hcEVuY29kaW5nXFxcIiwgXFxcImVudk1hcFxcXCIsIFxcXCJlbnZNYXBNb2RlXFxcIiwgXFxcImVudk1hcEVuY29kaW5nXFxcIixcXG5cXHRcXHRcXHRcXFwibGlnaHRNYXBcXFwiLCBcXFwiYW9NYXBcXFwiLCBcXFwiZW1pc3NpdmVNYXBcXFwiLCBcXFwiZW1pc3NpdmVNYXBFbmNvZGluZ1xcXCIsIFxcXCJidW1wTWFwXFxcIiwgXFxcIm5vcm1hbE1hcFxcXCIsIFxcXCJkaXNwbGFjZW1lbnRNYXBcXFwiLCBcXFwic3BlY3VsYXJNYXBcXFwiLFxcblxcdFxcdFxcdFxcXCJyb3VnaG5lc3NNYXBcXFwiLCBcXFwibWV0YWxuZXNzTWFwXFxcIiwgXFxcImdyYWRpZW50TWFwXFxcIixcXG5cXHRcXHRcXHRcXFwiYWxwaGFNYXBcXFwiLCBcXFwiY29tYmluZVxcXCIsIFxcXCJ2ZXJ0ZXhDb2xvcnNcXFwiLCBcXFwiZm9nXFxcIiwgXFxcInVzZUZvZ1xcXCIsIFxcXCJmb2dFeHBcXFwiLFxcblxcdFxcdFxcdFxcXCJmbGF0U2hhZGluZ1xcXCIsIFxcXCJzaXplQXR0ZW51YXRpb25cXFwiLCBcXFwibG9nYXJpdGhtaWNEZXB0aEJ1ZmZlclxcXCIsIFxcXCJza2lubmluZ1xcXCIsXFxuXFx0XFx0XFx0XFxcIm1heEJvbmVzXFxcIiwgXFxcInVzZVZlcnRleFRleHR1cmVcXFwiLCBcXFwibW9ycGhUYXJnZXRzXFxcIiwgXFxcIm1vcnBoTm9ybWFsc1xcXCIsXFxuXFx0XFx0XFx0XFxcIm1heE1vcnBoVGFyZ2V0c1xcXCIsIFxcXCJtYXhNb3JwaE5vcm1hbHNcXFwiLCBcXFwicHJlbXVsdGlwbGllZEFscGhhXFxcIixcXG5cXHRcXHRcXHRcXFwibnVtRGlyTGlnaHRzXFxcIiwgXFxcIm51bVBvaW50TGlnaHRzXFxcIiwgXFxcIm51bVNwb3RMaWdodHNcXFwiLCBcXFwibnVtSGVtaUxpZ2h0c1xcXCIsIFxcXCJudW1SZWN0QXJlYUxpZ2h0c1xcXCIsXFxuXFx0XFx0XFx0XFxcInNoYWRvd01hcEVuYWJsZWRcXFwiLCBcXFwic2hhZG93TWFwVHlwZVxcXCIsIFxcXCJ0b25lTWFwcGluZ1xcXCIsICdwaHlzaWNhbGx5Q29ycmVjdExpZ2h0cycsXFxuXFx0XFx0XFx0XFxcImFscGhhVGVzdFxcXCIsIFxcXCJkb3VibGVTaWRlZFxcXCIsIFxcXCJmbGlwU2lkZWRcXFwiLCBcXFwibnVtQ2xpcHBpbmdQbGFuZXNcXFwiLCBcXFwibnVtQ2xpcEludGVyc2VjdGlvblxcXCIsIFxcXCJkZXB0aFBhY2tpbmdcXFwiLCBcXFwiZGl0aGVyaW5nXFxcIlxcblxcdFxcdF07XFxuXFxuXFxuXFx0XFx0ZnVuY3Rpb24gYWxsb2NhdGVCb25lcyggb2JqZWN0ICkge1xcblxcblxcdFxcdFxcdHZhciBza2VsZXRvbiA9IG9iamVjdC5za2VsZXRvbjtcXG5cXHRcXHRcXHR2YXIgYm9uZXMgPSBza2VsZXRvbi5ib25lcztcXG5cXG5cXHRcXHRcXHRpZiAoIGNhcGFiaWxpdGllcy5mbG9hdFZlcnRleFRleHR1cmVzICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiAxMDI0O1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gZGVmYXVsdCBmb3Igd2hlbiBvYmplY3QgaXMgbm90IHNwZWNpZmllZFxcblxcdFxcdFxcdFxcdC8vICggZm9yIGV4YW1wbGUgd2hlbiBwcmVidWlsZGluZyBzaGFkZXIgdG8gYmUgdXNlZCB3aXRoIG11bHRpcGxlIG9iamVjdHMgKVxcblxcdFxcdFxcdFxcdC8vXFxuXFx0XFx0XFx0XFx0Ly8gIC0gbGVhdmUgc29tZSBleHRyYSBzcGFjZSBmb3Igb3RoZXIgdW5pZm9ybXNcXG5cXHRcXHRcXHRcXHQvLyAgLSBsaW1pdCBoZXJlIGlzIEFOR0xFJ3MgMjU0IG1heCB1bmlmb3JtIHZlY3RvcnNcXG5cXHRcXHRcXHRcXHQvLyAgICAodXAgdG8gNTQgc2hvdWxkIGJlIHNhZmUpXFxuXFxuXFx0XFx0XFx0XFx0dmFyIG5WZXJ0ZXhVbmlmb3JtcyA9IGNhcGFiaWxpdGllcy5tYXhWZXJ0ZXhVbmlmb3JtcztcXG5cXHRcXHRcXHRcXHR2YXIgblZlcnRleE1hdHJpY2VzID0gTWF0aC5mbG9vciggKCBuVmVydGV4VW5pZm9ybXMgLSAyMCApIC8gNCApO1xcblxcblxcdFxcdFxcdFxcdHZhciBtYXhCb25lcyA9IE1hdGgubWluKCBuVmVydGV4TWF0cmljZXMsIGJvbmVzLmxlbmd0aCApO1xcblxcblxcdFxcdFxcdFxcdGlmICggbWF4Qm9uZXMgPCBib25lcy5sZW5ndGggKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogU2tlbGV0b24gaGFzICcgKyBib25lcy5sZW5ndGggKyAnIGJvbmVzLiBUaGlzIEdQVSBzdXBwb3J0cyAnICsgbWF4Qm9uZXMgKyAnLicgKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gMDtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIG1heEJvbmVzO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gZ2V0VGV4dHVyZUVuY29kaW5nRnJvbU1hcCggbWFwLCBnYW1tYU92ZXJyaWRlTGluZWFyICkge1xcblxcblxcdFxcdFxcdHZhciBlbmNvZGluZztcXG5cXG5cXHRcXHRcXHRpZiAoICEgbWFwICkge1xcblxcblxcdFxcdFxcdFxcdGVuY29kaW5nID0gTGluZWFyRW5jb2Rpbmc7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggbWFwLmlzVGV4dHVyZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRlbmNvZGluZyA9IG1hcC5lbmNvZGluZztcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXAuaXNXZWJHTFJlbmRlclRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oIFxcXCJUSFJFRS5XZWJHTFByb2dyYW1zLmdldFRleHR1cmVFbmNvZGluZ0Zyb21NYXA6IGRvbid0IHVzZSByZW5kZXIgdGFyZ2V0cyBhcyB0ZXh0dXJlcy4gVXNlIHRoZWlyIC50ZXh0dXJlIHByb3BlcnR5IGluc3RlYWQuXFxcIiApO1xcblxcdFxcdFxcdFxcdGVuY29kaW5nID0gbWFwLnRleHR1cmUuZW5jb2Rpbmc7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGFkZCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgV2ViR0xSZW5kZXJlci5nYW1tYUlucHV0L2dhbW1hT3V0cHV0IHBhcmFtZXRlciwgc2hvdWxkIHByb2JhYmx5IGJlIHJlbW92ZWQgYXQgc29tZSBwb2ludC5cXG5cXHRcXHRcXHRpZiAoIGVuY29kaW5nID09PSBMaW5lYXJFbmNvZGluZyAmJiBnYW1tYU92ZXJyaWRlTGluZWFyICkge1xcblxcblxcdFxcdFxcdFxcdGVuY29kaW5nID0gR2FtbWFFbmNvZGluZztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGVuY29kaW5nO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLmdldFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoIG1hdGVyaWFsLCBsaWdodHMsIHNoYWRvd3MsIGZvZywgbkNsaXBQbGFuZXMsIG5DbGlwSW50ZXJzZWN0aW9uLCBvYmplY3QgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHNoYWRlcklEID0gc2hhZGVySURzWyBtYXRlcmlhbC50eXBlIF07XFxuXFxuXFx0XFx0XFx0Ly8gaGV1cmlzdGljcyB0byBjcmVhdGUgc2hhZGVyIHBhcmFtZXRlcnMgYWNjb3JkaW5nIHRvIGxpZ2h0cyBpbiB0aGUgc2NlbmVcXG5cXHRcXHRcXHQvLyAobm90IHRvIGJsb3cgb3ZlciBtYXhMaWdodHMgYnVkZ2V0KVxcblxcblxcdFxcdFxcdHZhciBtYXhCb25lcyA9IG9iamVjdC5pc1NraW5uZWRNZXNoID8gYWxsb2NhdGVCb25lcyggb2JqZWN0ICkgOiAwO1xcblxcdFxcdFxcdHZhciBwcmVjaXNpb24gPSBjYXBhYmlsaXRpZXMucHJlY2lzaW9uO1xcblxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwucHJlY2lzaW9uICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdHByZWNpc2lvbiA9IGNhcGFiaWxpdGllcy5nZXRNYXhQcmVjaXNpb24oIG1hdGVyaWFsLnByZWNpc2lvbiApO1xcblxcblxcdFxcdFxcdFxcdGlmICggcHJlY2lzaW9uICE9PSBtYXRlcmlhbC5wcmVjaXNpb24gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xQcm9ncmFtLmdldFBhcmFtZXRlcnM6JywgbWF0ZXJpYWwucHJlY2lzaW9uLCAnbm90IHN1cHBvcnRlZCwgdXNpbmcnLCBwcmVjaXNpb24sICdpbnN0ZWFkLicgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBjdXJyZW50UmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XFxuXFxuXFx0XFx0XFx0dmFyIHBhcmFtZXRlcnMgPSB7XFxuXFxuXFx0XFx0XFx0XFx0c2hhZGVySUQ6IHNoYWRlcklELFxcblxcblxcdFxcdFxcdFxcdHByZWNpc2lvbjogcHJlY2lzaW9uLFxcblxcdFxcdFxcdFxcdHN1cHBvcnRzVmVydGV4VGV4dHVyZXM6IGNhcGFiaWxpdGllcy52ZXJ0ZXhUZXh0dXJlcyxcXG5cXHRcXHRcXHRcXHRvdXRwdXRFbmNvZGluZzogZ2V0VGV4dHVyZUVuY29kaW5nRnJvbU1hcCggKCAhIGN1cnJlbnRSZW5kZXJUYXJnZXQgKSA/IG51bGwgOiBjdXJyZW50UmVuZGVyVGFyZ2V0LnRleHR1cmUsIHJlbmRlcmVyLmdhbW1hT3V0cHV0ICksXFxuXFx0XFx0XFx0XFx0bWFwOiAhISBtYXRlcmlhbC5tYXAsXFxuXFx0XFx0XFx0XFx0bWFwRW5jb2Rpbmc6IGdldFRleHR1cmVFbmNvZGluZ0Zyb21NYXAoIG1hdGVyaWFsLm1hcCwgcmVuZGVyZXIuZ2FtbWFJbnB1dCApLFxcblxcdFxcdFxcdFxcdGVudk1hcDogISEgbWF0ZXJpYWwuZW52TWFwLFxcblxcdFxcdFxcdFxcdGVudk1hcE1vZGU6IG1hdGVyaWFsLmVudk1hcCAmJiBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyxcXG5cXHRcXHRcXHRcXHRlbnZNYXBFbmNvZGluZzogZ2V0VGV4dHVyZUVuY29kaW5nRnJvbU1hcCggbWF0ZXJpYWwuZW52TWFwLCByZW5kZXJlci5nYW1tYUlucHV0ICksXFxuXFx0XFx0XFx0XFx0ZW52TWFwQ3ViZVVWOiAoICEhIG1hdGVyaWFsLmVudk1hcCApICYmICggKCBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyA9PT0gQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmcgKSB8fCAoIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nID09PSBDdWJlVVZSZWZyYWN0aW9uTWFwcGluZyApICksXFxuXFx0XFx0XFx0XFx0bGlnaHRNYXA6ICEhIG1hdGVyaWFsLmxpZ2h0TWFwLFxcblxcdFxcdFxcdFxcdGFvTWFwOiAhISBtYXRlcmlhbC5hb01hcCxcXG5cXHRcXHRcXHRcXHRlbWlzc2l2ZU1hcDogISEgbWF0ZXJpYWwuZW1pc3NpdmVNYXAsXFxuXFx0XFx0XFx0XFx0ZW1pc3NpdmVNYXBFbmNvZGluZzogZ2V0VGV4dHVyZUVuY29kaW5nRnJvbU1hcCggbWF0ZXJpYWwuZW1pc3NpdmVNYXAsIHJlbmRlcmVyLmdhbW1hSW5wdXQgKSxcXG5cXHRcXHRcXHRcXHRidW1wTWFwOiAhISBtYXRlcmlhbC5idW1wTWFwLFxcblxcdFxcdFxcdFxcdG5vcm1hbE1hcDogISEgbWF0ZXJpYWwubm9ybWFsTWFwLFxcblxcdFxcdFxcdFxcdGRpc3BsYWNlbWVudE1hcDogISEgbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwLFxcblxcdFxcdFxcdFxcdHJvdWdobmVzc01hcDogISEgbWF0ZXJpYWwucm91Z2huZXNzTWFwLFxcblxcdFxcdFxcdFxcdG1ldGFsbmVzc01hcDogISEgbWF0ZXJpYWwubWV0YWxuZXNzTWFwLFxcblxcdFxcdFxcdFxcdHNwZWN1bGFyTWFwOiAhISBtYXRlcmlhbC5zcGVjdWxhck1hcCxcXG5cXHRcXHRcXHRcXHRhbHBoYU1hcDogISEgbWF0ZXJpYWwuYWxwaGFNYXAsXFxuXFxuXFx0XFx0XFx0XFx0Z3JhZGllbnRNYXA6ICEhIG1hdGVyaWFsLmdyYWRpZW50TWFwLFxcblxcblxcdFxcdFxcdFxcdGNvbWJpbmU6IG1hdGVyaWFsLmNvbWJpbmUsXFxuXFxuXFx0XFx0XFx0XFx0dmVydGV4Q29sb3JzOiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMsXFxuXFxuXFx0XFx0XFx0XFx0Zm9nOiAhISBmb2csXFxuXFx0XFx0XFx0XFx0dXNlRm9nOiBtYXRlcmlhbC5mb2csXFxuXFx0XFx0XFx0XFx0Zm9nRXhwOiAoIGZvZyAmJiBmb2cuaXNGb2dFeHAyICksXFxuXFxuXFx0XFx0XFx0XFx0ZmxhdFNoYWRpbmc6IG1hdGVyaWFsLmZsYXRTaGFkaW5nLFxcblxcblxcdFxcdFxcdFxcdHNpemVBdHRlbnVhdGlvbjogbWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uLFxcblxcdFxcdFxcdFxcdGxvZ2FyaXRobWljRGVwdGhCdWZmZXI6IGNhcGFiaWxpdGllcy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyLFxcblxcblxcdFxcdFxcdFxcdHNraW5uaW5nOiBtYXRlcmlhbC5za2lubmluZyAmJiBtYXhCb25lcyA+IDAsXFxuXFx0XFx0XFx0XFx0bWF4Qm9uZXM6IG1heEJvbmVzLFxcblxcdFxcdFxcdFxcdHVzZVZlcnRleFRleHR1cmU6IGNhcGFiaWxpdGllcy5mbG9hdFZlcnRleFRleHR1cmVzLFxcblxcblxcdFxcdFxcdFxcdG1vcnBoVGFyZ2V0czogbWF0ZXJpYWwubW9ycGhUYXJnZXRzLFxcblxcdFxcdFxcdFxcdG1vcnBoTm9ybWFsczogbWF0ZXJpYWwubW9ycGhOb3JtYWxzLFxcblxcdFxcdFxcdFxcdG1heE1vcnBoVGFyZ2V0czogcmVuZGVyZXIubWF4TW9ycGhUYXJnZXRzLFxcblxcdFxcdFxcdFxcdG1heE1vcnBoTm9ybWFsczogcmVuZGVyZXIubWF4TW9ycGhOb3JtYWxzLFxcblxcblxcdFxcdFxcdFxcdG51bURpckxpZ2h0czogbGlnaHRzLmRpcmVjdGlvbmFsLmxlbmd0aCxcXG5cXHRcXHRcXHRcXHRudW1Qb2ludExpZ2h0czogbGlnaHRzLnBvaW50Lmxlbmd0aCxcXG5cXHRcXHRcXHRcXHRudW1TcG90TGlnaHRzOiBsaWdodHMuc3BvdC5sZW5ndGgsXFxuXFx0XFx0XFx0XFx0bnVtUmVjdEFyZWFMaWdodHM6IGxpZ2h0cy5yZWN0QXJlYS5sZW5ndGgsXFxuXFx0XFx0XFx0XFx0bnVtSGVtaUxpZ2h0czogbGlnaHRzLmhlbWkubGVuZ3RoLFxcblxcblxcdFxcdFxcdFxcdG51bUNsaXBwaW5nUGxhbmVzOiBuQ2xpcFBsYW5lcyxcXG5cXHRcXHRcXHRcXHRudW1DbGlwSW50ZXJzZWN0aW9uOiBuQ2xpcEludGVyc2VjdGlvbixcXG5cXG5cXHRcXHRcXHRcXHRkaXRoZXJpbmc6IG1hdGVyaWFsLmRpdGhlcmluZyxcXG5cXG5cXHRcXHRcXHRcXHRzaGFkb3dNYXBFbmFibGVkOiByZW5kZXJlci5zaGFkb3dNYXAuZW5hYmxlZCAmJiBvYmplY3QucmVjZWl2ZVNoYWRvdyAmJiBzaGFkb3dzLmxlbmd0aCA+IDAsXFxuXFx0XFx0XFx0XFx0c2hhZG93TWFwVHlwZTogcmVuZGVyZXIuc2hhZG93TWFwLnR5cGUsXFxuXFxuXFx0XFx0XFx0XFx0dG9uZU1hcHBpbmc6IHJlbmRlcmVyLnRvbmVNYXBwaW5nLFxcblxcdFxcdFxcdFxcdHBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzOiByZW5kZXJlci5waHlzaWNhbGx5Q29ycmVjdExpZ2h0cyxcXG5cXG5cXHRcXHRcXHRcXHRwcmVtdWx0aXBsaWVkQWxwaGE6IG1hdGVyaWFsLnByZW11bHRpcGxpZWRBbHBoYSxcXG5cXG5cXHRcXHRcXHRcXHRhbHBoYVRlc3Q6IG1hdGVyaWFsLmFscGhhVGVzdCxcXG5cXHRcXHRcXHRcXHRkb3VibGVTaWRlZDogbWF0ZXJpYWwuc2lkZSA9PT0gRG91YmxlU2lkZSxcXG5cXHRcXHRcXHRcXHRmbGlwU2lkZWQ6IG1hdGVyaWFsLnNpZGUgPT09IEJhY2tTaWRlLFxcblxcblxcdFxcdFxcdFxcdGRlcHRoUGFja2luZzogKCBtYXRlcmlhbC5kZXB0aFBhY2tpbmcgIT09IHVuZGVmaW5lZCApID8gbWF0ZXJpYWwuZGVwdGhQYWNraW5nIDogZmFsc2VcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdHJldHVybiBwYXJhbWV0ZXJzO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5nZXRQcm9ncmFtQ29kZSA9IGZ1bmN0aW9uICggbWF0ZXJpYWwsIHBhcmFtZXRlcnMgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGFycmF5ID0gW107XFxuXFxuXFx0XFx0XFx0aWYgKCBwYXJhbWV0ZXJzLnNoYWRlcklEICkge1xcblxcblxcdFxcdFxcdFxcdGFycmF5LnB1c2goIHBhcmFtZXRlcnMuc2hhZGVySUQgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdGFycmF5LnB1c2goIG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyICk7XFxuXFx0XFx0XFx0XFx0YXJyYXkucHVzaCggbWF0ZXJpYWwudmVydGV4U2hhZGVyICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwuZGVmaW5lcyAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBuYW1lIGluIG1hdGVyaWFsLmRlZmluZXMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YXJyYXkucHVzaCggbmFtZSApO1xcblxcdFxcdFxcdFxcdFxcdGFycmF5LnB1c2goIG1hdGVyaWFsLmRlZmluZXNbIG5hbWUgXSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgcGFyYW1ldGVyTmFtZXMubGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdGFycmF5LnB1c2goIHBhcmFtZXRlcnNbIHBhcmFtZXRlck5hbWVzWyBpIF0gXSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRhcnJheS5wdXNoKCBtYXRlcmlhbC5vbkJlZm9yZUNvbXBpbGUudG9TdHJpbmcoKSApO1xcblxcblxcdFxcdFxcdGFycmF5LnB1c2goIHJlbmRlcmVyLmdhbW1hT3V0cHV0ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGFycmF5LmpvaW4oKTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuYWNxdWlyZVByb2dyYW0gPSBmdW5jdGlvbiAoIG1hdGVyaWFsLCBzaGFkZXIsIHBhcmFtZXRlcnMsIGNvZGUgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHByb2dyYW07XFxuXFxuXFx0XFx0XFx0Ly8gQ2hlY2sgaWYgY29kZSBoYXMgYmVlbiBhbHJlYWR5IGNvbXBpbGVkXFxuXFx0XFx0XFx0Zm9yICggdmFyIHAgPSAwLCBwbCA9IHByb2dyYW1zLmxlbmd0aDsgcCA8IHBsOyBwICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBwcm9ncmFtSW5mbyA9IHByb2dyYW1zWyBwIF07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBwcm9ncmFtSW5mby5jb2RlID09PSBjb2RlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHByb2dyYW0gPSBwcm9ncmFtSW5mbztcXG5cXHRcXHRcXHRcXHRcXHQrKyBwcm9ncmFtLnVzZWRUaW1lcztcXG5cXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdHByb2dyYW0gPSBuZXcgV2ViR0xQcm9ncmFtKCByZW5kZXJlciwgZXh0ZW5zaW9ucywgY29kZSwgbWF0ZXJpYWwsIHNoYWRlciwgcGFyYW1ldGVycyApO1xcblxcdFxcdFxcdFxcdHByb2dyYW1zLnB1c2goIHByb2dyYW0gKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHByb2dyYW07XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGlzLnJlbGVhc2VQcm9ncmFtID0gZnVuY3Rpb24gKCBwcm9ncmFtICkge1xcblxcblxcdFxcdFxcdGlmICggLS0gcHJvZ3JhbS51c2VkVGltZXMgPT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gUmVtb3ZlIGZyb20gdW5vcmRlcmVkIHNldFxcblxcdFxcdFxcdFxcdHZhciBpID0gcHJvZ3JhbXMuaW5kZXhPZiggcHJvZ3JhbSApO1xcblxcdFxcdFxcdFxcdHByb2dyYW1zWyBpIF0gPSBwcm9ncmFtc1sgcHJvZ3JhbXMubGVuZ3RoIC0gMSBdO1xcblxcdFxcdFxcdFxcdHByb2dyYW1zLnBvcCgpO1xcblxcblxcdFxcdFxcdFxcdC8vIEZyZWUgV2ViR0wgcmVzb3VyY2VzXFxuXFx0XFx0XFx0XFx0cHJvZ3JhbS5kZXN0cm95KCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gRXhwb3NlZCBmb3IgcmVzb3VyY2UgbW9uaXRvcmluZyAmIGVycm9yIGZlZWRiYWNrIHZpYSByZW5kZXJlci5pbmZvOlxcblxcdFxcdHRoaXMucHJvZ3JhbXMgPSBwcm9ncmFtcztcXG5cXG5cXHR9XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBXZWJHTFRleHR1cmVzKCBfZ2wsIGV4dGVuc2lvbnMsIHN0YXRlLCBwcm9wZXJ0aWVzLCBjYXBhYmlsaXRpZXMsIHV0aWxzLCBpbmZvTWVtb3J5ICkge1xcblxcblxcdFxcdHZhciBfaXNXZWJHTDIgPSAoIHR5cGVvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0ICE9PSAndW5kZWZpbmVkJyAmJiBfZ2wgaW5zdGFuY2VvZiB3aW5kb3cuV2ViR0wyUmVuZGVyaW5nQ29udGV4dCApO1xcblxcdFxcdHZhciBfdmlkZW9UZXh0dXJlcyA9IHt9O1xcblxcblxcdFxcdC8vXFxuXFxuXFx0XFx0ZnVuY3Rpb24gY2xhbXBUb01heFNpemUoIGltYWdlLCBtYXhTaXplICkge1xcblxcblxcdFxcdFxcdGlmICggaW1hZ2Uud2lkdGggPiBtYXhTaXplIHx8IGltYWdlLmhlaWdodCA+IG1heFNpemUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gV2FybmluZzogU2NhbGluZyB0aHJvdWdoIHRoZSBjYW52YXMgd2lsbCBvbmx5IHdvcmsgd2l0aCBpbWFnZXMgdGhhdCB1c2VcXG5cXHRcXHRcXHRcXHQvLyBwcmVtdWx0aXBsaWVkIGFscGhhLlxcblxcblxcdFxcdFxcdFxcdHZhciBzY2FsZSA9IG1heFNpemUgLyBNYXRoLm1heCggaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCApO1xcblxcblxcdFxcdFxcdFxcdHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywgJ2NhbnZhcycgKTtcXG5cXHRcXHRcXHRcXHRjYW52YXMud2lkdGggPSBNYXRoLmZsb29yKCBpbWFnZS53aWR0aCAqIHNjYWxlICk7XFxuXFx0XFx0XFx0XFx0Y2FudmFzLmhlaWdodCA9IE1hdGguZmxvb3IoIGltYWdlLmhlaWdodCAqIHNjYWxlICk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xcblxcdFxcdFxcdFxcdGNvbnRleHQuZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0ICk7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogaW1hZ2UgaXMgdG9vIGJpZyAoJyArIGltYWdlLndpZHRoICsgJ3gnICsgaW1hZ2UuaGVpZ2h0ICsgJykuIFJlc2l6ZWQgdG8gJyArIGNhbnZhcy53aWR0aCArICd4JyArIGNhbnZhcy5oZWlnaHQsIGltYWdlICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNhbnZhcztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGltYWdlO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBpc1Bvd2VyT2ZUd28oIGltYWdlICkge1xcblxcblxcdFxcdFxcdHJldHVybiBfTWF0aC5pc1Bvd2VyT2ZUd28oIGltYWdlLndpZHRoICkgJiYgX01hdGguaXNQb3dlck9mVHdvKCBpbWFnZS5oZWlnaHQgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gbWFrZVBvd2VyT2ZUd28oIGltYWdlICkge1xcblxcblxcdFxcdFxcdGlmICggaW1hZ2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50IHx8IGltYWdlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgfHwgaW1hZ2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsICdjYW52YXMnICk7XFxuXFx0XFx0XFx0XFx0Y2FudmFzLndpZHRoID0gX01hdGguZmxvb3JQb3dlck9mVHdvKCBpbWFnZS53aWR0aCApO1xcblxcdFxcdFxcdFxcdGNhbnZhcy5oZWlnaHQgPSBfTWF0aC5mbG9vclBvd2VyT2ZUd28oIGltYWdlLmhlaWdodCApO1xcblxcblxcdFxcdFxcdFxcdHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcXG5cXHRcXHRcXHRcXHRjb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCApO1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IGltYWdlIGlzIG5vdCBwb3dlciBvZiB0d28gKCcgKyBpbWFnZS53aWR0aCArICd4JyArIGltYWdlLmhlaWdodCArICcpLiBSZXNpemVkIHRvICcgKyBjYW52YXMud2lkdGggKyAneCcgKyBjYW52YXMuaGVpZ2h0LCBpbWFnZSApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBjYW52YXM7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBpbWFnZTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gdGV4dHVyZU5lZWRzUG93ZXJPZlR3byggdGV4dHVyZSApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gKCB0ZXh0dXJlLndyYXBTICE9PSBDbGFtcFRvRWRnZVdyYXBwaW5nIHx8IHRleHR1cmUud3JhcFQgIT09IENsYW1wVG9FZGdlV3JhcHBpbmcgKSB8fFxcblxcdFxcdFxcdFxcdCggdGV4dHVyZS5taW5GaWx0ZXIgIT09IE5lYXJlc3RGaWx0ZXIgJiYgdGV4dHVyZS5taW5GaWx0ZXIgIT09IExpbmVhckZpbHRlciApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiB0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHMoIHRleHR1cmUsIGlzUG93ZXJPZlR3byApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgJiYgaXNQb3dlck9mVHdvICYmXFxuXFx0XFx0XFx0XFx0dGV4dHVyZS5taW5GaWx0ZXIgIT09IE5lYXJlc3RGaWx0ZXIgJiYgdGV4dHVyZS5taW5GaWx0ZXIgIT09IExpbmVhckZpbHRlcjtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gRmFsbGJhY2sgZmlsdGVycyBmb3Igbm9uLXBvd2VyLW9mLTIgdGV4dHVyZXNcXG5cXG5cXHRcXHRmdW5jdGlvbiBmaWx0ZXJGYWxsYmFjayggZiApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGYgPT09IE5lYXJlc3RGaWx0ZXIgfHwgZiA9PT0gTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgfHwgZiA9PT0gTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gX2dsLk5FQVJFU1Q7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBfZ2wuTElORUFSO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvL1xcblxcblxcdFxcdGZ1bmN0aW9uIG9uVGV4dHVyZURpc3Bvc2UoIGV2ZW50ICkge1xcblxcblxcdFxcdFxcdHZhciB0ZXh0dXJlID0gZXZlbnQudGFyZ2V0O1xcblxcblxcdFxcdFxcdHRleHR1cmUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XFxuXFxuXFx0XFx0XFx0ZGVhbGxvY2F0ZVRleHR1cmUoIHRleHR1cmUgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIHRleHR1cmUuaXNWaWRlb1RleHR1cmUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZGVsZXRlIF92aWRlb1RleHR1cmVzWyB0ZXh0dXJlLmlkIF07XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGluZm9NZW1vcnkudGV4dHVyZXMgLS07XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSggZXZlbnQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHJlbmRlclRhcmdldCA9IGV2ZW50LnRhcmdldDtcXG5cXG5cXHRcXHRcXHRyZW5kZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblJlbmRlclRhcmdldERpc3Bvc2UgKTtcXG5cXG5cXHRcXHRcXHRkZWFsbG9jYXRlUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcXG5cXG5cXHRcXHRcXHRpbmZvTWVtb3J5LnRleHR1cmVzIC0tO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvL1xcblxcblxcdFxcdGZ1bmN0aW9uIGRlYWxsb2NhdGVUZXh0dXJlKCB0ZXh0dXJlICkge1xcblxcblxcdFxcdFxcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XFxuXFxuXFx0XFx0XFx0aWYgKCB0ZXh0dXJlLmltYWdlICYmIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gY3ViZSB0ZXh0dXJlXFxuXFxuXFx0XFx0XFx0XFx0X2dsLmRlbGV0ZVRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdC8vIDJEIHRleHR1cmVcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xJbml0ID09PSB1bmRlZmluZWQgKSByZXR1cm47XFxuXFxuXFx0XFx0XFx0XFx0X2dsLmRlbGV0ZVRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIHJlbW92ZSBhbGwgd2ViZ2wgcHJvcGVydGllc1xcblxcdFxcdFxcdHByb3BlcnRpZXMucmVtb3ZlKCB0ZXh0dXJlICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGRlYWxsb2NhdGVSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcXG5cXHRcXHRcXHR2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKTtcXG5cXG5cXHRcXHRcXHRpZiAoICEgcmVuZGVyVGFyZ2V0ICkgcmV0dXJuO1xcblxcblxcdFxcdFxcdGlmICggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRfZ2wuZGVsZXRlVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlICkge1xcblxcblxcdFxcdFxcdFxcdHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuZGlzcG9zZSgpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHJlbmRlclRhcmdldC5pc1dlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdF9nbC5kZWxldGVGcmFtZWJ1ZmZlciggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSApO1xcblxcdFxcdFxcdFxcdFxcdGlmICggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIgKSBfZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlclsgaSBdICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0X2dsLmRlbGV0ZUZyYW1lYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciApO1xcblxcdFxcdFxcdFxcdGlmICggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIgKSBfZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRwcm9wZXJ0aWVzLnJlbW92ZSggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKTtcXG5cXHRcXHRcXHRwcm9wZXJ0aWVzLnJlbW92ZSggcmVuZGVyVGFyZ2V0ICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vXFxuXFxuXFxuXFxuXFx0XFx0ZnVuY3Rpb24gc2V0VGV4dHVyZTJEKCB0ZXh0dXJlLCBzbG90ICkge1xcblxcblxcdFxcdFxcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICk7XFxuXFxuXFx0XFx0XFx0aWYgKCB0ZXh0dXJlLnZlcnNpb24gPiAwICYmIHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiAhPT0gdGV4dHVyZS52ZXJzaW9uICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBpbWFnZSA9IHRleHR1cmUuaW1hZ2U7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBpbWFnZSA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgbWFya2VkIGZvciB1cGRhdGUgYnV0IGltYWdlIGlzIHVuZGVmaW5lZCcsIHRleHR1cmUgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBpbWFnZS5jb21wbGV0ZSA9PT0gZmFsc2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBtYXJrZWQgZm9yIHVwZGF0ZSBidXQgaW1hZ2UgaXMgaW5jb21wbGV0ZScsIHRleHR1cmUgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdHVwbG9hZFRleHR1cmUoIHRleHR1cmVQcm9wZXJ0aWVzLCB0ZXh0dXJlLCBzbG90ICk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xcblxcdFxcdFxcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gc2V0VGV4dHVyZUN1YmUoIHRleHR1cmUsIHNsb3QgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIHRleHR1cmUuaW1hZ2UubGVuZ3RoID09PSA2ICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggdGV4dHVyZS52ZXJzaW9uID4gMCAmJiB0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gIT09IHRleHR1cmUudmVyc2lvbiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoICEgdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgPSBfZ2wuY3JlYXRlVGV4dHVyZSgpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGluZm9NZW1vcnkudGV4dHVyZXMgKys7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmVQcm9wZXJ0aWVzLl9faW1hZ2VfX3dlYmdsVGV4dHVyZUN1YmUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0ZXh0dXJlLmZsaXBZICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGlzQ29tcHJlc3NlZCA9ICggdGV4dHVyZSAmJiB0ZXh0dXJlLmlzQ29tcHJlc3NlZFRleHR1cmUgKTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgaXNEYXRhVGV4dHVyZSA9ICggdGV4dHVyZS5pbWFnZVsgMCBdICYmIHRleHR1cmUuaW1hZ2VbIDAgXS5pc0RhdGFUZXh0dXJlICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGN1YmVJbWFnZSA9IFtdO1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCAhIGlzQ29tcHJlc3NlZCAmJiAhIGlzRGF0YVRleHR1cmUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y3ViZUltYWdlWyBpIF0gPSBjbGFtcFRvTWF4U2l6ZSggdGV4dHVyZS5pbWFnZVsgaSBdLCBjYXBhYmlsaXRpZXMubWF4Q3ViZW1hcFNpemUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGN1YmVJbWFnZVsgaSBdID0gaXNEYXRhVGV4dHVyZSA/IHRleHR1cmUuaW1hZ2VbIGkgXS5pbWFnZSA6IHRleHR1cmUuaW1hZ2VbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHZhciBpbWFnZSA9IGN1YmVJbWFnZVsgMCBdLFxcblxcdFxcdFxcdFxcdFxcdFxcdGlzUG93ZXJPZlR3b0ltYWdlID0gaXNQb3dlck9mVHdvKCBpbWFnZSApLFxcblxcdFxcdFxcdFxcdFxcdFxcdGdsRm9ybWF0ID0gdXRpbHMuY29udmVydCggdGV4dHVyZS5mb3JtYXQgKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRnbFR5cGUgPSB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlLnR5cGUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmUsIGlzUG93ZXJPZlR3b0ltYWdlICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoICEgaXNDb21wcmVzc2VkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggaXNEYXRhVGV4dHVyZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCwgZ2xGb3JtYXQsIGN1YmVJbWFnZVsgaSBdLndpZHRoLCBjdWJlSW1hZ2VbIGkgXS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGN1YmVJbWFnZVsgaSBdLmRhdGEgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgY3ViZUltYWdlWyBpIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgbWlwbWFwLCBtaXBtYXBzID0gY3ViZUltYWdlWyBpIF0ubWlwbWFwcztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gbWlwbWFwcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRtaXBtYXAgPSBtaXBtYXBzWyBqIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB0ZXh0dXJlLmZvcm1hdCAhPT0gUkdCQUZvcm1hdCAmJiB0ZXh0dXJlLmZvcm1hdCAhPT0gUkdCRm9ybWF0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggc3RhdGUuZ2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzKCkuaW5kZXhPZiggZ2xGb3JtYXQgKSA+IC0gMSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzdGF0ZS5jb21wcmVzc2VkVGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIGosIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIG1pcG1hcC5kYXRhICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAuc2V0VGV4dHVyZUN1YmUoKScgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHMoIHRleHR1cmUsIGlzUG93ZXJPZlR3b0ltYWdlICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0X2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gPSB0ZXh0dXJlLnZlcnNpb247XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0ZXh0dXJlLm9uVXBkYXRlICkgdGV4dHVyZS5vblVwZGF0ZSggdGV4dHVyZSApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xcblxcdFxcdFxcdFxcdFxcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHNldFRleHR1cmVDdWJlRHluYW1pYyggdGV4dHVyZSwgc2xvdCApIHtcXG5cXG5cXHRcXHRcXHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XFxuXFx0XFx0XFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHNldFRleHR1cmVQYXJhbWV0ZXJzKCB0ZXh0dXJlVHlwZSwgdGV4dHVyZSwgaXNQb3dlck9mVHdvSW1hZ2UgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGV4dGVuc2lvbjtcXG5cXG5cXHRcXHRcXHRpZiAoIGlzUG93ZXJPZlR3b0ltYWdlICkge1xcblxcblxcdFxcdFxcdFxcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9TLCB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlLndyYXBTICkgKTtcXG5cXHRcXHRcXHRcXHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfVCwgdXRpbHMuY29udmVydCggdGV4dHVyZS53cmFwVCApICk7XFxuXFxuXFx0XFx0XFx0XFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlLm1hZ0ZpbHRlciApICk7XFxuXFx0XFx0XFx0XFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlLm1pbkZpbHRlciApICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfUywgX2dsLkNMQU1QX1RPX0VER0UgKTtcXG5cXHRcXHRcXHRcXHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfVCwgX2dsLkNMQU1QX1RPX0VER0UgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHRleHR1cmUud3JhcFMgIT09IENsYW1wVG9FZGdlV3JhcHBpbmcgfHwgdGV4dHVyZS53cmFwVCAhPT0gQ2xhbXBUb0VkZ2VXcmFwcGluZyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGlzIG5vdCBwb3dlciBvZiB0d28uIFRleHR1cmUud3JhcFMgYW5kIFRleHR1cmUud3JhcFQgc2hvdWxkIGJlIHNldCB0byBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nLicsIHRleHR1cmUgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBmaWx0ZXJGYWxsYmFjayggdGV4dHVyZS5tYWdGaWx0ZXIgKSApO1xcblxcdFxcdFxcdFxcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZmlsdGVyRmFsbGJhY2soIHRleHR1cmUubWluRmlsdGVyICkgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHRleHR1cmUubWluRmlsdGVyICE9PSBOZWFyZXN0RmlsdGVyICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBMaW5lYXJGaWx0ZXIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBpcyBub3QgcG93ZXIgb2YgdHdvLiBUZXh0dXJlLm1pbkZpbHRlciBzaG91bGQgYmUgc2V0IHRvIFRIUkVFLk5lYXJlc3RGaWx0ZXIgb3IgVEhSRUUuTGluZWFyRmlsdGVyLicsIHRleHR1cmUgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xcblxcblxcdFxcdFxcdGlmICggZXh0ZW5zaW9uICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggdGV4dHVyZS50eXBlID09PSBGbG9hdFR5cGUgJiYgZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInICkgPT09IG51bGwgKSByZXR1cm47XFxuXFx0XFx0XFx0XFx0aWYgKCB0ZXh0dXJlLnR5cGUgPT09IEhhbGZGbG9hdFR5cGUgJiYgZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhcicgKSA9PT0gbnVsbCApIHJldHVybjtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHRleHR1cmUuYW5pc290cm9weSA+IDEgfHwgcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKS5fX2N1cnJlbnRBbmlzb3Ryb3B5ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdF9nbC50ZXhQYXJhbWV0ZXJmKCB0ZXh0dXJlVHlwZSwgZXh0ZW5zaW9uLlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhULCBNYXRoLm1pbiggdGV4dHVyZS5hbmlzb3Ryb3B5LCBjYXBhYmlsaXRpZXMuZ2V0TWF4QW5pc290cm9weSgpICkgKTtcXG5cXHRcXHRcXHRcXHRcXHRwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApLl9fY3VycmVudEFuaXNvdHJvcHkgPSB0ZXh0dXJlLmFuaXNvdHJvcHk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gdXBsb2FkVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUsIHNsb3QgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsSW5pdCA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xJbml0ID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHR0ZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xcblxcblxcdFxcdFxcdFxcdHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHRleHR1cmUuaXNWaWRlb1RleHR1cmUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0X3ZpZGVvVGV4dHVyZXNbIHRleHR1cmUuaWQgXSA9IHRleHR1cmU7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGluZm9NZW1vcnkudGV4dHVyZXMgKys7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcXG5cXHRcXHRcXHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlICk7XFxuXFxuXFx0XFx0XFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdGV4dHVyZS5mbGlwWSApO1xcblxcdFxcdFxcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdGV4dHVyZS5wcmVtdWx0aXBseUFscGhhICk7XFxuXFx0XFx0XFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0FMSUdOTUVOVCwgdGV4dHVyZS51bnBhY2tBbGlnbm1lbnQgKTtcXG5cXG5cXHRcXHRcXHR2YXIgaW1hZ2UgPSBjbGFtcFRvTWF4U2l6ZSggdGV4dHVyZS5pbWFnZSwgY2FwYWJpbGl0aWVzLm1heFRleHR1cmVTaXplICk7XFxuXFxuXFx0XFx0XFx0aWYgKCB0ZXh0dXJlTmVlZHNQb3dlck9mVHdvKCB0ZXh0dXJlICkgJiYgaXNQb3dlck9mVHdvKCBpbWFnZSApID09PSBmYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRpbWFnZSA9IG1ha2VQb3dlck9mVHdvKCBpbWFnZSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgaXNQb3dlck9mVHdvSW1hZ2UgPSBpc1Bvd2VyT2ZUd28oIGltYWdlICksXFxuXFx0XFx0XFx0XFx0Z2xGb3JtYXQgPSB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlLmZvcm1hdCApLFxcblxcdFxcdFxcdFxcdGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQoIHRleHR1cmUudHlwZSApO1xcblxcblxcdFxcdFxcdHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSwgaXNQb3dlck9mVHdvSW1hZ2UgKTtcXG5cXG5cXHRcXHRcXHR2YXIgbWlwbWFwLCBtaXBtYXBzID0gdGV4dHVyZS5taXBtYXBzO1xcblxcblxcdFxcdFxcdGlmICggdGV4dHVyZS5pc0RlcHRoVGV4dHVyZSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBwb3B1bGF0ZSBkZXB0aCB0ZXh0dXJlIHdpdGggZHVtbXkgZGF0YVxcblxcblxcdFxcdFxcdFxcdHZhciBpbnRlcm5hbEZvcm1hdCA9IF9nbC5ERVBUSF9DT01QT05FTlQ7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB0ZXh0dXJlLnR5cGUgPT09IEZsb2F0VHlwZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoICEgX2lzV2ViR0wyICkgdGhyb3cgbmV3IEVycm9yKCAnRmxvYXQgRGVwdGggVGV4dHVyZSBvbmx5IHN1cHBvcnRlZCBpbiBXZWJHTDIuMCcgKTtcXG5cXHRcXHRcXHRcXHRcXHRpbnRlcm5hbEZvcm1hdCA9IF9nbC5ERVBUSF9DT01QT05FTlQzMkY7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggX2lzV2ViR0wyICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFdlYkdMIDIuMCByZXF1aXJlcyBzaWduZWQgaW50ZXJuYWxmb3JtYXQgZm9yIGdsVGV4SW1hZ2UyRFxcblxcdFxcdFxcdFxcdFxcdGludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX0NPTVBPTkVOVDE2O1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHRleHR1cmUuZm9ybWF0ID09PSBEZXB0aEZvcm1hdCAmJiBpbnRlcm5hbEZvcm1hdCA9PT0gX2dsLkRFUFRIX0NPTVBPTkVOVCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBUaGUgZXJyb3IgSU5WQUxJRF9PUEVSQVRJT04gaXMgZ2VuZXJhdGVkIGJ5IHRleEltYWdlMkQgaWYgZm9ybWF0IGFuZCBpbnRlcm5hbGZvcm1hdCBhcmVcXG5cXHRcXHRcXHRcXHRcXHQvLyBERVBUSF9DT01QT05FTlQgYW5kIHR5cGUgaXMgbm90IFVOU0lHTkVEX1NIT1JUIG9yIFVOU0lHTkVEX0lOVFxcblxcdFxcdFxcdFxcdFxcdC8vIChodHRwczovL3d3dy5raHJvbm9zLm9yZy9yZWdpc3RyeS93ZWJnbC9leHRlbnNpb25zL1dFQkdMX2RlcHRoX3RleHR1cmUvKVxcblxcdFxcdFxcdFxcdFxcdGlmICggdGV4dHVyZS50eXBlICE9PSBVbnNpZ25lZFNob3J0VHlwZSAmJiB0ZXh0dXJlLnR5cGUgIT09IFVuc2lnbmVkSW50VHlwZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBVc2UgVW5zaWduZWRTaG9ydFR5cGUgb3IgVW5zaWduZWRJbnRUeXBlIGZvciBEZXB0aEZvcm1hdCBEZXB0aFRleHR1cmUuJyApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRleHR1cmUudHlwZSA9IFVuc2lnbmVkU2hvcnRUeXBlO1xcblxcdFxcdFxcdFxcdFxcdFxcdGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQoIHRleHR1cmUudHlwZSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRGVwdGggc3RlbmNpbCB0ZXh0dXJlcyBuZWVkIHRoZSBERVBUSF9TVEVOQ0lMIGludGVybmFsIGZvcm1hdFxcblxcdFxcdFxcdFxcdC8vIChodHRwczovL3d3dy5raHJvbm9zLm9yZy9yZWdpc3RyeS93ZWJnbC9leHRlbnNpb25zL1dFQkdMX2RlcHRoX3RleHR1cmUvKVxcblxcdFxcdFxcdFxcdGlmICggdGV4dHVyZS5mb3JtYXQgPT09IERlcHRoU3RlbmNpbEZvcm1hdCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpbnRlcm5hbEZvcm1hdCA9IF9nbC5ERVBUSF9TVEVOQ0lMO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFRoZSBlcnJvciBJTlZBTElEX09QRVJBVElPTiBpcyBnZW5lcmF0ZWQgYnkgdGV4SW1hZ2UyRCBpZiBmb3JtYXQgYW5kIGludGVybmFsZm9ybWF0IGFyZVxcblxcdFxcdFxcdFxcdFxcdC8vIERFUFRIX1NURU5DSUwgYW5kIHR5cGUgaXMgbm90IFVOU0lHTkVEX0lOVF8yNF84X1dFQkdMLlxcblxcdFxcdFxcdFxcdFxcdC8vIChodHRwczovL3d3dy5raHJvbm9zLm9yZy9yZWdpc3RyeS93ZWJnbC9leHRlbnNpb25zL1dFQkdMX2RlcHRoX3RleHR1cmUvKVxcblxcdFxcdFxcdFxcdFxcdGlmICggdGV4dHVyZS50eXBlICE9PSBVbnNpZ25lZEludDI0OFR5cGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVXNlIFVuc2lnbmVkSW50MjQ4VHlwZSBmb3IgRGVwdGhTdGVuY2lsRm9ybWF0IERlcHRoVGV4dHVyZS4nICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGV4dHVyZS50eXBlID0gVW5zaWduZWRJbnQyNDhUeXBlO1xcblxcdFxcdFxcdFxcdFxcdFxcdGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQoIHRleHR1cmUudHlwZSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIDAsIGludGVybmFsRm9ybWF0LCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBudWxsICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggdGV4dHVyZS5pc0RhdGFUZXh0dXJlICkge1xcblxcblxcdFxcdFxcdFxcdC8vIHVzZSBtYW51YWxseSBjcmVhdGVkIG1pcG1hcHMgaWYgYXZhaWxhYmxlXFxuXFx0XFx0XFx0XFx0Ly8gaWYgdGhlcmUgYXJlIG5vIG1hbnVhbCBtaXBtYXBzXFxuXFx0XFx0XFx0XFx0Ly8gc2V0IDAgbGV2ZWwgbWlwbWFwIGFuZCB0aGVuIHVzZSBHTCB0byBnZW5lcmF0ZSBvdGhlciBtaXBtYXAgbGV2ZWxzXFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBtaXBtYXBzLmxlbmd0aCA+IDAgJiYgaXNQb3dlck9mVHdvSW1hZ2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG1pcG1hcHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0bWlwbWFwID0gbWlwbWFwc1sgaSBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIDAsIGdsRm9ybWF0LCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBpbWFnZS5kYXRhICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIHRleHR1cmUuaXNDb21wcmVzc2VkVGV4dHVyZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRtaXBtYXAgPSBtaXBtYXBzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0ZXh0dXJlLmZvcm1hdCAhPT0gUkdCQUZvcm1hdCAmJiB0ZXh0dXJlLmZvcm1hdCAhPT0gUkdCRm9ybWF0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggc3RhdGUuZ2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzKCkuaW5kZXhPZiggZ2xGb3JtYXQgKSA+IC0gMSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzdGF0ZS5jb21wcmVzc2VkVGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIG1pcG1hcC5kYXRhICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAudXBsb2FkVGV4dHVyZSgpJyApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyByZWd1bGFyIFRleHR1cmUgKGltYWdlLCB2aWRlbywgY2FudmFzKVxcblxcblxcdFxcdFxcdFxcdC8vIHVzZSBtYW51YWxseSBjcmVhdGVkIG1pcG1hcHMgaWYgYXZhaWxhYmxlXFxuXFx0XFx0XFx0XFx0Ly8gaWYgdGhlcmUgYXJlIG5vIG1hbnVhbCBtaXBtYXBzXFxuXFx0XFx0XFx0XFx0Ly8gc2V0IDAgbGV2ZWwgbWlwbWFwIGFuZCB0aGVuIHVzZSBHTCB0byBnZW5lcmF0ZSBvdGhlciBtaXBtYXAgbGV2ZWxzXFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBtaXBtYXBzLmxlbmd0aCA+IDAgJiYgaXNQb3dlck9mVHdvSW1hZ2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG1pcG1hcHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0bWlwbWFwID0gbWlwbWFwc1sgaSBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyggdGV4dHVyZSwgaXNQb3dlck9mVHdvSW1hZ2UgKSApIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfMkQgKTtcXG5cXG5cXHRcXHRcXHR0ZXh0dXJlUHJvcGVydGllcy5fX3ZlcnNpb24gPSB0ZXh0dXJlLnZlcnNpb247XFxuXFxuXFx0XFx0XFx0aWYgKCB0ZXh0dXJlLm9uVXBkYXRlICkgdGV4dHVyZS5vblVwZGF0ZSggdGV4dHVyZSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBSZW5kZXIgdGFyZ2V0c1xcblxcblxcdFxcdC8vIFNldHVwIHN0b3JhZ2UgZm9yIHRhcmdldCB0ZXh0dXJlIGFuZCBiaW5kIGl0IHRvIGNvcnJlY3QgZnJhbWVidWZmZXJcXG5cXHRcXHRmdW5jdGlvbiBzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZSggZnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgYXR0YWNobWVudCwgdGV4dHVyZVRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgZ2xGb3JtYXQgPSB1dGlscy5jb252ZXJ0KCByZW5kZXJUYXJnZXQudGV4dHVyZS5mb3JtYXQgKTtcXG5cXHRcXHRcXHR2YXIgZ2xUeXBlID0gdXRpbHMuY29udmVydCggcmVuZGVyVGFyZ2V0LnRleHR1cmUudHlwZSApO1xcblxcdFxcdFxcdHN0YXRlLnRleEltYWdlMkQoIHRleHR1cmVUYXJnZXQsIDAsIGdsRm9ybWF0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG51bGwgKTtcXG5cXHRcXHRcXHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XFxuXFx0XFx0XFx0X2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKCBfZ2wuRlJBTUVCVUZGRVIsIGF0dGFjaG1lbnQsIHRleHR1cmVUYXJnZXQsIHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlLCAwICk7XFxuXFx0XFx0XFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBudWxsICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFNldHVwIHN0b3JhZ2UgZm9yIGludGVybmFsIGRlcHRoL3N0ZW5jaWwgYnVmZmVycyBhbmQgYmluZCB0byBjb3JyZWN0IGZyYW1lYnVmZmVyXFxuXFx0XFx0ZnVuY3Rpb24gc2V0dXBSZW5kZXJCdWZmZXJTdG9yYWdlKCByZW5kZXJidWZmZXIsIHJlbmRlclRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHRfZ2wuYmluZFJlbmRlcmJ1ZmZlciggX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XFxuXFxuXFx0XFx0XFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgISByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcXG5cXG5cXHRcXHRcXHRcXHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLkRFUFRIX0NPTVBPTkVOVDE2LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcXG5cXHRcXHRcXHRcXHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcXG5cXG5cXHRcXHRcXHRcXHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUwsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xcblxcdFxcdFxcdFxcdF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdC8vIEZJWE1FOiBXZSBkb24ndCBzdXBwb3J0ICFkZXB0aCAhc3RlbmNpbFxcblxcdFxcdFxcdFxcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuUkdCQTQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRfZ2wuYmluZFJlbmRlcmJ1ZmZlciggX2dsLlJFTkRFUkJVRkZFUiwgbnVsbCApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBTZXR1cCByZXNvdXJjZXMgZm9yIGEgRGVwdGggVGV4dHVyZSBmb3IgYSBGQk8gKG5lZWRzIGFuIGV4dGVuc2lvbilcXG5cXHRcXHRmdW5jdGlvbiBzZXR1cERlcHRoVGV4dHVyZSggZnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgaXNDdWJlID0gKCByZW5kZXJUYXJnZXQgJiYgcmVuZGVyVGFyZ2V0LmlzV2ViR0xSZW5kZXJUYXJnZXRDdWJlICk7XFxuXFx0XFx0XFx0aWYgKCBpc0N1YmUgKSB0aHJvdyBuZXcgRXJyb3IoICdEZXB0aCBUZXh0dXJlIHdpdGggY3ViZSByZW5kZXIgdGFyZ2V0cyBpcyBub3Qgc3VwcG9ydGVkJyApO1xcblxcblxcdFxcdFxcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcXG5cXG5cXHRcXHRcXHRpZiAoICEgKCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlICYmIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuaXNEZXB0aFRleHR1cmUgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoICdyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuRGVwdGhUZXh0dXJlJyApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyB1cGxvYWQgYW4gZW1wdHkgZGVwdGggdGV4dHVyZSB3aXRoIGZyYW1lYnVmZmVyIHNpemVcXG5cXHRcXHRcXHRpZiAoICEgcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgKS5fX3dlYmdsVGV4dHVyZSB8fFxcblxcdFxcdFxcdFxcdFxcdHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuaW1hZ2Uud2lkdGggIT09IHJlbmRlclRhcmdldC53aWR0aCB8fFxcblxcdFxcdFxcdFxcdFxcdHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuaW1hZ2UuaGVpZ2h0ICE9PSByZW5kZXJUYXJnZXQuaGVpZ2h0ICkge1xcblxcblxcdFxcdFxcdFxcdHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUuaW1hZ2Uud2lkdGggPSByZW5kZXJUYXJnZXQud2lkdGg7XFxuXFx0XFx0XFx0XFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5pbWFnZS5oZWlnaHQgPSByZW5kZXJUYXJnZXQuaGVpZ2h0O1xcblxcdFxcdFxcdFxcdHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRzZXRUZXh0dXJlMkQoIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUsIDAgKTtcXG5cXG5cXHRcXHRcXHR2YXIgd2ViZ2xEZXB0aFRleHR1cmUgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlO1xcblxcblxcdFxcdFxcdGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5mb3JtYXQgPT09IERlcHRoRm9ybWF0ICkge1xcblxcblxcdFxcdFxcdFxcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfQVRUQUNITUVOVCwgX2dsLlRFWFRVUkVfMkQsIHdlYmdsRGVwdGhUZXh0dXJlLCAwICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5mb3JtYXQgPT09IERlcHRoU3RlbmNpbEZvcm1hdCApIHtcXG5cXG5cXHRcXHRcXHRcXHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgX2dsLlRFWFRVUkVfMkQsIHdlYmdsRGVwdGhUZXh0dXJlLCAwICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoICdVbmtub3duIGRlcHRoVGV4dHVyZSBmb3JtYXQnICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBTZXR1cCBHTCByZXNvdXJjZXMgZm9yIGEgbm9uLXRleHR1cmUgZGVwdGggYnVmZmVyXFxuXFx0XFx0ZnVuY3Rpb24gc2V0dXBEZXB0aFJlbmRlcmJ1ZmZlciggcmVuZGVyVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdHZhciByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xcblxcblxcdFxcdFxcdHZhciBpc0N1YmUgPSAoIHJlbmRlclRhcmdldC5pc1dlYkdMUmVuZGVyVGFyZ2V0Q3ViZSA9PT0gdHJ1ZSApO1xcblxcblxcdFxcdFxcdGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGlzQ3ViZSApIHRocm93IG5ldyBFcnJvciggJ3RhcmdldC5kZXB0aFRleHR1cmUgbm90IHN1cHBvcnRlZCBpbiBDdWJlIHJlbmRlciB0YXJnZXRzJyApO1xcblxcblxcdFxcdFxcdFxcdHNldHVwRGVwdGhUZXh0dXJlKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0ICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGlzQ3ViZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciA9IFtdO1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXJbIGkgXSA9IF9nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzZXR1cFJlbmRlckJ1ZmZlclN0b3JhZ2UoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyWyBpIF0sIHJlbmRlclRhcmdldCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgKTtcXG5cXHRcXHRcXHRcXHRcXHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciA9IF9nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcXG5cXHRcXHRcXHRcXHRcXHRzZXR1cFJlbmRlckJ1ZmZlclN0b3JhZ2UoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyLCByZW5kZXJUYXJnZXQgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBTZXQgdXAgR0wgcmVzb3VyY2VzIGZvciB0aGUgcmVuZGVyIHRhcmdldFxcblxcdFxcdGZ1bmN0aW9uIHNldHVwUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICk7XFxuXFx0XFx0XFx0dmFyIHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldC50ZXh0dXJlICk7XFxuXFxuXFx0XFx0XFx0cmVuZGVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25SZW5kZXJUYXJnZXREaXNwb3NlICk7XFxuXFxuXFx0XFx0XFx0dGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgPSBfZ2wuY3JlYXRlVGV4dHVyZSgpO1xcblxcblxcdFxcdFxcdGluZm9NZW1vcnkudGV4dHVyZXMgKys7XFxuXFxuXFx0XFx0XFx0dmFyIGlzQ3ViZSA9ICggcmVuZGVyVGFyZ2V0LmlzV2ViR0xSZW5kZXJUYXJnZXRDdWJlID09PSB0cnVlICk7XFxuXFx0XFx0XFx0dmFyIGlzVGFyZ2V0UG93ZXJPZlR3byA9IGlzUG93ZXJPZlR3byggcmVuZGVyVGFyZ2V0ICk7XFxuXFxuXFx0XFx0XFx0Ly8gU2V0dXAgZnJhbWVidWZmZXJcXG5cXG5cXHRcXHRcXHRpZiAoIGlzQ3ViZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciA9IFtdO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSA9IF9nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFNldHVwIGNvbG9yIGJ1ZmZlclxcblxcblxcdFxcdFxcdGlmICggaXNDdWJlICkge1xcblxcblxcdFxcdFxcdFxcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcXG5cXHRcXHRcXHRcXHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHJlbmRlclRhcmdldC50ZXh0dXJlLCBpc1RhcmdldFBvd2VyT2ZUd28gKTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHNldHVwRnJhbWVCdWZmZXJUZXh0dXJlKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdLCByZW5kZXJUYXJnZXQsIF9nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGkgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHMoIHJlbmRlclRhcmdldC50ZXh0dXJlLCBpc1RhcmdldFBvd2VyT2ZUd28gKSApIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfQ1VCRV9NQVAgKTtcXG5cXHRcXHRcXHRcXHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcXG5cXHRcXHRcXHRcXHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfMkQsIHJlbmRlclRhcmdldC50ZXh0dXJlLCBpc1RhcmdldFBvd2VyT2ZUd28gKTtcXG5cXHRcXHRcXHRcXHRzZXR1cEZyYW1lQnVmZmVyVGV4dHVyZSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCBfZ2wuVEVYVFVSRV8yRCApO1xcblxcblxcdFxcdFxcdFxcdGlmICggdGV4dHVyZU5lZWRzR2VuZXJhdGVNaXBtYXBzKCByZW5kZXJUYXJnZXQudGV4dHVyZSwgaXNUYXJnZXRQb3dlck9mVHdvICkgKSBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFXzJEICk7XFxuXFx0XFx0XFx0XFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCBudWxsICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFNldHVwIGRlcHRoIGFuZCBzdGVuY2lsIGJ1ZmZlcnNcXG5cXG5cXHRcXHRcXHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciApIHtcXG5cXG5cXHRcXHRcXHRcXHRzZXR1cERlcHRoUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXQgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCggcmVuZGVyVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdHZhciB0ZXh0dXJlID0gcmVuZGVyVGFyZ2V0LnRleHR1cmU7XFxuXFx0XFx0XFx0dmFyIGlzVGFyZ2V0UG93ZXJPZlR3byA9IGlzUG93ZXJPZlR3byggcmVuZGVyVGFyZ2V0ICk7XFxuXFxuXFx0XFx0XFx0aWYgKCB0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHMoIHRleHR1cmUsIGlzVGFyZ2V0UG93ZXJPZlR3byApICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB0YXJnZXQgPSByZW5kZXJUYXJnZXQuaXNXZWJHTFJlbmRlclRhcmdldEN1YmUgPyBfZ2wuVEVYVFVSRV9DVUJFX01BUCA6IF9nbC5URVhUVVJFXzJEO1xcblxcdFxcdFxcdFxcdHZhciB3ZWJnbFRleHR1cmUgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlO1xcblxcblxcdFxcdFxcdFxcdHN0YXRlLmJpbmRUZXh0dXJlKCB0YXJnZXQsIHdlYmdsVGV4dHVyZSApO1xcblxcdFxcdFxcdFxcdF9nbC5nZW5lcmF0ZU1pcG1hcCggdGFyZ2V0ICk7XFxuXFx0XFx0XFx0XFx0c3RhdGUuYmluZFRleHR1cmUoIHRhcmdldCwgbnVsbCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gdXBkYXRlVmlkZW9UZXh0dXJlcygpIHtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaWQgaW4gX3ZpZGVvVGV4dHVyZXMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0X3ZpZGVvVGV4dHVyZXNbIGlkIF0udXBkYXRlKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLnNldFRleHR1cmUyRCA9IHNldFRleHR1cmUyRDtcXG5cXHRcXHR0aGlzLnNldFRleHR1cmVDdWJlID0gc2V0VGV4dHVyZUN1YmU7XFxuXFx0XFx0dGhpcy5zZXRUZXh0dXJlQ3ViZUR5bmFtaWMgPSBzZXRUZXh0dXJlQ3ViZUR5bmFtaWM7XFxuXFx0XFx0dGhpcy5zZXR1cFJlbmRlclRhcmdldCA9IHNldHVwUmVuZGVyVGFyZ2V0O1xcblxcdFxcdHRoaXMudXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwID0gdXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwO1xcblxcdFxcdHRoaXMudXBkYXRlVmlkZW9UZXh0dXJlcyA9IHVwZGF0ZVZpZGVvVGV4dHVyZXM7XFxuXFxuXFx0fVxcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgZm9yZGFjaW91cyAvIGZvcmRhY2lvdXMuZ2l0aHViLmlvXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gV2ViR0xQcm9wZXJ0aWVzKCkge1xcblxcblxcdFxcdHZhciBwcm9wZXJ0aWVzID0ge307XFxuXFxuXFx0XFx0ZnVuY3Rpb24gZ2V0KCBvYmplY3QgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHV1aWQgPSBvYmplY3QudXVpZDtcXG5cXHRcXHRcXHR2YXIgbWFwID0gcHJvcGVydGllc1sgdXVpZCBdO1xcblxcblxcdFxcdFxcdGlmICggbWFwID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0bWFwID0ge307XFxuXFx0XFx0XFx0XFx0cHJvcGVydGllc1sgdXVpZCBdID0gbWFwO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gbWFwO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiByZW1vdmUoIG9iamVjdCApIHtcXG5cXG5cXHRcXHRcXHRkZWxldGUgcHJvcGVydGllc1sgb2JqZWN0LnV1aWQgXTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gY2xlYXIoKSB7XFxuXFxuXFx0XFx0XFx0cHJvcGVydGllcyA9IHt9O1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdGdldDogZ2V0LFxcblxcdFxcdFxcdHJlbW92ZTogcmVtb3ZlLFxcblxcdFxcdFxcdGNsZWFyOiBjbGVhclxcblxcdFxcdH07XFxuXFxuXFx0fVxcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gV2ViR0xTdGF0ZSggZ2wsIGV4dGVuc2lvbnMsIHV0aWxzICkge1xcblxcblxcdFxcdGZ1bmN0aW9uIENvbG9yQnVmZmVyKCkge1xcblxcblxcdFxcdFxcdHZhciBsb2NrZWQgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHR2YXIgY29sb3IgPSBuZXcgVmVjdG9yNCgpO1xcblxcdFxcdFxcdHZhciBjdXJyZW50Q29sb3JNYXNrID0gbnVsbDtcXG5cXHRcXHRcXHR2YXIgY3VycmVudENvbG9yQ2xlYXIgPSBuZXcgVmVjdG9yNCggMCwgMCwgMCwgMCApO1xcblxcblxcdFxcdFxcdHJldHVybiB7XFxuXFxuXFx0XFx0XFx0XFx0c2V0TWFzazogZnVuY3Rpb24gKCBjb2xvck1hc2sgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBjdXJyZW50Q29sb3JNYXNrICE9PSBjb2xvck1hc2sgJiYgISBsb2NrZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2wuY29sb3JNYXNrKCBjb2xvck1hc2ssIGNvbG9yTWFzaywgY29sb3JNYXNrLCBjb2xvck1hc2sgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjdXJyZW50Q29sb3JNYXNrID0gY29sb3JNYXNrO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdHNldExvY2tlZDogZnVuY3Rpb24gKCBsb2NrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGxvY2tlZCA9IGxvY2s7XFxuXFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHRzZXRDbGVhcjogZnVuY3Rpb24gKCByLCBnLCBiLCBhLCBwcmVtdWx0aXBsaWVkQWxwaGEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBwcmVtdWx0aXBsaWVkQWxwaGEgPT09IHRydWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0ciAqPSBhOyBnICo9IGE7IGIgKj0gYTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y29sb3Iuc2V0KCByLCBnLCBiLCBhICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBjdXJyZW50Q29sb3JDbGVhci5lcXVhbHMoIGNvbG9yICkgPT09IGZhbHNlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGdsLmNsZWFyQ29sb3IoIHIsIGcsIGIsIGEgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjdXJyZW50Q29sb3JDbGVhci5jb3B5KCBjb2xvciApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdHJlc2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bG9ja2VkID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y3VycmVudENvbG9yTWFzayA9IG51bGw7XFxuXFx0XFx0XFx0XFx0XFx0Y3VycmVudENvbG9yQ2xlYXIuc2V0KCAtIDEsIDAsIDAsIDAgKTsgLy8gc2V0IHRvIGludmFsaWQgc3RhdGVcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gRGVwdGhCdWZmZXIoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGxvY2tlZCA9IGZhbHNlO1xcblxcblxcdFxcdFxcdHZhciBjdXJyZW50RGVwdGhNYXNrID0gbnVsbDtcXG5cXHRcXHRcXHR2YXIgY3VycmVudERlcHRoRnVuYyA9IG51bGw7XFxuXFx0XFx0XFx0dmFyIGN1cnJlbnREZXB0aENsZWFyID0gbnVsbDtcXG5cXG5cXHRcXHRcXHRyZXR1cm4ge1xcblxcblxcdFxcdFxcdFxcdHNldFRlc3Q6IGZ1bmN0aW9uICggZGVwdGhUZXN0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggZGVwdGhUZXN0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGlzYWJsZSggZ2wuREVQVEhfVEVTVCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdHNldE1hc2s6IGZ1bmN0aW9uICggZGVwdGhNYXNrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggY3VycmVudERlcHRoTWFzayAhPT0gZGVwdGhNYXNrICYmICEgbG9ja2VkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGdsLmRlcHRoTWFzayggZGVwdGhNYXNrICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y3VycmVudERlcHRoTWFzayA9IGRlcHRoTWFzaztcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHRzZXRGdW5jOiBmdW5jdGlvbiAoIGRlcHRoRnVuYyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGN1cnJlbnREZXB0aEZ1bmMgIT09IGRlcHRoRnVuYyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGRlcHRoRnVuYyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzd2l0Y2ggKCBkZXB0aEZ1bmMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSBOZXZlckRlcHRoOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLmRlcHRoRnVuYyggZ2wuTkVWRVIgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjYXNlIEFsd2F5c0RlcHRoOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLmRlcHRoRnVuYyggZ2wuQUxXQVlTICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSBMZXNzRGVwdGg6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wuZGVwdGhGdW5jKCBnbC5MRVNTICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSBMZXNzRXF1YWxEZXB0aDpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgRXF1YWxEZXB0aDpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC5kZXB0aEZ1bmMoIGdsLkVRVUFMICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSBHcmVhdGVyRXF1YWxEZXB0aDpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC5kZXB0aEZ1bmMoIGdsLkdFUVVBTCApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgR3JlYXRlckRlcHRoOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLmRlcHRoRnVuYyggZ2wuR1JFQVRFUiApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgTm90RXF1YWxEZXB0aDpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC5kZXB0aEZ1bmMoIGdsLk5PVEVRVUFMICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGVmYXVsdDpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGN1cnJlbnREZXB0aEZ1bmMgPSBkZXB0aEZ1bmM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0c2V0TG9ja2VkOiBmdW5jdGlvbiAoIGxvY2sgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bG9ja2VkID0gbG9jaztcXG5cXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdHNldENsZWFyOiBmdW5jdGlvbiAoIGRlcHRoICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggY3VycmVudERlcHRoQ2xlYXIgIT09IGRlcHRoICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGdsLmNsZWFyRGVwdGgoIGRlcHRoICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y3VycmVudERlcHRoQ2xlYXIgPSBkZXB0aDtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHRyZXNldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdFxcdGxvY2tlZCA9IGZhbHNlO1xcblxcblxcdFxcdFxcdFxcdFxcdGN1cnJlbnREZXB0aE1hc2sgPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdGN1cnJlbnREZXB0aEZ1bmMgPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdGN1cnJlbnREZXB0aENsZWFyID0gbnVsbDtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gU3RlbmNpbEJ1ZmZlcigpIHtcXG5cXG5cXHRcXHRcXHR2YXIgbG9ja2VkID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0dmFyIGN1cnJlbnRTdGVuY2lsTWFzayA9IG51bGw7XFxuXFx0XFx0XFx0dmFyIGN1cnJlbnRTdGVuY2lsRnVuYyA9IG51bGw7XFxuXFx0XFx0XFx0dmFyIGN1cnJlbnRTdGVuY2lsUmVmID0gbnVsbDtcXG5cXHRcXHRcXHR2YXIgY3VycmVudFN0ZW5jaWxGdW5jTWFzayA9IG51bGw7XFxuXFx0XFx0XFx0dmFyIGN1cnJlbnRTdGVuY2lsRmFpbCA9IG51bGw7XFxuXFx0XFx0XFx0dmFyIGN1cnJlbnRTdGVuY2lsWkZhaWwgPSBudWxsO1xcblxcdFxcdFxcdHZhciBjdXJyZW50U3RlbmNpbFpQYXNzID0gbnVsbDtcXG5cXHRcXHRcXHR2YXIgY3VycmVudFN0ZW5jaWxDbGVhciA9IG51bGw7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHtcXG5cXG5cXHRcXHRcXHRcXHRzZXRUZXN0OiBmdW5jdGlvbiAoIHN0ZW5jaWxUZXN0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggc3RlbmNpbFRlc3QgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZW5hYmxlKCBnbC5TVEVOQ0lMX1RFU1QgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGRpc2FibGUoIGdsLlNURU5DSUxfVEVTVCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdHNldE1hc2s6IGZ1bmN0aW9uICggc3RlbmNpbE1hc2sgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBjdXJyZW50U3RlbmNpbE1hc2sgIT09IHN0ZW5jaWxNYXNrICYmICEgbG9ja2VkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGdsLnN0ZW5jaWxNYXNrKCBzdGVuY2lsTWFzayApO1xcblxcdFxcdFxcdFxcdFxcdFxcdGN1cnJlbnRTdGVuY2lsTWFzayA9IHN0ZW5jaWxNYXNrO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdHNldEZ1bmM6IGZ1bmN0aW9uICggc3RlbmNpbEZ1bmMsIHN0ZW5jaWxSZWYsIHN0ZW5jaWxNYXNrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggY3VycmVudFN0ZW5jaWxGdW5jICE9PSBzdGVuY2lsRnVuYyB8fFxcblxcdFxcdFxcdFxcdFxcdCAgICAgY3VycmVudFN0ZW5jaWxSZWYgXFx0IT09IHN0ZW5jaWxSZWYgXFx0fHxcXG5cXHRcXHRcXHRcXHRcXHQgICAgIGN1cnJlbnRTdGVuY2lsRnVuY01hc2sgIT09IHN0ZW5jaWxNYXNrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGdsLnN0ZW5jaWxGdW5jKCBzdGVuY2lsRnVuYywgc3RlbmNpbFJlZiwgc3RlbmNpbE1hc2sgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjdXJyZW50U3RlbmNpbEZ1bmMgPSBzdGVuY2lsRnVuYztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjdXJyZW50U3RlbmNpbFJlZiA9IHN0ZW5jaWxSZWY7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y3VycmVudFN0ZW5jaWxGdW5jTWFzayA9IHN0ZW5jaWxNYXNrO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdHNldE9wOiBmdW5jdGlvbiAoIHN0ZW5jaWxGYWlsLCBzdGVuY2lsWkZhaWwsIHN0ZW5jaWxaUGFzcyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGN1cnJlbnRTdGVuY2lsRmFpbFxcdCAhPT0gc3RlbmNpbEZhaWwgXFx0fHxcXG5cXHRcXHRcXHRcXHRcXHQgICAgIGN1cnJlbnRTdGVuY2lsWkZhaWwgIT09IHN0ZW5jaWxaRmFpbCB8fFxcblxcdFxcdFxcdFxcdFxcdCAgICAgY3VycmVudFN0ZW5jaWxaUGFzcyAhPT0gc3RlbmNpbFpQYXNzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGdsLnN0ZW5jaWxPcCggc3RlbmNpbEZhaWwsIHN0ZW5jaWxaRmFpbCwgc3RlbmNpbFpQYXNzICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y3VycmVudFN0ZW5jaWxGYWlsID0gc3RlbmNpbEZhaWw7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y3VycmVudFN0ZW5jaWxaRmFpbCA9IHN0ZW5jaWxaRmFpbDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjdXJyZW50U3RlbmNpbFpQYXNzID0gc3RlbmNpbFpQYXNzO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdHNldExvY2tlZDogZnVuY3Rpb24gKCBsb2NrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGxvY2tlZCA9IGxvY2s7XFxuXFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHRzZXRDbGVhcjogZnVuY3Rpb24gKCBzdGVuY2lsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggY3VycmVudFN0ZW5jaWxDbGVhciAhPT0gc3RlbmNpbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRnbC5jbGVhclN0ZW5jaWwoIHN0ZW5jaWwgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjdXJyZW50U3RlbmNpbENsZWFyID0gc3RlbmNpbDtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHRyZXNldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdFxcdGxvY2tlZCA9IGZhbHNlO1xcblxcblxcdFxcdFxcdFxcdFxcdGN1cnJlbnRTdGVuY2lsTWFzayA9IG51bGw7XFxuXFx0XFx0XFx0XFx0XFx0Y3VycmVudFN0ZW5jaWxGdW5jID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRjdXJyZW50U3RlbmNpbFJlZiA9IG51bGw7XFxuXFx0XFx0XFx0XFx0XFx0Y3VycmVudFN0ZW5jaWxGdW5jTWFzayA9IG51bGw7XFxuXFx0XFx0XFx0XFx0XFx0Y3VycmVudFN0ZW5jaWxGYWlsID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRjdXJyZW50U3RlbmNpbFpGYWlsID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRjdXJyZW50U3RlbmNpbFpQYXNzID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRjdXJyZW50U3RlbmNpbENsZWFyID0gbnVsbDtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly9cXG5cXG5cXHRcXHR2YXIgY29sb3JCdWZmZXIgPSBuZXcgQ29sb3JCdWZmZXIoKTtcXG5cXHRcXHR2YXIgZGVwdGhCdWZmZXIgPSBuZXcgRGVwdGhCdWZmZXIoKTtcXG5cXHRcXHR2YXIgc3RlbmNpbEJ1ZmZlciA9IG5ldyBTdGVuY2lsQnVmZmVyKCk7XFxuXFxuXFx0XFx0dmFyIG1heFZlcnRleEF0dHJpYnV0ZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WRVJURVhfQVRUUklCUyApO1xcblxcdFxcdHZhciBuZXdBdHRyaWJ1dGVzID0gbmV3IFVpbnQ4QXJyYXkoIG1heFZlcnRleEF0dHJpYnV0ZXMgKTtcXG5cXHRcXHR2YXIgZW5hYmxlZEF0dHJpYnV0ZXMgPSBuZXcgVWludDhBcnJheSggbWF4VmVydGV4QXR0cmlidXRlcyApO1xcblxcdFxcdHZhciBhdHRyaWJ1dGVEaXZpc29ycyA9IG5ldyBVaW50OEFycmF5KCBtYXhWZXJ0ZXhBdHRyaWJ1dGVzICk7XFxuXFxuXFx0XFx0dmFyIGNhcGFiaWxpdGllcyA9IHt9O1xcblxcblxcdFxcdHZhciBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPSBudWxsO1xcblxcblxcdFxcdHZhciBjdXJyZW50UHJvZ3JhbSA9IG51bGw7XFxuXFxuXFx0XFx0dmFyIGN1cnJlbnRCbGVuZGluZyA9IG51bGw7XFxuXFx0XFx0dmFyIGN1cnJlbnRCbGVuZEVxdWF0aW9uID0gbnVsbDtcXG5cXHRcXHR2YXIgY3VycmVudEJsZW5kU3JjID0gbnVsbDtcXG5cXHRcXHR2YXIgY3VycmVudEJsZW5kRHN0ID0gbnVsbDtcXG5cXHRcXHR2YXIgY3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XFxuXFx0XFx0dmFyIGN1cnJlbnRCbGVuZFNyY0FscGhhID0gbnVsbDtcXG5cXHRcXHR2YXIgY3VycmVudEJsZW5kRHN0QWxwaGEgPSBudWxsO1xcblxcdFxcdHZhciBjdXJyZW50UHJlbXVsdGlwbGVkQWxwaGEgPSBmYWxzZTtcXG5cXG5cXHRcXHR2YXIgY3VycmVudEZsaXBTaWRlZCA9IG51bGw7XFxuXFx0XFx0dmFyIGN1cnJlbnRDdWxsRmFjZSA9IG51bGw7XFxuXFxuXFx0XFx0dmFyIGN1cnJlbnRMaW5lV2lkdGggPSBudWxsO1xcblxcblxcdFxcdHZhciBjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciA9IG51bGw7XFxuXFx0XFx0dmFyIGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgPSBudWxsO1xcblxcblxcdFxcdHZhciBtYXhUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcXG5cXG5cXHRcXHR2YXIgdmVyc2lvbiA9IHBhcnNlRmxvYXQoIC9eV2ViR0xcXFxcIChbMC05XSkvLmV4ZWMoIGdsLmdldFBhcmFtZXRlciggZ2wuVkVSU0lPTiApIClbIDEgXSApO1xcblxcdFxcdHZhciBsaW5lV2lkdGhBdmFpbGFibGUgPSBwYXJzZUZsb2F0KCB2ZXJzaW9uICkgPj0gMS4wO1xcblxcblxcdFxcdHZhciBjdXJyZW50VGV4dHVyZVNsb3QgPSBudWxsO1xcblxcdFxcdHZhciBjdXJyZW50Qm91bmRUZXh0dXJlcyA9IHt9O1xcblxcblxcdFxcdHZhciBjdXJyZW50U2Npc3NvciA9IG5ldyBWZWN0b3I0KCk7XFxuXFx0XFx0dmFyIGN1cnJlbnRWaWV3cG9ydCA9IG5ldyBWZWN0b3I0KCk7XFxuXFxuXFx0XFx0ZnVuY3Rpb24gY3JlYXRlVGV4dHVyZSggdHlwZSwgdGFyZ2V0LCBjb3VudCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KCA0ICk7IC8vIDQgaXMgcmVxdWlyZWQgdG8gbWF0Y2ggZGVmYXVsdCB1bnBhY2sgYWxpZ25tZW50IG9mIDQuXFxuXFx0XFx0XFx0dmFyIHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XFxuXFxuXFx0XFx0XFx0Z2wuYmluZFRleHR1cmUoIHR5cGUsIHRleHR1cmUgKTtcXG5cXHRcXHRcXHRnbC50ZXhQYXJhbWV0ZXJpKCB0eXBlLCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QgKTtcXG5cXHRcXHRcXHRnbC50ZXhQYXJhbWV0ZXJpKCB0eXBlLCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QgKTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRnbC50ZXhJbWFnZTJEKCB0YXJnZXQgKyBpLCAwLCBnbC5SR0JBLCAxLCAxLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBkYXRhICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0ZXh0dXJlO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR2YXIgZW1wdHlUZXh0dXJlcyA9IHt9O1xcblxcdFxcdGVtcHR5VGV4dHVyZXNbIGdsLlRFWFRVUkVfMkQgXSA9IGNyZWF0ZVRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfMkQsIDEgKTtcXG5cXHRcXHRlbXB0eVRleHR1cmVzWyBnbC5URVhUVVJFX0NVQkVfTUFQIF0gPSBjcmVhdGVUZXh0dXJlKCBnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1gsIDYgKTtcXG5cXG5cXHRcXHQvLyBpbml0XFxuXFxuXFx0XFx0Y29sb3JCdWZmZXIuc2V0Q2xlYXIoIDAsIDAsIDAsIDEgKTtcXG5cXHRcXHRkZXB0aEJ1ZmZlci5zZXRDbGVhciggMSApO1xcblxcdFxcdHN0ZW5jaWxCdWZmZXIuc2V0Q2xlYXIoIDAgKTtcXG5cXG5cXHRcXHRlbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcXG5cXHRcXHRkZXB0aEJ1ZmZlci5zZXRGdW5jKCBMZXNzRXF1YWxEZXB0aCApO1xcblxcblxcdFxcdHNldEZsaXBTaWRlZCggZmFsc2UgKTtcXG5cXHRcXHRzZXRDdWxsRmFjZSggQ3VsbEZhY2VCYWNrICk7XFxuXFx0XFx0ZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcXG5cXG5cXHRcXHRlbmFibGUoIGdsLkJMRU5EICk7XFxuXFx0XFx0c2V0QmxlbmRpbmcoIE5vcm1hbEJsZW5kaW5nICk7XFxuXFxuXFx0XFx0Ly9cXG5cXG5cXHRcXHRmdW5jdGlvbiBpbml0QXR0cmlidXRlcygpIHtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBuZXdBdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0bmV3QXR0cmlidXRlc1sgaSBdID0gMDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xcblxcblxcdFxcdFxcdG5ld0F0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID0gMTtcXG5cXG5cXHRcXHRcXHRpZiAoIGVuYWJsZWRBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9PT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggYXR0cmlidXRlICk7XFxuXFx0XFx0XFx0XFx0ZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID0gMTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBhdHRyaWJ1dGVEaXZpc29yc1sgYXR0cmlidXRlIF0gIT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcXG5cXG5cXHRcXHRcXHRcXHRleHRlbnNpb24udmVydGV4QXR0cmliRGl2aXNvckFOR0xFKCBhdHRyaWJ1dGUsIDAgKTtcXG5cXHRcXHRcXHRcXHRhdHRyaWJ1dGVEaXZpc29yc1sgYXR0cmlidXRlIF0gPSAwO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvciggYXR0cmlidXRlLCBtZXNoUGVyQXR0cmlidXRlICkge1xcblxcblxcdFxcdFxcdG5ld0F0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID0gMTtcXG5cXG5cXHRcXHRcXHRpZiAoIGVuYWJsZWRBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9PT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggYXR0cmlidXRlICk7XFxuXFx0XFx0XFx0XFx0ZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID0gMTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBhdHRyaWJ1dGVEaXZpc29yc1sgYXR0cmlidXRlIF0gIT09IG1lc2hQZXJBdHRyaWJ1dGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcXG5cXG5cXHRcXHRcXHRcXHRleHRlbnNpb24udmVydGV4QXR0cmliRGl2aXNvckFOR0xFKCBhdHRyaWJ1dGUsIG1lc2hQZXJBdHRyaWJ1dGUgKTtcXG5cXHRcXHRcXHRcXHRhdHRyaWJ1dGVEaXZpc29yc1sgYXR0cmlidXRlIF0gPSBtZXNoUGVyQXR0cmlidXRlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKSB7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZW5hYmxlZEF0dHJpYnV0ZXMubGVuZ3RoOyBpICE9PSBsOyArKyBpICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggZW5hYmxlZEF0dHJpYnV0ZXNbIGkgXSAhPT0gbmV3QXR0cmlidXRlc1sgaSBdICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSggaSApO1xcblxcdFxcdFxcdFxcdFxcdGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPSAwO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGVuYWJsZSggaWQgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBjYXBhYmlsaXRpZXNbIGlkIF0gIT09IHRydWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Z2wuZW5hYmxlKCBpZCApO1xcblxcdFxcdFxcdFxcdGNhcGFiaWxpdGllc1sgaWQgXSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBkaXNhYmxlKCBpZCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGNhcGFiaWxpdGllc1sgaWQgXSAhPT0gZmFsc2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Z2wuZGlzYWJsZSggaWQgKTtcXG5cXHRcXHRcXHRcXHRjYXBhYmlsaXRpZXNbIGlkIF0gPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGdldENvbXByZXNzZWRUZXh0dXJlRm9ybWF0cygpIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9PT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApIHx8XFxuXFx0XFx0XFx0XFx0ICAgICBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApIHx8XFxuXFx0XFx0XFx0XFx0ICAgICBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxJyApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBmb3JtYXRzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5DT01QUkVTU0VEX1RFWFRVUkVfRk9STUFUUyApO1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IGZvcm1hdHMubGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cy5wdXNoKCBmb3JtYXRzWyBpIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiB1c2VQcm9ncmFtKCBwcm9ncmFtICkge1xcblxcblxcdFxcdFxcdGlmICggY3VycmVudFByb2dyYW0gIT09IHByb2dyYW0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0Z2wudXNlUHJvZ3JhbSggcHJvZ3JhbSApO1xcblxcblxcdFxcdFxcdFxcdGN1cnJlbnRQcm9ncmFtID0gcHJvZ3JhbTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBzZXRCbGVuZGluZyggYmxlbmRpbmcsIGJsZW5kRXF1YXRpb24sIGJsZW5kU3JjLCBibGVuZERzdCwgYmxlbmRFcXVhdGlvbkFscGhhLCBibGVuZFNyY0FscGhhLCBibGVuZERzdEFscGhhLCBwcmVtdWx0aXBsaWVkQWxwaGEgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBibGVuZGluZyAhPT0gTm9CbGVuZGluZyApIHtcXG5cXG5cXHRcXHRcXHRcXHRlbmFibGUoIGdsLkJMRU5EICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRkaXNhYmxlKCBnbC5CTEVORCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGJsZW5kaW5nICE9PSBDdXN0b21CbGVuZGluZyApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGJsZW5kaW5nICE9PSBjdXJyZW50QmxlbmRpbmcgfHwgcHJlbXVsdGlwbGllZEFscGhhICE9PSBjdXJyZW50UHJlbXVsdGlwbGVkQWxwaGEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0c3dpdGNoICggYmxlbmRpbmcgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSBBZGRpdGl2ZUJsZW5kaW5nOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggcHJlbXVsdGlwbGllZEFscGhhICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggZ2wuRlVOQ19BREQsIGdsLkZVTkNfQUREICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIGdsLk9ORSwgZ2wuT05FLCBnbC5PTkUsIGdsLk9ORSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC5ibGVuZEZ1bmMoIGdsLlNSQ19BTFBIQSwgZ2wuT05FICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgU3VidHJhY3RpdmVCbGVuZGluZzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHByZW11bHRpcGxpZWRBbHBoYSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoIGdsLkZVTkNfQURELCBnbC5GVU5DX0FERCApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBnbC5aRVJPLCBnbC5aRVJPLCBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC5ibGVuZEVxdWF0aW9uKCBnbC5GVU5DX0FERCApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLmJsZW5kRnVuYyggZ2wuWkVSTywgZ2wuT05FX01JTlVTX1NSQ19DT0xPUiApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlIE11bHRpcGx5QmxlbmRpbmc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBwcmVtdWx0aXBsaWVkQWxwaGEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKCBnbC5GVU5DX0FERCwgZ2wuRlVOQ19BREQgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuWkVSTywgZ2wuU1JDX0NPTE9SLCBnbC5aRVJPLCBnbC5TUkNfQUxQSEEgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLmJsZW5kRXF1YXRpb24oIGdsLkZVTkNfQUREICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wuYmxlbmRGdW5jKCBnbC5aRVJPLCBnbC5TUkNfQ09MT1IgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGVmYXVsdDpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHByZW11bHRpcGxpZWRBbHBoYSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoIGdsLkZVTkNfQURELCBnbC5GVU5DX0FERCApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKCBnbC5GVU5DX0FERCwgZ2wuRlVOQ19BREQgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRjdXJyZW50QmxlbmRFcXVhdGlvbiA9IG51bGw7XFxuXFx0XFx0XFx0XFx0Y3VycmVudEJsZW5kU3JjID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRjdXJyZW50QmxlbmREc3QgPSBudWxsO1xcblxcdFxcdFxcdFxcdGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xcblxcdFxcdFxcdFxcdGN1cnJlbnRCbGVuZFNyY0FscGhhID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRjdXJyZW50QmxlbmREc3RBbHBoYSA9IG51bGw7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRibGVuZEVxdWF0aW9uQWxwaGEgPSBibGVuZEVxdWF0aW9uQWxwaGEgfHwgYmxlbmRFcXVhdGlvbjtcXG5cXHRcXHRcXHRcXHRibGVuZFNyY0FscGhhID0gYmxlbmRTcmNBbHBoYSB8fCBibGVuZFNyYztcXG5cXHRcXHRcXHRcXHRibGVuZERzdEFscGhhID0gYmxlbmREc3RBbHBoYSB8fCBibGVuZERzdDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGJsZW5kRXF1YXRpb24gIT09IGN1cnJlbnRCbGVuZEVxdWF0aW9uIHx8IGJsZW5kRXF1YXRpb25BbHBoYSAhPT0gY3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoIHV0aWxzLmNvbnZlcnQoIGJsZW5kRXF1YXRpb24gKSwgdXRpbHMuY29udmVydCggYmxlbmRFcXVhdGlvbkFscGhhICkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjdXJyZW50QmxlbmRFcXVhdGlvbiA9IGJsZW5kRXF1YXRpb247XFxuXFx0XFx0XFx0XFx0XFx0Y3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IGJsZW5kRXF1YXRpb25BbHBoYTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBibGVuZFNyYyAhPT0gY3VycmVudEJsZW5kU3JjIHx8IGJsZW5kRHN0ICE9PSBjdXJyZW50QmxlbmREc3QgfHwgYmxlbmRTcmNBbHBoYSAhPT0gY3VycmVudEJsZW5kU3JjQWxwaGEgfHwgYmxlbmREc3RBbHBoYSAhPT0gY3VycmVudEJsZW5kRHN0QWxwaGEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIHV0aWxzLmNvbnZlcnQoIGJsZW5kU3JjICksIHV0aWxzLmNvbnZlcnQoIGJsZW5kRHN0ICksIHV0aWxzLmNvbnZlcnQoIGJsZW5kU3JjQWxwaGEgKSwgdXRpbHMuY29udmVydCggYmxlbmREc3RBbHBoYSApICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y3VycmVudEJsZW5kU3JjID0gYmxlbmRTcmM7XFxuXFx0XFx0XFx0XFx0XFx0Y3VycmVudEJsZW5kRHN0ID0gYmxlbmREc3Q7XFxuXFx0XFx0XFx0XFx0XFx0Y3VycmVudEJsZW5kU3JjQWxwaGEgPSBibGVuZFNyY0FscGhhO1xcblxcdFxcdFxcdFxcdFxcdGN1cnJlbnRCbGVuZERzdEFscGhhID0gYmxlbmREc3RBbHBoYTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGN1cnJlbnRCbGVuZGluZyA9IGJsZW5kaW5nO1xcblxcdFxcdFxcdGN1cnJlbnRQcmVtdWx0aXBsZWRBbHBoYSA9IHByZW11bHRpcGxpZWRBbHBoYTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gc2V0TWF0ZXJpYWwoIG1hdGVyaWFsLCBmcm9udEZhY2VDVyApIHtcXG5cXG5cXHRcXHRcXHRtYXRlcmlhbC5zaWRlID09PSBEb3VibGVTaWRlXFxuXFx0XFx0XFx0XFx0PyBkaXNhYmxlKCBnbC5DVUxMX0ZBQ0UgKVxcblxcdFxcdFxcdFxcdDogZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcXG5cXG5cXHRcXHRcXHR2YXIgZmxpcFNpZGVkID0gKCBtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSApO1xcblxcdFxcdFxcdGlmICggZnJvbnRGYWNlQ1cgKSBmbGlwU2lkZWQgPSAhIGZsaXBTaWRlZDtcXG5cXG5cXHRcXHRcXHRzZXRGbGlwU2lkZWQoIGZsaXBTaWRlZCApO1xcblxcblxcdFxcdFxcdG1hdGVyaWFsLnRyYW5zcGFyZW50ID09PSB0cnVlXFxuXFx0XFx0XFx0XFx0PyBzZXRCbGVuZGluZyggbWF0ZXJpYWwuYmxlbmRpbmcsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb24sIG1hdGVyaWFsLmJsZW5kU3JjLCBtYXRlcmlhbC5ibGVuZERzdCwgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbkFscGhhLCBtYXRlcmlhbC5ibGVuZFNyY0FscGhhLCBtYXRlcmlhbC5ibGVuZERzdEFscGhhLCBtYXRlcmlhbC5wcmVtdWx0aXBsaWVkQWxwaGEgKVxcblxcdFxcdFxcdFxcdDogc2V0QmxlbmRpbmcoIE5vQmxlbmRpbmcgKTtcXG5cXG5cXHRcXHRcXHRkZXB0aEJ1ZmZlci5zZXRGdW5jKCBtYXRlcmlhbC5kZXB0aEZ1bmMgKTtcXG5cXHRcXHRcXHRkZXB0aEJ1ZmZlci5zZXRUZXN0KCBtYXRlcmlhbC5kZXB0aFRlc3QgKTtcXG5cXHRcXHRcXHRkZXB0aEJ1ZmZlci5zZXRNYXNrKCBtYXRlcmlhbC5kZXB0aFdyaXRlICk7XFxuXFx0XFx0XFx0Y29sb3JCdWZmZXIuc2V0TWFzayggbWF0ZXJpYWwuY29sb3JXcml0ZSApO1xcblxcblxcdFxcdFxcdHNldFBvbHlnb25PZmZzZXQoIG1hdGVyaWFsLnBvbHlnb25PZmZzZXQsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRGYWN0b3IsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRVbml0cyApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvL1xcblxcblxcdFxcdGZ1bmN0aW9uIHNldEZsaXBTaWRlZCggZmxpcFNpZGVkICkge1xcblxcblxcdFxcdFxcdGlmICggY3VycmVudEZsaXBTaWRlZCAhPT0gZmxpcFNpZGVkICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggZmxpcFNpZGVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGdsLmZyb250RmFjZSggZ2wuQ1cgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdGdsLmZyb250RmFjZSggZ2wuQ0NXICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGN1cnJlbnRGbGlwU2lkZWQgPSBmbGlwU2lkZWQ7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBzZXRDdWxsRmFjZSggY3VsbEZhY2UgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBjdWxsRmFjZSAhPT0gQ3VsbEZhY2VOb25lICkge1xcblxcblxcdFxcdFxcdFxcdGVuYWJsZSggZ2wuQ1VMTF9GQUNFICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBjdWxsRmFjZSAhPT0gY3VycmVudEN1bGxGYWNlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggY3VsbEZhY2UgPT09IEN1bGxGYWNlQmFjayApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRnbC5jdWxsRmFjZSggZ2wuQkFDSyApO1xcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIGN1bGxGYWNlID09PSBDdWxsRmFjZUZyb250ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGdsLmN1bGxGYWNlKCBnbC5GUk9OVCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2wuY3VsbEZhY2UoIGdsLkZST05UX0FORF9CQUNLICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdGRpc2FibGUoIGdsLkNVTExfRkFDRSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRjdXJyZW50Q3VsbEZhY2UgPSBjdWxsRmFjZTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gc2V0TGluZVdpZHRoKCB3aWR0aCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHdpZHRoICE9PSBjdXJyZW50TGluZVdpZHRoICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggbGluZVdpZHRoQXZhaWxhYmxlICkgZ2wubGluZVdpZHRoKCB3aWR0aCApO1xcblxcblxcdFxcdFxcdFxcdGN1cnJlbnRMaW5lV2lkdGggPSB3aWR0aDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHNldFBvbHlnb25PZmZzZXQoIHBvbHlnb25PZmZzZXQsIGZhY3RvciwgdW5pdHMgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBwb2x5Z29uT2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdFxcdGVuYWJsZSggZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCApO1xcblxcblxcdFxcdFxcdFxcdGlmICggY3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgIT09IGZhY3RvciB8fCBjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzICE9PSB1bml0cyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRnbC5wb2x5Z29uT2Zmc2V0KCBmYWN0b3IsIHVuaXRzICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgPSBmYWN0b3I7XFxuXFx0XFx0XFx0XFx0XFx0Y3VycmVudFBvbHlnb25PZmZzZXRVbml0cyA9IHVuaXRzO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdGRpc2FibGUoIGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHNldFNjaXNzb3JUZXN0KCBzY2lzc29yVGVzdCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHNjaXNzb3JUZXN0ICkge1xcblxcblxcdFxcdFxcdFxcdGVuYWJsZSggZ2wuU0NJU1NPUl9URVNUICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRkaXNhYmxlKCBnbC5TQ0lTU09SX1RFU1QgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIHRleHR1cmVcXG5cXG5cXHRcXHRmdW5jdGlvbiBhY3RpdmVUZXh0dXJlKCB3ZWJnbFNsb3QgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB3ZWJnbFNsb3QgPT09IHVuZGVmaW5lZCApIHdlYmdsU2xvdCA9IGdsLlRFWFRVUkUwICsgbWF4VGV4dHVyZXMgLSAxO1xcblxcblxcdFxcdFxcdGlmICggY3VycmVudFRleHR1cmVTbG90ICE9PSB3ZWJnbFNsb3QgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Z2wuYWN0aXZlVGV4dHVyZSggd2ViZ2xTbG90ICk7XFxuXFx0XFx0XFx0XFx0Y3VycmVudFRleHR1cmVTbG90ID0gd2ViZ2xTbG90O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gYmluZFRleHR1cmUoIHdlYmdsVHlwZSwgd2ViZ2xUZXh0dXJlICkge1xcblxcblxcdFxcdFxcdGlmICggY3VycmVudFRleHR1cmVTbG90ID09PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdGFjdGl2ZVRleHR1cmUoKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIGJvdW5kVGV4dHVyZSA9IGN1cnJlbnRCb3VuZFRleHR1cmVzWyBjdXJyZW50VGV4dHVyZVNsb3QgXTtcXG5cXG5cXHRcXHRcXHRpZiAoIGJvdW5kVGV4dHVyZSA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGJvdW5kVGV4dHVyZSA9IHsgdHlwZTogdW5kZWZpbmVkLCB0ZXh0dXJlOiB1bmRlZmluZWQgfTtcXG5cXHRcXHRcXHRcXHRjdXJyZW50Qm91bmRUZXh0dXJlc1sgY3VycmVudFRleHR1cmVTbG90IF0gPSBib3VuZFRleHR1cmU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggYm91bmRUZXh0dXJlLnR5cGUgIT09IHdlYmdsVHlwZSB8fCBib3VuZFRleHR1cmUudGV4dHVyZSAhPT0gd2ViZ2xUZXh0dXJlICkge1xcblxcblxcdFxcdFxcdFxcdGdsLmJpbmRUZXh0dXJlKCB3ZWJnbFR5cGUsIHdlYmdsVGV4dHVyZSB8fCBlbXB0eVRleHR1cmVzWyB3ZWJnbFR5cGUgXSApO1xcblxcblxcdFxcdFxcdFxcdGJvdW5kVGV4dHVyZS50eXBlID0gd2ViZ2xUeXBlO1xcblxcdFxcdFxcdFxcdGJvdW5kVGV4dHVyZS50ZXh0dXJlID0gd2ViZ2xUZXh0dXJlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gY29tcHJlc3NlZFRleEltYWdlMkQoKSB7XFxuXFxuXFx0XFx0XFx0dHJ5IHtcXG5cXG5cXHRcXHRcXHRcXHRnbC5jb21wcmVzc2VkVGV4SW1hZ2UyRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xcblxcblxcdFxcdFxcdH0gY2F0Y2ggKCBlcnJvciApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xTdGF0ZTonLCBlcnJvciApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gdGV4SW1hZ2UyRCgpIHtcXG5cXG5cXHRcXHRcXHR0cnkge1xcblxcblxcdFxcdFxcdFxcdGdsLnRleEltYWdlMkQuYXBwbHkoIGdsLCBhcmd1bWVudHMgKTtcXG5cXG5cXHRcXHRcXHR9IGNhdGNoICggZXJyb3IgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMU3RhdGU6JywgZXJyb3IgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vXFxuXFxuXFx0XFx0ZnVuY3Rpb24gc2Npc3Nvciggc2Npc3NvciApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGN1cnJlbnRTY2lzc29yLmVxdWFscyggc2Npc3NvciApID09PSBmYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRnbC5zY2lzc29yKCBzY2lzc29yLngsIHNjaXNzb3IueSwgc2Npc3Nvci56LCBzY2lzc29yLncgKTtcXG5cXHRcXHRcXHRcXHRjdXJyZW50U2Npc3Nvci5jb3B5KCBzY2lzc29yICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiB2aWV3cG9ydCggdmlld3BvcnQgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBjdXJyZW50Vmlld3BvcnQuZXF1YWxzKCB2aWV3cG9ydCApID09PSBmYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRnbC52aWV3cG9ydCggdmlld3BvcnQueCwgdmlld3BvcnQueSwgdmlld3BvcnQueiwgdmlld3BvcnQudyApO1xcblxcdFxcdFxcdFxcdGN1cnJlbnRWaWV3cG9ydC5jb3B5KCB2aWV3cG9ydCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly9cXG5cXG5cXHRcXHRmdW5jdGlvbiByZXNldCgpIHtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbmFibGVkQXR0cmlidXRlcy5sZW5ndGg7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBlbmFibGVkQXR0cmlidXRlc1sgaSBdID09PSAxICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSggaSApO1xcblxcdFxcdFxcdFxcdFxcdGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPSAwO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Y2FwYWJpbGl0aWVzID0ge307XFxuXFxuXFx0XFx0XFx0Y29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID0gbnVsbDtcXG5cXG5cXHRcXHRcXHRjdXJyZW50VGV4dHVyZVNsb3QgPSBudWxsO1xcblxcdFxcdFxcdGN1cnJlbnRCb3VuZFRleHR1cmVzID0ge307XFxuXFxuXFx0XFx0XFx0Y3VycmVudFByb2dyYW0gPSBudWxsO1xcblxcblxcdFxcdFxcdGN1cnJlbnRCbGVuZGluZyA9IG51bGw7XFxuXFxuXFx0XFx0XFx0Y3VycmVudEZsaXBTaWRlZCA9IG51bGw7XFxuXFx0XFx0XFx0Y3VycmVudEN1bGxGYWNlID0gbnVsbDtcXG5cXG5cXHRcXHRcXHRjb2xvckJ1ZmZlci5yZXNldCgpO1xcblxcdFxcdFxcdGRlcHRoQnVmZmVyLnJlc2V0KCk7XFxuXFx0XFx0XFx0c3RlbmNpbEJ1ZmZlci5yZXNldCgpO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4ge1xcblxcblxcdFxcdFxcdGJ1ZmZlcnM6IHtcXG5cXHRcXHRcXHRcXHRjb2xvcjogY29sb3JCdWZmZXIsXFxuXFx0XFx0XFx0XFx0ZGVwdGg6IGRlcHRoQnVmZmVyLFxcblxcdFxcdFxcdFxcdHN0ZW5jaWw6IHN0ZW5jaWxCdWZmZXJcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdGluaXRBdHRyaWJ1dGVzOiBpbml0QXR0cmlidXRlcyxcXG5cXHRcXHRcXHRlbmFibGVBdHRyaWJ1dGU6IGVuYWJsZUF0dHJpYnV0ZSxcXG5cXHRcXHRcXHRlbmFibGVBdHRyaWJ1dGVBbmREaXZpc29yOiBlbmFibGVBdHRyaWJ1dGVBbmREaXZpc29yLFxcblxcdFxcdFxcdGRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzOiBkaXNhYmxlVW51c2VkQXR0cmlidXRlcyxcXG5cXHRcXHRcXHRlbmFibGU6IGVuYWJsZSxcXG5cXHRcXHRcXHRkaXNhYmxlOiBkaXNhYmxlLFxcblxcdFxcdFxcdGdldENvbXByZXNzZWRUZXh0dXJlRm9ybWF0czogZ2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzLFxcblxcblxcdFxcdFxcdHVzZVByb2dyYW06IHVzZVByb2dyYW0sXFxuXFxuXFx0XFx0XFx0c2V0QmxlbmRpbmc6IHNldEJsZW5kaW5nLFxcblxcdFxcdFxcdHNldE1hdGVyaWFsOiBzZXRNYXRlcmlhbCxcXG5cXG5cXHRcXHRcXHRzZXRGbGlwU2lkZWQ6IHNldEZsaXBTaWRlZCxcXG5cXHRcXHRcXHRzZXRDdWxsRmFjZTogc2V0Q3VsbEZhY2UsXFxuXFxuXFx0XFx0XFx0c2V0TGluZVdpZHRoOiBzZXRMaW5lV2lkdGgsXFxuXFx0XFx0XFx0c2V0UG9seWdvbk9mZnNldDogc2V0UG9seWdvbk9mZnNldCxcXG5cXG5cXHRcXHRcXHRzZXRTY2lzc29yVGVzdDogc2V0U2Npc3NvclRlc3QsXFxuXFxuXFx0XFx0XFx0YWN0aXZlVGV4dHVyZTogYWN0aXZlVGV4dHVyZSxcXG5cXHRcXHRcXHRiaW5kVGV4dHVyZTogYmluZFRleHR1cmUsXFxuXFx0XFx0XFx0Y29tcHJlc3NlZFRleEltYWdlMkQ6IGNvbXByZXNzZWRUZXhJbWFnZTJELFxcblxcdFxcdFxcdHRleEltYWdlMkQ6IHRleEltYWdlMkQsXFxuXFxuXFx0XFx0XFx0c2Npc3Nvcjogc2Npc3NvcixcXG5cXHRcXHRcXHR2aWV3cG9ydDogdmlld3BvcnQsXFxuXFxuXFx0XFx0XFx0cmVzZXQ6IHJlc2V0XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHR9XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBXZWJHTENhcGFiaWxpdGllcyggZ2wsIGV4dGVuc2lvbnMsIHBhcmFtZXRlcnMgKSB7XFxuXFxuXFx0XFx0dmFyIG1heEFuaXNvdHJvcHk7XFxuXFxuXFx0XFx0ZnVuY3Rpb24gZ2V0TWF4QW5pc290cm9weSgpIHtcXG5cXG5cXHRcXHRcXHRpZiAoIG1heEFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCApIHJldHVybiBtYXhBbmlzb3Ryb3B5O1xcblxcblxcdFxcdFxcdHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRtYXhBbmlzb3Ryb3B5ID0gZ2wuZ2V0UGFyYW1ldGVyKCBleHRlbnNpb24uTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRtYXhBbmlzb3Ryb3B5ID0gMDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG1heEFuaXNvdHJvcHk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGdldE1heFByZWNpc2lvbiggcHJlY2lzaW9uICkge1xcblxcblxcdFxcdFxcdGlmICggcHJlY2lzaW9uID09PSAnaGlnaHAnICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5WRVJURVhfU0hBREVSLCBnbC5ISUdIX0ZMT0FUICkucHJlY2lzaW9uID4gMCAmJlxcblxcdFxcdFxcdFxcdCAgICAgZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkhJR0hfRkxPQVQgKS5wcmVjaXNpb24gPiAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiAnaGlnaHAnO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRwcmVjaXNpb24gPSAnbWVkaXVtcCc7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggcHJlY2lzaW9uID09PSAnbWVkaXVtcCcgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIGdsLlZFUlRFWF9TSEFERVIsIGdsLk1FRElVTV9GTE9BVCApLnByZWNpc2lvbiA+IDAgJiZcXG5cXHRcXHRcXHRcXHQgICAgIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5NRURJVU1fRkxPQVQgKS5wcmVjaXNpb24gPiAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiAnbWVkaXVtcCc7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gJ2xvd3AnO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR2YXIgcHJlY2lzaW9uID0gcGFyYW1ldGVycy5wcmVjaXNpb24gIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucHJlY2lzaW9uIDogJ2hpZ2hwJztcXG5cXHRcXHR2YXIgbWF4UHJlY2lzaW9uID0gZ2V0TWF4UHJlY2lzaW9uKCBwcmVjaXNpb24gKTtcXG5cXG5cXHRcXHRpZiAoIG1heFByZWNpc2lvbiAhPT0gcHJlY2lzaW9uICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6JywgcHJlY2lzaW9uLCAnbm90IHN1cHBvcnRlZCwgdXNpbmcnLCBtYXhQcmVjaXNpb24sICdpbnN0ZWFkLicgKTtcXG5cXHRcXHRcXHRwcmVjaXNpb24gPSBtYXhQcmVjaXNpb247XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHZhciBsb2dhcml0aG1pY0RlcHRoQnVmZmVyID0gcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID09PSB0cnVlO1xcblxcblxcdFxcdHZhciBtYXhUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcXG5cXHRcXHR2YXIgbWF4VmVydGV4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUyApO1xcblxcdFxcdHZhciBtYXhUZXh0dXJlU2l6ZSA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1RFWFRVUkVfU0laRSApO1xcblxcdFxcdHZhciBtYXhDdWJlbWFwU2l6ZSA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSApO1xcblxcblxcdFxcdHZhciBtYXhBdHRyaWJ1dGVzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkVSVEVYX0FUVFJJQlMgKTtcXG5cXHRcXHR2YXIgbWF4VmVydGV4VW5pZm9ybXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WRVJURVhfVU5JRk9STV9WRUNUT1JTICk7XFxuXFx0XFx0dmFyIG1heFZhcnlpbmdzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkFSWUlOR19WRUNUT1JTICk7XFxuXFx0XFx0dmFyIG1heEZyYWdtZW50VW5pZm9ybXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9GUkFHTUVOVF9VTklGT1JNX1ZFQ1RPUlMgKTtcXG5cXG5cXHRcXHR2YXIgdmVydGV4VGV4dHVyZXMgPSBtYXhWZXJ0ZXhUZXh0dXJlcyA+IDA7XFxuXFx0XFx0dmFyIGZsb2F0RnJhZ21lbnRUZXh0dXJlcyA9ICEhIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXQnICk7XFxuXFx0XFx0dmFyIGZsb2F0VmVydGV4VGV4dHVyZXMgPSB2ZXJ0ZXhUZXh0dXJlcyAmJiBmbG9hdEZyYWdtZW50VGV4dHVyZXM7XFxuXFxuXFx0XFx0cmV0dXJuIHtcXG5cXG5cXHRcXHRcXHRnZXRNYXhBbmlzb3Ryb3B5OiBnZXRNYXhBbmlzb3Ryb3B5LFxcblxcdFxcdFxcdGdldE1heFByZWNpc2lvbjogZ2V0TWF4UHJlY2lzaW9uLFxcblxcblxcdFxcdFxcdHByZWNpc2lvbjogcHJlY2lzaW9uLFxcblxcdFxcdFxcdGxvZ2FyaXRobWljRGVwdGhCdWZmZXI6IGxvZ2FyaXRobWljRGVwdGhCdWZmZXIsXFxuXFxuXFx0XFx0XFx0bWF4VGV4dHVyZXM6IG1heFRleHR1cmVzLFxcblxcdFxcdFxcdG1heFZlcnRleFRleHR1cmVzOiBtYXhWZXJ0ZXhUZXh0dXJlcyxcXG5cXHRcXHRcXHRtYXhUZXh0dXJlU2l6ZTogbWF4VGV4dHVyZVNpemUsXFxuXFx0XFx0XFx0bWF4Q3ViZW1hcFNpemU6IG1heEN1YmVtYXBTaXplLFxcblxcblxcdFxcdFxcdG1heEF0dHJpYnV0ZXM6IG1heEF0dHJpYnV0ZXMsXFxuXFx0XFx0XFx0bWF4VmVydGV4VW5pZm9ybXM6IG1heFZlcnRleFVuaWZvcm1zLFxcblxcdFxcdFxcdG1heFZhcnlpbmdzOiBtYXhWYXJ5aW5ncyxcXG5cXHRcXHRcXHRtYXhGcmFnbWVudFVuaWZvcm1zOiBtYXhGcmFnbWVudFVuaWZvcm1zLFxcblxcblxcdFxcdFxcdHZlcnRleFRleHR1cmVzOiB2ZXJ0ZXhUZXh0dXJlcyxcXG5cXHRcXHRcXHRmbG9hdEZyYWdtZW50VGV4dHVyZXM6IGZsb2F0RnJhZ21lbnRUZXh0dXJlcyxcXG5cXHRcXHRcXHRmbG9hdFZlcnRleFRleHR1cmVzOiBmbG9hdFZlcnRleFRleHR1cmVzXFxuXFxuXFx0XFx0fTtcXG5cXG5cXHR9XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIGdyZWdnbWFuIC8gaHR0cDovL2dhbWVzLmdyZWdnbWFuLmNvbS9cXG5cXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXFxuXFx0ICogQGF1dGhvciB0c2Nod1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICkge1xcblxcblxcdFxcdENhbWVyYS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1BlcnNwZWN0aXZlQ2FtZXJhJztcXG5cXG5cXHRcXHR0aGlzLmZvdiA9IGZvdiAhPT0gdW5kZWZpbmVkID8gZm92IDogNTA7XFxuXFx0XFx0dGhpcy56b29tID0gMTtcXG5cXG5cXHRcXHR0aGlzLm5lYXIgPSBuZWFyICE9PSB1bmRlZmluZWQgPyBuZWFyIDogMC4xO1xcblxcdFxcdHRoaXMuZmFyID0gZmFyICE9PSB1bmRlZmluZWQgPyBmYXIgOiAyMDAwO1xcblxcdFxcdHRoaXMuZm9jdXMgPSAxMDtcXG5cXG5cXHRcXHR0aGlzLmFzcGVjdCA9IGFzcGVjdCAhPT0gdW5kZWZpbmVkID8gYXNwZWN0IDogMTtcXG5cXHRcXHR0aGlzLnZpZXcgPSBudWxsO1xcblxcblxcdFxcdHRoaXMuZmlsbUdhdWdlID0gMzU7XFx0Ly8gd2lkdGggb2YgdGhlIGZpbG0gKGRlZmF1bHQgaW4gbWlsbGltZXRlcnMpXFxuXFx0XFx0dGhpcy5maWxtT2Zmc2V0ID0gMDtcXHQvLyBob3Jpem9udGFsIGZpbG0gb2Zmc2V0IChzYW1lIHVuaXQgYXMgZ2F1Z2UpXFxuXFxuXFx0XFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XFxuXFxuXFx0fVxcblxcblxcdFBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIENhbWVyYS5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBQZXJzcGVjdGl2ZUNhbWVyYSxcXG5cXG5cXHRcXHRpc1BlcnNwZWN0aXZlQ2FtZXJhOiB0cnVlLFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlLCByZWN1cnNpdmUgKSB7XFxuXFxuXFx0XFx0XFx0Q2FtZXJhLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSwgcmVjdXJzaXZlICk7XFxuXFxuXFx0XFx0XFx0dGhpcy5mb3YgPSBzb3VyY2UuZm92O1xcblxcdFxcdFxcdHRoaXMuem9vbSA9IHNvdXJjZS56b29tO1xcblxcblxcdFxcdFxcdHRoaXMubmVhciA9IHNvdXJjZS5uZWFyO1xcblxcdFxcdFxcdHRoaXMuZmFyID0gc291cmNlLmZhcjtcXG5cXHRcXHRcXHR0aGlzLmZvY3VzID0gc291cmNlLmZvY3VzO1xcblxcblxcdFxcdFxcdHRoaXMuYXNwZWN0ID0gc291cmNlLmFzcGVjdDtcXG5cXHRcXHRcXHR0aGlzLnZpZXcgPSBzb3VyY2UudmlldyA9PT0gbnVsbCA/IG51bGwgOiBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnZpZXcgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLmZpbG1HYXVnZSA9IHNvdXJjZS5maWxtR2F1Z2U7XFxuXFx0XFx0XFx0dGhpcy5maWxtT2Zmc2V0ID0gc291cmNlLmZpbG1PZmZzZXQ7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBTZXRzIHRoZSBGT1YgYnkgZm9jYWwgbGVuZ3RoIGluIHJlc3BlY3QgdG8gdGhlIGN1cnJlbnQgLmZpbG1HYXVnZS5cXG5cXHRcXHQgKlxcblxcdFxcdCAqIFRoZSBkZWZhdWx0IGZpbG0gZ2F1Z2UgaXMgMzUsIHNvIHRoYXQgdGhlIGZvY2FsIGxlbmd0aCBjYW4gYmUgc3BlY2lmaWVkIGZvclxcblxcdFxcdCAqIGEgMzVtbSAoZnVsbCBmcmFtZSkgY2FtZXJhLlxcblxcdFxcdCAqXFxuXFx0XFx0ICogVmFsdWVzIGZvciBmb2NhbCBsZW5ndGggYW5kIGZpbG0gZ2F1Z2UgbXVzdCBoYXZlIHRoZSBzYW1lIHVuaXQuXFxuXFx0XFx0ICovXFxuXFx0XFx0c2V0Rm9jYWxMZW5ndGg6IGZ1bmN0aW9uICggZm9jYWxMZW5ndGggKSB7XFxuXFxuXFx0XFx0XFx0Ly8gc2VlIGh0dHA6Ly93d3cuYm9iYXRraW5zLmNvbS9waG90b2dyYXBoeS90ZWNobmljYWwvZmllbGRfb2Zfdmlldy5odG1sXFxuXFx0XFx0XFx0dmFyIHZFeHRlbnRTbG9wZSA9IDAuNSAqIHRoaXMuZ2V0RmlsbUhlaWdodCgpIC8gZm9jYWxMZW5ndGg7XFxuXFxuXFx0XFx0XFx0dGhpcy5mb3YgPSBfTWF0aC5SQUQyREVHICogMiAqIE1hdGguYXRhbiggdkV4dGVudFNsb3BlICk7XFxuXFx0XFx0XFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBDYWxjdWxhdGVzIHRoZSBmb2NhbCBsZW5ndGggZnJvbSB0aGUgY3VycmVudCAuZm92IGFuZCAuZmlsbUdhdWdlLlxcblxcdFxcdCAqL1xcblxcdFxcdGdldEZvY2FsTGVuZ3RoOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHZFeHRlbnRTbG9wZSA9IE1hdGgudGFuKCBfTWF0aC5ERUcyUkFEICogMC41ICogdGhpcy5mb3YgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gMC41ICogdGhpcy5nZXRGaWxtSGVpZ2h0KCkgLyB2RXh0ZW50U2xvcGU7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRFZmZlY3RpdmVGT1Y6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gX01hdGguUkFEMkRFRyAqIDIgKiBNYXRoLmF0YW4oXFxuXFx0XFx0XFx0XFx0TWF0aC50YW4oIF9NYXRoLkRFRzJSQUQgKiAwLjUgKiB0aGlzLmZvdiApIC8gdGhpcy56b29tICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRGaWxtV2lkdGg6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHQvLyBmaWxtIG5vdCBjb21wbGV0ZWx5IGNvdmVyZWQgaW4gcG9ydHJhaXQgZm9ybWF0IChhc3BlY3QgPCAxKVxcblxcdFxcdFxcdHJldHVybiB0aGlzLmZpbG1HYXVnZSAqIE1hdGgubWluKCB0aGlzLmFzcGVjdCwgMSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0RmlsbUhlaWdodDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdC8vIGZpbG0gbm90IGNvbXBsZXRlbHkgY292ZXJlZCBpbiBsYW5kc2NhcGUgZm9ybWF0IChhc3BlY3QgPiAxKVxcblxcdFxcdFxcdHJldHVybiB0aGlzLmZpbG1HYXVnZSAvIE1hdGgubWF4KCB0aGlzLmFzcGVjdCwgMSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogU2V0cyBhbiBvZmZzZXQgaW4gYSBsYXJnZXIgZnJ1c3R1bS4gVGhpcyBpcyB1c2VmdWwgZm9yIG11bHRpLXdpbmRvdyBvclxcblxcdFxcdCAqIG11bHRpLW1vbml0b3IvbXVsdGktbWFjaGluZSBzZXR1cHMuXFxuXFx0XFx0ICpcXG5cXHRcXHQgKiBGb3IgZXhhbXBsZSwgaWYgeW91IGhhdmUgM3gyIG1vbml0b3JzIGFuZCBlYWNoIG1vbml0b3IgaXMgMTkyMHgxMDgwIGFuZFxcblxcdFxcdCAqIHRoZSBtb25pdG9ycyBhcmUgaW4gZ3JpZCBsaWtlIHRoaXNcXG5cXHRcXHQgKlxcblxcdFxcdCAqICAgKy0tLSstLS0rLS0tK1xcblxcdFxcdCAqICAgfCBBIHwgQiB8IEMgfFxcblxcdFxcdCAqICAgKy0tLSstLS0rLS0tK1xcblxcdFxcdCAqICAgfCBEIHwgRSB8IEYgfFxcblxcdFxcdCAqICAgKy0tLSstLS0rLS0tK1xcblxcdFxcdCAqXFxuXFx0XFx0ICogdGhlbiBmb3IgZWFjaCBtb25pdG9yIHlvdSB3b3VsZCBjYWxsIGl0IGxpa2UgdGhpc1xcblxcdFxcdCAqXFxuXFx0XFx0ICogICB2YXIgdyA9IDE5MjA7XFxuXFx0XFx0ICogICB2YXIgaCA9IDEwODA7XFxuXFx0XFx0ICogICB2YXIgZnVsbFdpZHRoID0gdyAqIDM7XFxuXFx0XFx0ICogICB2YXIgZnVsbEhlaWdodCA9IGggKiAyO1xcblxcdFxcdCAqXFxuXFx0XFx0ICogICAtLUEtLVxcblxcdFxcdCAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMCwgaCAqIDAsIHcsIGggKTtcXG5cXHRcXHQgKiAgIC0tQi0tXFxuXFx0XFx0ICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAxLCBoICogMCwgdywgaCApO1xcblxcdFxcdCAqICAgLS1DLS1cXG5cXHRcXHQgKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDIsIGggKiAwLCB3LCBoICk7XFxuXFx0XFx0ICogICAtLUQtLVxcblxcdFxcdCAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMCwgaCAqIDEsIHcsIGggKTtcXG5cXHRcXHQgKiAgIC0tRS0tXFxuXFx0XFx0ICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAxLCBoICogMSwgdywgaCApO1xcblxcdFxcdCAqICAgLS1GLS1cXG5cXHRcXHQgKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDIsIGggKiAxLCB3LCBoICk7XFxuXFx0XFx0ICpcXG5cXHRcXHQgKiAgIE5vdGUgdGhlcmUgaXMgbm8gcmVhc29uIG1vbml0b3JzIGhhdmUgdG8gYmUgdGhlIHNhbWUgc2l6ZSBvciBpbiBhIGdyaWQuXFxuXFx0XFx0ICovXFxuXFx0XFx0c2V0Vmlld09mZnNldDogZnVuY3Rpb24gKCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5hc3BlY3QgPSBmdWxsV2lkdGggLyBmdWxsSGVpZ2h0O1xcblxcblxcdFxcdFxcdGlmICggdGhpcy52aWV3ID09PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMudmlldyA9IHtcXG5cXHRcXHRcXHRcXHRcXHRlbmFibGVkOiB0cnVlLFxcblxcdFxcdFxcdFxcdFxcdGZ1bGxXaWR0aDogMSxcXG5cXHRcXHRcXHRcXHRcXHRmdWxsSGVpZ2h0OiAxLFxcblxcdFxcdFxcdFxcdFxcdG9mZnNldFg6IDAsXFxuXFx0XFx0XFx0XFx0XFx0b2Zmc2V0WTogMCxcXG5cXHRcXHRcXHRcXHRcXHR3aWR0aDogMSxcXG5cXHRcXHRcXHRcXHRcXHRoZWlnaHQ6IDFcXG5cXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLnZpZXcuZW5hYmxlZCA9IHRydWU7XFxuXFx0XFx0XFx0dGhpcy52aWV3LmZ1bGxXaWR0aCA9IGZ1bGxXaWR0aDtcXG5cXHRcXHRcXHR0aGlzLnZpZXcuZnVsbEhlaWdodCA9IGZ1bGxIZWlnaHQ7XFxuXFx0XFx0XFx0dGhpcy52aWV3Lm9mZnNldFggPSB4O1xcblxcdFxcdFxcdHRoaXMudmlldy5vZmZzZXRZID0geTtcXG5cXHRcXHRcXHR0aGlzLnZpZXcud2lkdGggPSB3aWR0aDtcXG5cXHRcXHRcXHR0aGlzLnZpZXcuaGVpZ2h0ID0gaGVpZ2h0O1xcblxcblxcdFxcdFxcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xlYXJWaWV3T2Zmc2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnZpZXcgIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy52aWV3LmVuYWJsZWQgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR1cGRhdGVQcm9qZWN0aW9uTWF0cml4OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIG5lYXIgPSB0aGlzLm5lYXIsXFxuXFx0XFx0XFx0XFx0dG9wID0gbmVhciAqIE1hdGgudGFuKFxcblxcdFxcdFxcdFxcdFxcdF9NYXRoLkRFRzJSQUQgKiAwLjUgKiB0aGlzLmZvdiApIC8gdGhpcy56b29tLFxcblxcdFxcdFxcdFxcdGhlaWdodCA9IDIgKiB0b3AsXFxuXFx0XFx0XFx0XFx0d2lkdGggPSB0aGlzLmFzcGVjdCAqIGhlaWdodCxcXG5cXHRcXHRcXHRcXHRsZWZ0ID0gLSAwLjUgKiB3aWR0aCxcXG5cXHRcXHRcXHRcXHR2aWV3ID0gdGhpcy52aWV3O1xcblxcblxcdFxcdFxcdGlmICggdGhpcy52aWV3ICE9PSBudWxsICYmIHRoaXMudmlldy5lbmFibGVkICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBmdWxsV2lkdGggPSB2aWV3LmZ1bGxXaWR0aCxcXG5cXHRcXHRcXHRcXHRcXHRmdWxsSGVpZ2h0ID0gdmlldy5mdWxsSGVpZ2h0O1xcblxcblxcdFxcdFxcdFxcdGxlZnQgKz0gdmlldy5vZmZzZXRYICogd2lkdGggLyBmdWxsV2lkdGg7XFxuXFx0XFx0XFx0XFx0dG9wIC09IHZpZXcub2Zmc2V0WSAqIGhlaWdodCAvIGZ1bGxIZWlnaHQ7XFxuXFx0XFx0XFx0XFx0d2lkdGggKj0gdmlldy53aWR0aCAvIGZ1bGxXaWR0aDtcXG5cXHRcXHRcXHRcXHRoZWlnaHQgKj0gdmlldy5oZWlnaHQgLyBmdWxsSGVpZ2h0O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgc2tldyA9IHRoaXMuZmlsbU9mZnNldDtcXG5cXHRcXHRcXHRpZiAoIHNrZXcgIT09IDAgKSBsZWZ0ICs9IG5lYXIgKiBza2V3IC8gdGhpcy5nZXRGaWxtV2lkdGgoKTtcXG5cXG5cXHRcXHRcXHR0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZVBlcnNwZWN0aXZlKCBsZWZ0LCBsZWZ0ICsgd2lkdGgsIHRvcCwgdG9wIC0gaGVpZ2h0LCBuZWFyLCB0aGlzLmZhciApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGRhdGEgPSBPYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcXG5cXG5cXHRcXHRcXHRkYXRhLm9iamVjdC5mb3YgPSB0aGlzLmZvdjtcXG5cXHRcXHRcXHRkYXRhLm9iamVjdC56b29tID0gdGhpcy56b29tO1xcblxcblxcdFxcdFxcdGRhdGEub2JqZWN0Lm5lYXIgPSB0aGlzLm5lYXI7XFxuXFx0XFx0XFx0ZGF0YS5vYmplY3QuZmFyID0gdGhpcy5mYXI7XFxuXFx0XFx0XFx0ZGF0YS5vYmplY3QuZm9jdXMgPSB0aGlzLmZvY3VzO1xcblxcblxcdFxcdFxcdGRhdGEub2JqZWN0LmFzcGVjdCA9IHRoaXMuYXNwZWN0O1xcblxcblxcdFxcdFxcdGlmICggdGhpcy52aWV3ICE9PSBudWxsICkgZGF0YS5vYmplY3QudmlldyA9IE9iamVjdC5hc3NpZ24oIHt9LCB0aGlzLnZpZXcgKTtcXG5cXG5cXHRcXHRcXHRkYXRhLm9iamVjdC5maWxtR2F1Z2UgPSB0aGlzLmZpbG1HYXVnZTtcXG5cXHRcXHRcXHRkYXRhLm9iamVjdC5maWxtT2Zmc2V0ID0gdGhpcy5maWxtT2Zmc2V0O1xcblxcblxcdFxcdFxcdHJldHVybiBkYXRhO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBBcnJheUNhbWVyYSggYXJyYXkgKSB7XFxuXFxuXFx0XFx0UGVyc3BlY3RpdmVDYW1lcmEuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMuY2FtZXJhcyA9IGFycmF5IHx8IFtdO1xcblxcblxcdH1cXG5cXG5cXHRBcnJheUNhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBQZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBBcnJheUNhbWVyYSxcXG5cXG5cXHRcXHRpc0FycmF5Q2FtZXJhOiB0cnVlXFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gV2ViVlJNYW5hZ2VyKCByZW5kZXJlciApIHtcXG5cXG5cXHRcXHR2YXIgc2NvcGUgPSB0aGlzO1xcblxcblxcdFxcdHZhciBkZXZpY2UgPSBudWxsO1xcblxcdFxcdHZhciBmcmFtZURhdGEgPSBudWxsO1xcblxcblxcdFxcdHZhciBwb3NlVGFyZ2V0ID0gbnVsbDtcXG5cXG5cXHRcXHRpZiAoIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICdWUkZyYW1lRGF0YScgaW4gd2luZG93ICkge1xcblxcblxcdFxcdFxcdGZyYW1lRGF0YSA9IG5ldyB3aW5kb3cuVlJGcmFtZURhdGEoKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dmFyIG1hdHJpeFdvcmxkSW52ZXJzZSA9IG5ldyBNYXRyaXg0KCk7XFxuXFxuXFx0XFx0dmFyIGNhbWVyYUwgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKTtcXG5cXHRcXHRjYW1lcmFMLmJvdW5kcyA9IG5ldyBWZWN0b3I0KCAwLjAsIDAuMCwgMC41LCAxLjAgKTtcXG5cXHRcXHRjYW1lcmFMLmxheWVycy5lbmFibGUoIDEgKTtcXG5cXG5cXHRcXHR2YXIgY2FtZXJhUiA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSgpO1xcblxcdFxcdGNhbWVyYVIuYm91bmRzID0gbmV3IFZlY3RvcjQoIDAuNSwgMC4wLCAwLjUsIDEuMCApO1xcblxcdFxcdGNhbWVyYVIubGF5ZXJzLmVuYWJsZSggMiApO1xcblxcblxcdFxcdHZhciBjYW1lcmFWUiA9IG5ldyBBcnJheUNhbWVyYSggWyBjYW1lcmFMLCBjYW1lcmFSIF0gKTtcXG5cXHRcXHRjYW1lcmFWUi5sYXllcnMuZW5hYmxlKCAxICk7XFxuXFx0XFx0Y2FtZXJhVlIubGF5ZXJzLmVuYWJsZSggMiApO1xcblxcblxcdFxcdC8vXFxuXFxuXFx0XFx0dmFyIGN1cnJlbnRTaXplLCBjdXJyZW50UGl4ZWxSYXRpbztcXG5cXG5cXHRcXHRmdW5jdGlvbiBvblZSRGlzcGxheVByZXNlbnRDaGFuZ2UoKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBkZXZpY2UgIT09IG51bGwgJiYgZGV2aWNlLmlzUHJlc2VudGluZyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZXllUGFyYW1ldGVycyA9IGRldmljZS5nZXRFeWVQYXJhbWV0ZXJzKCAnbGVmdCcgKTtcXG5cXHRcXHRcXHRcXHR2YXIgcmVuZGVyV2lkdGggPSBleWVQYXJhbWV0ZXJzLnJlbmRlcldpZHRoO1xcblxcdFxcdFxcdFxcdHZhciByZW5kZXJIZWlnaHQgPSBleWVQYXJhbWV0ZXJzLnJlbmRlckhlaWdodDtcXG5cXG5cXHRcXHRcXHRcXHRjdXJyZW50UGl4ZWxSYXRpbyA9IHJlbmRlcmVyLmdldFBpeGVsUmF0aW8oKTtcXG5cXHRcXHRcXHRcXHRjdXJyZW50U2l6ZSA9IHJlbmRlcmVyLmdldFNpemUoKTtcXG5cXG5cXHRcXHRcXHRcXHRyZW5kZXJlci5zZXREcmF3aW5nQnVmZmVyU2l6ZSggcmVuZGVyV2lkdGggKiAyLCByZW5kZXJIZWlnaHQsIDEgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBzY29wZS5lbmFibGVkICkge1xcblxcblxcdFxcdFxcdFxcdHJlbmRlcmVyLnNldERyYXdpbmdCdWZmZXJTaXplKCBjdXJyZW50U2l6ZS53aWR0aCwgY3VycmVudFNpemUuaGVpZ2h0LCBjdXJyZW50UGl4ZWxSYXRpbyApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyApIHtcXG5cXG5cXHRcXHRcXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ3ZyZGlzcGxheXByZXNlbnRjaGFuZ2UnLCBvblZSRGlzcGxheVByZXNlbnRDaGFuZ2UsIGZhbHNlICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vXFxuXFxuXFx0XFx0dGhpcy5lbmFibGVkID0gZmFsc2U7XFxuXFxuXFx0XFx0dGhpcy5nZXREZXZpY2UgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGRldmljZTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuc2V0RGV2aWNlID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSBkZXZpY2UgPSB2YWx1ZTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuc2V0UG9zZVRhcmdldCA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xcblxcblxcdFxcdFxcdGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgKSBwb3NlVGFyZ2V0ID0gb2JqZWN0O1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5nZXRDYW1lcmEgPSBmdW5jdGlvbiAoIGNhbWVyYSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGRldmljZSA9PT0gbnVsbCApIHJldHVybiBjYW1lcmE7XFxuXFxuXFx0XFx0XFx0ZGV2aWNlLmRlcHRoTmVhciA9IGNhbWVyYS5uZWFyO1xcblxcdFxcdFxcdGRldmljZS5kZXB0aEZhciA9IGNhbWVyYS5mYXI7XFxuXFxuXFx0XFx0XFx0ZGV2aWNlLmdldEZyYW1lRGF0YSggZnJhbWVEYXRhICk7XFxuXFxuXFx0XFx0XFx0Ly9cXG5cXG5cXHRcXHRcXHR2YXIgcG9zZSA9IGZyYW1lRGF0YS5wb3NlO1xcblxcdFxcdFxcdHZhciBwb3NlT2JqZWN0ID0gcG9zZVRhcmdldCAhPT0gbnVsbCA/IHBvc2VUYXJnZXQgOiBjYW1lcmE7XFxuXFxuXFx0XFx0XFx0aWYgKCBwb3NlLnBvc2l0aW9uICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdHBvc2VPYmplY3QucG9zaXRpb24uZnJvbUFycmF5KCBwb3NlLnBvc2l0aW9uICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRwb3NlT2JqZWN0LnBvc2l0aW9uLnNldCggMCwgMCwgMCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHBvc2Uub3JpZW50YXRpb24gIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cG9zZU9iamVjdC5xdWF0ZXJuaW9uLmZyb21BcnJheSggcG9zZS5vcmllbnRhdGlvbiApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRwb3NlT2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XFxuXFxuXFx0XFx0XFx0aWYgKCBkZXZpY2UuaXNQcmVzZW50aW5nID09PSBmYWxzZSApIHJldHVybiBjYW1lcmE7XFxuXFxuXFx0XFx0XFx0Ly9cXG5cXG5cXHRcXHRcXHRjYW1lcmFMLm5lYXIgPSBjYW1lcmEubmVhcjtcXG5cXHRcXHRcXHRjYW1lcmFSLm5lYXIgPSBjYW1lcmEubmVhcjtcXG5cXG5cXHRcXHRcXHRjYW1lcmFMLmZhciA9IGNhbWVyYS5mYXI7XFxuXFx0XFx0XFx0Y2FtZXJhUi5mYXIgPSBjYW1lcmEuZmFyO1xcblxcblxcdFxcdFxcdGNhbWVyYVZSLm1hdHJpeFdvcmxkLmNvcHkoIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xcblxcdFxcdFxcdGNhbWVyYVZSLm1hdHJpeFdvcmxkSW52ZXJzZS5jb3B5KCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XFxuXFxuXFx0XFx0XFx0Y2FtZXJhTC5tYXRyaXhXb3JsZEludmVyc2UuZnJvbUFycmF5KCBmcmFtZURhdGEubGVmdFZpZXdNYXRyaXggKTtcXG5cXHRcXHRcXHRjYW1lcmFSLm1hdHJpeFdvcmxkSW52ZXJzZS5mcm9tQXJyYXkoIGZyYW1lRGF0YS5yaWdodFZpZXdNYXRyaXggKTtcXG5cXG5cXHRcXHRcXHR2YXIgcGFyZW50ID0gcG9zZU9iamVjdC5wYXJlbnQ7XFxuXFxuXFx0XFx0XFx0aWYgKCBwYXJlbnQgIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0bWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoIHBhcmVudC5tYXRyaXhXb3JsZCApO1xcblxcblxcdFxcdFxcdFxcdGNhbWVyYUwubWF0cml4V29ybGRJbnZlcnNlLm11bHRpcGx5KCBtYXRyaXhXb3JsZEludmVyc2UgKTtcXG5cXHRcXHRcXHRcXHRjYW1lcmFSLm1hdHJpeFdvcmxkSW52ZXJzZS5tdWx0aXBseSggbWF0cml4V29ybGRJbnZlcnNlICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGVudk1hcCBhbmQgTWlycm9yIG5lZWRzIGNhbWVyYS5tYXRyaXhXb3JsZFxcblxcblxcdFxcdFxcdGNhbWVyYUwubWF0cml4V29ybGQuZ2V0SW52ZXJzZSggY2FtZXJhTC5tYXRyaXhXb3JsZEludmVyc2UgKTtcXG5cXHRcXHRcXHRjYW1lcmFSLm1hdHJpeFdvcmxkLmdldEludmVyc2UoIGNhbWVyYVIubWF0cml4V29ybGRJbnZlcnNlICk7XFxuXFxuXFx0XFx0XFx0Y2FtZXJhTC5wcm9qZWN0aW9uTWF0cml4LmZyb21BcnJheSggZnJhbWVEYXRhLmxlZnRQcm9qZWN0aW9uTWF0cml4ICk7XFxuXFx0XFx0XFx0Y2FtZXJhUi5wcm9qZWN0aW9uTWF0cml4LmZyb21BcnJheSggZnJhbWVEYXRhLnJpZ2h0UHJvamVjdGlvbk1hdHJpeCApO1xcblxcblxcdFxcdFxcdC8vIEhBQ0sgQG1yZG9vYlxcblxcdFxcdFxcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93M2Mvd2VidnIvaXNzdWVzLzIwM1xcblxcblxcdFxcdFxcdGNhbWVyYVZSLnByb2plY3Rpb25NYXRyaXguY29weSggY2FtZXJhTC5wcm9qZWN0aW9uTWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0Ly9cXG5cXG5cXHRcXHRcXHR2YXIgbGF5ZXJzID0gZGV2aWNlLmdldExheWVycygpO1xcblxcblxcdFxcdFxcdGlmICggbGF5ZXJzLmxlbmd0aCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbGF5ZXIgPSBsYXllcnNbIDAgXTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGxheWVyLmxlZnRCb3VuZHMgIT09IG51bGwgJiYgbGF5ZXIubGVmdEJvdW5kcy5sZW5ndGggPT09IDQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FtZXJhTC5ib3VuZHMuZnJvbUFycmF5KCBsYXllci5sZWZ0Qm91bmRzICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggbGF5ZXIucmlnaHRCb3VuZHMgIT09IG51bGwgJiYgbGF5ZXIucmlnaHRCb3VuZHMubGVuZ3RoID09PSA0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNhbWVyYVIuYm91bmRzLmZyb21BcnJheSggbGF5ZXIucmlnaHRCb3VuZHMgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBjYW1lcmFWUjtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuc3VibWl0RnJhbWUgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBkZXZpY2UgJiYgZGV2aWNlLmlzUHJlc2VudGluZyApIGRldmljZS5zdWJtaXRGcmFtZSgpO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGlmICggdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgKSB7XFxuXFxuXFx0XFx0XFx0XFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoICd2cmRpc3BsYXlwcmVzZW50Y2hhbmdlJywgb25WUkRpc3BsYXlQcmVzZW50Q2hhbmdlICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH07XFxuXFxuXFx0fVxcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gV2ViR0xFeHRlbnNpb25zKCBnbCApIHtcXG5cXG5cXHRcXHR2YXIgZXh0ZW5zaW9ucyA9IHt9O1xcblxcblxcdFxcdHJldHVybiB7XFxuXFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoIG5hbWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBleHRlbnNpb25zWyBuYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZXh0ZW5zaW9uc1sgbmFtZSBdO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR2YXIgZXh0ZW5zaW9uO1xcblxcblxcdFxcdFxcdFxcdHN3aXRjaCAoIG5hbWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnV0VCR0xfZGVwdGhfdGV4dHVyZSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfZGVwdGhfdGV4dHVyZScgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdNT1pfV0VCR0xfZGVwdGhfdGV4dHVyZScgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfV0VCR0xfZGVwdGhfdGV4dHVyZScgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdNT1pfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ01PWl9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjMSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZGVmYXVsdDpcXG5cXHRcXHRcXHRcXHRcXHRcXHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oIG5hbWUgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogJyArIG5hbWUgKyAnIGV4dGVuc2lvbiBub3Qgc3VwcG9ydGVkLicgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0ZXh0ZW5zaW9uc1sgbmFtZSBdID0gZXh0ZW5zaW9uO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBleHRlbnNpb247XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH07XFxuXFxuXFx0fVxcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgdHNjaHdcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBXZWJHTENsaXBwaW5nKCkge1xcblxcblxcdFxcdHZhciBzY29wZSA9IHRoaXMsXFxuXFxuXFx0XFx0XFx0Z2xvYmFsU3RhdGUgPSBudWxsLFxcblxcdFxcdFxcdG51bUdsb2JhbFBsYW5lcyA9IDAsXFxuXFx0XFx0XFx0bG9jYWxDbGlwcGluZ0VuYWJsZWQgPSBmYWxzZSxcXG5cXHRcXHRcXHRyZW5kZXJpbmdTaGFkb3dzID0gZmFsc2UsXFxuXFxuXFx0XFx0XFx0cGxhbmUgPSBuZXcgUGxhbmUoKSxcXG5cXHRcXHRcXHR2aWV3Tm9ybWFsTWF0cml4ID0gbmV3IE1hdHJpeDMoKSxcXG5cXG5cXHRcXHRcXHR1bmlmb3JtID0geyB2YWx1ZTogbnVsbCwgbmVlZHNVcGRhdGU6IGZhbHNlIH07XFxuXFxuXFx0XFx0dGhpcy51bmlmb3JtID0gdW5pZm9ybTtcXG5cXHRcXHR0aGlzLm51bVBsYW5lcyA9IDA7XFxuXFx0XFx0dGhpcy5udW1JbnRlcnNlY3Rpb24gPSAwO1xcblxcblxcdFxcdHRoaXMuaW5pdCA9IGZ1bmN0aW9uICggcGxhbmVzLCBlbmFibGVMb2NhbENsaXBwaW5nLCBjYW1lcmEgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGVuYWJsZWQgPVxcblxcdFxcdFxcdFxcdHBsYW5lcy5sZW5ndGggIT09IDAgfHxcXG5cXHRcXHRcXHRcXHRlbmFibGVMb2NhbENsaXBwaW5nIHx8XFxuXFx0XFx0XFx0XFx0Ly8gZW5hYmxlIHN0YXRlIG9mIHByZXZpb3VzIGZyYW1lIC0gdGhlIGNsaXBwaW5nIGNvZGUgaGFzIHRvXFxuXFx0XFx0XFx0XFx0Ly8gcnVuIGFub3RoZXIgZnJhbWUgaW4gb3JkZXIgdG8gcmVzZXQgdGhlIHN0YXRlOlxcblxcdFxcdFxcdFxcdG51bUdsb2JhbFBsYW5lcyAhPT0gMCB8fFxcblxcdFxcdFxcdFxcdGxvY2FsQ2xpcHBpbmdFbmFibGVkO1xcblxcblxcdFxcdFxcdGxvY2FsQ2xpcHBpbmdFbmFibGVkID0gZW5hYmxlTG9jYWxDbGlwcGluZztcXG5cXG5cXHRcXHRcXHRnbG9iYWxTdGF0ZSA9IHByb2plY3RQbGFuZXMoIHBsYW5lcywgY2FtZXJhLCAwICk7XFxuXFx0XFx0XFx0bnVtR2xvYmFsUGxhbmVzID0gcGxhbmVzLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZW5hYmxlZDtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuYmVnaW5TaGFkb3dzID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJlbmRlcmluZ1NoYWRvd3MgPSB0cnVlO1xcblxcdFxcdFxcdHByb2plY3RQbGFuZXMoIG51bGwgKTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuZW5kU2hhZG93cyA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZW5kZXJpbmdTaGFkb3dzID0gZmFsc2U7XFxuXFx0XFx0XFx0cmVzZXRHbG9iYWxTdGF0ZSgpO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5zZXRTdGF0ZSA9IGZ1bmN0aW9uICggcGxhbmVzLCBjbGlwSW50ZXJzZWN0aW9uLCBjbGlwU2hhZG93cywgY2FtZXJhLCBjYWNoZSwgZnJvbUNhY2hlICkge1xcblxcblxcdFxcdFxcdGlmICggISBsb2NhbENsaXBwaW5nRW5hYmxlZCB8fCBwbGFuZXMgPT09IG51bGwgfHwgcGxhbmVzLmxlbmd0aCA9PT0gMCB8fCByZW5kZXJpbmdTaGFkb3dzICYmICEgY2xpcFNoYWRvd3MgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdGhlcmUncyBubyBsb2NhbCBjbGlwcGluZ1xcblxcblxcdFxcdFxcdFxcdGlmICggcmVuZGVyaW5nU2hhZG93cyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyB0aGVyZSdzIG5vIGdsb2JhbCBjbGlwcGluZ1xcblxcblxcdFxcdFxcdFxcdFxcdHByb2plY3RQbGFuZXMoIG51bGwgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdHJlc2V0R2xvYmFsU3RhdGUoKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbkdsb2JhbCA9IHJlbmRlcmluZ1NoYWRvd3MgPyAwIDogbnVtR2xvYmFsUGxhbmVzLFxcblxcdFxcdFxcdFxcdFxcdGxHbG9iYWwgPSBuR2xvYmFsICogNCxcXG5cXG5cXHRcXHRcXHRcXHRcXHRkc3RBcnJheSA9IGNhY2hlLmNsaXBwaW5nU3RhdGUgfHwgbnVsbDtcXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3JtLnZhbHVlID0gZHN0QXJyYXk7IC8vIGVuc3VyZSB1bmlxdWUgc3RhdGVcXG5cXG5cXHRcXHRcXHRcXHRkc3RBcnJheSA9IHByb2plY3RQbGFuZXMoIHBsYW5lcywgY2FtZXJhLCBsR2xvYmFsLCBmcm9tQ2FjaGUgKTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IGxHbG9iYWw7ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZHN0QXJyYXlbIGkgXSA9IGdsb2JhbFN0YXRlWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGNhY2hlLmNsaXBwaW5nU3RhdGUgPSBkc3RBcnJheTtcXG5cXHRcXHRcXHRcXHR0aGlzLm51bUludGVyc2VjdGlvbiA9IGNsaXBJbnRlcnNlY3Rpb24gPyB0aGlzLm51bVBsYW5lcyA6IDA7XFxuXFx0XFx0XFx0XFx0dGhpcy5udW1QbGFuZXMgKz0gbkdsb2JhbDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRmdW5jdGlvbiByZXNldEdsb2JhbFN0YXRlKCkge1xcblxcblxcdFxcdFxcdGlmICggdW5pZm9ybS52YWx1ZSAhPT0gZ2xvYmFsU3RhdGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dW5pZm9ybS52YWx1ZSA9IGdsb2JhbFN0YXRlO1xcblxcdFxcdFxcdFxcdHVuaWZvcm0ubmVlZHNVcGRhdGUgPSBudW1HbG9iYWxQbGFuZXMgPiAwO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRzY29wZS5udW1QbGFuZXMgPSBudW1HbG9iYWxQbGFuZXM7XFxuXFx0XFx0XFx0c2NvcGUubnVtSW50ZXJzZWN0aW9uID0gMDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gcHJvamVjdFBsYW5lcyggcGxhbmVzLCBjYW1lcmEsIGRzdE9mZnNldCwgc2tpcFRyYW5zZm9ybSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgblBsYW5lcyA9IHBsYW5lcyAhPT0gbnVsbCA/IHBsYW5lcy5sZW5ndGggOiAwLFxcblxcdFxcdFxcdFxcdGRzdEFycmF5ID0gbnVsbDtcXG5cXG5cXHRcXHRcXHRpZiAoIG5QbGFuZXMgIT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZHN0QXJyYXkgPSB1bmlmb3JtLnZhbHVlO1xcblxcblxcdFxcdFxcdFxcdGlmICggc2tpcFRyYW5zZm9ybSAhPT0gdHJ1ZSB8fCBkc3RBcnJheSA9PT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgZmxhdFNpemUgPSBkc3RPZmZzZXQgKyBuUGxhbmVzICogNCxcXG5cXHRcXHRcXHRcXHRcXHRcXHR2aWV3TWF0cml4ID0gY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2aWV3Tm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggdmlld01hdHJpeCApO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggZHN0QXJyYXkgPT09IG51bGwgfHwgZHN0QXJyYXkubGVuZ3RoIDwgZmxhdFNpemUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZHN0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBmbGF0U2l6ZSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGk0ID0gZHN0T2Zmc2V0OyBpICE9PSBuUGxhbmVzOyArKyBpLCBpNCArPSA0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHBsYW5lLmNvcHkoIHBsYW5lc1sgaSBdICkuYXBwbHlNYXRyaXg0KCB2aWV3TWF0cml4LCB2aWV3Tm9ybWFsTWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cGxhbmUubm9ybWFsLnRvQXJyYXkoIGRzdEFycmF5LCBpNCApO1xcblxcdFxcdFxcdFxcdFxcdFxcdGRzdEFycmF5WyBpNCArIDMgXSA9IHBsYW5lLmNvbnN0YW50O1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dW5pZm9ybS52YWx1ZSA9IGRzdEFycmF5O1xcblxcdFxcdFxcdFxcdHVuaWZvcm0ubmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRzY29wZS5udW1QbGFuZXMgPSBuUGxhbmVzO1xcblxcblxcdFxcdFxcdHJldHVybiBkc3RBcnJheTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fVxcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgdGhlc3BpdGUgLyBodHRwOi8vd3d3LnR3aXR0ZXIuY29tL3RoZXNwaXRlXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gV2ViR0xVdGlscyggZ2wsIGV4dGVuc2lvbnMgKSB7XFxuXFxuXFx0XFx0ZnVuY3Rpb24gY29udmVydCggcCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgZXh0ZW5zaW9uO1xcblxcblxcdFxcdFxcdGlmICggcCA9PT0gUmVwZWF0V3JhcHBpbmcgKSByZXR1cm4gZ2wuUkVQRUFUO1xcblxcdFxcdFxcdGlmICggcCA9PT0gQ2xhbXBUb0VkZ2VXcmFwcGluZyApIHJldHVybiBnbC5DTEFNUF9UT19FREdFO1xcblxcdFxcdFxcdGlmICggcCA9PT0gTWlycm9yZWRSZXBlYXRXcmFwcGluZyApIHJldHVybiBnbC5NSVJST1JFRF9SRVBFQVQ7XFxuXFxuXFx0XFx0XFx0aWYgKCBwID09PSBOZWFyZXN0RmlsdGVyICkgcmV0dXJuIGdsLk5FQVJFU1Q7XFxuXFx0XFx0XFx0aWYgKCBwID09PSBOZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciApIHJldHVybiBnbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNUO1xcblxcdFxcdFxcdGlmICggcCA9PT0gTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciApIHJldHVybiBnbC5ORUFSRVNUX01JUE1BUF9MSU5FQVI7XFxuXFxuXFx0XFx0XFx0aWYgKCBwID09PSBMaW5lYXJGaWx0ZXIgKSByZXR1cm4gZ2wuTElORUFSO1xcblxcdFxcdFxcdGlmICggcCA9PT0gTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlciApIHJldHVybiBnbC5MSU5FQVJfTUlQTUFQX05FQVJFU1Q7XFxuXFx0XFx0XFx0aWYgKCBwID09PSBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIgKSByZXR1cm4gZ2wuTElORUFSX01JUE1BUF9MSU5FQVI7XFxuXFxuXFx0XFx0XFx0aWYgKCBwID09PSBVbnNpZ25lZEJ5dGVUeXBlICkgcmV0dXJuIGdsLlVOU0lHTkVEX0JZVEU7XFxuXFx0XFx0XFx0aWYgKCBwID09PSBVbnNpZ25lZFNob3J0NDQ0NFR5cGUgKSByZXR1cm4gZ2wuVU5TSUdORURfU0hPUlRfNF80XzRfNDtcXG5cXHRcXHRcXHRpZiAoIHAgPT09IFVuc2lnbmVkU2hvcnQ1NTUxVHlwZSApIHJldHVybiBnbC5VTlNJR05FRF9TSE9SVF81XzVfNV8xO1xcblxcdFxcdFxcdGlmICggcCA9PT0gVW5zaWduZWRTaG9ydDU2NVR5cGUgKSByZXR1cm4gZ2wuVU5TSUdORURfU0hPUlRfNV82XzU7XFxuXFxuXFx0XFx0XFx0aWYgKCBwID09PSBCeXRlVHlwZSApIHJldHVybiBnbC5CWVRFO1xcblxcdFxcdFxcdGlmICggcCA9PT0gU2hvcnRUeXBlICkgcmV0dXJuIGdsLlNIT1JUO1xcblxcdFxcdFxcdGlmICggcCA9PT0gVW5zaWduZWRTaG9ydFR5cGUgKSByZXR1cm4gZ2wuVU5TSUdORURfU0hPUlQ7XFxuXFx0XFx0XFx0aWYgKCBwID09PSBJbnRUeXBlICkgcmV0dXJuIGdsLklOVDtcXG5cXHRcXHRcXHRpZiAoIHAgPT09IFVuc2lnbmVkSW50VHlwZSApIHJldHVybiBnbC5VTlNJR05FRF9JTlQ7XFxuXFx0XFx0XFx0aWYgKCBwID09PSBGbG9hdFR5cGUgKSByZXR1cm4gZ2wuRkxPQVQ7XFxuXFxuXFx0XFx0XFx0aWYgKCBwID09PSBIYWxmRmxvYXRUeXBlICkge1xcblxcblxcdFxcdFxcdFxcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHJldHVybiBleHRlbnNpb24uSEFMRl9GTE9BVF9PRVM7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggcCA9PT0gQWxwaGFGb3JtYXQgKSByZXR1cm4gZ2wuQUxQSEE7XFxuXFx0XFx0XFx0aWYgKCBwID09PSBSR0JGb3JtYXQgKSByZXR1cm4gZ2wuUkdCO1xcblxcdFxcdFxcdGlmICggcCA9PT0gUkdCQUZvcm1hdCApIHJldHVybiBnbC5SR0JBO1xcblxcdFxcdFxcdGlmICggcCA9PT0gTHVtaW5hbmNlRm9ybWF0ICkgcmV0dXJuIGdsLkxVTUlOQU5DRTtcXG5cXHRcXHRcXHRpZiAoIHAgPT09IEx1bWluYW5jZUFscGhhRm9ybWF0ICkgcmV0dXJuIGdsLkxVTUlOQU5DRV9BTFBIQTtcXG5cXHRcXHRcXHRpZiAoIHAgPT09IERlcHRoRm9ybWF0ICkgcmV0dXJuIGdsLkRFUFRIX0NPTVBPTkVOVDtcXG5cXHRcXHRcXHRpZiAoIHAgPT09IERlcHRoU3RlbmNpbEZvcm1hdCApIHJldHVybiBnbC5ERVBUSF9TVEVOQ0lMO1xcblxcblxcdFxcdFxcdGlmICggcCA9PT0gQWRkRXF1YXRpb24gKSByZXR1cm4gZ2wuRlVOQ19BREQ7XFxuXFx0XFx0XFx0aWYgKCBwID09PSBTdWJ0cmFjdEVxdWF0aW9uICkgcmV0dXJuIGdsLkZVTkNfU1VCVFJBQ1Q7XFxuXFx0XFx0XFx0aWYgKCBwID09PSBSZXZlcnNlU3VidHJhY3RFcXVhdGlvbiApIHJldHVybiBnbC5GVU5DX1JFVkVSU0VfU1VCVFJBQ1Q7XFxuXFxuXFx0XFx0XFx0aWYgKCBwID09PSBaZXJvRmFjdG9yICkgcmV0dXJuIGdsLlpFUk87XFxuXFx0XFx0XFx0aWYgKCBwID09PSBPbmVGYWN0b3IgKSByZXR1cm4gZ2wuT05FO1xcblxcdFxcdFxcdGlmICggcCA9PT0gU3JjQ29sb3JGYWN0b3IgKSByZXR1cm4gZ2wuU1JDX0NPTE9SO1xcblxcdFxcdFxcdGlmICggcCA9PT0gT25lTWludXNTcmNDb2xvckZhY3RvciApIHJldHVybiBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SO1xcblxcdFxcdFxcdGlmICggcCA9PT0gU3JjQWxwaGFGYWN0b3IgKSByZXR1cm4gZ2wuU1JDX0FMUEhBO1xcblxcdFxcdFxcdGlmICggcCA9PT0gT25lTWludXNTcmNBbHBoYUZhY3RvciApIHJldHVybiBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBO1xcblxcdFxcdFxcdGlmICggcCA9PT0gRHN0QWxwaGFGYWN0b3IgKSByZXR1cm4gZ2wuRFNUX0FMUEhBO1xcblxcdFxcdFxcdGlmICggcCA9PT0gT25lTWludXNEc3RBbHBoYUZhY3RvciApIHJldHVybiBnbC5PTkVfTUlOVVNfRFNUX0FMUEhBO1xcblxcblxcdFxcdFxcdGlmICggcCA9PT0gRHN0Q29sb3JGYWN0b3IgKSByZXR1cm4gZ2wuRFNUX0NPTE9SO1xcblxcdFxcdFxcdGlmICggcCA9PT0gT25lTWludXNEc3RDb2xvckZhY3RvciApIHJldHVybiBnbC5PTkVfTUlOVVNfRFNUX0NPTE9SO1xcblxcdFxcdFxcdGlmICggcCA9PT0gU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciApIHJldHVybiBnbC5TUkNfQUxQSEFfU0FUVVJBVEU7XFxuXFxuXFx0XFx0XFx0aWYgKCBwID09PSBSR0JfUzNUQ19EWFQxX0Zvcm1hdCB8fCBwID09PSBSR0JBX1MzVENfRFhUMV9Gb3JtYXQgfHxcXG5cXHRcXHRcXHRcXHRwID09PSBSR0JBX1MzVENfRFhUM19Gb3JtYXQgfHwgcCA9PT0gUkdCQV9TM1RDX0RYVDVfRm9ybWF0ICkge1xcblxcblxcdFxcdFxcdFxcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBwID09PSBSR0JfUzNUQ19EWFQxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUzNUQ19EWFQxX0VYVDtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHAgPT09IFJHQkFfUzNUQ19EWFQxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFQ7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBwID09PSBSR0JBX1MzVENfRFhUM19Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDNfRVhUO1xcblxcdFxcdFxcdFxcdFxcdGlmICggcCA9PT0gUkdCQV9TM1RDX0RYVDVfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQ1X0VYVDtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggcCA9PT0gUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQgfHwgcCA9PT0gUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQgfHxcXG5cXHRcXHRcXHRcXHRwID09PSBSR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQgfHwgcCA9PT0gUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ICkge1xcblxcblxcdFxcdFxcdFxcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApO1xcblxcblxcdFxcdFxcdFxcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggcCA9PT0gUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX1BWUlRDXzRCUFBWMV9JTUc7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBwID09PSBSR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUFZSVENfMkJQUFYxX0lNRztcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHAgPT09IFJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzRCUFBWMV9JTUc7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBwID09PSBSR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9QVlJUQ18yQlBQVjFfSU1HO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBwID09PSBSR0JfRVRDMV9Gb3JtYXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjMScgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfRVRDMV9XRUJHTDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBwID09PSBNaW5FcXVhdGlvbiB8fCBwID09PSBNYXhFcXVhdGlvbiApIHtcXG5cXG5cXHRcXHRcXHRcXHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0VYVF9ibGVuZF9taW5tYXgnICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBwID09PSBNaW5FcXVhdGlvbiApIHJldHVybiBleHRlbnNpb24uTUlOX0VYVDtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHAgPT09IE1heEVxdWF0aW9uICkgcmV0dXJuIGV4dGVuc2lvbi5NQVhfRVhUO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBwID09PSBVbnNpZ25lZEludDI0OFR5cGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9kZXB0aF90ZXh0dXJlJyApO1xcblxcblxcdFxcdFxcdFxcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkgcmV0dXJuIGV4dGVuc2lvbi5VTlNJR05FRF9JTlRfMjRfOF9XRUJHTDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIDA7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB7IGNvbnZlcnQ6IGNvbnZlcnQgfTtcXG5cXG5cXHR9XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICogQGF1dGhvciBzemltZWsgLyBodHRwczovL2dpdGh1Yi5jb20vc3ppbWVrL1xcblxcdCAqIEBhdXRob3IgdHNjaHdcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBXZWJHTFJlbmRlcmVyKCBwYXJhbWV0ZXJzICkge1xcblxcblxcdFxcdGNvbnNvbGUubG9nKCAnVEhSRUUuV2ViR0xSZW5kZXJlcicsIFJFVklTSU9OICk7XFxuXFxuXFx0XFx0cGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XFxuXFxuXFx0XFx0dmFyIF9jYW52YXMgPSBwYXJhbWV0ZXJzLmNhbnZhcyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5jYW52YXMgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywgJ2NhbnZhcycgKSxcXG5cXHRcXHRcXHRfY29udGV4dCA9IHBhcmFtZXRlcnMuY29udGV4dCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5jb250ZXh0IDogbnVsbCxcXG5cXG5cXHRcXHRcXHRfYWxwaGEgPSBwYXJhbWV0ZXJzLmFscGhhICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFscGhhIDogZmFsc2UsXFxuXFx0XFx0XFx0X2RlcHRoID0gcGFyYW1ldGVycy5kZXB0aCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5kZXB0aCA6IHRydWUsXFxuXFx0XFx0XFx0X3N0ZW5jaWwgPSBwYXJhbWV0ZXJzLnN0ZW5jaWwgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuc3RlbmNpbCA6IHRydWUsXFxuXFx0XFx0XFx0X2FudGlhbGlhcyA9IHBhcmFtZXRlcnMuYW50aWFsaWFzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFudGlhbGlhcyA6IGZhbHNlLFxcblxcdFxcdFxcdF9wcmVtdWx0aXBsaWVkQWxwaGEgPSBwYXJhbWV0ZXJzLnByZW11bHRpcGxpZWRBbHBoYSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVtdWx0aXBsaWVkQWxwaGEgOiB0cnVlLFxcblxcdFxcdFxcdF9wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSBwYXJhbWV0ZXJzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgOiBmYWxzZSxcXG5cXHRcXHRcXHRfcG93ZXJQcmVmZXJlbmNlID0gcGFyYW1ldGVycy5wb3dlclByZWZlcmVuY2UgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucG93ZXJQcmVmZXJlbmNlIDogJ2RlZmF1bHQnO1xcblxcblxcdFxcdHZhciBsaWdodHNBcnJheSA9IFtdO1xcblxcdFxcdHZhciBzaGFkb3dzQXJyYXkgPSBbXTtcXG5cXG5cXHRcXHR2YXIgY3VycmVudFJlbmRlckxpc3QgPSBudWxsO1xcblxcblxcdFxcdHZhciBzcHJpdGVzQXJyYXkgPSBbXTtcXG5cXHRcXHR2YXIgZmxhcmVzQXJyYXkgPSBbXTtcXG5cXG5cXHRcXHQvLyBwdWJsaWMgcHJvcGVydGllc1xcblxcblxcdFxcdHRoaXMuZG9tRWxlbWVudCA9IF9jYW52YXM7XFxuXFx0XFx0dGhpcy5jb250ZXh0ID0gbnVsbDtcXG5cXG5cXHRcXHQvLyBjbGVhcmluZ1xcblxcblxcdFxcdHRoaXMuYXV0b0NsZWFyID0gdHJ1ZTtcXG5cXHRcXHR0aGlzLmF1dG9DbGVhckNvbG9yID0gdHJ1ZTtcXG5cXHRcXHR0aGlzLmF1dG9DbGVhckRlcHRoID0gdHJ1ZTtcXG5cXHRcXHR0aGlzLmF1dG9DbGVhclN0ZW5jaWwgPSB0cnVlO1xcblxcblxcdFxcdC8vIHNjZW5lIGdyYXBoXFxuXFxuXFx0XFx0dGhpcy5zb3J0T2JqZWN0cyA9IHRydWU7XFxuXFxuXFx0XFx0Ly8gdXNlci1kZWZpbmVkIGNsaXBwaW5nXFxuXFxuXFx0XFx0dGhpcy5jbGlwcGluZ1BsYW5lcyA9IFtdO1xcblxcdFxcdHRoaXMubG9jYWxDbGlwcGluZ0VuYWJsZWQgPSBmYWxzZTtcXG5cXG5cXHRcXHQvLyBwaHlzaWNhbGx5IGJhc2VkIHNoYWRpbmdcXG5cXG5cXHRcXHR0aGlzLmdhbW1hRmFjdG9yID0gMi4wO1xcdC8vIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxcblxcdFxcdHRoaXMuZ2FtbWFJbnB1dCA9IGZhbHNlO1xcblxcdFxcdHRoaXMuZ2FtbWFPdXRwdXQgPSBmYWxzZTtcXG5cXG5cXHRcXHQvLyBwaHlzaWNhbCBsaWdodHNcXG5cXG5cXHRcXHR0aGlzLnBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzID0gZmFsc2U7XFxuXFxuXFx0XFx0Ly8gdG9uZSBtYXBwaW5nXFxuXFxuXFx0XFx0dGhpcy50b25lTWFwcGluZyA9IExpbmVhclRvbmVNYXBwaW5nO1xcblxcdFxcdHRoaXMudG9uZU1hcHBpbmdFeHBvc3VyZSA9IDEuMDtcXG5cXHRcXHR0aGlzLnRvbmVNYXBwaW5nV2hpdGVQb2ludCA9IDEuMDtcXG5cXG5cXHRcXHQvLyBtb3JwaHNcXG5cXG5cXHRcXHR0aGlzLm1heE1vcnBoVGFyZ2V0cyA9IDg7XFxuXFx0XFx0dGhpcy5tYXhNb3JwaE5vcm1hbHMgPSA0O1xcblxcblxcdFxcdC8vIGludGVybmFsIHByb3BlcnRpZXNcXG5cXG5cXHRcXHR2YXIgX3RoaXMgPSB0aGlzLFxcblxcblxcdFxcdFxcdF9pc0NvbnRleHRMb3N0ID0gZmFsc2UsXFxuXFxuXFx0XFx0XFx0Ly8gaW50ZXJuYWwgc3RhdGUgY2FjaGVcXG5cXG5cXHRcXHRcXHRfY3VycmVudFJlbmRlclRhcmdldCA9IG51bGwsXFxuXFx0XFx0XFx0X2N1cnJlbnRGcmFtZWJ1ZmZlciA9IG51bGwsXFxuXFx0XFx0XFx0X2N1cnJlbnRNYXRlcmlhbElkID0gLSAxLFxcblxcdFxcdFxcdF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtID0gJycsXFxuXFxuXFx0XFx0XFx0X2N1cnJlbnRDYW1lcmEgPSBudWxsLFxcblxcdFxcdFxcdF9jdXJyZW50QXJyYXlDYW1lcmEgPSBudWxsLFxcblxcblxcdFxcdFxcdF9jdXJyZW50Vmlld3BvcnQgPSBuZXcgVmVjdG9yNCgpLFxcblxcdFxcdFxcdF9jdXJyZW50U2Npc3NvciA9IG5ldyBWZWN0b3I0KCksXFxuXFx0XFx0XFx0X2N1cnJlbnRTY2lzc29yVGVzdCA9IG51bGwsXFxuXFxuXFx0XFx0XFx0Ly9cXG5cXG5cXHRcXHRcXHRfdXNlZFRleHR1cmVVbml0cyA9IDAsXFxuXFxuXFx0XFx0XFx0Ly9cXG5cXG5cXHRcXHRcXHRfd2lkdGggPSBfY2FudmFzLndpZHRoLFxcblxcdFxcdFxcdF9oZWlnaHQgPSBfY2FudmFzLmhlaWdodCxcXG5cXG5cXHRcXHRcXHRfcGl4ZWxSYXRpbyA9IDEsXFxuXFxuXFx0XFx0XFx0X3ZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoIDAsIDAsIF93aWR0aCwgX2hlaWdodCApLFxcblxcdFxcdFxcdF9zY2lzc29yID0gbmV3IFZlY3RvcjQoIDAsIDAsIF93aWR0aCwgX2hlaWdodCApLFxcblxcdFxcdFxcdF9zY2lzc29yVGVzdCA9IGZhbHNlLFxcblxcblxcdFxcdFxcdC8vIGZydXN0dW1cXG5cXG5cXHRcXHRcXHRfZnJ1c3R1bSA9IG5ldyBGcnVzdHVtKCksXFxuXFxuXFx0XFx0XFx0Ly8gY2xpcHBpbmdcXG5cXG5cXHRcXHRcXHRfY2xpcHBpbmcgPSBuZXcgV2ViR0xDbGlwcGluZygpLFxcblxcdFxcdFxcdF9jbGlwcGluZ0VuYWJsZWQgPSBmYWxzZSxcXG5cXHRcXHRcXHRfbG9jYWxDbGlwcGluZ0VuYWJsZWQgPSBmYWxzZSxcXG5cXG5cXHRcXHRcXHQvLyBjYW1lcmEgbWF0cmljZXMgY2FjaGVcXG5cXG5cXHRcXHRcXHRfcHJvalNjcmVlbk1hdHJpeCA9IG5ldyBNYXRyaXg0KCksXFxuXFxuXFx0XFx0XFx0X3ZlY3RvcjMgPSBuZXcgVmVjdG9yMygpLFxcblxcblxcdFxcdFxcdC8vIGluZm9cXG5cXG5cXHRcXHRcXHRfaW5mb01lbW9yeSA9IHtcXG5cXHRcXHRcXHRcXHRnZW9tZXRyaWVzOiAwLFxcblxcdFxcdFxcdFxcdHRleHR1cmVzOiAwXFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRfaW5mb1JlbmRlciA9IHtcXG5cXG5cXHRcXHRcXHRcXHRmcmFtZTogMCxcXG5cXHRcXHRcXHRcXHRjYWxsczogMCxcXG5cXHRcXHRcXHRcXHR2ZXJ0aWNlczogMCxcXG5cXHRcXHRcXHRcXHRmYWNlczogMCxcXG5cXHRcXHRcXHRcXHRwb2ludHM6IDBcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuaW5mbyA9IHtcXG5cXG5cXHRcXHRcXHRyZW5kZXI6IF9pbmZvUmVuZGVyLFxcblxcdFxcdFxcdG1lbW9yeTogX2luZm9NZW1vcnksXFxuXFx0XFx0XFx0cHJvZ3JhbXM6IG51bGxcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdGZ1bmN0aW9uIGdldFRhcmdldFBpeGVsUmF0aW8oKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIF9jdXJyZW50UmVuZGVyVGFyZ2V0ID09PSBudWxsID8gX3BpeGVsUmF0aW8gOiAxO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBpbml0aWFsaXplXFxuXFxuXFx0XFx0dmFyIF9nbDtcXG5cXG5cXHRcXHR0cnkge1xcblxcblxcdFxcdFxcdHZhciBjb250ZXh0QXR0cmlidXRlcyA9IHtcXG5cXHRcXHRcXHRcXHRhbHBoYTogX2FscGhhLFxcblxcdFxcdFxcdFxcdGRlcHRoOiBfZGVwdGgsXFxuXFx0XFx0XFx0XFx0c3RlbmNpbDogX3N0ZW5jaWwsXFxuXFx0XFx0XFx0XFx0YW50aWFsaWFzOiBfYW50aWFsaWFzLFxcblxcdFxcdFxcdFxcdHByZW11bHRpcGxpZWRBbHBoYTogX3ByZW11bHRpcGxpZWRBbHBoYSxcXG5cXHRcXHRcXHRcXHRwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IF9wcmVzZXJ2ZURyYXdpbmdCdWZmZXIsXFxuXFx0XFx0XFx0XFx0cG93ZXJQcmVmZXJlbmNlOiBfcG93ZXJQcmVmZXJlbmNlXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHQvLyBldmVudCBsaXN0ZW5lcnMgbXVzdCBiZSByZWdpc3RlcmVkIGJlZm9yZSBXZWJHTCBjb250ZXh0IGlzIGNyZWF0ZWQsIHNlZSAjMTI3NTNcXG5cXG5cXHRcXHRcXHRfY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoICd3ZWJnbGNvbnRleHRsb3N0Jywgb25Db250ZXh0TG9zdCwgZmFsc2UgKTtcXG5cXHRcXHRcXHRfY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoICd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIG9uQ29udGV4dFJlc3RvcmUsIGZhbHNlICk7XFxuXFxuXFx0XFx0XFx0X2dsID0gX2NvbnRleHQgfHwgX2NhbnZhcy5nZXRDb250ZXh0KCAnd2ViZ2wnLCBjb250ZXh0QXR0cmlidXRlcyApIHx8IF9jYW52YXMuZ2V0Q29udGV4dCggJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGNvbnRleHRBdHRyaWJ1dGVzICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBfZ2wgPT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBfY2FudmFzLmdldENvbnRleHQoICd3ZWJnbCcgKSAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoICdFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0IHdpdGggeW91ciBzZWxlY3RlZCBhdHRyaWJ1dGVzLicgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdHRocm93IG5ldyBFcnJvciggJ0Vycm9yIGNyZWF0aW5nIFdlYkdMIGNvbnRleHQuJyApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU29tZSBleHBlcmltZW50YWwtd2ViZ2wgaW1wbGVtZW50YXRpb25zIGRvIG5vdCBoYXZlIGdldFNoYWRlclByZWNpc2lvbkZvcm1hdFxcblxcblxcdFxcdFxcdGlmICggX2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHsgJ3JhbmdlTWluJzogMSwgJ3JhbmdlTWF4JzogMSwgJ3ByZWNpc2lvbic6IDEgfTtcXG5cXG5cXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9IGNhdGNoICggZXJyb3IgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXI6ICcgKyBlcnJvci5tZXNzYWdlICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHZhciBleHRlbnNpb25zLCBjYXBhYmlsaXRpZXMsIHN0YXRlO1xcblxcdFxcdHZhciBwcm9wZXJ0aWVzLCB0ZXh0dXJlcywgYXR0cmlidXRlcywgZ2VvbWV0cmllcywgb2JqZWN0cywgbGlnaHRzO1xcblxcdFxcdHZhciBwcm9ncmFtQ2FjaGUsIHJlbmRlckxpc3RzO1xcblxcblxcdFxcdHZhciBiYWNrZ3JvdW5kLCBtb3JwaHRhcmdldHMsIGJ1ZmZlclJlbmRlcmVyLCBpbmRleGVkQnVmZmVyUmVuZGVyZXI7XFxuXFx0XFx0dmFyIGZsYXJlUmVuZGVyZXIsIHNwcml0ZVJlbmRlcmVyO1xcblxcblxcdFxcdHZhciB1dGlscztcXG5cXG5cXHRcXHRmdW5jdGlvbiBpbml0R0xDb250ZXh0KCkge1xcblxcblxcdFxcdFxcdGV4dGVuc2lvbnMgPSBuZXcgV2ViR0xFeHRlbnNpb25zKCBfZ2wgKTtcXG5cXHRcXHRcXHRleHRlbnNpb25zLmdldCggJ1dFQkdMX2RlcHRoX3RleHR1cmUnICk7XFxuXFx0XFx0XFx0ZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdCcgKTtcXG5cXHRcXHRcXHRleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicgKTtcXG5cXHRcXHRcXHRleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnICk7XFxuXFx0XFx0XFx0ZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0X2xpbmVhcicgKTtcXG5cXHRcXHRcXHRleHRlbnNpb25zLmdldCggJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcycgKTtcXG5cXHRcXHRcXHRleHRlbnNpb25zLmdldCggJ09FU19lbGVtZW50X2luZGV4X3VpbnQnICk7XFxuXFx0XFx0XFx0ZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xcblxcblxcdFxcdFxcdHV0aWxzID0gbmV3IFdlYkdMVXRpbHMoIF9nbCwgZXh0ZW5zaW9ucyApO1xcblxcblxcdFxcdFxcdGNhcGFiaWxpdGllcyA9IG5ldyBXZWJHTENhcGFiaWxpdGllcyggX2dsLCBleHRlbnNpb25zLCBwYXJhbWV0ZXJzICk7XFxuXFxuXFx0XFx0XFx0c3RhdGUgPSBuZXcgV2ViR0xTdGF0ZSggX2dsLCBleHRlbnNpb25zLCB1dGlscyApO1xcblxcdFxcdFxcdHN0YXRlLnNjaXNzb3IoIF9jdXJyZW50U2Npc3Nvci5jb3B5KCBfc2Npc3NvciApLm11bHRpcGx5U2NhbGFyKCBfcGl4ZWxSYXRpbyApICk7XFxuXFx0XFx0XFx0c3RhdGUudmlld3BvcnQoIF9jdXJyZW50Vmlld3BvcnQuY29weSggX3ZpZXdwb3J0ICkubXVsdGlwbHlTY2FsYXIoIF9waXhlbFJhdGlvICkgKTtcXG5cXG5cXHRcXHRcXHRwcm9wZXJ0aWVzID0gbmV3IFdlYkdMUHJvcGVydGllcygpO1xcblxcdFxcdFxcdHRleHR1cmVzID0gbmV3IFdlYkdMVGV4dHVyZXMoIF9nbCwgZXh0ZW5zaW9ucywgc3RhdGUsIHByb3BlcnRpZXMsIGNhcGFiaWxpdGllcywgdXRpbHMsIF9pbmZvTWVtb3J5ICk7XFxuXFx0XFx0XFx0YXR0cmlidXRlcyA9IG5ldyBXZWJHTEF0dHJpYnV0ZXMoIF9nbCApO1xcblxcdFxcdFxcdGdlb21ldHJpZXMgPSBuZXcgV2ViR0xHZW9tZXRyaWVzKCBfZ2wsIGF0dHJpYnV0ZXMsIF9pbmZvTWVtb3J5ICk7XFxuXFx0XFx0XFx0b2JqZWN0cyA9IG5ldyBXZWJHTE9iamVjdHMoIGdlb21ldHJpZXMsIF9pbmZvUmVuZGVyICk7XFxuXFx0XFx0XFx0bW9ycGh0YXJnZXRzID0gbmV3IFdlYkdMTW9ycGh0YXJnZXRzKCBfZ2wgKTtcXG5cXHRcXHRcXHRwcm9ncmFtQ2FjaGUgPSBuZXcgV2ViR0xQcm9ncmFtcyggX3RoaXMsIGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcyApO1xcblxcdFxcdFxcdGxpZ2h0cyA9IG5ldyBXZWJHTExpZ2h0cygpO1xcblxcdFxcdFxcdHJlbmRlckxpc3RzID0gbmV3IFdlYkdMUmVuZGVyTGlzdHMoKTtcXG5cXG5cXHRcXHRcXHRiYWNrZ3JvdW5kID0gbmV3IFdlYkdMQmFja2dyb3VuZCggX3RoaXMsIHN0YXRlLCBnZW9tZXRyaWVzLCBfcHJlbXVsdGlwbGllZEFscGhhICk7XFxuXFxuXFx0XFx0XFx0YnVmZmVyUmVuZGVyZXIgPSBuZXcgV2ViR0xCdWZmZXJSZW5kZXJlciggX2dsLCBleHRlbnNpb25zLCBfaW5mb1JlbmRlciApO1xcblxcdFxcdFxcdGluZGV4ZWRCdWZmZXJSZW5kZXJlciA9IG5ldyBXZWJHTEluZGV4ZWRCdWZmZXJSZW5kZXJlciggX2dsLCBleHRlbnNpb25zLCBfaW5mb1JlbmRlciApO1xcblxcblxcdFxcdFxcdGZsYXJlUmVuZGVyZXIgPSBuZXcgV2ViR0xGbGFyZVJlbmRlcmVyKCBfdGhpcywgX2dsLCBzdGF0ZSwgdGV4dHVyZXMsIGNhcGFiaWxpdGllcyApO1xcblxcdFxcdFxcdHNwcml0ZVJlbmRlcmVyID0gbmV3IFdlYkdMU3ByaXRlUmVuZGVyZXIoIF90aGlzLCBfZ2wsIHN0YXRlLCB0ZXh0dXJlcywgY2FwYWJpbGl0aWVzICk7XFxuXFxuXFx0XFx0XFx0X3RoaXMuaW5mby5wcm9ncmFtcyA9IHByb2dyYW1DYWNoZS5wcm9ncmFtcztcXG5cXG5cXHRcXHRcXHRfdGhpcy5jb250ZXh0ID0gX2dsO1xcblxcdFxcdFxcdF90aGlzLmNhcGFiaWxpdGllcyA9IGNhcGFiaWxpdGllcztcXG5cXHRcXHRcXHRfdGhpcy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcXG5cXHRcXHRcXHRfdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcXG5cXHRcXHRcXHRfdGhpcy5yZW5kZXJMaXN0cyA9IHJlbmRlckxpc3RzO1xcblxcdFxcdFxcdF90aGlzLnN0YXRlID0gc3RhdGU7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGluaXRHTENvbnRleHQoKTtcXG5cXG5cXHRcXHQvLyB2clxcblxcblxcdFxcdHZhciB2ciA9IG5ldyBXZWJWUk1hbmFnZXIoIF90aGlzICk7XFxuXFxuXFx0XFx0dGhpcy52ciA9IHZyO1xcblxcblxcdFxcdC8vIHNoYWRvdyBtYXBcXG5cXG5cXHRcXHR2YXIgc2hhZG93TWFwID0gbmV3IFdlYkdMU2hhZG93TWFwKCBfdGhpcywgb2JqZWN0cywgY2FwYWJpbGl0aWVzLm1heFRleHR1cmVTaXplICk7XFxuXFxuXFx0XFx0dGhpcy5zaGFkb3dNYXAgPSBzaGFkb3dNYXA7XFxuXFxuXFx0XFx0Ly8gQVBJXFxuXFxuXFx0XFx0dGhpcy5nZXRDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBfZ2w7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGlzLmdldENvbnRleHRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBfZ2wuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuZm9yY2VDb250ZXh0TG9zcyA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9sb3NlX2NvbnRleHQnICk7XFxuXFx0XFx0XFx0aWYgKCBleHRlbnNpb24gKSBleHRlbnNpb24ubG9zZUNvbnRleHQoKTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuZm9yY2VDb250ZXh0UmVzdG9yZSA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9sb3NlX2NvbnRleHQnICk7XFxuXFx0XFx0XFx0aWYgKCBleHRlbnNpb24gKSBleHRlbnNpb24ucmVzdG9yZUNvbnRleHQoKTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuZ2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gX3BpeGVsUmF0aW87XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGlzLnNldFBpeGVsUmF0aW8gPSBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHJldHVybjtcXG5cXG5cXHRcXHRcXHRfcGl4ZWxSYXRpbyA9IHZhbHVlO1xcblxcblxcdFxcdFxcdHRoaXMuc2V0U2l6ZSggX3dpZHRoLCBfaGVpZ2h0LCBmYWxzZSApO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0XFx0d2lkdGg6IF93aWR0aCxcXG5cXHRcXHRcXHRcXHRoZWlnaHQ6IF9oZWlnaHRcXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5zZXRTaXplID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCB1cGRhdGVTdHlsZSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgZGV2aWNlID0gdnIuZ2V0RGV2aWNlKCk7XFxuXFxuXFx0XFx0XFx0aWYgKCBkZXZpY2UgJiYgZGV2aWNlLmlzUHJlc2VudGluZyApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBDYW5cXFxcJ3QgY2hhbmdlIHNpemUgd2hpbGUgVlIgZGV2aWNlIGlzIHByZXNlbnRpbmcuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0X3dpZHRoID0gd2lkdGg7XFxuXFx0XFx0XFx0X2hlaWdodCA9IGhlaWdodDtcXG5cXG5cXHRcXHRcXHRfY2FudmFzLndpZHRoID0gd2lkdGggKiBfcGl4ZWxSYXRpbztcXG5cXHRcXHRcXHRfY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIF9waXhlbFJhdGlvO1xcblxcblxcdFxcdFxcdGlmICggdXBkYXRlU3R5bGUgIT09IGZhbHNlICkge1xcblxcblxcdFxcdFxcdFxcdF9jYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XFxuXFx0XFx0XFx0XFx0X2NhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLnNldFZpZXdwb3J0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGlzLmdldERyYXdpbmdCdWZmZXJTaXplID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0XFx0d2lkdGg6IF93aWR0aCAqIF9waXhlbFJhdGlvLFxcblxcdFxcdFxcdFxcdGhlaWdodDogX2hlaWdodCAqIF9waXhlbFJhdGlvXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuc2V0RHJhd2luZ0J1ZmZlclNpemUgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIHBpeGVsUmF0aW8gKSB7XFxuXFxuXFx0XFx0XFx0X3dpZHRoID0gd2lkdGg7XFxuXFx0XFx0XFx0X2hlaWdodCA9IGhlaWdodDtcXG5cXG5cXHRcXHRcXHRfcGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XFxuXFxuXFx0XFx0XFx0X2NhbnZhcy53aWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcXG5cXHRcXHRcXHRfY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIHBpeGVsUmF0aW87XFxuXFxuXFx0XFx0XFx0dGhpcy5zZXRWaWV3cG9ydCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5zZXRWaWV3cG9ydCA9IGZ1bmN0aW9uICggeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcXG5cXG5cXHRcXHRcXHRfdmlld3BvcnQuc2V0KCB4LCBfaGVpZ2h0IC0geSAtIGhlaWdodCwgd2lkdGgsIGhlaWdodCApO1xcblxcdFxcdFxcdHN0YXRlLnZpZXdwb3J0KCBfY3VycmVudFZpZXdwb3J0LmNvcHkoIF92aWV3cG9ydCApLm11bHRpcGx5U2NhbGFyKCBfcGl4ZWxSYXRpbyApICk7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGlzLnNldFNjaXNzb3IgPSBmdW5jdGlvbiAoIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XFxuXFxuXFx0XFx0XFx0X3NjaXNzb3Iuc2V0KCB4LCBfaGVpZ2h0IC0geSAtIGhlaWdodCwgd2lkdGgsIGhlaWdodCApO1xcblxcdFxcdFxcdHN0YXRlLnNjaXNzb3IoIF9jdXJyZW50U2Npc3Nvci5jb3B5KCBfc2Npc3NvciApLm11bHRpcGx5U2NhbGFyKCBfcGl4ZWxSYXRpbyApICk7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGlzLnNldFNjaXNzb3JUZXN0ID0gZnVuY3Rpb24gKCBib29sZWFuICkge1xcblxcblxcdFxcdFxcdHN0YXRlLnNldFNjaXNzb3JUZXN0KCBfc2Npc3NvclRlc3QgPSBib29sZWFuICk7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBDbGVhcmluZ1xcblxcblxcdFxcdHRoaXMuZ2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gYmFja2dyb3VuZC5nZXRDbGVhckNvbG9yKCk7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGlzLnNldENsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0YmFja2dyb3VuZC5zZXRDbGVhckNvbG9yLmFwcGx5KCBiYWNrZ3JvdW5kLCBhcmd1bWVudHMgKTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuZ2V0Q2xlYXJBbHBoYSA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gYmFja2dyb3VuZC5nZXRDbGVhckFscGhhKCk7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGlzLnNldENsZWFyQWxwaGEgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0YmFja2dyb3VuZC5zZXRDbGVhckFscGhhLmFwcGx5KCBiYWNrZ3JvdW5kLCBhcmd1bWVudHMgKTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYml0cyA9IDA7XFxuXFxuXFx0XFx0XFx0aWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkIHx8IGNvbG9yICkgYml0cyB8PSBfZ2wuQ09MT1JfQlVGRkVSX0JJVDtcXG5cXHRcXHRcXHRpZiAoIGRlcHRoID09PSB1bmRlZmluZWQgfHwgZGVwdGggKSBiaXRzIHw9IF9nbC5ERVBUSF9CVUZGRVJfQklUO1xcblxcdFxcdFxcdGlmICggc3RlbmNpbCA9PT0gdW5kZWZpbmVkIHx8IHN0ZW5jaWwgKSBiaXRzIHw9IF9nbC5TVEVOQ0lMX0JVRkZFUl9CSVQ7XFxuXFxuXFx0XFx0XFx0X2dsLmNsZWFyKCBiaXRzICk7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGlzLmNsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5jbGVhciggdHJ1ZSwgZmFsc2UsIGZhbHNlICk7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGlzLmNsZWFyRGVwdGggPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5jbGVhciggZmFsc2UsIHRydWUsIGZhbHNlICk7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGlzLmNsZWFyU3RlbmNpbCA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmNsZWFyKCBmYWxzZSwgZmFsc2UsIHRydWUgKTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuY2xlYXJUYXJnZXQgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCwgY29sb3IsIGRlcHRoLCBzdGVuY2lsICkge1xcblxcblxcdFxcdFxcdHRoaXMuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcXG5cXHRcXHRcXHR0aGlzLmNsZWFyKCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vXFxuXFxuXFx0XFx0dGhpcy5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdF9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3dlYmdsY29udGV4dGxvc3QnLCBvbkNvbnRleHRMb3N0LCBmYWxzZSApO1xcblxcdFxcdFxcdF9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgb25Db250ZXh0UmVzdG9yZSwgZmFsc2UgKTtcXG5cXG5cXHRcXHRcXHRyZW5kZXJMaXN0cy5kaXNwb3NlKCk7XFxuXFxuXFx0XFx0XFx0dnIuZGlzcG9zZSgpO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gRXZlbnRzXFxuXFxuXFx0XFx0ZnVuY3Rpb24gb25Db250ZXh0TG9zdCggZXZlbnQgKSB7XFxuXFxuXFx0XFx0XFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLmxvZyggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IENvbnRleHQgTG9zdC4nICk7XFxuXFxuXFx0XFx0XFx0X2lzQ29udGV4dExvc3QgPSB0cnVlO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBvbkNvbnRleHRSZXN0b3JlKCAvKiBldmVudCAqLyApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLmxvZyggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IENvbnRleHQgUmVzdG9yZWQuJyApO1xcblxcblxcdFxcdFxcdF9pc0NvbnRleHRMb3N0ID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0aW5pdEdMQ29udGV4dCgpO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBvbk1hdGVyaWFsRGlzcG9zZSggZXZlbnQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIG1hdGVyaWFsID0gZXZlbnQudGFyZ2V0O1xcblxcblxcdFxcdFxcdG1hdGVyaWFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25NYXRlcmlhbERpc3Bvc2UgKTtcXG5cXG5cXHRcXHRcXHRkZWFsbG9jYXRlTWF0ZXJpYWwoIG1hdGVyaWFsICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEJ1ZmZlciBkZWFsbG9jYXRpb25cXG5cXG5cXHRcXHRmdW5jdGlvbiBkZWFsbG9jYXRlTWF0ZXJpYWwoIG1hdGVyaWFsICkge1xcblxcblxcdFxcdFxcdHJlbGVhc2VNYXRlcmlhbFByb2dyYW1SZWZlcmVuY2UoIG1hdGVyaWFsICk7XFxuXFxuXFx0XFx0XFx0cHJvcGVydGllcy5yZW1vdmUoIG1hdGVyaWFsICk7XFxuXFxuXFx0XFx0fVxcblxcblxcblxcdFxcdGZ1bmN0aW9uIHJlbGVhc2VNYXRlcmlhbFByb2dyYW1SZWZlcmVuY2UoIG1hdGVyaWFsICkge1xcblxcblxcdFxcdFxcdHZhciBwcm9ncmFtSW5mbyA9IHByb3BlcnRpZXMuZ2V0KCBtYXRlcmlhbCApLnByb2dyYW07XFxuXFxuXFx0XFx0XFx0bWF0ZXJpYWwucHJvZ3JhbSA9IHVuZGVmaW5lZDtcXG5cXG5cXHRcXHRcXHRpZiAoIHByb2dyYW1JbmZvICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cHJvZ3JhbUNhY2hlLnJlbGVhc2VQcm9ncmFtKCBwcm9ncmFtSW5mbyApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQnVmZmVyIHJlbmRlcmluZ1xcblxcblxcdFxcdGZ1bmN0aW9uIHJlbmRlck9iamVjdEltbWVkaWF0ZSggb2JqZWN0LCBwcm9ncmFtLCBtYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRcXHRvYmplY3QucmVuZGVyKCBmdW5jdGlvbiAoIG9iamVjdCApIHtcXG5cXG5cXHRcXHRcXHRcXHRfdGhpcy5yZW5kZXJCdWZmZXJJbW1lZGlhdGUoIG9iamVjdCwgcHJvZ3JhbSwgbWF0ZXJpYWwgKTtcXG5cXG5cXHRcXHRcXHR9ICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMucmVuZGVyQnVmZmVySW1tZWRpYXRlID0gZnVuY3Rpb24gKCBvYmplY3QsIHByb2dyYW0sIG1hdGVyaWFsICkge1xcblxcblxcdFxcdFxcdHN0YXRlLmluaXRBdHRyaWJ1dGVzKCk7XFxuXFxuXFx0XFx0XFx0dmFyIGJ1ZmZlcnMgPSBwcm9wZXJ0aWVzLmdldCggb2JqZWN0ICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBvYmplY3QuaGFzUG9zaXRpb25zICYmICEgYnVmZmVycy5wb3NpdGlvbiApIGJ1ZmZlcnMucG9zaXRpb24gPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XFxuXFx0XFx0XFx0aWYgKCBvYmplY3QuaGFzTm9ybWFscyAmJiAhIGJ1ZmZlcnMubm9ybWFsICkgYnVmZmVycy5ub3JtYWwgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XFxuXFx0XFx0XFx0aWYgKCBvYmplY3QuaGFzVXZzICYmICEgYnVmZmVycy51diApIGJ1ZmZlcnMudXYgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XFxuXFx0XFx0XFx0aWYgKCBvYmplY3QuaGFzQ29sb3JzICYmICEgYnVmZmVycy5jb2xvciApIGJ1ZmZlcnMuY29sb3IgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XFxuXFxuXFx0XFx0XFx0dmFyIHByb2dyYW1BdHRyaWJ1dGVzID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGVzKCk7XFxuXFxuXFx0XFx0XFx0aWYgKCBvYmplY3QuaGFzUG9zaXRpb25zICkge1xcblxcblxcdFxcdFxcdFxcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJzLnBvc2l0aW9uICk7XFxuXFx0XFx0XFx0XFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5wb3NpdGlvbkFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XFxuXFxuXFx0XFx0XFx0XFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBwcm9ncmFtQXR0cmlidXRlcy5wb3NpdGlvbiApO1xcblxcdFxcdFxcdFxcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBwcm9ncmFtQXR0cmlidXRlcy5wb3NpdGlvbiwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIG9iamVjdC5oYXNOb3JtYWxzICkge1xcblxcblxcdFxcdFxcdFxcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJzLm5vcm1hbCApO1xcblxcblxcdFxcdFxcdFxcdGlmICggISBtYXRlcmlhbC5pc01lc2hQaG9uZ01hdGVyaWFsICYmXFxuXFx0XFx0XFx0XFx0XFx0ISBtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsICYmXFxuXFx0XFx0XFx0XFx0XFx0ISBtYXRlcmlhbC5pc01lc2hOb3JtYWxNYXRlcmlhbCAmJlxcblxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsLmZsYXRTaGFkaW5nID09PSB0cnVlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IG9iamVjdC5jb3VudCAqIDM7IGkgPCBsOyBpICs9IDkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGFycmF5ID0gb2JqZWN0Lm5vcm1hbEFycmF5O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBueCA9ICggYXJyYXlbIGkgKyAwIF0gKyBhcnJheVsgaSArIDMgXSArIGFycmF5WyBpICsgNiBdICkgLyAzO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBueSA9ICggYXJyYXlbIGkgKyAxIF0gKyBhcnJheVsgaSArIDQgXSArIGFycmF5WyBpICsgNyBdICkgLyAzO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBueiA9ICggYXJyYXlbIGkgKyAyIF0gKyBhcnJheVsgaSArIDUgXSArIGFycmF5WyBpICsgOCBdICkgLyAzO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGFycmF5WyBpICsgMCBdID0gbng7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YXJyYXlbIGkgKyAxIF0gPSBueTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRhcnJheVsgaSArIDIgXSA9IG56O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGFycmF5WyBpICsgMyBdID0gbng7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YXJyYXlbIGkgKyA0IF0gPSBueTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRhcnJheVsgaSArIDUgXSA9IG56O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGFycmF5WyBpICsgNiBdID0gbng7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YXJyYXlbIGkgKyA3IF0gPSBueTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRhcnJheVsgaSArIDggXSA9IG56O1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5ub3JtYWxBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xcblxcblxcdFxcdFxcdFxcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggcHJvZ3JhbUF0dHJpYnV0ZXMubm9ybWFsICk7XFxuXFxuXFx0XFx0XFx0XFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIHByb2dyYW1BdHRyaWJ1dGVzLm5vcm1hbCwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIG9iamVjdC5oYXNVdnMgJiYgbWF0ZXJpYWwubWFwICkge1xcblxcblxcdFxcdFxcdFxcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJzLnV2ICk7XFxuXFx0XFx0XFx0XFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC51dkFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XFxuXFxuXFx0XFx0XFx0XFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBwcm9ncmFtQXR0cmlidXRlcy51diApO1xcblxcblxcdFxcdFxcdFxcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBwcm9ncmFtQXR0cmlidXRlcy51diwgMiwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIG9iamVjdC5oYXNDb2xvcnMgJiYgbWF0ZXJpYWwudmVydGV4Q29sb3JzICE9PSBOb0NvbG9ycyApIHtcXG5cXG5cXHRcXHRcXHRcXHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVycy5jb2xvciApO1xcblxcdFxcdFxcdFxcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QuY29sb3JBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xcblxcblxcdFxcdFxcdFxcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggcHJvZ3JhbUF0dHJpYnV0ZXMuY29sb3IgKTtcXG5cXG5cXHRcXHRcXHRcXHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbUF0dHJpYnV0ZXMuY29sb3IsIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0c3RhdGUuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcXG5cXG5cXHRcXHRcXHRfZ2wuZHJhd0FycmF5cyggX2dsLlRSSUFOR0xFUywgMCwgb2JqZWN0LmNvdW50ICk7XFxuXFxuXFx0XFx0XFx0b2JqZWN0LmNvdW50ID0gMDtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMucmVuZGVyQnVmZmVyRGlyZWN0ID0gZnVuY3Rpb24gKCBjYW1lcmEsIGZvZywgZ2VvbWV0cnksIG1hdGVyaWFsLCBvYmplY3QsIGdyb3VwICkge1xcblxcblxcdFxcdFxcdHZhciBmcm9udEZhY2VDVyA9ICggb2JqZWN0LmlzTWVzaCAmJiBvYmplY3QubWF0cml4V29ybGQuZGV0ZXJtaW5hbnQoKSA8IDAgKTtcXG5cXG5cXHRcXHRcXHRzdGF0ZS5zZXRNYXRlcmlhbCggbWF0ZXJpYWwsIGZyb250RmFjZUNXICk7XFxuXFxuXFx0XFx0XFx0dmFyIHByb2dyYW0gPSBzZXRQcm9ncmFtKCBjYW1lcmEsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApO1xcblxcdFxcdFxcdHZhciBnZW9tZXRyeVByb2dyYW0gPSBnZW9tZXRyeS5pZCArICdfJyArIHByb2dyYW0uaWQgKyAnXycgKyAoIG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZSApO1xcblxcblxcdFxcdFxcdHZhciB1cGRhdGVCdWZmZXJzID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0aWYgKCBnZW9tZXRyeVByb2dyYW0gIT09IF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtICkge1xcblxcblxcdFxcdFxcdFxcdF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtID0gZ2VvbWV0cnlQcm9ncmFtO1xcblxcdFxcdFxcdFxcdHVwZGF0ZUJ1ZmZlcnMgPSB0cnVlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIG9iamVjdC5tb3JwaFRhcmdldEluZmx1ZW5jZXMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0bW9ycGh0YXJnZXRzLnVwZGF0ZSggb2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHByb2dyYW0gKTtcXG5cXG5cXHRcXHRcXHRcXHR1cGRhdGVCdWZmZXJzID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly9cXG5cXG5cXHRcXHRcXHR2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcXG5cXHRcXHRcXHR2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xcblxcdFxcdFxcdHZhciByYW5nZUZhY3RvciA9IDE7XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aW5kZXggPSBnZW9tZXRyaWVzLmdldFdpcmVmcmFtZUF0dHJpYnV0ZSggZ2VvbWV0cnkgKTtcXG5cXHRcXHRcXHRcXHRyYW5nZUZhY3RvciA9IDI7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBhdHRyaWJ1dGU7XFxuXFx0XFx0XFx0dmFyIHJlbmRlcmVyID0gYnVmZmVyUmVuZGVyZXI7XFxuXFxuXFx0XFx0XFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLmdldCggaW5kZXggKTtcXG5cXG5cXHRcXHRcXHRcXHRyZW5kZXJlciA9IGluZGV4ZWRCdWZmZXJSZW5kZXJlcjtcXG5cXHRcXHRcXHRcXHRyZW5kZXJlci5zZXRJbmRleCggYXR0cmlidXRlICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggdXBkYXRlQnVmZmVycyApIHtcXG5cXG5cXHRcXHRcXHRcXHRzZXR1cFZlcnRleEF0dHJpYnV0ZXMoIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSApO1xcblxcblxcdFxcdFxcdFxcdGlmICggaW5kZXggIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgYXR0cmlidXRlLmJ1ZmZlciApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly9cXG5cXG5cXHRcXHRcXHR2YXIgZGF0YUNvdW50ID0gMDtcXG5cXG5cXHRcXHRcXHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdGRhdGFDb3VudCA9IGluZGV4LmNvdW50O1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZGF0YUNvdW50ID0gcG9zaXRpb24uY291bnQ7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciByYW5nZVN0YXJ0ID0gZ2VvbWV0cnkuZHJhd1JhbmdlLnN0YXJ0ICogcmFuZ2VGYWN0b3I7XFxuXFx0XFx0XFx0dmFyIHJhbmdlQ291bnQgPSBnZW9tZXRyeS5kcmF3UmFuZ2UuY291bnQgKiByYW5nZUZhY3RvcjtcXG5cXG5cXHRcXHRcXHR2YXIgZ3JvdXBTdGFydCA9IGdyb3VwICE9PSBudWxsID8gZ3JvdXAuc3RhcnQgKiByYW5nZUZhY3RvciA6IDA7XFxuXFx0XFx0XFx0dmFyIGdyb3VwQ291bnQgPSBncm91cCAhPT0gbnVsbCA/IGdyb3VwLmNvdW50ICogcmFuZ2VGYWN0b3IgOiBJbmZpbml0eTtcXG5cXG5cXHRcXHRcXHR2YXIgZHJhd1N0YXJ0ID0gTWF0aC5tYXgoIHJhbmdlU3RhcnQsIGdyb3VwU3RhcnQgKTtcXG5cXHRcXHRcXHR2YXIgZHJhd0VuZCA9IE1hdGgubWluKCBkYXRhQ291bnQsIHJhbmdlU3RhcnQgKyByYW5nZUNvdW50LCBncm91cFN0YXJ0ICsgZ3JvdXBDb3VudCApIC0gMTtcXG5cXG5cXHRcXHRcXHR2YXIgZHJhd0NvdW50ID0gTWF0aC5tYXgoIDAsIGRyYXdFbmQgLSBkcmF3U3RhcnQgKyAxICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBkcmF3Q291bnQgPT09IDAgKSByZXR1cm47XFxuXFxuXFx0XFx0XFx0Ly9cXG5cXG5cXHRcXHRcXHRpZiAoIG9iamVjdC5pc01lc2ggKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUuc2V0TGluZVdpZHRoKCBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggKiBnZXRUYXJnZXRQaXhlbFJhdGlvKCkgKTtcXG5cXHRcXHRcXHRcXHRcXHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuTElORVMgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdHN3aXRjaCAoIG9iamVjdC5kcmF3TW9kZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlIFRyaWFuZ2xlc0RyYXdNb2RlOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5UUklBTkdMRVMgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlIFRyaWFuZ2xlU3RyaXBEcmF3TW9kZTpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuVFJJQU5HTEVfU1RSSVAgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlIFRyaWFuZ2xlRmFuRHJhd01vZGU6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLlRSSUFOR0xFX0ZBTiApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggb2JqZWN0LmlzTGluZSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbGluZVdpZHRoID0gbWF0ZXJpYWwubGluZXdpZHRoO1xcblxcblxcdFxcdFxcdFxcdGlmICggbGluZVdpZHRoID09PSB1bmRlZmluZWQgKSBsaW5lV2lkdGggPSAxOyAvLyBOb3QgdXNpbmcgTGluZSpNYXRlcmlhbFxcblxcblxcdFxcdFxcdFxcdHN0YXRlLnNldExpbmVXaWR0aCggbGluZVdpZHRoICogZ2V0VGFyZ2V0UGl4ZWxSYXRpbygpICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBvYmplY3QuaXNMaW5lU2VnbWVudHMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLkxJTkVTICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggb2JqZWN0LmlzTGluZUxvb3AgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLkxJTkVfTE9PUCApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLkxJTkVfU1RSSVAgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggb2JqZWN0LmlzUG9pbnRzICkge1xcblxcblxcdFxcdFxcdFxcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5QT0lOVFMgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPiAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJlbmRlcmVyLnJlbmRlckluc3RhbmNlcyggZ2VvbWV0cnksIGRyYXdTdGFydCwgZHJhd0NvdW50ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0cmVuZGVyZXIucmVuZGVyKCBkcmF3U3RhcnQsIGRyYXdDb3VudCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdGZ1bmN0aW9uIHNldHVwVmVydGV4QXR0cmlidXRlcyggbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5LCBzdGFydEluZGV4ICkge1xcblxcblxcdFxcdFxcdGlmICggZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKSA9PT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5zZXR1cFZlcnRleEF0dHJpYnV0ZXM6IHVzaW5nIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLicgKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHN0YXJ0SW5kZXggPT09IHVuZGVmaW5lZCApIHN0YXJ0SW5kZXggPSAwO1xcblxcblxcdFxcdFxcdHN0YXRlLmluaXRBdHRyaWJ1dGVzKCk7XFxuXFxuXFx0XFx0XFx0dmFyIGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XFxuXFxuXFx0XFx0XFx0dmFyIHByb2dyYW1BdHRyaWJ1dGVzID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGVzKCk7XFxuXFxuXFx0XFx0XFx0dmFyIG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyA9IG1hdGVyaWFsLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXM7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIG5hbWUgaW4gcHJvZ3JhbUF0dHJpYnV0ZXMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHByb2dyYW1BdHRyaWJ1dGUgPSBwcm9ncmFtQXR0cmlidXRlc1sgbmFtZSBdO1xcblxcblxcdFxcdFxcdFxcdGlmICggcHJvZ3JhbUF0dHJpYnV0ZSA+PSAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBnZW9tZXRyeUF0dHJpYnV0ZSA9IGdlb21ldHJ5QXR0cmlidXRlc1sgbmFtZSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgbm9ybWFsaXplZCA9IGdlb21ldHJ5QXR0cmlidXRlLm5vcm1hbGl6ZWQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHNpemUgPSBnZW9tZXRyeUF0dHJpYnV0ZS5pdGVtU2l6ZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlcy5nZXQoIGdlb21ldHJ5QXR0cmlidXRlICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gVE9ETyBBdHRyaWJ1dGUgbWF5IG5vdCBiZSBhdmFpbGFibGUgb24gY29udGV4dCByZXN0b3JlXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBhdHRyaWJ1dGUgPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBidWZmZXIgPSBhdHRyaWJ1dGUuYnVmZmVyO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciB0eXBlID0gYXR0cmlidXRlLnR5cGU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGJ5dGVzUGVyRWxlbWVudCA9IGF0dHJpYnV0ZS5ieXRlc1BlckVsZW1lbnQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyeUF0dHJpYnV0ZS5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBkYXRhID0gZ2VvbWV0cnlBdHRyaWJ1dGUuZGF0YTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgc3RyaWRlID0gZGF0YS5zdHJpZGU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIG9mZnNldCA9IGdlb21ldHJ5QXR0cmlidXRlLm9mZnNldDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEgJiYgZGF0YS5pc0luc3RhbmNlZEludGVybGVhdmVkQnVmZmVyICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IoIHByb2dyYW1BdHRyaWJ1dGUsIGRhdGEubWVzaFBlckF0dHJpYnV0ZSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA9IGRhdGEubWVzaFBlckF0dHJpYnV0ZSAqIGRhdGEuY291bnQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBwcm9ncmFtQXR0cmlidXRlICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbUF0dHJpYnV0ZSwgc2l6ZSwgdHlwZSwgbm9ybWFsaXplZCwgc3RyaWRlICogYnl0ZXNQZXJFbGVtZW50LCAoIHN0YXJ0SW5kZXggKiBzdHJpZGUgKyBvZmZzZXQgKSAqIGJ5dGVzUGVyRWxlbWVudCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyeUF0dHJpYnV0ZS5pc0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGVBbmREaXZpc29yKCBwcm9ncmFtQXR0cmlidXRlLCBnZW9tZXRyeUF0dHJpYnV0ZS5tZXNoUGVyQXR0cmlidXRlICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID0gZ2VvbWV0cnlBdHRyaWJ1dGUubWVzaFBlckF0dHJpYnV0ZSAqIGdlb21ldHJ5QXR0cmlidXRlLmNvdW50O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggcHJvZ3JhbUF0dHJpYnV0ZSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgYnVmZmVyICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIHByb2dyYW1BdHRyaWJ1dGUsIHNpemUsIHR5cGUsIG5vcm1hbGl6ZWQsIDAsIHN0YXJ0SW5kZXggKiBzaXplICogYnl0ZXNQZXJFbGVtZW50ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlcyAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciB2YWx1ZSA9IG1hdGVyaWFsRGVmYXVsdEF0dHJpYnV0ZVZhbHVlc1sgbmFtZSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzd2l0Y2ggKCB2YWx1ZS5sZW5ndGggKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAyOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdF9nbC52ZXJ0ZXhBdHRyaWIyZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAzOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdF9nbC52ZXJ0ZXhBdHRyaWIzZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSA0OlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdF9nbC52ZXJ0ZXhBdHRyaWI0ZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGVmYXVsdDpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRfZ2wudmVydGV4QXR0cmliMWZ2KCBwcm9ncmFtQXR0cmlidXRlLCB2YWx1ZSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0c3RhdGUuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMoKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQ29tcGlsZVxcblxcblxcdFxcdHRoaXMuY29tcGlsZSA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSApIHtcXG5cXG5cXHRcXHRcXHRsaWdodHNBcnJheS5sZW5ndGggPSAwO1xcblxcdFxcdFxcdHNoYWRvd3NBcnJheS5sZW5ndGggPSAwO1xcblxcblxcdFxcdFxcdHNjZW5lLnRyYXZlcnNlKCBmdW5jdGlvbiAoIG9iamVjdCApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG9iamVjdC5pc0xpZ2h0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGxpZ2h0c0FycmF5LnB1c2goIG9iamVjdCApO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggb2JqZWN0LmNhc3RTaGFkb3cgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0c2hhZG93c0FycmF5LnB1c2goIG9iamVjdCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fSApO1xcblxcblxcdFxcdFxcdGxpZ2h0cy5zZXR1cCggbGlnaHRzQXJyYXksIHNoYWRvd3NBcnJheSwgY2FtZXJhICk7XFxuXFxuXFx0XFx0XFx0c2NlbmUudHJhdmVyc2UoIGZ1bmN0aW9uICggb2JqZWN0ICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggb2JqZWN0Lm1hdGVyaWFsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggQXJyYXkuaXNBcnJheSggb2JqZWN0Lm1hdGVyaWFsICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgb2JqZWN0Lm1hdGVyaWFsLmxlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpbml0TWF0ZXJpYWwoIG9iamVjdC5tYXRlcmlhbFsgaSBdLCBzY2VuZS5mb2csIG9iamVjdCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGluaXRNYXRlcmlhbCggb2JqZWN0Lm1hdGVyaWFsLCBzY2VuZS5mb2csIG9iamVjdCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fSApO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gQW5pbWF0aW9uIExvb3BcXG5cXG5cXHRcXHR2YXIgaXNBbmltYXRpbmcgPSBmYWxzZTtcXG5cXHRcXHR2YXIgb25BbmltYXRpb25GcmFtZSA9IG51bGw7XFxuXFxuXFx0XFx0ZnVuY3Rpb24gc3RhcnQoKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBpc0FuaW1hdGluZyApIHJldHVybjtcXG5cXG5cXHRcXHRcXHR2YXIgZGV2aWNlID0gdnIuZ2V0RGV2aWNlKCk7XFxuXFxuXFx0XFx0XFx0aWYgKCBkZXZpY2UgJiYgZGV2aWNlLmlzUHJlc2VudGluZyApIHtcXG5cXG5cXHRcXHRcXHRcXHRkZXZpY2UucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBsb29wICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBsb29wICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlzQW5pbWF0aW5nID0gdHJ1ZTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gbG9vcCggdGltZSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIG9uQW5pbWF0aW9uRnJhbWUgIT09IG51bGwgKSBvbkFuaW1hdGlvbkZyYW1lKCB0aW1lICk7XFxuXFxuXFx0XFx0XFx0dmFyIGRldmljZSA9IHZyLmdldERldmljZSgpO1xcblxcblxcdFxcdFxcdGlmICggZGV2aWNlICYmIGRldmljZS5pc1ByZXNlbnRpbmcgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZGV2aWNlLnJlcXVlc3RBbmltYXRpb25GcmFtZSggbG9vcCApO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggbG9vcCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5hbmltYXRlID0gZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcXG5cXG5cXHRcXHRcXHRvbkFuaW1hdGlvbkZyYW1lID0gY2FsbGJhY2s7XFxuXFx0XFx0XFx0c3RhcnQoKTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIFJlbmRlcmluZ1xcblxcblxcdFxcdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhLCByZW5kZXJUYXJnZXQsIGZvcmNlQ2xlYXIgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCAhICggY2FtZXJhICYmIGNhbWVyYS5pc0NhbWVyYSApICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlbmRlcjogY2FtZXJhIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5DYW1lcmEuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBfaXNDb250ZXh0TG9zdCApIHJldHVybjtcXG5cXG5cXHRcXHRcXHQvLyByZXNldCBjYWNoaW5nIGZvciB0aGlzIGZyYW1lXFxuXFxuXFx0XFx0XFx0X2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJztcXG5cXHRcXHRcXHRfY3VycmVudE1hdGVyaWFsSWQgPSAtIDE7XFxuXFx0XFx0XFx0X2N1cnJlbnRDYW1lcmEgPSBudWxsO1xcblxcblxcdFxcdFxcdC8vIHVwZGF0ZSBzY2VuZSBncmFwaFxcblxcblxcdFxcdFxcdGlmICggc2NlbmUuYXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHNjZW5lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XFxuXFxuXFx0XFx0XFx0Ly8gdXBkYXRlIGNhbWVyYSBtYXRyaWNlcyBhbmQgZnJ1c3R1bVxcblxcblxcdFxcdFxcdGlmICggY2FtZXJhLnBhcmVudCA9PT0gbnVsbCApIGNhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xcblxcblxcdFxcdFxcdGlmICggdnIuZW5hYmxlZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjYW1lcmEgPSB2ci5nZXRDYW1lcmEoIGNhbWVyYSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRfcHJvalNjcmVlbk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xcblxcdFxcdFxcdF9mcnVzdHVtLnNldEZyb21NYXRyaXgoIF9wcm9qU2NyZWVuTWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0bGlnaHRzQXJyYXkubGVuZ3RoID0gMDtcXG5cXHRcXHRcXHRzaGFkb3dzQXJyYXkubGVuZ3RoID0gMDtcXG5cXG5cXHRcXHRcXHRzcHJpdGVzQXJyYXkubGVuZ3RoID0gMDtcXG5cXHRcXHRcXHRmbGFyZXNBcnJheS5sZW5ndGggPSAwO1xcblxcblxcdFxcdFxcdF9sb2NhbENsaXBwaW5nRW5hYmxlZCA9IHRoaXMubG9jYWxDbGlwcGluZ0VuYWJsZWQ7XFxuXFx0XFx0XFx0X2NsaXBwaW5nRW5hYmxlZCA9IF9jbGlwcGluZy5pbml0KCB0aGlzLmNsaXBwaW5nUGxhbmVzLCBfbG9jYWxDbGlwcGluZ0VuYWJsZWQsIGNhbWVyYSApO1xcblxcblxcdFxcdFxcdGN1cnJlbnRSZW5kZXJMaXN0ID0gcmVuZGVyTGlzdHMuZ2V0KCBzY2VuZSwgY2FtZXJhICk7XFxuXFx0XFx0XFx0Y3VycmVudFJlbmRlckxpc3QuaW5pdCgpO1xcblxcblxcdFxcdFxcdHByb2plY3RPYmplY3QoIHNjZW5lLCBjYW1lcmEsIF90aGlzLnNvcnRPYmplY3RzICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBfdGhpcy5zb3J0T2JqZWN0cyA9PT0gdHJ1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjdXJyZW50UmVuZGVyTGlzdC5zb3J0KCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vXFxuXFxuXFx0XFx0XFx0dGV4dHVyZXMudXBkYXRlVmlkZW9UZXh0dXJlcygpO1xcblxcblxcdFxcdFxcdC8vXFxuXFxuXFx0XFx0XFx0aWYgKCBfY2xpcHBpbmdFbmFibGVkICkgX2NsaXBwaW5nLmJlZ2luU2hhZG93cygpO1xcblxcblxcdFxcdFxcdHNoYWRvd01hcC5yZW5kZXIoIHNoYWRvd3NBcnJheSwgc2NlbmUsIGNhbWVyYSApO1xcblxcblxcdFxcdFxcdGxpZ2h0cy5zZXR1cCggbGlnaHRzQXJyYXksIHNoYWRvd3NBcnJheSwgY2FtZXJhICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBfY2xpcHBpbmdFbmFibGVkICkgX2NsaXBwaW5nLmVuZFNoYWRvd3MoKTtcXG5cXG5cXHRcXHRcXHQvL1xcblxcblxcdFxcdFxcdF9pbmZvUmVuZGVyLmZyYW1lICsrO1xcblxcdFxcdFxcdF9pbmZvUmVuZGVyLmNhbGxzID0gMDtcXG5cXHRcXHRcXHRfaW5mb1JlbmRlci52ZXJ0aWNlcyA9IDA7XFxuXFx0XFx0XFx0X2luZm9SZW5kZXIuZmFjZXMgPSAwO1xcblxcdFxcdFxcdF9pbmZvUmVuZGVyLnBvaW50cyA9IDA7XFxuXFxuXFx0XFx0XFx0aWYgKCByZW5kZXJUYXJnZXQgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZW5kZXJUYXJnZXQgPSBudWxsO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XFxuXFxuXFx0XFx0XFx0Ly9cXG5cXG5cXHRcXHRcXHRiYWNrZ3JvdW5kLnJlbmRlciggY3VycmVudFJlbmRlckxpc3QsIHNjZW5lLCBjYW1lcmEsIGZvcmNlQ2xlYXIgKTtcXG5cXG5cXHRcXHRcXHQvLyByZW5kZXIgc2NlbmVcXG5cXG5cXHRcXHRcXHR2YXIgb3BhcXVlT2JqZWN0cyA9IGN1cnJlbnRSZW5kZXJMaXN0Lm9wYXF1ZTtcXG5cXHRcXHRcXHR2YXIgdHJhbnNwYXJlbnRPYmplY3RzID0gY3VycmVudFJlbmRlckxpc3QudHJhbnNwYXJlbnQ7XFxuXFxuXFx0XFx0XFx0aWYgKCBzY2VuZS5vdmVycmlkZU1hdGVyaWFsICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBvdmVycmlkZU1hdGVyaWFsID0gc2NlbmUub3ZlcnJpZGVNYXRlcmlhbDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG9wYXF1ZU9iamVjdHMubGVuZ3RoICkgcmVuZGVyT2JqZWN0cyggb3BhcXVlT2JqZWN0cywgc2NlbmUsIGNhbWVyYSwgb3ZlcnJpZGVNYXRlcmlhbCApO1xcblxcdFxcdFxcdFxcdGlmICggdHJhbnNwYXJlbnRPYmplY3RzLmxlbmd0aCApIHJlbmRlck9iamVjdHMoIHRyYW5zcGFyZW50T2JqZWN0cywgc2NlbmUsIGNhbWVyYSwgb3ZlcnJpZGVNYXRlcmlhbCApO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gb3BhcXVlIHBhc3MgKGZyb250LXRvLWJhY2sgb3JkZXIpXFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBvcGFxdWVPYmplY3RzLmxlbmd0aCApIHJlbmRlck9iamVjdHMoIG9wYXF1ZU9iamVjdHMsIHNjZW5lLCBjYW1lcmEgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyB0cmFuc3BhcmVudCBwYXNzIChiYWNrLXRvLWZyb250IG9yZGVyKVxcblxcblxcdFxcdFxcdFxcdGlmICggdHJhbnNwYXJlbnRPYmplY3RzLmxlbmd0aCApIHJlbmRlck9iamVjdHMoIHRyYW5zcGFyZW50T2JqZWN0cywgc2NlbmUsIGNhbWVyYSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBjdXN0b20gcmVuZGVyZXJzXFxuXFxuXFx0XFx0XFx0c3ByaXRlUmVuZGVyZXIucmVuZGVyKCBzcHJpdGVzQXJyYXksIHNjZW5lLCBjYW1lcmEgKTtcXG5cXHRcXHRcXHRmbGFyZVJlbmRlcmVyLnJlbmRlciggZmxhcmVzQXJyYXksIHNjZW5lLCBjYW1lcmEsIF9jdXJyZW50Vmlld3BvcnQgKTtcXG5cXG5cXHRcXHRcXHQvLyBHZW5lcmF0ZSBtaXBtYXAgaWYgd2UncmUgdXNpbmcgYW55IGtpbmQgb2YgbWlwbWFwIGZpbHRlcmluZ1xcblxcblxcdFxcdFxcdGlmICggcmVuZGVyVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdFxcdHRleHR1cmVzLnVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCggcmVuZGVyVGFyZ2V0ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEVuc3VyZSBkZXB0aCBidWZmZXIgd3JpdGluZyBpcyBlbmFibGVkIHNvIGl0IGNhbiBiZSBjbGVhcmVkIG9uIG5leHQgcmVuZGVyXFxuXFxuXFx0XFx0XFx0c3RhdGUuYnVmZmVycy5kZXB0aC5zZXRUZXN0KCB0cnVlICk7XFxuXFx0XFx0XFx0c3RhdGUuYnVmZmVycy5kZXB0aC5zZXRNYXNrKCB0cnVlICk7XFxuXFx0XFx0XFx0c3RhdGUuYnVmZmVycy5jb2xvci5zZXRNYXNrKCB0cnVlICk7XFxuXFxuXFx0XFx0XFx0c3RhdGUuc2V0UG9seWdvbk9mZnNldCggZmFsc2UgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIHZyLmVuYWJsZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dnIuc3VibWl0RnJhbWUoKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gX2dsLmZpbmlzaCgpO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0LypcXG5cXHRcXHQvLyBUT0RPIER1cGxpY2F0ZWQgY29kZSAoRnJ1c3R1bSlcXG5cXG5cXHRcXHR2YXIgX3NwaGVyZSA9IG5ldyBTcGhlcmUoKTtcXG5cXG5cXHRcXHRmdW5jdGlvbiBpc09iamVjdFZpZXdhYmxlKCBvYmplY3QgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xcblxcblxcdFxcdFxcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKVxcblxcdFxcdFxcdFxcdGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xcblxcblxcdFxcdFxcdF9zcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKS5cXG5cXHRcXHRcXHRhcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xcblxcblxcdFxcdFxcdHJldHVybiBpc1NwaGVyZVZpZXdhYmxlKCBfc3BoZXJlICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGlzU3ByaXRlVmlld2FibGUoIHNwcml0ZSApIHtcXG5cXG5cXHRcXHRcXHRfc3BoZXJlLmNlbnRlci5zZXQoIDAsIDAsIDAgKTtcXG5cXHRcXHRcXHRfc3BoZXJlLnJhZGl1cyA9IDAuNzA3MTA2NzgxMTg2NTQ3NjtcXG5cXHRcXHRcXHRfc3BoZXJlLmFwcGx5TWF0cml4NCggc3ByaXRlLm1hdHJpeFdvcmxkICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGlzU3BoZXJlVmlld2FibGUoIF9zcGhlcmUgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gaXNTcGhlcmVWaWV3YWJsZSggc3BoZXJlICkge1xcblxcblxcdFxcdFxcdGlmICggISBfZnJ1c3R1bS5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSApIHJldHVybiBmYWxzZTtcXG5cXG5cXHRcXHRcXHR2YXIgbnVtUGxhbmVzID0gX2NsaXBwaW5nLm51bVBsYW5lcztcXG5cXG5cXHRcXHRcXHRpZiAoIG51bVBsYW5lcyA9PT0gMCApIHJldHVybiB0cnVlO1xcblxcblxcdFxcdFxcdHZhciBwbGFuZXMgPSBfdGhpcy5jbGlwcGluZ1BsYW5lcyxcXG5cXG5cXHRcXHRcXHRcXHRjZW50ZXIgPSBzcGhlcmUuY2VudGVyLFxcblxcdFxcdFxcdFxcdG5lZ1JhZCA9IC0gc3BoZXJlLnJhZGl1cyxcXG5cXHRcXHRcXHRcXHRpID0gMDtcXG5cXG5cXHRcXHRcXHRkbyB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gb3V0IHdoZW4gZGVlcGVyIHRoYW4gcmFkaXVzIGluIHRoZSBuZWdhdGl2ZSBoYWxmc3BhY2VcXG5cXHRcXHRcXHRcXHRpZiAoIHBsYW5lc1sgaSBdLmRpc3RhbmNlVG9Qb2ludCggY2VudGVyICkgPCBuZWdSYWQgKSByZXR1cm4gZmFsc2U7XFxuXFxuXFx0XFx0XFx0fSB3aGlsZSAoICsrIGkgIT09IG51bVBsYW5lcyApO1xcblxcblxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcblxcdFxcdH1cXG5cXHRcXHQqL1xcblxcblxcdFxcdGZ1bmN0aW9uIHByb2plY3RPYmplY3QoIG9iamVjdCwgY2FtZXJhLCBzb3J0T2JqZWN0cyApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIG9iamVjdC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcXG5cXG5cXHRcXHRcXHR2YXIgdmlzaWJsZSA9IG9iamVjdC5sYXllcnMudGVzdCggY2FtZXJhLmxheWVycyApO1xcblxcblxcdFxcdFxcdGlmICggdmlzaWJsZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG9iamVjdC5pc0xpZ2h0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGxpZ2h0c0FycmF5LnB1c2goIG9iamVjdCApO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggb2JqZWN0LmNhc3RTaGFkb3cgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0c2hhZG93c0FycmF5LnB1c2goIG9iamVjdCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBvYmplY3QuaXNTcHJpdGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAhIG9iamVjdC5mcnVzdHVtQ3VsbGVkIHx8IF9mcnVzdHVtLmludGVyc2VjdHNTcHJpdGUoIG9iamVjdCApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHNwcml0ZXNBcnJheS5wdXNoKCBvYmplY3QgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggb2JqZWN0LmlzTGVuc0ZsYXJlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGZsYXJlc0FycmF5LnB1c2goIG9iamVjdCApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIG9iamVjdC5pc0ltbWVkaWF0ZVJlbmRlck9iamVjdCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHNvcnRPYmplY3RzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggb2JqZWN0Lm1hdHJpeFdvcmxkIClcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQuYXBwbHlNYXRyaXg0KCBfcHJvalNjcmVlbk1hdHJpeCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRjdXJyZW50UmVuZGVyTGlzdC5wdXNoKCBvYmplY3QsIG51bGwsIG9iamVjdC5tYXRlcmlhbCwgX3ZlY3RvcjMueiwgbnVsbCApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIG9iamVjdC5pc01lc2ggfHwgb2JqZWN0LmlzTGluZSB8fCBvYmplY3QuaXNQb2ludHMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBvYmplY3QuaXNTa2lubmVkTWVzaCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRvYmplY3Quc2tlbGV0b24udXBkYXRlKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGlmICggISBvYmplY3QuZnJ1c3R1bUN1bGxlZCB8fCBfZnJ1c3R1bS5pbnRlcnNlY3RzT2JqZWN0KCBvYmplY3QgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHNvcnRPYmplY3RzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggb2JqZWN0Lm1hdHJpeFdvcmxkIClcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQuYXBwbHlNYXRyaXg0KCBfcHJvalNjcmVlbk1hdHJpeCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgZ2VvbWV0cnkgPSBvYmplY3RzLnVwZGF0ZSggb2JqZWN0ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggQXJyYXkuaXNBcnJheSggbWF0ZXJpYWwgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGdyb3Vwcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBncm91cCA9IGdyb3Vwc1sgaSBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBncm91cE1hdGVyaWFsID0gbWF0ZXJpYWxbIGdyb3VwLm1hdGVyaWFsSW5kZXggXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGdyb3VwTWF0ZXJpYWwgJiYgZ3JvdXBNYXRlcmlhbC52aXNpYmxlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGN1cnJlbnRSZW5kZXJMaXN0LnB1c2goIG9iamVjdCwgZ2VvbWV0cnksIGdyb3VwTWF0ZXJpYWwsIF92ZWN0b3IzLnosIGdyb3VwICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXRlcmlhbC52aXNpYmxlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGN1cnJlbnRSZW5kZXJMaXN0LnB1c2goIG9iamVjdCwgZ2VvbWV0cnksIG1hdGVyaWFsLCBfdmVjdG9yMy56LCBudWxsICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHByb2plY3RPYmplY3QoIGNoaWxkcmVuWyBpIF0sIGNhbWVyYSwgc29ydE9iamVjdHMgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHJlbmRlck9iamVjdHMoIHJlbmRlckxpc3QsIHNjZW5lLCBjYW1lcmEsIG92ZXJyaWRlTWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcmVuZGVyTGlzdC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciByZW5kZXJJdGVtID0gcmVuZGVyTGlzdFsgaSBdO1xcblxcblxcdFxcdFxcdFxcdHZhciBvYmplY3QgPSByZW5kZXJJdGVtLm9iamVjdDtcXG5cXHRcXHRcXHRcXHR2YXIgZ2VvbWV0cnkgPSByZW5kZXJJdGVtLmdlb21ldHJ5O1xcblxcdFxcdFxcdFxcdHZhciBtYXRlcmlhbCA9IG92ZXJyaWRlTWF0ZXJpYWwgPT09IHVuZGVmaW5lZCA/IHJlbmRlckl0ZW0ubWF0ZXJpYWwgOiBvdmVycmlkZU1hdGVyaWFsO1xcblxcdFxcdFxcdFxcdHZhciBncm91cCA9IHJlbmRlckl0ZW0uZ3JvdXA7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBjYW1lcmEuaXNBcnJheUNhbWVyYSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRfY3VycmVudEFycmF5Q2FtZXJhID0gY2FtZXJhO1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBjYW1lcmFzID0gY2FtZXJhLmNhbWVyYXM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGNhbWVyYXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGNhbWVyYTIgPSBjYW1lcmFzWyBqIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBvYmplY3QubGF5ZXJzLnRlc3QoIGNhbWVyYTIubGF5ZXJzICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGJvdW5kcyA9IGNhbWVyYTIuYm91bmRzO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciB4ID0gYm91bmRzLnggKiBfd2lkdGg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIHkgPSBib3VuZHMueSAqIF9oZWlnaHQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIHdpZHRoID0gYm91bmRzLnogKiBfd2lkdGg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGhlaWdodCA9IGJvdW5kcy53ICogX2hlaWdodDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzdGF0ZS52aWV3cG9ydCggX2N1cnJlbnRWaWV3cG9ydC5zZXQoIHgsIHksIHdpZHRoLCBoZWlnaHQgKS5tdWx0aXBseVNjYWxhciggX3BpeGVsUmF0aW8gKSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlbmRlck9iamVjdCggb2JqZWN0LCBzY2VuZSwgY2FtZXJhMiwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRfY3VycmVudEFycmF5Q2FtZXJhID0gbnVsbDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZW5kZXJPYmplY3QoIG9iamVjdCwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHJlbmRlck9iamVjdCggb2JqZWN0LCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwICkge1xcblxcblxcdFxcdFxcdG9iamVjdC5vbkJlZm9yZVJlbmRlciggX3RoaXMsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXAgKTtcXG5cXG5cXHRcXHRcXHRvYmplY3QubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIG9iamVjdC5tYXRyaXhXb3JsZCApO1xcblxcdFxcdFxcdG9iamVjdC5ub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCBvYmplY3QubW9kZWxWaWV3TWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBvYmplY3QuaXNJbW1lZGlhdGVSZW5kZXJPYmplY3QgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGZyb250RmFjZUNXID0gKCBvYmplY3QuaXNNZXNoICYmIG9iamVjdC5tYXRyaXhXb3JsZC5kZXRlcm1pbmFudCgpIDwgMCApO1xcblxcblxcdFxcdFxcdFxcdHN0YXRlLnNldE1hdGVyaWFsKCBtYXRlcmlhbCwgZnJvbnRGYWNlQ1cgKTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcHJvZ3JhbSA9IHNldFByb2dyYW0oIGNhbWVyYSwgc2NlbmUuZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICk7XFxuXFxuXFx0XFx0XFx0XFx0X2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJztcXG5cXG5cXHRcXHRcXHRcXHRyZW5kZXJPYmplY3RJbW1lZGlhdGUoIG9iamVjdCwgcHJvZ3JhbSwgbWF0ZXJpYWwgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdF90aGlzLnJlbmRlckJ1ZmZlckRpcmVjdCggY2FtZXJhLCBzY2VuZS5mb2csIGdlb21ldHJ5LCBtYXRlcmlhbCwgb2JqZWN0LCBncm91cCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRvYmplY3Qub25BZnRlclJlbmRlciggX3RoaXMsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXAgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gaW5pdE1hdGVyaWFsKCBtYXRlcmlhbCwgZm9nLCBvYmplY3QgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIG1hdGVyaWFsUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCBtYXRlcmlhbCApO1xcblxcblxcdFxcdFxcdHZhciBwYXJhbWV0ZXJzID0gcHJvZ3JhbUNhY2hlLmdldFBhcmFtZXRlcnMoXFxuXFx0XFx0XFx0XFx0bWF0ZXJpYWwsIGxpZ2h0cy5zdGF0ZSwgc2hhZG93c0FycmF5LCBmb2csIF9jbGlwcGluZy5udW1QbGFuZXMsIF9jbGlwcGluZy5udW1JbnRlcnNlY3Rpb24sIG9iamVjdCApO1xcblxcblxcdFxcdFxcdHZhciBjb2RlID0gcHJvZ3JhbUNhY2hlLmdldFByb2dyYW1Db2RlKCBtYXRlcmlhbCwgcGFyYW1ldGVycyApO1xcblxcblxcdFxcdFxcdHZhciBwcm9ncmFtID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW07XFxuXFx0XFx0XFx0dmFyIHByb2dyYW1DaGFuZ2UgPSB0cnVlO1xcblxcblxcdFxcdFxcdGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdC8vIG5ldyBtYXRlcmlhbFxcblxcdFxcdFxcdFxcdG1hdGVyaWFsLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25NYXRlcmlhbERpc3Bvc2UgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBwcm9ncmFtLmNvZGUgIT09IGNvZGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gY2hhbmdlZCBnbHNsIG9yIHBhcmFtZXRlcnNcXG5cXHRcXHRcXHRcXHRyZWxlYXNlTWF0ZXJpYWxQcm9ncmFtUmVmZXJlbmNlKCBtYXRlcmlhbCApO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIHBhcmFtZXRlcnMuc2hhZGVySUQgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBzYW1lIGdsc2wgYW5kIHVuaWZvcm0gbGlzdFxcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdC8vIG9ubHkgcmVidWlsZCB1bmlmb3JtIGxpc3RcXG5cXHRcXHRcXHRcXHRwcm9ncmFtQ2hhbmdlID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggcHJvZ3JhbUNoYW5nZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHBhcmFtZXRlcnMuc2hhZGVySUQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHNoYWRlciA9IFNoYWRlckxpYlsgcGFyYW1ldGVycy5zaGFkZXJJRCBdO1xcblxcblxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsUHJvcGVydGllcy5zaGFkZXIgPSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bmFtZTogbWF0ZXJpYWwudHlwZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHR1bmlmb3JtczogVW5pZm9ybXNVdGlscy5jbG9uZSggc2hhZGVyLnVuaWZvcm1zICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmVydGV4U2hhZGVyOiBzaGFkZXIudmVydGV4U2hhZGVyLFxcblxcdFxcdFxcdFxcdFxcdFxcdGZyYWdtZW50U2hhZGVyOiBzaGFkZXIuZnJhZ21lbnRTaGFkZXJcXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLnNoYWRlciA9IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRuYW1lOiBtYXRlcmlhbC50eXBlLFxcblxcdFxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zOiBtYXRlcmlhbC51bmlmb3JtcyxcXG5cXHRcXHRcXHRcXHRcXHRcXHR2ZXJ0ZXhTaGFkZXI6IG1hdGVyaWFsLnZlcnRleFNoYWRlcixcXG5cXHRcXHRcXHRcXHRcXHRcXHRmcmFnbWVudFNoYWRlcjogbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXJcXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRtYXRlcmlhbC5vbkJlZm9yZUNvbXBpbGUoIG1hdGVyaWFsUHJvcGVydGllcy5zaGFkZXIgKTtcXG5cXG5cXHRcXHRcXHRcXHRwcm9ncmFtID0gcHJvZ3JhbUNhY2hlLmFjcXVpcmVQcm9ncmFtKCBtYXRlcmlhbCwgbWF0ZXJpYWxQcm9wZXJ0aWVzLnNoYWRlciwgcGFyYW1ldGVycywgY29kZSApO1xcblxcblxcdFxcdFxcdFxcdG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtID0gcHJvZ3JhbTtcXG5cXHRcXHRcXHRcXHRtYXRlcmlhbC5wcm9ncmFtID0gcHJvZ3JhbTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIHByb2dyYW1BdHRyaWJ1dGVzID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGVzKCk7XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5tb3JwaFRhcmdldHMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzID0gMDtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBfdGhpcy5tYXhNb3JwaFRhcmdldHM7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBwcm9ncmFtQXR0cmlidXRlc1sgJ21vcnBoVGFyZ2V0JyArIGkgXSA+PSAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoVGFyZ2V0cyArKztcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLm1vcnBoTm9ybWFscyApIHtcXG5cXG5cXHRcXHRcXHRcXHRtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaE5vcm1hbHMgPSAwO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IF90aGlzLm1heE1vcnBoTm9ybWFsczsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHByb2dyYW1BdHRyaWJ1dGVzWyAnbW9ycGhOb3JtYWwnICsgaSBdID49IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhOb3JtYWxzICsrO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciB1bmlmb3JtcyA9IG1hdGVyaWFsUHJvcGVydGllcy5zaGFkZXIudW5pZm9ybXM7XFxuXFxuXFx0XFx0XFx0aWYgKCAhIG1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgJiZcXG5cXHRcXHRcXHRcXHQhIG1hdGVyaWFsLmlzUmF3U2hhZGVyTWF0ZXJpYWwgfHxcXG5cXHRcXHRcXHRcXHRtYXRlcmlhbC5jbGlwcGluZyA9PT0gdHJ1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRtYXRlcmlhbFByb3BlcnRpZXMubnVtQ2xpcHBpbmdQbGFuZXMgPSBfY2xpcHBpbmcubnVtUGxhbmVzO1xcblxcdFxcdFxcdFxcdG1hdGVyaWFsUHJvcGVydGllcy5udW1JbnRlcnNlY3Rpb24gPSBfY2xpcHBpbmcubnVtSW50ZXJzZWN0aW9uO1xcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmNsaXBwaW5nUGxhbmVzID0gX2NsaXBwaW5nLnVuaWZvcm07XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdG1hdGVyaWFsUHJvcGVydGllcy5mb2cgPSBmb2c7XFxuXFxuXFx0XFx0XFx0Ly8gc3RvcmUgdGhlIGxpZ2h0IHNldHVwIGl0IHdhcyBjcmVhdGVkIGZvclxcblxcblxcdFxcdFxcdG1hdGVyaWFsUHJvcGVydGllcy5saWdodHNIYXNoID0gbGlnaHRzLnN0YXRlLmhhc2g7XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5saWdodHMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gd2lyZSB1cCB0aGUgbWF0ZXJpYWwgdG8gdGhpcyByZW5kZXJlcidzIGxpZ2h0aW5nIHN0YXRlXFxuXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuYW1iaWVudExpZ2h0Q29sb3IudmFsdWUgPSBsaWdodHMuc3RhdGUuYW1iaWVudDtcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaXJlY3Rpb25hbExpZ2h0cy52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5kaXJlY3Rpb25hbDtcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5zcG90TGlnaHRzLnZhbHVlID0gbGlnaHRzLnN0YXRlLnNwb3Q7XFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMucmVjdEFyZWFMaWdodHMudmFsdWUgPSBsaWdodHMuc3RhdGUucmVjdEFyZWE7XFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMucG9pbnRMaWdodHMudmFsdWUgPSBsaWdodHMuc3RhdGUucG9pbnQ7XFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0cy52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5oZW1pO1xcblxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpcmVjdGlvbmFsU2hhZG93TWFwLnZhbHVlID0gbGlnaHRzLnN0YXRlLmRpcmVjdGlvbmFsU2hhZG93TWFwO1xcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4LnZhbHVlID0gbGlnaHRzLnN0YXRlLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4O1xcblxcdFxcdFxcdFxcdHVuaWZvcm1zLnNwb3RTaGFkb3dNYXAudmFsdWUgPSBsaWdodHMuc3RhdGUuc3BvdFNoYWRvd01hcDtcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5zcG90U2hhZG93TWF0cml4LnZhbHVlID0gbGlnaHRzLnN0YXRlLnNwb3RTaGFkb3dNYXRyaXg7XFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMucG9pbnRTaGFkb3dNYXAudmFsdWUgPSBsaWdodHMuc3RhdGUucG9pbnRTaGFkb3dNYXA7XFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMucG9pbnRTaGFkb3dNYXRyaXgudmFsdWUgPSBsaWdodHMuc3RhdGUucG9pbnRTaGFkb3dNYXRyaXg7XFxuXFx0XFx0XFx0XFx0Ly8gVE9ETyAoYWJlbG5hdGlvbik6IGFkZCBhcmVhIGxpZ2h0cyBzaGFkb3cgaW5mbyB0byB1bmlmb3Jtc1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgcHJvZ1VuaWZvcm1zID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW0uZ2V0VW5pZm9ybXMoKSxcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtc0xpc3QgPVxcblxcdFxcdFxcdFxcdFxcdFdlYkdMVW5pZm9ybXMuc2VxV2l0aFZhbHVlKCBwcm9nVW5pZm9ybXMuc2VxLCB1bmlmb3JtcyApO1xcblxcblxcdFxcdFxcdG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3QgPSB1bmlmb3Jtc0xpc3Q7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHNldFByb2dyYW0oIGNhbWVyYSwgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICkge1xcblxcblxcdFxcdFxcdF91c2VkVGV4dHVyZVVuaXRzID0gMDtcXG5cXG5cXHRcXHRcXHR2YXIgbWF0ZXJpYWxQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIG1hdGVyaWFsICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBfY2xpcHBpbmdFbmFibGVkICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggX2xvY2FsQ2xpcHBpbmdFbmFibGVkIHx8IGNhbWVyYSAhPT0gX2N1cnJlbnRDYW1lcmEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHVzZUNhY2hlID1cXG5cXHRcXHRcXHRcXHRcXHRcXHRjYW1lcmEgPT09IF9jdXJyZW50Q2FtZXJhICYmXFxuXFx0XFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWwuaWQgPT09IF9jdXJyZW50TWF0ZXJpYWxJZDtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyB3ZSBtaWdodCB3YW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiB3aXRoIHNvbWUgQ2xpcHBpbmdHcm91cFxcblxcdFxcdFxcdFxcdFxcdC8vIG9iamVjdCBpbnN0ZWFkIG9mIHRoZSBtYXRlcmlhbCwgb25jZSBpdCBiZWNvbWVzIGZlYXNpYmxlXFxuXFx0XFx0XFx0XFx0XFx0Ly8gKCM4NDY1LCAjODM3OSlcXG5cXHRcXHRcXHRcXHRcXHRfY2xpcHBpbmcuc2V0U3RhdGUoXFxuXFx0XFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWwuY2xpcHBpbmdQbGFuZXMsIG1hdGVyaWFsLmNsaXBJbnRlcnNlY3Rpb24sIG1hdGVyaWFsLmNsaXBTaGFkb3dzLFxcblxcdFxcdFxcdFxcdFxcdFxcdGNhbWVyYSwgbWF0ZXJpYWxQcm9wZXJ0aWVzLCB1c2VDYWNoZSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9PT0gZmFsc2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5mb2cgJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLmZvZyAhPT0gZm9nICkge1xcblxcblxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5saWdodHMgJiYgbWF0ZXJpYWxQcm9wZXJ0aWVzLmxpZ2h0c0hhc2ggIT09IGxpZ2h0cy5zdGF0ZS5oYXNoICkge1xcblxcblxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXRlcmlhbFByb3BlcnRpZXMubnVtQ2xpcHBpbmdQbGFuZXMgIT09IHVuZGVmaW5lZCAmJlxcblxcdFxcdFxcdFxcdFxcdCggbWF0ZXJpYWxQcm9wZXJ0aWVzLm51bUNsaXBwaW5nUGxhbmVzICE9PSBfY2xpcHBpbmcubnVtUGxhbmVzIHx8XFxuXFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLm51bUludGVyc2VjdGlvbiAhPT0gX2NsaXBwaW5nLm51bUludGVyc2VjdGlvbiApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwubmVlZHNVcGRhdGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aW5pdE1hdGVyaWFsKCBtYXRlcmlhbCwgZm9nLCBvYmplY3QgKTtcXG5cXHRcXHRcXHRcXHRtYXRlcmlhbC5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgcmVmcmVzaFByb2dyYW0gPSBmYWxzZTtcXG5cXHRcXHRcXHR2YXIgcmVmcmVzaE1hdGVyaWFsID0gZmFsc2U7XFxuXFx0XFx0XFx0dmFyIHJlZnJlc2hMaWdodHMgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHR2YXIgcHJvZ3JhbSA9IG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtLFxcblxcdFxcdFxcdFxcdHBfdW5pZm9ybXMgPSBwcm9ncmFtLmdldFVuaWZvcm1zKCksXFxuXFx0XFx0XFx0XFx0bV91bmlmb3JtcyA9IG1hdGVyaWFsUHJvcGVydGllcy5zaGFkZXIudW5pZm9ybXM7XFxuXFxuXFx0XFx0XFx0aWYgKCBzdGF0ZS51c2VQcm9ncmFtKCBwcm9ncmFtLnByb2dyYW0gKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZWZyZXNoUHJvZ3JhbSA9IHRydWU7XFxuXFx0XFx0XFx0XFx0cmVmcmVzaE1hdGVyaWFsID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRyZWZyZXNoTGlnaHRzID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5pZCAhPT0gX2N1cnJlbnRNYXRlcmlhbElkICkge1xcblxcblxcdFxcdFxcdFxcdF9jdXJyZW50TWF0ZXJpYWxJZCA9IG1hdGVyaWFsLmlkO1xcblxcblxcdFxcdFxcdFxcdHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggcmVmcmVzaFByb2dyYW0gfHwgY2FtZXJhICE9PSBfY3VycmVudENhbWVyYSApIHtcXG5cXG5cXHRcXHRcXHRcXHRwX3VuaWZvcm1zLnNldFZhbHVlKCBfZ2wsICdwcm9qZWN0aW9uTWF0cml4JywgY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGNhcGFiaWxpdGllcy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ2xvZ0RlcHRoQnVmRkMnLFxcblxcdFxcdFxcdFxcdFxcdFxcdDIuMCAvICggTWF0aC5sb2coIGNhbWVyYS5mYXIgKyAxLjAgKSAvIE1hdGguTE4yICkgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQXZvaWQgdW5uZWVkZWQgdW5pZm9ybSB1cGRhdGVzIHBlciBBcnJheUNhbWVyYSdzIHN1Yi1jYW1lcmFcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIF9jdXJyZW50Q2FtZXJhICE9PSAoIF9jdXJyZW50QXJyYXlDYW1lcmEgfHwgY2FtZXJhICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0X2N1cnJlbnRDYW1lcmEgPSAoIF9jdXJyZW50QXJyYXlDYW1lcmEgfHwgY2FtZXJhICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gbGlnaHRpbmcgdW5pZm9ybXMgZGVwZW5kIG9uIHRoZSBjYW1lcmEgc28gZW5mb3JjZSBhbiB1cGRhdGVcXG5cXHRcXHRcXHRcXHRcXHQvLyBub3csIGluIGNhc2UgdGhpcyBtYXRlcmlhbCBzdXBwb3J0cyBsaWdodHMgLSBvciBsYXRlciwgd2hlblxcblxcdFxcdFxcdFxcdFxcdC8vIHRoZSBuZXh0IG1hdGVyaWFsIHRoYXQgZG9lcyBnZXRzIGFjdGl2YXRlZDpcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZWZyZXNoTWF0ZXJpYWwgPSB0cnVlO1xcdFxcdC8vIHNldCB0byB0cnVlIG9uIG1hdGVyaWFsIGNoYW5nZVxcblxcdFxcdFxcdFxcdFxcdHJlZnJlc2hMaWdodHMgPSB0cnVlO1xcdFxcdC8vIHJlbWFpbnMgc2V0IHVudGlsIHVwZGF0ZSBkb25lXFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIGxvYWQgbWF0ZXJpYWwgc3BlY2lmaWMgdW5pZm9ybXNcXG5cXHRcXHRcXHRcXHQvLyAoc2hhZGVyIG1hdGVyaWFsIGFsc28gZ2V0cyB0aGVtIGZvciB0aGUgc2FrZSBvZiBnZW5lcmljaXR5KVxcblxcblxcdFxcdFxcdFxcdGlmICggbWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCB8fFxcblxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsLmlzTWVzaFBob25nTWF0ZXJpYWwgfHxcXG5cXHRcXHRcXHRcXHRcXHRtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsIHx8XFxuXFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWwuZW52TWFwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciB1Q2FtUG9zID0gcF91bmlmb3Jtcy5tYXAuY2FtZXJhUG9zaXRpb247XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB1Q2FtUG9zICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dUNhbVBvcy5zZXRWYWx1ZSggX2dsLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggbWF0ZXJpYWwuaXNNZXNoUGhvbmdNYXRlcmlhbCB8fFxcblxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsLmlzTWVzaExhbWJlcnRNYXRlcmlhbCB8fFxcblxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsLmlzTWVzaEJhc2ljTWF0ZXJpYWwgfHxcXG5cXHRcXHRcXHRcXHRcXHRtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsIHx8XFxuXFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCB8fFxcblxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsLnNraW5uaW5nICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ3ZpZXdNYXRyaXgnLCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBza2lubmluZyB1bmlmb3JtcyBtdXN0IGJlIHNldCBldmVuIGlmIG1hdGVyaWFsIGRpZG4ndCBjaGFuZ2VcXG5cXHRcXHRcXHQvLyBhdXRvLXNldHRpbmcgb2YgdGV4dHVyZSB1bml0IGZvciBib25lIHRleHR1cmUgbXVzdCBnbyBiZWZvcmUgb3RoZXIgdGV4dHVyZXNcXG5cXHRcXHRcXHQvLyBub3Qgc3VyZSB3aHksIGJ1dCBvdGhlcndpc2Ugd2VpcmQgdGhpbmdzIGhhcHBlblxcblxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwuc2tpbm5pbmcgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cF91bmlmb3Jtcy5zZXRPcHRpb25hbCggX2dsLCBvYmplY3QsICdiaW5kTWF0cml4JyApO1xcblxcdFxcdFxcdFxcdHBfdW5pZm9ybXMuc2V0T3B0aW9uYWwoIF9nbCwgb2JqZWN0LCAnYmluZE1hdHJpeEludmVyc2UnICk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHNrZWxldG9uID0gb2JqZWN0LnNrZWxldG9uO1xcblxcblxcdFxcdFxcdFxcdGlmICggc2tlbGV0b24gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGJvbmVzID0gc2tlbGV0b24uYm9uZXM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBjYXBhYmlsaXRpZXMuZmxvYXRWZXJ0ZXhUZXh0dXJlcyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHNrZWxldG9uLmJvbmVUZXh0dXJlID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gbGF5b3V0ICgxIG1hdHJpeCA9IDQgcGl4ZWxzKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vICAgICAgUkdCQSBSR0JBIFJHQkEgUkdCQSAoPT4gY29sdW1uMSwgY29sdW1uMiwgY29sdW1uMywgY29sdW1uNClcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyAgd2l0aCAgOHg4ICBwaXhlbCB0ZXh0dXJlIG1heCAgIDE2IGJvbmVzICogNCBwaXhlbHMgPSAgKDggKiA4KVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vICAgICAgIDE2eDE2IHBpeGVsIHRleHR1cmUgbWF4ICAgNjQgYm9uZXMgKiA0IHBpeGVscyA9ICgxNiAqIDE2KVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vICAgICAgIDMyeDMyIHBpeGVsIHRleHR1cmUgbWF4ICAyNTYgYm9uZXMgKiA0IHBpeGVscyA9ICgzMiAqIDMyKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vICAgICAgIDY0eDY0IHBpeGVsIHRleHR1cmUgbWF4IDEwMjQgYm9uZXMgKiA0IHBpeGVscyA9ICg2NCAqIDY0KVxcblxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBzaXplID0gTWF0aC5zcXJ0KCBib25lcy5sZW5ndGggKiA0ICk7IC8vIDQgcGl4ZWxzIG5lZWRlZCBmb3IgMSBtYXRyaXhcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzaXplID0gX01hdGguY2VpbFBvd2VyT2ZUd28oIHNpemUgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzaXplID0gTWF0aC5tYXgoIHNpemUsIDQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgYm9uZU1hdHJpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggc2l6ZSAqIHNpemUgKiA0ICk7IC8vIDQgZmxvYXRzIHBlciBSR0JBIHBpeGVsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ym9uZU1hdHJpY2VzLnNldCggc2tlbGV0b24uYm9uZU1hdHJpY2VzICk7IC8vIGNvcHkgY3VycmVudCB2YWx1ZXNcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgYm9uZVRleHR1cmUgPSBuZXcgRGF0YVRleHR1cmUoIGJvbmVNYXRyaWNlcywgc2l6ZSwgc2l6ZSwgUkdCQUZvcm1hdCwgRmxvYXRUeXBlICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2tlbGV0b24uYm9uZU1hdHJpY2VzID0gYm9uZU1hdHJpY2VzO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNrZWxldG9uLmJvbmVUZXh0dXJlID0gYm9uZVRleHR1cmU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2tlbGV0b24uYm9uZVRleHR1cmVTaXplID0gc2l6ZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAnYm9uZVRleHR1cmUnLCBza2VsZXRvbi5ib25lVGV4dHVyZSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ2JvbmVUZXh0dXJlU2l6ZScsIHNrZWxldG9uLmJvbmVUZXh0dXJlU2l6ZSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cF91bmlmb3Jtcy5zZXRPcHRpb25hbCggX2dsLCBza2VsZXRvbiwgJ2JvbmVNYXRyaWNlcycgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHJlZnJlc2hNYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRwX3VuaWZvcm1zLnNldFZhbHVlKCBfZ2wsICd0b25lTWFwcGluZ0V4cG9zdXJlJywgX3RoaXMudG9uZU1hcHBpbmdFeHBvc3VyZSApO1xcblxcdFxcdFxcdFxcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ3RvbmVNYXBwaW5nV2hpdGVQb2ludCcsIF90aGlzLnRvbmVNYXBwaW5nV2hpdGVQb2ludCApO1xcblxcblxcdFxcdFxcdFxcdGlmICggbWF0ZXJpYWwubGlnaHRzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIHRoZSBjdXJyZW50IG1hdGVyaWFsIHJlcXVpcmVzIGxpZ2h0aW5nIGluZm9cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBub3RlOiBhbGwgbGlnaHRpbmcgdW5pZm9ybXMgYXJlIGFsd2F5cyBzZXQgY29ycmVjdGx5XFxuXFx0XFx0XFx0XFx0XFx0Ly8gdGhleSBzaW1wbHkgcmVmZXJlbmNlIHRoZSByZW5kZXJlcidzIHN0YXRlIGZvciB0aGVpclxcblxcdFxcdFxcdFxcdFxcdC8vIHZhbHVlc1xcblxcdFxcdFxcdFxcdFxcdC8vXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdXNlIHRoZSBjdXJyZW50IG1hdGVyaWFsJ3MgLm5lZWRzVXBkYXRlIGZsYWdzIHRvIHNldFxcblxcdFxcdFxcdFxcdFxcdC8vIHRoZSBHTCBzdGF0ZSB3aGVuIHJlcXVpcmVkXFxuXFxuXFx0XFx0XFx0XFx0XFx0bWFya1VuaWZvcm1zTGlnaHRzTmVlZHNVcGRhdGUoIG1fdW5pZm9ybXMsIHJlZnJlc2hMaWdodHMgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gcmVmcmVzaCB1bmlmb3JtcyBjb21tb24gdG8gc2V2ZXJhbCBtYXRlcmlhbHNcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGZvZyAmJiBtYXRlcmlhbC5mb2cgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmVmcmVzaFVuaWZvcm1zRm9nKCBtX3VuaWZvcm1zLCBmb2cgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5pc01lc2hCYXNpY01hdGVyaWFsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc01lc2hMYW1iZXJ0TWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xcblxcdFxcdFxcdFxcdFxcdHJlZnJlc2hVbmlmb3Jtc0xhbWJlcnQoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNNZXNoUGhvbmdNYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZWZyZXNoVW5pZm9ybXNDb21tb24oIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5pc01lc2hUb29uTWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmVmcmVzaFVuaWZvcm1zVG9vbiggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHJlZnJlc2hVbmlmb3Jtc1Bob25nKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc01lc2hTdGFuZGFyZE1hdGVyaWFsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG1hdGVyaWFsLmlzTWVzaFBoeXNpY2FsTWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmVmcmVzaFVuaWZvcm1zUGh5c2ljYWwoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRyZWZyZXNoVW5pZm9ybXNTdGFuZGFyZCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNNZXNoRGVwdGhNYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZWZyZXNoVW5pZm9ybXNDb21tb24oIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XFxuXFx0XFx0XFx0XFx0XFx0cmVmcmVzaFVuaWZvcm1zRGVwdGgoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNNZXNoRGlzdGFuY2VNYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZWZyZXNoVW5pZm9ybXNDb21tb24oIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XFxuXFx0XFx0XFx0XFx0XFx0cmVmcmVzaFVuaWZvcm1zRGlzdGFuY2UoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuaXNNZXNoTm9ybWFsTWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xcblxcdFxcdFxcdFxcdFxcdHJlZnJlc2hVbmlmb3Jtc05vcm1hbCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc0xpbmVCYXNpY01hdGVyaWFsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJlZnJlc2hVbmlmb3Jtc0xpbmUoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5pc0xpbmVEYXNoZWRNYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRyZWZyZXNoVW5pZm9ybXNEYXNoKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc1BvaW50c01hdGVyaWFsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJlZnJlc2hVbmlmb3Jtc1BvaW50cyggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc1NoYWRvd01hdGVyaWFsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdG1fdW5pZm9ybXMuY29sb3IudmFsdWUgPSBtYXRlcmlhbC5jb2xvcjtcXG5cXHRcXHRcXHRcXHRcXHRtX3VuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBSZWN0QXJlYUxpZ2h0IFRleHR1cmVcXG5cXHRcXHRcXHRcXHQvLyBUT0RPIChtcmRvb2IpOiBGaW5kIGEgbmljZXIgaW1wbGVtZW50YXRpb25cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG1fdW5pZm9ybXMubHRjTWF0ICE9PSB1bmRlZmluZWQgKSBtX3VuaWZvcm1zLmx0Y01hdC52YWx1ZSA9IFVuaWZvcm1zTGliLkxUQ19NQVRfVEVYVFVSRTtcXG5cXHRcXHRcXHRcXHRpZiAoIG1fdW5pZm9ybXMubHRjTWFnICE9PSB1bmRlZmluZWQgKSBtX3VuaWZvcm1zLmx0Y01hZy52YWx1ZSA9IFVuaWZvcm1zTGliLkxUQ19NQUdfVEVYVFVSRTtcXG5cXG5cXHRcXHRcXHRcXHRXZWJHTFVuaWZvcm1zLnVwbG9hZChcXG5cXHRcXHRcXHRcXHRcXHRfZ2wsIG1hdGVyaWFsUHJvcGVydGllcy51bmlmb3Jtc0xpc3QsIG1fdW5pZm9ybXMsIF90aGlzICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcblxcdFxcdFxcdC8vIGNvbW1vbiBtYXRyaWNlc1xcblxcblxcdFxcdFxcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ21vZGVsVmlld01hdHJpeCcsIG9iamVjdC5tb2RlbFZpZXdNYXRyaXggKTtcXG5cXHRcXHRcXHRwX3VuaWZvcm1zLnNldFZhbHVlKCBfZ2wsICdub3JtYWxNYXRyaXgnLCBvYmplY3Qubm9ybWFsTWF0cml4ICk7XFxuXFx0XFx0XFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAnbW9kZWxNYXRyaXgnLCBvYmplY3QubWF0cml4V29ybGQgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gcHJvZ3JhbTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gVW5pZm9ybXMgKHJlZnJlc2ggdW5pZm9ybXMgb2JqZWN0cylcXG5cXG5cXHRcXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNDb21tb24oIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRcXHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLmNvbG9yICkge1xcblxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUgPSBtYXRlcmlhbC5jb2xvcjtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5lbWlzc2l2ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5lbWlzc2l2ZS52YWx1ZS5jb3B5KCBtYXRlcmlhbC5lbWlzc2l2ZSApLm11bHRpcGx5U2NhbGFyKCBtYXRlcmlhbC5lbWlzc2l2ZUludGVuc2l0eSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLm1hcCApIHtcXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5tYXAudmFsdWUgPSBtYXRlcmlhbC5tYXA7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwuYWxwaGFNYXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuYWxwaGFNYXAudmFsdWUgPSBtYXRlcmlhbC5hbHBoYU1hcDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5zcGVjdWxhck1hcCApIHtcXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5zcGVjdWxhck1hcC52YWx1ZSA9IG1hdGVyaWFsLnNwZWN1bGFyTWFwO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLmVudk1hcCApIHtcXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5lbnZNYXAudmFsdWUgPSBtYXRlcmlhbC5lbnZNYXA7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gZG9uJ3QgZmxpcCBDdWJlVGV4dHVyZSBlbnZNYXBzLCBmbGlwIGV2ZXJ5dGhpbmcgZWxzZTpcXG5cXHRcXHRcXHRcXHQvLyAgV2ViR0xSZW5kZXJUYXJnZXRDdWJlIHdpbGwgYmUgZmxpcHBlZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcXG5cXHRcXHRcXHRcXHQvLyAgV2ViR0xSZW5kZXJUYXJnZXRDdWJlLnRleHR1cmUgd2lsbCBiZSBmbGlwcGVkIGJlY2F1c2UgaXQncyBhIFRleHR1cmUgYW5kIE5PVCBhIEN1YmVUZXh0dXJlXFxuXFx0XFx0XFx0XFx0Ly8gdGhpcyBjaGVjayBtdXN0IGJlIGhhbmRsZWQgZGlmZmVyZW50bHksIG9yIHJlbW92ZWQgZW50aXJlbHksIGlmIFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZSB1c2VzIGEgQ3ViZVRleHR1cmUgaW4gdGhlIGZ1dHVyZVxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmZsaXBFbnZNYXAudmFsdWUgPSAoICEgKCBtYXRlcmlhbC5lbnZNYXAgJiYgbWF0ZXJpYWwuZW52TWFwLmlzQ3ViZVRleHR1cmUgKSApID8gMSA6IC0gMTtcXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5yZWZsZWN0aXZpdHkudmFsdWUgPSBtYXRlcmlhbC5yZWZsZWN0aXZpdHk7XFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMucmVmcmFjdGlvblJhdGlvLnZhbHVlID0gbWF0ZXJpYWwucmVmcmFjdGlvblJhdGlvO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLmxpZ2h0TWFwICkge1xcblxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmxpZ2h0TWFwLnZhbHVlID0gbWF0ZXJpYWwubGlnaHRNYXA7XFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMubGlnaHRNYXBJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcEludGVuc2l0eTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5hb01hcCApIHtcXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5hb01hcC52YWx1ZSA9IG1hdGVyaWFsLmFvTWFwO1xcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmFvTWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwuYW9NYXBJbnRlbnNpdHk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIHV2IHJlcGVhdCBhbmQgb2Zmc2V0IHNldHRpbmcgcHJpb3JpdGllc1xcblxcdFxcdFxcdC8vIDEuIGNvbG9yIG1hcFxcblxcdFxcdFxcdC8vIDIuIHNwZWN1bGFyIG1hcFxcblxcdFxcdFxcdC8vIDMuIG5vcm1hbCBtYXBcXG5cXHRcXHRcXHQvLyA0LiBidW1wIG1hcFxcblxcdFxcdFxcdC8vIDUuIGFscGhhIG1hcFxcblxcdFxcdFxcdC8vIDYuIGVtaXNzaXZlIG1hcFxcblxcblxcdFxcdFxcdHZhciB1dlNjYWxlTWFwO1xcblxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwubWFwICkge1xcblxcblxcdFxcdFxcdFxcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5tYXA7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuc3BlY3VsYXJNYXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLnNwZWN1bGFyTWFwO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCApIHtcXG5cXG5cXHRcXHRcXHRcXHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLm5vcm1hbE1hcCApIHtcXG5cXG5cXHRcXHRcXHRcXHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmJ1bXBNYXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmJ1bXBNYXA7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggbWF0ZXJpYWwucm91Z2huZXNzTWFwICkge1xcblxcblxcdFxcdFxcdFxcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5yb3VnaG5lc3NNYXA7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggbWF0ZXJpYWwubWV0YWxuZXNzTWFwICkge1xcblxcblxcdFxcdFxcdFxcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5tZXRhbG5lc3NNYXA7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuYWxwaGFNYXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmFscGhhTWFwO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmVtaXNzaXZlTWFwICkge1xcblxcblxcdFxcdFxcdFxcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5lbWlzc2l2ZU1hcDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCB1dlNjYWxlTWFwICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcXG5cXHRcXHRcXHRcXHRpZiAoIHV2U2NhbGVNYXAuaXNXZWJHTFJlbmRlclRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR1dlNjYWxlTWFwID0gdXZTY2FsZU1hcC50ZXh0dXJlO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHV2U2NhbGVNYXAubWF0cml4QXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgb2Zmc2V0ID0gdXZTY2FsZU1hcC5vZmZzZXQ7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHJlcGVhdCA9IHV2U2NhbGVNYXAucmVwZWF0O1xcblxcdFxcdFxcdFxcdFxcdHZhciByb3RhdGlvbiA9IHV2U2NhbGVNYXAucm90YXRpb247XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGNlbnRlciA9IHV2U2NhbGVNYXAuY2VudGVyO1xcblxcblxcdFxcdFxcdFxcdFxcdHV2U2NhbGVNYXAubWF0cml4LnNldFV2VHJhbnNmb3JtKCBvZmZzZXQueCwgb2Zmc2V0LnksIHJlcGVhdC54LCByZXBlYXQueSwgcm90YXRpb24sIGNlbnRlci54LCBjZW50ZXIueSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy51dlRyYW5zZm9ybS52YWx1ZS5jb3B5KCB1dlNjYWxlTWFwLm1hdHJpeCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTGluZSggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xcblxcblxcdFxcdFxcdHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUgPSBtYXRlcmlhbC5jb2xvcjtcXG5cXHRcXHRcXHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zRGFzaCggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xcblxcblxcdFxcdFxcdHVuaWZvcm1zLmRhc2hTaXplLnZhbHVlID0gbWF0ZXJpYWwuZGFzaFNpemU7XFxuXFx0XFx0XFx0dW5pZm9ybXMudG90YWxTaXplLnZhbHVlID0gbWF0ZXJpYWwuZGFzaFNpemUgKyBtYXRlcmlhbC5nYXBTaXplO1xcblxcdFxcdFxcdHVuaWZvcm1zLnNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuc2NhbGU7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1BvaW50cyggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xcblxcblxcdFxcdFxcdHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUgPSBtYXRlcmlhbC5jb2xvcjtcXG5cXHRcXHRcXHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcXG5cXHRcXHRcXHR1bmlmb3Jtcy5zaXplLnZhbHVlID0gbWF0ZXJpYWwuc2l6ZSAqIF9waXhlbFJhdGlvO1xcblxcdFxcdFxcdHVuaWZvcm1zLnNjYWxlLnZhbHVlID0gX2hlaWdodCAqIDAuNTtcXG5cXG5cXHRcXHRcXHR1bmlmb3Jtcy5tYXAudmFsdWUgPSBtYXRlcmlhbC5tYXA7XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5tYXAgIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5tYXAubWF0cml4QXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgb2Zmc2V0ID0gbWF0ZXJpYWwubWFwLm9mZnNldDtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgcmVwZWF0ID0gbWF0ZXJpYWwubWFwLnJlcGVhdDtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgcm90YXRpb24gPSBtYXRlcmlhbC5tYXAucm90YXRpb247XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGNlbnRlciA9IG1hdGVyaWFsLm1hcC5jZW50ZXI7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWwubWFwLm1hdHJpeC5zZXRVdlRyYW5zZm9ybSggb2Zmc2V0LngsIG9mZnNldC55LCByZXBlYXQueCwgcmVwZWF0LnksIHJvdGF0aW9uLCBjZW50ZXIueCwgY2VudGVyLnkgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMudXZUcmFuc2Zvcm0udmFsdWUuY29weSggbWF0ZXJpYWwubWFwLm1hdHJpeCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zRm9nKCB1bmlmb3JtcywgZm9nICkge1xcblxcblxcdFxcdFxcdHVuaWZvcm1zLmZvZ0NvbG9yLnZhbHVlID0gZm9nLmNvbG9yO1xcblxcblxcdFxcdFxcdGlmICggZm9nLmlzRm9nICkge1xcblxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmZvZ05lYXIudmFsdWUgPSBmb2cubmVhcjtcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5mb2dGYXIudmFsdWUgPSBmb2cuZmFyO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGZvZy5pc0ZvZ0V4cDIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZm9nRGVuc2l0eS52YWx1ZSA9IGZvZy5kZW5zaXR5O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTGFtYmVydCggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xcblxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwuZW1pc3NpdmVNYXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZW1pc3NpdmVNYXAudmFsdWUgPSBtYXRlcmlhbC5lbWlzc2l2ZU1hcDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1Bob25nKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0dW5pZm9ybXMuc3BlY3VsYXIudmFsdWUgPSBtYXRlcmlhbC5zcGVjdWxhcjtcXG5cXHRcXHRcXHR1bmlmb3Jtcy5zaGluaW5lc3MudmFsdWUgPSBNYXRoLm1heCggbWF0ZXJpYWwuc2hpbmluZXNzLCAxZS00ICk7IC8vIHRvIHByZXZlbnQgcG93KCAwLjAsIDAuMCApXFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcCApIHtcXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5lbWlzc2l2ZU1hcC52YWx1ZSA9IG1hdGVyaWFsLmVtaXNzaXZlTWFwO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLmJ1bXBNYXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuYnVtcE1hcC52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBNYXA7XFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuYnVtcFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuYnVtcFNjYWxlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLm5vcm1hbE1hcCApIHtcXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5ub3JtYWxNYXAudmFsdWUgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMubm9ybWFsU2NhbGUudmFsdWUuY29weSggbWF0ZXJpYWwubm9ybWFsU2NhbGUgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50TWFwLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGU7XFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50Qmlhcy52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXM7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNUb29uKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0cmVmcmVzaFVuaWZvcm1zUGhvbmcoIHVuaWZvcm1zLCBtYXRlcmlhbCApO1xcblxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwuZ3JhZGllbnRNYXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZ3JhZGllbnRNYXAudmFsdWUgPSBtYXRlcmlhbC5ncmFkaWVudE1hcDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1N0YW5kYXJkKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0dW5pZm9ybXMucm91Z2huZXNzLnZhbHVlID0gbWF0ZXJpYWwucm91Z2huZXNzO1xcblxcdFxcdFxcdHVuaWZvcm1zLm1ldGFsbmVzcy52YWx1ZSA9IG1hdGVyaWFsLm1ldGFsbmVzcztcXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLnJvdWdobmVzc01hcCApIHtcXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5yb3VnaG5lc3NNYXAudmFsdWUgPSBtYXRlcmlhbC5yb3VnaG5lc3NNYXA7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwubWV0YWxuZXNzTWFwICkge1xcblxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLm1ldGFsbmVzc01hcC52YWx1ZSA9IG1hdGVyaWFsLm1ldGFsbmVzc01hcDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcCApIHtcXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5lbWlzc2l2ZU1hcC52YWx1ZSA9IG1hdGVyaWFsLmVtaXNzaXZlTWFwO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLmJ1bXBNYXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuYnVtcE1hcC52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBNYXA7XFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuYnVtcFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuYnVtcFNjYWxlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLm5vcm1hbE1hcCApIHtcXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5ub3JtYWxNYXAudmFsdWUgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMubm9ybWFsU2NhbGUudmFsdWUuY29weSggbWF0ZXJpYWwubm9ybWFsU2NhbGUgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50TWFwLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGU7XFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50Qmlhcy52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXM7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwuZW52TWFwICkge1xcblxcblxcdFxcdFxcdFxcdC8vdW5pZm9ybXMuZW52TWFwLnZhbHVlID0gbWF0ZXJpYWwuZW52TWFwOyAvLyBwYXJ0IG9mIHVuaWZvcm1zIGNvbW1vblxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmVudk1hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmVudk1hcEludGVuc2l0eTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1BoeXNpY2FsKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0dW5pZm9ybXMuY2xlYXJDb2F0LnZhbHVlID0gbWF0ZXJpYWwuY2xlYXJDb2F0O1xcblxcdFxcdFxcdHVuaWZvcm1zLmNsZWFyQ29hdFJvdWdobmVzcy52YWx1ZSA9IG1hdGVyaWFsLmNsZWFyQ29hdFJvdWdobmVzcztcXG5cXG5cXHRcXHRcXHRyZWZyZXNoVW5pZm9ybXNTdGFuZGFyZCggdW5pZm9ybXMsIG1hdGVyaWFsICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0RlcHRoKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50TWFwLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGU7XFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50Qmlhcy52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXM7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNEaXN0YW5jZSggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xcblxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwICkge1xcblxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpc3BsYWNlbWVudE1hcC52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcDtcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlO1xcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpc3BsYWNlbWVudEJpYXMudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR1bmlmb3Jtcy5yZWZlcmVuY2VQb3NpdGlvbi52YWx1ZS5jb3B5KCBtYXRlcmlhbC5yZWZlcmVuY2VQb3NpdGlvbiApO1xcblxcdFxcdFxcdHVuaWZvcm1zLm5lYXJEaXN0YW5jZS52YWx1ZSA9IG1hdGVyaWFsLm5lYXJEaXN0YW5jZTtcXG5cXHRcXHRcXHR1bmlmb3Jtcy5mYXJEaXN0YW5jZS52YWx1ZSA9IG1hdGVyaWFsLmZhckRpc3RhbmNlO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNOb3JtYWwoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLmJ1bXBNYXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuYnVtcE1hcC52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBNYXA7XFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuYnVtcFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuYnVtcFNjYWxlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLm5vcm1hbE1hcCApIHtcXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5ub3JtYWxNYXAudmFsdWUgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMubm9ybWFsU2NhbGUudmFsdWUuY29weSggbWF0ZXJpYWwubm9ybWFsU2NhbGUgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50TWFwLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGU7XFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50Qmlhcy52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXM7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBJZiB1bmlmb3JtcyBhcmUgbWFya2VkIGFzIGNsZWFuLCB0aGV5IGRvbid0IG5lZWQgdG8gYmUgbG9hZGVkIHRvIHRoZSBHUFUuXFxuXFxuXFx0XFx0ZnVuY3Rpb24gbWFya1VuaWZvcm1zTGlnaHRzTmVlZHNVcGRhdGUoIHVuaWZvcm1zLCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHR1bmlmb3Jtcy5hbWJpZW50TGlnaHRDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xcblxcblxcdFxcdFxcdHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XFxuXFx0XFx0XFx0dW5pZm9ybXMucG9pbnRMaWdodHMubmVlZHNVcGRhdGUgPSB2YWx1ZTtcXG5cXHRcXHRcXHR1bmlmb3Jtcy5zcG90TGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XFxuXFx0XFx0XFx0dW5pZm9ybXMucmVjdEFyZWFMaWdodHMubmVlZHNVcGRhdGUgPSB2YWx1ZTtcXG5cXHRcXHRcXHR1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRzLm5lZWRzVXBkYXRlID0gdmFsdWU7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEdMIHN0YXRlIHNldHRpbmdcXG5cXG5cXHRcXHR0aGlzLnNldEZhY2VDdWxsaW5nID0gZnVuY3Rpb24gKCBjdWxsRmFjZSwgZnJvbnRGYWNlRGlyZWN0aW9uICkge1xcblxcblxcdFxcdFxcdHN0YXRlLnNldEN1bGxGYWNlKCBjdWxsRmFjZSApO1xcblxcdFxcdFxcdHN0YXRlLnNldEZsaXBTaWRlZCggZnJvbnRGYWNlRGlyZWN0aW9uID09PSBGcm9udEZhY2VEaXJlY3Rpb25DVyApO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gVGV4dHVyZXNcXG5cXG5cXHRcXHRmdW5jdGlvbiBhbGxvY1RleHR1cmVVbml0KCkge1xcblxcblxcdFxcdFxcdHZhciB0ZXh0dXJlVW5pdCA9IF91c2VkVGV4dHVyZVVuaXRzO1xcblxcblxcdFxcdFxcdGlmICggdGV4dHVyZVVuaXQgPj0gY2FwYWJpbGl0aWVzLm1heFRleHR1cmVzICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRyeWluZyB0byB1c2UgJyArIHRleHR1cmVVbml0ICsgJyB0ZXh0dXJlIHVuaXRzIHdoaWxlIHRoaXMgR1BVIHN1cHBvcnRzIG9ubHkgJyArIGNhcGFiaWxpdGllcy5tYXhUZXh0dXJlcyApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRfdXNlZFRleHR1cmVVbml0cyArPSAxO1xcblxcblxcdFxcdFxcdHJldHVybiB0ZXh0dXJlVW5pdDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5hbGxvY1RleHR1cmVVbml0ID0gYWxsb2NUZXh0dXJlVW5pdDtcXG5cXG5cXHRcXHQvLyB0aGlzLnNldFRleHR1cmUyRCA9IHNldFRleHR1cmUyRDtcXG5cXHRcXHR0aGlzLnNldFRleHR1cmUyRCA9ICggZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB3YXJuZWQgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogcGVlbCB0ZXh0dXJlLnRleHR1cmVcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gc2V0VGV4dHVyZTJEKCB0ZXh0dXJlLCBzbG90ICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggdGV4dHVyZSAmJiB0ZXh0dXJlLmlzV2ViR0xSZW5kZXJUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAhIHdhcm5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oIFxcXCJUSFJFRS5XZWJHTFJlbmRlcmVyLnNldFRleHR1cmUyRDogZG9uJ3QgdXNlIHJlbmRlciB0YXJnZXRzIGFzIHRleHR1cmVzLiBVc2UgdGhlaXIgLnRleHR1cmUgcHJvcGVydHkgaW5zdGVhZC5cXFwiICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0d2FybmVkID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGV4dHVyZSA9IHRleHR1cmUudGV4dHVyZTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dGV4dHVyZXMuc2V0VGV4dHVyZTJEKCB0ZXh0dXJlLCBzbG90ICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCkgKTtcXG5cXG5cXHRcXHR0aGlzLnNldFRleHR1cmUgPSAoIGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgd2FybmVkID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHNldFRleHR1cmUoIHRleHR1cmUsIHNsb3QgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCAhIHdhcm5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oIFxcXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2V0VGV4dHVyZSBpcyBkZXByZWNhdGVkLCB1c2Ugc2V0VGV4dHVyZTJEIGluc3RlYWQuXFxcIiApO1xcblxcdFxcdFxcdFxcdFxcdHdhcm5lZCA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHRleHR1cmVzLnNldFRleHR1cmUyRCggdGV4dHVyZSwgc2xvdCApO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpICk7XFxuXFxuXFx0XFx0dGhpcy5zZXRUZXh0dXJlQ3ViZSA9ICggZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB3YXJuZWQgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gc2V0VGV4dHVyZUN1YmUoIHRleHR1cmUsIHNsb3QgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHk6IHBlZWwgdGV4dHVyZS50ZXh0dXJlXFxuXFx0XFx0XFx0XFx0aWYgKCB0ZXh0dXJlICYmIHRleHR1cmUuaXNXZWJHTFJlbmRlclRhcmdldEN1YmUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAhIHdhcm5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oIFxcXCJUSFJFRS5XZWJHTFJlbmRlcmVyLnNldFRleHR1cmVDdWJlOiBkb24ndCB1c2UgY3ViZSByZW5kZXIgdGFyZ2V0cyBhcyB0ZXh0dXJlcy4gVXNlIHRoZWlyIC50ZXh0dXJlIHByb3BlcnR5IGluc3RlYWQuXFxcIiApO1xcblxcdFxcdFxcdFxcdFxcdFxcdHdhcm5lZCA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHRleHR1cmUgPSB0ZXh0dXJlLnRleHR1cmU7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIGN1cnJlbnRseSByZWx5aW5nIG9uIHRoZSBmYWN0IHRoYXQgV2ViR0xSZW5kZXJUYXJnZXRDdWJlLnRleHR1cmUgaXMgYSBUZXh0dXJlIGFuZCBOT1QgYSBDdWJlVGV4dHVyZVxcblxcdFxcdFxcdFxcdC8vIFRPRE86IHVuaWZ5IHRoZXNlIGNvZGUgcGF0aHNcXG5cXHRcXHRcXHRcXHRpZiAoICggdGV4dHVyZSAmJiB0ZXh0dXJlLmlzQ3ViZVRleHR1cmUgKSB8fFxcblxcdFxcdFxcdFxcdFxcdCggQXJyYXkuaXNBcnJheSggdGV4dHVyZS5pbWFnZSApICYmIHRleHR1cmUuaW1hZ2UubGVuZ3RoID09PSA2ICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gQ29tcHJlc3NlZFRleHR1cmUgY2FuIGhhdmUgQXJyYXkgaW4gaW1hZ2UgOi9cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyB0aGlzIGZ1bmN0aW9uIGFsb25lIHNob3VsZCB0YWtlIGNhcmUgb2YgY3ViZSB0ZXh0dXJlc1xcblxcdFxcdFxcdFxcdFxcdHRleHR1cmVzLnNldFRleHR1cmVDdWJlKCB0ZXh0dXJlLCBzbG90ICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBhc3N1bWVkOiB0ZXh0dXJlIHByb3BlcnR5IG9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZVxcblxcblxcdFxcdFxcdFxcdFxcdHRleHR1cmVzLnNldFRleHR1cmVDdWJlRHluYW1pYyggdGV4dHVyZSwgc2xvdCApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSApO1xcblxcblxcdFxcdHRoaXMuZ2V0UmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBfY3VycmVudFJlbmRlclRhcmdldDtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuc2V0UmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKCByZW5kZXJUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0X2N1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXQ7XFxuXFxuXFx0XFx0XFx0aWYgKCByZW5kZXJUYXJnZXQgJiYgcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApLl9fd2ViZ2xGcmFtZWJ1ZmZlciA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdHRleHR1cmVzLnNldHVwUmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIGZyYW1lYnVmZmVyID0gbnVsbDtcXG5cXHRcXHRcXHR2YXIgaXNDdWJlID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0aWYgKCByZW5kZXJUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIF9fd2ViZ2xGcmFtZWJ1ZmZlciA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKS5fX3dlYmdsRnJhbWVidWZmZXI7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCByZW5kZXJUYXJnZXQuaXNXZWJHTFJlbmRlclRhcmdldEN1YmUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZnJhbWVidWZmZXIgPSBfX3dlYmdsRnJhbWVidWZmZXJbIHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSBdO1xcblxcdFxcdFxcdFxcdFxcdGlzQ3ViZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmcmFtZWJ1ZmZlciA9IF9fd2ViZ2xGcmFtZWJ1ZmZlcjtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0X2N1cnJlbnRWaWV3cG9ydC5jb3B5KCByZW5kZXJUYXJnZXQudmlld3BvcnQgKTtcXG5cXHRcXHRcXHRcXHRfY3VycmVudFNjaXNzb3IuY29weSggcmVuZGVyVGFyZ2V0LnNjaXNzb3IgKTtcXG5cXHRcXHRcXHRcXHRfY3VycmVudFNjaXNzb3JUZXN0ID0gcmVuZGVyVGFyZ2V0LnNjaXNzb3JUZXN0O1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0X2N1cnJlbnRWaWV3cG9ydC5jb3B5KCBfdmlld3BvcnQgKS5tdWx0aXBseVNjYWxhciggX3BpeGVsUmF0aW8gKTtcXG5cXHRcXHRcXHRcXHRfY3VycmVudFNjaXNzb3IuY29weSggX3NjaXNzb3IgKS5tdWx0aXBseVNjYWxhciggX3BpeGVsUmF0aW8gKTtcXG5cXHRcXHRcXHRcXHRfY3VycmVudFNjaXNzb3JUZXN0ID0gX3NjaXNzb3JUZXN0O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIF9jdXJyZW50RnJhbWVidWZmZXIgIT09IGZyYW1lYnVmZmVyICkge1xcblxcblxcdFxcdFxcdFxcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcXG5cXHRcXHRcXHRcXHRfY3VycmVudEZyYW1lYnVmZmVyID0gZnJhbWVidWZmZXI7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHN0YXRlLnZpZXdwb3J0KCBfY3VycmVudFZpZXdwb3J0ICk7XFxuXFx0XFx0XFx0c3RhdGUuc2Npc3NvciggX2N1cnJlbnRTY2lzc29yICk7XFxuXFx0XFx0XFx0c3RhdGUuc2V0U2Npc3NvclRlc3QoIF9jdXJyZW50U2Npc3NvclRlc3QgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGlzQ3ViZSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKTtcXG5cXHRcXHRcXHRcXHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSwgcmVuZGVyVGFyZ2V0LmFjdGl2ZU1pcE1hcExldmVsICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzID0gZnVuY3Rpb24gKCByZW5kZXJUYXJnZXQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIGJ1ZmZlciApIHtcXG5cXG5cXHRcXHRcXHRpZiAoICEgKCByZW5kZXJUYXJnZXQgJiYgcmVuZGVyVGFyZ2V0LmlzV2ViR0xSZW5kZXJUYXJnZXQgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBmcmFtZWJ1ZmZlciA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKS5fX3dlYmdsRnJhbWVidWZmZXI7XFxuXFxuXFx0XFx0XFx0aWYgKCBmcmFtZWJ1ZmZlciApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcmVzdG9yZSA9IGZhbHNlO1xcblxcblxcdFxcdFxcdFxcdGlmICggZnJhbWVidWZmZXIgIT09IF9jdXJyZW50RnJhbWVidWZmZXIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xcblxcblxcdFxcdFxcdFxcdFxcdHJlc3RvcmUgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0cnkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciB0ZXh0dXJlID0gcmVuZGVyVGFyZ2V0LnRleHR1cmU7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHRleHR1cmVGb3JtYXQgPSB0ZXh0dXJlLmZvcm1hdDtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdGV4dHVyZVR5cGUgPSB0ZXh0dXJlLnR5cGU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0ZXh0dXJlRm9ybWF0ICE9PSBSR0JBRm9ybWF0ICYmIHV0aWxzLmNvbnZlcnQoIHRleHR1cmVGb3JtYXQgKSAhPT0gX2dsLmdldFBhcmFtZXRlciggX2dsLklNUExFTUVOVEFUSU9OX0NPTE9SX1JFQURfRk9STUFUICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBpbiBSR0JBIG9yIGltcGxlbWVudGF0aW9uIGRlZmluZWQgZm9ybWF0LicgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGlmICggdGV4dHVyZVR5cGUgIT09IFVuc2lnbmVkQnl0ZVR5cGUgJiYgdXRpbHMuY29udmVydCggdGV4dHVyZVR5cGUgKSAhPT0gX2dsLmdldFBhcmFtZXRlciggX2dsLklNUExFTUVOVEFUSU9OX0NPTE9SX1JFQURfVFlQRSApICYmIC8vIElFMTEsIEVkZ2UgYW5kIENocm9tZSBNYWMgPCA1MiAoIzk1MTMpXFxuXFx0XFx0XFx0XFx0XFx0XFx0ISAoIHRleHR1cmVUeXBlID09PSBGbG9hdFR5cGUgJiYgKCBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApIHx8IGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0JyApICkgKSAmJiAvLyBDaHJvbWUgTWFjID49IDUyIGFuZCBGaXJlZm94XFxuXFx0XFx0XFx0XFx0XFx0XFx0ISAoIHRleHR1cmVUeXBlID09PSBIYWxmRmxvYXRUeXBlICYmIGV4dGVuc2lvbnMuZ2V0KCAnRVhUX2NvbG9yX2J1ZmZlcl9oYWxmX2Zsb2F0JyApICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVuZGVyVGFyZ2V0IGlzIG5vdCBpbiBVbnNpZ25lZEJ5dGVUeXBlIG9yIGltcGxlbWVudGF0aW9uIGRlZmluZWQgdHlwZS4nICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIF9nbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKCBfZ2wuRlJBTUVCVUZGRVIgKSA9PT0gX2dsLkZSQU1FQlVGRkVSX0NPTVBMRVRFICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHRoZSBmb2xsb3dpbmcgaWYgc3RhdGVtZW50IGVuc3VyZXMgdmFsaWQgcmVhZCByZXF1ZXN0cyAobm8gb3V0LW9mLWJvdW5kcyBwaXhlbHMsIHNlZSAjODYwNClcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoICggeCA+PSAwICYmIHggPD0gKCByZW5kZXJUYXJnZXQud2lkdGggLSB3aWR0aCApICkgJiYgKCB5ID49IDAgJiYgeSA8PSAoIHJlbmRlclRhcmdldC5oZWlnaHQgLSBoZWlnaHQgKSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdF9nbC5yZWFkUGl4ZWxzKCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlRm9ybWF0ICksIHV0aWxzLmNvbnZlcnQoIHRleHR1cmVUeXBlICksIGJ1ZmZlciApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlYWRQaXhlbHMgZnJvbSByZW5kZXJUYXJnZXQgZmFpbGVkLiBGcmFtZWJ1ZmZlciBub3QgY29tcGxldGUuJyApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9IGZpbmFsbHkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggcmVzdG9yZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9jdXJyZW50RnJhbWVidWZmZXIgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9O1xcblxcblxcdH1cXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gRm9nRXhwMiggY29sb3IsIGRlbnNpdHkgKSB7XFxuXFxuXFx0XFx0dGhpcy5uYW1lID0gJyc7XFxuXFxuXFx0XFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggY29sb3IgKTtcXG5cXHRcXHR0aGlzLmRlbnNpdHkgPSAoIGRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gZGVuc2l0eSA6IDAuMDAwMjU7XFxuXFxuXFx0fVxcblxcblxcdEZvZ0V4cDIucHJvdG90eXBlLmlzRm9nRXhwMiA9IHRydWU7XFxuXFxuXFx0Rm9nRXhwMi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0cmV0dXJuIG5ldyBGb2dFeHAyKCB0aGlzLmNvbG9yLmdldEhleCgpLCB0aGlzLmRlbnNpdHkgKTtcXG5cXG5cXHR9O1xcblxcblxcdEZvZ0V4cDIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggLyogbWV0YSAqLyApIHtcXG5cXG5cXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdHR5cGU6ICdGb2dFeHAyJyxcXG5cXHRcXHRcXHRjb2xvcjogdGhpcy5jb2xvci5nZXRIZXgoKSxcXG5cXHRcXHRcXHRkZW5zaXR5OiB0aGlzLmRlbnNpdHlcXG5cXHRcXHR9O1xcblxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEZvZyggY29sb3IsIG5lYXIsIGZhciApIHtcXG5cXG5cXHRcXHR0aGlzLm5hbWUgPSAnJztcXG5cXG5cXHRcXHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCBjb2xvciApO1xcblxcblxcdFxcdHRoaXMubmVhciA9ICggbmVhciAhPT0gdW5kZWZpbmVkICkgPyBuZWFyIDogMTtcXG5cXHRcXHR0aGlzLmZhciA9ICggZmFyICE9PSB1bmRlZmluZWQgKSA/IGZhciA6IDEwMDA7XFxuXFxuXFx0fVxcblxcblxcdEZvZy5wcm90b3R5cGUuaXNGb2cgPSB0cnVlO1xcblxcblxcdEZvZy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0cmV0dXJuIG5ldyBGb2coIHRoaXMuY29sb3IuZ2V0SGV4KCksIHRoaXMubmVhciwgdGhpcy5mYXIgKTtcXG5cXG5cXHR9O1xcblxcblxcdEZvZy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCAvKiBtZXRhICovICkge1xcblxcblxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0dHlwZTogJ0ZvZycsXFxuXFx0XFx0XFx0Y29sb3I6IHRoaXMuY29sb3IuZ2V0SGV4KCksXFxuXFx0XFx0XFx0bmVhcjogdGhpcy5uZWFyLFxcblxcdFxcdFxcdGZhcjogdGhpcy5mYXJcXG5cXHRcXHR9O1xcblxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBTY2VuZSgpIHtcXG5cXG5cXHRcXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1NjZW5lJztcXG5cXG5cXHRcXHR0aGlzLmJhY2tncm91bmQgPSBudWxsO1xcblxcdFxcdHRoaXMuZm9nID0gbnVsbDtcXG5cXHRcXHR0aGlzLm92ZXJyaWRlTWF0ZXJpYWwgPSBudWxsO1xcblxcblxcdFxcdHRoaXMuYXV0b1VwZGF0ZSA9IHRydWU7IC8vIGNoZWNrZWQgYnkgdGhlIHJlbmRlcmVyXFxuXFxuXFx0fVxcblxcblxcdFNjZW5lLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IFNjZW5lLFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlLCByZWN1cnNpdmUgKSB7XFxuXFxuXFx0XFx0XFx0T2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlLCByZWN1cnNpdmUgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIHNvdXJjZS5iYWNrZ3JvdW5kICE9PSBudWxsICkgdGhpcy5iYWNrZ3JvdW5kID0gc291cmNlLmJhY2tncm91bmQuY2xvbmUoKTtcXG5cXHRcXHRcXHRpZiAoIHNvdXJjZS5mb2cgIT09IG51bGwgKSB0aGlzLmZvZyA9IHNvdXJjZS5mb2cuY2xvbmUoKTtcXG5cXHRcXHRcXHRpZiAoIHNvdXJjZS5vdmVycmlkZU1hdGVyaWFsICE9PSBudWxsICkgdGhpcy5vdmVycmlkZU1hdGVyaWFsID0gc291cmNlLm92ZXJyaWRlTWF0ZXJpYWwuY2xvbmUoKTtcXG5cXG5cXHRcXHRcXHR0aGlzLmF1dG9VcGRhdGUgPSBzb3VyY2UuYXV0b1VwZGF0ZTtcXG5cXHRcXHRcXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBzb3VyY2UubWF0cml4QXV0b1VwZGF0ZTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xcblxcblxcdFxcdFxcdHZhciBkYXRhID0gT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmJhY2tncm91bmQgIT09IG51bGwgKSBkYXRhLm9iamVjdC5iYWNrZ3JvdW5kID0gdGhpcy5iYWNrZ3JvdW5kLnRvSlNPTiggbWV0YSApO1xcblxcdFxcdFxcdGlmICggdGhpcy5mb2cgIT09IG51bGwgKSBkYXRhLm9iamVjdC5mb2cgPSB0aGlzLmZvZy50b0pTT04oKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZGF0YTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBMZW5zRmxhcmUoIHRleHR1cmUsIHNpemUsIGRpc3RhbmNlLCBibGVuZGluZywgY29sb3IgKSB7XFxuXFxuXFx0XFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMubGVuc0ZsYXJlcyA9IFtdO1xcblxcblxcdFxcdHRoaXMucG9zaXRpb25TY3JlZW4gPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdHRoaXMuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgPSB1bmRlZmluZWQ7XFxuXFxuXFx0XFx0aWYgKCB0ZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5hZGQoIHRleHR1cmUsIHNpemUsIGRpc3RhbmNlLCBibGVuZGluZywgY29sb3IgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fVxcblxcblxcdExlbnNGbGFyZS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBMZW5zRmxhcmUsXFxuXFxuXFx0XFx0aXNMZW5zRmxhcmU6IHRydWUsXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxuXFxuXFx0XFx0XFx0T2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxuXFxuXFx0XFx0XFx0dGhpcy5wb3NpdGlvblNjcmVlbi5jb3B5KCBzb3VyY2UucG9zaXRpb25TY3JlZW4gKTtcXG5cXHRcXHRcXHR0aGlzLmN1c3RvbVVwZGF0ZUNhbGxiYWNrID0gc291cmNlLmN1c3RvbVVwZGF0ZUNhbGxiYWNrO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHNvdXJjZS5sZW5zRmxhcmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5sZW5zRmxhcmVzLnB1c2goIHNvdXJjZS5sZW5zRmxhcmVzWyBpIF0gKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRhZGQ6IGZ1bmN0aW9uICggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciwgb3BhY2l0eSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHNpemUgPT09IHVuZGVmaW5lZCApIHNpemUgPSAtIDE7XFxuXFx0XFx0XFx0aWYgKCBkaXN0YW5jZSA9PT0gdW5kZWZpbmVkICkgZGlzdGFuY2UgPSAwO1xcblxcdFxcdFxcdGlmICggb3BhY2l0eSA9PT0gdW5kZWZpbmVkICkgb3BhY2l0eSA9IDE7XFxuXFx0XFx0XFx0aWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkICkgY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7XFxuXFx0XFx0XFx0aWYgKCBibGVuZGluZyA9PT0gdW5kZWZpbmVkICkgYmxlbmRpbmcgPSBOb3JtYWxCbGVuZGluZztcXG5cXG5cXHRcXHRcXHRkaXN0YW5jZSA9IE1hdGgubWluKCBkaXN0YW5jZSwgTWF0aC5tYXgoIDAsIGRpc3RhbmNlICkgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLmxlbnNGbGFyZXMucHVzaCgge1xcblxcdFxcdFxcdFxcdHRleHR1cmU6IHRleHR1cmUsXFx0Ly8gVEhSRUUuVGV4dHVyZVxcblxcdFxcdFxcdFxcdHNpemU6IHNpemUsIFxcdFxcdC8vIHNpemUgaW4gcGl4ZWxzICgtMSA9IHVzZSB0ZXh0dXJlLndpZHRoKVxcblxcdFxcdFxcdFxcdGRpc3RhbmNlOiBkaXN0YW5jZSwgXFx0Ly8gZGlzdGFuY2UgKDAtMSkgZnJvbSBsaWdodCBzb3VyY2UgKDA9YXQgbGlnaHQgc291cmNlKVxcblxcdFxcdFxcdFxcdHg6IDAsIHk6IDAsIHo6IDAsXFx0Ly8gc2NyZWVuIHBvc2l0aW9uICgtMSA9PiAxKSB6ID0gMCBpcyBpbiBmcm9udCB6ID0gMSBpcyBiYWNrXFxuXFx0XFx0XFx0XFx0c2NhbGU6IDEsIFxcdFxcdC8vIHNjYWxlXFxuXFx0XFx0XFx0XFx0cm90YXRpb246IDAsIFxcdFxcdC8vIHJvdGF0aW9uXFxuXFx0XFx0XFx0XFx0b3BhY2l0eTogb3BhY2l0eSxcXHQvLyBvcGFjaXR5XFxuXFx0XFx0XFx0XFx0Y29sb3I6IGNvbG9yLFxcdFxcdC8vIGNvbG9yXFxuXFx0XFx0XFx0XFx0YmxlbmRpbmc6IGJsZW5kaW5nXFx0Ly8gYmxlbmRpbmdcXG5cXHRcXHRcXHR9ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKlxcblxcdFxcdCAqIFVwZGF0ZSBsZW5zIGZsYXJlcyB1cGRhdGUgcG9zaXRpb25zIG9uIGFsbCBmbGFyZXMgYmFzZWQgb24gdGhlIHNjcmVlbiBwb3NpdGlvblxcblxcdFxcdCAqIFNldCBteUxlbnNGbGFyZS5jdXN0b21VcGRhdGVDYWxsYmFjayB0byBhbHRlciB0aGUgZmxhcmVzIGluIHlvdXIgcHJvamVjdCBzcGVjaWZpYyB3YXkuXFxuXFx0XFx0ICovXFxuXFxuXFx0XFx0dXBkYXRlTGVuc0ZsYXJlczogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBmLCBmbCA9IHRoaXMubGVuc0ZsYXJlcy5sZW5ndGg7XFxuXFx0XFx0XFx0dmFyIGZsYXJlO1xcblxcdFxcdFxcdHZhciB2ZWNYID0gLSB0aGlzLnBvc2l0aW9uU2NyZWVuLnggKiAyO1xcblxcdFxcdFxcdHZhciB2ZWNZID0gLSB0aGlzLnBvc2l0aW9uU2NyZWVuLnkgKiAyO1xcblxcblxcdFxcdFxcdGZvciAoIGYgPSAwOyBmIDwgZmw7IGYgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZmxhcmUgPSB0aGlzLmxlbnNGbGFyZXNbIGYgXTtcXG5cXG5cXHRcXHRcXHRcXHRmbGFyZS54ID0gdGhpcy5wb3NpdGlvblNjcmVlbi54ICsgdmVjWCAqIGZsYXJlLmRpc3RhbmNlO1xcblxcdFxcdFxcdFxcdGZsYXJlLnkgPSB0aGlzLnBvc2l0aW9uU2NyZWVuLnkgKyB2ZWNZICogZmxhcmUuZGlzdGFuY2U7XFxuXFxuXFx0XFx0XFx0XFx0ZmxhcmUud2FudGVkUm90YXRpb24gPSBmbGFyZS54ICogTWF0aC5QSSAqIDAuMjU7XFxuXFx0XFx0XFx0XFx0ZmxhcmUucm90YXRpb24gKz0gKCBmbGFyZS53YW50ZWRSb3RhdGlvbiAtIGZsYXJlLnJvdGF0aW9uICkgKiAwLjI1O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICpcXG5cXHQgKiBwYXJhbWV0ZXJzID0ge1xcblxcdCAqICBjb2xvcjogPGhleD4sXFxuXFx0ICogIG9wYWNpdHk6IDxmbG9hdD4sXFxuXFx0ICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXG5cXHQgKlxcblxcdCAqXFx0dXZPZmZzZXQ6IG5ldyBUSFJFRS5WZWN0b3IyKCksXFxuXFx0ICpcXHR1dlNjYWxlOiBuZXcgVEhSRUUuVmVjdG9yMigpXFxuXFx0ICogfVxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFNwcml0ZU1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xcblxcblxcdFxcdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnU3ByaXRlTWF0ZXJpYWwnO1xcblxcblxcdFxcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7XFxuXFx0XFx0dGhpcy5tYXAgPSBudWxsO1xcblxcblxcdFxcdHRoaXMucm90YXRpb24gPSAwO1xcblxcblxcdFxcdHRoaXMuZm9nID0gZmFsc2U7XFxuXFx0XFx0dGhpcy5saWdodHMgPSBmYWxzZTtcXG5cXG5cXHRcXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xcblxcblxcdH1cXG5cXG5cXHRTcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXRlcmlhbC5wcm90b3R5cGUgKTtcXG5cXHRTcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcHJpdGVNYXRlcmlhbDtcXG5cXHRTcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUuaXNTcHJpdGVNYXRlcmlhbCA9IHRydWU7XFxuXFxuXFx0U3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXG5cXG5cXHRcXHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xcblxcdFxcdHRoaXMubWFwID0gc291cmNlLm1hcDtcXG5cXG5cXHRcXHR0aGlzLnJvdGF0aW9uID0gc291cmNlLnJvdGF0aW9uO1xcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFNwcml0ZSggbWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdTcHJpdGUnO1xcblxcblxcdFxcdHRoaXMubWF0ZXJpYWwgPSAoIG1hdGVyaWFsICE9PSB1bmRlZmluZWQgKSA/IG1hdGVyaWFsIDogbmV3IFNwcml0ZU1hdGVyaWFsKCk7XFxuXFxuXFx0fVxcblxcblxcdFNwcml0ZS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBTcHJpdGUsXFxuXFxuXFx0XFx0aXNTcHJpdGU6IHRydWUsXFxuXFxuXFx0XFx0cmF5Y2FzdDogKCBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGludGVyc2VjdFBvaW50ID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgd29ybGRQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0dmFyIHdvcmxkU2NhbGUgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiByYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0d29ybGRQb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcXG5cXHRcXHRcXHRcXHRyYXljYXN0ZXIucmF5LmNsb3Nlc3RQb2ludFRvUG9pbnQoIHdvcmxkUG9zaXRpb24sIGludGVyc2VjdFBvaW50ICk7XFxuXFxuXFx0XFx0XFx0XFx0d29ybGRTY2FsZS5zZXRGcm9tTWF0cml4U2NhbGUoIHRoaXMubWF0cml4V29ybGQgKTtcXG5cXHRcXHRcXHRcXHR2YXIgZ3Vlc3NTaXplU3EgPSB3b3JsZFNjYWxlLnggKiB3b3JsZFNjYWxlLnkgLyA0O1xcblxcblxcdFxcdFxcdFxcdGlmICggd29ybGRQb3NpdGlvbi5kaXN0YW5jZVRvU3F1YXJlZCggaW50ZXJzZWN0UG9pbnQgKSA+IGd1ZXNzU2l6ZVNxICkgcmV0dXJuO1xcblxcblxcdFxcdFxcdFxcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyc2VjdFBvaW50ICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIHJldHVybjtcXG5cXG5cXHRcXHRcXHRcXHRpbnRlcnNlY3RzLnB1c2goIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRkaXN0YW5jZTogZGlzdGFuY2UsXFxuXFx0XFx0XFx0XFx0XFx0cG9pbnQ6IGludGVyc2VjdFBvaW50LmNsb25lKCksXFxuXFx0XFx0XFx0XFx0XFx0ZmFjZTogbnVsbCxcXG5cXHRcXHRcXHRcXHRcXHRvYmplY3Q6IHRoaXNcXG5cXG5cXHRcXHRcXHRcXHR9ICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCkgKSxcXG5cXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIExPRCgpIHtcXG5cXG5cXHRcXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ0xPRCc7XFxuXFxuXFx0XFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcXG5cXHRcXHRcXHRsZXZlbHM6IHtcXG5cXHRcXHRcXHRcXHRlbnVtZXJhYmxlOiB0cnVlLFxcblxcdFxcdFxcdFxcdHZhbHVlOiBbXVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9ICk7XFxuXFxuXFx0fVxcblxcblxcdExPRC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBMT0QsXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxuXFxuXFx0XFx0XFx0T2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlLCBmYWxzZSApO1xcblxcblxcdFxcdFxcdHZhciBsZXZlbHMgPSBzb3VyY2UubGV2ZWxzO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBsZXZlbCA9IGxldmVsc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdHRoaXMuYWRkTGV2ZWwoIGxldmVsLm9iamVjdC5jbG9uZSgpLCBsZXZlbC5kaXN0YW5jZSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGFkZExldmVsOiBmdW5jdGlvbiAoIG9iamVjdCwgZGlzdGFuY2UgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBkaXN0YW5jZSA9PT0gdW5kZWZpbmVkICkgZGlzdGFuY2UgPSAwO1xcblxcblxcdFxcdFxcdGRpc3RhbmNlID0gTWF0aC5hYnMoIGRpc3RhbmNlICk7XFxuXFxuXFx0XFx0XFx0dmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBsID0gMDsgbCA8IGxldmVscy5sZW5ndGg7IGwgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBkaXN0YW5jZSA8IGxldmVsc1sgbCBdLmRpc3RhbmNlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0bGV2ZWxzLnNwbGljZSggbCwgMCwgeyBkaXN0YW5jZTogZGlzdGFuY2UsIG9iamVjdDogb2JqZWN0IH0gKTtcXG5cXG5cXHRcXHRcXHR0aGlzLmFkZCggb2JqZWN0ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRPYmplY3RGb3JEaXN0YW5jZTogZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAxLCBsID0gbGV2ZWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBkaXN0YW5jZSA8IGxldmVsc1sgaSBdLmRpc3RhbmNlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGxldmVsc1sgaSAtIDEgXS5vYmplY3Q7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyYXljYXN0OiAoIGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgbWF0cml4UG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiByYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0bWF0cml4UG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggbWF0cml4UG9zaXRpb24gKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmdldE9iamVjdEZvckRpc3RhbmNlKCBkaXN0YW5jZSApLnJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpICksXFxuXFxuXFx0XFx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgdjIgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoIGNhbWVyYSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBsZXZlbHMubGVuZ3RoID4gMSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2MS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xcblxcdFxcdFxcdFxcdFxcdHYyLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBkaXN0YW5jZSA9IHYxLmRpc3RhbmNlVG8oIHYyICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bGV2ZWxzWyAwIF0ub2JqZWN0LnZpc2libGUgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMSwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggZGlzdGFuY2UgPj0gbGV2ZWxzWyBpIF0uZGlzdGFuY2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bGV2ZWxzWyBpIC0gMSBdLm9iamVjdC52aXNpYmxlID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bGV2ZWxzWyBpIF0ub2JqZWN0LnZpc2libGUgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCA7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGxldmVsc1sgaSBdLm9iamVjdC52aXNpYmxlID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHR0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgZGF0YSA9IE9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xcblxcblxcdFxcdFxcdGRhdGEub2JqZWN0LmxldmVscyA9IFtdO1xcblxcblxcdFxcdFxcdHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbGV2ZWwgPSBsZXZlbHNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRkYXRhLm9iamVjdC5sZXZlbHMucHVzaCgge1xcblxcdFxcdFxcdFxcdFxcdG9iamVjdDogbGV2ZWwub2JqZWN0LnV1aWQsXFxuXFx0XFx0XFx0XFx0XFx0ZGlzdGFuY2U6IGxldmVsLmRpc3RhbmNlXFxuXFx0XFx0XFx0XFx0fSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gZGF0YTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKiBAYXV0aG9yIG1pY2hhZWwgZ3VlcnJlcm8gLyBodHRwOi8vcmVhbGl0eW1lbHRkb3duLmNvbVxcblxcdCAqIEBhdXRob3IgaWtlcnIgLyBodHRwOi8vdmVyb2xkLmNvbVxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFNrZWxldG9uKCBib25lcywgYm9uZUludmVyc2VzICkge1xcblxcblxcdFxcdC8vIGNvcHkgdGhlIGJvbmUgYXJyYXlcXG5cXG5cXHRcXHRib25lcyA9IGJvbmVzIHx8IFtdO1xcblxcblxcdFxcdHRoaXMuYm9uZXMgPSBib25lcy5zbGljZSggMCApO1xcblxcdFxcdHRoaXMuYm9uZU1hdHJpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggdGhpcy5ib25lcy5sZW5ndGggKiAxNiApO1xcblxcblxcdFxcdC8vIHVzZSB0aGUgc3VwcGxpZWQgYm9uZSBpbnZlcnNlcyBvciBjYWxjdWxhdGUgdGhlIGludmVyc2VzXFxuXFxuXFx0XFx0aWYgKCBib25lSW52ZXJzZXMgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmNhbGN1bGF0ZUludmVyc2VzKCk7XFxuXFxuXFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuYm9uZXMubGVuZ3RoID09PSBib25lSW52ZXJzZXMubGVuZ3RoICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuYm9uZUludmVyc2VzID0gYm9uZUludmVyc2VzLnNsaWNlKCAwICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5Ta2VsZXRvbiBib25lSW52ZXJzZXMgaXMgdGhlIHdyb25nIGxlbmd0aC4nICk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5ib25lSW52ZXJzZXMgPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy5ib25lcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKCBuZXcgTWF0cml4NCgpICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5hc3NpZ24oIFNrZWxldG9uLnByb3RvdHlwZSwge1xcblxcblxcdFxcdGNhbGN1bGF0ZUludmVyc2VzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5ib25lSW52ZXJzZXMgPSBbXTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy5ib25lcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgaW52ZXJzZSA9IG5ldyBNYXRyaXg0KCk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB0aGlzLmJvbmVzWyBpIF0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aW52ZXJzZS5nZXRJbnZlcnNlKCB0aGlzLmJvbmVzWyBpIF0ubWF0cml4V29ybGQgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5ib25lSW52ZXJzZXMucHVzaCggaW52ZXJzZSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHBvc2U6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgYm9uZSwgaSwgaWw7XFxuXFxuXFx0XFx0XFx0Ly8gcmVjb3ZlciB0aGUgYmluZC10aW1lIHdvcmxkIG1hdHJpY2VzXFxuXFxuXFx0XFx0XFx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy5ib25lcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRib25lID0gdGhpcy5ib25lc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdGlmICggYm9uZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRib25lLm1hdHJpeFdvcmxkLmdldEludmVyc2UoIHRoaXMuYm9uZUludmVyc2VzWyBpIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGNvbXB1dGUgdGhlIGxvY2FsIG1hdHJpY2VzLCBwb3NpdGlvbnMsIHJvdGF0aW9ucyBhbmQgc2NhbGVzXFxuXFxuXFx0XFx0XFx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy5ib25lcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRib25lID0gdGhpcy5ib25lc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdGlmICggYm9uZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGJvbmUucGFyZW50ICYmIGJvbmUucGFyZW50LmlzQm9uZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRib25lLm1hdHJpeC5nZXRJbnZlcnNlKCBib25lLnBhcmVudC5tYXRyaXhXb3JsZCApO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJvbmUubWF0cml4Lm11bHRpcGx5KCBib25lLm1hdHJpeFdvcmxkICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRib25lLm1hdHJpeC5jb3B5KCBib25lLm1hdHJpeFdvcmxkICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGJvbmUubWF0cml4LmRlY29tcG9zZSggYm9uZS5wb3NpdGlvbiwgYm9uZS5xdWF0ZXJuaW9uLCBib25lLnNjYWxlICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHVwZGF0ZTogKCBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIG9mZnNldE1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XFxuXFx0XFx0XFx0dmFyIGlkZW50aXR5TWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xcblxcblxcdFxcdFxcdFxcdHZhciBib25lcyA9IHRoaXMuYm9uZXM7XFxuXFx0XFx0XFx0XFx0dmFyIGJvbmVJbnZlcnNlcyA9IHRoaXMuYm9uZUludmVyc2VzO1xcblxcdFxcdFxcdFxcdHZhciBib25lTWF0cmljZXMgPSB0aGlzLmJvbmVNYXRyaWNlcztcXG5cXHRcXHRcXHRcXHR2YXIgYm9uZVRleHR1cmUgPSB0aGlzLmJvbmVUZXh0dXJlO1xcblxcblxcdFxcdFxcdFxcdC8vIGZsYXR0ZW4gYm9uZSBtYXRyaWNlcyB0byBhcnJheVxcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSBib25lcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBjb21wdXRlIHRoZSBvZmZzZXQgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgdGhlIG9yaWdpbmFsIHRyYW5zZm9ybVxcblxcblxcdFxcdFxcdFxcdFxcdHZhciBtYXRyaXggPSBib25lc1sgaSBdID8gYm9uZXNbIGkgXS5tYXRyaXhXb3JsZCA6IGlkZW50aXR5TWF0cml4O1xcblxcblxcdFxcdFxcdFxcdFxcdG9mZnNldE1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXgsIGJvbmVJbnZlcnNlc1sgaSBdICk7XFxuXFx0XFx0XFx0XFx0XFx0b2Zmc2V0TWF0cml4LnRvQXJyYXkoIGJvbmVNYXRyaWNlcywgaSAqIDE2ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggYm9uZVRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRib25lVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSApKCksXFxuXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IFNrZWxldG9uKCB0aGlzLmJvbmVzLCB0aGlzLmJvbmVJbnZlcnNlcyApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqIEBhdXRob3IgaWtlcnIgLyBodHRwOi8vdmVyb2xkLmNvbVxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEJvbmUoKSB7XFxuXFxuXFx0XFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdCb25lJztcXG5cXG5cXHR9XFxuXFxuXFx0Qm9uZS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBCb25lLFxcblxcblxcdFxcdGlzQm9uZTogdHJ1ZVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gU2tpbm5lZE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRNZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdTa2lubmVkTWVzaCc7XFxuXFxuXFx0XFx0dGhpcy5iaW5kTW9kZSA9ICdhdHRhY2hlZCc7XFxuXFx0XFx0dGhpcy5iaW5kTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcXG5cXHRcXHR0aGlzLmJpbmRNYXRyaXhJbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcXG5cXG5cXHRcXHR2YXIgYm9uZXMgPSB0aGlzLmluaXRCb25lcygpO1xcblxcdFxcdHZhciBza2VsZXRvbiA9IG5ldyBTa2VsZXRvbiggYm9uZXMgKTtcXG5cXG5cXHRcXHR0aGlzLmJpbmQoIHNrZWxldG9uLCB0aGlzLm1hdHJpeFdvcmxkICk7XFxuXFxuXFx0XFx0dGhpcy5ub3JtYWxpemVTa2luV2VpZ2h0cygpO1xcblxcblxcdH1cXG5cXG5cXHRTa2lubmVkTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBNZXNoLnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IFNraW5uZWRNZXNoLFxcblxcblxcdFxcdGlzU2tpbm5lZE1lc2g6IHRydWUsXFxuXFxuXFx0XFx0aW5pdEJvbmVzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGJvbmVzID0gW10sIGJvbmUsIGdib25lO1xcblxcdFxcdFxcdHZhciBpLCBpbDtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuZ2VvbWV0cnkgJiYgdGhpcy5nZW9tZXRyeS5ib25lcyAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdC8vIGZpcnN0LCBjcmVhdGUgYXJyYXkgb2YgJ0JvbmUnIG9iamVjdHMgZnJvbSBnZW9tZXRyeSBkYXRhXFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy5nZW9tZXRyeS5ib25lcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRnYm9uZSA9IHRoaXMuZ2VvbWV0cnkuYm9uZXNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBjcmVhdGUgbmV3ICdCb25lJyBvYmplY3RcXG5cXG5cXHRcXHRcXHRcXHRcXHRib25lID0gbmV3IEJvbmUoKTtcXG5cXHRcXHRcXHRcXHRcXHRib25lcy5wdXNoKCBib25lICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gYXBwbHkgdmFsdWVzXFxuXFxuXFx0XFx0XFx0XFx0XFx0Ym9uZS5uYW1lID0gZ2JvbmUubmFtZTtcXG5cXHRcXHRcXHRcXHRcXHRib25lLnBvc2l0aW9uLmZyb21BcnJheSggZ2JvbmUucG9zICk7XFxuXFx0XFx0XFx0XFx0XFx0Ym9uZS5xdWF0ZXJuaW9uLmZyb21BcnJheSggZ2JvbmUucm90cSApO1xcblxcdFxcdFxcdFxcdFxcdGlmICggZ2JvbmUuc2NsICE9PSB1bmRlZmluZWQgKSBib25lLnNjYWxlLmZyb21BcnJheSggZ2JvbmUuc2NsICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIHNlY29uZCwgY3JlYXRlIGJvbmUgaGllcmFyY2h5XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy5nZW9tZXRyeS5ib25lcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRnYm9uZSA9IHRoaXMuZ2VvbWV0cnkuYm9uZXNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoICggZ2JvbmUucGFyZW50ICE9PSAtIDEgKSAmJiAoIGdib25lLnBhcmVudCAhPT0gbnVsbCApICYmICggYm9uZXNbIGdib25lLnBhcmVudCBdICE9PSB1bmRlZmluZWQgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBzdWJzZXF1ZW50IGJvbmVzIGluIHRoZSBoaWVyYXJjaHlcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRib25lc1sgZ2JvbmUucGFyZW50IF0uYWRkKCBib25lc1sgaSBdICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyB0b3Btb3N0IGJvbmUsIGltbWVkaWF0ZSBjaGlsZCBvZiB0aGUgc2tpbm5lZCBtZXNoXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5hZGQoIGJvbmVzWyBpIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBub3cgdGhlIGJvbmVzIGFyZSBwYXJ0IG9mIHRoZSBzY2VuZSBncmFwaCBhbmQgY2hpbGRyZW4gb2YgdGhlIHNraW5uZWQgbWVzaC5cXG5cXHRcXHRcXHQvLyBsZXQncyB1cGRhdGUgdGhlIGNvcnJlc3BvbmRpbmcgbWF0cmljZXNcXG5cXG5cXHRcXHRcXHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGJvbmVzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YmluZDogZnVuY3Rpb24gKCBza2VsZXRvbiwgYmluZE1hdHJpeCApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnNrZWxldG9uID0gc2tlbGV0b247XFxuXFxuXFx0XFx0XFx0aWYgKCBiaW5kTWF0cml4ID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xcblxcblxcdFxcdFxcdFxcdHRoaXMuc2tlbGV0b24uY2FsY3VsYXRlSW52ZXJzZXMoKTtcXG5cXG5cXHRcXHRcXHRcXHRiaW5kTWF0cml4ID0gdGhpcy5tYXRyaXhXb3JsZDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5iaW5kTWF0cml4LmNvcHkoIGJpbmRNYXRyaXggKTtcXG5cXHRcXHRcXHR0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmdldEludmVyc2UoIGJpbmRNYXRyaXggKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHBvc2U6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnNrZWxldG9uLnBvc2UoKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG5vcm1hbGl6ZVNraW5XZWlnaHRzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHNjYWxlLCBpO1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5nZW9tZXRyeSAmJiB0aGlzLmdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPCB0aGlzLmdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgc3cgPSB0aGlzLmdlb21ldHJ5LnNraW5XZWlnaHRzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0c2NhbGUgPSAxLjAgLyBzdy5tYW5oYXR0YW5MZW5ndGgoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHNjYWxlICE9PSBJbmZpbml0eSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRzdy5tdWx0aXBseVNjYWxhciggc2NhbGUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHN3LnNldCggMSwgMCwgMCwgMCApOyAvLyBkbyBzb21ldGhpbmcgcmVhc29uYWJsZVxcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggdGhpcy5nZW9tZXRyeSAmJiB0aGlzLmdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHZlYyA9IG5ldyBWZWN0b3I0KCk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHNraW5XZWlnaHQgPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMuc2tpbldlaWdodDtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCBpID0gMDsgaSA8IHNraW5XZWlnaHQuY291bnQ7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmVjLnggPSBza2luV2VpZ2h0LmdldFgoIGkgKTtcXG5cXHRcXHRcXHRcXHRcXHR2ZWMueSA9IHNraW5XZWlnaHQuZ2V0WSggaSApO1xcblxcdFxcdFxcdFxcdFxcdHZlYy56ID0gc2tpbldlaWdodC5nZXRaKCBpICk7XFxuXFx0XFx0XFx0XFx0XFx0dmVjLncgPSBza2luV2VpZ2h0LmdldFcoIGkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzY2FsZSA9IDEuMCAvIHZlYy5tYW5oYXR0YW5MZW5ndGgoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHNjYWxlICE9PSBJbmZpbml0eSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2ZWMubXVsdGlwbHlTY2FsYXIoIHNjYWxlICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2ZWMuc2V0KCAxLCAwLCAwLCAwICk7IC8vIGRvIHNvbWV0aGluZyByZWFzb25hYmxlXFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHNraW5XZWlnaHQuc2V0WFlaVyggaSwgdmVjLngsIHZlYy55LCB2ZWMueiwgdmVjLncgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dXBkYXRlTWF0cml4V29ybGQ6IGZ1bmN0aW9uICggZm9yY2UgKSB7XFxuXFxuXFx0XFx0XFx0TWVzaC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuYmluZE1vZGUgPT09ICdhdHRhY2hlZCcgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5iaW5kTWF0cml4SW52ZXJzZS5nZXRJbnZlcnNlKCB0aGlzLm1hdHJpeFdvcmxkICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggdGhpcy5iaW5kTW9kZSA9PT0gJ2RldGFjaGVkJyApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmdldEludmVyc2UoIHRoaXMuYmluZE1hdHJpeCApO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU2tpbm5lZE1lc2g6IFVucmVjb2duaXplZCBiaW5kTW9kZTogJyArIHRoaXMuYmluZE1vZGUgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKlxcblxcdCAqIHBhcmFtZXRlcnMgPSB7XFxuXFx0ICogIGNvbG9yOiA8aGV4PixcXG5cXHQgKiAgb3BhY2l0eTogPGZsb2F0PixcXG5cXHQgKlxcblxcdCAqICBsaW5ld2lkdGg6IDxmbG9hdD4sXFxuXFx0ICogIGxpbmVjYXA6IFxcXCJyb3VuZFxcXCIsXFxuXFx0ICogIGxpbmVqb2luOiBcXFwicm91bmRcXFwiXFxuXFx0ICogfVxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIExpbmVCYXNpY01hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xcblxcblxcdFxcdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnTGluZUJhc2ljTWF0ZXJpYWwnO1xcblxcblxcdFxcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7XFxuXFxuXFx0XFx0dGhpcy5saW5ld2lkdGggPSAxO1xcblxcdFxcdHRoaXMubGluZWNhcCA9ICdyb3VuZCc7XFxuXFx0XFx0dGhpcy5saW5lam9pbiA9ICdyb3VuZCc7XFxuXFxuXFx0XFx0dGhpcy5saWdodHMgPSBmYWxzZTtcXG5cXG5cXHRcXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xcblxcblxcdH1cXG5cXG5cXHRMaW5lQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXRlcmlhbC5wcm90b3R5cGUgKTtcXG5cXHRMaW5lQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaW5lQmFzaWNNYXRlcmlhbDtcXG5cXG5cXHRMaW5lQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuaXNMaW5lQmFzaWNNYXRlcmlhbCA9IHRydWU7XFxuXFxuXFx0TGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXG5cXG5cXHRcXHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xcblxcblxcdFxcdHRoaXMubGluZXdpZHRoID0gc291cmNlLmxpbmV3aWR0aDtcXG5cXHRcXHR0aGlzLmxpbmVjYXAgPSBzb3VyY2UubGluZWNhcDtcXG5cXHRcXHR0aGlzLmxpbmVqb2luID0gc291cmNlLmxpbmVqb2luO1xcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBMaW5lKCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG1vZGUgKSB7XFxuXFxuXFx0XFx0aWYgKCBtb2RlID09PSAxICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpbmU6IHBhcmFtZXRlciBUSFJFRS5MaW5lUGllY2VzIG5vIGxvbmdlciBzdXBwb3J0ZWQuIENyZWF0ZWQgVEhSRUUuTGluZVNlZ21lbnRzIGluc3RlYWQuJyApO1xcblxcdFxcdFxcdHJldHVybiBuZXcgTGluZVNlZ21lbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdMaW5lJztcXG5cXG5cXHRcXHR0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCA/IGdlb21ldHJ5IDogbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XFxuXFx0XFx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbCA6IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmIH0gKTtcXG5cXG5cXHR9XFxuXFxuXFx0TGluZS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBMaW5lLFxcblxcblxcdFxcdGlzTGluZTogdHJ1ZSxcXG5cXG5cXHRcXHRyYXljYXN0OiAoIGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgaW52ZXJzZU1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XFxuXFx0XFx0XFx0dmFyIHJheSA9IG5ldyBSYXkoKTtcXG5cXHRcXHRcXHR2YXIgc3BoZXJlID0gbmV3IFNwaGVyZSgpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiByYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHByZWNpc2lvbiA9IHJheWNhc3Rlci5saW5lUHJlY2lzaW9uO1xcblxcdFxcdFxcdFxcdHZhciBwcmVjaXNpb25TcSA9IHByZWNpc2lvbiAqIHByZWNpc2lvbjtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xcblxcdFxcdFxcdFxcdHZhciBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQ2hlY2tpbmcgYm91bmRpbmdTcGhlcmUgZGlzdGFuY2UgdG8gcmF5XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xcblxcblxcdFxcdFxcdFxcdHNwaGVyZS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApO1xcblxcdFxcdFxcdFxcdHNwaGVyZS5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCByYXljYXN0ZXIucmF5LmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApID09PSBmYWxzZSApIHJldHVybjtcXG5cXG5cXHRcXHRcXHRcXHQvL1xcblxcblxcdFxcdFxcdFxcdGludmVyc2VNYXRyaXguZ2V0SW52ZXJzZSggbWF0cml4V29ybGQgKTtcXG5cXHRcXHRcXHRcXHRyYXkuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggaW52ZXJzZU1hdHJpeCApO1xcblxcblxcdFxcdFxcdFxcdHZhciB2U3RhcnQgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdFxcdHZhciB2RW5kID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHRcXHR2YXIgaW50ZXJTZWdtZW50ID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHRcXHR2YXIgaW50ZXJSYXkgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdFxcdHZhciBzdGVwID0gKCB0aGlzICYmIHRoaXMuaXNMaW5lU2VnbWVudHMgKSA/IDIgOiAxO1xcblxcblxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGluZGljZXMubGVuZ3RoIC0gMTsgaSA8IGw7IGkgKz0gc3RlcCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgYSA9IGluZGljZXNbIGkgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgYiA9IGluZGljZXNbIGkgKyAxIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dlN0YXJ0LmZyb21BcnJheSggcG9zaXRpb25zLCBhICogMyApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZFbmQuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGIgKiAzICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGRpc3RTcSA9IHJheS5kaXN0YW5jZVNxVG9TZWdtZW50KCB2U3RhcnQsIHZFbmQsIGludGVyUmF5LCBpbnRlclNlZ21lbnQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGRpc3RTcSA+IHByZWNpc2lvblNxICkgY29udGludWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aW50ZXJSYXkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7IC8vTW92ZSBiYWNrIHRvIHdvcmxkIHNwYWNlIGZvciBkaXN0YW5jZSBjYWxjdWxhdGlvblxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyUmF5ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGludGVyc2VjdHMucHVzaCgge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRpc3RhbmNlOiBkaXN0YW5jZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBwb2ludDogcmF5Y2FzdGVyLnJheS5hdCggZGlzdGFuY2UgKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwb2ludDogaW50ZXJTZWdtZW50LmNsb25lKCkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aW5kZXg6IGksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZmFjZTogbnVsbCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRmYWNlSW5kZXg6IG51bGwsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0OiB0aGlzXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHBvc2l0aW9ucy5sZW5ndGggLyAzIC0gMTsgaSA8IGw7IGkgKz0gc3RlcCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2U3RhcnQuZnJvbUFycmF5KCBwb3NpdGlvbnMsIDMgKiBpICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dkVuZC5mcm9tQXJyYXkoIHBvc2l0aW9ucywgMyAqIGkgKyAzICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGRpc3RTcSA9IHJheS5kaXN0YW5jZVNxVG9TZWdtZW50KCB2U3RhcnQsIHZFbmQsIGludGVyUmF5LCBpbnRlclNlZ21lbnQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGRpc3RTcSA+IHByZWNpc2lvblNxICkgY29udGludWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aW50ZXJSYXkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7IC8vTW92ZSBiYWNrIHRvIHdvcmxkIHNwYWNlIGZvciBkaXN0YW5jZSBjYWxjdWxhdGlvblxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyUmF5ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGludGVyc2VjdHMucHVzaCgge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRpc3RhbmNlOiBkaXN0YW5jZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBwb2ludDogcmF5Y2FzdGVyLnJheS5hdCggZGlzdGFuY2UgKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwb2ludDogaW50ZXJTZWdtZW50LmNsb25lKCkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aW5kZXg6IGksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZmFjZTogbnVsbCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRmYWNlSW5kZXg6IG51bGwsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0OiB0aGlzXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggZ2VvbWV0cnkuaXNHZW9tZXRyeSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcXG5cXHRcXHRcXHRcXHRcXHR2YXIgbmJWZXJ0aWNlcyA9IHZlcnRpY2VzLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBuYlZlcnRpY2VzIC0gMTsgaSArPSBzdGVwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBkaXN0U3EgPSByYXkuZGlzdGFuY2VTcVRvU2VnbWVudCggdmVydGljZXNbIGkgXSwgdmVydGljZXNbIGkgKyAxIF0sIGludGVyUmF5LCBpbnRlclNlZ21lbnQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGRpc3RTcSA+IHByZWNpc2lvblNxICkgY29udGludWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aW50ZXJSYXkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7IC8vTW92ZSBiYWNrIHRvIHdvcmxkIHNwYWNlIGZvciBkaXN0YW5jZSBjYWxjdWxhdGlvblxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyUmF5ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGludGVyc2VjdHMucHVzaCgge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRpc3RhbmNlOiBkaXN0YW5jZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBwb2ludDogcmF5Y2FzdGVyLnJheS5hdCggZGlzdGFuY2UgKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwb2ludDogaW50ZXJTZWdtZW50LmNsb25lKCkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aW5kZXg6IGksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZmFjZTogbnVsbCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmYWNlSW5kZXg6IG51bGwsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0OiB0aGlzXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCkgKSxcXG5cXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gTGluZVNlZ21lbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0TGluZS5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnTGluZVNlZ21lbnRzJztcXG5cXG5cXHR9XFxuXFxuXFx0TGluZVNlZ21lbnRzLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExpbmUucHJvdG90eXBlICksIHtcXG5cXG5cXHRcXHRjb25zdHJ1Y3RvcjogTGluZVNlZ21lbnRzLFxcblxcblxcdFxcdGlzTGluZVNlZ21lbnRzOiB0cnVlXFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbWdyZXRlciAvIGh0dHA6Ly9naXRodWIuY29tL21ncmV0ZXJcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBMaW5lTG9vcCggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xcblxcblxcdFxcdExpbmUuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ0xpbmVMb29wJztcXG5cXG5cXHR9XFxuXFxuXFx0TGluZUxvb3AucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTGluZS5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBMaW5lTG9vcCxcXG5cXG5cXHRcXHRpc0xpbmVMb29wOiB0cnVlLFxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICpcXG5cXHQgKiBwYXJhbWV0ZXJzID0ge1xcblxcdCAqICBjb2xvcjogPGhleD4sXFxuXFx0ICogIG9wYWNpdHk6IDxmbG9hdD4sXFxuXFx0ICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXG5cXHQgKlxcblxcdCAqICBzaXplOiA8ZmxvYXQ+LFxcblxcdCAqICBzaXplQXR0ZW51YXRpb246IDxib29sPlxcblxcdCAqIH1cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBQb2ludHNNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcXG5cXG5cXHRcXHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1BvaW50c01hdGVyaWFsJztcXG5cXG5cXHRcXHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApO1xcblxcblxcdFxcdHRoaXMubWFwID0gbnVsbDtcXG5cXG5cXHRcXHR0aGlzLnNpemUgPSAxO1xcblxcdFxcdHRoaXMuc2l6ZUF0dGVudWF0aW9uID0gdHJ1ZTtcXG5cXG5cXHRcXHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xcblxcblxcdFxcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XFxuXFxuXFx0fVxcblxcblxcdFBvaW50c01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hdGVyaWFsLnByb3RvdHlwZSApO1xcblxcdFBvaW50c01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvaW50c01hdGVyaWFsO1xcblxcblxcdFBvaW50c01hdGVyaWFsLnByb3RvdHlwZS5pc1BvaW50c01hdGVyaWFsID0gdHJ1ZTtcXG5cXG5cXHRQb2ludHNNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcblxcblxcdFxcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XFxuXFxuXFx0XFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xcblxcblxcdFxcdHRoaXMuc2l6ZSA9IHNvdXJjZS5zaXplO1xcblxcdFxcdHRoaXMuc2l6ZUF0dGVudWF0aW9uID0gc291cmNlLnNpemVBdHRlbnVhdGlvbjtcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gUG9pbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdQb2ludHMnO1xcblxcblxcdFxcdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkID8gZ2VvbWV0cnkgOiBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcXG5cXHRcXHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsIDogbmV3IFBvaW50c01hdGVyaWFsKCB7IGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYgfSApO1xcblxcblxcdH1cXG5cXG5cXHRQb2ludHMucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICksIHtcXG5cXG5cXHRcXHRjb25zdHJ1Y3RvcjogUG9pbnRzLFxcblxcblxcdFxcdGlzUG9pbnRzOiB0cnVlLFxcblxcblxcdFxcdHJheWNhc3Q6ICggZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcXG5cXHRcXHRcXHR2YXIgcmF5ID0gbmV3IFJheSgpO1xcblxcdFxcdFxcdHZhciBzcGhlcmUgPSBuZXcgU3BoZXJlKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgb2JqZWN0ID0gdGhpcztcXG5cXHRcXHRcXHRcXHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xcblxcdFxcdFxcdFxcdHZhciBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XFxuXFx0XFx0XFx0XFx0dmFyIHRocmVzaG9sZCA9IHJheWNhc3Rlci5wYXJhbXMuUG9pbnRzLnRocmVzaG9sZDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZSBkaXN0YW5jZSB0byByYXlcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XFxuXFxuXFx0XFx0XFx0XFx0c3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XFxuXFx0XFx0XFx0XFx0c3BoZXJlLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcXG5cXHRcXHRcXHRcXHRzcGhlcmUucmFkaXVzICs9IHRocmVzaG9sZDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHJheWNhc3Rlci5yYXkuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkgPT09IGZhbHNlICkgcmV0dXJuO1xcblxcblxcdFxcdFxcdFxcdC8vXFxuXFxuXFx0XFx0XFx0XFx0aW52ZXJzZU1hdHJpeC5nZXRJbnZlcnNlKCBtYXRyaXhXb3JsZCApO1xcblxcdFxcdFxcdFxcdHJheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBpbnZlcnNlTWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGxvY2FsVGhyZXNob2xkID0gdGhyZXNob2xkIC8gKCAoIHRoaXMuc2NhbGUueCArIHRoaXMuc2NhbGUueSArIHRoaXMuc2NhbGUueiApIC8gMyApO1xcblxcdFxcdFxcdFxcdHZhciBsb2NhbFRocmVzaG9sZFNxID0gbG9jYWxUaHJlc2hvbGQgKiBsb2NhbFRocmVzaG9sZDtcXG5cXHRcXHRcXHRcXHR2YXIgcG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uIHRlc3RQb2ludCggcG9pbnQsIGluZGV4ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciByYXlQb2ludERpc3RhbmNlU3EgPSByYXkuZGlzdGFuY2VTcVRvUG9pbnQoIHBvaW50ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCByYXlQb2ludERpc3RhbmNlU3EgPCBsb2NhbFRocmVzaG9sZFNxICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBpbnRlcnNlY3RQb2ludCA9IHJheS5jbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludCApO1xcblxcdFxcdFxcdFxcdFxcdFxcdGludGVyc2VjdFBvaW50LmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlcnNlY3RQb2ludCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSByZXR1cm47XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aW50ZXJzZWN0cy5wdXNoKCB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRpc3RhbmNlVG9SYXk6IE1hdGguc3FydCggcmF5UG9pbnREaXN0YW5jZVNxICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cG9pbnQ6IGludGVyc2VjdFBvaW50LmNsb25lKCksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aW5kZXg6IGluZGV4LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZhY2U6IG51bGwsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0OiBvYmplY3RcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xcblxcdFxcdFxcdFxcdFxcdHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggaW5kZXggIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGluZGljZXMgPSBpbmRleC5hcnJheTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgYSA9IGluZGljZXNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwb3NpdGlvbi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYSAqIDMgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0ZXN0UG9pbnQoIHBvc2l0aW9uLCBhICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcG9zaXRpb25zLmxlbmd0aCAvIDM7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uLmZyb21BcnJheSggcG9zaXRpb25zLCBpICogMyApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRlc3RQb2ludCggcG9zaXRpb24sIGkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0ZXN0UG9pbnQoIHZlcnRpY2VzWyBpIF0sIGkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpICksXFxuXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwgKS5jb3B5KCB0aGlzICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEdyb3VwKCkge1xcblxcblxcdFxcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnR3JvdXAnO1xcblxcblxcdH1cXG5cXG5cXHRHcm91cC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBHcm91cCxcXG5cXG5cXHRcXHRpc0dyb3VwOiB0cnVlXFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gVmlkZW9UZXh0dXJlKCB2aWRlbywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xcblxcblxcdFxcdFRleHR1cmUuY2FsbCggdGhpcywgdmlkZW8sIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xcblxcblxcdFxcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XFxuXFxuXFx0XFx0Ly8gU2V0IG5lZWRzVXBkYXRlIHdoZW4gZmlyc3QgZnJhbWUgaXMgcmVhZHlcXG5cXG5cXHRcXHR2YXIgc2NvcGUgPSB0aGlzO1xcblxcblxcdFxcdGZ1bmN0aW9uIG9uTG9hZGVkKCkge1xcblxcblxcdFxcdFxcdHZpZGVvLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdsb2FkZWRkYXRhJywgb25Mb2FkZWQsIGZhbHNlICk7XFxuXFx0XFx0XFx0c2NvcGUubmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR2aWRlby5hZGRFdmVudExpc3RlbmVyKCAnbG9hZGVkZGF0YScsIG9uTG9hZGVkLCBmYWxzZSApO1xcblxcblxcdH1cXG5cXG5cXHRWaWRlb1RleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggVGV4dHVyZS5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBWaWRlb1RleHR1cmUsXFxuXFxuXFx0XFx0aXNWaWRlb1RleHR1cmU6IHRydWUsXFxuXFxuXFx0XFx0dXBkYXRlOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHZpZGVvID0gdGhpcy5pbWFnZTtcXG5cXG5cXHRcXHRcXHRpZiAoIHZpZGVvLnJlYWR5U3RhdGUgPj0gdmlkZW8uSEFWRV9DVVJSRU5UX0RBVEEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBDb21wcmVzc2VkVGV4dHVyZSggbWlwbWFwcywgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBhbmlzb3Ryb3B5LCBlbmNvZGluZyApIHtcXG5cXG5cXHRcXHRUZXh0dXJlLmNhbGwoIHRoaXMsIG51bGwsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSwgZW5jb2RpbmcgKTtcXG5cXG5cXHRcXHR0aGlzLmltYWdlID0geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XFxuXFx0XFx0dGhpcy5taXBtYXBzID0gbWlwbWFwcztcXG5cXG5cXHRcXHQvLyBubyBmbGlwcGluZyBmb3IgY3ViZSB0ZXh0dXJlc1xcblxcdFxcdC8vIChhbHNvIGZsaXBwaW5nIGRvZXNuJ3Qgd29yayBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlcyApXFxuXFxuXFx0XFx0dGhpcy5mbGlwWSA9IGZhbHNlO1xcblxcblxcdFxcdC8vIGNhbid0IGdlbmVyYXRlIG1pcG1hcHMgZm9yIGNvbXByZXNzZWQgdGV4dHVyZXNcXG5cXHRcXHQvLyBtaXBzIG11c3QgYmUgZW1iZWRkZWQgaW4gRERTIGZpbGVzXFxuXFxuXFx0XFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcXG5cXG5cXHR9XFxuXFxuXFx0Q29tcHJlc3NlZFRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVGV4dHVyZS5wcm90b3R5cGUgKTtcXG5cXHRDb21wcmVzc2VkVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb21wcmVzc2VkVGV4dHVyZTtcXG5cXG5cXHRDb21wcmVzc2VkVGV4dHVyZS5wcm90b3R5cGUuaXNDb21wcmVzc2VkVGV4dHVyZSA9IHRydWU7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBNYXR0IERlc0xhdXJpZXJzIC8gQG1hdHRkZXNsXFxuXFx0ICogQGF1dGhvciBhdGl4IC8gYXJ0aHVyc2lsYmVyLmRlXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gRGVwdGhUZXh0dXJlKCB3aWR0aCwgaGVpZ2h0LCB0eXBlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBhbmlzb3Ryb3B5LCBmb3JtYXQgKSB7XFxuXFxuXFx0XFx0Zm9ybWF0ID0gZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBmb3JtYXQgOiBEZXB0aEZvcm1hdDtcXG5cXG5cXHRcXHRpZiAoIGZvcm1hdCAhPT0gRGVwdGhGb3JtYXQgJiYgZm9ybWF0ICE9PSBEZXB0aFN0ZW5jaWxGb3JtYXQgKSB7XFxuXFxuXFx0XFx0XFx0dGhyb3cgbmV3IEVycm9yKCAnRGVwdGhUZXh0dXJlIGZvcm1hdCBtdXN0IGJlIGVpdGhlciBUSFJFRS5EZXB0aEZvcm1hdCBvciBUSFJFRS5EZXB0aFN0ZW5jaWxGb3JtYXQnICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggdHlwZSA9PT0gdW5kZWZpbmVkICYmIGZvcm1hdCA9PT0gRGVwdGhGb3JtYXQgKSB0eXBlID0gVW5zaWduZWRTaG9ydFR5cGU7XFxuXFx0XFx0aWYgKCB0eXBlID09PSB1bmRlZmluZWQgJiYgZm9ybWF0ID09PSBEZXB0aFN0ZW5jaWxGb3JtYXQgKSB0eXBlID0gVW5zaWduZWRJbnQyNDhUeXBlO1xcblxcblxcdFxcdFRleHR1cmUuY2FsbCggdGhpcywgbnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XFxuXFxuXFx0XFx0dGhpcy5pbWFnZSA9IHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xcblxcblxcdFxcdHRoaXMubWFnRmlsdGVyID0gbWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtYWdGaWx0ZXIgOiBOZWFyZXN0RmlsdGVyO1xcblxcdFxcdHRoaXMubWluRmlsdGVyID0gbWluRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtaW5GaWx0ZXIgOiBOZWFyZXN0RmlsdGVyO1xcblxcblxcdFxcdHRoaXMuZmxpcFkgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLmdlbmVyYXRlTWlwbWFwc1xcdD0gZmFsc2U7XFxuXFxuXFx0fVxcblxcblxcdERlcHRoVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUZXh0dXJlLnByb3RvdHlwZSApO1xcblxcdERlcHRoVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEZXB0aFRleHR1cmU7XFxuXFx0RGVwdGhUZXh0dXJlLnByb3RvdHlwZS5pc0RlcHRoVGV4dHVyZSA9IHRydWU7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFdpcmVmcmFtZUdlb21ldHJ5KCBnZW9tZXRyeSApIHtcXG5cXG5cXHRcXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1dpcmVmcmFtZUdlb21ldHJ5JztcXG5cXG5cXHRcXHQvLyBidWZmZXJcXG5cXG5cXHRcXHR2YXIgdmVydGljZXMgPSBbXTtcXG5cXG5cXHRcXHQvLyBoZWxwZXIgdmFyaWFibGVzXFxuXFxuXFx0XFx0dmFyIGksIGosIGwsIG8sIG9sO1xcblxcdFxcdHZhciBlZGdlID0gWyAwLCAwIF0sIGVkZ2VzID0ge30sIGUsIGVkZ2UxLCBlZGdlMjtcXG5cXHRcXHR2YXIga2V5LCBrZXlzID0gWyAnYScsICdiJywgJ2MnIF07XFxuXFx0XFx0dmFyIHZlcnRleDtcXG5cXG5cXHRcXHQvLyBkaWZmZXJlbnQgbG9naWMgZm9yIEdlb21ldHJ5IGFuZCBCdWZmZXJHZW9tZXRyeVxcblxcblxcdFxcdGlmICggZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNHZW9tZXRyeSApIHtcXG5cXG5cXHRcXHRcXHQvLyBjcmVhdGUgYSBkYXRhIHN0cnVjdHVyZSB0aGF0IGNvbnRhaW5zIGFsbCBlZGdlcyB3aXRob3V0IGR1cGxpY2F0ZXNcXG5cXG5cXHRcXHRcXHR2YXIgZmFjZXMgPSBnZW9tZXRyeS5mYWNlcztcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIGogPSAwOyBqIDwgMzsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRlZGdlMSA9IGZhY2VbIGtleXNbIGogXSBdO1xcblxcdFxcdFxcdFxcdFxcdGVkZ2UyID0gZmFjZVsga2V5c1sgKCBqICsgMSApICUgMyBdIF07XFxuXFx0XFx0XFx0XFx0XFx0ZWRnZVsgMCBdID0gTWF0aC5taW4oIGVkZ2UxLCBlZGdlMiApOyAvLyBzb3J0aW5nIHByZXZlbnRzIGR1cGxpY2F0ZXNcXG5cXHRcXHRcXHRcXHRcXHRlZGdlWyAxIF0gPSBNYXRoLm1heCggZWRnZTEsIGVkZ2UyICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0a2V5ID0gZWRnZVsgMCBdICsgJywnICsgZWRnZVsgMSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggZWRnZXNbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWRnZXNbIGtleSBdID0geyBpbmRleDE6IGVkZ2VbIDAgXSwgaW5kZXgyOiBlZGdlWyAxIF0gfTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlc1xcblxcblxcdFxcdFxcdGZvciAoIGtleSBpbiBlZGdlcyApIHtcXG5cXG5cXHRcXHRcXHRcXHRlID0gZWRnZXNbIGtleSBdO1xcblxcblxcdFxcdFxcdFxcdHZlcnRleCA9IGdlb21ldHJ5LnZlcnRpY2VzWyBlLmluZGV4MSBdO1xcblxcdFxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcXG5cXG5cXHRcXHRcXHRcXHR2ZXJ0ZXggPSBnZW9tZXRyeS52ZXJ0aWNlc1sgZS5pbmRleDIgXTtcXG5cXHRcXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0gZWxzZSBpZiAoIGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHBvc2l0aW9uLCBpbmRpY2VzLCBncm91cHM7XFxuXFx0XFx0XFx0dmFyIGdyb3VwLCBzdGFydCwgY291bnQ7XFxuXFx0XFx0XFx0dmFyIGluZGV4MSwgaW5kZXgyO1xcblxcblxcdFxcdFxcdHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBpbmRleGVkIEJ1ZmZlckdlb21ldHJ5XFxuXFxuXFx0XFx0XFx0XFx0cG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xcblxcdFxcdFxcdFxcdGluZGljZXMgPSBnZW9tZXRyeS5pbmRleDtcXG5cXHRcXHRcXHRcXHRncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBncm91cHMubGVuZ3RoID09PSAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGdyb3VwcyA9IFsgeyBzdGFydDogMCwgY291bnQ6IGluZGljZXMuY291bnQsIG1hdGVyaWFsSW5kZXg6IDAgfSBdO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBjcmVhdGUgYSBkYXRhIHN0cnVjdHVyZSB0aGF0IGNvbnRhaW5zIGFsbCBlZ2VzIHdpdGhvdXQgZHVwbGljYXRlc1xcblxcblxcdFxcdFxcdFxcdGZvciAoIG8gPSAwLCBvbCA9IGdyb3Vwcy5sZW5ndGg7IG8gPCBvbDsgKysgbyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRncm91cCA9IGdyb3Vwc1sgbyBdO1xcblxcblxcdFxcdFxcdFxcdFxcdHN0YXJ0ID0gZ3JvdXAuc3RhcnQ7XFxuXFx0XFx0XFx0XFx0XFx0Y291bnQgPSBncm91cC5jb3VudDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCBpID0gc3RhcnQsIGwgPSAoIHN0YXJ0ICsgY291bnQgKTsgaSA8IGw7IGkgKz0gMyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCBqID0gMDsgaiA8IDM7IGogKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWRnZTEgPSBpbmRpY2VzLmdldFgoIGkgKyBqICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWRnZTIgPSBpbmRpY2VzLmdldFgoIGkgKyAoIGogKyAxICkgJSAzICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWRnZVsgMCBdID0gTWF0aC5taW4oIGVkZ2UxLCBlZGdlMiApOyAvLyBzb3J0aW5nIHByZXZlbnRzIGR1cGxpY2F0ZXNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRlZGdlWyAxIF0gPSBNYXRoLm1heCggZWRnZTEsIGVkZ2UyICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0a2V5ID0gZWRnZVsgMCBdICsgJywnICsgZWRnZVsgMSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggZWRnZXNbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWRnZXNbIGtleSBdID0geyBpbmRleDE6IGVkZ2VbIDAgXSwgaW5kZXgyOiBlZGdlWyAxIF0gfTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gZ2VuZXJhdGUgdmVydGljZXNcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCBrZXkgaW4gZWRnZXMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZSA9IGVkZ2VzWyBrZXkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0ZXguZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGUuaW5kZXgxICk7XFxuXFx0XFx0XFx0XFx0XFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xcblxcblxcdFxcdFxcdFxcdFxcdHZlcnRleC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgZS5pbmRleDIgKTtcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gbm9uLWluZGV4ZWQgQnVmZmVyR2VvbWV0cnlcXG5cXG5cXHRcXHRcXHRcXHRwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggaSA9IDAsIGwgPSAoIHBvc2l0aW9uLmNvdW50IC8gMyApOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCBqID0gMDsgaiA8IDM7IGogKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gdGhyZWUgZWRnZXMgcGVyIHRyaWFuZ2xlLCBhbiBlZGdlIGlzIHJlcHJlc2VudGVkIGFzIChpbmRleDEsIGluZGV4MilcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBlLmcuIHRoZSBmaXJzdCB0cmlhbmdsZSBoYXMgdGhlIGZvbGxvd2luZyBlZGdlczogKDAsMSksKDEsMiksKDIsMClcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpbmRleDEgPSAzICogaSArIGo7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmVydGV4LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBpbmRleDEgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aW5kZXgyID0gMyAqIGkgKyAoICggaiArIDEgKSAlIDMgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2ZXJ0ZXguZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGluZGV4MiApO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gYnVpbGQgZ2VvbWV0cnlcXG5cXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcXG5cXG5cXHR9XFxuXFxuXFx0V2lyZWZyYW1lR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XFxuXFx0V2lyZWZyYW1lR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV2lyZWZyYW1lR2VvbWV0cnk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciB6ejg1IC8gaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcXG5cXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xcblxcdCAqXFxuXFx0ICogUGFyYW1ldHJpYyBTdXJmYWNlcyBHZW9tZXRyeVxcblxcdCAqIGJhc2VkIG9uIHRoZSBicmlsbGlhbnQgYXJ0aWNsZSBieSBAcHJpZGVvdXQgaHR0cDovL3ByaWRlb3V0Lm5ldC9ibG9nLz9wPTQ0XFxuXFx0ICovXFxuXFxuXFx0Ly8gUGFyYW1ldHJpY0dlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gUGFyYW1ldHJpY0dlb21ldHJ5KCBmdW5jLCBzbGljZXMsIHN0YWNrcyApIHtcXG5cXG5cXHRcXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1BhcmFtZXRyaWNHZW9tZXRyeSc7XFxuXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcblxcdFxcdFxcdGZ1bmM6IGZ1bmMsXFxuXFx0XFx0XFx0c2xpY2VzOiBzbGljZXMsXFxuXFx0XFx0XFx0c3RhY2tzOiBzdGFja3NcXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgUGFyYW1ldHJpY0J1ZmZlckdlb21ldHJ5KCBmdW5jLCBzbGljZXMsIHN0YWNrcyApICk7XFxuXFx0XFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XFxuXFxuXFx0fVxcblxcblxcdFBhcmFtZXRyaWNHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcXG5cXHRQYXJhbWV0cmljR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGFyYW1ldHJpY0dlb21ldHJ5O1xcblxcblxcdC8vIFBhcmFtZXRyaWNCdWZmZXJHZW9tZXRyeVxcblxcblxcdGZ1bmN0aW9uIFBhcmFtZXRyaWNCdWZmZXJHZW9tZXRyeSggZnVuYywgc2xpY2VzLCBzdGFja3MgKSB7XFxuXFxuXFx0XFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdQYXJhbWV0cmljQnVmZmVyR2VvbWV0cnknO1xcblxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXG5cXHRcXHRcXHRmdW5jOiBmdW5jLFxcblxcdFxcdFxcdHNsaWNlczogc2xpY2VzLFxcblxcdFxcdFxcdHN0YWNrczogc3RhY2tzXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBidWZmZXJzXFxuXFxuXFx0XFx0dmFyIGluZGljZXMgPSBbXTtcXG5cXHRcXHR2YXIgdmVydGljZXMgPSBbXTtcXG5cXHRcXHR2YXIgbm9ybWFscyA9IFtdO1xcblxcdFxcdHZhciB1dnMgPSBbXTtcXG5cXG5cXHRcXHR2YXIgRVBTID0gMC4wMDAwMTtcXG5cXG5cXHRcXHR2YXIgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHR2YXIgcDAgPSBuZXcgVmVjdG9yMygpLCBwMSA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0dmFyIHB1ID0gbmV3IFZlY3RvcjMoKSwgcHYgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdHZhciBpLCBqO1xcblxcblxcdFxcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcXG5cXG5cXHRcXHR2YXIgc2xpY2VDb3VudCA9IHNsaWNlcyArIDE7XFxuXFxuXFx0XFx0Zm9yICggaSA9IDA7IGkgPD0gc3RhY2tzOyBpICsrICkge1xcblxcblxcdFxcdFxcdHZhciB2ID0gaSAvIHN0YWNrcztcXG5cXG5cXHRcXHRcXHRmb3IgKCBqID0gMDsgaiA8PSBzbGljZXM7IGogKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHUgPSBqIC8gc2xpY2VzO1xcblxcblxcdFxcdFxcdFxcdC8vIHZlcnRleFxcblxcblxcdFxcdFxcdFxcdHAwID0gZnVuYyggdSwgdiwgcDAgKTtcXG5cXHRcXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCBwMC54LCBwMC55LCBwMC56ICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gbm9ybWFsXFxuXFxuXFx0XFx0XFx0XFx0Ly8gYXBwcm94aW1hdGUgdGFuZ2VudCB2ZWN0b3JzIHZpYSBmaW5pdGUgZGlmZmVyZW5jZXNcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHUgLSBFUFMgPj0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRwMSA9IGZ1bmMoIHUgLSBFUFMsIHYsIHAxICk7XFxuXFx0XFx0XFx0XFx0XFx0cHUuc3ViVmVjdG9ycyggcDAsIHAxICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRwMSA9IGZ1bmMoIHUgKyBFUFMsIHYsIHAxICk7XFxuXFx0XFx0XFx0XFx0XFx0cHUuc3ViVmVjdG9ycyggcDEsIHAwICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggdiAtIEVQUyA+PSAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHAxID0gZnVuYyggdSwgdiAtIEVQUywgcDEgKTtcXG5cXHRcXHRcXHRcXHRcXHRwdi5zdWJWZWN0b3JzKCBwMCwgcDEgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdHAxID0gZnVuYyggdSwgdiArIEVQUywgcDEgKTtcXG5cXHRcXHRcXHRcXHRcXHRwdi5zdWJWZWN0b3JzKCBwMSwgcDAgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gY3Jvc3MgcHJvZHVjdCBvZiB0YW5nZW50IHZlY3RvcnMgcmV0dXJucyBzdXJmYWNlIG5vcm1hbFxcblxcblxcdFxcdFxcdFxcdG5vcm1hbC5jcm9zc1ZlY3RvcnMoIHB1LCBwdiApLm5vcm1hbGl6ZSgpO1xcblxcdFxcdFxcdFxcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xcblxcblxcdFxcdFxcdFxcdC8vIHV2XFxuXFxuXFx0XFx0XFx0XFx0dXZzLnB1c2goIHUsIHYgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGdlbmVyYXRlIGluZGljZXNcXG5cXG5cXHRcXHRmb3IgKCBpID0gMDsgaSA8IHN0YWNrczsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRmb3IgKCBqID0gMDsgaiA8IHNsaWNlczsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgYSA9IGkgKiBzbGljZUNvdW50ICsgajtcXG5cXHRcXHRcXHRcXHR2YXIgYiA9IGkgKiBzbGljZUNvdW50ICsgaiArIDE7XFxuXFx0XFx0XFx0XFx0dmFyIGMgPSAoIGkgKyAxICkgKiBzbGljZUNvdW50ICsgaiArIDE7XFxuXFx0XFx0XFx0XFx0dmFyIGQgPSAoIGkgKyAxICkgKiBzbGljZUNvdW50ICsgajtcXG5cXG5cXHRcXHRcXHRcXHQvLyBmYWNlcyBvbmUgYW5kIHR3b1xcblxcblxcdFxcdFxcdFxcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xcblxcdFxcdFxcdFxcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gYnVpbGQgZ2VvbWV0cnlcXG5cXG5cXHRcXHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xcblxcblxcdH1cXG5cXG5cXHRQYXJhbWV0cmljQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XFxuXFx0UGFyYW1ldHJpY0J1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBhcmFtZXRyaWNCdWZmZXJHZW9tZXRyeTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGNsb2Nrd29ya2dlZWsgLyBodHRwczovL2dpdGh1Yi5jb20vY2xvY2t3b3JrZ2Vla1xcblxcdCAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcXG5cXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcXG5cXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xcblxcdCAqL1xcblxcblxcdC8vIFBvbHloZWRyb25HZW9tZXRyeVxcblxcblxcdGZ1bmN0aW9uIFBvbHloZWRyb25HZW9tZXRyeSggdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICkge1xcblxcblxcdFxcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnUG9seWhlZHJvbkdlb21ldHJ5JztcXG5cXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxuXFx0XFx0XFx0dmVydGljZXM6IHZlcnRpY2VzLFxcblxcdFxcdFxcdGluZGljZXM6IGluZGljZXMsXFxuXFx0XFx0XFx0cmFkaXVzOiByYWRpdXMsXFxuXFx0XFx0XFx0ZGV0YWlsOiBkZXRhaWxcXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5KCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKSApO1xcblxcdFxcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xcblxcblxcdH1cXG5cXG5cXHRQb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XFxuXFx0UG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvbHloZWRyb25HZW9tZXRyeTtcXG5cXG5cXHQvLyBQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnkoIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApIHtcXG5cXG5cXHRcXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1BvbHloZWRyb25CdWZmZXJHZW9tZXRyeSc7XFxuXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcblxcdFxcdFxcdHZlcnRpY2VzOiB2ZXJ0aWNlcyxcXG5cXHRcXHRcXHRpbmRpY2VzOiBpbmRpY2VzLFxcblxcdFxcdFxcdHJhZGl1czogcmFkaXVzLFxcblxcdFxcdFxcdGRldGFpbDogZGV0YWlsXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRyYWRpdXMgPSByYWRpdXMgfHwgMTtcXG5cXHRcXHRkZXRhaWwgPSBkZXRhaWwgfHwgMDtcXG5cXG5cXHRcXHQvLyBkZWZhdWx0IGJ1ZmZlciBkYXRhXFxuXFxuXFx0XFx0dmFyIHZlcnRleEJ1ZmZlciA9IFtdO1xcblxcdFxcdHZhciB1dkJ1ZmZlciA9IFtdO1xcblxcblxcdFxcdC8vIHRoZSBzdWJkaXZpc2lvbiBjcmVhdGVzIHRoZSB2ZXJ0ZXggYnVmZmVyIGRhdGFcXG5cXG5cXHRcXHRzdWJkaXZpZGUoIGRldGFpbCApO1xcblxcblxcdFxcdC8vIGFsbCB2ZXJ0aWNlcyBzaG91bGQgbGllIG9uIGEgY29uY2VwdHVhbCBzcGhlcmUgd2l0aCBhIGdpdmVuIHJhZGl1c1xcblxcblxcdFxcdGFwcHBseVJhZGl1cyggcmFkaXVzICk7XFxuXFxuXFx0XFx0Ly8gZmluYWxseSwgY3JlYXRlIHRoZSB1diBkYXRhXFxuXFxuXFx0XFx0Z2VuZXJhdGVVVnMoKTtcXG5cXG5cXHRcXHQvLyBidWlsZCBub24taW5kZXhlZCBnZW9tZXRyeVxcblxcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGV4QnVmZmVyLCAzICkgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0ZXhCdWZmZXIuc2xpY2UoKSwgMyApICk7XFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dkJ1ZmZlciwgMiApICk7XFxuXFxuXFx0XFx0aWYgKCBkZXRhaWwgPT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpOyAvLyBmbGF0IG5vcm1hbHNcXG5cXG5cXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdHRoaXMubm9ybWFsaXplTm9ybWFscygpOyAvLyBzbW9vdGggbm9ybWFsc1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBoZWxwZXIgZnVuY3Rpb25zXFxuXFxuXFx0XFx0ZnVuY3Rpb24gc3ViZGl2aWRlKCBkZXRhaWwgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGEgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdHZhciBiID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgYyA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0Ly8gaXRlcmF0ZSBvdmVyIGFsbCBmYWNlcyBhbmQgYXBwbHkgYSBzdWJkaXZpc29uIHdpdGggdGhlIGdpdmVuIGRldGFpbCB2YWx1ZVxcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpICs9IDMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gZ2V0IHRoZSB2ZXJ0aWNlcyBvZiB0aGUgZmFjZVxcblxcblxcdFxcdFxcdFxcdGdldFZlcnRleEJ5SW5kZXgoIGluZGljZXNbIGkgKyAwIF0sIGEgKTtcXG5cXHRcXHRcXHRcXHRnZXRWZXJ0ZXhCeUluZGV4KCBpbmRpY2VzWyBpICsgMSBdLCBiICk7XFxuXFx0XFx0XFx0XFx0Z2V0VmVydGV4QnlJbmRleCggaW5kaWNlc1sgaSArIDIgXSwgYyApO1xcblxcblxcdFxcdFxcdFxcdC8vIHBlcmZvcm0gc3ViZGl2aXNpb25cXG5cXG5cXHRcXHRcXHRcXHRzdWJkaXZpZGVGYWNlKCBhLCBiLCBjLCBkZXRhaWwgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHN1YmRpdmlkZUZhY2UoIGEsIGIsIGMsIGRldGFpbCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgY29scyA9IE1hdGgucG93KCAyLCBkZXRhaWwgKTtcXG5cXG5cXHRcXHRcXHQvLyB3ZSB1c2UgdGhpcyBtdWx0aWRpbWVuc2lvbmFsIGFycmF5IGFzIGEgZGF0YSBzdHJ1Y3R1cmUgZm9yIGNyZWF0aW5nIHRoZSBzdWJkaXZpc2lvblxcblxcblxcdFxcdFxcdHZhciB2ID0gW107XFxuXFxuXFx0XFx0XFx0dmFyIGksIGo7XFxuXFxuXFx0XFx0XFx0Ly8gY29uc3RydWN0IGFsbCBvZiB0aGUgdmVydGljZXMgZm9yIHRoaXMgc3ViZGl2aXNpb25cXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gMDsgaSA8PSBjb2xzOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZbIGkgXSA9IFtdO1xcblxcblxcdFxcdFxcdFxcdHZhciBhaiA9IGEuY2xvbmUoKS5sZXJwKCBjLCBpIC8gY29scyApO1xcblxcdFxcdFxcdFxcdHZhciBiaiA9IGIuY2xvbmUoKS5sZXJwKCBjLCBpIC8gY29scyApO1xcblxcblxcdFxcdFxcdFxcdHZhciByb3dzID0gY29scyAtIGk7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggaiA9IDA7IGogPD0gcm93czsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGogPT09IDAgJiYgaSA9PT0gY29scyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2WyBpIF1bIGogXSA9IGFqO1xcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dlsgaSBdWyBqIF0gPSBhai5jbG9uZSgpLmxlcnAoIGJqLCBqIC8gcm93cyApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGNvbnN0cnVjdCBhbGwgb2YgdGhlIGZhY2VzXFxuXFxuXFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPCBjb2xzOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdGZvciAoIGogPSAwOyBqIDwgMiAqICggY29scyAtIGkgKSAtIDE7IGogKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGsgPSBNYXRoLmZsb29yKCBqIC8gMiApO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggaiAlIDIgPT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cHVzaFZlcnRleCggdlsgaSBdWyBrICsgMSBdICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cHVzaFZlcnRleCggdlsgaSArIDEgXVsgayBdICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cHVzaFZlcnRleCggdlsgaSBdWyBrIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHB1c2hWZXJ0ZXgoIHZbIGkgXVsgayArIDEgXSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdHB1c2hWZXJ0ZXgoIHZbIGkgKyAxIF1bIGsgKyAxIF0gKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwdXNoVmVydGV4KCB2WyBpICsgMSBdWyBrIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gYXBwcGx5UmFkaXVzKCByYWRpdXMgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0Ly8gaXRlcmF0ZSBvdmVyIHRoZSBlbnRpcmUgYnVmZmVyIGFuZCBhcHBseSB0aGUgcmFkaXVzIHRvIGVhY2ggdmVydGV4XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdmVydGV4QnVmZmVyLmxlbmd0aDsgaSArPSAzICkge1xcblxcblxcdFxcdFxcdFxcdHZlcnRleC54ID0gdmVydGV4QnVmZmVyWyBpICsgMCBdO1xcblxcdFxcdFxcdFxcdHZlcnRleC55ID0gdmVydGV4QnVmZmVyWyBpICsgMSBdO1xcblxcdFxcdFxcdFxcdHZlcnRleC56ID0gdmVydGV4QnVmZmVyWyBpICsgMiBdO1xcblxcblxcdFxcdFxcdFxcdHZlcnRleC5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggcmFkaXVzICk7XFxuXFxuXFx0XFx0XFx0XFx0dmVydGV4QnVmZmVyWyBpICsgMCBdID0gdmVydGV4Lng7XFxuXFx0XFx0XFx0XFx0dmVydGV4QnVmZmVyWyBpICsgMSBdID0gdmVydGV4Lnk7XFxuXFx0XFx0XFx0XFx0dmVydGV4QnVmZmVyWyBpICsgMiBdID0gdmVydGV4Lno7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBnZW5lcmF0ZVVWcygpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB2ZXJ0ZXhCdWZmZXIubGVuZ3RoOyBpICs9IDMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmVydGV4LnggPSB2ZXJ0ZXhCdWZmZXJbIGkgKyAwIF07XFxuXFx0XFx0XFx0XFx0dmVydGV4LnkgPSB2ZXJ0ZXhCdWZmZXJbIGkgKyAxIF07XFxuXFx0XFx0XFx0XFx0dmVydGV4LnogPSB2ZXJ0ZXhCdWZmZXJbIGkgKyAyIF07XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHUgPSBhemltdXRoKCB2ZXJ0ZXggKSAvIDIgLyBNYXRoLlBJICsgMC41O1xcblxcdFxcdFxcdFxcdHZhciB2ID0gaW5jbGluYXRpb24oIHZlcnRleCApIC8gTWF0aC5QSSArIDAuNTtcXG5cXHRcXHRcXHRcXHR1dkJ1ZmZlci5wdXNoKCB1LCAxIC0gdiApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRjb3JyZWN0VVZzKCk7XFxuXFxuXFx0XFx0XFx0Y29ycmVjdFNlYW0oKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gY29ycmVjdFNlYW0oKSB7XFxuXFxuXFx0XFx0XFx0Ly8gaGFuZGxlIGNhc2Ugd2hlbiBmYWNlIHN0cmFkZGxlcyB0aGUgc2VhbSwgc2VlICMzMjY5XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdXZCdWZmZXIubGVuZ3RoOyBpICs9IDYgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdXYgZGF0YSBvZiBhIHNpbmdsZSBmYWNlXFxuXFxuXFx0XFx0XFx0XFx0dmFyIHgwID0gdXZCdWZmZXJbIGkgKyAwIF07XFxuXFx0XFx0XFx0XFx0dmFyIHgxID0gdXZCdWZmZXJbIGkgKyAyIF07XFxuXFx0XFx0XFx0XFx0dmFyIHgyID0gdXZCdWZmZXJbIGkgKyA0IF07XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG1heCA9IE1hdGgubWF4KCB4MCwgeDEsIHgyICk7XFxuXFx0XFx0XFx0XFx0dmFyIG1pbiA9IE1hdGgubWluKCB4MCwgeDEsIHgyICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gMC45IGlzIHNvbWV3aGF0IGFyYml0cmFyeVxcblxcblxcdFxcdFxcdFxcdGlmICggbWF4ID4gMC45ICYmIG1pbiA8IDAuMSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHgwIDwgMC4yICkgdXZCdWZmZXJbIGkgKyAwIF0gKz0gMTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHgxIDwgMC4yICkgdXZCdWZmZXJbIGkgKyAyIF0gKz0gMTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHgyIDwgMC4yICkgdXZCdWZmZXJbIGkgKyA0IF0gKz0gMTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBwdXNoVmVydGV4KCB2ZXJ0ZXggKSB7XFxuXFxuXFx0XFx0XFx0dmVydGV4QnVmZmVyLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gZ2V0VmVydGV4QnlJbmRleCggaW5kZXgsIHZlcnRleCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgc3RyaWRlID0gaW5kZXggKiAzO1xcblxcblxcdFxcdFxcdHZlcnRleC54ID0gdmVydGljZXNbIHN0cmlkZSArIDAgXTtcXG5cXHRcXHRcXHR2ZXJ0ZXgueSA9IHZlcnRpY2VzWyBzdHJpZGUgKyAxIF07XFxuXFx0XFx0XFx0dmVydGV4LnogPSB2ZXJ0aWNlc1sgc3RyaWRlICsgMiBdO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBjb3JyZWN0VVZzKCkge1xcblxcblxcdFxcdFxcdHZhciBhID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgYiA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0dmFyIGMgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHZhciBjZW50cm9pZCA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0dmFyIHV2QSA9IG5ldyBWZWN0b3IyKCk7XFxuXFx0XFx0XFx0dmFyIHV2QiA9IG5ldyBWZWN0b3IyKCk7XFxuXFx0XFx0XFx0dmFyIHV2QyA9IG5ldyBWZWN0b3IyKCk7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBqID0gMDsgaSA8IHZlcnRleEJ1ZmZlci5sZW5ndGg7IGkgKz0gOSwgaiArPSA2ICkge1xcblxcblxcdFxcdFxcdFxcdGEuc2V0KCB2ZXJ0ZXhCdWZmZXJbIGkgKyAwIF0sIHZlcnRleEJ1ZmZlclsgaSArIDEgXSwgdmVydGV4QnVmZmVyWyBpICsgMiBdICk7XFxuXFx0XFx0XFx0XFx0Yi5zZXQoIHZlcnRleEJ1ZmZlclsgaSArIDMgXSwgdmVydGV4QnVmZmVyWyBpICsgNCBdLCB2ZXJ0ZXhCdWZmZXJbIGkgKyA1IF0gKTtcXG5cXHRcXHRcXHRcXHRjLnNldCggdmVydGV4QnVmZmVyWyBpICsgNiBdLCB2ZXJ0ZXhCdWZmZXJbIGkgKyA3IF0sIHZlcnRleEJ1ZmZlclsgaSArIDggXSApO1xcblxcblxcdFxcdFxcdFxcdHV2QS5zZXQoIHV2QnVmZmVyWyBqICsgMCBdLCB1dkJ1ZmZlclsgaiArIDEgXSApO1xcblxcdFxcdFxcdFxcdHV2Qi5zZXQoIHV2QnVmZmVyWyBqICsgMiBdLCB1dkJ1ZmZlclsgaiArIDMgXSApO1xcblxcdFxcdFxcdFxcdHV2Qy5zZXQoIHV2QnVmZmVyWyBqICsgNCBdLCB1dkJ1ZmZlclsgaiArIDUgXSApO1xcblxcblxcdFxcdFxcdFxcdGNlbnRyb2lkLmNvcHkoIGEgKS5hZGQoIGIgKS5hZGQoIGMgKS5kaXZpZGVTY2FsYXIoIDMgKTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgYXppID0gYXppbXV0aCggY2VudHJvaWQgKTtcXG5cXG5cXHRcXHRcXHRcXHRjb3JyZWN0VVYoIHV2QSwgaiArIDAsIGEsIGF6aSApO1xcblxcdFxcdFxcdFxcdGNvcnJlY3RVViggdXZCLCBqICsgMiwgYiwgYXppICk7XFxuXFx0XFx0XFx0XFx0Y29ycmVjdFVWKCB1dkMsIGogKyA0LCBjLCBhemkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGNvcnJlY3RVViggdXYsIHN0cmlkZSwgdmVjdG9yLCBhemltdXRoICkge1xcblxcblxcdFxcdFxcdGlmICggKCBhemltdXRoIDwgMCApICYmICggdXYueCA9PT0gMSApICkge1xcblxcblxcdFxcdFxcdFxcdHV2QnVmZmVyWyBzdHJpZGUgXSA9IHV2LnggLSAxO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoICggdmVjdG9yLnggPT09IDAgKSAmJiAoIHZlY3Rvci56ID09PSAwICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dXZCdWZmZXJbIHN0cmlkZSBdID0gYXppbXV0aCAvIDIgLyBNYXRoLlBJICsgMC41O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQW5nbGUgYXJvdW5kIHRoZSBZIGF4aXMsIGNvdW50ZXItY2xvY2t3aXNlIHdoZW4gbG9va2luZyBmcm9tIGFib3ZlLlxcblxcblxcdFxcdGZ1bmN0aW9uIGF6aW11dGgoIHZlY3RvciApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gTWF0aC5hdGFuMiggdmVjdG9yLnosIC0gdmVjdG9yLnggKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFxuXFx0XFx0Ly8gQW5nbGUgYWJvdmUgdGhlIFhaIHBsYW5lLlxcblxcblxcdFxcdGZ1bmN0aW9uIGluY2xpbmF0aW9uKCB2ZWN0b3IgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIE1hdGguYXRhbjIoIC0gdmVjdG9yLnksIE1hdGguc3FydCggKCB2ZWN0b3IueCAqIHZlY3Rvci54ICkgKyAoIHZlY3Rvci56ICogdmVjdG9yLnogKSApICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH1cXG5cXG5cXHRQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XFxuXFx0UG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XFxuXFx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcXG5cXHQgKi9cXG5cXG5cXHQvLyBUZXRyYWhlZHJvbkdlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gVGV0cmFoZWRyb25HZW9tZXRyeSggcmFkaXVzLCBkZXRhaWwgKSB7XFxuXFxuXFx0XFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdUZXRyYWhlZHJvbkdlb21ldHJ5JztcXG5cXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxuXFx0XFx0XFx0cmFkaXVzOiByYWRpdXMsXFxuXFx0XFx0XFx0ZGV0YWlsOiBkZXRhaWxcXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgVGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeSggcmFkaXVzLCBkZXRhaWwgKSApO1xcblxcdFxcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xcblxcblxcdH1cXG5cXG5cXHRUZXRyYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xcblxcdFRldHJhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV0cmFoZWRyb25HZW9tZXRyeTtcXG5cXG5cXHQvLyBUZXRyYWhlZHJvbkJ1ZmZlckdlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gVGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeSggcmFkaXVzLCBkZXRhaWwgKSB7XFxuXFxuXFx0XFx0dmFyIHZlcnRpY2VzID0gW1xcblxcdFxcdFxcdDEsIDEsIDEsIFxcdC0gMSwgLSAxLCAxLCBcXHQtIDEsIDEsIC0gMSwgXFx0MSwgLSAxLCAtIDFcXG5cXHRcXHRdO1xcblxcblxcdFxcdHZhciBpbmRpY2VzID0gW1xcblxcdFxcdFxcdDIsIDEsIDAsIFxcdDAsIDMsIDIsXFx0MSwgMywgMCxcXHQyLCAzLCAxXFxuXFx0XFx0XTtcXG5cXG5cXHRcXHRQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcywgdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1RldHJhaGVkcm9uQnVmZmVyR2VvbWV0cnknO1xcblxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXG5cXHRcXHRcXHRyYWRpdXM6IHJhZGl1cyxcXG5cXHRcXHRcXHRkZXRhaWw6IGRldGFpbFxcblxcdFxcdH07XFxuXFxuXFx0fVxcblxcblxcdFRldHJhaGVkcm9uQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xcblxcdFRldHJhaGVkcm9uQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XFxuXFx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcXG5cXHQgKi9cXG5cXG5cXHQvLyBPY3RhaGVkcm9uR2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBPY3RhaGVkcm9uR2VvbWV0cnkoIHJhZGl1cywgZGV0YWlsICkge1xcblxcblxcdFxcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnT2N0YWhlZHJvbkdlb21ldHJ5JztcXG5cXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxuXFx0XFx0XFx0cmFkaXVzOiByYWRpdXMsXFxuXFx0XFx0XFx0ZGV0YWlsOiBkZXRhaWxcXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgT2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIGRldGFpbCApICk7XFxuXFx0XFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XFxuXFxuXFx0fVxcblxcblxcdE9jdGFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcXG5cXHRPY3RhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT2N0YWhlZHJvbkdlb21ldHJ5O1xcblxcblxcdC8vIE9jdGFoZWRyb25CdWZmZXJHZW9tZXRyeVxcblxcblxcdGZ1bmN0aW9uIE9jdGFoZWRyb25CdWZmZXJHZW9tZXRyeSggcmFkaXVzLCBkZXRhaWwgKSB7XFxuXFxuXFx0XFx0dmFyIHZlcnRpY2VzID0gW1xcblxcdFxcdFxcdDEsIDAsIDAsIFxcdC0gMSwgMCwgMCxcXHQwLCAxLCAwLFxcblxcdFxcdFxcdDAsIC0gMSwgMCwgXFx0MCwgMCwgMSxcXHQwLCAwLCAtIDFcXG5cXHRcXHRdO1xcblxcblxcdFxcdHZhciBpbmRpY2VzID0gW1xcblxcdFxcdFxcdDAsIDIsIDQsXFx0MCwgNCwgMyxcXHQwLCAzLCA1LFxcblxcdFxcdFxcdDAsIDUsIDIsXFx0MSwgMiwgNSxcXHQxLCA1LCAzLFxcblxcdFxcdFxcdDEsIDMsIDQsXFx0MSwgNCwgMlxcblxcdFxcdF07XFxuXFxuXFx0XFx0UG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdPY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnknO1xcblxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXG5cXHRcXHRcXHRyYWRpdXM6IHJhZGl1cyxcXG5cXHRcXHRcXHRkZXRhaWw6IGRldGFpbFxcblxcdFxcdH07XFxuXFxuXFx0fVxcblxcblxcdE9jdGFoZWRyb25CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XFxuXFx0T2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE9jdGFoZWRyb25CdWZmZXJHZW9tZXRyeTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XFxuXFx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcXG5cXHQgKi9cXG5cXG5cXHQvLyBJY29zYWhlZHJvbkdlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gSWNvc2FoZWRyb25HZW9tZXRyeSggcmFkaXVzLCBkZXRhaWwgKSB7XFxuXFxuXFx0XFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdJY29zYWhlZHJvbkdlb21ldHJ5JztcXG5cXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxuXFx0XFx0XFx0cmFkaXVzOiByYWRpdXMsXFxuXFx0XFx0XFx0ZGV0YWlsOiBkZXRhaWxcXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgSWNvc2FoZWRyb25CdWZmZXJHZW9tZXRyeSggcmFkaXVzLCBkZXRhaWwgKSApO1xcblxcdFxcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xcblxcblxcdH1cXG5cXG5cXHRJY29zYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xcblxcdEljb3NhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSWNvc2FoZWRyb25HZW9tZXRyeTtcXG5cXG5cXHQvLyBJY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gSWNvc2FoZWRyb25CdWZmZXJHZW9tZXRyeSggcmFkaXVzLCBkZXRhaWwgKSB7XFxuXFxuXFx0XFx0dmFyIHQgPSAoIDEgKyBNYXRoLnNxcnQoIDUgKSApIC8gMjtcXG5cXG5cXHRcXHR2YXIgdmVydGljZXMgPSBbXFxuXFx0XFx0XFx0LSAxLCB0LCAwLCBcXHQxLCB0LCAwLCBcXHQtIDEsIC0gdCwgMCwgXFx0MSwgLSB0LCAwLFxcblxcdFxcdFxcdCAwLCAtIDEsIHQsIFxcdDAsIDEsIHQsXFx0MCwgLSAxLCAtIHQsIFxcdDAsIDEsIC0gdCxcXG5cXHRcXHRcXHQgdCwgMCwgLSAxLCBcXHR0LCAwLCAxLCBcXHQtIHQsIDAsIC0gMSwgXFx0LSB0LCAwLCAxXFxuXFx0XFx0XTtcXG5cXG5cXHRcXHR2YXIgaW5kaWNlcyA9IFtcXG5cXHRcXHRcXHQgMCwgMTEsIDUsIFxcdDAsIDUsIDEsIFxcdDAsIDEsIDcsIFxcdDAsIDcsIDEwLCBcXHQwLCAxMCwgMTEsXFxuXFx0XFx0XFx0IDEsIDUsIDksIFxcdDUsIDExLCA0LFxcdDExLCAxMCwgMixcXHQxMCwgNywgNixcXHQ3LCAxLCA4LFxcblxcdFxcdFxcdCAzLCA5LCA0LCBcXHQzLCA0LCAyLFxcdDMsIDIsIDYsXFx0MywgNiwgOCxcXHQzLCA4LCA5LFxcblxcdFxcdFxcdCA0LCA5LCA1LCBcXHQyLCA0LCAxMSxcXHQ2LCAyLCAxMCxcXHQ4LCA2LCA3LFxcdDksIDgsIDFcXG5cXHRcXHRdO1xcblxcblxcdFxcdFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnSWNvc2FoZWRyb25CdWZmZXJHZW9tZXRyeSc7XFxuXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcblxcdFxcdFxcdHJhZGl1czogcmFkaXVzLFxcblxcdFxcdFxcdGRldGFpbDogZGV0YWlsXFxuXFx0XFx0fTtcXG5cXG5cXHR9XFxuXFxuXFx0SWNvc2FoZWRyb25CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XFxuXFx0SWNvc2FoZWRyb25CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgQWJlIFBhem9zIC8gaHR0cHM6Ly9oYW1vaWQuY29tXFxuXFx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcXG5cXHQgKi9cXG5cXG5cXHQvLyBEb2RlY2FoZWRyb25HZW9tZXRyeVxcblxcblxcdGZ1bmN0aW9uIERvZGVjYWhlZHJvbkdlb21ldHJ5KCByYWRpdXMsIGRldGFpbCApIHtcXG5cXG5cXHRcXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ0RvZGVjYWhlZHJvbkdlb21ldHJ5JztcXG5cXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxuXFx0XFx0XFx0cmFkaXVzOiByYWRpdXMsXFxuXFx0XFx0XFx0ZGV0YWlsOiBkZXRhaWxcXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgRG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgZGV0YWlsICkgKTtcXG5cXHRcXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcXG5cXG5cXHR9XFxuXFxuXFx0RG9kZWNhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XFxuXFx0RG9kZWNhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRG9kZWNhaGVkcm9uR2VvbWV0cnk7XFxuXFxuXFx0Ly8gRG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBEb2RlY2FoZWRyb25CdWZmZXJHZW9tZXRyeSggcmFkaXVzLCBkZXRhaWwgKSB7XFxuXFxuXFx0XFx0dmFyIHQgPSAoIDEgKyBNYXRoLnNxcnQoIDUgKSApIC8gMjtcXG5cXHRcXHR2YXIgciA9IDEgLyB0O1xcblxcblxcdFxcdHZhciB2ZXJ0aWNlcyA9IFtcXG5cXG5cXHRcXHRcXHQvLyAowrExLCDCsTEsIMKxMSlcXG5cXHRcXHRcXHQtIDEsIC0gMSwgLSAxLFxcdC0gMSwgLSAxLCAxLFxcblxcdFxcdFxcdC0gMSwgMSwgLSAxLCAtIDEsIDEsIDEsXFxuXFx0XFx0XFx0MSwgLSAxLCAtIDEsIDEsIC0gMSwgMSxcXG5cXHRcXHRcXHQxLCAxLCAtIDEsIDEsIDEsIDEsXFxuXFxuXFx0XFx0XFx0Ly8gKDAsIMKxMS/PhiwgwrHPhilcXG5cXHRcXHRcXHQgMCwgLSByLCAtIHQsIDAsIC0gciwgdCxcXG5cXHRcXHRcXHQgMCwgciwgLSB0LCAwLCByLCB0LFxcblxcblxcdFxcdFxcdC8vICjCsTEvz4YsIMKxz4YsIDApXFxuXFx0XFx0XFx0LSByLCAtIHQsIDAsIC0gciwgdCwgMCxcXG5cXHRcXHRcXHQgciwgLSB0LCAwLCByLCB0LCAwLFxcblxcblxcdFxcdFxcdC8vICjCsc+GLCAwLCDCsTEvz4YpXFxuXFx0XFx0XFx0LSB0LCAwLCAtIHIsIHQsIDAsIC0gcixcXG5cXHRcXHRcXHQtIHQsIDAsIHIsIHQsIDAsIHJcXG5cXHRcXHRdO1xcblxcblxcdFxcdHZhciBpbmRpY2VzID0gW1xcblxcdFxcdFxcdDMsIDExLCA3LCBcXHQzLCA3LCAxNSwgXFx0MywgMTUsIDEzLFxcblxcdFxcdFxcdDcsIDE5LCAxNywgXFx0NywgMTcsIDYsIFxcdDcsIDYsIDE1LFxcblxcdFxcdFxcdDE3LCA0LCA4LCBcXHQxNywgOCwgMTAsIFxcdDE3LCAxMCwgNixcXG5cXHRcXHRcXHQ4LCAwLCAxNiwgXFx0OCwgMTYsIDIsIFxcdDgsIDIsIDEwLFxcblxcdFxcdFxcdDAsIDEyLCAxLCBcXHQwLCAxLCAxOCwgXFx0MCwgMTgsIDE2LFxcblxcdFxcdFxcdDYsIDEwLCAyLCBcXHQ2LCAyLCAxMywgXFx0NiwgMTMsIDE1LFxcblxcdFxcdFxcdDIsIDE2LCAxOCwgXFx0MiwgMTgsIDMsIFxcdDIsIDMsIDEzLFxcblxcdFxcdFxcdDE4LCAxLCA5LCBcXHQxOCwgOSwgMTEsIFxcdDE4LCAxMSwgMyxcXG5cXHRcXHRcXHQ0LCAxNCwgMTIsIFxcdDQsIDEyLCAwLCBcXHQ0LCAwLCA4LFxcblxcdFxcdFxcdDExLCA5LCA1LCBcXHQxMSwgNSwgMTksIFxcdDExLCAxOSwgNyxcXG5cXHRcXHRcXHQxOSwgNSwgMTQsIFxcdDE5LCAxNCwgNCwgXFx0MTksIDQsIDE3LFxcblxcdFxcdFxcdDEsIDEyLCAxNCwgXFx0MSwgMTQsIDUsIFxcdDEsIDUsIDlcXG5cXHRcXHRdO1xcblxcblxcdFxcdFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnRG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnknO1xcblxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXG5cXHRcXHRcXHRyYWRpdXM6IHJhZGl1cyxcXG5cXHRcXHRcXHRkZXRhaWw6IGRldGFpbFxcblxcdFxcdH07XFxuXFxuXFx0fVxcblxcblxcdERvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcXG5cXHREb2RlY2FoZWRyb25CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEb2RlY2FoZWRyb25CdWZmZXJHZW9tZXRyeTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG9vc21veGllY29kZSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9vb3Ntb3hpZWNvZGVcXG5cXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XFxuXFx0ICogQGF1dGhvciB6ejg1IC8gaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcXG5cXHQgKiBAYXV0aG9yIG1pbmluZ29sZCAvIGh0dHBzOi8vZ2l0aHViLmNvbS9taW5pbmdvbGRcXG5cXHQgKiBAYXV0aG9yIGpvbm9icjEgLyBodHRwczovL2dpdGh1Yi5jb20vam9ub2JyMVxcblxcdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XFxuXFx0ICpcXG5cXHQgKi9cXG5cXG5cXHQvLyBUdWJlR2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBUdWJlR2VvbWV0cnkoIHBhdGgsIHR1YnVsYXJTZWdtZW50cywgcmFkaXVzLCByYWRpYWxTZWdtZW50cywgY2xvc2VkLCB0YXBlciApIHtcXG5cXG5cXHRcXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1R1YmVHZW9tZXRyeSc7XFxuXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcblxcdFxcdFxcdHBhdGg6IHBhdGgsXFxuXFx0XFx0XFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXFxuXFx0XFx0XFx0cmFkaXVzOiByYWRpdXMsXFxuXFx0XFx0XFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxcblxcdFxcdFxcdGNsb3NlZDogY2xvc2VkXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRpZiAoIHRhcGVyICE9PSB1bmRlZmluZWQgKSBjb25zb2xlLndhcm4oICdUSFJFRS5UdWJlR2VvbWV0cnk6IHRhcGVyIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcblxcblxcdFxcdHZhciBidWZmZXJHZW9tZXRyeSA9IG5ldyBUdWJlQnVmZmVyR2VvbWV0cnkoIHBhdGgsIHR1YnVsYXJTZWdtZW50cywgcmFkaXVzLCByYWRpYWxTZWdtZW50cywgY2xvc2VkICk7XFxuXFxuXFx0XFx0Ly8gZXhwb3NlIGludGVybmFsc1xcblxcblxcdFxcdHRoaXMudGFuZ2VudHMgPSBidWZmZXJHZW9tZXRyeS50YW5nZW50cztcXG5cXHRcXHR0aGlzLm5vcm1hbHMgPSBidWZmZXJHZW9tZXRyeS5ub3JtYWxzO1xcblxcdFxcdHRoaXMuYmlub3JtYWxzID0gYnVmZmVyR2VvbWV0cnkuYmlub3JtYWxzO1xcblxcblxcdFxcdC8vIGNyZWF0ZSBnZW9tZXRyeVxcblxcblxcdFxcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBidWZmZXJHZW9tZXRyeSApO1xcblxcdFxcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xcblxcblxcdH1cXG5cXG5cXHRUdWJlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XFxuXFx0VHViZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFR1YmVHZW9tZXRyeTtcXG5cXG5cXHQvLyBUdWJlQnVmZmVyR2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBUdWJlQnVmZmVyR2VvbWV0cnkoIHBhdGgsIHR1YnVsYXJTZWdtZW50cywgcmFkaXVzLCByYWRpYWxTZWdtZW50cywgY2xvc2VkICkge1xcblxcblxcdFxcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnVHViZUJ1ZmZlckdlb21ldHJ5JztcXG5cXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxuXFx0XFx0XFx0cGF0aDogcGF0aCxcXG5cXHRcXHRcXHR0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcXG5cXHRcXHRcXHRyYWRpdXM6IHJhZGl1cyxcXG5cXHRcXHRcXHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXFxuXFx0XFx0XFx0Y2xvc2VkOiBjbG9zZWRcXG5cXHRcXHR9O1xcblxcblxcdFxcdHR1YnVsYXJTZWdtZW50cyA9IHR1YnVsYXJTZWdtZW50cyB8fCA2NDtcXG5cXHRcXHRyYWRpdXMgPSByYWRpdXMgfHwgMTtcXG5cXHRcXHRyYWRpYWxTZWdtZW50cyA9IHJhZGlhbFNlZ21lbnRzIHx8IDg7XFxuXFx0XFx0Y2xvc2VkID0gY2xvc2VkIHx8IGZhbHNlO1xcblxcblxcdFxcdHZhciBmcmFtZXMgPSBwYXRoLmNvbXB1dGVGcmVuZXRGcmFtZXMoIHR1YnVsYXJTZWdtZW50cywgY2xvc2VkICk7XFxuXFxuXFx0XFx0Ly8gZXhwb3NlIGludGVybmFsc1xcblxcblxcdFxcdHRoaXMudGFuZ2VudHMgPSBmcmFtZXMudGFuZ2VudHM7XFxuXFx0XFx0dGhpcy5ub3JtYWxzID0gZnJhbWVzLm5vcm1hbHM7XFxuXFx0XFx0dGhpcy5iaW5vcm1hbHMgPSBmcmFtZXMuYmlub3JtYWxzO1xcblxcblxcdFxcdC8vIGhlbHBlciB2YXJpYWJsZXNcXG5cXG5cXHRcXHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHR2YXIgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHR2YXIgdXYgPSBuZXcgVmVjdG9yMigpO1xcblxcdFxcdHZhciBQID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHR2YXIgaSwgajtcXG5cXG5cXHRcXHQvLyBidWZmZXJcXG5cXG5cXHRcXHR2YXIgdmVydGljZXMgPSBbXTtcXG5cXHRcXHR2YXIgbm9ybWFscyA9IFtdO1xcblxcdFxcdHZhciB1dnMgPSBbXTtcXG5cXHRcXHR2YXIgaW5kaWNlcyA9IFtdO1xcblxcblxcdFxcdC8vIGNyZWF0ZSBidWZmZXIgZGF0YVxcblxcblxcdFxcdGdlbmVyYXRlQnVmZmVyRGF0YSgpO1xcblxcblxcdFxcdC8vIGJ1aWxkIGdlb21ldHJ5XFxuXFxuXFx0XFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcXG5cXG5cXHRcXHQvLyBmdW5jdGlvbnNcXG5cXG5cXHRcXHRmdW5jdGlvbiBnZW5lcmF0ZUJ1ZmZlckRhdGEoKSB7XFxuXFxuXFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPCB0dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Z2VuZXJhdGVTZWdtZW50KCBpICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGlmIHRoZSBnZW9tZXRyeSBpcyBub3QgY2xvc2VkLCBnZW5lcmF0ZSB0aGUgbGFzdCByb3cgb2YgdmVydGljZXMgYW5kIG5vcm1hbHNcXG5cXHRcXHRcXHQvLyBhdCB0aGUgcmVndWxhciBwb3NpdGlvbiBvbiB0aGUgZ2l2ZW4gcGF0aFxcblxcdFxcdFxcdC8vXFxuXFx0XFx0XFx0Ly8gaWYgdGhlIGdlb21ldHJ5IGlzIGNsb3NlZCwgZHVwbGljYXRlIHRoZSBmaXJzdCByb3cgb2YgdmVydGljZXMgYW5kIG5vcm1hbHMgKHV2cyB3aWxsIGRpZmZlcilcXG5cXG5cXHRcXHRcXHRnZW5lcmF0ZVNlZ21lbnQoICggY2xvc2VkID09PSBmYWxzZSApID8gdHVidWxhclNlZ21lbnRzIDogMCApO1xcblxcblxcdFxcdFxcdC8vIHV2cyBhcmUgZ2VuZXJhdGVkIGluIGEgc2VwYXJhdGUgZnVuY3Rpb24uXFxuXFx0XFx0XFx0Ly8gdGhpcyBtYWtlcyBpdCBlYXN5IGNvbXB1dGUgY29ycmVjdCB2YWx1ZXMgZm9yIGNsb3NlZCBnZW9tZXRyaWVzXFxuXFxuXFx0XFx0XFx0Z2VuZXJhdGVVVnMoKTtcXG5cXG5cXHRcXHRcXHQvLyBmaW5hbGx5IGNyZWF0ZSBmYWNlc1xcblxcblxcdFxcdFxcdGdlbmVyYXRlSW5kaWNlcygpO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBnZW5lcmF0ZVNlZ21lbnQoIGkgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gd2UgdXNlIGdldFBvaW50QXQgdG8gc2FtcGxlIGV2ZW5seSBkaXN0cmlidXRlZCBwb2ludHMgZnJvbSB0aGUgZ2l2ZW4gcGF0aFxcblxcblxcdFxcdFxcdFAgPSBwYXRoLmdldFBvaW50QXQoIGkgLyB0dWJ1bGFyU2VnbWVudHMsIFAgKTtcXG5cXG5cXHRcXHRcXHQvLyByZXRyaWV2ZSBjb3JyZXNwb25kaW5nIG5vcm1hbCBhbmQgYmlub3JtYWxcXG5cXG5cXHRcXHRcXHR2YXIgTiA9IGZyYW1lcy5ub3JtYWxzWyBpIF07XFxuXFx0XFx0XFx0dmFyIEIgPSBmcmFtZXMuYmlub3JtYWxzWyBpIF07XFxuXFxuXFx0XFx0XFx0Ly8gZ2VuZXJhdGUgbm9ybWFscyBhbmQgdmVydGljZXMgZm9yIHRoZSBjdXJyZW50IHNlZ21lbnRcXG5cXG5cXHRcXHRcXHRmb3IgKCBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIE1hdGguUEkgKiAyO1xcblxcblxcdFxcdFxcdFxcdHZhciBzaW4gPSBNYXRoLnNpbiggdiApO1xcblxcdFxcdFxcdFxcdHZhciBjb3MgPSAtIE1hdGguY29zKCB2ICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gbm9ybWFsXFxuXFxuXFx0XFx0XFx0XFx0bm9ybWFsLnggPSAoIGNvcyAqIE4ueCArIHNpbiAqIEIueCApO1xcblxcdFxcdFxcdFxcdG5vcm1hbC55ID0gKCBjb3MgKiBOLnkgKyBzaW4gKiBCLnkgKTtcXG5cXHRcXHRcXHRcXHRub3JtYWwueiA9ICggY29zICogTi56ICsgc2luICogQi56ICk7XFxuXFx0XFx0XFx0XFx0bm9ybWFsLm5vcm1hbGl6ZSgpO1xcblxcblxcdFxcdFxcdFxcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xcblxcblxcdFxcdFxcdFxcdC8vIHZlcnRleFxcblxcblxcdFxcdFxcdFxcdHZlcnRleC54ID0gUC54ICsgcmFkaXVzICogbm9ybWFsLng7XFxuXFx0XFx0XFx0XFx0dmVydGV4LnkgPSBQLnkgKyByYWRpdXMgKiBub3JtYWwueTtcXG5cXHRcXHRcXHRcXHR2ZXJ0ZXgueiA9IFAueiArIHJhZGl1cyAqIG5vcm1hbC56O1xcblxcblxcdFxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGdlbmVyYXRlSW5kaWNlcygpIHtcXG5cXG5cXHRcXHRcXHRmb3IgKCBqID0gMTsgaiA8PSB0dWJ1bGFyU2VnbWVudHM7IGogKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggaSA9IDE7IGkgPD0gcmFkaWFsU2VnbWVudHM7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGEgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgKCBpIC0gMSApO1xcblxcdFxcdFxcdFxcdFxcdHZhciBiID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqIGogKyAoIGkgLSAxICk7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGMgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogaiArIGk7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGQgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBmYWNlc1xcblxcblxcdFxcdFxcdFxcdFxcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xcblxcdFxcdFxcdFxcdFxcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGdlbmVyYXRlVVZzKCkge1xcblxcblxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR1di54ID0gaSAvIHR1YnVsYXJTZWdtZW50cztcXG5cXHRcXHRcXHRcXHRcXHR1di55ID0gaiAvIHJhZGlhbFNlZ21lbnRzO1xcblxcblxcdFxcdFxcdFxcdFxcdHV2cy5wdXNoKCB1di54LCB1di55ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0fVxcblxcblxcdFR1YmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcXG5cXHRUdWJlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHViZUJ1ZmZlckdlb21ldHJ5O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3Igb29zbW94aWVjb2RlXFxuXFx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcXG5cXHQgKlxcblxcdCAqIGJhc2VkIG9uIGh0dHA6Ly93d3cuYmxhY2twYXduLmNvbS90ZXh0cy9wcXRvcnVzL1xcblxcdCAqL1xcblxcblxcdC8vIFRvcnVzS25vdEdlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gVG9ydXNLbm90R2VvbWV0cnkoIHJhZGl1cywgdHViZSwgdHVidWxhclNlZ21lbnRzLCByYWRpYWxTZWdtZW50cywgcCwgcSwgaGVpZ2h0U2NhbGUgKSB7XFxuXFxuXFx0XFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdUb3J1c0tub3RHZW9tZXRyeSc7XFxuXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcblxcdFxcdFxcdHJhZGl1czogcmFkaXVzLFxcblxcdFxcdFxcdHR1YmU6IHR1YmUsXFxuXFx0XFx0XFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXFxuXFx0XFx0XFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxcblxcdFxcdFxcdHA6IHAsXFxuXFx0XFx0XFx0cTogcVxcblxcdFxcdH07XFxuXFxuXFx0XFx0aWYgKCBoZWlnaHRTY2FsZSAhPT0gdW5kZWZpbmVkICkgY29uc29sZS53YXJuKCAnVEhSRUUuVG9ydXNLbm90R2VvbWV0cnk6IGhlaWdodFNjYWxlIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAuc2NhbGUoIHgsIHksIHogKSBpbnN0ZWFkLicgKTtcXG5cXG5cXHRcXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHR1YmUsIHR1YnVsYXJTZWdtZW50cywgcmFkaWFsU2VnbWVudHMsIHAsIHEgKSApO1xcblxcdFxcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xcblxcblxcdH1cXG5cXG5cXHRUb3J1c0tub3RHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcXG5cXHRUb3J1c0tub3RHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUb3J1c0tub3RHZW9tZXRyeTtcXG5cXG5cXHQvLyBUb3J1c0tub3RCdWZmZXJHZW9tZXRyeVxcblxcblxcdGZ1bmN0aW9uIFRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHR1YmUsIHR1YnVsYXJTZWdtZW50cywgcmFkaWFsU2VnbWVudHMsIHAsIHEgKSB7XFxuXFxuXFx0XFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdUb3J1c0tub3RCdWZmZXJHZW9tZXRyeSc7XFxuXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcblxcdFxcdFxcdHJhZGl1czogcmFkaXVzLFxcblxcdFxcdFxcdHR1YmU6IHR1YmUsXFxuXFx0XFx0XFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXFxuXFx0XFx0XFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxcblxcdFxcdFxcdHA6IHAsXFxuXFx0XFx0XFx0cTogcVxcblxcdFxcdH07XFxuXFxuXFx0XFx0cmFkaXVzID0gcmFkaXVzIHx8IDE7XFxuXFx0XFx0dHViZSA9IHR1YmUgfHwgMC40O1xcblxcdFxcdHR1YnVsYXJTZWdtZW50cyA9IE1hdGguZmxvb3IoIHR1YnVsYXJTZWdtZW50cyApIHx8IDY0O1xcblxcdFxcdHJhZGlhbFNlZ21lbnRzID0gTWF0aC5mbG9vciggcmFkaWFsU2VnbWVudHMgKSB8fCA4O1xcblxcdFxcdHAgPSBwIHx8IDI7XFxuXFx0XFx0cSA9IHEgfHwgMztcXG5cXG5cXHRcXHQvLyBidWZmZXJzXFxuXFxuXFx0XFx0dmFyIGluZGljZXMgPSBbXTtcXG5cXHRcXHR2YXIgdmVydGljZXMgPSBbXTtcXG5cXHRcXHR2YXIgbm9ybWFscyA9IFtdO1xcblxcdFxcdHZhciB1dnMgPSBbXTtcXG5cXG5cXHRcXHQvLyBoZWxwZXIgdmFyaWFibGVzXFxuXFxuXFx0XFx0dmFyIGksIGo7XFxuXFxuXFx0XFx0dmFyIHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0dmFyIG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0dmFyIFAxID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHR2YXIgUDIgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdHZhciBCID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHR2YXIgVCA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0dmFyIE4gPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcXG5cXG5cXHRcXHRmb3IgKCBpID0gMDsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gdGhlIHJhZGlhbiBcXFwidVxcXCIgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlIHBvc2l0aW9uIG9uIHRoZSB0b3J1cyBjdXJ2ZSBvZiB0aGUgY3VycmVudCB0dWJ1bGFyIHNlZ2VtZW50XFxuXFxuXFx0XFx0XFx0dmFyIHUgPSBpIC8gdHVidWxhclNlZ21lbnRzICogcCAqIE1hdGguUEkgKiAyO1xcblxcblxcdFxcdFxcdC8vIG5vdyB3ZSBjYWxjdWxhdGUgdHdvIHBvaW50cy4gUDEgaXMgb3VyIGN1cnJlbnQgcG9zaXRpb24gb24gdGhlIGN1cnZlLCBQMiBpcyBhIGxpdHRsZSBmYXJ0aGVyIGFoZWFkLlxcblxcdFxcdFxcdC8vIHRoZXNlIHBvaW50cyBhcmUgdXNlZCB0byBjcmVhdGUgYSBzcGVjaWFsIFxcXCJjb29yZGluYXRlIHNwYWNlXFxcIiwgd2hpY2ggaXMgbmVjZXNzYXJ5IHRvIGNhbGN1bGF0ZSB0aGUgY29ycmVjdCB2ZXJ0ZXggcG9zaXRpb25zXFxuXFxuXFx0XFx0XFx0Y2FsY3VsYXRlUG9zaXRpb25PbkN1cnZlKCB1LCBwLCBxLCByYWRpdXMsIFAxICk7XFxuXFx0XFx0XFx0Y2FsY3VsYXRlUG9zaXRpb25PbkN1cnZlKCB1ICsgMC4wMSwgcCwgcSwgcmFkaXVzLCBQMiApO1xcblxcblxcdFxcdFxcdC8vIGNhbGN1bGF0ZSBvcnRob25vcm1hbCBiYXNpc1xcblxcblxcdFxcdFxcdFQuc3ViVmVjdG9ycyggUDIsIFAxICk7XFxuXFx0XFx0XFx0Ti5hZGRWZWN0b3JzKCBQMiwgUDEgKTtcXG5cXHRcXHRcXHRCLmNyb3NzVmVjdG9ycyggVCwgTiApO1xcblxcdFxcdFxcdE4uY3Jvc3NWZWN0b3JzKCBCLCBUICk7XFxuXFxuXFx0XFx0XFx0Ly8gbm9ybWFsaXplIEIsIE4uIFQgY2FuIGJlIGlnbm9yZWQsIHdlIGRvbid0IHVzZSBpdFxcblxcblxcdFxcdFxcdEIubm9ybWFsaXplKCk7XFxuXFx0XFx0XFx0Ti5ub3JtYWxpemUoKTtcXG5cXG5cXHRcXHRcXHRmb3IgKCBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgKysgaiApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBub3cgY2FsY3VsYXRlIHRoZSB2ZXJ0aWNlcy4gdGhleSBhcmUgbm90aGluZyBtb3JlIHRoYW4gYW4gZXh0cnVzaW9uIG9mIHRoZSB0b3J1cyBjdXJ2ZS5cXG5cXHRcXHRcXHRcXHQvLyBiZWNhdXNlIHdlIGV4dHJ1ZGUgYSBzaGFwZSBpbiB0aGUgeHktcGxhbmUsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsY3VsYXRlIGEgei12YWx1ZS5cXG5cXG5cXHRcXHRcXHRcXHR2YXIgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIE1hdGguUEkgKiAyO1xcblxcdFxcdFxcdFxcdHZhciBjeCA9IC0gdHViZSAqIE1hdGguY29zKCB2ICk7XFxuXFx0XFx0XFx0XFx0dmFyIGN5ID0gdHViZSAqIE1hdGguc2luKCB2ICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gbm93IGNhbGN1bGF0ZSB0aGUgZmluYWwgdmVydGV4IHBvc2l0aW9uLlxcblxcdFxcdFxcdFxcdC8vIGZpcnN0IHdlIG9yaWVudCB0aGUgZXh0cnVzaW9uIHdpdGggb3VyIGJhc2lzIHZlY3RvcywgdGhlbiB3ZSBhZGQgaXQgdG8gdGhlIGN1cnJlbnQgcG9zaXRpb24gb24gdGhlIGN1cnZlXFxuXFxuXFx0XFx0XFx0XFx0dmVydGV4LnggPSBQMS54ICsgKCBjeCAqIE4ueCArIGN5ICogQi54ICk7XFxuXFx0XFx0XFx0XFx0dmVydGV4LnkgPSBQMS55ICsgKCBjeCAqIE4ueSArIGN5ICogQi55ICk7XFxuXFx0XFx0XFx0XFx0dmVydGV4LnogPSBQMS56ICsgKCBjeCAqIE4ueiArIGN5ICogQi56ICk7XFxuXFxuXFx0XFx0XFx0XFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xcblxcblxcdFxcdFxcdFxcdC8vIG5vcm1hbCAoUDEgaXMgYWx3YXlzIHRoZSBjZW50ZXIvb3JpZ2luIG9mIHRoZSBleHRydXNpb24sIHRodXMgd2UgY2FuIHVzZSBpdCB0byBjYWxjdWxhdGUgdGhlIG5vcm1hbClcXG5cXG5cXHRcXHRcXHRcXHRub3JtYWwuc3ViVmVjdG9ycyggdmVydGV4LCBQMSApLm5vcm1hbGl6ZSgpO1xcblxcblxcdFxcdFxcdFxcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xcblxcblxcdFxcdFxcdFxcdC8vIHV2XFxuXFxuXFx0XFx0XFx0XFx0dXZzLnB1c2goIGkgLyB0dWJ1bGFyU2VnbWVudHMgKTtcXG5cXHRcXHRcXHRcXHR1dnMucHVzaCggaiAvIHJhZGlhbFNlZ21lbnRzICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBnZW5lcmF0ZSBpbmRpY2VzXFxuXFxuXFx0XFx0Zm9yICggaiA9IDE7IGogPD0gdHVidWxhclNlZ21lbnRzOyBqICsrICkge1xcblxcblxcdFxcdFxcdGZvciAoIGkgPSAxOyBpIDw9IHJhZGlhbFNlZ21lbnRzOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdC8vIGluZGljZXNcXG5cXG5cXHRcXHRcXHRcXHR2YXIgYSA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyAoIGkgLSAxICk7XFxuXFx0XFx0XFx0XFx0dmFyIGIgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogaiArICggaSAtIDEgKTtcXG5cXHRcXHRcXHRcXHR2YXIgYyA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiBqICsgaTtcXG5cXHRcXHRcXHRcXHR2YXIgZCA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpO1xcblxcblxcdFxcdFxcdFxcdC8vIGZhY2VzXFxuXFxuXFx0XFx0XFx0XFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XFxuXFx0XFx0XFx0XFx0aW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBidWlsZCBnZW9tZXRyeVxcblxcblxcdFxcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XFxuXFxuXFx0XFx0Ly8gdGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9uIHRoZSB0b3J1cyBjdXJ2ZVxcblxcblxcdFxcdGZ1bmN0aW9uIGNhbGN1bGF0ZVBvc2l0aW9uT25DdXJ2ZSggdSwgcCwgcSwgcmFkaXVzLCBwb3NpdGlvbiApIHtcXG5cXG5cXHRcXHRcXHR2YXIgY3UgPSBNYXRoLmNvcyggdSApO1xcblxcdFxcdFxcdHZhciBzdSA9IE1hdGguc2luKCB1ICk7XFxuXFx0XFx0XFx0dmFyIHF1T3ZlclAgPSBxIC8gcCAqIHU7XFxuXFx0XFx0XFx0dmFyIGNzID0gTWF0aC5jb3MoIHF1T3ZlclAgKTtcXG5cXG5cXHRcXHRcXHRwb3NpdGlvbi54ID0gcmFkaXVzICogKCAyICsgY3MgKSAqIDAuNSAqIGN1O1xcblxcdFxcdFxcdHBvc2l0aW9uLnkgPSByYWRpdXMgKiAoIDIgKyBjcyApICogc3UgKiAwLjU7XFxuXFx0XFx0XFx0cG9zaXRpb24ueiA9IHJhZGl1cyAqIE1hdGguc2luKCBxdU92ZXJQICkgKiAwLjU7XFxuXFxuXFx0XFx0fVxcblxcblxcdH1cXG5cXG5cXHRUb3J1c0tub3RCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcXG5cXHRUb3J1c0tub3RCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUb3J1c0tub3RCdWZmZXJHZW9tZXRyeTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG9vc21veGllY29kZVxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcXG5cXHQgKi9cXG5cXG5cXHQvLyBUb3J1c0dlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gVG9ydXNHZW9tZXRyeSggcmFkaXVzLCB0dWJlLCByYWRpYWxTZWdtZW50cywgdHVidWxhclNlZ21lbnRzLCBhcmMgKSB7XFxuXFxuXFx0XFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdUb3J1c0dlb21ldHJ5JztcXG5cXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxuXFx0XFx0XFx0cmFkaXVzOiByYWRpdXMsXFxuXFx0XFx0XFx0dHViZTogdHViZSxcXG5cXHRcXHRcXHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXFxuXFx0XFx0XFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXFxuXFx0XFx0XFx0YXJjOiBhcmNcXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgVG9ydXNCdWZmZXJHZW9tZXRyeSggcmFkaXVzLCB0dWJlLCByYWRpYWxTZWdtZW50cywgdHVidWxhclNlZ21lbnRzLCBhcmMgKSApO1xcblxcdFxcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xcblxcblxcdH1cXG5cXG5cXHRUb3J1c0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xcblxcdFRvcnVzR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVG9ydXNHZW9tZXRyeTtcXG5cXG5cXHQvLyBUb3J1c0J1ZmZlckdlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gVG9ydXNCdWZmZXJHZW9tZXRyeSggcmFkaXVzLCB0dWJlLCByYWRpYWxTZWdtZW50cywgdHVidWxhclNlZ21lbnRzLCBhcmMgKSB7XFxuXFxuXFx0XFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdUb3J1c0J1ZmZlckdlb21ldHJ5JztcXG5cXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxuXFx0XFx0XFx0cmFkaXVzOiByYWRpdXMsXFxuXFx0XFx0XFx0dHViZTogdHViZSxcXG5cXHRcXHRcXHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXFxuXFx0XFx0XFx0dHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXFxuXFx0XFx0XFx0YXJjOiBhcmNcXG5cXHRcXHR9O1xcblxcblxcdFxcdHJhZGl1cyA9IHJhZGl1cyB8fCAxO1xcblxcdFxcdHR1YmUgPSB0dWJlIHx8IDAuNDtcXG5cXHRcXHRyYWRpYWxTZWdtZW50cyA9IE1hdGguZmxvb3IoIHJhZGlhbFNlZ21lbnRzICkgfHwgODtcXG5cXHRcXHR0dWJ1bGFyU2VnbWVudHMgPSBNYXRoLmZsb29yKCB0dWJ1bGFyU2VnbWVudHMgKSB8fCA2O1xcblxcdFxcdGFyYyA9IGFyYyB8fCBNYXRoLlBJICogMjtcXG5cXG5cXHRcXHQvLyBidWZmZXJzXFxuXFxuXFx0XFx0dmFyIGluZGljZXMgPSBbXTtcXG5cXHRcXHR2YXIgdmVydGljZXMgPSBbXTtcXG5cXHRcXHR2YXIgbm9ybWFscyA9IFtdO1xcblxcdFxcdHZhciB1dnMgPSBbXTtcXG5cXG5cXHRcXHQvLyBoZWxwZXIgdmFyaWFibGVzXFxuXFxuXFx0XFx0dmFyIGNlbnRlciA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0dmFyIHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0dmFyIG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0dmFyIGosIGk7XFxuXFxuXFx0XFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xcblxcblxcdFxcdGZvciAoIGogPSAwOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xcblxcblxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdSA9IGkgLyB0dWJ1bGFyU2VnbWVudHMgKiBhcmM7XFxuXFx0XFx0XFx0XFx0dmFyIHYgPSBqIC8gcmFkaWFsU2VnbWVudHMgKiBNYXRoLlBJICogMjtcXG5cXG5cXHRcXHRcXHRcXHQvLyB2ZXJ0ZXhcXG5cXG5cXHRcXHRcXHRcXHR2ZXJ0ZXgueCA9ICggcmFkaXVzICsgdHViZSAqIE1hdGguY29zKCB2ICkgKSAqIE1hdGguY29zKCB1ICk7XFxuXFx0XFx0XFx0XFx0dmVydGV4LnkgPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLnNpbiggdSApO1xcblxcdFxcdFxcdFxcdHZlcnRleC56ID0gdHViZSAqIE1hdGguc2luKCB2ICk7XFxuXFxuXFx0XFx0XFx0XFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xcblxcblxcdFxcdFxcdFxcdC8vIG5vcm1hbFxcblxcblxcdFxcdFxcdFxcdGNlbnRlci54ID0gcmFkaXVzICogTWF0aC5jb3MoIHUgKTtcXG5cXHRcXHRcXHRcXHRjZW50ZXIueSA9IHJhZGl1cyAqIE1hdGguc2luKCB1ICk7XFxuXFx0XFx0XFx0XFx0bm9ybWFsLnN1YlZlY3RvcnMoIHZlcnRleCwgY2VudGVyICkubm9ybWFsaXplKCk7XFxuXFxuXFx0XFx0XFx0XFx0bm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdXZcXG5cXG5cXHRcXHRcXHRcXHR1dnMucHVzaCggaSAvIHR1YnVsYXJTZWdtZW50cyApO1xcblxcdFxcdFxcdFxcdHV2cy5wdXNoKCBqIC8gcmFkaWFsU2VnbWVudHMgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGdlbmVyYXRlIGluZGljZXNcXG5cXG5cXHRcXHRmb3IgKCBqID0gMTsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gMTsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gaW5kaWNlc1xcblxcblxcdFxcdFxcdFxcdHZhciBhID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiBqICsgaSAtIDE7XFxuXFx0XFx0XFx0XFx0dmFyIGIgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArIGkgLSAxO1xcblxcdFxcdFxcdFxcdHZhciBjID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpO1xcblxcdFxcdFxcdFxcdHZhciBkID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiBqICsgaTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBmYWNlc1xcblxcblxcdFxcdFxcdFxcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xcblxcdFxcdFxcdFxcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gYnVpbGQgZ2VvbWV0cnlcXG5cXG5cXHRcXHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xcblxcblxcdH1cXG5cXG5cXHRUb3J1c0J1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xcblxcdFRvcnVzQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVG9ydXNCdWZmZXJHZW9tZXRyeTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xcblxcdCAqIFBvcnQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWFwYm94L2VhcmN1dCAodjIuMS4yKVxcblxcdCAqL1xcblxcblxcdHZhciBFYXJjdXQgPSB7XFxuXFxuXFx0XFx0dHJpYW5ndWxhdGU6IGZ1bmN0aW9uICggZGF0YSwgaG9sZUluZGljZXMsIGRpbSApIHtcXG5cXG5cXHRcXHRcXHRkaW0gPSBkaW0gfHwgMjtcXG5cXG5cXHRcXHRcXHR2YXIgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGgsXFxuXFx0XFx0XFx0XFx0b3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWyAwIF0gKiBkaW0gOiBkYXRhLmxlbmd0aCxcXG5cXHRcXHRcXHRcXHRvdXRlck5vZGUgPSBsaW5rZWRMaXN0KCBkYXRhLCAwLCBvdXRlckxlbiwgZGltLCB0cnVlICksXFxuXFx0XFx0XFx0XFx0dHJpYW5nbGVzID0gW107XFxuXFxuXFx0XFx0XFx0aWYgKCAhIG91dGVyTm9kZSApIHJldHVybiB0cmlhbmdsZXM7XFxuXFxuXFx0XFx0XFx0dmFyIG1pblgsIG1pblksIG1heFgsIG1heFksIHgsIHksIGludlNpemU7XFxuXFxuXFx0XFx0XFx0aWYgKCBoYXNIb2xlcyApIG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGVzKCBkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0gKTtcXG5cXG5cXHRcXHRcXHQvLyBpZiB0aGUgc2hhcGUgaXMgbm90IHRvbyBzaW1wbGUsIHdlJ2xsIHVzZSB6LW9yZGVyIGN1cnZlIGhhc2ggbGF0ZXI7IGNhbGN1bGF0ZSBwb2x5Z29uIGJib3hcXG5cXG5cXHRcXHRcXHRpZiAoIGRhdGEubGVuZ3RoID4gODAgKiBkaW0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0bWluWCA9IG1heFggPSBkYXRhWyAwIF07XFxuXFx0XFx0XFx0XFx0bWluWSA9IG1heFkgPSBkYXRhWyAxIF07XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSBkaW07IGkgPCBvdXRlckxlbjsgaSArPSBkaW0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0eCA9IGRhdGFbIGkgXTtcXG5cXHRcXHRcXHRcXHRcXHR5ID0gZGF0YVsgaSArIDEgXTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHggPCBtaW5YICkgbWluWCA9IHg7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB5IDwgbWluWSApIG1pblkgPSB5O1xcblxcdFxcdFxcdFxcdFxcdGlmICggeCA+IG1heFggKSBtYXhYID0geDtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHkgPiBtYXhZICkgbWF4WSA9IHk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIG1pblgsIG1pblkgYW5kIGludlNpemUgYXJlIGxhdGVyIHVzZWQgdG8gdHJhbnNmb3JtIGNvb3JkcyBpbnRvIGludGVnZXJzIGZvciB6LW9yZGVyIGNhbGN1bGF0aW9uXFxuXFxuXFx0XFx0XFx0XFx0aW52U2l6ZSA9IE1hdGgubWF4KCBtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkgKTtcXG5cXHRcXHRcXHRcXHRpbnZTaXplID0gaW52U2l6ZSAhPT0gMCA/IDEgLyBpbnZTaXplIDogMDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0ZWFyY3V0TGlua2VkKCBvdXRlck5vZGUsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRyaWFuZ2xlcztcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fTtcXG5cXG5cXHQvLyBjcmVhdGUgYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QgZnJvbSBwb2x5Z29uIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIHdpbmRpbmcgb3JkZXJcXG5cXG5cXHRmdW5jdGlvbiBsaW5rZWRMaXN0KCBkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGNsb2Nrd2lzZSApIHtcXG5cXG5cXHRcXHR2YXIgaSwgbGFzdDtcXG5cXG5cXHRcXHRpZiAoIGNsb2Nrd2lzZSA9PT0gKCBzaWduZWRBcmVhKCBkYXRhLCBzdGFydCwgZW5kLCBkaW0gKSA+IDAgKSApIHtcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gZGltICkgbGFzdCA9IGluc2VydE5vZGUoIGksIGRhdGFbIGkgXSwgZGF0YVsgaSArIDEgXSwgbGFzdCApO1xcblxcblxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0Zm9yICggaSA9IGVuZCAtIGRpbTsgaSA+PSBzdGFydDsgaSAtPSBkaW0gKSBsYXN0ID0gaW5zZXJ0Tm9kZSggaSwgZGF0YVsgaSBdLCBkYXRhWyBpICsgMSBdLCBsYXN0ICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggbGFzdCAmJiBlcXVhbHMoIGxhc3QsIGxhc3QubmV4dCApICkge1xcblxcblxcdFxcdFxcdHJlbW92ZU5vZGUoIGxhc3QgKTtcXG5cXHRcXHRcXHRsYXN0ID0gbGFzdC5uZXh0O1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gbGFzdDtcXG5cXG5cXHR9XFxuXFxuXFx0Ly8gZWxpbWluYXRlIGNvbGluZWFyIG9yIGR1cGxpY2F0ZSBwb2ludHNcXG5cXG5cXHRmdW5jdGlvbiBmaWx0ZXJQb2ludHMoIHN0YXJ0LCBlbmQgKSB7XFxuXFxuXFx0XFx0aWYgKCAhIHN0YXJ0ICkgcmV0dXJuIHN0YXJ0O1xcblxcdFxcdGlmICggISBlbmQgKSBlbmQgPSBzdGFydDtcXG5cXG5cXHRcXHR2YXIgcCA9IHN0YXJ0LCBhZ2FpbjtcXG5cXG5cXHRcXHRkbyB7XFxuXFxuXFx0XFx0XFx0YWdhaW4gPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHRpZiAoICEgcC5zdGVpbmVyICYmICggZXF1YWxzKCBwLCBwLm5leHQgKSB8fCBhcmVhKCBwLnByZXYsIHAsIHAubmV4dCApID09PSAwICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmVtb3ZlTm9kZSggcCApO1xcblxcdFxcdFxcdFxcdHAgPSBlbmQgPSBwLnByZXY7XFxuXFx0XFx0XFx0XFx0aWYgKCBwID09PSBwLm5leHQgKSBicmVhaztcXG5cXHRcXHRcXHRcXHRhZ2FpbiA9IHRydWU7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRwID0gcC5uZXh0O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9IHdoaWxlICggYWdhaW4gfHwgcCAhPT0gZW5kICk7XFxuXFxuXFx0XFx0cmV0dXJuIGVuZDtcXG5cXG5cXHR9XFxuXFxuXFx0Ly8gbWFpbiBlYXIgc2xpY2luZyBsb29wIHdoaWNoIHRyaWFuZ3VsYXRlcyBhIHBvbHlnb24gKGdpdmVuIGFzIGEgbGlua2VkIGxpc3QpXFxuXFxuXFx0ZnVuY3Rpb24gZWFyY3V0TGlua2VkKCBlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCBwYXNzICkge1xcblxcblxcdFxcdGlmICggISBlYXIgKSByZXR1cm47XFxuXFxuXFx0XFx0Ly8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxcblxcblxcdFxcdGlmICggISBwYXNzICYmIGludlNpemUgKSBpbmRleEN1cnZlKCBlYXIsIG1pblgsIG1pblksIGludlNpemUgKTtcXG5cXG5cXHRcXHR2YXIgc3RvcCA9IGVhciwgcHJldiwgbmV4dDtcXG5cXG5cXHRcXHQvLyBpdGVyYXRlIHRocm91Z2ggZWFycywgc2xpY2luZyB0aGVtIG9uZSBieSBvbmVcXG5cXG5cXHRcXHR3aGlsZSAoIGVhci5wcmV2ICE9PSBlYXIubmV4dCApIHtcXG5cXG5cXHRcXHRcXHRwcmV2ID0gZWFyLnByZXY7XFxuXFx0XFx0XFx0bmV4dCA9IGVhci5uZXh0O1xcblxcblxcdFxcdFxcdGlmICggaW52U2l6ZSA/IGlzRWFySGFzaGVkKCBlYXIsIG1pblgsIG1pblksIGludlNpemUgKSA6IGlzRWFyKCBlYXIgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBjdXQgb2ZmIHRoZSB0cmlhbmdsZVxcblxcdFxcdFxcdFxcdHRyaWFuZ2xlcy5wdXNoKCBwcmV2LmkgLyBkaW0gKTtcXG5cXHRcXHRcXHRcXHR0cmlhbmdsZXMucHVzaCggZWFyLmkgLyBkaW0gKTtcXG5cXHRcXHRcXHRcXHR0cmlhbmdsZXMucHVzaCggbmV4dC5pIC8gZGltICk7XFxuXFxuXFx0XFx0XFx0XFx0cmVtb3ZlTm9kZSggZWFyICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gc2tpcHBpbmcgdGhlIG5leHQgdmVydGljZSBsZWFkcyB0byBsZXNzIHNsaXZlciB0cmlhbmdsZXNcXG5cXHRcXHRcXHRcXHRlYXIgPSBuZXh0Lm5leHQ7XFxuXFx0XFx0XFx0XFx0c3RvcCA9IG5leHQubmV4dDtcXG5cXG5cXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0ZWFyID0gbmV4dDtcXG5cXG5cXHRcXHRcXHQvLyBpZiB3ZSBsb29wZWQgdGhyb3VnaCB0aGUgd2hvbGUgcmVtYWluaW5nIHBvbHlnb24gYW5kIGNhbid0IGZpbmQgYW55IG1vcmUgZWFyc1xcblxcblxcdFxcdFxcdGlmICggZWFyID09PSBzdG9wICkge1xcblxcblxcdFxcdFxcdFxcdC8vIHRyeSBmaWx0ZXJpbmcgcG9pbnRzIGFuZCBzbGljaW5nIGFnYWluXFxuXFxuXFx0XFx0XFx0XFx0aWYgKCAhIHBhc3MgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZWFyY3V0TGlua2VkKCBmaWx0ZXJQb2ludHMoIGVhciApLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMSApO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGlmIHRoaXMgZGlkbid0IHdvcmssIHRyeSBjdXJpbmcgYWxsIHNtYWxsIHNlbGYtaW50ZXJzZWN0aW9ucyBsb2NhbGx5XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggcGFzcyA9PT0gMSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRlYXIgPSBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKCBlYXIsIHRyaWFuZ2xlcywgZGltICk7XFxuXFx0XFx0XFx0XFx0XFx0ZWFyY3V0TGlua2VkKCBlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAyICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gYXMgYSBsYXN0IHJlc29ydCwgdHJ5IHNwbGl0dGluZyB0aGUgcmVtYWluaW5nIHBvbHlnb24gaW50byB0d29cXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBwYXNzID09PSAyICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHNwbGl0RWFyY3V0KCBlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0fVxcblxcblxcdC8vIGNoZWNrIHdoZXRoZXIgYSBwb2x5Z29uIG5vZGUgZm9ybXMgYSB2YWxpZCBlYXIgd2l0aCBhZGphY2VudCBub2Rlc1xcblxcblxcdGZ1bmN0aW9uIGlzRWFyKCBlYXIgKSB7XFxuXFxuXFx0XFx0dmFyIGEgPSBlYXIucHJldixcXG5cXHRcXHRcXHRiID0gZWFyLFxcblxcdFxcdFxcdGMgPSBlYXIubmV4dDtcXG5cXG5cXHRcXHRpZiAoIGFyZWEoIGEsIGIsIGMgKSA+PSAwICkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxcblxcblxcdFxcdC8vIG5vdyBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZSBvdGhlciBwb2ludHMgaW5zaWRlIHRoZSBwb3RlbnRpYWwgZWFyXFxuXFx0XFx0dmFyIHAgPSBlYXIubmV4dC5uZXh0O1xcblxcblxcdFxcdHdoaWxlICggcCAhPT0gZWFyLnByZXYgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBwb2ludEluVHJpYW5nbGUoIGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55ICkgJiYgYXJlYSggcC5wcmV2LCBwLCBwLm5leHQgKSA+PSAwICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cCA9IHAubmV4dDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRydWU7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGlzRWFySGFzaGVkKCBlYXIsIG1pblgsIG1pblksIGludlNpemUgKSB7XFxuXFxuXFx0XFx0dmFyIGEgPSBlYXIucHJldixcXG5cXHRcXHRcXHRiID0gZWFyLFxcblxcdFxcdFxcdGMgPSBlYXIubmV4dDtcXG5cXG5cXHRcXHRpZiAoIGFyZWEoIGEsIGIsIGMgKSA+PSAwICkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxcblxcblxcdFxcdC8vIHRyaWFuZ2xlIGJib3g7IG1pbiAmIG1heCBhcmUgY2FsY3VsYXRlZCBsaWtlIHRoaXMgZm9yIHNwZWVkXFxuXFxuXFx0XFx0dmFyIG1pblRYID0gYS54IDwgYi54ID8gKCBhLnggPCBjLnggPyBhLnggOiBjLnggKSA6ICggYi54IDwgYy54ID8gYi54IDogYy54ICksXFxuXFx0XFx0XFx0bWluVFkgPSBhLnkgPCBiLnkgPyAoIGEueSA8IGMueSA/IGEueSA6IGMueSApIDogKCBiLnkgPCBjLnkgPyBiLnkgOiBjLnkgKSxcXG5cXHRcXHRcXHRtYXhUWCA9IGEueCA+IGIueCA/ICggYS54ID4gYy54ID8gYS54IDogYy54ICkgOiAoIGIueCA+IGMueCA/IGIueCA6IGMueCApLFxcblxcdFxcdFxcdG1heFRZID0gYS55ID4gYi55ID8gKCBhLnkgPiBjLnkgPyBhLnkgOiBjLnkgKSA6ICggYi55ID4gYy55ID8gYi55IDogYy55ICk7XFxuXFxuXFx0XFx0Ly8gei1vcmRlciByYW5nZSBmb3IgdGhlIGN1cnJlbnQgdHJpYW5nbGUgYmJveDtcXG5cXG5cXHRcXHR2YXIgbWluWiA9IHpPcmRlciggbWluVFgsIG1pblRZLCBtaW5YLCBtaW5ZLCBpbnZTaXplICksXFxuXFx0XFx0XFx0bWF4WiA9IHpPcmRlciggbWF4VFgsIG1heFRZLCBtaW5YLCBtaW5ZLCBpbnZTaXplICk7XFxuXFxuXFx0XFx0Ly8gZmlyc3QgbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgaW4gaW5jcmVhc2luZyB6LW9yZGVyXFxuXFxuXFx0XFx0dmFyIHAgPSBlYXIubmV4dFo7XFxuXFxuXFx0XFx0d2hpbGUgKCBwICYmIHAueiA8PSBtYXhaICkge1xcblxcblxcdFxcdFxcdGlmICggcCAhPT0gZWFyLnByZXYgJiYgcCAhPT0gZWFyLm5leHQgJiZcXG5cXHRcXHRcXHRcXHRcXHRwb2ludEluVHJpYW5nbGUoIGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55ICkgJiZcXG5cXHRcXHRcXHRcXHRcXHRhcmVhKCBwLnByZXYsIHAsIHAubmV4dCApID49IDAgKSByZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0cCA9IHAubmV4dFo7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIHRoZW4gbG9vayBmb3IgcG9pbnRzIGluIGRlY3JlYXNpbmcgei1vcmRlclxcblxcblxcdFxcdHAgPSBlYXIucHJldlo7XFxuXFxuXFx0XFx0d2hpbGUgKCBwICYmIHAueiA+PSBtaW5aICkge1xcblxcblxcdFxcdFxcdGlmICggcCAhPT0gZWFyLnByZXYgJiYgcCAhPT0gZWFyLm5leHQgJiZcXG5cXHRcXHRcXHRcXHRcXHRwb2ludEluVHJpYW5nbGUoIGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55ICkgJiZcXG5cXHRcXHRcXHRcXHRcXHRhcmVhKCBwLnByZXYsIHAsIHAubmV4dCApID49IDAgKSByZXR1cm4gZmFsc2U7XFxuXFxuXFx0XFx0XFx0cCA9IHAucHJldlo7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB0cnVlO1xcblxcblxcdH1cXG5cXG5cXHQvLyBnbyB0aHJvdWdoIGFsbCBwb2x5Z29uIG5vZGVzIGFuZCBjdXJlIHNtYWxsIGxvY2FsIHNlbGYtaW50ZXJzZWN0aW9uc1xcblxcblxcdGZ1bmN0aW9uIGN1cmVMb2NhbEludGVyc2VjdGlvbnMoIHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSApIHtcXG5cXG5cXHRcXHR2YXIgcCA9IHN0YXJ0O1xcblxcblxcdFxcdGRvIHtcXG5cXG5cXHRcXHRcXHR2YXIgYSA9IHAucHJldiwgYiA9IHAubmV4dC5uZXh0O1xcblxcblxcdFxcdFxcdGlmICggISBlcXVhbHMoIGEsIGIgKSAmJiBpbnRlcnNlY3RzKCBhLCBwLCBwLm5leHQsIGIgKSAmJiBsb2NhbGx5SW5zaWRlKCBhLCBiICkgJiYgbG9jYWxseUluc2lkZSggYiwgYSApICkge1xcblxcblxcdFxcdFxcdFxcdHRyaWFuZ2xlcy5wdXNoKCBhLmkgLyBkaW0gKTtcXG5cXHRcXHRcXHRcXHR0cmlhbmdsZXMucHVzaCggcC5pIC8gZGltICk7XFxuXFx0XFx0XFx0XFx0dHJpYW5nbGVzLnB1c2goIGIuaSAvIGRpbSApO1xcblxcblxcdFxcdFxcdFxcdC8vIHJlbW92ZSB0d28gbm9kZXMgaW52b2x2ZWRcXG5cXG5cXHRcXHRcXHRcXHRyZW1vdmVOb2RlKCBwICk7XFxuXFx0XFx0XFx0XFx0cmVtb3ZlTm9kZSggcC5uZXh0ICk7XFxuXFxuXFx0XFx0XFx0XFx0cCA9IHN0YXJ0ID0gYjtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cCA9IHAubmV4dDtcXG5cXG5cXHRcXHR9IHdoaWxlICggcCAhPT0gc3RhcnQgKTtcXG5cXG5cXHRcXHRyZXR1cm4gcDtcXG5cXG5cXHR9XFxuXFxuXFx0Ly8gdHJ5IHNwbGl0dGluZyBwb2x5Z29uIGludG8gdHdvIGFuZCB0cmlhbmd1bGF0ZSB0aGVtIGluZGVwZW5kZW50bHlcXG5cXG5cXHRmdW5jdGlvbiBzcGxpdEVhcmN1dCggc3RhcnQsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplICkge1xcblxcblxcdFxcdC8vIGxvb2sgZm9yIGEgdmFsaWQgZGlhZ29uYWwgdGhhdCBkaXZpZGVzIHRoZSBwb2x5Z29uIGludG8gdHdvXFxuXFxuXFx0XFx0dmFyIGEgPSBzdGFydDtcXG5cXG5cXHRcXHRkbyB7XFxuXFxuXFx0XFx0XFx0dmFyIGIgPSBhLm5leHQubmV4dDtcXG5cXG5cXHRcXHRcXHR3aGlsZSAoIGIgIT09IGEucHJldiApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGEuaSAhPT0gYi5pICYmIGlzVmFsaWREaWFnb25hbCggYSwgYiApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIHNwbGl0IHRoZSBwb2x5Z29uIGluIHR3byBieSB0aGUgZGlhZ29uYWxcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgYyA9IHNwbGl0UG9seWdvbiggYSwgYiApO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGZpbHRlciBjb2xpbmVhciBwb2ludHMgYXJvdW5kIHRoZSBjdXRzXFxuXFxuXFx0XFx0XFx0XFx0XFx0YSA9IGZpbHRlclBvaW50cyggYSwgYS5uZXh0ICk7XFxuXFx0XFx0XFx0XFx0XFx0YyA9IGZpbHRlclBvaW50cyggYywgYy5uZXh0ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gcnVuIGVhcmN1dCBvbiBlYWNoIGhhbGZcXG5cXG5cXHRcXHRcXHRcXHRcXHRlYXJjdXRMaW5rZWQoIGEsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplICk7XFxuXFx0XFx0XFx0XFx0XFx0ZWFyY3V0TGlua2VkKCBjLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSApO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0YiA9IGIubmV4dDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0YSA9IGEubmV4dDtcXG5cXG5cXHRcXHR9IHdoaWxlICggYSAhPT0gc3RhcnQgKTtcXG5cXG5cXHR9XFxuXFxuXFx0Ly8gbGluayBldmVyeSBob2xlIGludG8gdGhlIG91dGVyIGxvb3AsIHByb2R1Y2luZyBhIHNpbmdsZS1yaW5nIHBvbHlnb24gd2l0aG91dCBob2xlc1xcblxcblxcdGZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGVzKCBkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0gKSB7XFxuXFxuXFx0XFx0dmFyIHF1ZXVlID0gW10sIGksIGxlbiwgc3RhcnQsIGVuZCwgbGlzdDtcXG5cXG5cXHRcXHRmb3IgKCBpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpICsrICkge1xcblxcblxcdFxcdFxcdHN0YXJ0ID0gaG9sZUluZGljZXNbIGkgXSAqIGRpbTtcXG5cXHRcXHRcXHRlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzWyBpICsgMSBdICogZGltIDogZGF0YS5sZW5ndGg7XFxuXFx0XFx0XFx0bGlzdCA9IGxpbmtlZExpc3QoIGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgZmFsc2UgKTtcXG5cXHRcXHRcXHRpZiAoIGxpc3QgPT09IGxpc3QubmV4dCApIGxpc3Quc3RlaW5lciA9IHRydWU7XFxuXFx0XFx0XFx0cXVldWUucHVzaCggZ2V0TGVmdG1vc3QoIGxpc3QgKSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRxdWV1ZS5zb3J0KCBjb21wYXJlWCApO1xcblxcblxcdFxcdC8vIHByb2Nlc3MgaG9sZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0XFxuXFxuXFx0XFx0Zm9yICggaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0ZWxpbWluYXRlSG9sZSggcXVldWVbIGkgXSwgb3V0ZXJOb2RlICk7XFxuXFx0XFx0XFx0b3V0ZXJOb2RlID0gZmlsdGVyUG9pbnRzKCBvdXRlck5vZGUsIG91dGVyTm9kZS5uZXh0ICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBvdXRlck5vZGU7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGNvbXBhcmVYKCBhLCBiICkge1xcblxcblxcdFxcdHJldHVybiBhLnggLSBiLng7XFxuXFxuXFx0fVxcblxcblxcdC8vIGZpbmQgYSBicmlkZ2UgYmV0d2VlbiB2ZXJ0aWNlcyB0aGF0IGNvbm5lY3RzIGhvbGUgd2l0aCBhbiBvdXRlciByaW5nIGFuZCBhbmQgbGluayBpdFxcblxcblxcdGZ1bmN0aW9uIGVsaW1pbmF0ZUhvbGUoIGhvbGUsIG91dGVyTm9kZSApIHtcXG5cXG5cXHRcXHRvdXRlck5vZGUgPSBmaW5kSG9sZUJyaWRnZSggaG9sZSwgb3V0ZXJOb2RlICk7XFxuXFxuXFx0XFx0aWYgKCBvdXRlck5vZGUgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGIgPSBzcGxpdFBvbHlnb24oIG91dGVyTm9kZSwgaG9sZSApO1xcblxcblxcdFxcdFxcdGZpbHRlclBvaW50cyggYiwgYi5uZXh0ICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH1cXG5cXG5cXHQvLyBEYXZpZCBFYmVybHkncyBhbGdvcml0aG0gZm9yIGZpbmRpbmcgYSBicmlkZ2UgYmV0d2VlbiBob2xlIGFuZCBvdXRlciBwb2x5Z29uXFxuXFxuXFx0ZnVuY3Rpb24gZmluZEhvbGVCcmlkZ2UoIGhvbGUsIG91dGVyTm9kZSApIHtcXG5cXG5cXHRcXHR2YXIgcCA9IG91dGVyTm9kZSxcXG5cXHRcXHRcXHRoeCA9IGhvbGUueCxcXG5cXHRcXHRcXHRoeSA9IGhvbGUueSxcXG5cXHRcXHRcXHRxeCA9IC0gSW5maW5pdHksXFxuXFx0XFx0XFx0bTtcXG5cXG5cXHRcXHQvLyBmaW5kIGEgc2VnbWVudCBpbnRlcnNlY3RlZCBieSBhIHJheSBmcm9tIHRoZSBob2xlJ3MgbGVmdG1vc3QgcG9pbnQgdG8gdGhlIGxlZnQ7XFxuXFx0XFx0Ly8gc2VnbWVudCdzIGVuZHBvaW50IHdpdGggbGVzc2VyIHggd2lsbCBiZSBwb3RlbnRpYWwgY29ubmVjdGlvbiBwb2ludFxcblxcblxcdFxcdGRvIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGh5IDw9IHAueSAmJiBoeSA+PSBwLm5leHQueSAmJiBwLm5leHQueSAhPT0gcC55ICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB4ID0gcC54ICsgKCBoeSAtIHAueSApICogKCBwLm5leHQueCAtIHAueCApIC8gKCBwLm5leHQueSAtIHAueSApO1xcblxcblxcdFxcdFxcdFxcdGlmICggeCA8PSBoeCAmJiB4ID4gcXggKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cXggPSB4O1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggeCA9PT0gaHggKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBoeSA9PT0gcC55ICkgcmV0dXJuIHA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBoeSA9PT0gcC5uZXh0LnkgKSByZXR1cm4gcC5uZXh0O1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRtID0gcC54IDwgcC5uZXh0LnggPyBwIDogcC5uZXh0O1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cCA9IHAubmV4dDtcXG5cXG5cXHRcXHR9IHdoaWxlICggcCAhPT0gb3V0ZXJOb2RlICk7XFxuXFxuXFx0XFx0aWYgKCAhIG0gKSByZXR1cm4gbnVsbDtcXG5cXG5cXHRcXHRpZiAoIGh4ID09PSBxeCApIHJldHVybiBtLnByZXY7IC8vIGhvbGUgdG91Y2hlcyBvdXRlciBzZWdtZW50OyBwaWNrIGxvd2VyIGVuZHBvaW50XFxuXFxuXFx0XFx0Ly8gbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgb2YgaG9sZSBwb2ludCwgc2VnbWVudCBpbnRlcnNlY3Rpb24gYW5kIGVuZHBvaW50O1xcblxcdFxcdC8vIGlmIHRoZXJlIGFyZSBubyBwb2ludHMgZm91bmQsIHdlIGhhdmUgYSB2YWxpZCBjb25uZWN0aW9uO1xcblxcdFxcdC8vIG90aGVyd2lzZSBjaG9vc2UgdGhlIHBvaW50IG9mIHRoZSBtaW5pbXVtIGFuZ2xlIHdpdGggdGhlIHJheSBhcyBjb25uZWN0aW9uIHBvaW50XFxuXFxuXFx0XFx0dmFyIHN0b3AgPSBtLFxcblxcdFxcdFxcdG14ID0gbS54LFxcblxcdFxcdFxcdG15ID0gbS55LFxcblxcdFxcdFxcdHRhbk1pbiA9IEluZmluaXR5LFxcblxcdFxcdFxcdHRhbjtcXG5cXG5cXHRcXHRwID0gbS5uZXh0O1xcblxcblxcdFxcdHdoaWxlICggcCAhPT0gc3RvcCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGh4ID49IHAueCAmJiBwLnggPj0gbXggJiYgaHggIT09IHAueCAmJlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHBvaW50SW5UcmlhbmdsZSggaHkgPCBteSA/IGh4IDogcXgsIGh5LCBteCwgbXksIGh5IDwgbXkgPyBxeCA6IGh4LCBoeSwgcC54LCBwLnkgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0YW4gPSBNYXRoLmFicyggaHkgLSBwLnkgKSAvICggaHggLSBwLnggKTsgLy8gdGFuZ2VudGlhbFxcblxcblxcdFxcdFxcdFxcdGlmICggKCB0YW4gPCB0YW5NaW4gfHwgKCB0YW4gPT09IHRhbk1pbiAmJiBwLnggPiBtLnggKSApICYmIGxvY2FsbHlJbnNpZGUoIHAsIGhvbGUgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRtID0gcDtcXG5cXHRcXHRcXHRcXHRcXHR0YW5NaW4gPSB0YW47XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRwID0gcC5uZXh0O1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gbTtcXG5cXG5cXHR9XFxuXFxuXFx0Ly8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxcblxcblxcdGZ1bmN0aW9uIGluZGV4Q3VydmUoIHN0YXJ0LCBtaW5YLCBtaW5ZLCBpbnZTaXplICkge1xcblxcblxcdFxcdHZhciBwID0gc3RhcnQ7XFxuXFxuXFx0XFx0ZG8ge1xcblxcblxcdFxcdFxcdGlmICggcC56ID09PSBudWxsICkgcC56ID0gek9yZGVyKCBwLngsIHAueSwgbWluWCwgbWluWSwgaW52U2l6ZSApO1xcblxcdFxcdFxcdHAucHJldlogPSBwLnByZXY7XFxuXFx0XFx0XFx0cC5uZXh0WiA9IHAubmV4dDtcXG5cXHRcXHRcXHRwID0gcC5uZXh0O1xcblxcblxcdFxcdH0gd2hpbGUgKCBwICE9PSBzdGFydCApO1xcblxcblxcdFxcdHAucHJldloubmV4dFogPSBudWxsO1xcblxcdFxcdHAucHJldlogPSBudWxsO1xcblxcblxcdFxcdHNvcnRMaW5rZWQoIHAgKTtcXG5cXG5cXHR9XFxuXFxuXFx0Ly8gU2ltb24gVGF0aGFtJ3MgbGlua2VkIGxpc3QgbWVyZ2Ugc29ydCBhbGdvcml0aG1cXG5cXHQvLyBodHRwOi8vd3d3LmNoaWFyay5ncmVlbmVuZC5vcmcudWsvfnNndGF0aGFtL2FsZ29yaXRobXMvbGlzdHNvcnQuaHRtbFxcblxcblxcdGZ1bmN0aW9uIHNvcnRMaW5rZWQoIGxpc3QgKSB7XFxuXFxuXFx0XFx0dmFyIGksIHAsIHEsIGUsIHRhaWwsIG51bU1lcmdlcywgcFNpemUsIHFTaXplLCBpblNpemUgPSAxO1xcblxcblxcdFxcdGRvIHtcXG5cXG5cXHRcXHRcXHRwID0gbGlzdDtcXG5cXHRcXHRcXHRsaXN0ID0gbnVsbDtcXG5cXHRcXHRcXHR0YWlsID0gbnVsbDtcXG5cXHRcXHRcXHRudW1NZXJnZXMgPSAwO1xcblxcblxcdFxcdFxcdHdoaWxlICggcCApIHtcXG5cXG5cXHRcXHRcXHRcXHRudW1NZXJnZXMgKys7XFxuXFx0XFx0XFx0XFx0cSA9IHA7XFxuXFx0XFx0XFx0XFx0cFNpemUgPSAwO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDwgaW5TaXplOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHBTaXplICsrO1xcblxcdFxcdFxcdFxcdFxcdHEgPSBxLm5leHRaO1xcblxcdFxcdFxcdFxcdFxcdGlmICggISBxICkgYnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHFTaXplID0gaW5TaXplO1xcblxcblxcdFxcdFxcdFxcdHdoaWxlICggcFNpemUgPiAwIHx8ICggcVNpemUgPiAwICYmIHEgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHBTaXplICE9PSAwICYmICggcVNpemUgPT09IDAgfHwgISBxIHx8IHAueiA8PSBxLnogKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRlID0gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwID0gcC5uZXh0WjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwU2l6ZSAtLTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGUgPSBxO1xcblxcdFxcdFxcdFxcdFxcdFxcdHEgPSBxLm5leHRaO1xcblxcdFxcdFxcdFxcdFxcdFxcdHFTaXplIC0tO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHRhaWwgKSB0YWlsLm5leHRaID0gZTtcXG5cXHRcXHRcXHRcXHRcXHRlbHNlIGxpc3QgPSBlO1xcblxcblxcdFxcdFxcdFxcdFxcdGUucHJldlogPSB0YWlsO1xcblxcdFxcdFxcdFxcdFxcdHRhaWwgPSBlO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRwID0gcTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGFpbC5uZXh0WiA9IG51bGw7XFxuXFx0XFx0XFx0aW5TaXplICo9IDI7XFxuXFxuXFx0XFx0fSB3aGlsZSAoIG51bU1lcmdlcyA+IDEgKTtcXG5cXG5cXHRcXHRyZXR1cm4gbGlzdDtcXG5cXG5cXHR9XFxuXFxuXFx0Ly8gei1vcmRlciBvZiBhIHBvaW50IGdpdmVuIGNvb3JkcyBhbmQgaW52ZXJzZSBvZiB0aGUgbG9uZ2VyIHNpZGUgb2YgZGF0YSBiYm94XFxuXFxuXFx0ZnVuY3Rpb24gek9yZGVyKCB4LCB5LCBtaW5YLCBtaW5ZLCBpbnZTaXplICkge1xcblxcblxcdFxcdC8vIGNvb3JkcyBhcmUgdHJhbnNmb3JtZWQgaW50byBub24tbmVnYXRpdmUgMTUtYml0IGludGVnZXIgcmFuZ2VcXG5cXG5cXHRcXHR4ID0gMzI3NjcgKiAoIHggLSBtaW5YICkgKiBpbnZTaXplO1xcblxcdFxcdHkgPSAzMjc2NyAqICggeSAtIG1pblkgKSAqIGludlNpemU7XFxuXFxuXFx0XFx0eCA9ICggeCB8ICggeCA8PCA4ICkgKSAmIDB4MDBGRjAwRkY7XFxuXFx0XFx0eCA9ICggeCB8ICggeCA8PCA0ICkgKSAmIDB4MEYwRjBGMEY7XFxuXFx0XFx0eCA9ICggeCB8ICggeCA8PCAyICkgKSAmIDB4MzMzMzMzMzM7XFxuXFx0XFx0eCA9ICggeCB8ICggeCA8PCAxICkgKSAmIDB4NTU1NTU1NTU7XFxuXFxuXFx0XFx0eSA9ICggeSB8ICggeSA8PCA4ICkgKSAmIDB4MDBGRjAwRkY7XFxuXFx0XFx0eSA9ICggeSB8ICggeSA8PCA0ICkgKSAmIDB4MEYwRjBGMEY7XFxuXFx0XFx0eSA9ICggeSB8ICggeSA8PCAyICkgKSAmIDB4MzMzMzMzMzM7XFxuXFx0XFx0eSA9ICggeSB8ICggeSA8PCAxICkgKSAmIDB4NTU1NTU1NTU7XFxuXFxuXFx0XFx0cmV0dXJuIHggfCAoIHkgPDwgMSApO1xcblxcblxcdH1cXG5cXG5cXHQvLyBmaW5kIHRoZSBsZWZ0bW9zdCBub2RlIG9mIGEgcG9seWdvbiByaW5nXFxuXFxuXFx0ZnVuY3Rpb24gZ2V0TGVmdG1vc3QoIHN0YXJ0ICkge1xcblxcblxcdFxcdHZhciBwID0gc3RhcnQsIGxlZnRtb3N0ID0gc3RhcnQ7XFxuXFxuXFx0XFx0ZG8ge1xcblxcblxcdFxcdFxcdGlmICggcC54IDwgbGVmdG1vc3QueCApIGxlZnRtb3N0ID0gcDtcXG5cXHRcXHRcXHRwID0gcC5uZXh0O1xcblxcblxcdFxcdH0gd2hpbGUgKCBwICE9PSBzdGFydCApO1xcblxcblxcdFxcdHJldHVybiBsZWZ0bW9zdDtcXG5cXG5cXHR9XFxuXFxuXFx0Ly8gY2hlY2sgaWYgYSBwb2ludCBsaWVzIHdpdGhpbiBhIGNvbnZleCB0cmlhbmdsZVxcblxcblxcdGZ1bmN0aW9uIHBvaW50SW5UcmlhbmdsZSggYXgsIGF5LCBieCwgYnksIGN4LCBjeSwgcHgsIHB5ICkge1xcblxcblxcdFxcdHJldHVybiAoIGN4IC0gcHggKSAqICggYXkgLSBweSApIC0gKCBheCAtIHB4ICkgKiAoIGN5IC0gcHkgKSA+PSAwICYmXFxuXFx0XFx0ICggYXggLSBweCApICogKCBieSAtIHB5ICkgLSAoIGJ4IC0gcHggKSAqICggYXkgLSBweSApID49IDAgJiZcXG5cXHRcXHQgKCBieCAtIHB4ICkgKiAoIGN5IC0gcHkgKSAtICggY3ggLSBweCApICogKCBieSAtIHB5ICkgPj0gMDtcXG5cXG5cXHR9XFxuXFxuXFx0Ly8gY2hlY2sgaWYgYSBkaWFnb25hbCBiZXR3ZWVuIHR3byBwb2x5Z29uIG5vZGVzIGlzIHZhbGlkIChsaWVzIGluIHBvbHlnb24gaW50ZXJpb3IpXFxuXFxuXFx0ZnVuY3Rpb24gaXNWYWxpZERpYWdvbmFsKCBhLCBiICkge1xcblxcblxcdFxcdHJldHVybiBhLm5leHQuaSAhPT0gYi5pICYmIGEucHJldi5pICE9PSBiLmkgJiYgISBpbnRlcnNlY3RzUG9seWdvbiggYSwgYiApICYmXFxuXFx0XFx0XFx0bG9jYWxseUluc2lkZSggYSwgYiApICYmIGxvY2FsbHlJbnNpZGUoIGIsIGEgKSAmJiBtaWRkbGVJbnNpZGUoIGEsIGIgKTtcXG5cXG5cXHR9XFxuXFxuXFx0Ly8gc2lnbmVkIGFyZWEgb2YgYSB0cmlhbmdsZVxcblxcblxcdGZ1bmN0aW9uIGFyZWEoIHAsIHEsIHIgKSB7XFxuXFxuXFx0XFx0cmV0dXJuICggcS55IC0gcC55ICkgKiAoIHIueCAtIHEueCApIC0gKCBxLnggLSBwLnggKSAqICggci55IC0gcS55ICk7XFxuXFxuXFx0fVxcblxcblxcdC8vIGNoZWNrIGlmIHR3byBwb2ludHMgYXJlIGVxdWFsXFxuXFxuXFx0ZnVuY3Rpb24gZXF1YWxzKCBwMSwgcDIgKSB7XFxuXFxuXFx0XFx0cmV0dXJuIHAxLnggPT09IHAyLnggJiYgcDEueSA9PT0gcDIueTtcXG5cXG5cXHR9XFxuXFxuXFx0Ly8gY2hlY2sgaWYgdHdvIHNlZ21lbnRzIGludGVyc2VjdFxcblxcblxcdGZ1bmN0aW9uIGludGVyc2VjdHMoIHAxLCBxMSwgcDIsIHEyICkge1xcblxcblxcdFxcdGlmICggKCBlcXVhbHMoIHAxLCBxMSApICYmIGVxdWFscyggcDIsIHEyICkgKSB8fFxcblxcdFxcdFxcdFxcdCggZXF1YWxzKCBwMSwgcTIgKSAmJiBlcXVhbHMoIHAyLCBxMSApICkgKSByZXR1cm4gdHJ1ZTtcXG5cXG5cXHRcXHRyZXR1cm4gYXJlYSggcDEsIHExLCBwMiApID4gMCAhPT0gYXJlYSggcDEsIHExLCBxMiApID4gMCAmJlxcblxcdFxcdFxcdFxcdFxcdCBhcmVhKCBwMiwgcTIsIHAxICkgPiAwICE9PSBhcmVhKCBwMiwgcTIsIHExICkgPiAwO1xcblxcblxcdH1cXG5cXG5cXHQvLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaW50ZXJzZWN0cyBhbnkgcG9seWdvbiBzZWdtZW50c1xcblxcblxcdGZ1bmN0aW9uIGludGVyc2VjdHNQb2x5Z29uKCBhLCBiICkge1xcblxcblxcdFxcdHZhciBwID0gYTtcXG5cXG5cXHRcXHRkbyB7XFxuXFxuXFx0XFx0XFx0aWYgKCBwLmkgIT09IGEuaSAmJiBwLm5leHQuaSAhPT0gYS5pICYmIHAuaSAhPT0gYi5pICYmIHAubmV4dC5pICE9PSBiLmkgJiZcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpbnRlcnNlY3RzKCBwLCBwLm5leHQsIGEsIGIgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cCA9IHAubmV4dDtcXG5cXG5cXHRcXHR9IHdoaWxlICggcCAhPT0gYSApO1xcblxcblxcdFxcdHJldHVybiBmYWxzZTtcXG5cXG5cXHR9XFxuXFxuXFx0Ly8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGxvY2FsbHkgaW5zaWRlIHRoZSBwb2x5Z29uXFxuXFxuXFx0ZnVuY3Rpb24gbG9jYWxseUluc2lkZSggYSwgYiApIHtcXG5cXG5cXHRcXHRyZXR1cm4gYXJlYSggYS5wcmV2LCBhLCBhLm5leHQgKSA8IDAgP1xcblxcdFxcdFxcdGFyZWEoIGEsIGIsIGEubmV4dCApID49IDAgJiYgYXJlYSggYSwgYS5wcmV2LCBiICkgPj0gMCA6XFxuXFx0XFx0XFx0YXJlYSggYSwgYiwgYS5wcmV2ICkgPCAwIHx8IGFyZWEoIGEsIGEubmV4dCwgYiApIDwgMDtcXG5cXG5cXHR9XFxuXFxuXFx0Ly8gY2hlY2sgaWYgdGhlIG1pZGRsZSBwb2ludCBvZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgaW5zaWRlIHRoZSBwb2x5Z29uXFxuXFxuXFx0ZnVuY3Rpb24gbWlkZGxlSW5zaWRlKCBhLCBiICkge1xcblxcblxcdFxcdHZhciBwID0gYSxcXG5cXHRcXHRcXHRpbnNpZGUgPSBmYWxzZSxcXG5cXHRcXHRcXHRweCA9ICggYS54ICsgYi54ICkgLyAyLFxcblxcdFxcdFxcdHB5ID0gKCBhLnkgKyBiLnkgKSAvIDI7XFxuXFxuXFx0XFx0ZG8ge1xcblxcblxcdFxcdFxcdGlmICggKCAoIHAueSA+IHB5ICkgIT09ICggcC5uZXh0LnkgPiBweSApICkgJiYgcC5uZXh0LnkgIT09IHAueSAmJlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCggcHggPCAoIHAubmV4dC54IC0gcC54ICkgKiAoIHB5IC0gcC55ICkgLyAoIHAubmV4dC55IC0gcC55ICkgKyBwLnggKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRpbnNpZGUgPSAhIGluc2lkZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cCA9IHAubmV4dDtcXG5cXG5cXHRcXHR9IHdoaWxlICggcCAhPT0gYSApO1xcblxcblxcdFxcdHJldHVybiBpbnNpZGU7XFxuXFxuXFx0fVxcblxcblxcdC8vIGxpbmsgdHdvIHBvbHlnb24gdmVydGljZXMgd2l0aCBhIGJyaWRnZTsgaWYgdGhlIHZlcnRpY2VzIGJlbG9uZyB0byB0aGUgc2FtZSByaW5nLCBpdCBzcGxpdHMgcG9seWdvbiBpbnRvIHR3bztcXG5cXHQvLyBpZiBvbmUgYmVsb25ncyB0byB0aGUgb3V0ZXIgcmluZyBhbmQgYW5vdGhlciB0byBhIGhvbGUsIGl0IG1lcmdlcyBpdCBpbnRvIGEgc2luZ2xlIHJpbmdcXG5cXG5cXHRmdW5jdGlvbiBzcGxpdFBvbHlnb24oIGEsIGIgKSB7XFxuXFxuXFx0XFx0dmFyIGEyID0gbmV3IE5vZGUoIGEuaSwgYS54LCBhLnkgKSxcXG5cXHRcXHRcXHRiMiA9IG5ldyBOb2RlKCBiLmksIGIueCwgYi55ICksXFxuXFx0XFx0XFx0YW4gPSBhLm5leHQsXFxuXFx0XFx0XFx0YnAgPSBiLnByZXY7XFxuXFxuXFx0XFx0YS5uZXh0ID0gYjtcXG5cXHRcXHRiLnByZXYgPSBhO1xcblxcblxcdFxcdGEyLm5leHQgPSBhbjtcXG5cXHRcXHRhbi5wcmV2ID0gYTI7XFxuXFxuXFx0XFx0YjIubmV4dCA9IGEyO1xcblxcdFxcdGEyLnByZXYgPSBiMjtcXG5cXG5cXHRcXHRicC5uZXh0ID0gYjI7XFxuXFx0XFx0YjIucHJldiA9IGJwO1xcblxcblxcdFxcdHJldHVybiBiMjtcXG5cXG5cXHR9XFxuXFxuXFx0Ly8gY3JlYXRlIGEgbm9kZSBhbmQgb3B0aW9uYWxseSBsaW5rIGl0IHdpdGggcHJldmlvdXMgb25lIChpbiBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdClcXG5cXG5cXHRmdW5jdGlvbiBpbnNlcnROb2RlKCBpLCB4LCB5LCBsYXN0ICkge1xcblxcblxcdFxcdHZhciBwID0gbmV3IE5vZGUoIGksIHgsIHkgKTtcXG5cXG5cXHRcXHRpZiAoICEgbGFzdCApIHtcXG5cXG5cXHRcXHRcXHRwLnByZXYgPSBwO1xcblxcdFxcdFxcdHAubmV4dCA9IHA7XFxuXFxuXFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRwLm5leHQgPSBsYXN0Lm5leHQ7XFxuXFx0XFx0XFx0cC5wcmV2ID0gbGFzdDtcXG5cXHRcXHRcXHRsYXN0Lm5leHQucHJldiA9IHA7XFxuXFx0XFx0XFx0bGFzdC5uZXh0ID0gcDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHA7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIHJlbW92ZU5vZGUoIHAgKSB7XFxuXFxuXFx0XFx0cC5uZXh0LnByZXYgPSBwLnByZXY7XFxuXFx0XFx0cC5wcmV2Lm5leHQgPSBwLm5leHQ7XFxuXFxuXFx0XFx0aWYgKCBwLnByZXZaICkgcC5wcmV2Wi5uZXh0WiA9IHAubmV4dFo7XFxuXFx0XFx0aWYgKCBwLm5leHRaICkgcC5uZXh0Wi5wcmV2WiA9IHAucHJldlo7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIE5vZGUoIGksIHgsIHkgKSB7XFxuXFxuXFx0XFx0Ly8gdmVydGljZSBpbmRleCBpbiBjb29yZGluYXRlcyBhcnJheVxcblxcdFxcdHRoaXMuaSA9IGk7XFxuXFxuXFx0XFx0Ly8gdmVydGV4IGNvb3JkaW5hdGVzXFxuXFx0XFx0dGhpcy54ID0geDtcXG5cXHRcXHR0aGlzLnkgPSB5O1xcblxcblxcdFxcdC8vIHByZXZpb3VzIGFuZCBuZXh0IHZlcnRpY2Ugbm9kZXMgaW4gYSBwb2x5Z29uIHJpbmdcXG5cXHRcXHR0aGlzLnByZXYgPSBudWxsO1xcblxcdFxcdHRoaXMubmV4dCA9IG51bGw7XFxuXFxuXFx0XFx0Ly8gei1vcmRlciBjdXJ2ZSB2YWx1ZVxcblxcdFxcdHRoaXMueiA9IG51bGw7XFxuXFxuXFx0XFx0Ly8gcHJldmlvdXMgYW5kIG5leHQgbm9kZXMgaW4gei1vcmRlclxcblxcdFxcdHRoaXMucHJldlogPSBudWxsO1xcblxcdFxcdHRoaXMubmV4dFogPSBudWxsO1xcblxcblxcdFxcdC8vIGluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYSBzdGVpbmVyIHBvaW50XFxuXFx0XFx0dGhpcy5zdGVpbmVyID0gZmFsc2U7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIHNpZ25lZEFyZWEoIGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSApIHtcXG5cXG5cXHRcXHR2YXIgc3VtID0gMDtcXG5cXG5cXHRcXHRmb3IgKCB2YXIgaSA9IHN0YXJ0LCBqID0gZW5kIC0gZGltOyBpIDwgZW5kOyBpICs9IGRpbSApIHtcXG5cXG5cXHRcXHRcXHRzdW0gKz0gKCBkYXRhWyBqIF0gLSBkYXRhWyBpIF0gKSAqICggZGF0YVsgaSArIDEgXSArIGRhdGFbIGogKyAxIF0gKTtcXG5cXHRcXHRcXHRqID0gaTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHN1bTtcXG5cXG5cXHR9XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xcblxcdCAqL1xcblxcblxcdHZhciBTaGFwZVV0aWxzID0ge1xcblxcblxcdFxcdC8vIGNhbGN1bGF0ZSBhcmVhIG9mIHRoZSBjb250b3VyIHBvbHlnb25cXG5cXG5cXHRcXHRhcmVhOiBmdW5jdGlvbiAoIGNvbnRvdXIgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIG4gPSBjb250b3VyLmxlbmd0aDtcXG5cXHRcXHRcXHR2YXIgYSA9IDAuMDtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgcCA9IG4gLSAxLCBxID0gMDsgcSA8IG47IHAgPSBxICsrICkge1xcblxcblxcdFxcdFxcdFxcdGEgKz0gY29udG91clsgcCBdLnggKiBjb250b3VyWyBxIF0ueSAtIGNvbnRvdXJbIHEgXS54ICogY29udG91clsgcCBdLnk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBhICogMC41O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0aXNDbG9ja1dpc2U6IGZ1bmN0aW9uICggcHRzICkge1xcblxcblxcdFxcdFxcdHJldHVybiBTaGFwZVV0aWxzLmFyZWEoIHB0cyApIDwgMDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHRyaWFuZ3VsYXRlU2hhcGU6IGZ1bmN0aW9uICggY29udG91ciwgaG9sZXMgKSB7XFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gcmVtb3ZlRHVwRW5kUHRzKCBwb2ludHMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGwgPSBwb2ludHMubGVuZ3RoO1xcblxcblxcdFxcdFxcdFxcdGlmICggbCA+IDIgJiYgcG9pbnRzWyBsIC0gMSBdLmVxdWFscyggcG9pbnRzWyAwIF0gKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRwb2ludHMucG9wKCk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmdW5jdGlvbiBhZGRDb250b3VyKCB2ZXJ0aWNlcywgY29udG91ciApIHtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjb250b3VyLmxlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCBjb250b3VyWyBpIF0ueCApO1xcblxcdFxcdFxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIGNvbnRvdXJbIGkgXS55ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgdmVydGljZXMgPSBbXTsgLy8gZmxhdCBhcnJheSBvZiB2ZXJ0aWNlcyBsaWtlIFsgeDAseTAsIHgxLHkxLCB4Mix5MiwgLi4uIF1cXG5cXHRcXHRcXHR2YXIgaG9sZUluZGljZXMgPSBbXTsgLy8gYXJyYXkgb2YgaG9sZSBpbmRpY2VzXFxuXFx0XFx0XFx0dmFyIGZhY2VzID0gW107IC8vIGZpbmFsIGFycmF5IG9mIHZlcnRleCBpbmRpY2VzIGxpa2UgWyBbIGEsYixkIF0sIFsgYixjLGQgXSBdXFxuXFxuXFx0XFx0XFx0cmVtb3ZlRHVwRW5kUHRzKCBjb250b3VyICk7XFxuXFx0XFx0XFx0YWRkQ29udG91ciggdmVydGljZXMsIGNvbnRvdXIgKTtcXG5cXG5cXHRcXHRcXHQvL1xcblxcblxcdFxcdFxcdHZhciBob2xlSW5kZXggPSBjb250b3VyLmxlbmd0aDtcXG5cXHRcXHRcXHRob2xlcy5mb3JFYWNoKCByZW1vdmVEdXBFbmRQdHMgKTtcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gMDsgaSA8IGhvbGVzLmxlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRob2xlSW5kaWNlcy5wdXNoKCBob2xlSW5kZXggKTtcXG5cXHRcXHRcXHRcXHRob2xlSW5kZXggKz0gaG9sZXNbIGkgXS5sZW5ndGg7XFxuXFx0XFx0XFx0XFx0YWRkQ29udG91ciggdmVydGljZXMsIGhvbGVzWyBpIF0gKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly9cXG5cXG5cXHRcXHRcXHR2YXIgdHJpYW5nbGVzID0gRWFyY3V0LnRyaWFuZ3VsYXRlKCB2ZXJ0aWNlcywgaG9sZUluZGljZXMgKTtcXG5cXG5cXHRcXHRcXHQvL1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkgKz0gMyApIHtcXG5cXG5cXHRcXHRcXHRcXHRmYWNlcy5wdXNoKCB0cmlhbmdsZXMuc2xpY2UoIGksIGkgKyAzICkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZhY2VzO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcXG5cXHQgKlxcblxcdCAqIENyZWF0ZXMgZXh0cnVkZWQgZ2VvbWV0cnkgZnJvbSBhIHBhdGggc2hhcGUuXFxuXFx0ICpcXG5cXHQgKiBwYXJhbWV0ZXJzID0ge1xcblxcdCAqXFxuXFx0ICogIGN1cnZlU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXNcXG5cXHQgKiAgc3RlcHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIGZvciB6LXNpZGUgZXh0cnVzaW9ucyAvIHVzZWQgZm9yIHN1YmRpdmlkaW5nIHNlZ21lbnRzIG9mIGV4dHJ1ZGUgc3BsaW5lIHRvb1xcblxcdCAqICBhbW91bnQ6IDxpbnQ+LCAvLyBEZXB0aCB0byBleHRydWRlIHRoZSBzaGFwZVxcblxcdCAqXFxuXFx0ICogIGJldmVsRW5hYmxlZDogPGJvb2w+LCAvLyB0dXJuIG9uIGJldmVsXFxuXFx0ICogIGJldmVsVGhpY2tuZXNzOiA8ZmxvYXQ+LCAvLyBob3cgZGVlcCBpbnRvIHRoZSBvcmlnaW5hbCBzaGFwZSBiZXZlbCBnb2VzXFxuXFx0ICogIGJldmVsU2l6ZTogPGZsb2F0PiwgLy8gaG93IGZhciBmcm9tIHNoYXBlIG91dGxpbmUgaXMgYmV2ZWxcXG5cXHQgKiAgYmV2ZWxTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBiZXZlbCBsYXllcnNcXG5cXHQgKlxcblxcdCAqICBleHRydWRlUGF0aDogPFRIUkVFLkN1cnZlPiAvLyBjdXJ2ZSB0byBleHRydWRlIHNoYXBlIGFsb25nXFxuXFx0ICogIGZyYW1lczogPE9iamVjdD4gLy8gY29udGFpbmluZyBhcnJheXMgb2YgdGFuZ2VudHMsIG5vcm1hbHMsIGJpbm9ybWFsc1xcblxcdCAqXFxuXFx0ICogIFVWR2VuZXJhdG9yOiA8T2JqZWN0PiAvLyBvYmplY3QgdGhhdCBwcm92aWRlcyBVViBnZW5lcmF0b3IgZnVuY3Rpb25zXFxuXFx0ICpcXG5cXHQgKiB9XFxuXFx0ICovXFxuXFxuXFx0Ly8gRXh0cnVkZUdlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gRXh0cnVkZUdlb21ldHJ5KCBzaGFwZXMsIG9wdGlvbnMgKSB7XFxuXFxuXFx0XFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdFeHRydWRlR2VvbWV0cnknO1xcblxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXG5cXHRcXHRcXHRzaGFwZXM6IHNoYXBlcyxcXG5cXHRcXHRcXHRvcHRpb25zOiBvcHRpb25zXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeSggc2hhcGVzLCBvcHRpb25zICkgKTtcXG5cXHRcXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcXG5cXG5cXHR9XFxuXFxuXFx0RXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xcblxcdEV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFeHRydWRlR2VvbWV0cnk7XFxuXFxuXFx0Ly8gRXh0cnVkZUJ1ZmZlckdlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gRXh0cnVkZUJ1ZmZlckdlb21ldHJ5KCBzaGFwZXMsIG9wdGlvbnMgKSB7XFxuXFxuXFx0XFx0aWYgKCB0eXBlb2YgKCBzaGFwZXMgKSA9PT0gXFxcInVuZGVmaW5lZFxcXCIgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ0V4dHJ1ZGVCdWZmZXJHZW9tZXRyeSc7XFxuXFxuXFx0XFx0c2hhcGVzID0gQXJyYXkuaXNBcnJheSggc2hhcGVzICkgPyBzaGFwZXMgOiBbIHNoYXBlcyBdO1xcblxcblxcdFxcdHRoaXMuYWRkU2hhcGVMaXN0KCBzaGFwZXMsIG9wdGlvbnMgKTtcXG5cXG5cXHRcXHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XFxuXFxuXFx0XFx0Ly8gY2FuJ3QgcmVhbGx5IHVzZSBhdXRvbWF0aWMgdmVydGV4IG5vcm1hbHNcXG5cXHRcXHQvLyBhcyB0aGVuIGZyb250IGFuZCBiYWNrIHNpZGVzIGdldCBzbW9vdGhlZCB0b29cXG5cXHRcXHQvLyBzaG91bGQgZG8gc2VwYXJhdGUgc21vb3RoaW5nIGp1c3QgZm9yIHNpZGVzXFxuXFxuXFx0XFx0Ly90aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XFxuXFxuXFx0XFx0Ly9jb25zb2xlLmxvZyggXFxcInRvb2tcXFwiLCAoIERhdGUubm93KCkgLSBzdGFydFRpbWUgKSApO1xcblxcblxcdH1cXG5cXG5cXHRFeHRydWRlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XFxuXFx0RXh0cnVkZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeTtcXG5cXG5cXHRFeHRydWRlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmdldEFycmF5cyA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHR2YXIgcG9zaXRpb25BdHRyaWJ1dGUgPSB0aGlzLmdldEF0dHJpYnV0ZSggXFxcInBvc2l0aW9uXFxcIiApO1xcblxcdFxcdHZhciB2ZXJ0aWNlc0FycmF5ID0gcG9zaXRpb25BdHRyaWJ1dGUgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggcG9zaXRpb25BdHRyaWJ1dGUuYXJyYXkgKSA6IFtdO1xcblxcblxcdFxcdHZhciB1dkF0dHJpYnV0ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCBcXFwidXZcXFwiICk7XFxuXFx0XFx0dmFyIHV2QXJyYXkgPSB1dkF0dHJpYnV0ZSA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCB1dkF0dHJpYnV0ZS5hcnJheSApIDogW107XFxuXFxuXFx0XFx0dmFyIEluZGV4QXR0cmlidXRlID0gdGhpcy5pbmRleDtcXG5cXHRcXHR2YXIgaW5kaWNlc0FycmF5ID0gSW5kZXhBdHRyaWJ1dGUgPyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggSW5kZXhBdHRyaWJ1dGUuYXJyYXkgKSA6IFtdO1xcblxcblxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0cG9zaXRpb246IHZlcnRpY2VzQXJyYXksXFxuXFx0XFx0XFx0dXY6IHV2QXJyYXksXFxuXFx0XFx0XFx0aW5kZXg6IGluZGljZXNBcnJheVxcblxcdFxcdH07XFxuXFxuXFx0fTtcXG5cXG5cXHRFeHRydWRlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlTGlzdCA9IGZ1bmN0aW9uICggc2hhcGVzLCBvcHRpb25zICkge1xcblxcblxcdFxcdHZhciBzbCA9IHNoYXBlcy5sZW5ndGg7XFxuXFx0XFx0b3B0aW9ucy5hcnJheXMgPSB0aGlzLmdldEFycmF5cygpO1xcblxcblxcdFxcdGZvciAoIHZhciBzID0gMDsgcyA8IHNsOyBzICsrICkge1xcblxcblxcdFxcdFxcdHZhciBzaGFwZSA9IHNoYXBlc1sgcyBdO1xcblxcdFxcdFxcdHRoaXMuYWRkU2hhcGUoIHNoYXBlLCBvcHRpb25zICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuc2V0SW5kZXgoIG9wdGlvbnMuYXJyYXlzLmluZGV4ICk7XFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBvcHRpb25zLmFycmF5cy5wb3NpdGlvbiwgMyApICk7XFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBvcHRpb25zLmFycmF5cy51diwgMiApICk7XFxuXFxuXFx0fTtcXG5cXG5cXHRFeHRydWRlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24gKCBzaGFwZSwgb3B0aW9ucyApIHtcXG5cXG5cXHRcXHR2YXIgYXJyYXlzID0gb3B0aW9ucy5hcnJheXMgPyBvcHRpb25zLmFycmF5cyA6IHRoaXMuZ2V0QXJyYXlzKCk7XFxuXFx0XFx0dmFyIHZlcnRpY2VzQXJyYXkgPSBhcnJheXMucG9zaXRpb247XFxuXFx0XFx0dmFyIGluZGljZXNBcnJheSA9IGFycmF5cy5pbmRleDtcXG5cXHRcXHR2YXIgdXZBcnJheSA9IGFycmF5cy51djtcXG5cXG5cXHRcXHR2YXIgcGxhY2Vob2xkZXIgPSBbXTtcXG5cXG5cXG5cXHRcXHR2YXIgYW1vdW50ID0gb3B0aW9ucy5hbW91bnQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYW1vdW50IDogMTAwO1xcblxcblxcdFxcdHZhciBiZXZlbFRoaWNrbmVzcyA9IG9wdGlvbnMuYmV2ZWxUaGlja25lc3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxUaGlja25lc3MgOiA2OyAvLyAxMFxcblxcdFxcdHZhciBiZXZlbFNpemUgPSBvcHRpb25zLmJldmVsU2l6ZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNpemUgOiBiZXZlbFRoaWNrbmVzcyAtIDI7IC8vIDhcXG5cXHRcXHR2YXIgYmV2ZWxTZWdtZW50cyA9IG9wdGlvbnMuYmV2ZWxTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNlZ21lbnRzIDogMztcXG5cXG5cXHRcXHR2YXIgYmV2ZWxFbmFibGVkID0gb3B0aW9ucy5iZXZlbEVuYWJsZWQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxFbmFibGVkIDogdHJ1ZTsgLy8gZmFsc2VcXG5cXG5cXHRcXHR2YXIgY3VydmVTZWdtZW50cyA9IG9wdGlvbnMuY3VydmVTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzIDogMTI7XFxuXFxuXFx0XFx0dmFyIHN0ZXBzID0gb3B0aW9ucy5zdGVwcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdGVwcyA6IDE7XFxuXFxuXFx0XFx0dmFyIGV4dHJ1ZGVQYXRoID0gb3B0aW9ucy5leHRydWRlUGF0aDtcXG5cXHRcXHR2YXIgZXh0cnVkZVB0cywgZXh0cnVkZUJ5UGF0aCA9IGZhbHNlO1xcblxcblxcdFxcdC8vIFVzZSBkZWZhdWx0IFdvcmxkVVZHZW5lcmF0b3IgaWYgbm8gVVYgZ2VuZXJhdG9ycyBhcmUgc3BlY2lmaWVkLlxcblxcdFxcdHZhciB1dmdlbiA9IG9wdGlvbnMuVVZHZW5lcmF0b3IgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuVVZHZW5lcmF0b3IgOiBFeHRydWRlR2VvbWV0cnkuV29ybGRVVkdlbmVyYXRvcjtcXG5cXG5cXHRcXHR2YXIgc3BsaW5lVHViZSwgYmlub3JtYWwsIG5vcm1hbCwgcG9zaXRpb24yO1xcblxcdFxcdGlmICggZXh0cnVkZVBhdGggKSB7XFxuXFxuXFx0XFx0XFx0ZXh0cnVkZVB0cyA9IGV4dHJ1ZGVQYXRoLmdldFNwYWNlZFBvaW50cyggc3RlcHMgKTtcXG5cXG5cXHRcXHRcXHRleHRydWRlQnlQYXRoID0gdHJ1ZTtcXG5cXHRcXHRcXHRiZXZlbEVuYWJsZWQgPSBmYWxzZTsgLy8gYmV2ZWxzIG5vdCBzdXBwb3J0ZWQgZm9yIHBhdGggZXh0cnVzaW9uXFxuXFxuXFx0XFx0XFx0Ly8gU0VUVVAgVE5CIHZhcmlhYmxlc1xcblxcblxcdFxcdFxcdC8vIFRPRE8xIC0gaGF2ZSBhIC5pc0Nsb3NlZCBpbiBzcGxpbmU/XFxuXFxuXFx0XFx0XFx0c3BsaW5lVHViZSA9IG9wdGlvbnMuZnJhbWVzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZyYW1lcyA6IGV4dHJ1ZGVQYXRoLmNvbXB1dGVGcmVuZXRGcmFtZXMoIHN0ZXBzLCBmYWxzZSApO1xcblxcblxcdFxcdFxcdC8vIGNvbnNvbGUubG9nKHNwbGluZVR1YmUsICdzcGxpbmVUdWJlJywgc3BsaW5lVHViZS5ub3JtYWxzLmxlbmd0aCwgJ3N0ZXBzJywgc3RlcHMsICdleHRydWRlUHRzJywgZXh0cnVkZVB0cy5sZW5ndGgpO1xcblxcblxcdFxcdFxcdGJpbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHRub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdHBvc2l0aW9uMiA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFNhZmVndWFyZHMgaWYgYmV2ZWxzIGFyZSBub3QgZW5hYmxlZFxcblxcblxcdFxcdGlmICggISBiZXZlbEVuYWJsZWQgKSB7XFxuXFxuXFx0XFx0XFx0YmV2ZWxTZWdtZW50cyA9IDA7XFxuXFx0XFx0XFx0YmV2ZWxUaGlja25lc3MgPSAwO1xcblxcdFxcdFxcdGJldmVsU2l6ZSA9IDA7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFZhcmlhYmxlcyBpbml0aWFsaXphdGlvblxcblxcblxcdFxcdHZhciBhaG9sZSwgaCwgaGw7IC8vIGxvb3Bpbmcgb2YgaG9sZXNcXG5cXHRcXHR2YXIgc2NvcGUgPSB0aGlzO1xcblxcblxcdFxcdHZhciBzaGFwZVBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcXG5cXG5cXHRcXHR2YXIgdmVydGljZXMgPSBzaGFwZVBvaW50cy5zaGFwZTtcXG5cXHRcXHR2YXIgaG9sZXMgPSBzaGFwZVBvaW50cy5ob2xlcztcXG5cXG5cXHRcXHR2YXIgcmV2ZXJzZSA9ICEgU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggdmVydGljZXMgKTtcXG5cXG5cXHRcXHRpZiAoIHJldmVyc2UgKSB7XFxuXFxuXFx0XFx0XFx0dmVydGljZXMgPSB2ZXJ0aWNlcy5yZXZlcnNlKCk7XFxuXFxuXFx0XFx0XFx0Ly8gTWF5YmUgd2Ugc2hvdWxkIGFsc28gY2hlY2sgaWYgaG9sZXMgYXJlIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24sIGp1c3QgdG8gYmUgc2FmZSAuLi5cXG5cXG5cXHRcXHRcXHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRhaG9sZSA9IGhvbGVzWyBoIF07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCBhaG9sZSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGhvbGVzWyBoIF0gPSBhaG9sZS5yZXZlcnNlKCk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFxuXFx0XFx0dmFyIGZhY2VzID0gU2hhcGVVdGlscy50cmlhbmd1bGF0ZVNoYXBlKCB2ZXJ0aWNlcywgaG9sZXMgKTtcXG5cXG5cXHRcXHQvKiBWZXJ0aWNlcyAqL1xcblxcblxcdFxcdHZhciBjb250b3VyID0gdmVydGljZXM7IC8vIHZlcnRpY2VzIGhhcyBhbGwgcG9pbnRzIGJ1dCBjb250b3VyIGhhcyBvbmx5IHBvaW50cyBvZiBjaXJjdW1mZXJlbmNlXFxuXFxuXFx0XFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XFxuXFxuXFx0XFx0XFx0YWhvbGUgPSBob2xlc1sgaCBdO1xcblxcblxcdFxcdFxcdHZlcnRpY2VzID0gdmVydGljZXMuY29uY2F0KCBhaG9sZSApO1xcblxcblxcdFxcdH1cXG5cXG5cXG5cXHRcXHRmdW5jdGlvbiBzY2FsZVB0MiggcHQsIHZlYywgc2l6ZSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoICEgdmVjICkgY29uc29sZS5lcnJvciggXFxcIlRIUkVFLkV4dHJ1ZGVHZW9tZXRyeTogdmVjIGRvZXMgbm90IGV4aXN0XFxcIiApO1xcblxcblxcdFxcdFxcdHJldHVybiB2ZWMuY2xvbmUoKS5tdWx0aXBseVNjYWxhciggc2l6ZSApLmFkZCggcHQgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dmFyIGIsIGJzLCB0LCB6LFxcblxcdFxcdFxcdHZlcnQsIHZsZW4gPSB2ZXJ0aWNlcy5sZW5ndGgsXFxuXFx0XFx0XFx0ZmFjZSwgZmxlbiA9IGZhY2VzLmxlbmd0aDtcXG5cXG5cXG5cXHRcXHQvLyBGaW5kIGRpcmVjdGlvbnMgZm9yIHBvaW50IG1vdmVtZW50XFxuXFxuXFxuXFx0XFx0ZnVuY3Rpb24gZ2V0QmV2ZWxWZWMoIGluUHQsIGluUHJldiwgaW5OZXh0ICkge1xcblxcblxcdFxcdFxcdC8vIGNvbXB1dGVzIGZvciBpblB0IHRoZSBjb3JyZXNwb25kaW5nIHBvaW50IGluUHQnIG9uIGEgbmV3IGNvbnRvdXJcXG5cXHRcXHRcXHQvLyAgIHNoaWZ0ZWQgYnkgMSB1bml0IChsZW5ndGggb2Ygbm9ybWFsaXplZCB2ZWN0b3IpIHRvIHRoZSBsZWZ0XFxuXFx0XFx0XFx0Ly8gaWYgd2Ugd2FsayBhbG9uZyBjb250b3VyIGNsb2Nrd2lzZSwgdGhpcyBuZXcgY29udG91ciBpcyBvdXRzaWRlIHRoZSBvbGQgb25lXFxuXFx0XFx0XFx0Ly9cXG5cXHRcXHRcXHQvLyBpblB0JyBpcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gbGluZXMgcGFyYWxsZWwgdG8gdGhlIHR3b1xcblxcdFxcdFxcdC8vICBhZGphY2VudCBlZGdlcyBvZiBpblB0IGF0IGEgZGlzdGFuY2Ugb2YgMSB1bml0IG9uIHRoZSBsZWZ0IHNpZGUuXFxuXFxuXFx0XFx0XFx0dmFyIHZfdHJhbnNfeCwgdl90cmFuc195LCBzaHJpbmtfYnk7IC8vIHJlc3VsdGluZyB0cmFuc2xhdGlvbiB2ZWN0b3IgZm9yIGluUHRcXG5cXG5cXHRcXHRcXHQvLyBnb29kIHJlYWRpbmcgZm9yIGdlb21ldHJ5IGFsZ29yaXRobXMgKGhlcmU6IGxpbmUtbGluZSBpbnRlcnNlY3Rpb24pXFxuXFx0XFx0XFx0Ly8gaHR0cDovL2dlb21hbGdvcml0aG1zLmNvbS9hMDUtX2ludGVyc2VjdC0xLmh0bWxcXG5cXG5cXHRcXHRcXHR2YXIgdl9wcmV2X3ggPSBpblB0LnggLSBpblByZXYueCxcXG5cXHRcXHRcXHRcXHR2X3ByZXZfeSA9IGluUHQueSAtIGluUHJldi55O1xcblxcdFxcdFxcdHZhciB2X25leHRfeCA9IGluTmV4dC54IC0gaW5QdC54LFxcblxcdFxcdFxcdFxcdHZfbmV4dF95ID0gaW5OZXh0LnkgLSBpblB0Lnk7XFxuXFxuXFx0XFx0XFx0dmFyIHZfcHJldl9sZW5zcSA9ICggdl9wcmV2X3ggKiB2X3ByZXZfeCArIHZfcHJldl95ICogdl9wcmV2X3kgKTtcXG5cXG5cXHRcXHRcXHQvLyBjaGVjayBmb3IgY29sbGluZWFyIGVkZ2VzXFxuXFx0XFx0XFx0dmFyIGNvbGxpbmVhcjAgPSAoIHZfcHJldl94ICogdl9uZXh0X3kgLSB2X3ByZXZfeSAqIHZfbmV4dF94ICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBNYXRoLmFicyggY29sbGluZWFyMCApID4gTnVtYmVyLkVQU0lMT04gKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gbm90IGNvbGxpbmVhclxcblxcblxcdFxcdFxcdFxcdC8vIGxlbmd0aCBvZiB2ZWN0b3JzIGZvciBub3JtYWxpemluZ1xcblxcblxcdFxcdFxcdFxcdHZhciB2X3ByZXZfbGVuID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgKTtcXG5cXHRcXHRcXHRcXHR2YXIgdl9uZXh0X2xlbiA9IE1hdGguc3FydCggdl9uZXh0X3ggKiB2X25leHRfeCArIHZfbmV4dF95ICogdl9uZXh0X3kgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBzaGlmdCBhZGphY2VudCBwb2ludHMgYnkgdW5pdCB2ZWN0b3JzIHRvIHRoZSBsZWZ0XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHB0UHJldlNoaWZ0X3ggPSAoIGluUHJldi54IC0gdl9wcmV2X3kgLyB2X3ByZXZfbGVuICk7XFxuXFx0XFx0XFx0XFx0dmFyIHB0UHJldlNoaWZ0X3kgPSAoIGluUHJldi55ICsgdl9wcmV2X3ggLyB2X3ByZXZfbGVuICk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHB0TmV4dFNoaWZ0X3ggPSAoIGluTmV4dC54IC0gdl9uZXh0X3kgLyB2X25leHRfbGVuICk7XFxuXFx0XFx0XFx0XFx0dmFyIHB0TmV4dFNoaWZ0X3kgPSAoIGluTmV4dC55ICsgdl9uZXh0X3ggLyB2X25leHRfbGVuICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gc2NhbGluZyBmYWN0b3IgZm9yIHZfcHJldiB0byBpbnRlcnNlY3Rpb24gcG9pbnRcXG5cXG5cXHRcXHRcXHRcXHR2YXIgc2YgPSAoICggcHROZXh0U2hpZnRfeCAtIHB0UHJldlNoaWZ0X3ggKSAqIHZfbmV4dF95IC1cXG5cXHRcXHRcXHRcXHRcXHRcXHQoIHB0TmV4dFNoaWZ0X3kgLSBwdFByZXZTaGlmdF95ICkgKiB2X25leHRfeCApIC9cXG5cXHRcXHRcXHRcXHRcXHQoIHZfcHJldl94ICogdl9uZXh0X3kgLSB2X3ByZXZfeSAqIHZfbmV4dF94ICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdmVjdG9yIGZyb20gaW5QdCB0byBpbnRlcnNlY3Rpb24gcG9pbnRcXG5cXG5cXHRcXHRcXHRcXHR2X3RyYW5zX3ggPSAoIHB0UHJldlNoaWZ0X3ggKyB2X3ByZXZfeCAqIHNmIC0gaW5QdC54ICk7XFxuXFx0XFx0XFx0XFx0dl90cmFuc195ID0gKCBwdFByZXZTaGlmdF95ICsgdl9wcmV2X3kgKiBzZiAtIGluUHQueSApO1xcblxcblxcdFxcdFxcdFxcdC8vIERvbid0IG5vcm1hbGl6ZSEsIG90aGVyd2lzZSBzaGFycCBjb3JuZXJzIGJlY29tZSB1Z2x5XFxuXFx0XFx0XFx0XFx0Ly8gIGJ1dCBwcmV2ZW50IGNyYXp5IHNwaWtlc1xcblxcdFxcdFxcdFxcdHZhciB2X3RyYW5zX2xlbnNxID0gKCB2X3RyYW5zX3ggKiB2X3RyYW5zX3ggKyB2X3RyYW5zX3kgKiB2X3RyYW5zX3kgKTtcXG5cXHRcXHRcXHRcXHRpZiAoIHZfdHJhbnNfbGVuc3EgPD0gMiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gbmV3IFZlY3RvcjIoIHZfdHJhbnNfeCwgdl90cmFuc195ICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzaHJpbmtfYnkgPSBNYXRoLnNxcnQoIHZfdHJhbnNfbGVuc3EgLyAyICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gaGFuZGxlIHNwZWNpYWwgY2FzZSBvZiBjb2xsaW5lYXIgZWRnZXNcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZGlyZWN0aW9uX2VxID0gZmFsc2U7IC8vIGFzc3VtZXM6IG9wcG9zaXRlXFxuXFx0XFx0XFx0XFx0aWYgKCB2X3ByZXZfeCA+IE51bWJlci5FUFNJTE9OICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggdl9uZXh0X3ggPiBOdW1iZXIuRVBTSUxPTiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRkaXJlY3Rpb25fZXEgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggdl9wcmV2X3ggPCAtIE51bWJlci5FUFNJTE9OICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggdl9uZXh0X3ggPCAtIE51bWJlci5FUFNJTE9OICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRpcmVjdGlvbl9lcSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBNYXRoLnNpZ24oIHZfcHJldl95ICkgPT09IE1hdGguc2lnbiggdl9uZXh0X3kgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkaXJlY3Rpb25fZXEgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggZGlyZWN0aW9uX2VxICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGNvbnNvbGUubG9nKFxcXCJXYXJuaW5nOiBsaW5lcyBhcmUgYSBzdHJhaWdodCBzZXF1ZW5jZVxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdHZfdHJhbnNfeCA9IC0gdl9wcmV2X3k7XFxuXFx0XFx0XFx0XFx0XFx0dl90cmFuc195ID0gdl9wcmV2X3g7XFxuXFx0XFx0XFx0XFx0XFx0c2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGNvbnNvbGUubG9nKFxcXCJXYXJuaW5nOiBsaW5lcyBhcmUgYSBzdHJhaWdodCBzcGlrZVxcXCIpO1xcblxcdFxcdFxcdFxcdFxcdHZfdHJhbnNfeCA9IHZfcHJldl94O1xcblxcdFxcdFxcdFxcdFxcdHZfdHJhbnNfeSA9IHZfcHJldl95O1xcblxcdFxcdFxcdFxcdFxcdHNocmlua19ieSA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxIC8gMiApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyBWZWN0b3IyKCB2X3RyYW5zX3ggLyBzaHJpbmtfYnksIHZfdHJhbnNfeSAvIHNocmlua19ieSApO1xcblxcblxcdFxcdH1cXG5cXG5cXG5cXHRcXHR2YXIgY29udG91ck1vdmVtZW50cyA9IFtdO1xcblxcblxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aCwgaiA9IGlsIC0gMSwgayA9IGkgKyAxOyBpIDwgaWw7IGkgKyssIGogKyssIGsgKysgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBqID09PSBpbCApIGogPSAwO1xcblxcdFxcdFxcdGlmICggayA9PT0gaWwgKSBrID0gMDtcXG5cXG5cXHRcXHRcXHQvLyAgKGopLS0tKGkpLS0tKGspXFxuXFx0XFx0XFx0Ly8gY29uc29sZS5sb2coJ2ksaixrJywgaSwgaiAsIGspXFxuXFxuXFx0XFx0XFx0Y29udG91ck1vdmVtZW50c1sgaSBdID0gZ2V0QmV2ZWxWZWMoIGNvbnRvdXJbIGkgXSwgY29udG91clsgaiBdLCBjb250b3VyWyBrIF0gKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dmFyIGhvbGVzTW92ZW1lbnRzID0gW10sXFxuXFx0XFx0XFx0b25lSG9sZU1vdmVtZW50cywgdmVydGljZXNNb3ZlbWVudHMgPSBjb250b3VyTW92ZW1lbnRzLmNvbmNhdCgpO1xcblxcblxcdFxcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xcblxcblxcdFxcdFxcdGFob2xlID0gaG9sZXNbIGggXTtcXG5cXG5cXHRcXHRcXHRvbmVIb2xlTW92ZW1lbnRzID0gW107XFxuXFxuXFx0XFx0XFx0Zm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSArKywgaiArKywgayArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGogPT09IGlsICkgaiA9IDA7XFxuXFx0XFx0XFx0XFx0aWYgKCBrID09PSBpbCApIGsgPSAwO1xcblxcblxcdFxcdFxcdFxcdC8vICAoaiktLS0oaSktLS0oaylcXG5cXHRcXHRcXHRcXHRvbmVIb2xlTW92ZW1lbnRzWyBpIF0gPSBnZXRCZXZlbFZlYyggYWhvbGVbIGkgXSwgYWhvbGVbIGogXSwgYWhvbGVbIGsgXSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRob2xlc01vdmVtZW50cy5wdXNoKCBvbmVIb2xlTW92ZW1lbnRzICk7XFxuXFx0XFx0XFx0dmVydGljZXNNb3ZlbWVudHMgPSB2ZXJ0aWNlc01vdmVtZW50cy5jb25jYXQoIG9uZUhvbGVNb3ZlbWVudHMgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFxuXFx0XFx0Ly8gTG9vcCBiZXZlbFNlZ21lbnRzLCAxIGZvciB0aGUgZnJvbnQsIDEgZm9yIHRoZSBiYWNrXFxuXFxuXFx0XFx0Zm9yICggYiA9IDA7IGIgPCBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xcblxcblxcdFxcdFxcdC8vZm9yICggYiA9IGJldmVsU2VnbWVudHM7IGIgPiAwOyBiIC0tICkge1xcblxcblxcdFxcdFxcdHQgPSBiIC8gYmV2ZWxTZWdtZW50cztcXG5cXHRcXHRcXHR6ID0gYmV2ZWxUaGlja25lc3MgKiBNYXRoLmNvcyggdCAqIE1hdGguUEkgLyAyICk7XFxuXFx0XFx0XFx0YnMgPSBiZXZlbFNpemUgKiBNYXRoLnNpbiggdCAqIE1hdGguUEkgLyAyICk7XFxuXFxuXFx0XFx0XFx0Ly8gY29udHJhY3Qgc2hhcGVcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZlcnQgPSBzY2FsZVB0MiggY29udG91clsgaSBdLCBjb250b3VyTW92ZW1lbnRzWyBpIF0sIGJzICk7XFxuXFxuXFx0XFx0XFx0XFx0diggdmVydC54LCB2ZXJ0LnksIC0geiApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBleHBhbmQgaG9sZXNcXG5cXG5cXHRcXHRcXHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRhaG9sZSA9IGhvbGVzWyBoIF07XFxuXFx0XFx0XFx0XFx0b25lSG9sZU1vdmVtZW50cyA9IGhvbGVzTW92ZW1lbnRzWyBoIF07XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmVydCA9IHNjYWxlUHQyKCBhaG9sZVsgaSBdLCBvbmVIb2xlTW92ZW1lbnRzWyBpIF0sIGJzICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0diggdmVydC54LCB2ZXJ0LnksIC0geiApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGJzID0gYmV2ZWxTaXplO1xcblxcblxcdFxcdC8vIEJhY2sgZmFjaW5nIHZlcnRpY2VzXFxuXFxuXFx0XFx0Zm9yICggaSA9IDA7IGkgPCB2bGVuOyBpICsrICkge1xcblxcblxcdFxcdFxcdHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0MiggdmVydGljZXNbIGkgXSwgdmVydGljZXNNb3ZlbWVudHNbIGkgXSwgYnMgKSA6IHZlcnRpY2VzWyBpIF07XFxuXFxuXFx0XFx0XFx0aWYgKCAhIGV4dHJ1ZGVCeVBhdGggKSB7XFxuXFxuXFx0XFx0XFx0XFx0diggdmVydC54LCB2ZXJ0LnksIDAgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdC8vIHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgMCBdLnksIGV4dHJ1ZGVQdHNbIDAgXS54ICk7XFxuXFxuXFx0XFx0XFx0XFx0bm9ybWFsLmNvcHkoIHNwbGluZVR1YmUubm9ybWFsc1sgMCBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueCApO1xcblxcdFxcdFxcdFxcdGJpbm9ybWFsLmNvcHkoIHNwbGluZVR1YmUuYmlub3JtYWxzWyAwIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC55ICk7XFxuXFxuXFx0XFx0XFx0XFx0cG9zaXRpb24yLmNvcHkoIGV4dHJ1ZGVQdHNbIDAgXSApLmFkZCggbm9ybWFsICkuYWRkKCBiaW5vcm1hbCApO1xcblxcblxcdFxcdFxcdFxcdHYoIHBvc2l0aW9uMi54LCBwb3NpdGlvbjIueSwgcG9zaXRpb24yLnogKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIEFkZCBzdGVwcGVkIHZlcnRpY2VzLi4uXFxuXFx0XFx0Ly8gSW5jbHVkaW5nIGZyb250IGZhY2luZyB2ZXJ0aWNlc1xcblxcblxcdFxcdHZhciBzO1xcblxcblxcdFxcdGZvciAoIHMgPSAxOyBzIDw9IHN0ZXBzOyBzICsrICkge1xcblxcblxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2ZXJ0ID0gYmV2ZWxFbmFibGVkID8gc2NhbGVQdDIoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzTW92ZW1lbnRzWyBpIF0sIGJzICkgOiB2ZXJ0aWNlc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdGlmICggISBleHRydWRlQnlQYXRoICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHYoIHZlcnQueCwgdmVydC55LCBhbW91bnQgLyBzdGVwcyAqIHMgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgcyAtIDEgXS55LCBleHRydWRlUHRzWyBzIC0gMSBdLnggKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRub3JtYWwuY29weSggc3BsaW5lVHViZS5ub3JtYWxzWyBzIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC54ICk7XFxuXFx0XFx0XFx0XFx0XFx0Ymlub3JtYWwuY29weSggc3BsaW5lVHViZS5iaW5vcm1hbHNbIHMgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRwb3NpdGlvbjIuY29weSggZXh0cnVkZVB0c1sgcyBdICkuYWRkKCBub3JtYWwgKS5hZGQoIGJpbm9ybWFsICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0diggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcblxcdFxcdC8vIEFkZCBiZXZlbCBzZWdtZW50cyBwbGFuZXNcXG5cXG5cXHRcXHQvL2ZvciAoIGIgPSAxOyBiIDw9IGJldmVsU2VnbWVudHM7IGIgKysgKSB7XFxuXFx0XFx0Zm9yICggYiA9IGJldmVsU2VnbWVudHMgLSAxOyBiID49IDA7IGIgLS0gKSB7XFxuXFxuXFx0XFx0XFx0dCA9IGIgLyBiZXZlbFNlZ21lbnRzO1xcblxcdFxcdFxcdHogPSBiZXZlbFRoaWNrbmVzcyAqIE1hdGguY29zKCB0ICogTWF0aC5QSSAvIDIgKTtcXG5cXHRcXHRcXHRicyA9IGJldmVsU2l6ZSAqIE1hdGguc2luKCB0ICogTWF0aC5QSSAvIDIgKTtcXG5cXG5cXHRcXHRcXHQvLyBjb250cmFjdCBzaGFwZVxcblxcblxcdFxcdFxcdGZvciAoIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmVydCA9IHNjYWxlUHQyKCBjb250b3VyWyBpIF0sIGNvbnRvdXJNb3ZlbWVudHNbIGkgXSwgYnMgKTtcXG5cXHRcXHRcXHRcXHR2KCB2ZXJ0LngsIHZlcnQueSwgYW1vdW50ICsgeiApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBleHBhbmQgaG9sZXNcXG5cXG5cXHRcXHRcXHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRhaG9sZSA9IGhvbGVzWyBoIF07XFxuXFx0XFx0XFx0XFx0b25lSG9sZU1vdmVtZW50cyA9IGhvbGVzTW92ZW1lbnRzWyBoIF07XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmVydCA9IHNjYWxlUHQyKCBhaG9sZVsgaSBdLCBvbmVIb2xlTW92ZW1lbnRzWyBpIF0sIGJzICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAhIGV4dHJ1ZGVCeVBhdGggKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0diggdmVydC54LCB2ZXJ0LnksIGFtb3VudCArIHogKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgc3RlcHMgLSAxIF0ueSwgZXh0cnVkZVB0c1sgc3RlcHMgLSAxIF0ueCArIHogKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0LyogRmFjZXMgKi9cXG5cXG5cXHRcXHQvLyBUb3AgYW5kIGJvdHRvbSBmYWNlc1xcblxcblxcdFxcdGJ1aWxkTGlkRmFjZXMoKTtcXG5cXG5cXHRcXHQvLyBTaWRlcyBmYWNlc1xcblxcblxcdFxcdGJ1aWxkU2lkZUZhY2VzKCk7XFxuXFxuXFxuXFx0XFx0Ly8vLy8gIEludGVybmFsIGZ1bmN0aW9uc1xcblxcblxcdFxcdGZ1bmN0aW9uIGJ1aWxkTGlkRmFjZXMoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHN0YXJ0ID0gdmVydGljZXNBcnJheS5sZW5ndGggLyAzO1xcblxcblxcdFxcdFxcdGlmICggYmV2ZWxFbmFibGVkICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBsYXllciA9IDA7IC8vIHN0ZXBzICsgMVxcblxcdFxcdFxcdFxcdHZhciBvZmZzZXQgPSB2bGVuICogbGF5ZXI7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQm90dG9tIGZhY2VzXFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGZhY2UgPSBmYWNlc1sgaSBdO1xcblxcdFxcdFxcdFxcdFxcdGYzKCBmYWNlWyAyIF0gKyBvZmZzZXQsIGZhY2VbIDEgXSArIG9mZnNldCwgZmFjZVsgMCBdICsgb2Zmc2V0ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGxheWVyID0gc3RlcHMgKyBiZXZlbFNlZ21lbnRzICogMjtcXG5cXHRcXHRcXHRcXHRvZmZzZXQgPSB2bGVuICogbGF5ZXI7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gVG9wIGZhY2VzXFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGZhY2UgPSBmYWNlc1sgaSBdO1xcblxcdFxcdFxcdFxcdFxcdGYzKCBmYWNlWyAwIF0gKyBvZmZzZXQsIGZhY2VbIDEgXSArIG9mZnNldCwgZmFjZVsgMiBdICsgb2Zmc2V0ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQm90dG9tIGZhY2VzXFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGZhY2UgPSBmYWNlc1sgaSBdO1xcblxcdFxcdFxcdFxcdFxcdGYzKCBmYWNlWyAyIF0sIGZhY2VbIDEgXSwgZmFjZVsgMCBdICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFRvcCBmYWNlc1xcblxcblxcdFxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmYWNlID0gZmFjZXNbIGkgXTtcXG5cXHRcXHRcXHRcXHRcXHRmMyggZmFjZVsgMCBdICsgdmxlbiAqIHN0ZXBzLCBmYWNlWyAxIF0gKyB2bGVuICogc3RlcHMsIGZhY2VbIDIgXSArIHZsZW4gKiBzdGVwcyApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0c2NvcGUuYWRkR3JvdXAoIHN0YXJ0LCB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDMgLSBzdGFydCwgb3B0aW9ucy5tYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tYXRlcmlhbCA6IDAgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQ3JlYXRlIGZhY2VzIGZvciB0aGUgei1zaWRlcyBvZiB0aGUgc2hhcGVcXG5cXG5cXHRcXHRmdW5jdGlvbiBidWlsZFNpZGVGYWNlcygpIHtcXG5cXG5cXHRcXHRcXHR2YXIgc3RhcnQgPSB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDM7XFxuXFx0XFx0XFx0dmFyIGxheWVyb2Zmc2V0ID0gMDtcXG5cXHRcXHRcXHRzaWRld2FsbHMoIGNvbnRvdXIsIGxheWVyb2Zmc2V0ICk7XFxuXFx0XFx0XFx0bGF5ZXJvZmZzZXQgKz0gY29udG91ci5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0YWhvbGUgPSBob2xlc1sgaCBdO1xcblxcdFxcdFxcdFxcdHNpZGV3YWxscyggYWhvbGUsIGxheWVyb2Zmc2V0ICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8sIHRydWVcXG5cXHRcXHRcXHRcXHRsYXllcm9mZnNldCArPSBhaG9sZS5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcblxcdFxcdFxcdHNjb3BlLmFkZEdyb3VwKCBzdGFydCwgdmVydGljZXNBcnJheS5sZW5ndGggLyAzIC0gc3RhcnQsIG9wdGlvbnMuZXh0cnVkZU1hdGVyaWFsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmV4dHJ1ZGVNYXRlcmlhbCA6IDEgKTtcXG5cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gc2lkZXdhbGxzKCBjb250b3VyLCBsYXllcm9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgaiwgaztcXG5cXHRcXHRcXHRpID0gY29udG91ci5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0d2hpbGUgKCAtLSBpID49IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aiA9IGk7XFxuXFx0XFx0XFx0XFx0ayA9IGkgLSAxO1xcblxcdFxcdFxcdFxcdGlmICggayA8IDAgKSBrID0gY29udG91ci5sZW5ndGggLSAxO1xcblxcblxcdFxcdFxcdFxcdC8vY29uc29sZS5sb2coJ2InLCBpLGosIGktMSwgayx2ZXJ0aWNlcy5sZW5ndGgpO1xcblxcblxcdFxcdFxcdFxcdHZhciBzID0gMCxcXG5cXHRcXHRcXHRcXHRcXHRzbCA9IHN0ZXBzICsgYmV2ZWxTZWdtZW50cyAqIDI7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggcyA9IDA7IHMgPCBzbDsgcyArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgc2xlbjEgPSB2bGVuICogcztcXG5cXHRcXHRcXHRcXHRcXHR2YXIgc2xlbjIgPSB2bGVuICogKCBzICsgMSApO1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBhID0gbGF5ZXJvZmZzZXQgKyBqICsgc2xlbjEsXFxuXFx0XFx0XFx0XFx0XFx0XFx0YiA9IGxheWVyb2Zmc2V0ICsgayArIHNsZW4xLFxcblxcdFxcdFxcdFxcdFxcdFxcdGMgPSBsYXllcm9mZnNldCArIGsgKyBzbGVuMixcXG5cXHRcXHRcXHRcXHRcXHRcXHRkID0gbGF5ZXJvZmZzZXQgKyBqICsgc2xlbjI7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZjQoIGEsIGIsIGMsIGQgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiB2KCB4LCB5LCB6ICkge1xcblxcblxcdFxcdFxcdHBsYWNlaG9sZGVyLnB1c2goIHggKTtcXG5cXHRcXHRcXHRwbGFjZWhvbGRlci5wdXNoKCB5ICk7XFxuXFx0XFx0XFx0cGxhY2Vob2xkZXIucHVzaCggeiApO1xcblxcblxcdFxcdH1cXG5cXG5cXG5cXHRcXHRmdW5jdGlvbiBmMyggYSwgYiwgYyApIHtcXG5cXG5cXHRcXHRcXHRhZGRWZXJ0ZXgoIGEgKTtcXG5cXHRcXHRcXHRhZGRWZXJ0ZXgoIGIgKTtcXG5cXHRcXHRcXHRhZGRWZXJ0ZXgoIGMgKTtcXG5cXG5cXHRcXHRcXHR2YXIgbmV4dEluZGV4ID0gdmVydGljZXNBcnJheS5sZW5ndGggLyAzO1xcblxcdFxcdFxcdHZhciB1dnMgPSB1dmdlbi5nZW5lcmF0ZVRvcFVWKCBzY29wZSwgdmVydGljZXNBcnJheSwgbmV4dEluZGV4IC0gMywgbmV4dEluZGV4IC0gMiwgbmV4dEluZGV4IC0gMSApO1xcblxcblxcdFxcdFxcdGFkZFVWKCB1dnNbIDAgXSApO1xcblxcdFxcdFxcdGFkZFVWKCB1dnNbIDEgXSApO1xcblxcdFxcdFxcdGFkZFVWKCB1dnNbIDIgXSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBmNCggYSwgYiwgYywgZCApIHtcXG5cXG5cXHRcXHRcXHRhZGRWZXJ0ZXgoIGEgKTtcXG5cXHRcXHRcXHRhZGRWZXJ0ZXgoIGIgKTtcXG5cXHRcXHRcXHRhZGRWZXJ0ZXgoIGQgKTtcXG5cXG5cXHRcXHRcXHRhZGRWZXJ0ZXgoIGIgKTtcXG5cXHRcXHRcXHRhZGRWZXJ0ZXgoIGMgKTtcXG5cXHRcXHRcXHRhZGRWZXJ0ZXgoIGQgKTtcXG5cXG5cXG5cXHRcXHRcXHR2YXIgbmV4dEluZGV4ID0gdmVydGljZXNBcnJheS5sZW5ndGggLyAzO1xcblxcdFxcdFxcdHZhciB1dnMgPSB1dmdlbi5nZW5lcmF0ZVNpZGVXYWxsVVYoIHNjb3BlLCB2ZXJ0aWNlc0FycmF5LCBuZXh0SW5kZXggLSA2LCBuZXh0SW5kZXggLSAzLCBuZXh0SW5kZXggLSAyLCBuZXh0SW5kZXggLSAxICk7XFxuXFxuXFx0XFx0XFx0YWRkVVYoIHV2c1sgMCBdICk7XFxuXFx0XFx0XFx0YWRkVVYoIHV2c1sgMSBdICk7XFxuXFx0XFx0XFx0YWRkVVYoIHV2c1sgMyBdICk7XFxuXFxuXFx0XFx0XFx0YWRkVVYoIHV2c1sgMSBdICk7XFxuXFx0XFx0XFx0YWRkVVYoIHV2c1sgMiBdICk7XFxuXFx0XFx0XFx0YWRkVVYoIHV2c1sgMyBdICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGFkZFZlcnRleCggaW5kZXggKSB7XFxuXFxuXFx0XFx0XFx0aW5kaWNlc0FycmF5LnB1c2goIHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMyApO1xcblxcdFxcdFxcdHZlcnRpY2VzQXJyYXkucHVzaCggcGxhY2Vob2xkZXJbIGluZGV4ICogMyArIDAgXSApO1xcblxcdFxcdFxcdHZlcnRpY2VzQXJyYXkucHVzaCggcGxhY2Vob2xkZXJbIGluZGV4ICogMyArIDEgXSApO1xcblxcdFxcdFxcdHZlcnRpY2VzQXJyYXkucHVzaCggcGxhY2Vob2xkZXJbIGluZGV4ICogMyArIDIgXSApO1xcblxcblxcdFxcdH1cXG5cXG5cXG5cXHRcXHRmdW5jdGlvbiBhZGRVViggdmVjdG9yMiApIHtcXG5cXG5cXHRcXHRcXHR1dkFycmF5LnB1c2goIHZlY3RvcjIueCApO1xcblxcdFxcdFxcdHV2QXJyYXkucHVzaCggdmVjdG9yMi55ICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggISBvcHRpb25zLmFycmF5cyApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnNldEluZGV4KCBpbmRpY2VzQXJyYXkgKTtcXG5cXHRcXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzQXJyYXksIDMgKSApO1xcblxcdFxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZBcnJheSwgMiApICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH07XFxuXFxuXFx0RXh0cnVkZUdlb21ldHJ5LldvcmxkVVZHZW5lcmF0b3IgPSB7XFxuXFxuXFx0XFx0Z2VuZXJhdGVUb3BVVjogZnVuY3Rpb24gKCBnZW9tZXRyeSwgdmVydGljZXMsIGluZGV4QSwgaW5kZXhCLCBpbmRleEMgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGFfeCA9IHZlcnRpY2VzWyBpbmRleEEgKiAzIF07XFxuXFx0XFx0XFx0dmFyIGFfeSA9IHZlcnRpY2VzWyBpbmRleEEgKiAzICsgMSBdO1xcblxcdFxcdFxcdHZhciBiX3ggPSB2ZXJ0aWNlc1sgaW5kZXhCICogMyBdO1xcblxcdFxcdFxcdHZhciBiX3kgPSB2ZXJ0aWNlc1sgaW5kZXhCICogMyArIDEgXTtcXG5cXHRcXHRcXHR2YXIgY194ID0gdmVydGljZXNbIGluZGV4QyAqIDMgXTtcXG5cXHRcXHRcXHR2YXIgY195ID0gdmVydGljZXNbIGluZGV4QyAqIDMgKyAxIF07XFxuXFxuXFx0XFx0XFx0cmV0dXJuIFtcXG5cXHRcXHRcXHRcXHRuZXcgVmVjdG9yMiggYV94LCBhX3kgKSxcXG5cXHRcXHRcXHRcXHRuZXcgVmVjdG9yMiggYl94LCBiX3kgKSxcXG5cXHRcXHRcXHRcXHRuZXcgVmVjdG9yMiggY194LCBjX3kgKVxcblxcdFxcdFxcdF07XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZW5lcmF0ZVNpZGVXYWxsVVY6IGZ1bmN0aW9uICggZ2VvbWV0cnksIHZlcnRpY2VzLCBpbmRleEEsIGluZGV4QiwgaW5kZXhDLCBpbmRleEQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGFfeCA9IHZlcnRpY2VzWyBpbmRleEEgKiAzIF07XFxuXFx0XFx0XFx0dmFyIGFfeSA9IHZlcnRpY2VzWyBpbmRleEEgKiAzICsgMSBdO1xcblxcdFxcdFxcdHZhciBhX3ogPSB2ZXJ0aWNlc1sgaW5kZXhBICogMyArIDIgXTtcXG5cXHRcXHRcXHR2YXIgYl94ID0gdmVydGljZXNbIGluZGV4QiAqIDMgXTtcXG5cXHRcXHRcXHR2YXIgYl95ID0gdmVydGljZXNbIGluZGV4QiAqIDMgKyAxIF07XFxuXFx0XFx0XFx0dmFyIGJfeiA9IHZlcnRpY2VzWyBpbmRleEIgKiAzICsgMiBdO1xcblxcdFxcdFxcdHZhciBjX3ggPSB2ZXJ0aWNlc1sgaW5kZXhDICogMyBdO1xcblxcdFxcdFxcdHZhciBjX3kgPSB2ZXJ0aWNlc1sgaW5kZXhDICogMyArIDEgXTtcXG5cXHRcXHRcXHR2YXIgY196ID0gdmVydGljZXNbIGluZGV4QyAqIDMgKyAyIF07XFxuXFx0XFx0XFx0dmFyIGRfeCA9IHZlcnRpY2VzWyBpbmRleEQgKiAzIF07XFxuXFx0XFx0XFx0dmFyIGRfeSA9IHZlcnRpY2VzWyBpbmRleEQgKiAzICsgMSBdO1xcblxcdFxcdFxcdHZhciBkX3ogPSB2ZXJ0aWNlc1sgaW5kZXhEICogMyArIDIgXTtcXG5cXG5cXHRcXHRcXHRpZiAoIE1hdGguYWJzKCBhX3kgLSBiX3kgKSA8IDAuMDEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIFtcXG5cXHRcXHRcXHRcXHRcXHRuZXcgVmVjdG9yMiggYV94LCAxIC0gYV96ICksXFxuXFx0XFx0XFx0XFx0XFx0bmV3IFZlY3RvcjIoIGJfeCwgMSAtIGJfeiApLFxcblxcdFxcdFxcdFxcdFxcdG5ldyBWZWN0b3IyKCBjX3gsIDEgLSBjX3ogKSxcXG5cXHRcXHRcXHRcXHRcXHRuZXcgVmVjdG9yMiggZF94LCAxIC0gZF96IClcXG5cXHRcXHRcXHRcXHRdO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIFtcXG5cXHRcXHRcXHRcXHRcXHRuZXcgVmVjdG9yMiggYV95LCAxIC0gYV96ICksXFxuXFx0XFx0XFx0XFx0XFx0bmV3IFZlY3RvcjIoIGJfeSwgMSAtIGJfeiApLFxcblxcdFxcdFxcdFxcdFxcdG5ldyBWZWN0b3IyKCBjX3ksIDEgLSBjX3ogKSxcXG5cXHRcXHRcXHRcXHRcXHRuZXcgVmVjdG9yMiggZF95LCAxIC0gZF96IClcXG5cXHRcXHRcXHRcXHRdO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKlxcblxcdCAqIFRleHQgPSAzRCBUZXh0XFxuXFx0ICpcXG5cXHQgKiBwYXJhbWV0ZXJzID0ge1xcblxcdCAqICBmb250OiA8VEhSRUUuRm9udD4sIC8vIGZvbnRcXG5cXHQgKlxcblxcdCAqICBzaXplOiA8ZmxvYXQ+LCAvLyBzaXplIG9mIHRoZSB0ZXh0XFxuXFx0ICogIGhlaWdodDogPGZsb2F0PiwgLy8gdGhpY2tuZXNzIHRvIGV4dHJ1ZGUgdGV4dFxcblxcdCAqICBjdXJ2ZVNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVzXFxuXFx0ICpcXG5cXHQgKiAgYmV2ZWxFbmFibGVkOiA8Ym9vbD4sIC8vIHR1cm4gb24gYmV2ZWxcXG5cXHQgKiAgYmV2ZWxUaGlja25lc3M6IDxmbG9hdD4sIC8vIGhvdyBkZWVwIGludG8gdGV4dCBiZXZlbCBnb2VzXFxuXFx0ICogIGJldmVsU2l6ZTogPGZsb2F0PiAvLyBob3cgZmFyIGZyb20gdGV4dCBvdXRsaW5lIGlzIGJldmVsXFxuXFx0ICogfVxcblxcdCAqL1xcblxcblxcdC8vIFRleHRHZW9tZXRyeVxcblxcblxcdGZ1bmN0aW9uIFRleHRHZW9tZXRyeSggdGV4dCwgcGFyYW1ldGVycyApIHtcXG5cXG5cXHRcXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1RleHRHZW9tZXRyeSc7XFxuXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcblxcdFxcdFxcdHRleHQ6IHRleHQsXFxuXFx0XFx0XFx0cGFyYW1ldGVyczogcGFyYW1ldGVyc1xcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBUZXh0QnVmZmVyR2VvbWV0cnkoIHRleHQsIHBhcmFtZXRlcnMgKSApO1xcblxcdFxcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xcblxcblxcdH1cXG5cXG5cXHRUZXh0R2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XFxuXFx0VGV4dEdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRleHRHZW9tZXRyeTtcXG5cXG5cXHQvLyBUZXh0QnVmZmVyR2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBUZXh0QnVmZmVyR2VvbWV0cnkoIHRleHQsIHBhcmFtZXRlcnMgKSB7XFxuXFxuXFx0XFx0cGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XFxuXFxuXFx0XFx0dmFyIGZvbnQgPSBwYXJhbWV0ZXJzLmZvbnQ7XFxuXFxuXFx0XFx0aWYgKCAhICggZm9udCAmJiBmb250LmlzRm9udCApICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5UZXh0R2VvbWV0cnk6IGZvbnQgcGFyYW1ldGVyIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5Gb250LicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gbmV3IEdlb21ldHJ5KCk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHZhciBzaGFwZXMgPSBmb250LmdlbmVyYXRlU2hhcGVzKCB0ZXh0LCBwYXJhbWV0ZXJzLnNpemUsIHBhcmFtZXRlcnMuY3VydmVTZWdtZW50cyApO1xcblxcblxcdFxcdC8vIHRyYW5zbGF0ZSBwYXJhbWV0ZXJzIHRvIEV4dHJ1ZGVHZW9tZXRyeSBBUElcXG5cXG5cXHRcXHRwYXJhbWV0ZXJzLmFtb3VudCA9IHBhcmFtZXRlcnMuaGVpZ2h0ICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmhlaWdodCA6IDUwO1xcblxcblxcdFxcdC8vIGRlZmF1bHRzXFxuXFxuXFx0XFx0aWYgKCBwYXJhbWV0ZXJzLmJldmVsVGhpY2tuZXNzID09PSB1bmRlZmluZWQgKSBwYXJhbWV0ZXJzLmJldmVsVGhpY2tuZXNzID0gMTA7XFxuXFx0XFx0aWYgKCBwYXJhbWV0ZXJzLmJldmVsU2l6ZSA9PT0gdW5kZWZpbmVkICkgcGFyYW1ldGVycy5iZXZlbFNpemUgPSA4O1xcblxcdFxcdGlmICggcGFyYW1ldGVycy5iZXZlbEVuYWJsZWQgPT09IHVuZGVmaW5lZCApIHBhcmFtZXRlcnMuYmV2ZWxFbmFibGVkID0gZmFsc2U7XFxuXFxuXFx0XFx0RXh0cnVkZUJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMsIHNoYXBlcywgcGFyYW1ldGVycyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdUZXh0QnVmZmVyR2VvbWV0cnknO1xcblxcblxcdH1cXG5cXG5cXHRUZXh0QnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXh0cnVkZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xcblxcdFRleHRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZXh0QnVmZmVyR2VvbWV0cnk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcXG5cXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xcblxcdCAqL1xcblxcblxcdC8vIFNwaGVyZUdlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gU3BoZXJlR2VvbWV0cnkoIHJhZGl1cywgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGgsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xcblxcblxcdFxcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnU3BoZXJlR2VvbWV0cnknO1xcblxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXG5cXHRcXHRcXHRyYWRpdXM6IHJhZGl1cyxcXG5cXHRcXHRcXHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxcblxcdFxcdFxcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcXG5cXHRcXHRcXHRwaGlTdGFydDogcGhpU3RhcnQsXFxuXFx0XFx0XFx0cGhpTGVuZ3RoOiBwaGlMZW5ndGgsXFxuXFx0XFx0XFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcXG5cXHRcXHRcXHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgU3BoZXJlQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGgsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkgKTtcXG5cXHRcXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcXG5cXG5cXHR9XFxuXFxuXFx0U3BoZXJlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XFxuXFx0U3BoZXJlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3BoZXJlR2VvbWV0cnk7XFxuXFxuXFx0Ly8gU3BoZXJlQnVmZmVyR2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBTcGhlcmVCdWZmZXJHZW9tZXRyeSggcmFkaXVzLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XFxuXFxuXFx0XFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdTcGhlcmVCdWZmZXJHZW9tZXRyeSc7XFxuXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcblxcdFxcdFxcdHJhZGl1czogcmFkaXVzLFxcblxcdFxcdFxcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXFxuXFx0XFx0XFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxcblxcdFxcdFxcdHBoaVN0YXJ0OiBwaGlTdGFydCxcXG5cXHRcXHRcXHRwaGlMZW5ndGg6IHBoaUxlbmd0aCxcXG5cXHRcXHRcXHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxcblxcdFxcdFxcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxcblxcdFxcdH07XFxuXFxuXFx0XFx0cmFkaXVzID0gcmFkaXVzIHx8IDE7XFxuXFxuXFx0XFx0d2lkdGhTZWdtZW50cyA9IE1hdGgubWF4KCAzLCBNYXRoLmZsb29yKCB3aWR0aFNlZ21lbnRzICkgfHwgOCApO1xcblxcdFxcdGhlaWdodFNlZ21lbnRzID0gTWF0aC5tYXgoIDIsIE1hdGguZmxvb3IoIGhlaWdodFNlZ21lbnRzICkgfHwgNiApO1xcblxcblxcdFxcdHBoaVN0YXJ0ID0gcGhpU3RhcnQgIT09IHVuZGVmaW5lZCA/IHBoaVN0YXJ0IDogMDtcXG5cXHRcXHRwaGlMZW5ndGggPSBwaGlMZW5ndGggIT09IHVuZGVmaW5lZCA/IHBoaUxlbmd0aCA6IE1hdGguUEkgKiAyO1xcblxcblxcdFxcdHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcXG5cXHRcXHR0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEk7XFxuXFxuXFx0XFx0dmFyIHRoZXRhRW5kID0gdGhldGFTdGFydCArIHRoZXRhTGVuZ3RoO1xcblxcblxcdFxcdHZhciBpeCwgaXk7XFxuXFxuXFx0XFx0dmFyIGluZGV4ID0gMDtcXG5cXHRcXHR2YXIgZ3JpZCA9IFtdO1xcblxcblxcdFxcdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdHZhciBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdC8vIGJ1ZmZlcnNcXG5cXG5cXHRcXHR2YXIgaW5kaWNlcyA9IFtdO1xcblxcdFxcdHZhciB2ZXJ0aWNlcyA9IFtdO1xcblxcdFxcdHZhciBub3JtYWxzID0gW107XFxuXFx0XFx0dmFyIHV2cyA9IFtdO1xcblxcblxcdFxcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcXG5cXG5cXHRcXHRmb3IgKCBpeSA9IDA7IGl5IDw9IGhlaWdodFNlZ21lbnRzOyBpeSArKyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdmVydGljZXNSb3cgPSBbXTtcXG5cXG5cXHRcXHRcXHR2YXIgdiA9IGl5IC8gaGVpZ2h0U2VnbWVudHM7XFxuXFxuXFx0XFx0XFx0Zm9yICggaXggPSAwOyBpeCA8PSB3aWR0aFNlZ21lbnRzOyBpeCArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdSA9IGl4IC8gd2lkdGhTZWdtZW50cztcXG5cXG5cXHRcXHRcXHRcXHQvLyB2ZXJ0ZXhcXG5cXG5cXHRcXHRcXHRcXHR2ZXJ0ZXgueCA9IC0gcmFkaXVzICogTWF0aC5jb3MoIHBoaVN0YXJ0ICsgdSAqIHBoaUxlbmd0aCApICogTWF0aC5zaW4oIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcXG5cXHRcXHRcXHRcXHR2ZXJ0ZXgueSA9IHJhZGl1cyAqIE1hdGguY29zKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XFxuXFx0XFx0XFx0XFx0dmVydGV4LnogPSByYWRpdXMgKiBNYXRoLnNpbiggcGhpU3RhcnQgKyB1ICogcGhpTGVuZ3RoICkgKiBNYXRoLnNpbiggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xcblxcblxcdFxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBub3JtYWxcXG5cXG5cXHRcXHRcXHRcXHRub3JtYWwuc2V0KCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICkubm9ybWFsaXplKCk7XFxuXFx0XFx0XFx0XFx0bm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdXZcXG5cXG5cXHRcXHRcXHRcXHR1dnMucHVzaCggdSwgMSAtIHYgKTtcXG5cXG5cXHRcXHRcXHRcXHR2ZXJ0aWNlc1Jvdy5wdXNoKCBpbmRleCArKyApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRncmlkLnB1c2goIHZlcnRpY2VzUm93ICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGluZGljZXNcXG5cXG5cXHRcXHRmb3IgKCBpeSA9IDA7IGl5IDwgaGVpZ2h0U2VnbWVudHM7IGl5ICsrICkge1xcblxcblxcdFxcdFxcdGZvciAoIGl4ID0gMDsgaXggPCB3aWR0aFNlZ21lbnRzOyBpeCArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgYSA9IGdyaWRbIGl5IF1bIGl4ICsgMSBdO1xcblxcdFxcdFxcdFxcdHZhciBiID0gZ3JpZFsgaXkgXVsgaXggXTtcXG5cXHRcXHRcXHRcXHR2YXIgYyA9IGdyaWRbIGl5ICsgMSBdWyBpeCBdO1xcblxcdFxcdFxcdFxcdHZhciBkID0gZ3JpZFsgaXkgKyAxIF1bIGl4ICsgMSBdO1xcblxcblxcdFxcdFxcdFxcdGlmICggaXkgIT09IDAgfHwgdGhldGFTdGFydCA+IDAgKSBpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcXG5cXHRcXHRcXHRcXHRpZiAoIGl5ICE9PSBoZWlnaHRTZWdtZW50cyAtIDEgfHwgdGhldGFFbmQgPCBNYXRoLlBJICkgaW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBidWlsZCBnZW9tZXRyeVxcblxcblxcdFxcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XFxuXFxuXFx0fVxcblxcblxcdFNwaGVyZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xcblxcdFNwaGVyZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNwaGVyZUJ1ZmZlckdlb21ldHJ5O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgS2FsZWIgTXVycGh5XFxuXFx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcXG5cXHQgKi9cXG5cXG5cXHQvLyBSaW5nR2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBSaW5nR2VvbWV0cnkoIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgdGhldGFTZWdtZW50cywgcGhpU2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xcblxcblxcdFxcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnUmluZ0dlb21ldHJ5JztcXG5cXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxuXFx0XFx0XFx0aW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxcblxcdFxcdFxcdG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcXG5cXHRcXHRcXHR0aGV0YVNlZ21lbnRzOiB0aGV0YVNlZ21lbnRzLFxcblxcdFxcdFxcdHBoaVNlZ21lbnRzOiBwaGlTZWdtZW50cyxcXG5cXHRcXHRcXHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxcblxcdFxcdFxcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBSaW5nQnVmZmVyR2VvbWV0cnkoIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgdGhldGFTZWdtZW50cywgcGhpU2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkgKTtcXG5cXHRcXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcXG5cXG5cXHR9XFxuXFxuXFx0UmluZ0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xcblxcdFJpbmdHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSaW5nR2VvbWV0cnk7XFxuXFxuXFx0Ly8gUmluZ0J1ZmZlckdlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gUmluZ0J1ZmZlckdlb21ldHJ5KCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIHRoZXRhU2VnbWVudHMsIHBoaVNlZ21lbnRzLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcXG5cXG5cXHRcXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1JpbmdCdWZmZXJHZW9tZXRyeSc7XFxuXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcblxcdFxcdFxcdGlubmVyUmFkaXVzOiBpbm5lclJhZGl1cyxcXG5cXHRcXHRcXHRvdXRlclJhZGl1czogb3V0ZXJSYWRpdXMsXFxuXFx0XFx0XFx0dGhldGFTZWdtZW50czogdGhldGFTZWdtZW50cyxcXG5cXHRcXHRcXHRwaGlTZWdtZW50czogcGhpU2VnbWVudHMsXFxuXFx0XFx0XFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcXG5cXHRcXHRcXHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcXG5cXHRcXHR9O1xcblxcblxcdFxcdGlubmVyUmFkaXVzID0gaW5uZXJSYWRpdXMgfHwgMC41O1xcblxcdFxcdG91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgfHwgMTtcXG5cXG5cXHRcXHR0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XFxuXFx0XFx0dGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJICogMjtcXG5cXG5cXHRcXHR0aGV0YVNlZ21lbnRzID0gdGhldGFTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gTWF0aC5tYXgoIDMsIHRoZXRhU2VnbWVudHMgKSA6IDg7XFxuXFx0XFx0cGhpU2VnbWVudHMgPSBwaGlTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gTWF0aC5tYXgoIDEsIHBoaVNlZ21lbnRzICkgOiAxO1xcblxcblxcdFxcdC8vIGJ1ZmZlcnNcXG5cXG5cXHRcXHR2YXIgaW5kaWNlcyA9IFtdO1xcblxcdFxcdHZhciB2ZXJ0aWNlcyA9IFtdO1xcblxcdFxcdHZhciBub3JtYWxzID0gW107XFxuXFx0XFx0dmFyIHV2cyA9IFtdO1xcblxcblxcdFxcdC8vIHNvbWUgaGVscGVyIHZhcmlhYmxlc1xcblxcblxcdFxcdHZhciBzZWdtZW50O1xcblxcdFxcdHZhciByYWRpdXMgPSBpbm5lclJhZGl1cztcXG5cXHRcXHR2YXIgcmFkaXVzU3RlcCA9ICggKCBvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzICkgLyBwaGlTZWdtZW50cyApO1xcblxcdFxcdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdHZhciB1diA9IG5ldyBWZWN0b3IyKCk7XFxuXFx0XFx0dmFyIGosIGk7XFxuXFxuXFx0XFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xcblxcblxcdFxcdGZvciAoIGogPSAwOyBqIDw9IHBoaVNlZ21lbnRzOyBqICsrICkge1xcblxcblxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDw9IHRoZXRhU2VnbWVudHM7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdmFsdWVzIGFyZSBnZW5lcmF0ZSBmcm9tIHRoZSBpbnNpZGUgb2YgdGhlIHJpbmcgdG8gdGhlIG91dHNpZGVcXG5cXG5cXHRcXHRcXHRcXHRzZWdtZW50ID0gdGhldGFTdGFydCArIGkgLyB0aGV0YVNlZ21lbnRzICogdGhldGFMZW5ndGg7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdmVydGV4XFxuXFxuXFx0XFx0XFx0XFx0dmVydGV4LnggPSByYWRpdXMgKiBNYXRoLmNvcyggc2VnbWVudCApO1xcblxcdFxcdFxcdFxcdHZlcnRleC55ID0gcmFkaXVzICogTWF0aC5zaW4oIHNlZ21lbnQgKTtcXG5cXG5cXHRcXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gbm9ybWFsXFxuXFxuXFx0XFx0XFx0XFx0bm9ybWFscy5wdXNoKCAwLCAwLCAxICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdXZcXG5cXG5cXHRcXHRcXHRcXHR1di54ID0gKCB2ZXJ0ZXgueCAvIG91dGVyUmFkaXVzICsgMSApIC8gMjtcXG5cXHRcXHRcXHRcXHR1di55ID0gKCB2ZXJ0ZXgueSAvIG91dGVyUmFkaXVzICsgMSApIC8gMjtcXG5cXG5cXHRcXHRcXHRcXHR1dnMucHVzaCggdXYueCwgdXYueSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBpbmNyZWFzZSB0aGUgcmFkaXVzIGZvciBuZXh0IHJvdyBvZiB2ZXJ0aWNlc1xcblxcblxcdFxcdFxcdHJhZGl1cyArPSByYWRpdXNTdGVwO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBpbmRpY2VzXFxuXFxuXFx0XFx0Zm9yICggaiA9IDA7IGogPCBwaGlTZWdtZW50czsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdGhldGFTZWdtZW50TGV2ZWwgPSBqICogKCB0aGV0YVNlZ21lbnRzICsgMSApO1xcblxcblxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDwgdGhldGFTZWdtZW50czsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRzZWdtZW50ID0gaSArIHRoZXRhU2VnbWVudExldmVsO1xcblxcblxcdFxcdFxcdFxcdHZhciBhID0gc2VnbWVudDtcXG5cXHRcXHRcXHRcXHR2YXIgYiA9IHNlZ21lbnQgKyB0aGV0YVNlZ21lbnRzICsgMTtcXG5cXHRcXHRcXHRcXHR2YXIgYyA9IHNlZ21lbnQgKyB0aGV0YVNlZ21lbnRzICsgMjtcXG5cXHRcXHRcXHRcXHR2YXIgZCA9IHNlZ21lbnQgKyAxO1xcblxcblxcdFxcdFxcdFxcdC8vIGZhY2VzXFxuXFxuXFx0XFx0XFx0XFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XFxuXFx0XFx0XFx0XFx0aW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBidWlsZCBnZW9tZXRyeVxcblxcblxcdFxcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XFxuXFxuXFx0fVxcblxcblxcdFJpbmdCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcXG5cXHRSaW5nQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmluZ0J1ZmZlckdlb21ldHJ5O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgYXN0cm9kdWQgLyBodHRwOi8vYXN0cm9kdWQuaXNncmVhdC5vcmcvXFxuXFx0ICogQGF1dGhvciB6ejg1IC8gaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcXG5cXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXFxuXFx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcXG5cXHQgKi9cXG5cXG5cXHQvLyBMYXRoZUdlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gTGF0aGVHZW9tZXRyeSggcG9pbnRzLCBzZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCApIHtcXG5cXG5cXHRcXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ0xhdGhlR2VvbWV0cnknO1xcblxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXG5cXHRcXHRcXHRwb2ludHM6IHBvaW50cyxcXG5cXHRcXHRcXHRzZWdtZW50czogc2VnbWVudHMsXFxuXFx0XFx0XFx0cGhpU3RhcnQ6IHBoaVN0YXJ0LFxcblxcdFxcdFxcdHBoaUxlbmd0aDogcGhpTGVuZ3RoXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IExhdGhlQnVmZmVyR2VvbWV0cnkoIHBvaW50cywgc2VnbWVudHMsIHBoaVN0YXJ0LCBwaGlMZW5ndGggKSApO1xcblxcdFxcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xcblxcblxcdH1cXG5cXG5cXHRMYXRoZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xcblxcdExhdGhlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGF0aGVHZW9tZXRyeTtcXG5cXG5cXHQvLyBMYXRoZUJ1ZmZlckdlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gTGF0aGVCdWZmZXJHZW9tZXRyeSggcG9pbnRzLCBzZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCApIHtcXG5cXG5cXHRcXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ0xhdGhlQnVmZmVyR2VvbWV0cnknO1xcblxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXG5cXHRcXHRcXHRwb2ludHM6IHBvaW50cyxcXG5cXHRcXHRcXHRzZWdtZW50czogc2VnbWVudHMsXFxuXFx0XFx0XFx0cGhpU3RhcnQ6IHBoaVN0YXJ0LFxcblxcdFxcdFxcdHBoaUxlbmd0aDogcGhpTGVuZ3RoXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRzZWdtZW50cyA9IE1hdGguZmxvb3IoIHNlZ21lbnRzICkgfHwgMTI7XFxuXFx0XFx0cGhpU3RhcnQgPSBwaGlTdGFydCB8fCAwO1xcblxcdFxcdHBoaUxlbmd0aCA9IHBoaUxlbmd0aCB8fCBNYXRoLlBJICogMjtcXG5cXG5cXHRcXHQvLyBjbGFtcCBwaGlMZW5ndGggc28gaXQncyBpbiByYW5nZSBvZiBbIDAsIDJQSSBdXFxuXFxuXFx0XFx0cGhpTGVuZ3RoID0gX01hdGguY2xhbXAoIHBoaUxlbmd0aCwgMCwgTWF0aC5QSSAqIDIgKTtcXG5cXG5cXG5cXHRcXHQvLyBidWZmZXJzXFxuXFxuXFx0XFx0dmFyIGluZGljZXMgPSBbXTtcXG5cXHRcXHR2YXIgdmVydGljZXMgPSBbXTtcXG5cXHRcXHR2YXIgdXZzID0gW107XFxuXFxuXFx0XFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xcblxcblxcdFxcdHZhciBiYXNlO1xcblxcdFxcdHZhciBpbnZlcnNlU2VnbWVudHMgPSAxLjAgLyBzZWdtZW50cztcXG5cXHRcXHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHR2YXIgdXYgPSBuZXcgVmVjdG9yMigpO1xcblxcdFxcdHZhciBpLCBqO1xcblxcblxcdFxcdC8vIGdlbmVyYXRlIHZlcnRpY2VzIGFuZCB1dnNcXG5cXG5cXHRcXHRmb3IgKCBpID0gMDsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcGhpID0gcGhpU3RhcnQgKyBpICogaW52ZXJzZVNlZ21lbnRzICogcGhpTGVuZ3RoO1xcblxcblxcdFxcdFxcdHZhciBzaW4gPSBNYXRoLnNpbiggcGhpICk7XFxuXFx0XFx0XFx0dmFyIGNvcyA9IE1hdGguY29zKCBwaGkgKTtcXG5cXG5cXHRcXHRcXHRmb3IgKCBqID0gMDsgaiA8PSAoIHBvaW50cy5sZW5ndGggLSAxICk7IGogKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdmVydGV4XFxuXFxuXFx0XFx0XFx0XFx0dmVydGV4LnggPSBwb2ludHNbIGogXS54ICogc2luO1xcblxcdFxcdFxcdFxcdHZlcnRleC55ID0gcG9pbnRzWyBqIF0ueTtcXG5cXHRcXHRcXHRcXHR2ZXJ0ZXgueiA9IHBvaW50c1sgaiBdLnggKiBjb3M7XFxuXFxuXFx0XFx0XFx0XFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xcblxcblxcdFxcdFxcdFxcdC8vIHV2XFxuXFxuXFx0XFx0XFx0XFx0dXYueCA9IGkgLyBzZWdtZW50cztcXG5cXHRcXHRcXHRcXHR1di55ID0gaiAvICggcG9pbnRzLmxlbmd0aCAtIDEgKTtcXG5cXG5cXHRcXHRcXHRcXHR1dnMucHVzaCggdXYueCwgdXYueSApO1xcblxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gaW5kaWNlc1xcblxcblxcdFxcdGZvciAoIGkgPSAwOyBpIDwgc2VnbWVudHM7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0Zm9yICggaiA9IDA7IGogPCAoIHBvaW50cy5sZW5ndGggLSAxICk7IGogKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0YmFzZSA9IGogKyBpICogcG9pbnRzLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgYSA9IGJhc2U7XFxuXFx0XFx0XFx0XFx0dmFyIGIgPSBiYXNlICsgcG9pbnRzLmxlbmd0aDtcXG5cXHRcXHRcXHRcXHR2YXIgYyA9IGJhc2UgKyBwb2ludHMubGVuZ3RoICsgMTtcXG5cXHRcXHRcXHRcXHR2YXIgZCA9IGJhc2UgKyAxO1xcblxcblxcdFxcdFxcdFxcdC8vIGZhY2VzXFxuXFxuXFx0XFx0XFx0XFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XFxuXFx0XFx0XFx0XFx0aW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBidWlsZCBnZW9tZXRyeVxcblxcblxcdFxcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XFxuXFxuXFx0XFx0Ly8gZ2VuZXJhdGUgbm9ybWFsc1xcblxcblxcdFxcdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcXG5cXG5cXHRcXHQvLyBpZiB0aGUgZ2VvbWV0cnkgaXMgY2xvc2VkLCB3ZSBuZWVkIHRvIGF2ZXJhZ2UgdGhlIG5vcm1hbHMgYWxvbmcgdGhlIHNlYW0uXFxuXFx0XFx0Ly8gYmVjYXVzZSB0aGUgY29ycmVzcG9uZGluZyB2ZXJ0aWNlcyBhcmUgaWRlbnRpY2FsIChidXQgc3RpbGwgaGF2ZSBkaWZmZXJlbnQgVVZzKS5cXG5cXG5cXHRcXHRpZiAoIHBoaUxlbmd0aCA9PT0gTWF0aC5QSSAqIDIgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIG5vcm1hbHMgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xcblxcdFxcdFxcdHZhciBuMSA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0dmFyIG4yID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgbiA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0Ly8gdGhpcyBpcyB0aGUgYnVmZmVyIG9mZnNldCBmb3IgdGhlIGxhc3QgbGluZSBvZiB2ZXJ0aWNlc1xcblxcblxcdFxcdFxcdGJhc2UgPSBzZWdtZW50cyAqIHBvaW50cy5sZW5ndGggKiAzO1xcblxcblxcdFxcdFxcdGZvciAoIGkgPSAwLCBqID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKyssIGogKz0gMyApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBzZWxlY3QgdGhlIG5vcm1hbCBvZiB0aGUgdmVydGV4IGluIHRoZSBmaXJzdCBsaW5lXFxuXFxuXFx0XFx0XFx0XFx0bjEueCA9IG5vcm1hbHNbIGogKyAwIF07XFxuXFx0XFx0XFx0XFx0bjEueSA9IG5vcm1hbHNbIGogKyAxIF07XFxuXFx0XFx0XFx0XFx0bjEueiA9IG5vcm1hbHNbIGogKyAyIF07XFxuXFxuXFx0XFx0XFx0XFx0Ly8gc2VsZWN0IHRoZSBub3JtYWwgb2YgdGhlIHZlcnRleCBpbiB0aGUgbGFzdCBsaW5lXFxuXFxuXFx0XFx0XFx0XFx0bjIueCA9IG5vcm1hbHNbIGJhc2UgKyBqICsgMCBdO1xcblxcdFxcdFxcdFxcdG4yLnkgPSBub3JtYWxzWyBiYXNlICsgaiArIDEgXTtcXG5cXHRcXHRcXHRcXHRuMi56ID0gbm9ybWFsc1sgYmFzZSArIGogKyAyIF07XFxuXFxuXFx0XFx0XFx0XFx0Ly8gYXZlcmFnZSBub3JtYWxzXFxuXFxuXFx0XFx0XFx0XFx0bi5hZGRWZWN0b3JzKCBuMSwgbjIgKS5ub3JtYWxpemUoKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBhc3NpZ24gdGhlIG5ldyB2YWx1ZXMgdG8gYm90aCBub3JtYWxzXFxuXFxuXFx0XFx0XFx0XFx0bm9ybWFsc1sgaiArIDAgXSA9IG5vcm1hbHNbIGJhc2UgKyBqICsgMCBdID0gbi54O1xcblxcdFxcdFxcdFxcdG5vcm1hbHNbIGogKyAxIF0gPSBub3JtYWxzWyBiYXNlICsgaiArIDEgXSA9IG4ueTtcXG5cXHRcXHRcXHRcXHRub3JtYWxzWyBqICsgMiBdID0gbm9ybWFsc1sgYmFzZSArIGogKyAyIF0gPSBuLno7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHR9XFxuXFxuXFx0TGF0aGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcXG5cXHRMYXRoZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExhdGhlQnVmZmVyR2VvbWV0cnk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBqb25vYnIxIC8gaHR0cDovL2pvbm9icjEuY29tXFxuXFx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcXG5cXHQgKi9cXG5cXG5cXHQvLyBTaGFwZUdlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gU2hhcGVHZW9tZXRyeSggc2hhcGVzLCBjdXJ2ZVNlZ21lbnRzICkge1xcblxcblxcdFxcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnU2hhcGVHZW9tZXRyeSc7XFxuXFxuXFx0XFx0aWYgKCB0eXBlb2YgY3VydmVTZWdtZW50cyA9PT0gJ29iamVjdCcgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU2hhcGVHZW9tZXRyeTogT3B0aW9ucyBwYXJhbWV0ZXIgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxuXFxuXFx0XFx0XFx0Y3VydmVTZWdtZW50cyA9IGN1cnZlU2VnbWVudHMuY3VydmVTZWdtZW50cztcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcblxcdFxcdFxcdHNoYXBlczogc2hhcGVzLFxcblxcdFxcdFxcdGN1cnZlU2VnbWVudHM6IGN1cnZlU2VnbWVudHNcXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgU2hhcGVCdWZmZXJHZW9tZXRyeSggc2hhcGVzLCBjdXJ2ZVNlZ21lbnRzICkgKTtcXG5cXHRcXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcXG5cXG5cXHR9XFxuXFxuXFx0U2hhcGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcXG5cXHRTaGFwZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNoYXBlR2VvbWV0cnk7XFxuXFxuXFx0U2hhcGVHZW9tZXRyeS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdHZhciBkYXRhID0gR2VvbWV0cnkucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dmFyIHNoYXBlcyA9IHRoaXMucGFyYW1ldGVycy5zaGFwZXM7XFxuXFxuXFx0XFx0cmV0dXJuIHRvSlNPTiggc2hhcGVzLCBkYXRhICk7XFxuXFxuXFx0fTtcXG5cXG5cXHQvLyBTaGFwZUJ1ZmZlckdlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gU2hhcGVCdWZmZXJHZW9tZXRyeSggc2hhcGVzLCBjdXJ2ZVNlZ21lbnRzICkge1xcblxcblxcdFxcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnU2hhcGVCdWZmZXJHZW9tZXRyeSc7XFxuXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcblxcdFxcdFxcdHNoYXBlczogc2hhcGVzLFxcblxcdFxcdFxcdGN1cnZlU2VnbWVudHM6IGN1cnZlU2VnbWVudHNcXG5cXHRcXHR9O1xcblxcblxcdFxcdGN1cnZlU2VnbWVudHMgPSBjdXJ2ZVNlZ21lbnRzIHx8IDEyO1xcblxcblxcdFxcdC8vIGJ1ZmZlcnNcXG5cXG5cXHRcXHR2YXIgaW5kaWNlcyA9IFtdO1xcblxcdFxcdHZhciB2ZXJ0aWNlcyA9IFtdO1xcblxcdFxcdHZhciBub3JtYWxzID0gW107XFxuXFx0XFx0dmFyIHV2cyA9IFtdO1xcblxcblxcdFxcdC8vIGhlbHBlciB2YXJpYWJsZXNcXG5cXG5cXHRcXHR2YXIgZ3JvdXBTdGFydCA9IDA7XFxuXFx0XFx0dmFyIGdyb3VwQ291bnQgPSAwO1xcblxcblxcdFxcdC8vIGFsbG93IHNpbmdsZSBhbmQgYXJyYXkgdmFsdWVzIGZvciBcXFwic2hhcGVzXFxcIiBwYXJhbWV0ZXJcXG5cXG5cXHRcXHRpZiAoIEFycmF5LmlzQXJyYXkoIHNoYXBlcyApID09PSBmYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRhZGRTaGFwZSggc2hhcGVzICk7XFxuXFxuXFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBzaGFwZXMubGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdGFkZFNoYXBlKCBzaGFwZXNbIGkgXSApO1xcblxcblxcdFxcdFxcdFxcdHRoaXMuYWRkR3JvdXAoIGdyb3VwU3RhcnQsIGdyb3VwQ291bnQsIGkgKTsgLy8gZW5hYmxlcyBNdWx0aU1hdGVyaWFsIHN1cHBvcnRcXG5cXG5cXHRcXHRcXHRcXHRncm91cFN0YXJ0ICs9IGdyb3VwQ291bnQ7XFxuXFx0XFx0XFx0XFx0Z3JvdXBDb3VudCA9IDA7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBidWlsZCBnZW9tZXRyeVxcblxcblxcdFxcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XFxuXFxuXFxuXFx0XFx0Ly8gaGVscGVyIGZ1bmN0aW9uc1xcblxcblxcdFxcdGZ1bmN0aW9uIGFkZFNoYXBlKCBzaGFwZSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgaSwgbCwgc2hhcGVIb2xlO1xcblxcblxcdFxcdFxcdHZhciBpbmRleE9mZnNldCA9IHZlcnRpY2VzLmxlbmd0aCAvIDM7XFxuXFx0XFx0XFx0dmFyIHBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcXG5cXG5cXHRcXHRcXHR2YXIgc2hhcGVWZXJ0aWNlcyA9IHBvaW50cy5zaGFwZTtcXG5cXHRcXHRcXHR2YXIgc2hhcGVIb2xlcyA9IHBvaW50cy5ob2xlcztcXG5cXG5cXHRcXHRcXHQvLyBjaGVjayBkaXJlY3Rpb24gb2YgdmVydGljZXNcXG5cXG5cXHRcXHRcXHRpZiAoIFNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoIHNoYXBlVmVydGljZXMgKSA9PT0gZmFsc2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0c2hhcGVWZXJ0aWNlcyA9IHNoYXBlVmVydGljZXMucmV2ZXJzZSgpO1xcblxcblxcdFxcdFxcdFxcdC8vIGFsc28gY2hlY2sgaWYgaG9sZXMgYXJlIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb25cXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCBpID0gMCwgbCA9IHNoYXBlSG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzaGFwZUhvbGUgPSBzaGFwZUhvbGVzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCBzaGFwZUhvbGUgKSA9PT0gdHJ1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRzaGFwZUhvbGVzWyBpIF0gPSBzaGFwZUhvbGUucmV2ZXJzZSgpO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBmYWNlcyA9IFNoYXBlVXRpbHMudHJpYW5ndWxhdGVTaGFwZSggc2hhcGVWZXJ0aWNlcywgc2hhcGVIb2xlcyApO1xcblxcblxcdFxcdFxcdC8vIGpvaW4gdmVydGljZXMgb2YgaW5uZXIgYW5kIG91dGVyIHBhdGhzIHRvIGEgc2luZ2xlIGFycmF5XFxuXFxuXFx0XFx0XFx0Zm9yICggaSA9IDAsIGwgPSBzaGFwZUhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0c2hhcGVIb2xlID0gc2hhcGVIb2xlc1sgaSBdO1xcblxcdFxcdFxcdFxcdHNoYXBlVmVydGljZXMgPSBzaGFwZVZlcnRpY2VzLmNvbmNhdCggc2hhcGVIb2xlICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIHZlcnRpY2VzLCBub3JtYWxzLCB1dnNcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gMCwgbCA9IHNoYXBlVmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdmVydGV4ID0gc2hhcGVWZXJ0aWNlc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgMCApO1xcblxcdFxcdFxcdFxcdG5vcm1hbHMucHVzaCggMCwgMCwgMSApO1xcblxcdFxcdFxcdFxcdHV2cy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnkgKTsgLy8gd29ybGQgdXZzXFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGluY2lkZXNcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdHZhciBhID0gZmFjZVsgMCBdICsgaW5kZXhPZmZzZXQ7XFxuXFx0XFx0XFx0XFx0dmFyIGIgPSBmYWNlWyAxIF0gKyBpbmRleE9mZnNldDtcXG5cXHRcXHRcXHRcXHR2YXIgYyA9IGZhY2VbIDIgXSArIGluZGV4T2Zmc2V0O1xcblxcblxcdFxcdFxcdFxcdGluZGljZXMucHVzaCggYSwgYiwgYyApO1xcblxcdFxcdFxcdFxcdGdyb3VwQ291bnQgKz0gMztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdH1cXG5cXG5cXHRTaGFwZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xcblxcdFNoYXBlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2hhcGVCdWZmZXJHZW9tZXRyeTtcXG5cXG5cXHRTaGFwZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0dmFyIGRhdGEgPSBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR2YXIgc2hhcGVzID0gdGhpcy5wYXJhbWV0ZXJzLnNoYXBlcztcXG5cXG5cXHRcXHRyZXR1cm4gdG9KU09OKCBzaGFwZXMsIGRhdGEgKTtcXG5cXG5cXHR9O1xcblxcblxcdC8vXFxuXFxuXFx0ZnVuY3Rpb24gdG9KU09OKCBzaGFwZXMsIGRhdGEgKSB7XFxuXFxuXFx0XFx0ZGF0YS5zaGFwZXMgPSBbXTtcXG5cXG5cXHRcXHRpZiAoIEFycmF5LmlzQXJyYXkoIHNoYXBlcyApICkge1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBzaGFwZSA9IHNoYXBlc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdGRhdGEuc2hhcGVzLnB1c2goIHNoYXBlLnV1aWQgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRkYXRhLnNoYXBlcy5wdXNoKCBzaGFwZXMudXVpZCApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gZGF0YTtcXG5cXG5cXHR9XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XFxuXFx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBFZGdlc0dlb21ldHJ5KCBnZW9tZXRyeSwgdGhyZXNob2xkQW5nbGUgKSB7XFxuXFxuXFx0XFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdFZGdlc0dlb21ldHJ5JztcXG5cXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxuXFx0XFx0XFx0dGhyZXNob2xkQW5nbGU6IHRocmVzaG9sZEFuZ2xlXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aHJlc2hvbGRBbmdsZSA9ICggdGhyZXNob2xkQW5nbGUgIT09IHVuZGVmaW5lZCApID8gdGhyZXNob2xkQW5nbGUgOiAxO1xcblxcblxcdFxcdC8vIGJ1ZmZlclxcblxcblxcdFxcdHZhciB2ZXJ0aWNlcyA9IFtdO1xcblxcblxcdFxcdC8vIGhlbHBlciB2YXJpYWJsZXNcXG5cXG5cXHRcXHR2YXIgdGhyZXNob2xkRG90ID0gTWF0aC5jb3MoIF9NYXRoLkRFRzJSQUQgKiB0aHJlc2hvbGRBbmdsZSApO1xcblxcdFxcdHZhciBlZGdlID0gWyAwLCAwIF0sIGVkZ2VzID0ge30sIGVkZ2UxLCBlZGdlMjtcXG5cXHRcXHR2YXIga2V5LCBrZXlzID0gWyAnYScsICdiJywgJ2MnIF07XFxuXFxuXFx0XFx0Ly8gcHJlcGFyZSBzb3VyY2UgZ2VvbWV0cnlcXG5cXG5cXHRcXHR2YXIgZ2VvbWV0cnkyO1xcblxcblxcdFxcdGlmICggZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcXG5cXG5cXHRcXHRcXHRnZW9tZXRyeTIgPSBuZXcgR2VvbWV0cnkoKTtcXG5cXHRcXHRcXHRnZW9tZXRyeTIuZnJvbUJ1ZmZlckdlb21ldHJ5KCBnZW9tZXRyeSApO1xcblxcblxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0Z2VvbWV0cnkyID0gZ2VvbWV0cnkuY2xvbmUoKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Z2VvbWV0cnkyLm1lcmdlVmVydGljZXMoKTtcXG5cXHRcXHRnZW9tZXRyeTIuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XFxuXFxuXFx0XFx0dmFyIHNvdXJjZVZlcnRpY2VzID0gZ2VvbWV0cnkyLnZlcnRpY2VzO1xcblxcdFxcdHZhciBmYWNlcyA9IGdlb21ldHJ5Mi5mYWNlcztcXG5cXG5cXHRcXHQvLyBub3cgY3JlYXRlIGEgZGF0YSBzdHJ1Y3R1cmUgd2hlcmUgZWFjaCBlbnRyeSByZXByZXNlbnRzIGFuIGVkZ2Ugd2l0aCBpdHMgYWRqb2luaW5nIGZhY2VzXFxuXFxuXFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGogPSAwOyBqIDwgMzsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRlZGdlMSA9IGZhY2VbIGtleXNbIGogXSBdO1xcblxcdFxcdFxcdFxcdGVkZ2UyID0gZmFjZVsga2V5c1sgKCBqICsgMSApICUgMyBdIF07XFxuXFx0XFx0XFx0XFx0ZWRnZVsgMCBdID0gTWF0aC5taW4oIGVkZ2UxLCBlZGdlMiApO1xcblxcdFxcdFxcdFxcdGVkZ2VbIDEgXSA9IE1hdGgubWF4KCBlZGdlMSwgZWRnZTIgKTtcXG5cXG5cXHRcXHRcXHRcXHRrZXkgPSBlZGdlWyAwIF0gKyAnLCcgKyBlZGdlWyAxIF07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBlZGdlc1sga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRlZGdlc1sga2V5IF0gPSB7IGluZGV4MTogZWRnZVsgMCBdLCBpbmRleDI6IGVkZ2VbIDEgXSwgZmFjZTE6IGksIGZhY2UyOiB1bmRlZmluZWQgfTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdGVkZ2VzWyBrZXkgXS5mYWNlMiA9IGk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gZ2VuZXJhdGUgdmVydGljZXNcXG5cXG5cXHRcXHRmb3IgKCBrZXkgaW4gZWRnZXMgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGUgPSBlZGdlc1sga2V5IF07XFxuXFxuXFx0XFx0XFx0Ly8gYW4gZWRnZSBpcyBvbmx5IHJlbmRlcmVkIGlmIHRoZSBhbmdsZSAoaW4gZGVncmVlcykgYmV0d2VlbiB0aGUgZmFjZSBub3JtYWxzIG9mIHRoZSBhZGpvaW5pbmcgZmFjZXMgZXhjZWVkcyB0aGlzIHZhbHVlLiBkZWZhdWx0ID0gMSBkZWdyZWUuXFxuXFxuXFx0XFx0XFx0aWYgKCBlLmZhY2UyID09PSB1bmRlZmluZWQgfHwgZmFjZXNbIGUuZmFjZTEgXS5ub3JtYWwuZG90KCBmYWNlc1sgZS5mYWNlMiBdLm5vcm1hbCApIDw9IHRocmVzaG9sZERvdCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdmVydGV4ID0gc291cmNlVmVydGljZXNbIGUuaW5kZXgxIF07XFxuXFx0XFx0XFx0XFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xcblxcblxcdFxcdFxcdFxcdHZlcnRleCA9IHNvdXJjZVZlcnRpY2VzWyBlLmluZGV4MiBdO1xcblxcdFxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGJ1aWxkIGdlb21ldHJ5XFxuXFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XFxuXFxuXFx0fVxcblxcblxcdEVkZ2VzR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XFxuXFx0RWRnZXNHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFZGdlc0dlb21ldHJ5O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcXG5cXHQgKi9cXG5cXG5cXHQvLyBDeWxpbmRlckdlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gQ3lsaW5kZXJHZW9tZXRyeSggcmFkaXVzVG9wLCByYWRpdXNCb3R0b20sIGhlaWdodCwgcmFkaWFsU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBvcGVuRW5kZWQsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xcblxcblxcdFxcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnQ3lsaW5kZXJHZW9tZXRyeSc7XFxuXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcblxcdFxcdFxcdHJhZGl1c1RvcDogcmFkaXVzVG9wLFxcblxcdFxcdFxcdHJhZGl1c0JvdHRvbTogcmFkaXVzQm90dG9tLFxcblxcdFxcdFxcdGhlaWdodDogaGVpZ2h0LFxcblxcdFxcdFxcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcXG5cXHRcXHRcXHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXFxuXFx0XFx0XFx0b3BlbkVuZGVkOiBvcGVuRW5kZWQsXFxuXFx0XFx0XFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcXG5cXHRcXHRcXHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeSggcmFkaXVzVG9wLCByYWRpdXNCb3R0b20sIGhlaWdodCwgcmFkaWFsU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBvcGVuRW5kZWQsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkgKTtcXG5cXHRcXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcXG5cXG5cXHR9XFxuXFxuXFx0Q3lsaW5kZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcXG5cXHRDeWxpbmRlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEN5bGluZGVyR2VvbWV0cnk7XFxuXFxuXFx0Ly8gQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeVxcblxcblxcdGZ1bmN0aW9uIEN5bGluZGVyQnVmZmVyR2VvbWV0cnkoIHJhZGl1c1RvcCwgcmFkaXVzQm90dG9tLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcXG5cXG5cXHRcXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ0N5bGluZGVyQnVmZmVyR2VvbWV0cnknO1xcblxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXG5cXHRcXHRcXHRyYWRpdXNUb3A6IHJhZGl1c1RvcCxcXG5cXHRcXHRcXHRyYWRpdXNCb3R0b206IHJhZGl1c0JvdHRvbSxcXG5cXHRcXHRcXHRoZWlnaHQ6IGhlaWdodCxcXG5cXHRcXHRcXHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXFxuXFx0XFx0XFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxcblxcdFxcdFxcdG9wZW5FbmRlZDogb3BlbkVuZGVkLFxcblxcdFxcdFxcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXFxuXFx0XFx0XFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR2YXIgc2NvcGUgPSB0aGlzO1xcblxcblxcdFxcdHJhZGl1c1RvcCA9IHJhZGl1c1RvcCAhPT0gdW5kZWZpbmVkID8gcmFkaXVzVG9wIDogMTtcXG5cXHRcXHRyYWRpdXNCb3R0b20gPSByYWRpdXNCb3R0b20gIT09IHVuZGVmaW5lZCA/IHJhZGl1c0JvdHRvbSA6IDE7XFxuXFx0XFx0aGVpZ2h0ID0gaGVpZ2h0IHx8IDE7XFxuXFxuXFx0XFx0cmFkaWFsU2VnbWVudHMgPSBNYXRoLmZsb29yKCByYWRpYWxTZWdtZW50cyApIHx8IDg7XFxuXFx0XFx0aGVpZ2h0U2VnbWVudHMgPSBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApIHx8IDE7XFxuXFxuXFx0XFx0b3BlbkVuZGVkID0gb3BlbkVuZGVkICE9PSB1bmRlZmluZWQgPyBvcGVuRW5kZWQgOiBmYWxzZTtcXG5cXHRcXHR0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDAuMDtcXG5cXHRcXHR0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEkgKiAyO1xcblxcblxcdFxcdC8vIGJ1ZmZlcnNcXG5cXG5cXHRcXHR2YXIgaW5kaWNlcyA9IFtdO1xcblxcdFxcdHZhciB2ZXJ0aWNlcyA9IFtdO1xcblxcdFxcdHZhciBub3JtYWxzID0gW107XFxuXFx0XFx0dmFyIHV2cyA9IFtdO1xcblxcblxcdFxcdC8vIGhlbHBlciB2YXJpYWJsZXNcXG5cXG5cXHRcXHR2YXIgaW5kZXggPSAwO1xcblxcdFxcdHZhciBpbmRleEFycmF5ID0gW107XFxuXFx0XFx0dmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xcblxcdFxcdHZhciBncm91cFN0YXJ0ID0gMDtcXG5cXG5cXHRcXHQvLyBnZW5lcmF0ZSBnZW9tZXRyeVxcblxcblxcdFxcdGdlbmVyYXRlVG9yc28oKTtcXG5cXG5cXHRcXHRpZiAoIG9wZW5FbmRlZCA9PT0gZmFsc2UgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCByYWRpdXNUb3AgPiAwICkgZ2VuZXJhdGVDYXAoIHRydWUgKTtcXG5cXHRcXHRcXHRpZiAoIHJhZGl1c0JvdHRvbSA+IDAgKSBnZW5lcmF0ZUNhcCggZmFsc2UgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gYnVpbGQgZ2VvbWV0cnlcXG5cXG5cXHRcXHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xcblxcblxcdFxcdGZ1bmN0aW9uIGdlbmVyYXRlVG9yc28oKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHgsIHk7XFxuXFx0XFx0XFx0dmFyIG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0dmFyIHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0dmFyIGdyb3VwQ291bnQgPSAwO1xcblxcblxcdFxcdFxcdC8vIHRoaXMgd2lsbCBiZSB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgbm9ybWFsXFxuXFx0XFx0XFx0dmFyIHNsb3BlID0gKCByYWRpdXNCb3R0b20gLSByYWRpdXNUb3AgKSAvIGhlaWdodDtcXG5cXG5cXHRcXHRcXHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXFxuXFxuXFx0XFx0XFx0Zm9yICggeSA9IDA7IHkgPD0gaGVpZ2h0U2VnbWVudHM7IHkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGluZGV4Um93ID0gW107XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHYgPSB5IC8gaGVpZ2h0U2VnbWVudHM7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gY2FsY3VsYXRlIHRoZSByYWRpdXMgb2YgdGhlIGN1cnJlbnQgcm93XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHJhZGl1cyA9IHYgKiAoIHJhZGl1c0JvdHRvbSAtIHJhZGl1c1RvcCApICsgcmFkaXVzVG9wO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHggPSAwOyB4IDw9IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciB1ID0geCAvIHJhZGlhbFNlZ21lbnRzO1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciB0aGV0YSA9IHUgKiB0aGV0YUxlbmd0aCArIHRoZXRhU3RhcnQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHNpblRoZXRhID0gTWF0aC5zaW4oIHRoZXRhICk7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGNvc1RoZXRhID0gTWF0aC5jb3MoIHRoZXRhICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdmVydGV4XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmVydGV4LnggPSByYWRpdXMgKiBzaW5UaGV0YTtcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0ZXgueSA9IC0gdiAqIGhlaWdodCArIGhhbGZIZWlnaHQ7XFxuXFx0XFx0XFx0XFx0XFx0dmVydGV4LnogPSByYWRpdXMgKiBjb3NUaGV0YTtcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gbm9ybWFsXFxuXFxuXFx0XFx0XFx0XFx0XFx0bm9ybWFsLnNldCggc2luVGhldGEsIHNsb3BlLCBjb3NUaGV0YSApLm5vcm1hbGl6ZSgpO1xcblxcdFxcdFxcdFxcdFxcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIHV2XFxuXFxuXFx0XFx0XFx0XFx0XFx0dXZzLnB1c2goIHUsIDEgLSB2ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gc2F2ZSBpbmRleCBvZiB2ZXJ0ZXggaW4gcmVzcGVjdGl2ZSByb3dcXG5cXG5cXHRcXHRcXHRcXHRcXHRpbmRleFJvdy5wdXNoKCBpbmRleCArKyApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBub3cgc2F2ZSB2ZXJ0aWNlcyBvZiB0aGUgcm93IGluIG91ciBpbmRleCBhcnJheVxcblxcblxcdFxcdFxcdFxcdGluZGV4QXJyYXkucHVzaCggaW5kZXhSb3cgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gZ2VuZXJhdGUgaW5kaWNlc1xcblxcblxcdFxcdFxcdGZvciAoIHggPSAwOyB4IDwgcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggeSA9IDA7IHkgPCBoZWlnaHRTZWdtZW50czsgeSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyB3ZSB1c2UgdGhlIGluZGV4IGFycmF5IHRvIGFjY2VzcyB0aGUgY29ycmVjdCBpbmRpY2VzXFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGEgPSBpbmRleEFycmF5WyB5IF1bIHggXTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgYiA9IGluZGV4QXJyYXlbIHkgKyAxIF1bIHggXTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgYyA9IGluZGV4QXJyYXlbIHkgKyAxIF1bIHggKyAxIF07XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGQgPSBpbmRleEFycmF5WyB5IF1bIHggKyAxIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gZmFjZXNcXG5cXG5cXHRcXHRcXHRcXHRcXHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcXG5cXHRcXHRcXHRcXHRcXHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyB1cGRhdGUgZ3JvdXAgY291bnRlclxcblxcblxcdFxcdFxcdFxcdFxcdGdyb3VwQ291bnQgKz0gNjtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGFkZCBhIGdyb3VwIHRvIHRoZSBnZW9tZXRyeS4gdGhpcyB3aWxsIGVuc3VyZSBtdWx0aSBtYXRlcmlhbCBzdXBwb3J0XFxuXFxuXFx0XFx0XFx0c2NvcGUuYWRkR3JvdXAoIGdyb3VwU3RhcnQsIGdyb3VwQ291bnQsIDAgKTtcXG5cXG5cXHRcXHRcXHQvLyBjYWxjdWxhdGUgbmV3IHN0YXJ0IHZhbHVlIGZvciBncm91cHNcXG5cXG5cXHRcXHRcXHRncm91cFN0YXJ0ICs9IGdyb3VwQ291bnQ7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGdlbmVyYXRlQ2FwKCB0b3AgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHgsIGNlbnRlckluZGV4U3RhcnQsIGNlbnRlckluZGV4RW5kO1xcblxcblxcdFxcdFxcdHZhciB1diA9IG5ldyBWZWN0b3IyKCk7XFxuXFx0XFx0XFx0dmFyIHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0dmFyIGdyb3VwQ291bnQgPSAwO1xcblxcblxcdFxcdFxcdHZhciByYWRpdXMgPSAoIHRvcCA9PT0gdHJ1ZSApID8gcmFkaXVzVG9wIDogcmFkaXVzQm90dG9tO1xcblxcdFxcdFxcdHZhciBzaWduID0gKCB0b3AgPT09IHRydWUgKSA/IDEgOiAtIDE7XFxuXFxuXFx0XFx0XFx0Ly8gc2F2ZSB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNlbnRlciB2ZXJ0ZXhcXG5cXHRcXHRcXHRjZW50ZXJJbmRleFN0YXJ0ID0gaW5kZXg7XFxuXFxuXFx0XFx0XFx0Ly8gZmlyc3Qgd2UgZ2VuZXJhdGUgdGhlIGNlbnRlciB2ZXJ0ZXggZGF0YSBvZiB0aGUgY2FwLlxcblxcdFxcdFxcdC8vIGJlY2F1c2UgdGhlIGdlb21ldHJ5IG5lZWRzIG9uZSBzZXQgb2YgdXZzIHBlciBmYWNlLFxcblxcdFxcdFxcdC8vIHdlIG11c3QgZ2VuZXJhdGUgYSBjZW50ZXIgdmVydGV4IHBlciBmYWNlL3NlZ21lbnRcXG5cXG5cXHRcXHRcXHRmb3IgKCB4ID0gMTsgeCA8PSByYWRpYWxTZWdtZW50czsgeCArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyB2ZXJ0ZXhcXG5cXG5cXHRcXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCAwLCBoYWxmSGVpZ2h0ICogc2lnbiwgMCApO1xcblxcblxcdFxcdFxcdFxcdC8vIG5vcm1hbFxcblxcblxcdFxcdFxcdFxcdG5vcm1hbHMucHVzaCggMCwgc2lnbiwgMCApO1xcblxcblxcdFxcdFxcdFxcdC8vIHV2XFxuXFxuXFx0XFx0XFx0XFx0dXZzLnB1c2goIDAuNSwgMC41ICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gaW5jcmVhc2UgaW5kZXhcXG5cXG5cXHRcXHRcXHRcXHRpbmRleCArKztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gc2F2ZSB0aGUgaW5kZXggb2YgdGhlIGxhc3QgY2VudGVyIHZlcnRleFxcblxcblxcdFxcdFxcdGNlbnRlckluZGV4RW5kID0gaW5kZXg7XFxuXFxuXFx0XFx0XFx0Ly8gbm93IHdlIGdlbmVyYXRlIHRoZSBzdXJyb3VuZGluZyB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXFxuXFxuXFx0XFx0XFx0Zm9yICggeCA9IDA7IHggPD0gcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHUgPSB4IC8gcmFkaWFsU2VnbWVudHM7XFxuXFx0XFx0XFx0XFx0dmFyIHRoZXRhID0gdSAqIHRoZXRhTGVuZ3RoICsgdGhldGFTdGFydDtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgY29zVGhldGEgPSBNYXRoLmNvcyggdGhldGEgKTtcXG5cXHRcXHRcXHRcXHR2YXIgc2luVGhldGEgPSBNYXRoLnNpbiggdGhldGEgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyB2ZXJ0ZXhcXG5cXG5cXHRcXHRcXHRcXHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIHNpblRoZXRhO1xcblxcdFxcdFxcdFxcdHZlcnRleC55ID0gaGFsZkhlaWdodCAqIHNpZ247XFxuXFx0XFx0XFx0XFx0dmVydGV4LnogPSByYWRpdXMgKiBjb3NUaGV0YTtcXG5cXHRcXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gbm9ybWFsXFxuXFxuXFx0XFx0XFx0XFx0bm9ybWFscy5wdXNoKCAwLCBzaWduLCAwICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdXZcXG5cXG5cXHRcXHRcXHRcXHR1di54ID0gKCBjb3NUaGV0YSAqIDAuNSApICsgMC41O1xcblxcdFxcdFxcdFxcdHV2LnkgPSAoIHNpblRoZXRhICogMC41ICogc2lnbiApICsgMC41O1xcblxcdFxcdFxcdFxcdHV2cy5wdXNoKCB1di54LCB1di55ICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gaW5jcmVhc2UgaW5kZXhcXG5cXG5cXHRcXHRcXHRcXHRpbmRleCArKztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gZ2VuZXJhdGUgaW5kaWNlc1xcblxcblxcdFxcdFxcdGZvciAoIHggPSAwOyB4IDwgcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGMgPSBjZW50ZXJJbmRleFN0YXJ0ICsgeDtcXG5cXHRcXHRcXHRcXHR2YXIgaSA9IGNlbnRlckluZGV4RW5kICsgeDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHRvcCA9PT0gdHJ1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBmYWNlIHRvcFxcblxcblxcdFxcdFxcdFxcdFxcdGluZGljZXMucHVzaCggaSwgaSArIDEsIGMgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGZhY2UgYm90dG9tXFxuXFxuXFx0XFx0XFx0XFx0XFx0aW5kaWNlcy5wdXNoKCBpICsgMSwgaSwgYyApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRncm91cENvdW50ICs9IDM7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGFkZCBhIGdyb3VwIHRvIHRoZSBnZW9tZXRyeS4gdGhpcyB3aWxsIGVuc3VyZSBtdWx0aSBtYXRlcmlhbCBzdXBwb3J0XFxuXFxuXFx0XFx0XFx0c2NvcGUuYWRkR3JvdXAoIGdyb3VwU3RhcnQsIGdyb3VwQ291bnQsIHRvcCA9PT0gdHJ1ZSA/IDEgOiAyICk7XFxuXFxuXFx0XFx0XFx0Ly8gY2FsY3VsYXRlIG5ldyBzdGFydCB2YWx1ZSBmb3IgZ3JvdXBzXFxuXFxuXFx0XFx0XFx0Z3JvdXBTdGFydCArPSBncm91cENvdW50O1xcblxcblxcdFxcdH1cXG5cXG5cXHR9XFxuXFxuXFx0Q3lsaW5kZXJCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcXG5cXHRDeWxpbmRlckJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEN5bGluZGVyQnVmZmVyR2VvbWV0cnk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBhYmVsbmF0aW9uIC8gaHR0cDovL2dpdGh1Yi5jb20vYWJlbG5hdGlvblxcblxcdCAqL1xcblxcblxcdC8vIENvbmVHZW9tZXRyeVxcblxcblxcdGZ1bmN0aW9uIENvbmVHZW9tZXRyeSggcmFkaXVzLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcXG5cXG5cXHRcXHRDeWxpbmRlckdlb21ldHJ5LmNhbGwoIHRoaXMsIDAsIHJhZGl1cywgaGVpZ2h0LCByYWRpYWxTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIG9wZW5FbmRlZCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnQ29uZUdlb21ldHJ5JztcXG5cXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxuXFx0XFx0XFx0cmFkaXVzOiByYWRpdXMsXFxuXFx0XFx0XFx0aGVpZ2h0OiBoZWlnaHQsXFxuXFx0XFx0XFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxcblxcdFxcdFxcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcXG5cXHRcXHRcXHRvcGVuRW5kZWQ6IG9wZW5FbmRlZCxcXG5cXHRcXHRcXHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxcblxcdFxcdFxcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxcblxcdFxcdH07XFxuXFxuXFx0fVxcblxcblxcdENvbmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDeWxpbmRlckdlb21ldHJ5LnByb3RvdHlwZSApO1xcblxcdENvbmVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb25lR2VvbWV0cnk7XFxuXFxuXFx0Ly8gQ29uZUJ1ZmZlckdlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gQ29uZUJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIGhlaWdodCwgcmFkaWFsU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBvcGVuRW5kZWQsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xcblxcblxcdFxcdEN5bGluZGVyQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcywgMCwgcmFkaXVzLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdDb25lQnVmZmVyR2VvbWV0cnknO1xcblxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXG5cXHRcXHRcXHRyYWRpdXM6IHJhZGl1cyxcXG5cXHRcXHRcXHRoZWlnaHQ6IGhlaWdodCxcXG5cXHRcXHRcXHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXFxuXFx0XFx0XFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxcblxcdFxcdFxcdG9wZW5FbmRlZDogb3BlbkVuZGVkLFxcblxcdFxcdFxcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXFxuXFx0XFx0XFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXFxuXFx0XFx0fTtcXG5cXG5cXHR9XFxuXFxuXFx0Q29uZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN5bGluZGVyQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XFxuXFx0Q29uZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbmVCdWZmZXJHZW9tZXRyeTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcXG5cXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xcblxcdCAqIEBhdXRob3IgaHVnaGVzXFxuXFx0ICovXFxuXFxuXFx0Ly8gQ2lyY2xlR2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBDaXJjbGVHZW9tZXRyeSggcmFkaXVzLCBzZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XFxuXFxuXFx0XFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdDaXJjbGVHZW9tZXRyeSc7XFxuXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcblxcdFxcdFxcdHJhZGl1czogcmFkaXVzLFxcblxcdFxcdFxcdHNlZ21lbnRzOiBzZWdtZW50cyxcXG5cXHRcXHRcXHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxcblxcdFxcdFxcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBDaXJjbGVCdWZmZXJHZW9tZXRyeSggcmFkaXVzLCBzZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSApO1xcblxcdFxcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xcblxcblxcdH1cXG5cXG5cXHRDaXJjbGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcXG5cXHRDaXJjbGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDaXJjbGVHZW9tZXRyeTtcXG5cXG5cXHQvLyBDaXJjbGVCdWZmZXJHZW9tZXRyeVxcblxcblxcdGZ1bmN0aW9uIENpcmNsZUJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHNlZ21lbnRzLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcXG5cXG5cXHRcXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ0NpcmNsZUJ1ZmZlckdlb21ldHJ5JztcXG5cXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxuXFx0XFx0XFx0cmFkaXVzOiByYWRpdXMsXFxuXFx0XFx0XFx0c2VnbWVudHM6IHNlZ21lbnRzLFxcblxcdFxcdFxcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXFxuXFx0XFx0XFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRyYWRpdXMgPSByYWRpdXMgfHwgMTtcXG5cXHRcXHRzZWdtZW50cyA9IHNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCggMywgc2VnbWVudHMgKSA6IDg7XFxuXFxuXFx0XFx0dGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xcblxcdFxcdHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSSAqIDI7XFxuXFxuXFx0XFx0Ly8gYnVmZmVyc1xcblxcblxcdFxcdHZhciBpbmRpY2VzID0gW107XFxuXFx0XFx0dmFyIHZlcnRpY2VzID0gW107XFxuXFx0XFx0dmFyIG5vcm1hbHMgPSBbXTtcXG5cXHRcXHR2YXIgdXZzID0gW107XFxuXFxuXFx0XFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xcblxcblxcdFxcdHZhciBpLCBzO1xcblxcdFxcdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdHZhciB1diA9IG5ldyBWZWN0b3IyKCk7XFxuXFxuXFx0XFx0Ly8gY2VudGVyIHBvaW50XFxuXFxuXFx0XFx0dmVydGljZXMucHVzaCggMCwgMCwgMCApO1xcblxcdFxcdG5vcm1hbHMucHVzaCggMCwgMCwgMSApO1xcblxcdFxcdHV2cy5wdXNoKCAwLjUsIDAuNSApO1xcblxcblxcdFxcdGZvciAoIHMgPSAwLCBpID0gMzsgcyA8PSBzZWdtZW50czsgcyArKywgaSArPSAzICkge1xcblxcblxcdFxcdFxcdHZhciBzZWdtZW50ID0gdGhldGFTdGFydCArIHMgLyBzZWdtZW50cyAqIHRoZXRhTGVuZ3RoO1xcblxcblxcdFxcdFxcdC8vIHZlcnRleFxcblxcblxcdFxcdFxcdHZlcnRleC54ID0gcmFkaXVzICogTWF0aC5jb3MoIHNlZ21lbnQgKTtcXG5cXHRcXHRcXHR2ZXJ0ZXgueSA9IHJhZGl1cyAqIE1hdGguc2luKCBzZWdtZW50ICk7XFxuXFxuXFx0XFx0XFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xcblxcblxcdFxcdFxcdC8vIG5vcm1hbFxcblxcblxcdFxcdFxcdG5vcm1hbHMucHVzaCggMCwgMCwgMSApO1xcblxcblxcdFxcdFxcdC8vIHV2c1xcblxcblxcdFxcdFxcdHV2LnggPSAoIHZlcnRpY2VzWyBpIF0gLyByYWRpdXMgKyAxICkgLyAyO1xcblxcdFxcdFxcdHV2LnkgPSAoIHZlcnRpY2VzWyBpICsgMSBdIC8gcmFkaXVzICsgMSApIC8gMjtcXG5cXG5cXHRcXHRcXHR1dnMucHVzaCggdXYueCwgdXYueSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBpbmRpY2VzXFxuXFxuXFx0XFx0Zm9yICggaSA9IDE7IGkgPD0gc2VnbWVudHM7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0aW5kaWNlcy5wdXNoKCBpLCBpICsgMSwgMCApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBidWlsZCBnZW9tZXRyeVxcblxcblxcdFxcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XFxuXFxuXFx0fVxcblxcblxcdENpcmNsZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xcblxcdENpcmNsZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENpcmNsZUJ1ZmZlckdlb21ldHJ5O1xcblxcblxcblxcblxcdHZhciBHZW9tZXRyaWVzID0gT2JqZWN0LmZyZWV6ZSh7XFxuXFx0XFx0V2lyZWZyYW1lR2VvbWV0cnk6IFdpcmVmcmFtZUdlb21ldHJ5LFxcblxcdFxcdFBhcmFtZXRyaWNHZW9tZXRyeTogUGFyYW1ldHJpY0dlb21ldHJ5LFxcblxcdFxcdFBhcmFtZXRyaWNCdWZmZXJHZW9tZXRyeTogUGFyYW1ldHJpY0J1ZmZlckdlb21ldHJ5LFxcblxcdFxcdFRldHJhaGVkcm9uR2VvbWV0cnk6IFRldHJhaGVkcm9uR2VvbWV0cnksXFxuXFx0XFx0VGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeTogVGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeSxcXG5cXHRcXHRPY3RhaGVkcm9uR2VvbWV0cnk6IE9jdGFoZWRyb25HZW9tZXRyeSxcXG5cXHRcXHRPY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnk6IE9jdGFoZWRyb25CdWZmZXJHZW9tZXRyeSxcXG5cXHRcXHRJY29zYWhlZHJvbkdlb21ldHJ5OiBJY29zYWhlZHJvbkdlb21ldHJ5LFxcblxcdFxcdEljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnk6IEljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnksXFxuXFx0XFx0RG9kZWNhaGVkcm9uR2VvbWV0cnk6IERvZGVjYWhlZHJvbkdlb21ldHJ5LFxcblxcdFxcdERvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5OiBEb2RlY2FoZWRyb25CdWZmZXJHZW9tZXRyeSxcXG5cXHRcXHRQb2x5aGVkcm9uR2VvbWV0cnk6IFBvbHloZWRyb25HZW9tZXRyeSxcXG5cXHRcXHRQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnk6IFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeSxcXG5cXHRcXHRUdWJlR2VvbWV0cnk6IFR1YmVHZW9tZXRyeSxcXG5cXHRcXHRUdWJlQnVmZmVyR2VvbWV0cnk6IFR1YmVCdWZmZXJHZW9tZXRyeSxcXG5cXHRcXHRUb3J1c0tub3RHZW9tZXRyeTogVG9ydXNLbm90R2VvbWV0cnksXFxuXFx0XFx0VG9ydXNLbm90QnVmZmVyR2VvbWV0cnk6IFRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5LFxcblxcdFxcdFRvcnVzR2VvbWV0cnk6IFRvcnVzR2VvbWV0cnksXFxuXFx0XFx0VG9ydXNCdWZmZXJHZW9tZXRyeTogVG9ydXNCdWZmZXJHZW9tZXRyeSxcXG5cXHRcXHRUZXh0R2VvbWV0cnk6IFRleHRHZW9tZXRyeSxcXG5cXHRcXHRUZXh0QnVmZmVyR2VvbWV0cnk6IFRleHRCdWZmZXJHZW9tZXRyeSxcXG5cXHRcXHRTcGhlcmVHZW9tZXRyeTogU3BoZXJlR2VvbWV0cnksXFxuXFx0XFx0U3BoZXJlQnVmZmVyR2VvbWV0cnk6IFNwaGVyZUJ1ZmZlckdlb21ldHJ5LFxcblxcdFxcdFJpbmdHZW9tZXRyeTogUmluZ0dlb21ldHJ5LFxcblxcdFxcdFJpbmdCdWZmZXJHZW9tZXRyeTogUmluZ0J1ZmZlckdlb21ldHJ5LFxcblxcdFxcdFBsYW5lR2VvbWV0cnk6IFBsYW5lR2VvbWV0cnksXFxuXFx0XFx0UGxhbmVCdWZmZXJHZW9tZXRyeTogUGxhbmVCdWZmZXJHZW9tZXRyeSxcXG5cXHRcXHRMYXRoZUdlb21ldHJ5OiBMYXRoZUdlb21ldHJ5LFxcblxcdFxcdExhdGhlQnVmZmVyR2VvbWV0cnk6IExhdGhlQnVmZmVyR2VvbWV0cnksXFxuXFx0XFx0U2hhcGVHZW9tZXRyeTogU2hhcGVHZW9tZXRyeSxcXG5cXHRcXHRTaGFwZUJ1ZmZlckdlb21ldHJ5OiBTaGFwZUJ1ZmZlckdlb21ldHJ5LFxcblxcdFxcdEV4dHJ1ZGVHZW9tZXRyeTogRXh0cnVkZUdlb21ldHJ5LFxcblxcdFxcdEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeTogRXh0cnVkZUJ1ZmZlckdlb21ldHJ5LFxcblxcdFxcdEVkZ2VzR2VvbWV0cnk6IEVkZ2VzR2VvbWV0cnksXFxuXFx0XFx0Q29uZUdlb21ldHJ5OiBDb25lR2VvbWV0cnksXFxuXFx0XFx0Q29uZUJ1ZmZlckdlb21ldHJ5OiBDb25lQnVmZmVyR2VvbWV0cnksXFxuXFx0XFx0Q3lsaW5kZXJHZW9tZXRyeTogQ3lsaW5kZXJHZW9tZXRyeSxcXG5cXHRcXHRDeWxpbmRlckJ1ZmZlckdlb21ldHJ5OiBDeWxpbmRlckJ1ZmZlckdlb21ldHJ5LFxcblxcdFxcdENpcmNsZUdlb21ldHJ5OiBDaXJjbGVHZW9tZXRyeSxcXG5cXHRcXHRDaXJjbGVCdWZmZXJHZW9tZXRyeTogQ2lyY2xlQnVmZmVyR2VvbWV0cnksXFxuXFx0XFx0Qm94R2VvbWV0cnk6IEJveEdlb21ldHJ5LFxcblxcdFxcdEJveEJ1ZmZlckdlb21ldHJ5OiBCb3hCdWZmZXJHZW9tZXRyeVxcblxcdH0pO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICpcXG5cXHQgKiBwYXJhbWV0ZXJzID0ge1xcblxcdCAqICBjb2xvcjogPFRIUkVFLkNvbG9yPixcXG5cXHQgKiAgb3BhY2l0eTogPGZsb2F0PlxcblxcdCAqIH1cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBTaGFkb3dNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcXG5cXG5cXHRcXHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1NoYWRvd01hdGVyaWFsJztcXG5cXG5cXHRcXHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweDAwMDAwMCApO1xcblxcdFxcdHRoaXMub3BhY2l0eSA9IDEuMDtcXG5cXG5cXHRcXHR0aGlzLmxpZ2h0cyA9IHRydWU7XFxuXFx0XFx0dGhpcy50cmFuc3BhcmVudCA9IHRydWU7XFxuXFxuXFx0XFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcXG5cXG5cXHR9XFxuXFxuXFx0U2hhZG93TWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XFxuXFx0U2hhZG93TWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2hhZG93TWF0ZXJpYWw7XFxuXFxuXFx0U2hhZG93TWF0ZXJpYWwucHJvdG90eXBlLmlzU2hhZG93TWF0ZXJpYWwgPSB0cnVlO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gUmF3U2hhZGVyTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XFxuXFxuXFx0XFx0U2hhZGVyTWF0ZXJpYWwuY2FsbCggdGhpcywgcGFyYW1ldGVycyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdSYXdTaGFkZXJNYXRlcmlhbCc7XFxuXFxuXFx0fVxcblxcblxcdFJhd1NoYWRlck1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNoYWRlck1hdGVyaWFsLnByb3RvdHlwZSApO1xcblxcdFJhd1NoYWRlck1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJhd1NoYWRlck1hdGVyaWFsO1xcblxcblxcdFJhd1NoYWRlck1hdGVyaWFsLnByb3RvdHlwZS5pc1Jhd1NoYWRlck1hdGVyaWFsID0gdHJ1ZTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcXG5cXHQgKlxcblxcdCAqIHBhcmFtZXRlcnMgPSB7XFxuXFx0ICogIGNvbG9yOiA8aGV4PixcXG5cXHQgKiAgcm91Z2huZXNzOiA8ZmxvYXQ+LFxcblxcdCAqICBtZXRhbG5lc3M6IDxmbG9hdD4sXFxuXFx0ICogIG9wYWNpdHk6IDxmbG9hdD4sXFxuXFx0ICpcXG5cXHQgKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqXFxuXFx0ICogIGxpZ2h0TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqICBsaWdodE1hcEludGVuc2l0eTogPGZsb2F0PlxcblxcdCAqXFxuXFx0ICogIGFvTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqICBhb01hcEludGVuc2l0eTogPGZsb2F0PlxcblxcdCAqXFxuXFx0ICogIGVtaXNzaXZlOiA8aGV4PixcXG5cXHQgKiAgZW1pc3NpdmVJbnRlbnNpdHk6IDxmbG9hdD5cXG5cXHQgKiAgZW1pc3NpdmVNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxuXFx0ICpcXG5cXHQgKiAgYnVtcE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXG5cXHQgKiAgYnVtcFNjYWxlOiA8ZmxvYXQ+LFxcblxcdCAqXFxuXFx0ICogIG5vcm1hbE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXG5cXHQgKiAgbm9ybWFsU2NhbGU6IDxWZWN0b3IyPixcXG5cXHQgKlxcblxcdCAqICBkaXNwbGFjZW1lbnRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxuXFx0ICogIGRpc3BsYWNlbWVudFNjYWxlOiA8ZmxvYXQ+LFxcblxcdCAqICBkaXNwbGFjZW1lbnRCaWFzOiA8ZmxvYXQ+LFxcblxcdCAqXFxuXFx0ICogIHJvdWdobmVzc01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXG5cXHQgKlxcblxcdCAqICBtZXRhbG5lc3NNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxuXFx0ICpcXG5cXHQgKiAgYWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxuXFx0ICpcXG5cXHQgKiAgZW52TWFwOiBuZXcgVEhSRUUuQ3ViZVRleHR1cmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxcblxcdCAqICBlbnZNYXBJbnRlbnNpdHk6IDxmbG9hdD5cXG5cXHQgKlxcblxcdCAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXFxuXFx0ICpcXG5cXHQgKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXFxuXFx0ICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcXG5cXHQgKlxcblxcdCAqICBza2lubmluZzogPGJvb2w+LFxcblxcdCAqICBtb3JwaFRhcmdldHM6IDxib29sPixcXG5cXHQgKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD5cXG5cXHQgKiB9XFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gTWVzaFN0YW5kYXJkTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XFxuXFxuXFx0XFx0TWF0ZXJpYWwuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMuZGVmaW5lcyA9IHsgJ1NUQU5EQVJEJzogJycgfTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnTWVzaFN0YW5kYXJkTWF0ZXJpYWwnO1xcblxcblxcdFxcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGRpZmZ1c2VcXG5cXHRcXHR0aGlzLnJvdWdobmVzcyA9IDAuNTtcXG5cXHRcXHR0aGlzLm1ldGFsbmVzcyA9IDAuNTtcXG5cXG5cXHRcXHR0aGlzLm1hcCA9IG51bGw7XFxuXFxuXFx0XFx0dGhpcy5saWdodE1hcCA9IG51bGw7XFxuXFx0XFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcXG5cXG5cXHRcXHR0aGlzLmFvTWFwID0gbnVsbDtcXG5cXHRcXHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gMS4wO1xcblxcblxcdFxcdHRoaXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoIDB4MDAwMDAwICk7XFxuXFx0XFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IDEuMDtcXG5cXHRcXHR0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcXG5cXG5cXHRcXHR0aGlzLmJ1bXBNYXAgPSBudWxsO1xcblxcdFxcdHRoaXMuYnVtcFNjYWxlID0gMTtcXG5cXG5cXHRcXHR0aGlzLm5vcm1hbE1hcCA9IG51bGw7XFxuXFx0XFx0dGhpcy5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCAxLCAxICk7XFxuXFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XFxuXFxuXFx0XFx0dGhpcy5yb3VnaG5lc3NNYXAgPSBudWxsO1xcblxcblxcdFxcdHRoaXMubWV0YWxuZXNzTWFwID0gbnVsbDtcXG5cXG5cXHRcXHR0aGlzLmFscGhhTWFwID0gbnVsbDtcXG5cXG5cXHRcXHR0aGlzLmVudk1hcCA9IG51bGw7XFxuXFx0XFx0dGhpcy5lbnZNYXBJbnRlbnNpdHkgPSAxLjA7XFxuXFxuXFx0XFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xcblxcblxcdFxcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XFxuXFxuXFx0XFx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xcblxcdFxcdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XFxuXFx0XFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTtcXG5cXG5cXHRcXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xcblxcblxcdH1cXG5cXG5cXHRNZXNoU3RhbmRhcmRNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXRlcmlhbC5wcm90b3R5cGUgKTtcXG5cXHRNZXNoU3RhbmRhcmRNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNZXNoU3RhbmRhcmRNYXRlcmlhbDtcXG5cXG5cXHRNZXNoU3RhbmRhcmRNYXRlcmlhbC5wcm90b3R5cGUuaXNNZXNoU3RhbmRhcmRNYXRlcmlhbCA9IHRydWU7XFxuXFxuXFx0TWVzaFN0YW5kYXJkTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXG5cXG5cXHRcXHR0aGlzLmRlZmluZXMgPSB7ICdTVEFOREFSRCc6ICcnIH07XFxuXFxuXFx0XFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcXG5cXHRcXHR0aGlzLnJvdWdobmVzcyA9IHNvdXJjZS5yb3VnaG5lc3M7XFxuXFx0XFx0dGhpcy5tZXRhbG5lc3MgPSBzb3VyY2UubWV0YWxuZXNzO1xcblxcblxcdFxcdHRoaXMubWFwID0gc291cmNlLm1hcDtcXG5cXG5cXHRcXHR0aGlzLmxpZ2h0TWFwID0gc291cmNlLmxpZ2h0TWFwO1xcblxcdFxcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSBzb3VyY2UubGlnaHRNYXBJbnRlbnNpdHk7XFxuXFxuXFx0XFx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcXG5cXHRcXHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xcblxcblxcdFxcdHRoaXMuZW1pc3NpdmUuY29weSggc291cmNlLmVtaXNzaXZlICk7XFxuXFx0XFx0dGhpcy5lbWlzc2l2ZU1hcCA9IHNvdXJjZS5lbWlzc2l2ZU1hcDtcXG5cXHRcXHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gc291cmNlLmVtaXNzaXZlSW50ZW5zaXR5O1xcblxcblxcdFxcdHRoaXMuYnVtcE1hcCA9IHNvdXJjZS5idW1wTWFwO1xcblxcdFxcdHRoaXMuYnVtcFNjYWxlID0gc291cmNlLmJ1bXBTY2FsZTtcXG5cXG5cXHRcXHR0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XFxuXFx0XFx0dGhpcy5ub3JtYWxTY2FsZS5jb3B5KCBzb3VyY2Uubm9ybWFsU2NhbGUgKTtcXG5cXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50QmlhcztcXG5cXG5cXHRcXHR0aGlzLnJvdWdobmVzc01hcCA9IHNvdXJjZS5yb3VnaG5lc3NNYXA7XFxuXFxuXFx0XFx0dGhpcy5tZXRhbG5lc3NNYXAgPSBzb3VyY2UubWV0YWxuZXNzTWFwO1xcblxcblxcdFxcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XFxuXFxuXFx0XFx0dGhpcy5lbnZNYXAgPSBzb3VyY2UuZW52TWFwO1xcblxcdFxcdHRoaXMuZW52TWFwSW50ZW5zaXR5ID0gc291cmNlLmVudk1hcEludGVuc2l0eTtcXG5cXG5cXHRcXHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHNvdXJjZS5yZWZyYWN0aW9uUmF0aW87XFxuXFxuXFx0XFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xcblxcblxcdFxcdHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XFxuXFx0XFx0dGhpcy5tb3JwaFRhcmdldHMgPSBzb3VyY2UubW9ycGhUYXJnZXRzO1xcblxcdFxcdHRoaXMubW9ycGhOb3JtYWxzID0gc291cmNlLm1vcnBoTm9ybWFscztcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxcblxcdCAqXFxuXFx0ICogcGFyYW1ldGVycyA9IHtcXG5cXHQgKiAgcmVmbGVjdGl2aXR5OiA8ZmxvYXQ+XFxuXFx0ICogfVxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIE1lc2hQaHlzaWNhbE1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xcblxcblxcdFxcdE1lc2hTdGFuZGFyZE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLmRlZmluZXMgPSB7ICdQSFlTSUNBTCc6ICcnIH07XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ01lc2hQaHlzaWNhbE1hdGVyaWFsJztcXG5cXG5cXHRcXHR0aGlzLnJlZmxlY3Rpdml0eSA9IDAuNTsgLy8gbWFwcyB0byBGMCA9IDAuMDRcXG5cXG5cXHRcXHR0aGlzLmNsZWFyQ29hdCA9IDAuMDtcXG5cXHRcXHR0aGlzLmNsZWFyQ29hdFJvdWdobmVzcyA9IDAuMDtcXG5cXG5cXHRcXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xcblxcblxcdH1cXG5cXG5cXHRNZXNoUGh5c2ljYWxNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNZXNoU3RhbmRhcmRNYXRlcmlhbC5wcm90b3R5cGUgKTtcXG5cXHRNZXNoUGh5c2ljYWxNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNZXNoUGh5c2ljYWxNYXRlcmlhbDtcXG5cXG5cXHRNZXNoUGh5c2ljYWxNYXRlcmlhbC5wcm90b3R5cGUuaXNNZXNoUGh5c2ljYWxNYXRlcmlhbCA9IHRydWU7XFxuXFxuXFx0TWVzaFBoeXNpY2FsTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRNZXNoU3RhbmRhcmRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXG5cXG5cXHRcXHR0aGlzLmRlZmluZXMgPSB7ICdQSFlTSUNBTCc6ICcnIH07XFxuXFxuXFx0XFx0dGhpcy5yZWZsZWN0aXZpdHkgPSBzb3VyY2UucmVmbGVjdGl2aXR5O1xcblxcblxcdFxcdHRoaXMuY2xlYXJDb2F0ID0gc291cmNlLmNsZWFyQ29hdDtcXG5cXHRcXHR0aGlzLmNsZWFyQ29hdFJvdWdobmVzcyA9IHNvdXJjZS5jbGVhckNvYXRSb3VnaG5lc3M7XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICpcXG5cXHQgKiBwYXJhbWV0ZXJzID0ge1xcblxcdCAqICBjb2xvcjogPGhleD4sXFxuXFx0ICogIHNwZWN1bGFyOiA8aGV4PixcXG5cXHQgKiAgc2hpbmluZXNzOiA8ZmxvYXQ+LFxcblxcdCAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxcblxcdCAqXFxuXFx0ICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXG5cXHQgKlxcblxcdCAqICBsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXG5cXHQgKiAgbGlnaHRNYXBJbnRlbnNpdHk6IDxmbG9hdD5cXG5cXHQgKlxcblxcdCAqICBhb01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXG5cXHQgKiAgYW9NYXBJbnRlbnNpdHk6IDxmbG9hdD5cXG5cXHQgKlxcblxcdCAqICBlbWlzc2l2ZTogPGhleD4sXFxuXFx0ICogIGVtaXNzaXZlSW50ZW5zaXR5OiA8ZmxvYXQ+XFxuXFx0ICogIGVtaXNzaXZlTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqXFxuXFx0ICogIGJ1bXBNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxuXFx0ICogIGJ1bXBTY2FsZTogPGZsb2F0PixcXG5cXHQgKlxcblxcdCAqICBub3JtYWxNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxuXFx0ICogIG5vcm1hbFNjYWxlOiA8VmVjdG9yMj4sXFxuXFx0ICpcXG5cXHQgKiAgZGlzcGxhY2VtZW50TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqICBkaXNwbGFjZW1lbnRTY2FsZTogPGZsb2F0PixcXG5cXHQgKiAgZGlzcGxhY2VtZW50QmlhczogPGZsb2F0PixcXG5cXHQgKlxcblxcdCAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXG5cXHQgKlxcblxcdCAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXG5cXHQgKlxcblxcdCAqICBlbnZNYXA6IG5ldyBUSFJFRS5UZXh0dXJlQ3ViZSggW3Bvc3gsIG5lZ3gsIHBvc3ksIG5lZ3ksIHBvc3osIG5lZ3pdICksXFxuXFx0ICogIGNvbWJpbmU6IFRIUkVFLk11bHRpcGx5LFxcblxcdCAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXFxuXFx0ICogIHJlZnJhY3Rpb25SYXRpbzogPGZsb2F0PixcXG5cXHQgKlxcblxcdCAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcXG5cXHQgKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxcblxcdCAqXFxuXFx0ICogIHNraW5uaW5nOiA8Ym9vbD4sXFxuXFx0ICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxcblxcdCAqICBtb3JwaE5vcm1hbHM6IDxib29sPlxcblxcdCAqIH1cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBNZXNoUGhvbmdNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcXG5cXG5cXHRcXHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ01lc2hQaG9uZ01hdGVyaWFsJztcXG5cXG5cXHRcXHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCAweGZmZmZmZiApOyAvLyBkaWZmdXNlXFxuXFx0XFx0dGhpcy5zcGVjdWxhciA9IG5ldyBDb2xvciggMHgxMTExMTEgKTtcXG5cXHRcXHR0aGlzLnNoaW5pbmVzcyA9IDMwO1xcblxcblxcdFxcdHRoaXMubWFwID0gbnVsbDtcXG5cXG5cXHRcXHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcXG5cXHRcXHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMS4wO1xcblxcblxcdFxcdHRoaXMuYW9NYXAgPSBudWxsO1xcblxcdFxcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XFxuXFxuXFx0XFx0dGhpcy5lbWlzc2l2ZSA9IG5ldyBDb2xvciggMHgwMDAwMDAgKTtcXG5cXHRcXHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gMS4wO1xcblxcdFxcdHRoaXMuZW1pc3NpdmVNYXAgPSBudWxsO1xcblxcblxcdFxcdHRoaXMuYnVtcE1hcCA9IG51bGw7XFxuXFx0XFx0dGhpcy5idW1wU2NhbGUgPSAxO1xcblxcblxcdFxcdHRoaXMubm9ybWFsTWFwID0gbnVsbDtcXG5cXHRcXHR0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoIDEsIDEgKTtcXG5cXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcXG5cXG5cXHRcXHR0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcXG5cXG5cXHRcXHR0aGlzLmFscGhhTWFwID0gbnVsbDtcXG5cXG5cXHRcXHR0aGlzLmVudk1hcCA9IG51bGw7XFxuXFx0XFx0dGhpcy5jb21iaW5lID0gTXVsdGlwbHlPcGVyYXRpb247XFxuXFx0XFx0dGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xcblxcdFxcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcXG5cXG5cXHRcXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xcblxcblxcdFxcdHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xcblxcdFxcdHRoaXMubW9ycGhOb3JtYWxzID0gZmFsc2U7XFxuXFxuXFx0XFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcXG5cXG5cXHR9XFxuXFxuXFx0TWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XFxuXFx0TWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWVzaFBob25nTWF0ZXJpYWw7XFxuXFxuXFx0TWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaFBob25nTWF0ZXJpYWwgPSB0cnVlO1xcblxcblxcdE1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxuXFxuXFx0XFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxuXFxuXFx0XFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcXG5cXHRcXHR0aGlzLnNwZWN1bGFyLmNvcHkoIHNvdXJjZS5zcGVjdWxhciApO1xcblxcdFxcdHRoaXMuc2hpbmluZXNzID0gc291cmNlLnNoaW5pbmVzcztcXG5cXG5cXHRcXHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XFxuXFxuXFx0XFx0dGhpcy5saWdodE1hcCA9IHNvdXJjZS5saWdodE1hcDtcXG5cXHRcXHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xcblxcblxcdFxcdHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XFxuXFx0XFx0dGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcXG5cXG5cXHRcXHR0aGlzLmVtaXNzaXZlLmNvcHkoIHNvdXJjZS5lbWlzc2l2ZSApO1xcblxcdFxcdHRoaXMuZW1pc3NpdmVNYXAgPSBzb3VyY2UuZW1pc3NpdmVNYXA7XFxuXFx0XFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IHNvdXJjZS5lbWlzc2l2ZUludGVuc2l0eTtcXG5cXG5cXHRcXHR0aGlzLmJ1bXBNYXAgPSBzb3VyY2UuYnVtcE1hcDtcXG5cXHRcXHR0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XFxuXFxuXFx0XFx0dGhpcy5ub3JtYWxNYXAgPSBzb3VyY2Uubm9ybWFsTWFwO1xcblxcdFxcdHRoaXMubm9ybWFsU2NhbGUuY29weSggc291cmNlLm5vcm1hbFNjYWxlICk7XFxuXFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XFxuXFxuXFx0XFx0dGhpcy5zcGVjdWxhck1hcCA9IHNvdXJjZS5zcGVjdWxhck1hcDtcXG5cXG5cXHRcXHR0aGlzLmFscGhhTWFwID0gc291cmNlLmFscGhhTWFwO1xcblxcblxcdFxcdHRoaXMuZW52TWFwID0gc291cmNlLmVudk1hcDtcXG5cXHRcXHR0aGlzLmNvbWJpbmUgPSBzb3VyY2UuY29tYmluZTtcXG5cXHRcXHR0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XFxuXFx0XFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSBzb3VyY2UucmVmcmFjdGlvblJhdGlvO1xcblxcblxcdFxcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gc291cmNlLndpcmVmcmFtZUxpbmVjYXA7XFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9IHNvdXJjZS53aXJlZnJhbWVMaW5lam9pbjtcXG5cXG5cXHRcXHR0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xcblxcdFxcdHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcXG5cXHRcXHR0aGlzLm1vcnBoTm9ybWFscyA9IHNvdXJjZS5tb3JwaE5vcm1hbHM7XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIHRha2FoaXJveCAvIGh0dHA6Ly9naXRodWIuY29tL3Rha2FoaXJveFxcblxcdCAqXFxuXFx0ICogcGFyYW1ldGVycyA9IHtcXG5cXHQgKiAgZ3JhZGllbnRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+IClcXG5cXHQgKiB9XFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gTWVzaFRvb25NYXRlcmlhbCggcGFyYW1ldGVycyApIHtcXG5cXG5cXHRcXHRNZXNoUGhvbmdNYXRlcmlhbC5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy5kZWZpbmVzID0geyAnVE9PTic6ICcnIH07XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ01lc2hUb29uTWF0ZXJpYWwnO1xcblxcblxcdFxcdHRoaXMuZ3JhZGllbnRNYXAgPSBudWxsO1xcblxcblxcdFxcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XFxuXFxuXFx0fVxcblxcblxcdE1lc2hUb29uTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlICk7XFxuXFx0TWVzaFRvb25NYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNZXNoVG9vbk1hdGVyaWFsO1xcblxcblxcdE1lc2hUb29uTWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaFRvb25NYXRlcmlhbCA9IHRydWU7XFxuXFxuXFx0TWVzaFRvb25NYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdE1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcblxcblxcdFxcdHRoaXMuZ3JhZGllbnRNYXAgPSBzb3VyY2UuZ3JhZGllbnRNYXA7XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxcblxcdCAqXFxuXFx0ICogcGFyYW1ldGVycyA9IHtcXG5cXHQgKiAgb3BhY2l0eTogPGZsb2F0PixcXG5cXHQgKlxcblxcdCAqICBidW1wTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqICBidW1wU2NhbGU6IDxmbG9hdD4sXFxuXFx0ICpcXG5cXHQgKiAgbm9ybWFsTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqICBub3JtYWxTY2FsZTogPFZlY3RvcjI+LFxcblxcdCAqXFxuXFx0ICogIGRpc3BsYWNlbWVudE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXG5cXHQgKiAgZGlzcGxhY2VtZW50U2NhbGU6IDxmbG9hdD4sXFxuXFx0ICogIGRpc3BsYWNlbWVudEJpYXM6IDxmbG9hdD4sXFxuXFx0ICpcXG5cXHQgKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXFxuXFx0ICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PlxcblxcdCAqXFxuXFx0ICogIHNraW5uaW5nOiA8Ym9vbD4sXFxuXFx0ICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxcblxcdCAqICBtb3JwaE5vcm1hbHM6IDxib29sPlxcblxcdCAqIH1cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBNZXNoTm9ybWFsTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XFxuXFxuXFx0XFx0TWF0ZXJpYWwuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdNZXNoTm9ybWFsTWF0ZXJpYWwnO1xcblxcblxcdFxcdHRoaXMuYnVtcE1hcCA9IG51bGw7XFxuXFx0XFx0dGhpcy5idW1wU2NhbGUgPSAxO1xcblxcblxcdFxcdHRoaXMubm9ybWFsTWFwID0gbnVsbDtcXG5cXHRcXHR0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoIDEsIDEgKTtcXG5cXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcXG5cXG5cXHRcXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcXG5cXG5cXHRcXHR0aGlzLmZvZyA9IGZhbHNlO1xcblxcdFxcdHRoaXMubGlnaHRzID0gZmFsc2U7XFxuXFxuXFx0XFx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xcblxcdFxcdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XFxuXFx0XFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTtcXG5cXG5cXHRcXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xcblxcblxcdH1cXG5cXG5cXHRNZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XFxuXFx0TWVzaE5vcm1hbE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1lc2hOb3JtYWxNYXRlcmlhbDtcXG5cXG5cXHRNZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaE5vcm1hbE1hdGVyaWFsID0gdHJ1ZTtcXG5cXG5cXHRNZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXG5cXG5cXHRcXHR0aGlzLmJ1bXBNYXAgPSBzb3VyY2UuYnVtcE1hcDtcXG5cXHRcXHR0aGlzLmJ1bXBTY2FsZSA9IHNvdXJjZS5idW1wU2NhbGU7XFxuXFxuXFx0XFx0dGhpcy5ub3JtYWxNYXAgPSBzb3VyY2Uubm9ybWFsTWFwO1xcblxcdFxcdHRoaXMubm9ybWFsU2NhbGUuY29weSggc291cmNlLm5vcm1hbFNjYWxlICk7XFxuXFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XFxuXFxuXFx0XFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcXG5cXG5cXHRcXHR0aGlzLnNraW5uaW5nID0gc291cmNlLnNraW5uaW5nO1xcblxcdFxcdHRoaXMubW9ycGhUYXJnZXRzID0gc291cmNlLm1vcnBoVGFyZ2V0cztcXG5cXHRcXHR0aGlzLm1vcnBoTm9ybWFscyA9IHNvdXJjZS5tb3JwaE5vcm1hbHM7XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICpcXG5cXHQgKiBwYXJhbWV0ZXJzID0ge1xcblxcdCAqICBjb2xvcjogPGhleD4sXFxuXFx0ICogIG9wYWNpdHk6IDxmbG9hdD4sXFxuXFx0ICpcXG5cXHQgKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqXFxuXFx0ICogIGxpZ2h0TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqICBsaWdodE1hcEludGVuc2l0eTogPGZsb2F0PlxcblxcdCAqXFxuXFx0ICogIGFvTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqICBhb01hcEludGVuc2l0eTogPGZsb2F0PlxcblxcdCAqXFxuXFx0ICogIGVtaXNzaXZlOiA8aGV4PixcXG5cXHQgKiAgZW1pc3NpdmVJbnRlbnNpdHk6IDxmbG9hdD5cXG5cXHQgKiAgZW1pc3NpdmVNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxuXFx0ICpcXG5cXHQgKiAgc3BlY3VsYXJNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxuXFx0ICpcXG5cXHQgKiAgYWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxuXFx0ICpcXG5cXHQgKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxcblxcdCAqICBjb21iaW5lOiBUSFJFRS5NdWx0aXBseSxcXG5cXHQgKiAgcmVmbGVjdGl2aXR5OiA8ZmxvYXQ+LFxcblxcdCAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXFxuXFx0ICpcXG5cXHQgKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXFxuXFx0ICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcXG5cXHQgKlxcblxcdCAqICBza2lubmluZzogPGJvb2w+LFxcblxcdCAqICBtb3JwaFRhcmdldHM6IDxib29sPixcXG5cXHQgKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD5cXG5cXHQgKiB9XFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gTWVzaExhbWJlcnRNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcXG5cXG5cXHRcXHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ01lc2hMYW1iZXJ0TWF0ZXJpYWwnO1xcblxcblxcdFxcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGRpZmZ1c2VcXG5cXG5cXHRcXHR0aGlzLm1hcCA9IG51bGw7XFxuXFxuXFx0XFx0dGhpcy5saWdodE1hcCA9IG51bGw7XFxuXFx0XFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcXG5cXG5cXHRcXHR0aGlzLmFvTWFwID0gbnVsbDtcXG5cXHRcXHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gMS4wO1xcblxcblxcdFxcdHRoaXMuZW1pc3NpdmUgPSBuZXcgQ29sb3IoIDB4MDAwMDAwICk7XFxuXFx0XFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IDEuMDtcXG5cXHRcXHR0aGlzLmVtaXNzaXZlTWFwID0gbnVsbDtcXG5cXG5cXHRcXHR0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcXG5cXG5cXHRcXHR0aGlzLmFscGhhTWFwID0gbnVsbDtcXG5cXG5cXHRcXHR0aGlzLmVudk1hcCA9IG51bGw7XFxuXFx0XFx0dGhpcy5jb21iaW5lID0gTXVsdGlwbHlPcGVyYXRpb247XFxuXFx0XFx0dGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xcblxcdFxcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcXG5cXG5cXHRcXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xcblxcblxcdFxcdHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xcblxcdFxcdHRoaXMubW9ycGhOb3JtYWxzID0gZmFsc2U7XFxuXFxuXFx0XFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcXG5cXG5cXHR9XFxuXFxuXFx0TWVzaExhbWJlcnRNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXRlcmlhbC5wcm90b3R5cGUgKTtcXG5cXHRNZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1lc2hMYW1iZXJ0TWF0ZXJpYWw7XFxuXFxuXFx0TWVzaExhbWJlcnRNYXRlcmlhbC5wcm90b3R5cGUuaXNNZXNoTGFtYmVydE1hdGVyaWFsID0gdHJ1ZTtcXG5cXG5cXHRNZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxuXFxuXFx0XFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxuXFxuXFx0XFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcXG5cXG5cXHRcXHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XFxuXFxuXFx0XFx0dGhpcy5saWdodE1hcCA9IHNvdXJjZS5saWdodE1hcDtcXG5cXHRcXHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xcblxcblxcdFxcdHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XFxuXFx0XFx0dGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcXG5cXG5cXHRcXHR0aGlzLmVtaXNzaXZlLmNvcHkoIHNvdXJjZS5lbWlzc2l2ZSApO1xcblxcdFxcdHRoaXMuZW1pc3NpdmVNYXAgPSBzb3VyY2UuZW1pc3NpdmVNYXA7XFxuXFx0XFx0dGhpcy5lbWlzc2l2ZUludGVuc2l0eSA9IHNvdXJjZS5lbWlzc2l2ZUludGVuc2l0eTtcXG5cXG5cXHRcXHR0aGlzLnNwZWN1bGFyTWFwID0gc291cmNlLnNwZWN1bGFyTWFwO1xcblxcblxcdFxcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XFxuXFxuXFx0XFx0dGhpcy5lbnZNYXAgPSBzb3VyY2UuZW52TWFwO1xcblxcdFxcdHRoaXMuY29tYmluZSA9IHNvdXJjZS5jb21iaW5lO1xcblxcdFxcdHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcXG5cXHRcXHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHNvdXJjZS5yZWZyYWN0aW9uUmF0aW87XFxuXFxuXFx0XFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xcblxcblxcdFxcdHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XFxuXFx0XFx0dGhpcy5tb3JwaFRhcmdldHMgPSBzb3VyY2UubW9ycGhUYXJnZXRzO1xcblxcdFxcdHRoaXMubW9ycGhOb3JtYWxzID0gc291cmNlLm1vcnBoTm9ybWFscztcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICpcXG5cXHQgKiBwYXJhbWV0ZXJzID0ge1xcblxcdCAqICBjb2xvcjogPGhleD4sXFxuXFx0ICogIG9wYWNpdHk6IDxmbG9hdD4sXFxuXFx0ICpcXG5cXHQgKiAgbGluZXdpZHRoOiA8ZmxvYXQ+LFxcblxcdCAqXFxuXFx0ICogIHNjYWxlOiA8ZmxvYXQ+LFxcblxcdCAqICBkYXNoU2l6ZTogPGZsb2F0PixcXG5cXHQgKiAgZ2FwU2l6ZTogPGZsb2F0PlxcblxcdCAqIH1cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBMaW5lRGFzaGVkTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XFxuXFxuXFx0XFx0TGluZUJhc2ljTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdMaW5lRGFzaGVkTWF0ZXJpYWwnO1xcblxcblxcdFxcdHRoaXMuc2NhbGUgPSAxO1xcblxcdFxcdHRoaXMuZGFzaFNpemUgPSAzO1xcblxcdFxcdHRoaXMuZ2FwU2l6ZSA9IDE7XFxuXFxuXFx0XFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcXG5cXG5cXHR9XFxuXFxuXFx0TGluZURhc2hlZE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZSApO1xcblxcdExpbmVEYXNoZWRNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaW5lRGFzaGVkTWF0ZXJpYWw7XFxuXFxuXFx0TGluZURhc2hlZE1hdGVyaWFsLnByb3RvdHlwZS5pc0xpbmVEYXNoZWRNYXRlcmlhbCA9IHRydWU7XFxuXFxuXFx0TGluZURhc2hlZE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxuXFxuXFx0XFx0TGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxuXFxuXFx0XFx0dGhpcy5zY2FsZSA9IHNvdXJjZS5zY2FsZTtcXG5cXHRcXHR0aGlzLmRhc2hTaXplID0gc291cmNlLmRhc2hTaXplO1xcblxcdFxcdHRoaXMuZ2FwU2l6ZSA9IHNvdXJjZS5nYXBTaXplO1xcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdH07XFxuXFxuXFxuXFxuXFx0dmFyIE1hdGVyaWFscyA9IE9iamVjdC5mcmVlemUoe1xcblxcdFxcdFNoYWRvd01hdGVyaWFsOiBTaGFkb3dNYXRlcmlhbCxcXG5cXHRcXHRTcHJpdGVNYXRlcmlhbDogU3ByaXRlTWF0ZXJpYWwsXFxuXFx0XFx0UmF3U2hhZGVyTWF0ZXJpYWw6IFJhd1NoYWRlck1hdGVyaWFsLFxcblxcdFxcdFNoYWRlck1hdGVyaWFsOiBTaGFkZXJNYXRlcmlhbCxcXG5cXHRcXHRQb2ludHNNYXRlcmlhbDogUG9pbnRzTWF0ZXJpYWwsXFxuXFx0XFx0TWVzaFBoeXNpY2FsTWF0ZXJpYWw6IE1lc2hQaHlzaWNhbE1hdGVyaWFsLFxcblxcdFxcdE1lc2hTdGFuZGFyZE1hdGVyaWFsOiBNZXNoU3RhbmRhcmRNYXRlcmlhbCxcXG5cXHRcXHRNZXNoUGhvbmdNYXRlcmlhbDogTWVzaFBob25nTWF0ZXJpYWwsXFxuXFx0XFx0TWVzaFRvb25NYXRlcmlhbDogTWVzaFRvb25NYXRlcmlhbCxcXG5cXHRcXHRNZXNoTm9ybWFsTWF0ZXJpYWw6IE1lc2hOb3JtYWxNYXRlcmlhbCxcXG5cXHRcXHRNZXNoTGFtYmVydE1hdGVyaWFsOiBNZXNoTGFtYmVydE1hdGVyaWFsLFxcblxcdFxcdE1lc2hEZXB0aE1hdGVyaWFsOiBNZXNoRGVwdGhNYXRlcmlhbCxcXG5cXHRcXHRNZXNoRGlzdGFuY2VNYXRlcmlhbDogTWVzaERpc3RhbmNlTWF0ZXJpYWwsXFxuXFx0XFx0TWVzaEJhc2ljTWF0ZXJpYWw6IE1lc2hCYXNpY01hdGVyaWFsLFxcblxcdFxcdExpbmVEYXNoZWRNYXRlcmlhbDogTGluZURhc2hlZE1hdGVyaWFsLFxcblxcdFxcdExpbmVCYXNpY01hdGVyaWFsOiBMaW5lQmFzaWNNYXRlcmlhbCxcXG5cXHRcXHRNYXRlcmlhbDogTWF0ZXJpYWxcXG5cXHR9KTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdHZhciBDYWNoZSA9IHtcXG5cXG5cXHRcXHRlbmFibGVkOiBmYWxzZSxcXG5cXG5cXHRcXHRmaWxlczoge30sXFxuXFxuXFx0XFx0YWRkOiBmdW5jdGlvbiAoIGtleSwgZmlsZSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XFxuXFxuXFx0XFx0XFx0Ly8gY29uc29sZS5sb2coICdUSFJFRS5DYWNoZScsICdBZGRpbmcga2V5OicsIGtleSApO1xcblxcblxcdFxcdFxcdHRoaXMuZmlsZXNbIGtleSBdID0gZmlsZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldDogZnVuY3Rpb24gKCBrZXkgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xcblxcblxcdFxcdFxcdC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuQ2FjaGUnLCAnQ2hlY2tpbmcga2V5OicsIGtleSApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmZpbGVzWyBrZXkgXTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHJlbW92ZTogZnVuY3Rpb24gKCBrZXkgKSB7XFxuXFxuXFx0XFx0XFx0ZGVsZXRlIHRoaXMuZmlsZXNbIGtleSBdO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xlYXI6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmZpbGVzID0ge307XFxuXFxuXFx0XFx0fVxcblxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBMb2FkaW5nTWFuYWdlciggb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xcblxcblxcdFxcdHZhciBzY29wZSA9IHRoaXM7XFxuXFxuXFx0XFx0dmFyIGlzTG9hZGluZyA9IGZhbHNlO1xcblxcdFxcdHZhciBpdGVtc0xvYWRlZCA9IDA7XFxuXFx0XFx0dmFyIGl0ZW1zVG90YWwgPSAwO1xcblxcdFxcdHZhciB1cmxNb2RpZmllciA9IHVuZGVmaW5lZDtcXG5cXG5cXHRcXHR0aGlzLm9uU3RhcnQgPSB1bmRlZmluZWQ7XFxuXFx0XFx0dGhpcy5vbkxvYWQgPSBvbkxvYWQ7XFxuXFx0XFx0dGhpcy5vblByb2dyZXNzID0gb25Qcm9ncmVzcztcXG5cXHRcXHR0aGlzLm9uRXJyb3IgPSBvbkVycm9yO1xcblxcblxcdFxcdHRoaXMuaXRlbVN0YXJ0ID0gZnVuY3Rpb24gKCB1cmwgKSB7XFxuXFxuXFx0XFx0XFx0aXRlbXNUb3RhbCArKztcXG5cXG5cXHRcXHRcXHRpZiAoIGlzTG9hZGluZyA9PT0gZmFsc2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBzY29wZS5vblN0YXJ0ICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0c2NvcGUub25TdGFydCggdXJsLCBpdGVtc0xvYWRlZCwgaXRlbXNUb3RhbCApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aXNMb2FkaW5nID0gdHJ1ZTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuaXRlbUVuZCA9IGZ1bmN0aW9uICggdXJsICkge1xcblxcblxcdFxcdFxcdGl0ZW1zTG9hZGVkICsrO1xcblxcblxcdFxcdFxcdGlmICggc2NvcGUub25Qcm9ncmVzcyAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdHNjb3BlLm9uUHJvZ3Jlc3MoIHVybCwgaXRlbXNMb2FkZWQsIGl0ZW1zVG90YWwgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBpdGVtc0xvYWRlZCA9PT0gaXRlbXNUb3RhbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRpc0xvYWRpbmcgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHNjb3BlLm9uTG9hZCAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHNjb3BlLm9uTG9hZCgpO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGlzLml0ZW1FcnJvciA9IGZ1bmN0aW9uICggdXJsICkge1xcblxcblxcdFxcdFxcdGlmICggc2NvcGUub25FcnJvciAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdHNjb3BlLm9uRXJyb3IoIHVybCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMucmVzb2x2ZVVSTCA9IGZ1bmN0aW9uICggdXJsICkge1xcblxcblxcdFxcdFxcdGlmICggdXJsTW9kaWZpZXIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHVybE1vZGlmaWVyKCB1cmwgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHVybDtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuc2V0VVJMTW9kaWZpZXIgPSBmdW5jdGlvbiAoIHRyYW5zZm9ybSApIHtcXG5cXG5cXHRcXHRcXHR1cmxNb2RpZmllciA9IHRyYW5zZm9ybTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9O1xcblxcblxcdH1cXG5cXG5cXHR2YXIgRGVmYXVsdExvYWRpbmdNYW5hZ2VyID0gbmV3IExvYWRpbmdNYW5hZ2VyKCk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHR2YXIgbG9hZGluZyA9IHt9O1xcblxcblxcdGZ1bmN0aW9uIEZpbGVMb2FkZXIoIG1hbmFnZXIgKSB7XFxuXFxuXFx0XFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5hc3NpZ24oIEZpbGVMb2FkZXIucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHVybCA9PT0gdW5kZWZpbmVkICkgdXJsID0gJyc7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnBhdGggIT09IHVuZGVmaW5lZCApIHVybCA9IHRoaXMucGF0aCArIHVybDtcXG5cXG5cXHRcXHRcXHR1cmwgPSB0aGlzLm1hbmFnZXIucmVzb2x2ZVVSTCggdXJsICk7XFxuXFxuXFx0XFx0XFx0dmFyIHNjb3BlID0gdGhpcztcXG5cXG5cXHRcXHRcXHR2YXIgY2FjaGVkID0gQ2FjaGUuZ2V0KCB1cmwgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGNhY2hlZCAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcXG5cXG5cXHRcXHRcXHRcXHRzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIGNhY2hlZCApO1xcblxcblxcdFxcdFxcdFxcdFxcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XFxuXFxuXFx0XFx0XFx0XFx0fSwgMCApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBjYWNoZWQ7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIENoZWNrIGlmIHJlcXVlc3QgaXMgZHVwbGljYXRlXFxuXFxuXFx0XFx0XFx0aWYgKCBsb2FkaW5nWyB1cmwgXSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGxvYWRpbmdbIHVybCBdLnB1c2goIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRvbkxvYWQ6IG9uTG9hZCxcXG5cXHRcXHRcXHRcXHRcXHRvblByb2dyZXNzOiBvblByb2dyZXNzLFxcblxcdFxcdFxcdFxcdFxcdG9uRXJyb3I6IG9uRXJyb3JcXG5cXG5cXHRcXHRcXHRcXHR9ICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBDaGVjayBmb3IgZGF0YTogVVJJXFxuXFx0XFx0XFx0dmFyIGRhdGFVcmlSZWdleCA9IC9eZGF0YTooLio/KSg7YmFzZTY0KT8sKC4qKSQvO1xcblxcdFxcdFxcdHZhciBkYXRhVXJpUmVnZXhSZXN1bHQgPSB1cmwubWF0Y2goIGRhdGFVcmlSZWdleCApO1xcblxcblxcdFxcdFxcdC8vIFNhZmFyaSBjYW4gbm90IGhhbmRsZSBEYXRhIFVSSXMgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdCBzbyBwcm9jZXNzIG1hbnVhbGx5XFxuXFx0XFx0XFx0aWYgKCBkYXRhVXJpUmVnZXhSZXN1bHQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG1pbWVUeXBlID0gZGF0YVVyaVJlZ2V4UmVzdWx0WyAxIF07XFxuXFx0XFx0XFx0XFx0dmFyIGlzQmFzZTY0ID0gISEgZGF0YVVyaVJlZ2V4UmVzdWx0WyAyIF07XFxuXFx0XFx0XFx0XFx0dmFyIGRhdGEgPSBkYXRhVXJpUmVnZXhSZXN1bHRbIDMgXTtcXG5cXG5cXHRcXHRcXHRcXHRkYXRhID0gd2luZG93LmRlY29kZVVSSUNvbXBvbmVudCggZGF0YSApO1xcblxcblxcdFxcdFxcdFxcdGlmICggaXNCYXNlNjQgKSBkYXRhID0gd2luZG93LmF0b2IoIGRhdGEgKTtcXG5cXG5cXHRcXHRcXHRcXHR0cnkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciByZXNwb25zZTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgcmVzcG9uc2VUeXBlID0gKCB0aGlzLnJlc3BvbnNlVHlwZSB8fCAnJyApLnRvTG93ZXJDYXNlKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0c3dpdGNoICggcmVzcG9uc2VUeXBlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ2FycmF5YnVmZmVyJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdibG9iJzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KCBkYXRhLmxlbmd0aCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHZpZXdbIGkgXSA9IGRhdGEuY2hhckNvZGVBdCggaSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHJlc3BvbnNlVHlwZSA9PT0gJ2Jsb2InICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc3BvbnNlID0gbmV3IEJsb2IoIFsgdmlldy5idWZmZXIgXSwgeyB0eXBlOiBtaW1lVHlwZSB9ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXNwb25zZSA9IHZpZXcuYnVmZmVyO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdkb2N1bWVudCc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXNwb25zZSA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIG1pbWVUeXBlICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnanNvbic6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzcG9uc2UgPSBKU09OLnBhcnNlKCBkYXRhICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGVmYXVsdDogLy8gJ3RleHQnIG9yIG90aGVyXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzcG9uc2UgPSBkYXRhO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBXYWl0IGZvciBuZXh0IGJyb3dzZXIgdGljayBsaWtlIHN0YW5kYXJkIFhNTEh0dHBSZXF1ZXN0IGV2ZW50IGRpc3BhdGNoaW5nIGRvZXNcXG5cXHRcXHRcXHRcXHRcXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggb25Mb2FkICkgb25Mb2FkKCByZXNwb25zZSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSwgMCApO1xcblxcblxcdFxcdFxcdFxcdH0gY2F0Y2ggKCBlcnJvciApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBXYWl0IGZvciBuZXh0IGJyb3dzZXIgdGljayBsaWtlIHN0YW5kYXJkIFhNTEh0dHBSZXF1ZXN0IGV2ZW50IGRpc3BhdGNoaW5nIGRvZXNcXG5cXHRcXHRcXHRcXHRcXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggb25FcnJvciApIG9uRXJyb3IoIGVycm9yICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSwgMCApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdC8vIEluaXRpYWxpc2UgYXJyYXkgZm9yIGR1cGxpY2F0ZSByZXF1ZXN0c1xcblxcblxcdFxcdFxcdFxcdGxvYWRpbmdbIHVybCBdID0gW107XFxuXFxuXFx0XFx0XFx0XFx0bG9hZGluZ1sgdXJsIF0ucHVzaCgge1xcblxcblxcdFxcdFxcdFxcdFxcdG9uTG9hZDogb25Mb2FkLFxcblxcdFxcdFxcdFxcdFxcdG9uUHJvZ3Jlc3M6IG9uUHJvZ3Jlc3MsXFxuXFx0XFx0XFx0XFx0XFx0b25FcnJvcjogb25FcnJvclxcblxcblxcdFxcdFxcdFxcdH0gKTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xcblxcblxcdFxcdFxcdFxcdHJlcXVlc3Qub3BlbiggJ0dFVCcsIHVybCwgdHJ1ZSApO1xcblxcblxcdFxcdFxcdFxcdHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciByZXNwb25zZSA9IHRoaXMucmVzcG9uc2U7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Q2FjaGUuYWRkKCB1cmwsIHJlc3BvbnNlICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGNhbGxiYWNrcyA9IGxvYWRpbmdbIHVybCBdO1xcblxcblxcdFxcdFxcdFxcdFxcdGRlbGV0ZSBsb2FkaW5nWyB1cmwgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHRoaXMuc3RhdHVzID09PSAyMDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgY2FsbGJhY2sgPSBjYWxsYmFja3NbIGkgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGNhbGxiYWNrLm9uTG9hZCApIGNhbGxiYWNrLm9uTG9hZCggcmVzcG9uc2UgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCB0aGlzLnN0YXR1cyA9PT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBTb21lIGJyb3dzZXJzIHJldHVybiBIVFRQIFN0YXR1cyAwIHdoZW4gdXNpbmcgbm9uLWh0dHAgcHJvdG9jb2xcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBlLmcuICdmaWxlOi8vJyBvciAnZGF0YTovLycuIEhhbmRsZSBhcyBzdWNjZXNzLlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkZpbGVMb2FkZXI6IEhUVFAgU3RhdHVzIDAgcmVjZWl2ZWQuJyApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGNhbGxiYWNrID0gY2FsbGJhY2tzWyBpIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBjYWxsYmFjay5vbkxvYWQgKSBjYWxsYmFjay5vbkxvYWQoIHJlc3BvbnNlICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBjYWxsYmFjayA9IGNhbGxiYWNrc1sgaSBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggY2FsbGJhY2sub25FcnJvciApIGNhbGxiYWNrLm9uRXJyb3IoIGV2ZW50ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9LCBmYWxzZSApO1xcblxcblxcdFxcdFxcdFxcdHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lciggJ3Byb2dyZXNzJywgZnVuY3Rpb24gKCBldmVudCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgY2FsbGJhY2tzID0gbG9hZGluZ1sgdXJsIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgY2FsbGJhY2sgPSBjYWxsYmFja3NbIGkgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGNhbGxiYWNrLm9uUHJvZ3Jlc3MgKSBjYWxsYmFjay5vblByb2dyZXNzKCBldmVudCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9LCBmYWxzZSApO1xcblxcblxcdFxcdFxcdFxcdHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgZnVuY3Rpb24gKCBldmVudCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgY2FsbGJhY2tzID0gbG9hZGluZ1sgdXJsIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZGVsZXRlIGxvYWRpbmdbIHVybCBdO1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGNhbGxiYWNrID0gY2FsbGJhY2tzWyBpIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBjYWxsYmFjay5vbkVycm9yICkgY2FsbGJhY2sub25FcnJvciggZXZlbnQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcXG5cXHRcXHRcXHRcXHRcXHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XFxuXFxuXFx0XFx0XFx0XFx0fSwgZmFsc2UgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHRoaXMucmVzcG9uc2VUeXBlICE9PSB1bmRlZmluZWQgKSByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IHRoaXMucmVzcG9uc2VUeXBlO1xcblxcdFxcdFxcdFxcdGlmICggdGhpcy53aXRoQ3JlZGVudGlhbHMgIT09IHVuZGVmaW5lZCApIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gdGhpcy53aXRoQ3JlZGVudGlhbHM7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCByZXF1ZXN0Lm92ZXJyaWRlTWltZVR5cGUgKSByZXF1ZXN0Lm92ZXJyaWRlTWltZVR5cGUoIHRoaXMubWltZVR5cGUgIT09IHVuZGVmaW5lZCA/IHRoaXMubWltZVR5cGUgOiAndGV4dC9wbGFpbicgKTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaGVhZGVyIGluIHRoaXMucmVxdWVzdEhlYWRlciApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoIGhlYWRlciwgdGhpcy5yZXF1ZXN0SGVhZGVyWyBoZWFkZXIgXSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXF1ZXN0LnNlbmQoIG51bGwgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xcblxcblxcdFxcdFxcdHJldHVybiByZXF1ZXN0O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0UGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnBhdGggPSB2YWx1ZTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFJlc3BvbnNlVHlwZTogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnJlc3BvbnNlVHlwZSA9IHZhbHVlO1xcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0V2l0aENyZWRlbnRpYWxzOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdHRoaXMud2l0aENyZWRlbnRpYWxzID0gdmFsdWU7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRNaW1lVHlwZTogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm1pbWVUeXBlID0gdmFsdWU7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdHRoaXMucmVxdWVzdEhlYWRlciA9IHZhbHVlO1xcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKlxcblxcdCAqIEFic3RyYWN0IEJhc2UgY2xhc3MgdG8gYmxvY2sgYmFzZWQgdGV4dHVyZXMgbG9hZGVyIChkZHMsIHB2ciwgLi4uKVxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIENvbXByZXNzZWRUZXh0dXJlTG9hZGVyKCBtYW5hZ2VyICkge1xcblxcblxcdFxcdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xcblxcblxcdFxcdC8vIG92ZXJyaWRlIGluIHN1YiBjbGFzc2VzXFxuXFx0XFx0dGhpcy5fcGFyc2VyID0gbnVsbDtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcXG5cXG5cXHRcXHRcXHR2YXIgc2NvcGUgPSB0aGlzO1xcblxcblxcdFxcdFxcdHZhciBpbWFnZXMgPSBbXTtcXG5cXG5cXHRcXHRcXHR2YXIgdGV4dHVyZSA9IG5ldyBDb21wcmVzc2VkVGV4dHVyZSgpO1xcblxcdFxcdFxcdHRleHR1cmUuaW1hZ2UgPSBpbWFnZXM7XFxuXFxuXFx0XFx0XFx0dmFyIGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcXG5cXHRcXHRcXHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XFxuXFx0XFx0XFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xcblxcblxcdFxcdFxcdGZ1bmN0aW9uIGxvYWRUZXh0dXJlKCBpICkge1xcblxcblxcdFxcdFxcdFxcdGxvYWRlci5sb2FkKCB1cmxbIGkgXSwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHRleERhdGFzID0gc2NvcGUuX3BhcnNlciggYnVmZmVyLCB0cnVlICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aW1hZ2VzWyBpIF0gPSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0d2lkdGg6IHRleERhdGFzLndpZHRoLFxcblxcdFxcdFxcdFxcdFxcdFxcdGhlaWdodDogdGV4RGF0YXMuaGVpZ2h0LFxcblxcdFxcdFxcdFxcdFxcdFxcdGZvcm1hdDogdGV4RGF0YXMuZm9ybWF0LFxcblxcdFxcdFxcdFxcdFxcdFxcdG1pcG1hcHM6IHRleERhdGFzLm1pcG1hcHNcXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdFxcdFxcdGxvYWRlZCArPSAxO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggbG9hZGVkID09PSA2ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggdGV4RGF0YXMubWlwbWFwQ291bnQgPT09IDEgKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRleHR1cmUuZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xcblxcdFxcdFxcdFxcdFxcdFxcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBBcnJheS5pc0FycmF5KCB1cmwgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbG9hZGVkID0gMDtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdXJsLmxlbmd0aDsgaSA8IGlsOyArKyBpICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGxvYWRUZXh0dXJlKCBpICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gY29tcHJlc3NlZCBjdWJlbWFwIHRleHR1cmUgc3RvcmVkIGluIGEgc2luZ2xlIEREUyBmaWxlXFxuXFxuXFx0XFx0XFx0XFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHRleERhdGFzID0gc2NvcGUuX3BhcnNlciggYnVmZmVyLCB0cnVlICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0ZXhEYXRhcy5pc0N1YmVtYXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGZhY2VzID0gdGV4RGF0YXMubWlwbWFwcy5sZW5ndGggLyB0ZXhEYXRhcy5taXBtYXBDb3VudDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgZiA9IDA7IGYgPCBmYWNlczsgZiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpbWFnZXNbIGYgXSA9IHsgbWlwbWFwczogW10gfTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0ZXhEYXRhcy5taXBtYXBDb3VudDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpbWFnZXNbIGYgXS5taXBtYXBzLnB1c2goIHRleERhdGFzLm1pcG1hcHNbIGYgKiB0ZXhEYXRhcy5taXBtYXBDb3VudCArIGkgXSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGltYWdlc1sgZiBdLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpbWFnZXNbIGYgXS53aWR0aCA9IHRleERhdGFzLndpZHRoO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGltYWdlc1sgZiBdLmhlaWdodCA9IHRleERhdGFzLmhlaWdodDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGV4dHVyZS5pbWFnZS53aWR0aCA9IHRleERhdGFzLndpZHRoO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRleHR1cmUuaW1hZ2UuaGVpZ2h0ID0gdGV4RGF0YXMuaGVpZ2h0O1xcblxcdFxcdFxcdFxcdFxcdFxcdHRleHR1cmUubWlwbWFwcyA9IHRleERhdGFzLm1pcG1hcHM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGlmICggdGV4RGF0YXMubWlwbWFwQ291bnQgPT09IDEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHRleHR1cmUuZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xcblxcdFxcdFxcdFxcdFxcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlICk7XFxuXFxuXFx0XFx0XFx0XFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGV4dHVyZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5wYXRoID0gdmFsdWU7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIE5pa29zIE0uIC8gaHR0cHM6Ly9naXRodWIuY29tL2ZvbzEyMy9cXG5cXHQgKlxcblxcdCAqIEFic3RyYWN0IEJhc2UgY2xhc3MgdG8gbG9hZCBnZW5lcmljIGJpbmFyeSB0ZXh0dXJlcyBmb3JtYXRzIChyZ2JlLCBoZHIsIC4uLilcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBEYXRhVGV4dHVyZUxvYWRlciggbWFuYWdlciApIHtcXG5cXG5cXHRcXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcXG5cXG5cXHRcXHQvLyBvdmVycmlkZSBpbiBzdWIgY2xhc3Nlc1xcblxcdFxcdHRoaXMuX3BhcnNlciA9IG51bGw7XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5hc3NpZ24oIERhdGFUZXh0dXJlTG9hZGVyLnByb3RvdHlwZSwge1xcblxcblxcdFxcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHNjb3BlID0gdGhpcztcXG5cXG5cXHRcXHRcXHR2YXIgdGV4dHVyZSA9IG5ldyBEYXRhVGV4dHVyZSgpO1xcblxcblxcdFxcdFxcdHZhciBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XFxuXFx0XFx0XFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xcblxcblxcdFxcdFxcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggYnVmZmVyICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB0ZXhEYXRhID0gc2NvcGUuX3BhcnNlciggYnVmZmVyICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCAhIHRleERhdGEgKSByZXR1cm47XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEuaW1hZ2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGV4dHVyZS5pbWFnZSA9IHRleERhdGEuaW1hZ2U7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmRhdGEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGV4dHVyZS5pbWFnZS53aWR0aCA9IHRleERhdGEud2lkdGg7XFxuXFx0XFx0XFx0XFx0XFx0dGV4dHVyZS5pbWFnZS5oZWlnaHQgPSB0ZXhEYXRhLmhlaWdodDtcXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLmltYWdlLmRhdGEgPSB0ZXhEYXRhLmRhdGE7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHRleHR1cmUud3JhcFMgPSB1bmRlZmluZWQgIT09IHRleERhdGEud3JhcFMgPyB0ZXhEYXRhLndyYXBTIDogQ2xhbXBUb0VkZ2VXcmFwcGluZztcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlLndyYXBUID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLndyYXBUID8gdGV4RGF0YS53cmFwVCA6IENsYW1wVG9FZGdlV3JhcHBpbmc7XFxuXFxuXFx0XFx0XFx0XFx0dGV4dHVyZS5tYWdGaWx0ZXIgPSB1bmRlZmluZWQgIT09IHRleERhdGEubWFnRmlsdGVyID8gdGV4RGF0YS5tYWdGaWx0ZXIgOiBMaW5lYXJGaWx0ZXI7XFxuXFx0XFx0XFx0XFx0dGV4dHVyZS5taW5GaWx0ZXIgPSB1bmRlZmluZWQgIT09IHRleERhdGEubWluRmlsdGVyID8gdGV4RGF0YS5taW5GaWx0ZXIgOiBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7XFxuXFxuXFx0XFx0XFx0XFx0dGV4dHVyZS5hbmlzb3Ryb3B5ID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmFuaXNvdHJvcHkgPyB0ZXhEYXRhLmFuaXNvdHJvcHkgOiAxO1xcblxcblxcdFxcdFxcdFxcdGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmZvcm1hdCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGEuZm9ybWF0O1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS50eXBlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRleHR1cmUudHlwZSA9IHRleERhdGEudHlwZTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEubWlwbWFwcyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLm1pcG1hcHMgPSB0ZXhEYXRhLm1pcG1hcHM7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggMSA9PT0gdGV4RGF0YS5taXBtYXBDb3VudCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUsIHRleERhdGEgKTtcXG5cXG5cXHRcXHRcXHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XFxuXFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRleHR1cmU7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEltYWdlTG9hZGVyKCBtYW5hZ2VyICkge1xcblxcblxcdFxcdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBJbWFnZUxvYWRlci5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRjcm9zc09yaWdpbjogJ0Fub255bW91cycsXFxuXFxuXFx0XFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHVybCA9PT0gdW5kZWZpbmVkICkgdXJsID0gJyc7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnBhdGggIT09IHVuZGVmaW5lZCApIHVybCA9IHRoaXMucGF0aCArIHVybDtcXG5cXG5cXHRcXHRcXHR1cmwgPSB0aGlzLm1hbmFnZXIucmVzb2x2ZVVSTCggdXJsICk7XFxuXFxuXFx0XFx0XFx0dmFyIHNjb3BlID0gdGhpcztcXG5cXG5cXHRcXHRcXHR2YXIgY2FjaGVkID0gQ2FjaGUuZ2V0KCB1cmwgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGNhY2hlZCAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcXG5cXG5cXHRcXHRcXHRcXHRzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIGNhY2hlZCApO1xcblxcblxcdFxcdFxcdFxcdFxcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XFxuXFxuXFx0XFx0XFx0XFx0fSwgMCApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBjYWNoZWQ7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCAnaW1nJyApO1xcblxcblxcdFxcdFxcdGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdENhY2hlLmFkZCggdXJsLCB0aGlzICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRoaXMgKTtcXG5cXG5cXHRcXHRcXHRcXHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xcblxcblxcdFxcdFxcdH0sIGZhbHNlICk7XFxuXFxuXFx0XFx0XFx0LypcXG5cXHRcXHRcXHRpbWFnZS5hZGRFdmVudExpc3RlbmVyKCAncHJvZ3Jlc3MnLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggb25Qcm9ncmVzcyApIG9uUHJvZ3Jlc3MoIGV2ZW50ICk7XFxuXFxuXFx0XFx0XFx0fSwgZmFsc2UgKTtcXG5cXHRcXHRcXHQqL1xcblxcblxcdFxcdFxcdGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdlcnJvcicsIGZ1bmN0aW9uICggZXZlbnQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggZXZlbnQgKTtcXG5cXG5cXHRcXHRcXHRcXHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xcblxcdFxcdFxcdFxcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcXG5cXG5cXHRcXHRcXHR9LCBmYWxzZSApO1xcblxcblxcdFxcdFxcdGlmICggdXJsLnN1YnN0ciggMCwgNSApICE9PSAnZGF0YTonICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggdGhpcy5jcm9zc09yaWdpbiAhPT0gdW5kZWZpbmVkICkgaW1hZ2UuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XFxuXFxuXFx0XFx0XFx0aW1hZ2Uuc3JjID0gdXJsO1xcblxcblxcdFxcdFxcdHJldHVybiBpbWFnZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5wYXRoID0gdmFsdWU7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEN1YmVUZXh0dXJlTG9hZGVyKCBtYW5hZ2VyICkge1xcblxcblxcdFxcdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBDdWJlVGV4dHVyZUxvYWRlci5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRjcm9zc09yaWdpbjogJ0Fub255bW91cycsXFxuXFxuXFx0XFx0bG9hZDogZnVuY3Rpb24gKCB1cmxzLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHRleHR1cmUgPSBuZXcgQ3ViZVRleHR1cmUoKTtcXG5cXG5cXHRcXHRcXHR2YXIgbG9hZGVyID0gbmV3IEltYWdlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcXG5cXHRcXHRcXHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcXG5cXHRcXHRcXHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XFxuXFxuXFx0XFx0XFx0dmFyIGxvYWRlZCA9IDA7XFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gbG9hZFRleHR1cmUoIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0bG9hZGVyLmxvYWQoIHVybHNbIGkgXSwgZnVuY3Rpb24gKCBpbWFnZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLmltYWdlc1sgaSBdID0gaW1hZ2U7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bG9hZGVkICsrO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggbG9hZGVkID09PSA2ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH0sIHVuZGVmaW5lZCwgb25FcnJvciApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB1cmxzLmxlbmd0aDsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHRcXHRsb2FkVGV4dHVyZSggaSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGV4dHVyZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5wYXRoID0gdmFsdWU7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFRleHR1cmVMb2FkZXIoIG1hbmFnZXIgKSB7XFxuXFxuXFx0XFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5hc3NpZ24oIFRleHR1cmVMb2FkZXIucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0Y3Jvc3NPcmlnaW46ICdBbm9ueW1vdXMnLFxcblxcblxcdFxcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHRleHR1cmUgPSBuZXcgVGV4dHVyZSgpO1xcblxcblxcdFxcdFxcdHZhciBsb2FkZXIgPSBuZXcgSW1hZ2VMb2FkZXIoIHRoaXMubWFuYWdlciApO1xcblxcdFxcdFxcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xcblxcdFxcdFxcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcXG5cXG5cXHRcXHRcXHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGltYWdlICkge1xcblxcblxcdFxcdFxcdFxcdHRleHR1cmUuaW1hZ2UgPSBpbWFnZTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBKUEVHcyBjYW4ndCBoYXZlIGFuIGFscGhhIGNoYW5uZWwsIHNvIG1lbW9yeSBjYW4gYmUgc2F2ZWQgYnkgc3RvcmluZyB0aGVtIGFzIFJHQi5cXG5cXHRcXHRcXHRcXHR2YXIgaXNKUEVHID0gdXJsLnNlYXJjaCggL1xcXFwuKGpwZ3xqcGVnKSQvICkgPiAwIHx8IHVybC5zZWFyY2goIC9eZGF0YVxcXFw6aW1hZ2VcXFxcL2pwZWcvICkgPT09IDA7XFxuXFxuXFx0XFx0XFx0XFx0dGV4dHVyZS5mb3JtYXQgPSBpc0pQRUcgPyBSR0JGb3JtYXQgOiBSR0JBRm9ybWF0O1xcblxcdFxcdFxcdFxcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdGlmICggb25Mb2FkICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0b25Mb2FkKCB0ZXh0dXJlICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGV4dHVyZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5wYXRoID0gdmFsdWU7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXFxuXFx0ICogRXh0ZW5zaWJsZSBjdXJ2ZSBvYmplY3RcXG5cXHQgKlxcblxcdCAqIFNvbWUgY29tbW9uIG9mIGN1cnZlIG1ldGhvZHM6XFxuXFx0ICogLmdldFBvaW50KCB0LCBvcHRpb25hbFRhcmdldCApLCAuZ2V0VGFuZ2VudCggdCApXFxuXFx0ICogLmdldFBvaW50QXQoIHUsIG9wdGlvbmFsVGFyZ2V0ICksIC5nZXRUYW5nZW50QXQoIHUgKVxcblxcdCAqIC5nZXRQb2ludHMoKSwgLmdldFNwYWNlZFBvaW50cygpXFxuXFx0ICogLmdldExlbmd0aCgpXFxuXFx0ICogLnVwZGF0ZUFyY0xlbmd0aHMoKVxcblxcdCAqXFxuXFx0ICogVGhpcyBmb2xsb3dpbmcgY3VydmVzIGluaGVyaXQgZnJvbSBUSFJFRS5DdXJ2ZTpcXG5cXHQgKlxcblxcdCAqIC0tIDJEIGN1cnZlcyAtLVxcblxcdCAqIFRIUkVFLkFyY0N1cnZlXFxuXFx0ICogVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZVxcblxcdCAqIFRIUkVFLkVsbGlwc2VDdXJ2ZVxcblxcdCAqIFRIUkVFLkxpbmVDdXJ2ZVxcblxcdCAqIFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlXFxuXFx0ICogVEhSRUUuU3BsaW5lQ3VydmVcXG5cXHQgKlxcblxcdCAqIC0tIDNEIGN1cnZlcyAtLVxcblxcdCAqIFRIUkVFLkNhdG11bGxSb21DdXJ2ZTNcXG5cXHQgKiBUSFJFRS5DdWJpY0JlemllckN1cnZlM1xcblxcdCAqIFRIUkVFLkxpbmVDdXJ2ZTNcXG5cXHQgKiBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZTNcXG5cXHQgKlxcblxcdCAqIEEgc2VyaWVzIG9mIGN1cnZlcyBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgYSBUSFJFRS5DdXJ2ZVBhdGguXFxuXFx0ICpcXG5cXHQgKiovXFxuXFxuXFx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxuXFx0ICpcXHRBYnN0cmFjdCBDdXJ2ZSBiYXNlIGNsYXNzXFxuXFx0ICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcblxcblxcdGZ1bmN0aW9uIEN1cnZlKCkge1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdDdXJ2ZSc7XFxuXFxuXFx0XFx0dGhpcy5hcmNMZW5ndGhEaXZpc2lvbnMgPSAyMDA7XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5hc3NpZ24oIEN1cnZlLnByb3RvdHlwZSwge1xcblxcblxcdFxcdC8vIFZpcnR1YWwgYmFzZSBjbGFzcyBtZXRob2QgdG8gb3ZlcndyaXRlIGFuZCBpbXBsZW1lbnQgaW4gc3ViY2xhc3Nlc1xcblxcdFxcdC8vXFx0LSB0IFswIC4uIDFdXFxuXFxuXFx0XFx0Z2V0UG9pbnQ6IGZ1bmN0aW9uICggLyogdCwgb3B0aW9uYWxUYXJnZXQgKi8gKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ3VydmU6IC5nZXRQb2ludCgpIG5vdCBpbXBsZW1lbnRlZC4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIG51bGw7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBHZXQgcG9pbnQgYXQgcmVsYXRpdmUgcG9zaXRpb24gaW4gY3VydmUgYWNjb3JkaW5nIHRvIGFyYyBsZW5ndGhcXG5cXHRcXHQvLyAtIHUgWzAgLi4gMV1cXG5cXG5cXHRcXHRnZXRQb2ludEF0OiBmdW5jdGlvbiAoIHUsIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdHZhciB0ID0gdGhpcy5nZXRVdG9UbWFwcGluZyggdSApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmdldFBvaW50KCB0LCBvcHRpb25hbFRhcmdldCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludCggdCApXFxuXFxuXFx0XFx0Z2V0UG9pbnRzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGRpdmlzaW9ucyA9PT0gdW5kZWZpbmVkICkgZGl2aXNpb25zID0gNTtcXG5cXG5cXHRcXHRcXHR2YXIgcG9pbnRzID0gW107XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGQgPSAwOyBkIDw9IGRpdmlzaW9uczsgZCArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRwb2ludHMucHVzaCggdGhpcy5nZXRQb2ludCggZCAvIGRpdmlzaW9ucyApICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBwb2ludHM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBHZXQgc2VxdWVuY2Ugb2YgcG9pbnRzIHVzaW5nIGdldFBvaW50QXQoIHUgKVxcblxcblxcdFxcdGdldFNwYWNlZFBvaW50czogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCApIGRpdmlzaW9ucyA9IDU7XFxuXFxuXFx0XFx0XFx0dmFyIHBvaW50cyA9IFtdO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBkID0gMDsgZCA8PSBkaXZpc2lvbnM7IGQgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnRBdCggZCAvIGRpdmlzaW9ucyApICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBwb2ludHM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBHZXQgdG90YWwgY3VydmUgYXJjIGxlbmd0aFxcblxcblxcdFxcdGdldExlbmd0aDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBsZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKCk7XFxuXFx0XFx0XFx0cmV0dXJuIGxlbmd0aHNbIGxlbmd0aHMubGVuZ3RoIC0gMSBdO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gR2V0IGxpc3Qgb2YgY3VtdWxhdGl2ZSBzZWdtZW50IGxlbmd0aHNcXG5cXG5cXHRcXHRnZXRMZW5ndGhzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGRpdmlzaW9ucyA9PT0gdW5kZWZpbmVkICkgZGl2aXNpb25zID0gdGhpcy5hcmNMZW5ndGhEaXZpc2lvbnM7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmNhY2hlQXJjTGVuZ3RocyAmJlxcblxcdFxcdFxcdFxcdCggdGhpcy5jYWNoZUFyY0xlbmd0aHMubGVuZ3RoID09PSBkaXZpc2lvbnMgKyAxICkgJiZcXG5cXHRcXHRcXHRcXHQhIHRoaXMubmVlZHNVcGRhdGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuY2FjaGVBcmNMZW5ndGhzO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0dmFyIGNhY2hlID0gW107XFxuXFx0XFx0XFx0dmFyIGN1cnJlbnQsIGxhc3QgPSB0aGlzLmdldFBvaW50KCAwICk7XFxuXFx0XFx0XFx0dmFyIHAsIHN1bSA9IDA7XFxuXFxuXFx0XFx0XFx0Y2FjaGUucHVzaCggMCApO1xcblxcblxcdFxcdFxcdGZvciAoIHAgPSAxOyBwIDw9IGRpdmlzaW9uczsgcCArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRjdXJyZW50ID0gdGhpcy5nZXRQb2ludCggcCAvIGRpdmlzaW9ucyApO1xcblxcdFxcdFxcdFxcdHN1bSArPSBjdXJyZW50LmRpc3RhbmNlVG8oIGxhc3QgKTtcXG5cXHRcXHRcXHRcXHRjYWNoZS5wdXNoKCBzdW0gKTtcXG5cXHRcXHRcXHRcXHRsYXN0ID0gY3VycmVudDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5jYWNoZUFyY0xlbmd0aHMgPSBjYWNoZTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gY2FjaGU7IC8vIHsgc3VtczogY2FjaGUsIHN1bTogc3VtIH07IFN1bSBpcyBpbiB0aGUgbGFzdCBlbGVtZW50LlxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dXBkYXRlQXJjTGVuZ3RoczogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcdFxcdFxcdHRoaXMuZ2V0TGVuZ3RocygpO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gR2l2ZW4gdSAoIDAgLi4gMSApLCBnZXQgYSB0IHRvIGZpbmQgcC4gVGhpcyBnaXZlcyB5b3UgcG9pbnRzIHdoaWNoIGFyZSBlcXVpZGlzdGFudFxcblxcblxcdFxcdGdldFV0b1RtYXBwaW5nOiBmdW5jdGlvbiAoIHUsIGRpc3RhbmNlICkge1xcblxcblxcdFxcdFxcdHZhciBhcmNMZW5ndGhzID0gdGhpcy5nZXRMZW5ndGhzKCk7XFxuXFxuXFx0XFx0XFx0dmFyIGkgPSAwLCBpbCA9IGFyY0xlbmd0aHMubGVuZ3RoO1xcblxcblxcdFxcdFxcdHZhciB0YXJnZXRBcmNMZW5ndGg7IC8vIFRoZSB0YXJnZXRlZCB1IGRpc3RhbmNlIHZhbHVlIHRvIGdldFxcblxcblxcdFxcdFxcdGlmICggZGlzdGFuY2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGFyZ2V0QXJjTGVuZ3RoID0gZGlzdGFuY2U7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHR0YXJnZXRBcmNMZW5ndGggPSB1ICogYXJjTGVuZ3Roc1sgaWwgLSAxIF07XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGJpbmFyeSBzZWFyY2ggZm9yIHRoZSBpbmRleCB3aXRoIGxhcmdlc3QgdmFsdWUgc21hbGxlciB0aGFuIHRhcmdldCB1IGRpc3RhbmNlXFxuXFxuXFx0XFx0XFx0dmFyIGxvdyA9IDAsIGhpZ2ggPSBpbCAtIDEsIGNvbXBhcmlzb247XFxuXFxuXFx0XFx0XFx0d2hpbGUgKCBsb3cgPD0gaGlnaCApIHtcXG5cXG5cXHRcXHRcXHRcXHRpID0gTWF0aC5mbG9vciggbG93ICsgKCBoaWdoIC0gbG93ICkgLyAyICk7IC8vIGxlc3MgbGlrZWx5IHRvIG92ZXJmbG93LCB0aG91Z2ggcHJvYmFibHkgbm90IGlzc3VlIGhlcmUsIEpTIGRvZXNuJ3QgcmVhbGx5IGhhdmUgaW50ZWdlcnMsIGFsbCBudW1iZXJzIGFyZSBmbG9hdHNcXG5cXG5cXHRcXHRcXHRcXHRjb21wYXJpc29uID0gYXJjTGVuZ3Roc1sgaSBdIC0gdGFyZ2V0QXJjTGVuZ3RoO1xcblxcblxcdFxcdFxcdFxcdGlmICggY29tcGFyaXNvbiA8IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bG93ID0gaSArIDE7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggY29tcGFyaXNvbiA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aGlnaCA9IGkgLSAxO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aGlnaCA9IGk7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gRE9ORVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aSA9IGhpZ2g7XFxuXFxuXFx0XFx0XFx0aWYgKCBhcmNMZW5ndGhzWyBpIF0gPT09IHRhcmdldEFyY0xlbmd0aCApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gaSAvICggaWwgLSAxICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIHdlIGNvdWxkIGdldCBmaW5lciBncmFpbiBhdCBsZW5ndGhzLCBvciB1c2Ugc2ltcGxlIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcG9pbnRzXFxuXFxuXFx0XFx0XFx0dmFyIGxlbmd0aEJlZm9yZSA9IGFyY0xlbmd0aHNbIGkgXTtcXG5cXHRcXHRcXHR2YXIgbGVuZ3RoQWZ0ZXIgPSBhcmNMZW5ndGhzWyBpICsgMSBdO1xcblxcblxcdFxcdFxcdHZhciBzZWdtZW50TGVuZ3RoID0gbGVuZ3RoQWZ0ZXIgLSBsZW5ndGhCZWZvcmU7XFxuXFxuXFx0XFx0XFx0Ly8gZGV0ZXJtaW5lIHdoZXJlIHdlIGFyZSBiZXR3ZWVuIHRoZSAnYmVmb3JlJyBhbmQgJ2FmdGVyJyBwb2ludHNcXG5cXG5cXHRcXHRcXHR2YXIgc2VnbWVudEZyYWN0aW9uID0gKCB0YXJnZXRBcmNMZW5ndGggLSBsZW5ndGhCZWZvcmUgKSAvIHNlZ21lbnRMZW5ndGg7XFxuXFxuXFx0XFx0XFx0Ly8gYWRkIHRoYXQgZnJhY3Rpb25hbCBhbW91bnQgdG8gdFxcblxcblxcdFxcdFxcdHZhciB0ID0gKCBpICsgc2VnbWVudEZyYWN0aW9uICkgLyAoIGlsIC0gMSApO1xcblxcblxcdFxcdFxcdHJldHVybiB0O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gUmV0dXJucyBhIHVuaXQgdmVjdG9yIHRhbmdlbnQgYXQgdFxcblxcdFxcdC8vIEluIGNhc2UgYW55IHN1YiBjdXJ2ZSBkb2VzIG5vdCBpbXBsZW1lbnQgaXRzIHRhbmdlbnQgZGVyaXZhdGlvbixcXG5cXHRcXHQvLyAyIHBvaW50cyBhIHNtYWxsIGRlbHRhIGFwYXJ0IHdpbGwgYmUgdXNlZCB0byBmaW5kIGl0cyBncmFkaWVudFxcblxcdFxcdC8vIHdoaWNoIHNlZW1zIHRvIGdpdmUgYSByZWFzb25hYmxlIGFwcHJveGltYXRpb25cXG5cXG5cXHRcXHRnZXRUYW5nZW50OiBmdW5jdGlvbiAoIHQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGRlbHRhID0gMC4wMDAxO1xcblxcdFxcdFxcdHZhciB0MSA9IHQgLSBkZWx0YTtcXG5cXHRcXHRcXHR2YXIgdDIgPSB0ICsgZGVsdGE7XFxuXFxuXFx0XFx0XFx0Ly8gQ2FwcGluZyBpbiBjYXNlIG9mIGRhbmdlclxcblxcblxcdFxcdFxcdGlmICggdDEgPCAwICkgdDEgPSAwO1xcblxcdFxcdFxcdGlmICggdDIgPiAxICkgdDIgPSAxO1xcblxcblxcdFxcdFxcdHZhciBwdDEgPSB0aGlzLmdldFBvaW50KCB0MSApO1xcblxcdFxcdFxcdHZhciBwdDIgPSB0aGlzLmdldFBvaW50KCB0MiApO1xcblxcblxcdFxcdFxcdHZhciB2ZWMgPSBwdDIuY2xvbmUoKS5zdWIoIHB0MSApO1xcblxcdFxcdFxcdHJldHVybiB2ZWMubm9ybWFsaXplKCk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRUYW5nZW50QXQ6IGZ1bmN0aW9uICggdSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdCA9IHRoaXMuZ2V0VXRvVG1hcHBpbmcoIHUgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5nZXRUYW5nZW50KCB0ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb21wdXRlRnJlbmV0RnJhbWVzOiBmdW5jdGlvbiAoIHNlZ21lbnRzLCBjbG9zZWQgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gc2VlIGh0dHA6Ly93d3cuY3MuaW5kaWFuYS5lZHUvcHViL3RlY2hyZXBvcnRzL1RSNDI1LnBkZlxcblxcblxcdFxcdFxcdHZhciBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHZhciB0YW5nZW50cyA9IFtdO1xcblxcdFxcdFxcdHZhciBub3JtYWxzID0gW107XFxuXFx0XFx0XFx0dmFyIGJpbm9ybWFscyA9IFtdO1xcblxcblxcdFxcdFxcdHZhciB2ZWMgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdHZhciBtYXQgPSBuZXcgTWF0cml4NCgpO1xcblxcblxcdFxcdFxcdHZhciBpLCB1LCB0aGV0YTtcXG5cXG5cXHRcXHRcXHQvLyBjb21wdXRlIHRoZSB0YW5nZW50IHZlY3RvcnMgZm9yIGVhY2ggc2VnbWVudCBvbiB0aGUgY3VydmVcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gMDsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR1ID0gaSAvIHNlZ21lbnRzO1xcblxcblxcdFxcdFxcdFxcdHRhbmdlbnRzWyBpIF0gPSB0aGlzLmdldFRhbmdlbnRBdCggdSApO1xcblxcdFxcdFxcdFxcdHRhbmdlbnRzWyBpIF0ubm9ybWFsaXplKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIHNlbGVjdCBhbiBpbml0aWFsIG5vcm1hbCB2ZWN0b3IgcGVycGVuZGljdWxhciB0byB0aGUgZmlyc3QgdGFuZ2VudCB2ZWN0b3IsXFxuXFx0XFx0XFx0Ly8gYW5kIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIG1pbmltdW0gdGFuZ2VudCB4eXogY29tcG9uZW50XFxuXFxuXFx0XFx0XFx0bm9ybWFsc1sgMCBdID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHRiaW5vcm1hbHNbIDAgXSA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0dmFyIG1pbiA9IE51bWJlci5NQVhfVkFMVUU7XFxuXFx0XFx0XFx0dmFyIHR4ID0gTWF0aC5hYnMoIHRhbmdlbnRzWyAwIF0ueCApO1xcblxcdFxcdFxcdHZhciB0eSA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnkgKTtcXG5cXHRcXHRcXHR2YXIgdHogPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS56ICk7XFxuXFxuXFx0XFx0XFx0aWYgKCB0eCA8PSBtaW4gKSB7XFxuXFxuXFx0XFx0XFx0XFx0bWluID0gdHg7XFxuXFx0XFx0XFx0XFx0bm9ybWFsLnNldCggMSwgMCwgMCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHR5IDw9IG1pbiApIHtcXG5cXG5cXHRcXHRcXHRcXHRtaW4gPSB0eTtcXG5cXHRcXHRcXHRcXHRub3JtYWwuc2V0KCAwLCAxLCAwICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggdHogPD0gbWluICkge1xcblxcblxcdFxcdFxcdFxcdG5vcm1hbC5zZXQoIDAsIDAsIDEgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmVjLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsICkubm9ybWFsaXplKCk7XFxuXFxuXFx0XFx0XFx0bm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgdmVjICk7XFxuXFx0XFx0XFx0Ymlub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKTtcXG5cXG5cXG5cXHRcXHRcXHQvLyBjb21wdXRlIHRoZSBzbG93bHktdmFyeWluZyBub3JtYWwgYW5kIGJpbm9ybWFsIHZlY3RvcnMgZm9yIGVhY2ggc2VnbWVudCBvbiB0aGUgY3VydmVcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gMTsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRub3JtYWxzWyBpIF0gPSBub3JtYWxzWyBpIC0gMSBdLmNsb25lKCk7XFxuXFxuXFx0XFx0XFx0XFx0Ymlub3JtYWxzWyBpIF0gPSBiaW5vcm1hbHNbIGkgLSAxIF0uY2xvbmUoKTtcXG5cXG5cXHRcXHRcXHRcXHR2ZWMuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSAtIDEgXSwgdGFuZ2VudHNbIGkgXSApO1xcblxcblxcdFxcdFxcdFxcdGlmICggdmVjLmxlbmd0aCgpID4gTnVtYmVyLkVQU0lMT04gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmVjLm5vcm1hbGl6ZSgpO1xcblxcblxcdFxcdFxcdFxcdFxcdHRoZXRhID0gTWF0aC5hY29zKCBfTWF0aC5jbGFtcCggdGFuZ2VudHNbIGkgLSAxIF0uZG90KCB0YW5nZW50c1sgaSBdICksIC0gMSwgMSApICk7IC8vIGNsYW1wIGZvciBmbG9hdGluZyBwdCBlcnJvcnNcXG5cXG5cXHRcXHRcXHRcXHRcXHRub3JtYWxzWyBpIF0uYXBwbHlNYXRyaXg0KCBtYXQubWFrZVJvdGF0aW9uQXhpcyggdmVjLCB0aGV0YSApICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGJpbm9ybWFsc1sgaSBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgXSwgbm9ybWFsc1sgaSBdICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGlmIHRoZSBjdXJ2ZSBpcyBjbG9zZWQsIHBvc3Rwcm9jZXNzIHRoZSB2ZWN0b3JzIHNvIHRoZSBmaXJzdCBhbmQgbGFzdCBub3JtYWwgdmVjdG9ycyBhcmUgdGhlIHNhbWVcXG5cXG5cXHRcXHRcXHRpZiAoIGNsb3NlZCA9PT0gdHJ1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGV0YSA9IE1hdGguYWNvcyggX01hdGguY2xhbXAoIG5vcm1hbHNbIDAgXS5kb3QoIG5vcm1hbHNbIHNlZ21lbnRzIF0gKSwgLSAxLCAxICkgKTtcXG5cXHRcXHRcXHRcXHR0aGV0YSAvPSBzZWdtZW50cztcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHRhbmdlbnRzWyAwIF0uZG90KCB2ZWMuY3Jvc3NWZWN0b3JzKCBub3JtYWxzWyAwIF0sIG5vcm1hbHNbIHNlZ21lbnRzIF0gKSApID4gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGV0YSA9IC0gdGhldGE7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGZvciAoIGkgPSAxOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIHR3aXN0IGEgbGl0dGxlLi4uXFxuXFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgaSBdLmFwcGx5TWF0cml4NCggbWF0Lm1ha2VSb3RhdGlvbkF4aXMoIHRhbmdlbnRzWyBpIF0sIHRoZXRhICogaSApICk7XFxuXFx0XFx0XFx0XFx0XFx0Ymlub3JtYWxzWyBpIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSBdLCBub3JtYWxzWyBpIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0XFx0dGFuZ2VudHM6IHRhbmdlbnRzLFxcblxcdFxcdFxcdFxcdG5vcm1hbHM6IG5vcm1hbHMsXFxuXFx0XFx0XFx0XFx0Ymlub3JtYWxzOiBiaW5vcm1hbHNcXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmFyY0xlbmd0aERpdmlzaW9ucyA9IHNvdXJjZS5hcmNMZW5ndGhEaXZpc2lvbnM7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0b0pTT046IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgZGF0YSA9IHtcXG5cXHRcXHRcXHRcXHRtZXRhZGF0YToge1xcblxcdFxcdFxcdFxcdFxcdHZlcnNpb246IDQuNSxcXG5cXHRcXHRcXHRcXHRcXHR0eXBlOiAnQ3VydmUnLFxcblxcdFxcdFxcdFxcdFxcdGdlbmVyYXRvcjogJ0N1cnZlLnRvSlNPTidcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHRkYXRhLmFyY0xlbmd0aERpdmlzaW9ucyA9IHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zO1xcblxcdFxcdFxcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZGF0YTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGZyb21KU09OOiBmdW5jdGlvbiAoIGpzb24gKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5hcmNMZW5ndGhEaXZpc2lvbnMgPSBqc29uLmFyY0xlbmd0aERpdmlzaW9ucztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdGZ1bmN0aW9uIEVsbGlwc2VDdXJ2ZSggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKSB7XFxuXFxuXFx0XFx0Q3VydmUuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdFbGxpcHNlQ3VydmUnO1xcblxcblxcdFxcdHRoaXMuYVggPSBhWCB8fCAwO1xcblxcdFxcdHRoaXMuYVkgPSBhWSB8fCAwO1xcblxcblxcdFxcdHRoaXMueFJhZGl1cyA9IHhSYWRpdXMgfHwgMTtcXG5cXHRcXHR0aGlzLnlSYWRpdXMgPSB5UmFkaXVzIHx8IDE7XFxuXFxuXFx0XFx0dGhpcy5hU3RhcnRBbmdsZSA9IGFTdGFydEFuZ2xlIHx8IDA7XFxuXFx0XFx0dGhpcy5hRW5kQW5nbGUgPSBhRW5kQW5nbGUgfHwgMiAqIE1hdGguUEk7XFxuXFxuXFx0XFx0dGhpcy5hQ2xvY2t3aXNlID0gYUNsb2Nrd2lzZSB8fCBmYWxzZTtcXG5cXG5cXHRcXHR0aGlzLmFSb3RhdGlvbiA9IGFSb3RhdGlvbiB8fCAwO1xcblxcblxcdH1cXG5cXG5cXHRFbGxpcHNlQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XFxuXFx0RWxsaXBzZUN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVsbGlwc2VDdXJ2ZTtcXG5cXG5cXHRFbGxpcHNlQ3VydmUucHJvdG90eXBlLmlzRWxsaXBzZUN1cnZlID0gdHJ1ZTtcXG5cXG5cXHRFbGxpcHNlQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHR2YXIgcG9pbnQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMigpO1xcblxcblxcdFxcdHZhciB0d29QaSA9IE1hdGguUEkgKiAyO1xcblxcdFxcdHZhciBkZWx0YUFuZ2xlID0gdGhpcy5hRW5kQW5nbGUgLSB0aGlzLmFTdGFydEFuZ2xlO1xcblxcdFxcdHZhciBzYW1lUG9pbnRzID0gTWF0aC5hYnMoIGRlbHRhQW5nbGUgKSA8IE51bWJlci5FUFNJTE9OO1xcblxcblxcdFxcdC8vIGVuc3VyZXMgdGhhdCBkZWx0YUFuZ2xlIGlzIDAgLi4gMiBQSVxcblxcdFxcdHdoaWxlICggZGVsdGFBbmdsZSA8IDAgKSBkZWx0YUFuZ2xlICs9IHR3b1BpO1xcblxcdFxcdHdoaWxlICggZGVsdGFBbmdsZSA+IHR3b1BpICkgZGVsdGFBbmdsZSAtPSB0d29QaTtcXG5cXG5cXHRcXHRpZiAoIGRlbHRhQW5nbGUgPCBOdW1iZXIuRVBTSUxPTiApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHNhbWVQb2ludHMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZGVsdGFBbmdsZSA9IDA7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRkZWx0YUFuZ2xlID0gdHdvUGk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIHRoaXMuYUNsb2Nrd2lzZSA9PT0gdHJ1ZSAmJiAhIHNhbWVQb2ludHMgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBkZWx0YUFuZ2xlID09PSB0d29QaSApIHtcXG5cXG5cXHRcXHRcXHRcXHRkZWx0YUFuZ2xlID0gLSB0d29QaTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdGRlbHRhQW5nbGUgPSBkZWx0YUFuZ2xlIC0gdHdvUGk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR2YXIgYW5nbGUgPSB0aGlzLmFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XFxuXFx0XFx0dmFyIHggPSB0aGlzLmFYICsgdGhpcy54UmFkaXVzICogTWF0aC5jb3MoIGFuZ2xlICk7XFxuXFx0XFx0dmFyIHkgPSB0aGlzLmFZICsgdGhpcy55UmFkaXVzICogTWF0aC5zaW4oIGFuZ2xlICk7XFxuXFxuXFx0XFx0aWYgKCB0aGlzLmFSb3RhdGlvbiAhPT0gMCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgY29zID0gTWF0aC5jb3MoIHRoaXMuYVJvdGF0aW9uICk7XFxuXFx0XFx0XFx0dmFyIHNpbiA9IE1hdGguc2luKCB0aGlzLmFSb3RhdGlvbiApO1xcblxcblxcdFxcdFxcdHZhciB0eCA9IHggLSB0aGlzLmFYO1xcblxcdFxcdFxcdHZhciB0eSA9IHkgLSB0aGlzLmFZO1xcblxcblxcdFxcdFxcdC8vIFJvdGF0ZSB0aGUgcG9pbnQgYWJvdXQgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZS5cXG5cXHRcXHRcXHR4ID0gdHggKiBjb3MgLSB0eSAqIHNpbiArIHRoaXMuYVg7XFxuXFx0XFx0XFx0eSA9IHR4ICogc2luICsgdHkgKiBjb3MgKyB0aGlzLmFZO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gcG9pbnQuc2V0KCB4LCB5ICk7XFxuXFxuXFx0fTtcXG5cXG5cXHRFbGxpcHNlQ3VydmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRDdXJ2ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXG5cXG5cXHRcXHR0aGlzLmFYID0gc291cmNlLmFYO1xcblxcdFxcdHRoaXMuYVkgPSBzb3VyY2UuYVk7XFxuXFxuXFx0XFx0dGhpcy54UmFkaXVzID0gc291cmNlLnhSYWRpdXM7XFxuXFx0XFx0dGhpcy55UmFkaXVzID0gc291cmNlLnlSYWRpdXM7XFxuXFxuXFx0XFx0dGhpcy5hU3RhcnRBbmdsZSA9IHNvdXJjZS5hU3RhcnRBbmdsZTtcXG5cXHRcXHR0aGlzLmFFbmRBbmdsZSA9IHNvdXJjZS5hRW5kQW5nbGU7XFxuXFxuXFx0XFx0dGhpcy5hQ2xvY2t3aXNlID0gc291cmNlLmFDbG9ja3dpc2U7XFxuXFxuXFx0XFx0dGhpcy5hUm90YXRpb24gPSBzb3VyY2UuYVJvdGF0aW9uO1xcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdH07XFxuXFxuXFxuXFx0RWxsaXBzZUN1cnZlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0dmFyIGRhdGEgPSBDdXJ2ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHRkYXRhLmFYID0gdGhpcy5hWDtcXG5cXHRcXHRkYXRhLmFZID0gdGhpcy5hWTtcXG5cXG5cXHRcXHRkYXRhLnhSYWRpdXMgPSB0aGlzLnhSYWRpdXM7XFxuXFx0XFx0ZGF0YS55UmFkaXVzID0gdGhpcy55UmFkaXVzO1xcblxcblxcdFxcdGRhdGEuYVN0YXJ0QW5nbGUgPSB0aGlzLmFTdGFydEFuZ2xlO1xcblxcdFxcdGRhdGEuYUVuZEFuZ2xlID0gdGhpcy5hRW5kQW5nbGU7XFxuXFxuXFx0XFx0ZGF0YS5hQ2xvY2t3aXNlID0gdGhpcy5hQ2xvY2t3aXNlO1xcblxcblxcdFxcdGRhdGEuYVJvdGF0aW9uID0gdGhpcy5hUm90YXRpb247XFxuXFxuXFx0XFx0cmV0dXJuIGRhdGE7XFxuXFxuXFx0fTtcXG5cXG5cXHRFbGxpcHNlQ3VydmUucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24gKCBqc29uICkge1xcblxcblxcdFxcdEN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKCB0aGlzLCBqc29uICk7XFxuXFxuXFx0XFx0dGhpcy5hWCA9IGpzb24uYVg7XFxuXFx0XFx0dGhpcy5hWSA9IGpzb24uYVk7XFxuXFxuXFx0XFx0dGhpcy54UmFkaXVzID0ganNvbi54UmFkaXVzO1xcblxcdFxcdHRoaXMueVJhZGl1cyA9IGpzb24ueVJhZGl1cztcXG5cXG5cXHRcXHR0aGlzLmFTdGFydEFuZ2xlID0ganNvbi5hU3RhcnRBbmdsZTtcXG5cXHRcXHR0aGlzLmFFbmRBbmdsZSA9IGpzb24uYUVuZEFuZ2xlO1xcblxcblxcdFxcdHRoaXMuYUNsb2Nrd2lzZSA9IGpzb24uYUNsb2Nrd2lzZTtcXG5cXG5cXHRcXHR0aGlzLmFSb3RhdGlvbiA9IGpzb24uYVJvdGF0aW9uO1xcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdH07XFxuXFxuXFx0ZnVuY3Rpb24gQXJjQ3VydmUoIGFYLCBhWSwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcXG5cXG5cXHRcXHRFbGxpcHNlQ3VydmUuY2FsbCggdGhpcywgYVgsIGFZLCBhUmFkaXVzLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ0FyY0N1cnZlJztcXG5cXG5cXHR9XFxuXFxuXFx0QXJjQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRWxsaXBzZUN1cnZlLnByb3RvdHlwZSApO1xcblxcdEFyY0N1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFyY0N1cnZlO1xcblxcblxcdEFyY0N1cnZlLnByb3RvdHlwZS5pc0FyY0N1cnZlID0gdHJ1ZTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIHp6ODUgaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcXG5cXHQgKlxcblxcdCAqIENlbnRyaXBldGFsIENhdG11bGxSb20gQ3VydmUgLSB3aGljaCBpcyB1c2VmdWwgZm9yIGF2b2lkaW5nXFxuXFx0ICogY3VzcHMgYW5kIHNlbGYtaW50ZXJzZWN0aW9ucyBpbiBub24tdW5pZm9ybSBjYXRtdWxsIHJvbSBjdXJ2ZXMuXFxuXFx0ICogaHR0cDovL3d3dy5jZW15dWtzZWwuY29tL3Jlc2VhcmNoL2NhdG11bGxyb21fcGFyYW0vY2F0bXVsbHJvbS5wZGZcXG5cXHQgKlxcblxcdCAqIGN1cnZlLnR5cGUgYWNjZXB0cyBjZW50cmlwZXRhbChkZWZhdWx0KSwgY2hvcmRhbCBhbmQgY2F0bXVsbHJvbVxcblxcdCAqIGN1cnZlLnRlbnNpb24gaXMgdXNlZCBmb3IgY2F0bXVsbHJvbSB3aGljaCBkZWZhdWx0cyB0byAwLjVcXG5cXHQgKi9cXG5cXG5cXG5cXHQvKlxcblxcdEJhc2VkIG9uIGFuIG9wdGltaXplZCBjKysgc29sdXRpb24gaW5cXG5cXHQgLSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk0ODk3MzYvY2F0bXVsbC1yb20tY3VydmUtd2l0aC1uby1jdXNwcy1hbmQtbm8tc2VsZi1pbnRlcnNlY3Rpb25zL1xcblxcdCAtIGh0dHA6Ly9pZGVvbmUuY29tL05vRWJWTVxcblxcblxcdFRoaXMgQ3ViaWNQb2x5IGNsYXNzIGNvdWxkIGJlIHVzZWQgZm9yIHJldXNpbmcgc29tZSB2YXJpYWJsZXMgYW5kIGNhbGN1bGF0aW9ucyxcXG5cXHRidXQgZm9yIHRocmVlLmpzIGN1cnZlIHVzZSwgaXQgY291bGQgYmUgcG9zc2libGUgaW5saW5lZCBhbmQgZmxhdHRlbiBpbnRvIGEgc2luZ2xlIGZ1bmN0aW9uIGNhbGxcXG5cXHR3aGljaCBjYW4gYmUgcGxhY2VkIGluIEN1cnZlVXRpbHMuXFxuXFx0Ki9cXG5cXG5cXHRmdW5jdGlvbiBDdWJpY1BvbHkoKSB7XFxuXFxuXFx0XFx0dmFyIGMwID0gMCwgYzEgPSAwLCBjMiA9IDAsIGMzID0gMDtcXG5cXG5cXHRcXHQvKlxcblxcdFxcdCAqIENvbXB1dGUgY29lZmZpY2llbnRzIGZvciBhIGN1YmljIHBvbHlub21pYWxcXG5cXHRcXHQgKiAgIHAocykgPSBjMCArIGMxKnMgKyBjMipzXjIgKyBjMypzXjNcXG5cXHRcXHQgKiBzdWNoIHRoYXRcXG5cXHRcXHQgKiAgIHAoMCkgPSB4MCwgcCgxKSA9IHgxXFxuXFx0XFx0ICogIGFuZFxcblxcdFxcdCAqICAgcCcoMCkgPSB0MCwgcCcoMSkgPSB0MS5cXG5cXHRcXHQgKi9cXG5cXHRcXHRmdW5jdGlvbiBpbml0KCB4MCwgeDEsIHQwLCB0MSApIHtcXG5cXG5cXHRcXHRcXHRjMCA9IHgwO1xcblxcdFxcdFxcdGMxID0gdDA7XFxuXFx0XFx0XFx0YzIgPSAtIDMgKiB4MCArIDMgKiB4MSAtIDIgKiB0MCAtIHQxO1xcblxcdFxcdFxcdGMzID0gMiAqIHgwIC0gMiAqIHgxICsgdDAgKyB0MTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHtcXG5cXG5cXHRcXHRcXHRpbml0Q2F0bXVsbFJvbTogZnVuY3Rpb24gKCB4MCwgeDEsIHgyLCB4MywgdGVuc2lvbiApIHtcXG5cXG5cXHRcXHRcXHRcXHRpbml0KCB4MSwgeDIsIHRlbnNpb24gKiAoIHgyIC0geDAgKSwgdGVuc2lvbiAqICggeDMgLSB4MSApICk7XFxuXFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRpbml0Tm9udW5pZm9ybUNhdG11bGxSb206IGZ1bmN0aW9uICggeDAsIHgxLCB4MiwgeDMsIGR0MCwgZHQxLCBkdDIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gY29tcHV0ZSB0YW5nZW50cyB3aGVuIHBhcmFtZXRlcml6ZWQgaW4gW3QxLHQyXVxcblxcdFxcdFxcdFxcdHZhciB0MSA9ICggeDEgLSB4MCApIC8gZHQwIC0gKCB4MiAtIHgwICkgLyAoIGR0MCArIGR0MSApICsgKCB4MiAtIHgxICkgLyBkdDE7XFxuXFx0XFx0XFx0XFx0dmFyIHQyID0gKCB4MiAtIHgxICkgLyBkdDEgLSAoIHgzIC0geDEgKSAvICggZHQxICsgZHQyICkgKyAoIHgzIC0geDIgKSAvIGR0MjtcXG5cXG5cXHRcXHRcXHRcXHQvLyByZXNjYWxlIHRhbmdlbnRzIGZvciBwYXJhbWV0cml6YXRpb24gaW4gWzAsMV1cXG5cXHRcXHRcXHRcXHR0MSAqPSBkdDE7XFxuXFx0XFx0XFx0XFx0dDIgKj0gZHQxO1xcblxcblxcdFxcdFxcdFxcdGluaXQoIHgxLCB4MiwgdDEsIHQyICk7XFxuXFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRjYWxjOiBmdW5jdGlvbiAoIHQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHQyID0gdCAqIHQ7XFxuXFx0XFx0XFx0XFx0dmFyIHQzID0gdDIgKiB0O1xcblxcdFxcdFxcdFxcdHJldHVybiBjMCArIGMxICogdCArIGMyICogdDIgKyBjMyAqIHQzO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9O1xcblxcblxcdH1cXG5cXG5cXHQvL1xcblxcblxcdHZhciB0bXAgPSBuZXcgVmVjdG9yMygpO1xcblxcdHZhciBweCA9IG5ldyBDdWJpY1BvbHkoKTtcXG5cXHR2YXIgcHkgPSBuZXcgQ3ViaWNQb2x5KCk7XFxuXFx0dmFyIHB6ID0gbmV3IEN1YmljUG9seSgpO1xcblxcblxcdGZ1bmN0aW9uIENhdG11bGxSb21DdXJ2ZTMoIHBvaW50cywgY2xvc2VkLCBjdXJ2ZVR5cGUsIHRlbnNpb24gKSB7XFxuXFxuXFx0XFx0Q3VydmUuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdDYXRtdWxsUm9tQ3VydmUzJztcXG5cXG5cXHRcXHR0aGlzLnBvaW50cyA9IHBvaW50cyB8fCBbXTtcXG5cXHRcXHR0aGlzLmNsb3NlZCA9IGNsb3NlZCB8fCBmYWxzZTtcXG5cXHRcXHR0aGlzLmN1cnZlVHlwZSA9IGN1cnZlVHlwZSB8fCAnY2VudHJpcGV0YWwnO1xcblxcdFxcdHRoaXMudGVuc2lvbiA9IHRlbnNpb24gfHwgMC41O1xcblxcblxcdH1cXG5cXG5cXHRDYXRtdWxsUm9tQ3VydmUzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApO1xcblxcdENhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2F0bXVsbFJvbUN1cnZlMztcXG5cXG5cXHRDYXRtdWxsUm9tQ3VydmUzLnByb3RvdHlwZS5pc0NhdG11bGxSb21DdXJ2ZTMgPSB0cnVlO1xcblxcblxcdENhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHR2YXIgcG9pbnQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcXG5cXHRcXHR2YXIgbCA9IHBvaW50cy5sZW5ndGg7XFxuXFxuXFx0XFx0dmFyIHAgPSAoIGwgLSAoIHRoaXMuY2xvc2VkID8gMCA6IDEgKSApICogdDtcXG5cXHRcXHR2YXIgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwICk7XFxuXFx0XFx0dmFyIHdlaWdodCA9IHAgLSBpbnRQb2ludDtcXG5cXG5cXHRcXHRpZiAoIHRoaXMuY2xvc2VkICkge1xcblxcblxcdFxcdFxcdGludFBvaW50ICs9IGludFBvaW50ID4gMCA/IDAgOiAoIE1hdGguZmxvb3IoIE1hdGguYWJzKCBpbnRQb2ludCApIC8gcG9pbnRzLmxlbmd0aCApICsgMSApICogcG9pbnRzLmxlbmd0aDtcXG5cXG5cXHRcXHR9IGVsc2UgaWYgKCB3ZWlnaHQgPT09IDAgJiYgaW50UG9pbnQgPT09IGwgLSAxICkge1xcblxcblxcdFxcdFxcdGludFBvaW50ID0gbCAtIDI7XFxuXFx0XFx0XFx0d2VpZ2h0ID0gMTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dmFyIHAwLCBwMSwgcDIsIHAzOyAvLyA0IHBvaW50c1xcblxcblxcdFxcdGlmICggdGhpcy5jbG9zZWQgfHwgaW50UG9pbnQgPiAwICkge1xcblxcblxcdFxcdFxcdHAwID0gcG9pbnRzWyAoIGludFBvaW50IC0gMSApICUgbCBdO1xcblxcblxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0Ly8gZXh0cmFwb2xhdGUgZmlyc3QgcG9pbnRcXG5cXHRcXHRcXHR0bXAuc3ViVmVjdG9ycyggcG9pbnRzWyAwIF0sIHBvaW50c1sgMSBdICkuYWRkKCBwb2ludHNbIDAgXSApO1xcblxcdFxcdFxcdHAwID0gdG1wO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRwMSA9IHBvaW50c1sgaW50UG9pbnQgJSBsIF07XFxuXFx0XFx0cDIgPSBwb2ludHNbICggaW50UG9pbnQgKyAxICkgJSBsIF07XFxuXFxuXFx0XFx0aWYgKCB0aGlzLmNsb3NlZCB8fCBpbnRQb2ludCArIDIgPCBsICkge1xcblxcblxcdFxcdFxcdHAzID0gcG9pbnRzWyAoIGludFBvaW50ICsgMiApICUgbCBdO1xcblxcblxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0Ly8gZXh0cmFwb2xhdGUgbGFzdCBwb2ludFxcblxcdFxcdFxcdHRtcC5zdWJWZWN0b3JzKCBwb2ludHNbIGwgLSAxIF0sIHBvaW50c1sgbCAtIDIgXSApLmFkZCggcG9pbnRzWyBsIC0gMSBdICk7XFxuXFx0XFx0XFx0cDMgPSB0bXA7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggdGhpcy5jdXJ2ZVR5cGUgPT09ICdjZW50cmlwZXRhbCcgfHwgdGhpcy5jdXJ2ZVR5cGUgPT09ICdjaG9yZGFsJyApIHtcXG5cXG5cXHRcXHRcXHQvLyBpbml0IENlbnRyaXBldGFsIC8gQ2hvcmRhbCBDYXRtdWxsLVJvbVxcblxcdFxcdFxcdHZhciBwb3cgPSB0aGlzLmN1cnZlVHlwZSA9PT0gJ2Nob3JkYWwnID8gMC41IDogMC4yNTtcXG5cXHRcXHRcXHR2YXIgZHQwID0gTWF0aC5wb3coIHAwLmRpc3RhbmNlVG9TcXVhcmVkKCBwMSApLCBwb3cgKTtcXG5cXHRcXHRcXHR2YXIgZHQxID0gTWF0aC5wb3coIHAxLmRpc3RhbmNlVG9TcXVhcmVkKCBwMiApLCBwb3cgKTtcXG5cXHRcXHRcXHR2YXIgZHQyID0gTWF0aC5wb3coIHAyLmRpc3RhbmNlVG9TcXVhcmVkKCBwMyApLCBwb3cgKTtcXG5cXG5cXHRcXHRcXHQvLyBzYWZldHkgY2hlY2sgZm9yIHJlcGVhdGVkIHBvaW50c1xcblxcdFxcdFxcdGlmICggZHQxIDwgMWUtNCApIGR0MSA9IDEuMDtcXG5cXHRcXHRcXHRpZiAoIGR0MCA8IDFlLTQgKSBkdDAgPSBkdDE7XFxuXFx0XFx0XFx0aWYgKCBkdDIgPCAxZS00ICkgZHQyID0gZHQxO1xcblxcblxcdFxcdFxcdHB4LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueCwgcDEueCwgcDIueCwgcDMueCwgZHQwLCBkdDEsIGR0MiApO1xcblxcdFxcdFxcdHB5LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueSwgcDEueSwgcDIueSwgcDMueSwgZHQwLCBkdDEsIGR0MiApO1xcblxcdFxcdFxcdHB6LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueiwgcDEueiwgcDIueiwgcDMueiwgZHQwLCBkdDEsIGR0MiApO1xcblxcblxcdFxcdH0gZWxzZSBpZiAoIHRoaXMuY3VydmVUeXBlID09PSAnY2F0bXVsbHJvbScgKSB7XFxuXFxuXFx0XFx0XFx0cHguaW5pdENhdG11bGxSb20oIHAwLngsIHAxLngsIHAyLngsIHAzLngsIHRoaXMudGVuc2lvbiApO1xcblxcdFxcdFxcdHB5LmluaXRDYXRtdWxsUm9tKCBwMC55LCBwMS55LCBwMi55LCBwMy55LCB0aGlzLnRlbnNpb24gKTtcXG5cXHRcXHRcXHRwei5pbml0Q2F0bXVsbFJvbSggcDAueiwgcDEueiwgcDIueiwgcDMueiwgdGhpcy50ZW5zaW9uICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHBvaW50LnNldChcXG5cXHRcXHRcXHRweC5jYWxjKCB3ZWlnaHQgKSxcXG5cXHRcXHRcXHRweS5jYWxjKCB3ZWlnaHQgKSxcXG5cXHRcXHRcXHRwei5jYWxjKCB3ZWlnaHQgKVxcblxcdFxcdCk7XFxuXFxuXFx0XFx0cmV0dXJuIHBvaW50O1xcblxcblxcdH07XFxuXFxuXFx0Q2F0bXVsbFJvbUN1cnZlMy5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdEN1cnZlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcblxcblxcdFxcdHRoaXMucG9pbnRzID0gW107XFxuXFxuXFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gc291cmNlLnBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdHZhciBwb2ludCA9IHNvdXJjZS5wb2ludHNbIGkgXTtcXG5cXG5cXHRcXHRcXHR0aGlzLnBvaW50cy5wdXNoKCBwb2ludC5jbG9uZSgpICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuY2xvc2VkID0gc291cmNlLmNsb3NlZDtcXG5cXHRcXHR0aGlzLmN1cnZlVHlwZSA9IHNvdXJjZS5jdXJ2ZVR5cGU7XFxuXFx0XFx0dGhpcy50ZW5zaW9uID0gc291cmNlLnRlbnNpb247XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0fTtcXG5cXG5cXHRDYXRtdWxsUm9tQ3VydmUzLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0dmFyIGRhdGEgPSBDdXJ2ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHRkYXRhLnBvaW50cyA9IFtdO1xcblxcblxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHBvaW50ID0gdGhpcy5wb2ludHNbIGkgXTtcXG5cXHRcXHRcXHRkYXRhLnBvaW50cy5wdXNoKCBwb2ludC50b0FycmF5KCkgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZGF0YS5jbG9zZWQgPSB0aGlzLmNsb3NlZDtcXG5cXHRcXHRkYXRhLmN1cnZlVHlwZSA9IHRoaXMuY3VydmVUeXBlO1xcblxcdFxcdGRhdGEudGVuc2lvbiA9IHRoaXMudGVuc2lvbjtcXG5cXG5cXHRcXHRyZXR1cm4gZGF0YTtcXG5cXG5cXHR9O1xcblxcblxcdENhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24gKCBqc29uICkge1xcblxcblxcdFxcdEN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKCB0aGlzLCBqc29uICk7XFxuXFxuXFx0XFx0dGhpcy5wb2ludHMgPSBbXTtcXG5cXG5cXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLnBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdHZhciBwb2ludCA9IGpzb24ucG9pbnRzWyBpIF07XFxuXFx0XFx0XFx0dGhpcy5wb2ludHMucHVzaCggbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkoIHBvaW50ICkgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5jbG9zZWQgPSBqc29uLmNsb3NlZDtcXG5cXHRcXHR0aGlzLmN1cnZlVHlwZSA9IGpzb24uY3VydmVUeXBlO1xcblxcdFxcdHRoaXMudGVuc2lvbiA9IGpzb24udGVuc2lvbjtcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcXG5cXHQgKlxcblxcdCAqIEJlemllciBDdXJ2ZXMgZm9ybXVsYXMgb2J0YWluZWQgZnJvbVxcblxcdCAqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQsOpemllcl9jdXJ2ZVxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIENhdG11bGxSb20oIHQsIHAwLCBwMSwgcDIsIHAzICkge1xcblxcblxcdFxcdHZhciB2MCA9ICggcDIgLSBwMCApICogMC41O1xcblxcdFxcdHZhciB2MSA9ICggcDMgLSBwMSApICogMC41O1xcblxcdFxcdHZhciB0MiA9IHQgKiB0O1xcblxcdFxcdHZhciB0MyA9IHQgKiB0MjtcXG5cXHRcXHRyZXR1cm4gKCAyICogcDEgLSAyICogcDIgKyB2MCArIHYxICkgKiB0MyArICggLSAzICogcDEgKyAzICogcDIgLSAyICogdjAgLSB2MSApICogdDIgKyB2MCAqIHQgKyBwMTtcXG5cXG5cXHR9XFxuXFxuXFx0Ly9cXG5cXG5cXHRmdW5jdGlvbiBRdWFkcmF0aWNCZXppZXJQMCggdCwgcCApIHtcXG5cXG5cXHRcXHR2YXIgayA9IDEgLSB0O1xcblxcdFxcdHJldHVybiBrICogayAqIHA7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIFF1YWRyYXRpY0JlemllclAxKCB0LCBwICkge1xcblxcblxcdFxcdHJldHVybiAyICogKCAxIC0gdCApICogdCAqIHA7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIFF1YWRyYXRpY0JlemllclAyKCB0LCBwICkge1xcblxcblxcdFxcdHJldHVybiB0ICogdCAqIHA7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIFF1YWRyYXRpY0JlemllciggdCwgcDAsIHAxLCBwMiApIHtcXG5cXG5cXHRcXHRyZXR1cm4gUXVhZHJhdGljQmV6aWVyUDAoIHQsIHAwICkgKyBRdWFkcmF0aWNCZXppZXJQMSggdCwgcDEgKSArXFxuXFx0XFx0XFx0UXVhZHJhdGljQmV6aWVyUDIoIHQsIHAyICk7XFxuXFxuXFx0fVxcblxcblxcdC8vXFxuXFxuXFx0ZnVuY3Rpb24gQ3ViaWNCZXppZXJQMCggdCwgcCApIHtcXG5cXG5cXHRcXHR2YXIgayA9IDEgLSB0O1xcblxcdFxcdHJldHVybiBrICogayAqIGsgKiBwO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBDdWJpY0JlemllclAxKCB0LCBwICkge1xcblxcblxcdFxcdHZhciBrID0gMSAtIHQ7XFxuXFx0XFx0cmV0dXJuIDMgKiBrICogayAqIHQgKiBwO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBDdWJpY0JlemllclAyKCB0LCBwICkge1xcblxcblxcdFxcdHJldHVybiAzICogKCAxIC0gdCApICogdCAqIHQgKiBwO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBDdWJpY0JlemllclAzKCB0LCBwICkge1xcblxcblxcdFxcdHJldHVybiB0ICogdCAqIHQgKiBwO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBDdWJpY0JlemllciggdCwgcDAsIHAxLCBwMiwgcDMgKSB7XFxuXFxuXFx0XFx0cmV0dXJuIEN1YmljQmV6aWVyUDAoIHQsIHAwICkgKyBDdWJpY0JlemllclAxKCB0LCBwMSApICsgQ3ViaWNCZXppZXJQMiggdCwgcDIgKSArXFxuXFx0XFx0XFx0Q3ViaWNCZXppZXJQMyggdCwgcDMgKTtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gQ3ViaWNCZXppZXJDdXJ2ZSggdjAsIHYxLCB2MiwgdjMgKSB7XFxuXFxuXFx0XFx0Q3VydmUuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdDdWJpY0JlemllckN1cnZlJztcXG5cXG5cXHRcXHR0aGlzLnYwID0gdjAgfHwgbmV3IFZlY3RvcjIoKTtcXG5cXHRcXHR0aGlzLnYxID0gdjEgfHwgbmV3IFZlY3RvcjIoKTtcXG5cXHRcXHR0aGlzLnYyID0gdjIgfHwgbmV3IFZlY3RvcjIoKTtcXG5cXHRcXHR0aGlzLnYzID0gdjMgfHwgbmV3IFZlY3RvcjIoKTtcXG5cXG5cXHR9XFxuXFxuXFx0Q3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKTtcXG5cXHRDdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEN1YmljQmV6aWVyQ3VydmU7XFxuXFxuXFx0Q3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuaXNDdWJpY0JlemllckN1cnZlID0gdHJ1ZTtcXG5cXG5cXHRDdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0dmFyIHBvaW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjIoKTtcXG5cXG5cXHRcXHR2YXIgdjAgPSB0aGlzLnYwLCB2MSA9IHRoaXMudjEsIHYyID0gdGhpcy52MiwgdjMgPSB0aGlzLnYzO1xcblxcblxcdFxcdHBvaW50LnNldChcXG5cXHRcXHRcXHRDdWJpY0JlemllciggdCwgdjAueCwgdjEueCwgdjIueCwgdjMueCApLFxcblxcdFxcdFxcdEN1YmljQmV6aWVyKCB0LCB2MC55LCB2MS55LCB2Mi55LCB2My55IClcXG5cXHRcXHQpO1xcblxcblxcdFxcdHJldHVybiBwb2ludDtcXG5cXG5cXHR9O1xcblxcblxcdEN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRDdXJ2ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXG5cXG5cXHRcXHR0aGlzLnYwLmNvcHkoIHNvdXJjZS52MCApO1xcblxcdFxcdHRoaXMudjEuY29weSggc291cmNlLnYxICk7XFxuXFx0XFx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcXG5cXHRcXHR0aGlzLnYzLmNvcHkoIHNvdXJjZS52MyApO1xcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdH07XFxuXFxuXFx0Q3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdHZhciBkYXRhID0gQ3VydmUucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0ZGF0YS52MCA9IHRoaXMudjAudG9BcnJheSgpO1xcblxcdFxcdGRhdGEudjEgPSB0aGlzLnYxLnRvQXJyYXkoKTtcXG5cXHRcXHRkYXRhLnYyID0gdGhpcy52Mi50b0FycmF5KCk7XFxuXFx0XFx0ZGF0YS52MyA9IHRoaXMudjMudG9BcnJheSgpO1xcblxcblxcdFxcdHJldHVybiBkYXRhO1xcblxcblxcdH07XFxuXFxuXFx0Q3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiAoIGpzb24gKSB7XFxuXFxuXFx0XFx0Q3VydmUucHJvdG90eXBlLmZyb21KU09OLmNhbGwoIHRoaXMsIGpzb24gKTtcXG5cXG5cXHRcXHR0aGlzLnYwLmZyb21BcnJheSgganNvbi52MCApO1xcblxcdFxcdHRoaXMudjEuZnJvbUFycmF5KCBqc29uLnYxICk7XFxuXFx0XFx0dGhpcy52Mi5mcm9tQXJyYXkoIGpzb24udjIgKTtcXG5cXHRcXHR0aGlzLnYzLmZyb21BcnJheSgganNvbi52MyApO1xcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdH07XFxuXFxuXFx0ZnVuY3Rpb24gQ3ViaWNCZXppZXJDdXJ2ZTMoIHYwLCB2MSwgdjIsIHYzICkge1xcblxcblxcdFxcdEN1cnZlLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnQ3ViaWNCZXppZXJDdXJ2ZTMnO1xcblxcblxcdFxcdHRoaXMudjAgPSB2MCB8fCBuZXcgVmVjdG9yMygpO1xcblxcdFxcdHRoaXMudjEgPSB2MSB8fCBuZXcgVmVjdG9yMygpO1xcblxcdFxcdHRoaXMudjIgPSB2MiB8fCBuZXcgVmVjdG9yMygpO1xcblxcdFxcdHRoaXMudjMgPSB2MyB8fCBuZXcgVmVjdG9yMygpO1xcblxcblxcdH1cXG5cXG5cXHRDdWJpY0JlemllckN1cnZlMy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKTtcXG5cXHRDdWJpY0JlemllckN1cnZlMy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDdWJpY0JlemllckN1cnZlMztcXG5cXG5cXHRDdWJpY0JlemllckN1cnZlMy5wcm90b3R5cGUuaXNDdWJpY0JlemllckN1cnZlMyA9IHRydWU7XFxuXFxuXFx0Q3ViaWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHR2YXIgcG9pbnQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdHZhciB2MCA9IHRoaXMudjAsIHYxID0gdGhpcy52MSwgdjIgPSB0aGlzLnYyLCB2MyA9IHRoaXMudjM7XFxuXFxuXFx0XFx0cG9pbnQuc2V0KFxcblxcdFxcdFxcdEN1YmljQmV6aWVyKCB0LCB2MC54LCB2MS54LCB2Mi54LCB2My54ICksXFxuXFx0XFx0XFx0Q3ViaWNCZXppZXIoIHQsIHYwLnksIHYxLnksIHYyLnksIHYzLnkgKSxcXG5cXHRcXHRcXHRDdWJpY0JlemllciggdCwgdjAueiwgdjEueiwgdjIueiwgdjMueiApXFxuXFx0XFx0KTtcXG5cXG5cXHRcXHRyZXR1cm4gcG9pbnQ7XFxuXFxuXFx0fTtcXG5cXG5cXHRDdWJpY0JlemllckN1cnZlMy5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdEN1cnZlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcblxcblxcdFxcdHRoaXMudjAuY29weSggc291cmNlLnYwICk7XFxuXFx0XFx0dGhpcy52MS5jb3B5KCBzb3VyY2UudjEgKTtcXG5cXHRcXHR0aGlzLnYyLmNvcHkoIHNvdXJjZS52MiApO1xcblxcdFxcdHRoaXMudjMuY29weSggc291cmNlLnYzICk7XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0fTtcXG5cXG5cXHRDdWJpY0JlemllckN1cnZlMy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdHZhciBkYXRhID0gQ3VydmUucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0ZGF0YS52MCA9IHRoaXMudjAudG9BcnJheSgpO1xcblxcdFxcdGRhdGEudjEgPSB0aGlzLnYxLnRvQXJyYXkoKTtcXG5cXHRcXHRkYXRhLnYyID0gdGhpcy52Mi50b0FycmF5KCk7XFxuXFx0XFx0ZGF0YS52MyA9IHRoaXMudjMudG9BcnJheSgpO1xcblxcblxcdFxcdHJldHVybiBkYXRhO1xcblxcblxcdH07XFxuXFxuXFx0Q3ViaWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24gKCBqc29uICkge1xcblxcblxcdFxcdEN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKCB0aGlzLCBqc29uICk7XFxuXFxuXFx0XFx0dGhpcy52MC5mcm9tQXJyYXkoIGpzb24udjAgKTtcXG5cXHRcXHR0aGlzLnYxLmZyb21BcnJheSgganNvbi52MSApO1xcblxcdFxcdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XFxuXFx0XFx0dGhpcy52My5mcm9tQXJyYXkoIGpzb24udjMgKTtcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHR9O1xcblxcblxcdGZ1bmN0aW9uIExpbmVDdXJ2ZSggdjEsIHYyICkge1xcblxcblxcdFxcdEN1cnZlLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnTGluZUN1cnZlJztcXG5cXG5cXHRcXHR0aGlzLnYxID0gdjEgfHwgbmV3IFZlY3RvcjIoKTtcXG5cXHRcXHR0aGlzLnYyID0gdjIgfHwgbmV3IFZlY3RvcjIoKTtcXG5cXG5cXHR9XFxuXFxuXFx0TGluZUN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApO1xcblxcdExpbmVDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaW5lQ3VydmU7XFxuXFxuXFx0TGluZUN1cnZlLnByb3RvdHlwZS5pc0xpbmVDdXJ2ZSA9IHRydWU7XFxuXFxuXFx0TGluZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0dmFyIHBvaW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjIoKTtcXG5cXG5cXHRcXHRpZiAoIHQgPT09IDEgKSB7XFxuXFxuXFx0XFx0XFx0cG9pbnQuY29weSggdGhpcy52MiApO1xcblxcblxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0cG9pbnQuY29weSggdGhpcy52MiApLnN1YiggdGhpcy52MSApO1xcblxcdFxcdFxcdHBvaW50Lm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnYxICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBwb2ludDtcXG5cXG5cXHR9O1xcblxcblxcdC8vIExpbmUgY3VydmUgaXMgbGluZWFyLCBzbyB3ZSBjYW4gb3ZlcndyaXRlIGRlZmF1bHQgZ2V0UG9pbnRBdFxcblxcblxcdExpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnRBdCA9IGZ1bmN0aW9uICggdSwgb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQoIHUsIG9wdGlvbmFsVGFyZ2V0ICk7XFxuXFxuXFx0fTtcXG5cXG5cXHRMaW5lQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiAoIC8qIHQgKi8gKSB7XFxuXFxuXFx0XFx0dmFyIHRhbmdlbnQgPSB0aGlzLnYyLmNsb25lKCkuc3ViKCB0aGlzLnYxICk7XFxuXFxuXFx0XFx0cmV0dXJuIHRhbmdlbnQubm9ybWFsaXplKCk7XFxuXFxuXFx0fTtcXG5cXG5cXHRMaW5lQ3VydmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRDdXJ2ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXG5cXG5cXHRcXHR0aGlzLnYxLmNvcHkoIHNvdXJjZS52MSApO1xcblxcdFxcdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0fTtcXG5cXG5cXHRMaW5lQ3VydmUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHR2YXIgZGF0YSA9IEN1cnZlLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xcblxcblxcdFxcdGRhdGEudjEgPSB0aGlzLnYxLnRvQXJyYXkoKTtcXG5cXHRcXHRkYXRhLnYyID0gdGhpcy52Mi50b0FycmF5KCk7XFxuXFxuXFx0XFx0cmV0dXJuIGRhdGE7XFxuXFxuXFx0fTtcXG5cXG5cXHRMaW5lQ3VydmUucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24gKCBqc29uICkge1xcblxcblxcdFxcdEN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKCB0aGlzLCBqc29uICk7XFxuXFxuXFx0XFx0dGhpcy52MS5mcm9tQXJyYXkoIGpzb24udjEgKTtcXG5cXHRcXHR0aGlzLnYyLmZyb21BcnJheSgganNvbi52MiApO1xcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdH07XFxuXFxuXFx0ZnVuY3Rpb24gTGluZUN1cnZlMyggdjEsIHYyICkge1xcblxcblxcdFxcdEN1cnZlLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnTGluZUN1cnZlMyc7XFxuXFxuXFx0XFx0dGhpcy52MSA9IHYxIHx8IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0dGhpcy52MiA9IHYyIHx8IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0fVxcblxcblxcdExpbmVDdXJ2ZTMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XFxuXFx0TGluZUN1cnZlMy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaW5lQ3VydmUzO1xcblxcblxcdExpbmVDdXJ2ZTMucHJvdG90eXBlLmlzTGluZUN1cnZlMyA9IHRydWU7XFxuXFxuXFx0TGluZUN1cnZlMy5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdHZhciBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0aWYgKCB0ID09PSAxICkge1xcblxcblxcdFxcdFxcdHBvaW50LmNvcHkoIHRoaXMudjIgKTtcXG5cXG5cXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdHBvaW50LmNvcHkoIHRoaXMudjIgKS5zdWIoIHRoaXMudjEgKTtcXG5cXHRcXHRcXHRwb2ludC5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy52MSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gcG9pbnQ7XFxuXFxuXFx0fTtcXG5cXG5cXHQvLyBMaW5lIGN1cnZlIGlzIGxpbmVhciwgc28gd2UgY2FuIG92ZXJ3cml0ZSBkZWZhdWx0IGdldFBvaW50QXRcXG5cXG5cXHRMaW5lQ3VydmUzLnByb3RvdHlwZS5nZXRQb2ludEF0ID0gZnVuY3Rpb24gKCB1LCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcy5nZXRQb2ludCggdSwgb3B0aW9uYWxUYXJnZXQgKTtcXG5cXG5cXHR9O1xcblxcblxcdExpbmVDdXJ2ZTMucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRDdXJ2ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXG5cXG5cXHRcXHR0aGlzLnYxLmNvcHkoIHNvdXJjZS52MSApO1xcblxcdFxcdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0fTtcXG5cXG5cXHRMaW5lQ3VydmUzLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0dmFyIGRhdGEgPSBDdXJ2ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHRkYXRhLnYxID0gdGhpcy52MS50b0FycmF5KCk7XFxuXFx0XFx0ZGF0YS52MiA9IHRoaXMudjIudG9BcnJheSgpO1xcblxcblxcdFxcdHJldHVybiBkYXRhO1xcblxcblxcdH07XFxuXFxuXFx0TGluZUN1cnZlMy5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiAoIGpzb24gKSB7XFxuXFxuXFx0XFx0Q3VydmUucHJvdG90eXBlLmZyb21KU09OLmNhbGwoIHRoaXMsIGpzb24gKTtcXG5cXG5cXHRcXHR0aGlzLnYxLmZyb21BcnJheSgganNvbi52MSApO1xcblxcdFxcdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0fTtcXG5cXG5cXHRmdW5jdGlvbiBRdWFkcmF0aWNCZXppZXJDdXJ2ZSggdjAsIHYxLCB2MiApIHtcXG5cXG5cXHRcXHRDdXJ2ZS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1F1YWRyYXRpY0JlemllckN1cnZlJztcXG5cXG5cXHRcXHR0aGlzLnYwID0gdjAgfHwgbmV3IFZlY3RvcjIoKTtcXG5cXHRcXHR0aGlzLnYxID0gdjEgfHwgbmV3IFZlY3RvcjIoKTtcXG5cXHRcXHR0aGlzLnYyID0gdjIgfHwgbmV3IFZlY3RvcjIoKTtcXG5cXG5cXHR9XFxuXFxuXFx0UXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XFxuXFx0UXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUXVhZHJhdGljQmV6aWVyQ3VydmU7XFxuXFxuXFx0UXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmlzUXVhZHJhdGljQmV6aWVyQ3VydmUgPSB0cnVlO1xcblxcblxcdFF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0dmFyIHBvaW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjIoKTtcXG5cXG5cXHRcXHR2YXIgdjAgPSB0aGlzLnYwLCB2MSA9IHRoaXMudjEsIHYyID0gdGhpcy52MjtcXG5cXG5cXHRcXHRwb2ludC5zZXQoXFxuXFx0XFx0XFx0UXVhZHJhdGljQmV6aWVyKCB0LCB2MC54LCB2MS54LCB2Mi54ICksXFxuXFx0XFx0XFx0UXVhZHJhdGljQmV6aWVyKCB0LCB2MC55LCB2MS55LCB2Mi55IClcXG5cXHRcXHQpO1xcblxcblxcdFxcdHJldHVybiBwb2ludDtcXG5cXG5cXHR9O1xcblxcblxcdFF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxuXFxuXFx0XFx0Q3VydmUucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxuXFxuXFx0XFx0dGhpcy52MC5jb3B5KCBzb3VyY2UudjAgKTtcXG5cXHRcXHR0aGlzLnYxLmNvcHkoIHNvdXJjZS52MSApO1xcblxcdFxcdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0fTtcXG5cXG5cXHRRdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdHZhciBkYXRhID0gQ3VydmUucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0ZGF0YS52MCA9IHRoaXMudjAudG9BcnJheSgpO1xcblxcdFxcdGRhdGEudjEgPSB0aGlzLnYxLnRvQXJyYXkoKTtcXG5cXHRcXHRkYXRhLnYyID0gdGhpcy52Mi50b0FycmF5KCk7XFxuXFxuXFx0XFx0cmV0dXJuIGRhdGE7XFxuXFxuXFx0fTtcXG5cXG5cXHRRdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiAoIGpzb24gKSB7XFxuXFxuXFx0XFx0Q3VydmUucHJvdG90eXBlLmZyb21KU09OLmNhbGwoIHRoaXMsIGpzb24gKTtcXG5cXG5cXHRcXHR0aGlzLnYwLmZyb21BcnJheSgganNvbi52MCApO1xcblxcdFxcdHRoaXMudjEuZnJvbUFycmF5KCBqc29uLnYxICk7XFxuXFx0XFx0dGhpcy52Mi5mcm9tQXJyYXkoIGpzb24udjIgKTtcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHR9O1xcblxcblxcdGZ1bmN0aW9uIFF1YWRyYXRpY0JlemllckN1cnZlMyggdjAsIHYxLCB2MiApIHtcXG5cXG5cXHRcXHRDdXJ2ZS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1F1YWRyYXRpY0JlemllckN1cnZlMyc7XFxuXFxuXFx0XFx0dGhpcy52MCA9IHYwIHx8IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0dGhpcy52MSA9IHYxIHx8IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0dGhpcy52MiA9IHYyIHx8IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0fVxcblxcblxcdFF1YWRyYXRpY0JlemllckN1cnZlMy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKTtcXG5cXHRRdWFkcmF0aWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUXVhZHJhdGljQmV6aWVyQ3VydmUzO1xcblxcblxcdFF1YWRyYXRpY0JlemllckN1cnZlMy5wcm90b3R5cGUuaXNRdWFkcmF0aWNCZXppZXJDdXJ2ZTMgPSB0cnVlO1xcblxcblxcdFF1YWRyYXRpY0JlemllckN1cnZlMy5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdHZhciBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0dmFyIHYwID0gdGhpcy52MCwgdjEgPSB0aGlzLnYxLCB2MiA9IHRoaXMudjI7XFxuXFxuXFx0XFx0cG9pbnQuc2V0KFxcblxcdFxcdFxcdFF1YWRyYXRpY0JlemllciggdCwgdjAueCwgdjEueCwgdjIueCApLFxcblxcdFxcdFxcdFF1YWRyYXRpY0JlemllciggdCwgdjAueSwgdjEueSwgdjIueSApLFxcblxcdFxcdFxcdFF1YWRyYXRpY0JlemllciggdCwgdjAueiwgdjEueiwgdjIueiApXFxuXFx0XFx0KTtcXG5cXG5cXHRcXHRyZXR1cm4gcG9pbnQ7XFxuXFxuXFx0fTtcXG5cXG5cXHRRdWFkcmF0aWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRDdXJ2ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXG5cXG5cXHRcXHR0aGlzLnYwLmNvcHkoIHNvdXJjZS52MCApO1xcblxcdFxcdHRoaXMudjEuY29weSggc291cmNlLnYxICk7XFxuXFx0XFx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHR9O1xcblxcblxcdFF1YWRyYXRpY0JlemllckN1cnZlMy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdHZhciBkYXRhID0gQ3VydmUucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0ZGF0YS52MCA9IHRoaXMudjAudG9BcnJheSgpO1xcblxcdFxcdGRhdGEudjEgPSB0aGlzLnYxLnRvQXJyYXkoKTtcXG5cXHRcXHRkYXRhLnYyID0gdGhpcy52Mi50b0FycmF5KCk7XFxuXFxuXFx0XFx0cmV0dXJuIGRhdGE7XFxuXFxuXFx0fTtcXG5cXG5cXHRRdWFkcmF0aWNCZXppZXJDdXJ2ZTMucHJvdG90eXBlLmZyb21KU09OID0gZnVuY3Rpb24gKCBqc29uICkge1xcblxcblxcdFxcdEN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKCB0aGlzLCBqc29uICk7XFxuXFxuXFx0XFx0dGhpcy52MC5mcm9tQXJyYXkoIGpzb24udjAgKTtcXG5cXHRcXHR0aGlzLnYxLmZyb21BcnJheSgganNvbi52MSApO1xcblxcdFxcdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0fTtcXG5cXG5cXHRmdW5jdGlvbiBTcGxpbmVDdXJ2ZSggcG9pbnRzIC8qIGFycmF5IG9mIFZlY3RvcjIgKi8gKSB7XFxuXFxuXFx0XFx0Q3VydmUuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdTcGxpbmVDdXJ2ZSc7XFxuXFxuXFx0XFx0dGhpcy5wb2ludHMgPSBwb2ludHMgfHwgW107XFxuXFxuXFx0fVxcblxcblxcdFNwbGluZUN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApO1xcblxcdFNwbGluZUN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNwbGluZUN1cnZlO1xcblxcblxcdFNwbGluZUN1cnZlLnByb3RvdHlwZS5pc1NwbGluZUN1cnZlID0gdHJ1ZTtcXG5cXG5cXHRTcGxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdHZhciBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IyKCk7XFxuXFxuXFx0XFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xcblxcdFxcdHZhciBwID0gKCBwb2ludHMubGVuZ3RoIC0gMSApICogdDtcXG5cXG5cXHRcXHR2YXIgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwICk7XFxuXFx0XFx0dmFyIHdlaWdodCA9IHAgLSBpbnRQb2ludDtcXG5cXG5cXHRcXHR2YXIgcDAgPSBwb2ludHNbIGludFBvaW50ID09PSAwID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDEgXTtcXG5cXHRcXHR2YXIgcDEgPSBwb2ludHNbIGludFBvaW50IF07XFxuXFx0XFx0dmFyIHAyID0gcG9pbnRzWyBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAyID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDEgXTtcXG5cXHRcXHR2YXIgcDMgPSBwb2ludHNbIGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDMgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMiBdO1xcblxcblxcdFxcdHBvaW50LnNldChcXG5cXHRcXHRcXHRDYXRtdWxsUm9tKCB3ZWlnaHQsIHAwLngsIHAxLngsIHAyLngsIHAzLnggKSxcXG5cXHRcXHRcXHRDYXRtdWxsUm9tKCB3ZWlnaHQsIHAwLnksIHAxLnksIHAyLnksIHAzLnkgKVxcblxcdFxcdCk7XFxuXFxuXFx0XFx0cmV0dXJuIHBvaW50O1xcblxcblxcdH07XFxuXFxuXFx0U3BsaW5lQ3VydmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRDdXJ2ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXG5cXG5cXHRcXHR0aGlzLnBvaW50cyA9IFtdO1xcblxcblxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHNvdXJjZS5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcG9pbnQgPSBzb3VyY2UucG9pbnRzWyBpIF07XFxuXFxuXFx0XFx0XFx0dGhpcy5wb2ludHMucHVzaCggcG9pbnQuY2xvbmUoKSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHR9O1xcblxcblxcdFNwbGluZUN1cnZlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0dmFyIGRhdGEgPSBDdXJ2ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHRkYXRhLnBvaW50cyA9IFtdO1xcblxcblxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHBvaW50ID0gdGhpcy5wb2ludHNbIGkgXTtcXG5cXHRcXHRcXHRkYXRhLnBvaW50cy5wdXNoKCBwb2ludC50b0FycmF5KCkgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGRhdGE7XFxuXFxuXFx0fTtcXG5cXG5cXHRTcGxpbmVDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiAoIGpzb24gKSB7XFxuXFxuXFx0XFx0Q3VydmUucHJvdG90eXBlLmZyb21KU09OLmNhbGwoIHRoaXMsIGpzb24gKTtcXG5cXG5cXHRcXHR0aGlzLnBvaW50cyA9IFtdO1xcblxcblxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHBvaW50ID0ganNvbi5wb2ludHNbIGkgXTtcXG5cXHRcXHRcXHR0aGlzLnBvaW50cy5wdXNoKCBuZXcgVmVjdG9yMigpLmZyb21BcnJheSggcG9pbnQgKSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHR9O1xcblxcblxcblxcblxcdHZhciBDdXJ2ZXMgPSBPYmplY3QuZnJlZXplKHtcXG5cXHRcXHRBcmNDdXJ2ZTogQXJjQ3VydmUsXFxuXFx0XFx0Q2F0bXVsbFJvbUN1cnZlMzogQ2F0bXVsbFJvbUN1cnZlMyxcXG5cXHRcXHRDdWJpY0JlemllckN1cnZlOiBDdWJpY0JlemllckN1cnZlLFxcblxcdFxcdEN1YmljQmV6aWVyQ3VydmUzOiBDdWJpY0JlemllckN1cnZlMyxcXG5cXHRcXHRFbGxpcHNlQ3VydmU6IEVsbGlwc2VDdXJ2ZSxcXG5cXHRcXHRMaW5lQ3VydmU6IExpbmVDdXJ2ZSxcXG5cXHRcXHRMaW5lQ3VydmUzOiBMaW5lQ3VydmUzLFxcblxcdFxcdFF1YWRyYXRpY0JlemllckN1cnZlOiBRdWFkcmF0aWNCZXppZXJDdXJ2ZSxcXG5cXHRcXHRRdWFkcmF0aWNCZXppZXJDdXJ2ZTM6IFF1YWRyYXRpY0JlemllckN1cnZlMyxcXG5cXHRcXHRTcGxpbmVDdXJ2ZTogU3BsaW5lQ3VydmVcXG5cXHR9KTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXFxuXFx0ICpcXG5cXHQgKiovXFxuXFxuXFx0LyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxuXFx0ICpcXHRDdXJ2ZWQgUGF0aCAtIGEgY3VydmUgcGF0aCBpcyBzaW1wbHkgYSBhcnJheSBvZiBjb25uZWN0ZWRcXG5cXHQgKiAgY3VydmVzLCBidXQgcmV0YWlucyB0aGUgYXBpIG9mIGEgY3VydmVcXG5cXHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuXFxuXFx0ZnVuY3Rpb24gQ3VydmVQYXRoKCkge1xcblxcblxcdFxcdEN1cnZlLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnQ3VydmVQYXRoJztcXG5cXG5cXHRcXHR0aGlzLmN1cnZlcyA9IFtdO1xcblxcdFxcdHRoaXMuYXV0b0Nsb3NlID0gZmFsc2U7IC8vIEF1dG9tYXRpY2FsbHkgY2xvc2VzIHRoZSBwYXRoXFxuXFxuXFx0fVxcblxcblxcdEN1cnZlUGF0aC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBDdXJ2ZVBhdGgsXFxuXFxuXFx0XFx0YWRkOiBmdW5jdGlvbiAoIGN1cnZlICkge1xcblxcblxcdFxcdFxcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbG9zZVBhdGg6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHQvLyBBZGQgYSBsaW5lIGN1cnZlIGlmIHN0YXJ0IGFuZCBlbmQgb2YgbGluZXMgYXJlIG5vdCBjb25uZWN0ZWRcXG5cXHRcXHRcXHR2YXIgc3RhcnRQb2ludCA9IHRoaXMuY3VydmVzWyAwIF0uZ2V0UG9pbnQoIDAgKTtcXG5cXHRcXHRcXHR2YXIgZW5kUG9pbnQgPSB0aGlzLmN1cnZlc1sgdGhpcy5jdXJ2ZXMubGVuZ3RoIC0gMSBdLmdldFBvaW50KCAxICk7XFxuXFxuXFx0XFx0XFx0aWYgKCAhIHN0YXJ0UG9pbnQuZXF1YWxzKCBlbmRQb2ludCApICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuY3VydmVzLnB1c2goIG5ldyBMaW5lQ3VydmUoIGVuZFBvaW50LCBzdGFydFBvaW50ICkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBUbyBnZXQgYWNjdXJhdGUgcG9pbnQgd2l0aCByZWZlcmVuY2UgdG9cXG5cXHRcXHQvLyBlbnRpcmUgcGF0aCBkaXN0YW5jZSBhdCB0aW1lIHQsXFxuXFx0XFx0Ly8gZm9sbG93aW5nIGhhcyB0byBiZSBkb25lOlxcblxcblxcdFxcdC8vIDEuIExlbmd0aCBvZiBlYWNoIHN1YiBwYXRoIGhhdmUgdG8gYmUga25vd25cXG5cXHRcXHQvLyAyLiBMb2NhdGUgYW5kIGlkZW50aWZ5IHR5cGUgb2YgY3VydmVcXG5cXHRcXHQvLyAzLiBHZXQgdCBmb3IgdGhlIGN1cnZlXFxuXFx0XFx0Ly8gNC4gUmV0dXJuIGN1cnZlLmdldFBvaW50QXQodCcpXFxuXFxuXFx0XFx0Z2V0UG9pbnQ6IGZ1bmN0aW9uICggdCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgZCA9IHQgKiB0aGlzLmdldExlbmd0aCgpO1xcblxcdFxcdFxcdHZhciBjdXJ2ZUxlbmd0aHMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xcblxcdFxcdFxcdHZhciBpID0gMDtcXG5cXG5cXHRcXHRcXHQvLyBUbyB0aGluayBhYm91dCBib3VuZGFyaWVzIHBvaW50cy5cXG5cXG5cXHRcXHRcXHR3aGlsZSAoIGkgPCBjdXJ2ZUxlbmd0aHMubGVuZ3RoICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggY3VydmVMZW5ndGhzWyBpIF0gPj0gZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgZGlmZiA9IGN1cnZlTGVuZ3Roc1sgaSBdIC0gZDtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgY3VydmUgPSB0aGlzLmN1cnZlc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBzZWdtZW50TGVuZ3RoID0gY3VydmUuZ2V0TGVuZ3RoKCk7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHUgPSBzZWdtZW50TGVuZ3RoID09PSAwID8gMCA6IDEgLSBkaWZmIC8gc2VnbWVudExlbmd0aDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gY3VydmUuZ2V0UG9pbnRBdCggdSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpICsrO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gbnVsbDtcXG5cXG5cXHRcXHRcXHQvLyBsb29wIHdoZXJlIHN1bSAhPSAwLCBzdW0gPiBkICwgc3VtKzEgPGRcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIFdlIGNhbm5vdCB1c2UgdGhlIGRlZmF1bHQgVEhSRUUuQ3VydmUgZ2V0UG9pbnQoKSB3aXRoIGdldExlbmd0aCgpIGJlY2F1c2UgaW5cXG5cXHRcXHQvLyBUSFJFRS5DdXJ2ZSwgZ2V0TGVuZ3RoKCkgZGVwZW5kcyBvbiBnZXRQb2ludCgpIGJ1dCBpbiBUSFJFRS5DdXJ2ZVBhdGhcXG5cXHRcXHQvLyBnZXRQb2ludCgpIGRlcGVuZHMgb24gZ2V0TGVuZ3RoXFxuXFxuXFx0XFx0Z2V0TGVuZ3RoOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGxlbnMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xcblxcdFxcdFxcdHJldHVybiBsZW5zWyBsZW5zLmxlbmd0aCAtIDEgXTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIGNhY2hlTGVuZ3RocyBtdXN0IGJlIHJlY2FsY3VsYXRlZC5cXG5cXHRcXHR1cGRhdGVBcmNMZW5ndGhzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XFxuXFx0XFx0XFx0dGhpcy5jYWNoZUxlbmd0aHMgPSBudWxsO1xcblxcdFxcdFxcdHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBDb21wdXRlIGxlbmd0aHMgYW5kIGNhY2hlIHRoZW1cXG5cXHRcXHQvLyBXZSBjYW5ub3Qgb3ZlcndyaXRlIGdldExlbmd0aHMoKSBiZWNhdXNlIFV0b1QgbWFwcGluZyB1c2VzIGl0LlxcblxcblxcdFxcdGdldEN1cnZlTGVuZ3RoczogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdC8vIFdlIHVzZSBjYWNoZSB2YWx1ZXMgaWYgY3VydmVzIGFuZCBjYWNoZSBhcnJheSBhcmUgc2FtZSBsZW5ndGhcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuY2FjaGVMZW5ndGhzICYmIHRoaXMuY2FjaGVMZW5ndGhzLmxlbmd0aCA9PT0gdGhpcy5jdXJ2ZXMubGVuZ3RoICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmNhY2hlTGVuZ3RocztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gR2V0IGxlbmd0aCBvZiBzdWItY3VydmVcXG5cXHRcXHRcXHQvLyBQdXNoIHN1bXMgaW50byBjYWNoZWQgYXJyYXlcXG5cXG5cXHRcXHRcXHR2YXIgbGVuZ3RocyA9IFtdLCBzdW1zID0gMDtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHN1bXMgKz0gdGhpcy5jdXJ2ZXNbIGkgXS5nZXRMZW5ndGgoKTtcXG5cXHRcXHRcXHRcXHRsZW5ndGhzLnB1c2goIHN1bXMgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5jYWNoZUxlbmd0aHMgPSBsZW5ndGhzO1xcblxcblxcdFxcdFxcdHJldHVybiBsZW5ndGhzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0U3BhY2VkUG9pbnRzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGRpdmlzaW9ucyA9PT0gdW5kZWZpbmVkICkgZGl2aXNpb25zID0gNDA7XFxuXFxuXFx0XFx0XFx0dmFyIHBvaW50cyA9IFtdO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8PSBkaXZpc2lvbnM7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnQoIGkgLyBkaXZpc2lvbnMgKSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuYXV0b0Nsb3NlICkge1xcblxcblxcdFxcdFxcdFxcdHBvaW50cy5wdXNoKCBwb2ludHNbIDAgXSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gcG9pbnRzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0UG9pbnRzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcXG5cXG5cXHRcXHRcXHRkaXZpc2lvbnMgPSBkaXZpc2lvbnMgfHwgMTI7XFxuXFxuXFx0XFx0XFx0dmFyIHBvaW50cyA9IFtdLCBsYXN0O1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgY3VydmVzID0gdGhpcy5jdXJ2ZXM7IGkgPCBjdXJ2ZXMubGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBjdXJ2ZSA9IGN1cnZlc1sgaSBdO1xcblxcdFxcdFxcdFxcdHZhciByZXNvbHV0aW9uID0gKCBjdXJ2ZSAmJiBjdXJ2ZS5pc0VsbGlwc2VDdXJ2ZSApID8gZGl2aXNpb25zICogMlxcblxcdFxcdFxcdFxcdFxcdDogKCBjdXJ2ZSAmJiBjdXJ2ZS5pc0xpbmVDdXJ2ZSApID8gMVxcblxcdFxcdFxcdFxcdFxcdFxcdDogKCBjdXJ2ZSAmJiBjdXJ2ZS5pc1NwbGluZUN1cnZlICkgPyBkaXZpc2lvbnMgKiBjdXJ2ZS5wb2ludHMubGVuZ3RoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0OiBkaXZpc2lvbnM7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHB0cyA9IGN1cnZlLmdldFBvaW50cyggcmVzb2x1dGlvbiApO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBqID0gMDsgaiA8IHB0cy5sZW5ndGg7IGogKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHBvaW50ID0gcHRzWyBqIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBsYXN0ICYmIGxhc3QuZXF1YWxzKCBwb2ludCApICkgY29udGludWU7IC8vIGVuc3VyZXMgbm8gY29uc2VjdXRpdmUgcG9pbnRzIGFyZSBkdXBsaWNhdGVzXFxuXFxuXFx0XFx0XFx0XFx0XFx0cG9pbnRzLnB1c2goIHBvaW50ICk7XFxuXFx0XFx0XFx0XFx0XFx0bGFzdCA9IHBvaW50O1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmF1dG9DbG9zZSAmJiBwb2ludHMubGVuZ3RoID4gMSAmJiAhIHBvaW50c1sgcG9pbnRzLmxlbmd0aCAtIDEgXS5lcXVhbHMoIHBvaW50c1sgMCBdICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cG9pbnRzLnB1c2goIHBvaW50c1sgMCBdICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBwb2ludHM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRcXHRDdXJ2ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLmN1cnZlcyA9IFtdO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHNvdXJjZS5jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgY3VydmUgPSBzb3VyY2UuY3VydmVzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUuY2xvbmUoKSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLmF1dG9DbG9zZSA9IHNvdXJjZS5hdXRvQ2xvc2U7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0b0pTT046IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgZGF0YSA9IEN1cnZlLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xcblxcblxcdFxcdFxcdGRhdGEuYXV0b0Nsb3NlID0gdGhpcy5hdXRvQ2xvc2U7XFxuXFx0XFx0XFx0ZGF0YS5jdXJ2ZXMgPSBbXTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBjdXJ2ZSA9IHRoaXMuY3VydmVzWyBpIF07XFxuXFx0XFx0XFx0XFx0ZGF0YS5jdXJ2ZXMucHVzaCggY3VydmUudG9KU09OKCkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGRhdGE7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRmcm9tSlNPTjogZnVuY3Rpb24gKCBqc29uICkge1xcblxcblxcdFxcdFxcdEN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKCB0aGlzLCBqc29uICk7XFxuXFxuXFx0XFx0XFx0dGhpcy5hdXRvQ2xvc2UgPSBqc29uLmF1dG9DbG9zZTtcXG5cXHRcXHRcXHR0aGlzLmN1cnZlcyA9IFtdO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24uY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGN1cnZlID0ganNvbi5jdXJ2ZXNbIGkgXTtcXG5cXHRcXHRcXHRcXHR0aGlzLmN1cnZlcy5wdXNoKCBuZXcgQ3VydmVzWyBjdXJ2ZS50eXBlIF0oKS5mcm9tSlNPTiggY3VydmUgKSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcXG5cXHQgKiBDcmVhdGVzIGZyZWUgZm9ybSAyZCBwYXRoIHVzaW5nIHNlcmllcyBvZiBwb2ludHMsIGxpbmVzIG9yIGN1cnZlcy5cXG5cXHQgKiovXFxuXFxuXFx0ZnVuY3Rpb24gUGF0aCggcG9pbnRzICkge1xcblxcblxcdFxcdEN1cnZlUGF0aC5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1BhdGgnO1xcblxcblxcdFxcdHRoaXMuY3VycmVudFBvaW50ID0gbmV3IFZlY3RvcjIoKTtcXG5cXG5cXHRcXHRpZiAoIHBvaW50cyApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnNldEZyb21Qb2ludHMoIHBvaW50cyApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9XFxuXFxuXFx0UGF0aC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBDdXJ2ZVBhdGgucHJvdG90eXBlICksIHtcXG5cXG5cXHRcXHRjb25zdHJ1Y3RvcjogUGF0aCxcXG5cXG5cXHRcXHRzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHBvaW50cyApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm1vdmVUbyggcG9pbnRzWyAwIF0ueCwgcG9pbnRzWyAwIF0ueSApO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMSwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMubGluZVRvKCBwb2ludHNbIGkgXS54LCBwb2ludHNbIGkgXS55ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bW92ZVRvOiBmdW5jdGlvbiAoIHgsIHkgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5jdXJyZW50UG9pbnQuc2V0KCB4LCB5ICk7IC8vIFRPRE8gY29uc2lkZXIgcmVmZXJlbmNpbmcgdmVjdG9ycyBpbnN0ZWFkIG9mIGNvcHlpbmc/XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRsaW5lVG86IGZ1bmN0aW9uICggeCwgeSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgY3VydmUgPSBuZXcgTGluZUN1cnZlKCB0aGlzLmN1cnJlbnRQb2ludC5jbG9uZSgpLCBuZXcgVmVjdG9yMiggeCwgeSApICk7XFxuXFx0XFx0XFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLmN1cnJlbnRQb2ludC5zZXQoIHgsIHkgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uICggYUNQeCwgYUNQeSwgYVgsIGFZICkge1xcblxcblxcdFxcdFxcdHZhciBjdXJ2ZSA9IG5ldyBRdWFkcmF0aWNCZXppZXJDdXJ2ZShcXG5cXHRcXHRcXHRcXHR0aGlzLmN1cnJlbnRQb2ludC5jbG9uZSgpLFxcblxcdFxcdFxcdFxcdG5ldyBWZWN0b3IyKCBhQ1B4LCBhQ1B5ICksXFxuXFx0XFx0XFx0XFx0bmV3IFZlY3RvcjIoIGFYLCBhWSApXFxuXFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xcblxcblxcdFxcdFxcdHRoaXMuY3VycmVudFBvaW50LnNldCggYVgsIGFZICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRiZXppZXJDdXJ2ZVRvOiBmdW5jdGlvbiAoIGFDUDF4LCBhQ1AxeSwgYUNQMngsIGFDUDJ5LCBhWCwgYVkgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGN1cnZlID0gbmV3IEN1YmljQmV6aWVyQ3VydmUoXFxuXFx0XFx0XFx0XFx0dGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSxcXG5cXHRcXHRcXHRcXHRuZXcgVmVjdG9yMiggYUNQMXgsIGFDUDF5ICksXFxuXFx0XFx0XFx0XFx0bmV3IFZlY3RvcjIoIGFDUDJ4LCBhQ1AyeSApLFxcblxcdFxcdFxcdFxcdG5ldyBWZWN0b3IyKCBhWCwgYVkgKVxcblxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLmN1cnJlbnRQb2ludC5zZXQoIGFYLCBhWSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c3BsaW5lVGhydTogZnVuY3Rpb24gKCBwdHMgLypBcnJheSBvZiBWZWN0b3IqLyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgbnB0cyA9IFsgdGhpcy5jdXJyZW50UG9pbnQuY2xvbmUoKSBdLmNvbmNhdCggcHRzICk7XFxuXFxuXFx0XFx0XFx0dmFyIGN1cnZlID0gbmV3IFNwbGluZUN1cnZlKCBucHRzICk7XFxuXFx0XFx0XFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLmN1cnJlbnRQb2ludC5jb3B5KCBwdHNbIHB0cy5sZW5ndGggLSAxIF0gKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGFyYzogZnVuY3Rpb24gKCBhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHgwID0gdGhpcy5jdXJyZW50UG9pbnQueDtcXG5cXHRcXHRcXHR2YXIgeTAgPSB0aGlzLmN1cnJlbnRQb2ludC55O1xcblxcblxcdFxcdFxcdHRoaXMuYWJzYXJjKCBhWCArIHgwLCBhWSArIHkwLCBhUmFkaXVzLFxcblxcdFxcdFxcdFxcdGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGFic2FyYzogZnVuY3Rpb24gKCBhWCwgYVksIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5hYnNlbGxpcHNlKCBhWCwgYVksIGFSYWRpdXMsIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGVsbGlwc2U6IGZ1bmN0aW9uICggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHgwID0gdGhpcy5jdXJyZW50UG9pbnQueDtcXG5cXHRcXHRcXHR2YXIgeTAgPSB0aGlzLmN1cnJlbnRQb2ludC55O1xcblxcblxcdFxcdFxcdHRoaXMuYWJzZWxsaXBzZSggYVggKyB4MCwgYVkgKyB5MCwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRhYnNlbGxpcHNlOiBmdW5jdGlvbiAoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICkge1xcblxcblxcdFxcdFxcdHZhciBjdXJ2ZSA9IG5ldyBFbGxpcHNlQ3VydmUoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSwgYVJvdGF0aW9uICk7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmN1cnZlcy5sZW5ndGggPiAwICkge1xcblxcblxcdFxcdFxcdFxcdC8vIGlmIGEgcHJldmlvdXMgY3VydmUgaXMgcHJlc2VudCwgYXR0ZW1wdCB0byBqb2luXFxuXFx0XFx0XFx0XFx0dmFyIGZpcnN0UG9pbnQgPSBjdXJ2ZS5nZXRQb2ludCggMCApO1xcblxcblxcdFxcdFxcdFxcdGlmICggISBmaXJzdFBvaW50LmVxdWFscyggdGhpcy5jdXJyZW50UG9pbnQgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmxpbmVUbyggZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XFxuXFxuXFx0XFx0XFx0dmFyIGxhc3RQb2ludCA9IGN1cnZlLmdldFBvaW50KCAxICk7XFxuXFx0XFx0XFx0dGhpcy5jdXJyZW50UG9pbnQuY29weSggbGFzdFBvaW50ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRcXHRDdXJ2ZVBhdGgucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxuXFxuXFx0XFx0XFx0dGhpcy5jdXJyZW50UG9pbnQuY29weSggc291cmNlLmN1cnJlbnRQb2ludCApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGRhdGEgPSBDdXJ2ZVBhdGgucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0XFx0ZGF0YS5jdXJyZW50UG9pbnQgPSB0aGlzLmN1cnJlbnRQb2ludC50b0FycmF5KCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGRhdGE7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRmcm9tSlNPTjogZnVuY3Rpb24gKCBqc29uICkge1xcblxcblxcdFxcdFxcdEN1cnZlUGF0aC5wcm90b3R5cGUuZnJvbUpTT04uY2FsbCggdGhpcywganNvbiApO1xcblxcblxcdFxcdFxcdHRoaXMuY3VycmVudFBvaW50LmZyb21BcnJheSgganNvbi5jdXJyZW50UG9pbnQgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcXG5cXHQgKiBEZWZpbmVzIGEgMmQgc2hhcGUgcGxhbmUgdXNpbmcgcGF0aHMuXFxuXFx0ICoqL1xcblxcblxcdC8vIFNURVAgMSBDcmVhdGUgYSBwYXRoLlxcblxcdC8vIFNURVAgMiBUdXJuIHBhdGggaW50byBzaGFwZS5cXG5cXHQvLyBTVEVQIDMgRXh0cnVkZUdlb21ldHJ5IHRha2VzIGluIFNoYXBlL1NoYXBlc1xcblxcdC8vIFNURVAgM2EgLSBFeHRyYWN0IHBvaW50cyBmcm9tIGVhY2ggc2hhcGUsIHR1cm4gdG8gdmVydGljZXNcXG5cXHQvLyBTVEVQIDNiIC0gVHJpYW5ndWxhdGUgZWFjaCBzaGFwZSwgYWRkIGZhY2VzLlxcblxcblxcdGZ1bmN0aW9uIFNoYXBlKCBwb2ludHMgKSB7XFxuXFxuXFx0XFx0UGF0aC5jYWxsKCB0aGlzLCBwb2ludHMgKTtcXG5cXG5cXHRcXHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnU2hhcGUnO1xcblxcblxcdFxcdHRoaXMuaG9sZXMgPSBbXTtcXG5cXG5cXHR9XFxuXFxuXFx0U2hhcGUucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggUGF0aC5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBTaGFwZSxcXG5cXG5cXHRcXHRnZXRQb2ludHNIb2xlczogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGhvbGVzUHRzID0gW107XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5ob2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdGhvbGVzUHRzWyBpIF0gPSB0aGlzLmhvbGVzWyBpIF0uZ2V0UG9pbnRzKCBkaXZpc2lvbnMgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGhvbGVzUHRzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gZ2V0IHBvaW50cyBvZiBzaGFwZSBhbmQgaG9sZXMgKGtleXBvaW50cyBiYXNlZCBvbiBzZWdtZW50cyBwYXJhbWV0ZXIpXFxuXFxuXFx0XFx0ZXh0cmFjdFBvaW50czogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHtcXG5cXG5cXHRcXHRcXHRcXHRzaGFwZTogdGhpcy5nZXRQb2ludHMoIGRpdmlzaW9ucyApLFxcblxcdFxcdFxcdFxcdGhvbGVzOiB0aGlzLmdldFBvaW50c0hvbGVzKCBkaXZpc2lvbnMgKVxcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRcXHRQYXRoLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcblxcblxcdFxcdFxcdHRoaXMuaG9sZXMgPSBbXTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzb3VyY2UuaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgaG9sZSA9IHNvdXJjZS5ob2xlc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdHRoaXMuaG9sZXMucHVzaCggaG9sZS5jbG9uZSgpICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGRhdGEgPSBQYXRoLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xcblxcblxcdFxcdFxcdGRhdGEudXVpZCA9IHRoaXMudXVpZDtcXG5cXHRcXHRcXHRkYXRhLmhvbGVzID0gW107XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5ob2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBob2xlID0gdGhpcy5ob2xlc1sgaSBdO1xcblxcdFxcdFxcdFxcdGRhdGEuaG9sZXMucHVzaCggaG9sZS50b0pTT04oKSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gZGF0YTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGZyb21KU09OOiBmdW5jdGlvbiAoIGpzb24gKSB7XFxuXFxuXFx0XFx0XFx0UGF0aC5wcm90b3R5cGUuZnJvbUpTT04uY2FsbCggdGhpcywganNvbiApO1xcblxcblxcdFxcdFxcdHRoaXMudXVpZCA9IGpzb24udXVpZDtcXG5cXHRcXHRcXHR0aGlzLmhvbGVzID0gW107XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5ob2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBob2xlID0ganNvbi5ob2xlc1sgaSBdO1xcblxcdFxcdFxcdFxcdHRoaXMuaG9sZXMucHVzaCggbmV3IFBhdGgoKS5mcm9tSlNPTiggaG9sZSApICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIExpZ2h0KCBjb2xvciwgaW50ZW5zaXR5ICkge1xcblxcblxcdFxcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnTGlnaHQnO1xcblxcblxcdFxcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIGNvbG9yICk7XFxuXFx0XFx0dGhpcy5pbnRlbnNpdHkgPSBpbnRlbnNpdHkgIT09IHVuZGVmaW5lZCA/IGludGVuc2l0eSA6IDE7XFxuXFxuXFx0XFx0dGhpcy5yZWNlaXZlU2hhZG93ID0gdW5kZWZpbmVkO1xcblxcblxcdH1cXG5cXG5cXHRMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBMaWdodCxcXG5cXG5cXHRcXHRpc0xpZ2h0OiB0cnVlLFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdFxcdE9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcblxcblxcdFxcdFxcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XFxuXFx0XFx0XFx0dGhpcy5pbnRlbnNpdHkgPSBzb3VyY2UuaW50ZW5zaXR5O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGRhdGEgPSBPYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcXG5cXG5cXHRcXHRcXHRkYXRhLm9iamVjdC5jb2xvciA9IHRoaXMuY29sb3IuZ2V0SGV4KCk7XFxuXFx0XFx0XFx0ZGF0YS5vYmplY3QuaW50ZW5zaXR5ID0gdGhpcy5pbnRlbnNpdHk7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmdyb3VuZENvbG9yICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5ncm91bmRDb2xvciA9IHRoaXMuZ3JvdW5kQ29sb3IuZ2V0SGV4KCk7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmRpc3RhbmNlICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5kaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2U7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLmFuZ2xlICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5hbmdsZSA9IHRoaXMuYW5nbGU7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLmRlY2F5ICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5kZWNheSA9IHRoaXMuZGVjYXk7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLnBlbnVtYnJhICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5wZW51bWJyYSA9IHRoaXMucGVudW1icmE7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnNoYWRvdyAhPT0gdW5kZWZpbmVkICkgZGF0YS5vYmplY3Quc2hhZG93ID0gdGhpcy5zaGFkb3cudG9KU09OKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGRhdGE7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEhlbWlzcGhlcmVMaWdodCggc2t5Q29sb3IsIGdyb3VuZENvbG9yLCBpbnRlbnNpdHkgKSB7XFxuXFxuXFx0XFx0TGlnaHQuY2FsbCggdGhpcywgc2t5Q29sb3IsIGludGVuc2l0eSApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdIZW1pc3BoZXJlTGlnaHQnO1xcblxcblxcdFxcdHRoaXMuY2FzdFNoYWRvdyA9IHVuZGVmaW5lZDtcXG5cXG5cXHRcXHR0aGlzLnBvc2l0aW9uLmNvcHkoIE9iamVjdDNELkRlZmF1bHRVcCApO1xcblxcdFxcdHRoaXMudXBkYXRlTWF0cml4KCk7XFxuXFxuXFx0XFx0dGhpcy5ncm91bmRDb2xvciA9IG5ldyBDb2xvciggZ3JvdW5kQ29sb3IgKTtcXG5cXG5cXHR9XFxuXFxuXFx0SGVtaXNwaGVyZUxpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExpZ2h0LnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IEhlbWlzcGhlcmVMaWdodCxcXG5cXG5cXHRcXHRpc0hlbWlzcGhlcmVMaWdodDogdHJ1ZSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRcXHRMaWdodC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLmdyb3VuZENvbG9yLmNvcHkoIHNvdXJjZS5ncm91bmRDb2xvciApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBMaWdodFNoYWRvdyggY2FtZXJhICkge1xcblxcblxcdFxcdHRoaXMuY2FtZXJhID0gY2FtZXJhO1xcblxcblxcdFxcdHRoaXMuYmlhcyA9IDA7XFxuXFx0XFx0dGhpcy5yYWRpdXMgPSAxO1xcblxcblxcdFxcdHRoaXMubWFwU2l6ZSA9IG5ldyBWZWN0b3IyKCA1MTIsIDUxMiApO1xcblxcblxcdFxcdHRoaXMubWFwID0gbnVsbDtcXG5cXHRcXHR0aGlzLm1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5hc3NpZ24oIExpZ2h0U2hhZG93LnByb3RvdHlwZSwge1xcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdFxcdHRoaXMuY2FtZXJhID0gc291cmNlLmNhbWVyYS5jbG9uZSgpO1xcblxcblxcdFxcdFxcdHRoaXMuYmlhcyA9IHNvdXJjZS5iaWFzO1xcblxcdFxcdFxcdHRoaXMucmFkaXVzID0gc291cmNlLnJhZGl1cztcXG5cXG5cXHRcXHRcXHR0aGlzLm1hcFNpemUuY29weSggc291cmNlLm1hcFNpemUgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIG9iamVjdCA9IHt9O1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5iaWFzICE9PSAwICkgb2JqZWN0LmJpYXMgPSB0aGlzLmJpYXM7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLnJhZGl1cyAhPT0gMSApIG9iamVjdC5yYWRpdXMgPSB0aGlzLnJhZGl1cztcXG5cXHRcXHRcXHRpZiAoIHRoaXMubWFwU2l6ZS54ICE9PSA1MTIgfHwgdGhpcy5tYXBTaXplLnkgIT09IDUxMiApIG9iamVjdC5tYXBTaXplID0gdGhpcy5tYXBTaXplLnRvQXJyYXkoKTtcXG5cXG5cXHRcXHRcXHRvYmplY3QuY2FtZXJhID0gdGhpcy5jYW1lcmEudG9KU09OKCBmYWxzZSApLm9iamVjdDtcXG5cXHRcXHRcXHRkZWxldGUgb2JqZWN0LmNhbWVyYS5tYXRyaXg7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG9iamVjdDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gU3BvdExpZ2h0U2hhZG93KCkge1xcblxcblxcdFxcdExpZ2h0U2hhZG93LmNhbGwoIHRoaXMsIG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggNTAsIDEsIDAuNSwgNTAwICkgKTtcXG5cXG5cXHR9XFxuXFxuXFx0U3BvdExpZ2h0U2hhZG93LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExpZ2h0U2hhZG93LnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IFNwb3RMaWdodFNoYWRvdyxcXG5cXG5cXHRcXHRpc1Nwb3RMaWdodFNoYWRvdzogdHJ1ZSxcXG5cXG5cXHRcXHR1cGRhdGU6IGZ1bmN0aW9uICggbGlnaHQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGNhbWVyYSA9IHRoaXMuY2FtZXJhO1xcblxcblxcdFxcdFxcdHZhciBmb3YgPSBfTWF0aC5SQUQyREVHICogMiAqIGxpZ2h0LmFuZ2xlO1xcblxcdFxcdFxcdHZhciBhc3BlY3QgPSB0aGlzLm1hcFNpemUud2lkdGggLyB0aGlzLm1hcFNpemUuaGVpZ2h0O1xcblxcdFxcdFxcdHZhciBmYXIgPSBsaWdodC5kaXN0YW5jZSB8fCBjYW1lcmEuZmFyO1xcblxcblxcdFxcdFxcdGlmICggZm92ICE9PSBjYW1lcmEuZm92IHx8IGFzcGVjdCAhPT0gY2FtZXJhLmFzcGVjdCB8fCBmYXIgIT09IGNhbWVyYS5mYXIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y2FtZXJhLmZvdiA9IGZvdjtcXG5cXHRcXHRcXHRcXHRjYW1lcmEuYXNwZWN0ID0gYXNwZWN0O1xcblxcdFxcdFxcdFxcdGNhbWVyYS5mYXIgPSBmYXI7XFxuXFx0XFx0XFx0XFx0Y2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFNwb3RMaWdodCggY29sb3IsIGludGVuc2l0eSwgZGlzdGFuY2UsIGFuZ2xlLCBwZW51bWJyYSwgZGVjYXkgKSB7XFxuXFxuXFx0XFx0TGlnaHQuY2FsbCggdGhpcywgY29sb3IsIGludGVuc2l0eSApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdTcG90TGlnaHQnO1xcblxcblxcdFxcdHRoaXMucG9zaXRpb24uY29weSggT2JqZWN0M0QuRGVmYXVsdFVwICk7XFxuXFx0XFx0dGhpcy51cGRhdGVNYXRyaXgoKTtcXG5cXG5cXHRcXHR0aGlzLnRhcmdldCA9IG5ldyBPYmplY3QzRCgpO1xcblxcblxcdFxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ3Bvd2VyJywge1xcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdC8vIGludGVuc2l0eSA9IHBvd2VyIHBlciBzb2xpZCBhbmdsZS5cXG5cXHRcXHRcXHRcXHQvLyByZWY6IGVxdWF0aW9uICgxNykgZnJvbSBodHRwOi8vd3d3LmZyb3N0Yml0ZS5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTQvMTEvY291cnNlX25vdGVzX21vdmluZ19mcm9zdGJpdGVfdG9fcGJyLnBkZlxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmludGVuc2l0eSAqIE1hdGguUEk7XFxuXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggcG93ZXIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gaW50ZW5zaXR5ID0gcG93ZXIgcGVyIHNvbGlkIGFuZ2xlLlxcblxcdFxcdFxcdFxcdC8vIHJlZjogZXF1YXRpb24gKDE3KSBmcm9tIGh0dHA6Ly93d3cuZnJvc3RiaXRlLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxNC8xMS9jb3Vyc2Vfbm90ZXNfbW92aW5nX2Zyb3N0Yml0ZV90b19wYnIucGRmXFxuXFx0XFx0XFx0XFx0dGhpcy5pbnRlbnNpdHkgPSBwb3dlciAvIE1hdGguUEk7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gKTtcXG5cXG5cXHRcXHR0aGlzLmRpc3RhbmNlID0gKCBkaXN0YW5jZSAhPT0gdW5kZWZpbmVkICkgPyBkaXN0YW5jZSA6IDA7XFxuXFx0XFx0dGhpcy5hbmdsZSA9ICggYW5nbGUgIT09IHVuZGVmaW5lZCApID8gYW5nbGUgOiBNYXRoLlBJIC8gMztcXG5cXHRcXHR0aGlzLnBlbnVtYnJhID0gKCBwZW51bWJyYSAhPT0gdW5kZWZpbmVkICkgPyBwZW51bWJyYSA6IDA7XFxuXFx0XFx0dGhpcy5kZWNheSA9ICggZGVjYXkgIT09IHVuZGVmaW5lZCApID8gZGVjYXkgOiAxO1xcdC8vIGZvciBwaHlzaWNhbGx5IGNvcnJlY3QgbGlnaHRzLCBzaG91bGQgYmUgMi5cXG5cXG5cXHRcXHR0aGlzLnNoYWRvdyA9IG5ldyBTcG90TGlnaHRTaGFkb3coKTtcXG5cXG5cXHR9XFxuXFxuXFx0U3BvdExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExpZ2h0LnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IFNwb3RMaWdodCxcXG5cXG5cXHRcXHRpc1Nwb3RMaWdodDogdHJ1ZSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRcXHRMaWdodC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLmRpc3RhbmNlID0gc291cmNlLmRpc3RhbmNlO1xcblxcdFxcdFxcdHRoaXMuYW5nbGUgPSBzb3VyY2UuYW5nbGU7XFxuXFx0XFx0XFx0dGhpcy5wZW51bWJyYSA9IHNvdXJjZS5wZW51bWJyYTtcXG5cXHRcXHRcXHR0aGlzLmRlY2F5ID0gc291cmNlLmRlY2F5O1xcblxcblxcdFxcdFxcdHRoaXMudGFyZ2V0ID0gc291cmNlLnRhcmdldC5jbG9uZSgpO1xcblxcblxcdFxcdFxcdHRoaXMuc2hhZG93ID0gc291cmNlLnNoYWRvdy5jbG9uZSgpO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXG5cXHRmdW5jdGlvbiBQb2ludExpZ2h0KCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSwgZGVjYXkgKSB7XFxuXFxuXFx0XFx0TGlnaHQuY2FsbCggdGhpcywgY29sb3IsIGludGVuc2l0eSApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdQb2ludExpZ2h0JztcXG5cXG5cXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdwb3dlcicsIHtcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBpbnRlbnNpdHkgPSBwb3dlciBwZXIgc29saWQgYW5nbGUuXFxuXFx0XFx0XFx0XFx0Ly8gcmVmOiBlcXVhdGlvbiAoMTUpIGZyb20gaHR0cDovL3d3dy5mcm9zdGJpdGUuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE0LzExL2NvdXJzZV9ub3Rlc19tb3ZpbmdfZnJvc3RiaXRlX3RvX3Bici5wZGZcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5pbnRlbnNpdHkgKiA0ICogTWF0aC5QSTtcXG5cXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCBwb3dlciApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBpbnRlbnNpdHkgPSBwb3dlciBwZXIgc29saWQgYW5nbGUuXFxuXFx0XFx0XFx0XFx0Ly8gcmVmOiBlcXVhdGlvbiAoMTUpIGZyb20gaHR0cDovL3d3dy5mcm9zdGJpdGUuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE0LzExL2NvdXJzZV9ub3Rlc19tb3ZpbmdfZnJvc3RiaXRlX3RvX3Bici5wZGZcXG5cXHRcXHRcXHRcXHR0aGlzLmludGVuc2l0eSA9IHBvd2VyIC8gKCA0ICogTWF0aC5QSSApO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHR9ICk7XFxuXFxuXFx0XFx0dGhpcy5kaXN0YW5jZSA9ICggZGlzdGFuY2UgIT09IHVuZGVmaW5lZCApID8gZGlzdGFuY2UgOiAwO1xcblxcdFxcdHRoaXMuZGVjYXkgPSAoIGRlY2F5ICE9PSB1bmRlZmluZWQgKSA/IGRlY2F5IDogMTtcXHQvLyBmb3IgcGh5c2ljYWxseSBjb3JyZWN0IGxpZ2h0cywgc2hvdWxkIGJlIDIuXFxuXFxuXFx0XFx0dGhpcy5zaGFkb3cgPSBuZXcgTGlnaHRTaGFkb3coIG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggOTAsIDEsIDAuNSwgNTAwICkgKTtcXG5cXG5cXHR9XFxuXFxuXFx0UG9pbnRMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMaWdodC5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBQb2ludExpZ2h0LFxcblxcblxcdFxcdGlzUG9pbnRMaWdodDogdHJ1ZSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRcXHRMaWdodC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLmRpc3RhbmNlID0gc291cmNlLmRpc3RhbmNlO1xcblxcdFxcdFxcdHRoaXMuZGVjYXkgPSBzb3VyY2UuZGVjYXk7XFxuXFxuXFx0XFx0XFx0dGhpcy5zaGFkb3cgPSBzb3VyY2Uuc2hhZG93LmNsb25lKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIERpcmVjdGlvbmFsTGlnaHRTaGFkb3coICkge1xcblxcblxcdFxcdExpZ2h0U2hhZG93LmNhbGwoIHRoaXMsIG5ldyBPcnRob2dyYXBoaWNDYW1lcmEoIC0gNSwgNSwgNSwgLSA1LCAwLjUsIDUwMCApICk7XFxuXFxuXFx0fVxcblxcblxcdERpcmVjdGlvbmFsTGlnaHRTaGFkb3cucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTGlnaHRTaGFkb3cucHJvdG90eXBlICksIHtcXG5cXG5cXHRcXHRjb25zdHJ1Y3RvcjogRGlyZWN0aW9uYWxMaWdodFNoYWRvd1xcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gRGlyZWN0aW9uYWxMaWdodCggY29sb3IsIGludGVuc2l0eSApIHtcXG5cXG5cXHRcXHRMaWdodC5jYWxsKCB0aGlzLCBjb2xvciwgaW50ZW5zaXR5ICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ0RpcmVjdGlvbmFsTGlnaHQnO1xcblxcblxcdFxcdHRoaXMucG9zaXRpb24uY29weSggT2JqZWN0M0QuRGVmYXVsdFVwICk7XFxuXFx0XFx0dGhpcy51cGRhdGVNYXRyaXgoKTtcXG5cXG5cXHRcXHR0aGlzLnRhcmdldCA9IG5ldyBPYmplY3QzRCgpO1xcblxcblxcdFxcdHRoaXMuc2hhZG93ID0gbmV3IERpcmVjdGlvbmFsTGlnaHRTaGFkb3coKTtcXG5cXG5cXHR9XFxuXFxuXFx0RGlyZWN0aW9uYWxMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMaWdodC5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBEaXJlY3Rpb25hbExpZ2h0LFxcblxcblxcdFxcdGlzRGlyZWN0aW9uYWxMaWdodDogdHJ1ZSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRcXHRMaWdodC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLnRhcmdldCA9IHNvdXJjZS50YXJnZXQuY2xvbmUoKTtcXG5cXG5cXHRcXHRcXHR0aGlzLnNoYWRvdyA9IHNvdXJjZS5zaGFkb3cuY2xvbmUoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gQW1iaWVudExpZ2h0KCBjb2xvciwgaW50ZW5zaXR5ICkge1xcblxcblxcdFxcdExpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yLCBpbnRlbnNpdHkgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnQW1iaWVudExpZ2h0JztcXG5cXG5cXHRcXHR0aGlzLmNhc3RTaGFkb3cgPSB1bmRlZmluZWQ7XFxuXFxuXFx0fVxcblxcblxcdEFtYmllbnRMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMaWdodC5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBBbWJpZW50TGlnaHQsXFxuXFxuXFx0XFx0aXNBbWJpZW50TGlnaHQ6IHRydWVcXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBhYmVsbmF0aW9uIC8gaHR0cDovL2dpdGh1Yi5jb20vYWJlbG5hdGlvblxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFJlY3RBcmVhTGlnaHQoIGNvbG9yLCBpbnRlbnNpdHksIHdpZHRoLCBoZWlnaHQgKSB7XFxuXFxuXFx0XFx0TGlnaHQuY2FsbCggdGhpcywgY29sb3IsIGludGVuc2l0eSApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdSZWN0QXJlYUxpZ2h0JztcXG5cXG5cXHRcXHR0aGlzLnBvc2l0aW9uLnNldCggMCwgMSwgMCApO1xcblxcdFxcdHRoaXMudXBkYXRlTWF0cml4KCk7XFxuXFxuXFx0XFx0dGhpcy53aWR0aCA9ICggd2lkdGggIT09IHVuZGVmaW5lZCApID8gd2lkdGggOiAxMDtcXG5cXHRcXHR0aGlzLmhlaWdodCA9ICggaGVpZ2h0ICE9PSB1bmRlZmluZWQgKSA/IGhlaWdodCA6IDEwO1xcblxcblxcdFxcdC8vIFRPRE8gKGFiZWxuYXRpb24pOiBkaXN0YW5jZS9kZWNheVxcblxcblxcdFxcdC8vIFRPRE8gKGFiZWxuYXRpb24pOiB1cGRhdGUgbWV0aG9kIGZvciBSZWN0QXJlYUxpZ2h0IHRvIHVwZGF0ZSB0cmFuc2Zvcm0gdG8gbG9va2F0IHRhcmdldFxcblxcblxcdFxcdC8vIFRPRE8gKGFiZWxuYXRpb24pOiBzaGFkb3dzXFxuXFxuXFx0fVxcblxcblxcdC8vIFRPRE8gKGFiZWxuYXRpb24pOiBSZWN0QXJlYUxpZ2h0IHVwZGF0ZSB3aGVuIGxpZ2h0IHNoYXBlIGlzIGNoYW5nZWRcXG5cXHRSZWN0QXJlYUxpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExpZ2h0LnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IFJlY3RBcmVhTGlnaHQsXFxuXFxuXFx0XFx0aXNSZWN0QXJlYUxpZ2h0OiB0cnVlLFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdFxcdExpZ2h0LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcblxcblxcdFxcdFxcdHRoaXMud2lkdGggPSBzb3VyY2Uud2lkdGg7XFxuXFx0XFx0XFx0dGhpcy5oZWlnaHQgPSBzb3VyY2UuaGVpZ2h0O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGRhdGEgPSBMaWdodC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcXG5cXG5cXHRcXHRcXHRkYXRhLm9iamVjdC53aWR0aCA9IHRoaXMud2lkdGg7XFxuXFx0XFx0XFx0ZGF0YS5vYmplY3QuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGRhdGE7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKlxcblxcdCAqIEEgVHJhY2sgdGhhdCBpbnRlcnBvbGF0ZXMgU3RyaW5nc1xcblxcdCAqXFxuXFx0ICpcXG5cXHQgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xcblxcdCAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xcblxcdCAqIEBhdXRob3IgdHNjaHdcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBTdHJpbmdLZXlmcmFtZVRyYWNrKCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICkge1xcblxcblxcdFxcdEtleWZyYW1lVHJhY2suY2FsbCggdGhpcywgbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApO1xcblxcblxcdH1cXG5cXG5cXHRTdHJpbmdLZXlmcmFtZVRyYWNrLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEtleWZyYW1lVHJhY2sucHJvdG90eXBlICksIHtcXG5cXG5cXHRcXHRjb25zdHJ1Y3RvcjogU3RyaW5nS2V5ZnJhbWVUcmFjayxcXG5cXG5cXHRcXHRWYWx1ZVR5cGVOYW1lOiAnc3RyaW5nJyxcXG5cXHRcXHRWYWx1ZUJ1ZmZlclR5cGU6IEFycmF5LFxcblxcblxcdFxcdERlZmF1bHRJbnRlcnBvbGF0aW9uOiBJbnRlcnBvbGF0ZURpc2NyZXRlLFxcblxcblxcdFxcdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjogdW5kZWZpbmVkLFxcblxcblxcdFxcdEludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aDogdW5kZWZpbmVkXFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqXFxuXFx0ICogQSBUcmFjayBvZiBCb29sZWFuIGtleWZyYW1lIHZhbHVlcy5cXG5cXHQgKlxcblxcdCAqXFxuXFx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cXG5cXHQgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cXG5cXHQgKiBAYXV0aG9yIHRzY2h3XFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gQm9vbGVhbktleWZyYW1lVHJhY2soIG5hbWUsIHRpbWVzLCB2YWx1ZXMgKSB7XFxuXFxuXFx0XFx0S2V5ZnJhbWVUcmFjay5jYWxsKCB0aGlzLCBuYW1lLCB0aW1lcywgdmFsdWVzICk7XFxuXFxuXFx0fVxcblxcblxcdEJvb2xlYW5LZXlmcmFtZVRyYWNrLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEtleWZyYW1lVHJhY2sucHJvdG90eXBlICksIHtcXG5cXG5cXHRcXHRjb25zdHJ1Y3RvcjogQm9vbGVhbktleWZyYW1lVHJhY2ssXFxuXFxuXFx0XFx0VmFsdWVUeXBlTmFtZTogJ2Jvb2wnLFxcblxcdFxcdFZhbHVlQnVmZmVyVHlwZTogQXJyYXksXFxuXFxuXFx0XFx0RGVmYXVsdEludGVycG9sYXRpb246IEludGVycG9sYXRlRGlzY3JldGUsXFxuXFxuXFx0XFx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyOiB1bmRlZmluZWQsXFxuXFx0XFx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoOiB1bmRlZmluZWRcXG5cXG5cXHRcXHQvLyBOb3RlOiBBY3R1YWxseSB0aGlzIHRyYWNrIGNvdWxkIGhhdmUgYSBvcHRpbWl6ZWQgLyBjb21wcmVzc2VkXFxuXFx0XFx0Ly8gcmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgdmFsdWUgYW5kIGEgY3VzdG9tIGludGVycG9sYW50IHRoYXRcXG5cXHRcXHQvLyBjb21wdXRlcyBcXFwiZmlyc3RWYWx1ZSBeIGlzT2RkKCBpbmRleCApXFxcIi5cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQWJzdHJhY3QgYmFzZSBjbGFzcyBvZiBpbnRlcnBvbGFudHMgb3ZlciBwYXJhbWV0cmljIHNhbXBsZXMuXFxuXFx0ICpcXG5cXHQgKiBUaGUgcGFyYW1ldGVyIGRvbWFpbiBpcyBvbmUgZGltZW5zaW9uYWwsIHR5cGljYWxseSB0aGUgdGltZSBvciBhIHBhdGhcXG5cXHQgKiBhbG9uZyBhIGN1cnZlIGRlZmluZWQgYnkgdGhlIGRhdGEuXFxuXFx0ICpcXG5cXHQgKiBUaGUgc2FtcGxlIHZhbHVlcyBjYW4gaGF2ZSBhbnkgZGltZW5zaW9uYWxpdHkgYW5kIGRlcml2ZWQgY2xhc3NlcyBtYXlcXG5cXHQgKiBhcHBseSBzcGVjaWFsIGludGVycHJldGF0aW9ucyB0byB0aGUgZGF0YS5cXG5cXHQgKlxcblxcdCAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgdGhlIGludGVydmFsIHNlZWsgaW4gYSBUZW1wbGF0ZSBNZXRob2QsIGRlZmVycmluZ1xcblxcdCAqIHRoZSBhY3R1YWwgaW50ZXJwb2xhdGlvbiB0byBkZXJpdmVkIGNsYXNzZXMuXFxuXFx0ICpcXG5cXHQgKiBUaW1lIGNvbXBsZXhpdHkgaXMgTygxKSBmb3IgbGluZWFyIGFjY2VzcyBjcm9zc2luZyBhdCBtb3N0IHR3byBwb2ludHNcXG5cXHQgKiBhbmQgTyhsb2cgTikgZm9yIHJhbmRvbSBhY2Nlc3MsIHdoZXJlIE4gaXMgdGhlIG51bWJlciBvZiBwb3NpdGlvbnMuXFxuXFx0ICpcXG5cXHQgKiBSZWZlcmVuY2VzOlxcblxcdCAqXFxuXFx0ICogXFx0XFx0aHR0cDovL3d3dy5vb2Rlc2lnbi5jb20vdGVtcGxhdGUtbWV0aG9kLXBhdHRlcm4uaHRtbFxcblxcdCAqXFxuXFx0ICogQGF1dGhvciB0c2Nod1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEludGVycG9sYW50KCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xcblxcblxcdFxcdHRoaXMucGFyYW1ldGVyUG9zaXRpb25zID0gcGFyYW1ldGVyUG9zaXRpb25zO1xcblxcdFxcdHRoaXMuX2NhY2hlZEluZGV4ID0gMDtcXG5cXG5cXHRcXHR0aGlzLnJlc3VsdEJ1ZmZlciA9IHJlc3VsdEJ1ZmZlciAhPT0gdW5kZWZpbmVkID9cXG5cXHRcXHRcXHRyZXN1bHRCdWZmZXIgOiBuZXcgc2FtcGxlVmFsdWVzLmNvbnN0cnVjdG9yKCBzYW1wbGVTaXplICk7XFxuXFx0XFx0dGhpcy5zYW1wbGVWYWx1ZXMgPSBzYW1wbGVWYWx1ZXM7XFxuXFx0XFx0dGhpcy52YWx1ZVNpemUgPSBzYW1wbGVTaXplO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBJbnRlcnBvbGFudC5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRldmFsdWF0ZTogZnVuY3Rpb24gKCB0ICkge1xcblxcblxcdFxcdFxcdHZhciBwcCA9IHRoaXMucGFyYW1ldGVyUG9zaXRpb25zLFxcblxcdFxcdFxcdFxcdGkxID0gdGhpcy5fY2FjaGVkSW5kZXgsXFxuXFxuXFx0XFx0XFx0XFx0dDEgPSBwcFsgaTEgXSxcXG5cXHRcXHRcXHRcXHR0MCA9IHBwWyBpMSAtIDEgXTtcXG5cXG5cXHRcXHRcXHR2YWxpZGF0ZV9pbnRlcnZhbDoge1xcblxcblxcdFxcdFxcdFxcdHNlZWs6IHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgcmlnaHQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bGluZWFyX3NjYW46IHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLy0gU2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NvbXBhcmlzb24tdG8tdW5kZWZpbmVkLzNcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLy0gc2xvd2VyIGNvZGU6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8tXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8tIFxcdFxcdFxcdFxcdGlmICggdCA+PSB0MSB8fCB0MSA9PT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGZvcndhcmRfc2NhbjogaWYgKCAhICggdCA8IHQxICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGdpdmVVcEF0ID0gaTEgKyAyOyA7ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggdDEgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHQgPCB0MCApIGJyZWFrIGZvcndhcmRfc2NhbjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBhZnRlciBlbmRcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpMSA9IHBwLmxlbmd0aDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9jYWNoZWRJbmRleCA9IGkxO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmFmdGVyRW5kXyggaTEgLSAxLCB0LCB0MCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGkxID09PSBnaXZlVXBBdCApIGJyZWFrOyAvLyB0aGlzIGxvb3BcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0MCA9IHQxO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHQxID0gcHBbICsrIGkxIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB0IDwgdDEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gd2UgaGF2ZSBhcnJpdmVkIGF0IHRoZSBzb3VnaHQgaW50ZXJ2YWxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhayBzZWVrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gcHJlcGFyZSBiaW5hcnkgc2VhcmNoIG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSBpbmRleFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJpZ2h0ID0gcHAubGVuZ3RoO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrIGxpbmVhcl9zY2FuO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLy0gc2xvd2VyIGNvZGU6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8tXFx0XFx0XFx0XFx0XFx0aWYgKCB0IDwgdDAgfHwgdDAgPT09IHVuZGVmaW5lZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoICEgKCB0ID49IHQwICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gbG9vcGluZz9cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgdDFnbG9iYWwgPSBwcFsgMSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggdCA8IHQxZ2xvYmFsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGkxID0gMjsgLy8gKyAxLCB1c2luZyB0aGUgc2NhbiBmb3IgdGhlIGRldGFpbHNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0MCA9IHQxZ2xvYmFsO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBsaW5lYXIgcmV2ZXJzZSBzY2FuXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGdpdmVVcEF0ID0gaTEgLSAyOyA7ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggdDAgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBiZWZvcmUgc3RhcnRcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9jYWNoZWRJbmRleCA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuYmVmb3JlU3RhcnRfKCAwLCB0LCB0MSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGkxID09PSBnaXZlVXBBdCApIGJyZWFrOyAvLyB0aGlzIGxvb3BcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR0MSA9IHQwO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHQwID0gcHBbIC0tIGkxIC0gMSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggdCA+PSB0MCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyB3ZSBoYXZlIGFycml2ZWQgYXQgdGhlIHNvdWdodCBpbnRlcnZhbFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrIHNlZWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBwcmVwYXJlIGJpbmFyeSBzZWFyY2ggb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgaW5kZXhcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyaWdodCA9IGkxO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGkxID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhayBsaW5lYXJfc2NhbjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gdGhlIGludGVydmFsIGlzIHZhbGlkXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWsgdmFsaWRhdGVfaW50ZXJ2YWw7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSAvLyBsaW5lYXIgc2NhblxcblxcblxcdFxcdFxcdFxcdFxcdC8vIGJpbmFyeSBzZWFyY2hcXG5cXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoIGkxIDwgcmlnaHQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIG1pZCA9ICggaTEgKyByaWdodCApID4+PiAxO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggdCA8IHBwWyBtaWQgXSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyaWdodCA9IG1pZDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGkxID0gbWlkICsgMTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHQxID0gcHBbIGkxIF07XFxuXFx0XFx0XFx0XFx0XFx0dDAgPSBwcFsgaTEgLSAxIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gY2hlY2sgYm91bmRhcnkgY2FzZXMsIGFnYWluXFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0MCA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2NhY2hlZEluZGV4ID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5iZWZvcmVTdGFydF8oIDAsIHQsIHQxICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGlmICggdDEgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpMSA9IHBwLmxlbmd0aDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9jYWNoZWRJbmRleCA9IGkxO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmFmdGVyRW5kXyggaTEgLSAxLCB0MCwgdCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9IC8vIHNlZWtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl9jYWNoZWRJbmRleCA9IGkxO1xcblxcblxcdFxcdFxcdFxcdHRoaXMuaW50ZXJ2YWxDaGFuZ2VkXyggaTEsIHQwLCB0MSApO1xcblxcblxcdFxcdFxcdH0gLy8gdmFsaWRhdGVfaW50ZXJ2YWxcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5pbnRlcnBvbGF0ZV8oIGkxLCB0MCwgdCwgdDEgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldHRpbmdzOiBudWxsLCAvLyBvcHRpb25hbCwgc3ViY2xhc3Mtc3BlY2lmaWMgc2V0dGluZ3Mgc3RydWN0dXJlXFxuXFx0XFx0Ly8gTm90ZTogVGhlIGluZGlyZWN0aW9uIGFsbG93cyBjZW50cmFsIGNvbnRyb2wgb2YgbWFueSBpbnRlcnBvbGFudHMuXFxuXFxuXFx0XFx0Ly8gLS0tIFByb3RlY3RlZCBpbnRlcmZhY2VcXG5cXG5cXHRcXHREZWZhdWx0U2V0dGluZ3NfOiB7fSxcXG5cXG5cXHRcXHRnZXRTZXR0aW5nc186IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5zZXR0aW5ncyB8fCB0aGlzLkRlZmF1bHRTZXR0aW5nc187XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb3B5U2FtcGxlVmFsdWVfOiBmdW5jdGlvbiAoIGluZGV4ICkge1xcblxcblxcdFxcdFxcdC8vIGNvcGllcyBhIHNhbXBsZSB2YWx1ZSB0byB0aGUgcmVzdWx0IGJ1ZmZlclxcblxcblxcdFxcdFxcdHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcixcXG5cXHRcXHRcXHRcXHR2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcyxcXG5cXHRcXHRcXHRcXHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcXG5cXHRcXHRcXHRcXHRvZmZzZXQgPSBpbmRleCAqIHN0cmlkZTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IHN0cmlkZTsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXN1bHRbIGkgXSA9IHZhbHVlc1sgb2Zmc2V0ICsgaSBdO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gVGVtcGxhdGUgbWV0aG9kcyBmb3IgZGVyaXZlZCBjbGFzc2VzOlxcblxcblxcdFxcdGludGVycG9sYXRlXzogZnVuY3Rpb24gKCAvKiBpMSwgdDAsIHQsIHQxICovICkge1xcblxcblxcdFxcdFxcdHRocm93IG5ldyBFcnJvciggJ2NhbGwgdG8gYWJzdHJhY3QgbWV0aG9kJyApO1xcblxcdFxcdFxcdC8vIGltcGxlbWVudGF0aW9ucyBzaGFsbCByZXR1cm4gdGhpcy5yZXN1bHRCdWZmZXJcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGludGVydmFsQ2hhbmdlZF86IGZ1bmN0aW9uICggLyogaTEsIHQwLCB0MSAqLyApIHtcXG5cXG5cXHRcXHRcXHQvLyBlbXB0eVxcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0Ly8hXFxcXCBERUNMQVJFIEFMSUFTIEFGVEVSIGFzc2lnbiBwcm90b3R5cGUgIVxcblxcdE9iamVjdC5hc3NpZ24oIEludGVycG9sYW50LnByb3RvdHlwZSwge1xcblxcblxcdFxcdC8vKCAwLCB0LCB0MCApLCByZXR1cm5zIHRoaXMucmVzdWx0QnVmZmVyXFxuXFx0XFx0YmVmb3JlU3RhcnRfOiBJbnRlcnBvbGFudC5wcm90b3R5cGUuY29weVNhbXBsZVZhbHVlXyxcXG5cXG5cXHRcXHQvLyggTi0xLCB0Ti0xLCB0ICksIHJldHVybnMgdGhpcy5yZXN1bHRCdWZmZXJcXG5cXHRcXHRhZnRlckVuZF86IEludGVycG9sYW50LnByb3RvdHlwZS5jb3B5U2FtcGxlVmFsdWVfLFxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBTcGhlcmljYWwgbGluZWFyIHVuaXQgcXVhdGVybmlvbiBpbnRlcnBvbGFudC5cXG5cXHQgKlxcblxcdCAqIEBhdXRob3IgdHNjaHdcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBRdWF0ZXJuaW9uTGluZWFySW50ZXJwb2xhbnQoIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKSB7XFxuXFxuXFx0XFx0SW50ZXJwb2xhbnQuY2FsbCggdGhpcywgcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApO1xcblxcblxcdH1cXG5cXG5cXHRRdWF0ZXJuaW9uTGluZWFySW50ZXJwb2xhbnQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggSW50ZXJwb2xhbnQucHJvdG90eXBlICksIHtcXG5cXG5cXHRcXHRjb25zdHJ1Y3RvcjogUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50LFxcblxcblxcdFxcdGludGVycG9sYXRlXzogZnVuY3Rpb24gKCBpMSwgdDAsIHQsIHQxICkge1xcblxcblxcdFxcdFxcdHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcixcXG5cXHRcXHRcXHRcXHR2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcyxcXG5cXHRcXHRcXHRcXHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcXG5cXG5cXHRcXHRcXHRcXHRvZmZzZXQgPSBpMSAqIHN0cmlkZSxcXG5cXG5cXHRcXHRcXHRcXHRhbHBoYSA9ICggdCAtIHQwICkgLyAoIHQxIC0gdDAgKTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgZW5kID0gb2Zmc2V0ICsgc3RyaWRlOyBvZmZzZXQgIT09IGVuZDsgb2Zmc2V0ICs9IDQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0UXVhdGVybmlvbi5zbGVycEZsYXQoIHJlc3VsdCwgMCwgdmFsdWVzLCBvZmZzZXQgLSBzdHJpZGUsIHZhbHVlcywgb2Zmc2V0LCBhbHBoYSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0O1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICpcXG5cXHQgKiBBIFRyYWNrIG9mIHF1YXRlcm5pb24ga2V5ZnJhbWUgdmFsdWVzLlxcblxcdCAqXFxuXFx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cXG5cXHQgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cXG5cXHQgKiBAYXV0aG9yIHRzY2h3XFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gUXVhdGVybmlvbktleWZyYW1lVHJhY2soIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKSB7XFxuXFxuXFx0XFx0S2V5ZnJhbWVUcmFjay5jYWxsKCB0aGlzLCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICk7XFxuXFxuXFx0fVxcblxcblxcdFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEtleWZyYW1lVHJhY2sucHJvdG90eXBlICksIHtcXG5cXG5cXHRcXHRjb25zdHJ1Y3RvcjogUXVhdGVybmlvbktleWZyYW1lVHJhY2ssXFxuXFxuXFx0XFx0VmFsdWVUeXBlTmFtZTogJ3F1YXRlcm5pb24nLFxcblxcblxcdFxcdC8vIFZhbHVlQnVmZmVyVHlwZSBpcyBpbmhlcml0ZWRcXG5cXG5cXHRcXHREZWZhdWx0SW50ZXJwb2xhdGlvbjogSW50ZXJwb2xhdGVMaW5lYXIsXFxuXFxuXFx0XFx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyOiBmdW5jdGlvbiAoIHJlc3VsdCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IFF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudCggdGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCksIHJlc3VsdCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoOiB1bmRlZmluZWQgLy8gbm90IHlldCBpbXBsZW1lbnRlZFxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKlxcblxcdCAqIEEgVHJhY2sgb2Yga2V5ZnJhbWUgdmFsdWVzIHRoYXQgcmVwcmVzZW50IGNvbG9yLlxcblxcdCAqXFxuXFx0ICpcXG5cXHQgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xcblxcdCAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xcblxcdCAqIEBhdXRob3IgdHNjaHdcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBDb2xvcktleWZyYW1lVHJhY2soIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKSB7XFxuXFxuXFx0XFx0S2V5ZnJhbWVUcmFjay5jYWxsKCB0aGlzLCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICk7XFxuXFxuXFx0fVxcblxcblxcdENvbG9yS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBLZXlmcmFtZVRyYWNrLnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IENvbG9yS2V5ZnJhbWVUcmFjayxcXG5cXG5cXHRcXHRWYWx1ZVR5cGVOYW1lOiAnY29sb3InXFxuXFxuXFx0XFx0Ly8gVmFsdWVCdWZmZXJUeXBlIGlzIGluaGVyaXRlZFxcblxcblxcdFxcdC8vIERlZmF1bHRJbnRlcnBvbGF0aW9uIGlzIGluaGVyaXRlZFxcblxcblxcdFxcdC8vIE5vdGU6IFZlcnkgYmFzaWMgaW1wbGVtZW50YXRpb24gYW5kIG5vdGhpbmcgc3BlY2lhbCB5ZXQuXFxuXFx0XFx0Ly8gSG93ZXZlciwgdGhpcyBpcyB0aGUgcGxhY2UgZm9yIGNvbG9yIHNwYWNlIHBhcmFtZXRlcml6YXRpb24uXFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqXFxuXFx0ICogQSBUcmFjayBvZiBudW1lcmljIGtleWZyYW1lIHZhbHVlcy5cXG5cXHQgKlxcblxcdCAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXFxuXFx0ICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXFxuXFx0ICogQGF1dGhvciB0c2Nod1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIE51bWJlcktleWZyYW1lVHJhY2soIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKSB7XFxuXFxuXFx0XFx0S2V5ZnJhbWVUcmFjay5jYWxsKCB0aGlzLCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICk7XFxuXFxuXFx0fVxcblxcblxcdE51bWJlcktleWZyYW1lVHJhY2sucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBOdW1iZXJLZXlmcmFtZVRyYWNrLFxcblxcblxcdFxcdFZhbHVlVHlwZU5hbWU6ICdudW1iZXInXFxuXFxuXFx0XFx0Ly8gVmFsdWVCdWZmZXJUeXBlIGlzIGluaGVyaXRlZFxcblxcblxcdFxcdC8vIERlZmF1bHRJbnRlcnBvbGF0aW9uIGlzIGluaGVyaXRlZFxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBGYXN0IGFuZCBzaW1wbGUgY3ViaWMgc3BsaW5lIGludGVycG9sYW50LlxcblxcdCAqXFxuXFx0ICogSXQgd2FzIGRlcml2ZWQgZnJvbSBhIEhlcm1pdGlhbiBjb25zdHJ1Y3Rpb24gc2V0dGluZyB0aGUgZmlyc3QgZGVyaXZhdGl2ZVxcblxcdCAqIGF0IGVhY2ggc2FtcGxlIHBvc2l0aW9uIHRvIHRoZSBsaW5lYXIgc2xvcGUgYmV0d2VlbiBuZWlnaGJvcmluZyBwb3NpdGlvbnNcXG5cXHQgKiBvdmVyIHRoZWlyIHBhcmFtZXRlciBpbnRlcnZhbC5cXG5cXHQgKlxcblxcdCAqIEBhdXRob3IgdHNjaHdcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBDdWJpY0ludGVycG9sYW50KCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xcblxcblxcdFxcdEludGVycG9sYW50LmNhbGwoIHRoaXMsIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKTtcXG5cXG5cXHRcXHR0aGlzLl93ZWlnaHRQcmV2ID0gLSAwO1xcblxcdFxcdHRoaXMuX29mZnNldFByZXYgPSAtIDA7XFxuXFx0XFx0dGhpcy5fd2VpZ2h0TmV4dCA9IC0gMDtcXG5cXHRcXHR0aGlzLl9vZmZzZXROZXh0ID0gLSAwO1xcblxcblxcdH1cXG5cXG5cXHRDdWJpY0ludGVycG9sYW50LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEludGVycG9sYW50LnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IEN1YmljSW50ZXJwb2xhbnQsXFxuXFxuXFx0XFx0RGVmYXVsdFNldHRpbmdzXzoge1xcblxcblxcdFxcdFxcdGVuZGluZ1N0YXJ0OiBaZXJvQ3VydmF0dXJlRW5kaW5nLFxcblxcdFxcdFxcdGVuZGluZ0VuZDogWmVyb0N1cnZhdHVyZUVuZGluZ1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0aW50ZXJ2YWxDaGFuZ2VkXzogZnVuY3Rpb24gKCBpMSwgdDAsIHQxICkge1xcblxcblxcdFxcdFxcdHZhciBwcCA9IHRoaXMucGFyYW1ldGVyUG9zaXRpb25zLFxcblxcdFxcdFxcdFxcdGlQcmV2ID0gaTEgLSAyLFxcblxcdFxcdFxcdFxcdGlOZXh0ID0gaTEgKyAxLFxcblxcblxcdFxcdFxcdFxcdHRQcmV2ID0gcHBbIGlQcmV2IF0sXFxuXFx0XFx0XFx0XFx0dE5leHQgPSBwcFsgaU5leHQgXTtcXG5cXG5cXHRcXHRcXHRpZiAoIHRQcmV2ID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0c3dpdGNoICggdGhpcy5nZXRTZXR0aW5nc18oKS5lbmRpbmdTdGFydCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlIFplcm9TbG9wZUVuZGluZzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBmJyh0MCkgPSAwXFxuXFx0XFx0XFx0XFx0XFx0XFx0aVByZXYgPSBpMTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0UHJldiA9IDIgKiB0MCAtIHQxO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdGNhc2UgV3JhcEFyb3VuZEVuZGluZzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyB1c2UgdGhlIG90aGVyIGVuZCBvZiB0aGUgY3VydmVcXG5cXHRcXHRcXHRcXHRcXHRcXHRpUHJldiA9IHBwLmxlbmd0aCAtIDI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dFByZXYgPSB0MCArIHBwWyBpUHJldiBdIC0gcHBbIGlQcmV2ICsgMSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdGRlZmF1bHQ6IC8vIFplcm9DdXJ2YXR1cmVFbmRpbmdcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBmJycodDApID0gMCBhLmsuYS4gTmF0dXJhbCBTcGxpbmVcXG5cXHRcXHRcXHRcXHRcXHRcXHRpUHJldiA9IGkxO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRQcmV2ID0gdDE7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHROZXh0ID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0c3dpdGNoICggdGhpcy5nZXRTZXR0aW5nc18oKS5lbmRpbmdFbmQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSBaZXJvU2xvcGVFbmRpbmc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gZicodE4pID0gMFxcblxcdFxcdFxcdFxcdFxcdFxcdGlOZXh0ID0gaTE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dE5leHQgPSAyICogdDEgLSB0MDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlIFdyYXBBcm91bmRFbmRpbmc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gdXNlIHRoZSBvdGhlciBlbmQgb2YgdGhlIGN1cnZlXFxuXFx0XFx0XFx0XFx0XFx0XFx0aU5leHQgPSAxO1xcblxcdFxcdFxcdFxcdFxcdFxcdHROZXh0ID0gdDEgKyBwcFsgMSBdIC0gcHBbIDAgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRkZWZhdWx0OiAvLyBaZXJvQ3VydmF0dXJlRW5kaW5nXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gZicnKHROKSA9IDAsIGEuay5hLiBOYXR1cmFsIFNwbGluZVxcblxcdFxcdFxcdFxcdFxcdFxcdGlOZXh0ID0gaTEgLSAxO1xcblxcdFxcdFxcdFxcdFxcdFxcdHROZXh0ID0gdDA7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgaGFsZkR0ID0gKCB0MSAtIHQwICkgKiAwLjUsXFxuXFx0XFx0XFx0XFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemU7XFxuXFxuXFx0XFx0XFx0dGhpcy5fd2VpZ2h0UHJldiA9IGhhbGZEdCAvICggdDAgLSB0UHJldiApO1xcblxcdFxcdFxcdHRoaXMuX3dlaWdodE5leHQgPSBoYWxmRHQgLyAoIHROZXh0IC0gdDEgKTtcXG5cXHRcXHRcXHR0aGlzLl9vZmZzZXRQcmV2ID0gaVByZXYgKiBzdHJpZGU7XFxuXFx0XFx0XFx0dGhpcy5fb2Zmc2V0TmV4dCA9IGlOZXh0ICogc3RyaWRlO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0aW50ZXJwb2xhdGVfOiBmdW5jdGlvbiAoIGkxLCB0MCwgdCwgdDEgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLFxcblxcdFxcdFxcdFxcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxcblxcdFxcdFxcdFxcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxcblxcblxcdFxcdFxcdFxcdG8xID0gaTEgKiBzdHJpZGUsXFx0XFx0bzAgPSBvMSAtIHN0cmlkZSxcXG5cXHRcXHRcXHRcXHRvUCA9IHRoaXMuX29mZnNldFByZXYsIFxcdG9OID0gdGhpcy5fb2Zmc2V0TmV4dCxcXG5cXHRcXHRcXHRcXHR3UCA9IHRoaXMuX3dlaWdodFByZXYsXFx0d04gPSB0aGlzLl93ZWlnaHROZXh0LFxcblxcblxcdFxcdFxcdFxcdHAgPSAoIHQgLSB0MCApIC8gKCB0MSAtIHQwICksXFxuXFx0XFx0XFx0XFx0cHAgPSBwICogcCxcXG5cXHRcXHRcXHRcXHRwcHAgPSBwcCAqIHA7XFxuXFxuXFx0XFx0XFx0Ly8gZXZhbHVhdGUgcG9seW5vbWlhbHNcXG5cXG5cXHRcXHRcXHR2YXIgc1AgPSAtIHdQICogcHBwICsgMiAqIHdQICogcHAgLSB3UCAqIHA7XFxuXFx0XFx0XFx0dmFyIHMwID0gKCAxICsgd1AgKSAqIHBwcCArICggLSAxLjUgLSAyICogd1AgKSAqIHBwICsgKCAtIDAuNSArIHdQICkgKiBwICsgMTtcXG5cXHRcXHRcXHR2YXIgczEgPSAoIC0gMSAtIHdOICkgKiBwcHAgKyAoIDEuNSArIHdOICkgKiBwcCArIDAuNSAqIHA7XFxuXFx0XFx0XFx0dmFyIHNOID0gd04gKiBwcHAgLSB3TiAqIHBwO1xcblxcblxcdFxcdFxcdC8vIGNvbWJpbmUgZGF0YSBsaW5lYXJseVxcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xcblxcblxcdFxcdFxcdFxcdHJlc3VsdFsgaSBdID1cXG5cXHRcXHRcXHRcXHRcXHRcXHRzUCAqIHZhbHVlc1sgb1AgKyBpIF0gK1xcblxcdFxcdFxcdFxcdFxcdFxcdHMwICogdmFsdWVzWyBvMCArIGkgXSArXFxuXFx0XFx0XFx0XFx0XFx0XFx0czEgKiB2YWx1ZXNbIG8xICsgaSBdICtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzTiAqIHZhbHVlc1sgb04gKyBpIF07XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiByZXN1bHQ7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIHRzY2h3XFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gTGluZWFySW50ZXJwb2xhbnQoIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKSB7XFxuXFxuXFx0XFx0SW50ZXJwb2xhbnQuY2FsbCggdGhpcywgcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApO1xcblxcblxcdH1cXG5cXG5cXHRMaW5lYXJJbnRlcnBvbGFudC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBJbnRlcnBvbGFudC5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBMaW5lYXJJbnRlcnBvbGFudCxcXG5cXG5cXHRcXHRpbnRlcnBvbGF0ZV86IGZ1bmN0aW9uICggaTEsIHQwLCB0LCB0MSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXFxuXFx0XFx0XFx0XFx0dmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXMsXFxuXFx0XFx0XFx0XFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXFxuXFxuXFx0XFx0XFx0XFx0b2Zmc2V0MSA9IGkxICogc3RyaWRlLFxcblxcdFxcdFxcdFxcdG9mZnNldDAgPSBvZmZzZXQxIC0gc3RyaWRlLFxcblxcblxcdFxcdFxcdFxcdHdlaWdodDEgPSAoIHQgLSB0MCApIC8gKCB0MSAtIHQwICksXFxuXFx0XFx0XFx0XFx0d2VpZ2h0MCA9IDEgLSB3ZWlnaHQxO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xcblxcblxcdFxcdFxcdFxcdHJlc3VsdFsgaSBdID1cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWx1ZXNbIG9mZnNldDAgKyBpIF0gKiB3ZWlnaHQwICtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWx1ZXNbIG9mZnNldDEgKyBpIF0gKiB3ZWlnaHQxO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0O1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICpcXG5cXHQgKiBJbnRlcnBvbGFudCB0aGF0IGV2YWx1YXRlcyB0byB0aGUgc2FtcGxlIHZhbHVlIGF0IHRoZSBwb3NpdGlvbiBwcmVjZWVkaW5nXFxuXFx0ICogdGhlIHBhcmFtZXRlci5cXG5cXHQgKlxcblxcdCAqIEBhdXRob3IgdHNjaHdcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBEaXNjcmV0ZUludGVycG9sYW50KCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICkge1xcblxcblxcdFxcdEludGVycG9sYW50LmNhbGwoIHRoaXMsIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKTtcXG5cXG5cXHR9XFxuXFxuXFx0RGlzY3JldGVJbnRlcnBvbGFudC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBJbnRlcnBvbGFudC5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBEaXNjcmV0ZUludGVycG9sYW50LFxcblxcblxcdFxcdGludGVycG9sYXRlXzogZnVuY3Rpb24gKCBpMSAvKiwgdDAsIHQsIHQxICovICkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmNvcHlTYW1wbGVWYWx1ZV8oIGkxIC0gMSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciB0c2Nod1xcblxcdCAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXFxuXFx0ICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXFxuXFx0ICovXFxuXFxuXFx0dmFyIEFuaW1hdGlvblV0aWxzID0ge1xcblxcblxcdFxcdC8vIHNhbWUgYXMgQXJyYXkucHJvdG90eXBlLnNsaWNlLCBidXQgYWxzbyB3b3JrcyBvbiB0eXBlZCBhcnJheXNcXG5cXHRcXHRhcnJheVNsaWNlOiBmdW5jdGlvbiAoIGFycmF5LCBmcm9tLCB0byApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIEFuaW1hdGlvblV0aWxzLmlzVHlwZWRBcnJheSggYXJyYXkgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBpbiBpb3M5IGFycmF5LnN1YmFycmF5KGZyb20sIHVuZGVmaW5lZCkgd2lsbCByZXR1cm4gZW1wdHkgYXJyYXlcXG5cXHRcXHRcXHRcXHQvLyBidXQgYXJyYXkuc3ViYXJyYXkoZnJvbSkgb3IgYXJyYXkuc3ViYXJyYXkoZnJvbSwgbGVuKSBpcyBjb3JyZWN0XFxuXFx0XFx0XFx0XFx0cmV0dXJuIG5ldyBhcnJheS5jb25zdHJ1Y3RvciggYXJyYXkuc3ViYXJyYXkoIGZyb20sIHRvICE9PSB1bmRlZmluZWQgPyB0byA6IGFycmF5Lmxlbmd0aCApICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBhcnJheS5zbGljZSggZnJvbSwgdG8gKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIGNvbnZlcnRzIGFuIGFycmF5IHRvIGEgc3BlY2lmaWMgdHlwZVxcblxcdFxcdGNvbnZlcnRBcnJheTogZnVuY3Rpb24gKCBhcnJheSwgdHlwZSwgZm9yY2VDbG9uZSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoICEgYXJyYXkgfHwgLy8gbGV0ICd1bmRlZmluZWQnIGFuZCAnbnVsbCcgcGFzc1xcblxcdFxcdFxcdFxcdFxcdCEgZm9yY2VDbG9uZSAmJiBhcnJheS5jb25zdHJ1Y3RvciA9PT0gdHlwZSApIHJldHVybiBhcnJheTtcXG5cXG5cXHRcXHRcXHRpZiAoIHR5cGVvZiB0eXBlLkJZVEVTX1BFUl9FTEVNRU5UID09PSAnbnVtYmVyJyApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gbmV3IHR5cGUoIGFycmF5ICk7IC8vIGNyZWF0ZSB0eXBlZCBhcnJheVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFycmF5ICk7IC8vIGNyZWF0ZSBBcnJheVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0aXNUeXBlZEFycmF5OiBmdW5jdGlvbiAoIG9iamVjdCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gQXJyYXlCdWZmZXIuaXNWaWV3KCBvYmplY3QgKSAmJlxcblxcdFxcdFxcdFxcdFxcdCEgKCBvYmplY3QgaW5zdGFuY2VvZiBEYXRhVmlldyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gcmV0dXJucyBhbiBhcnJheSBieSB3aGljaCB0aW1lcyBhbmQgdmFsdWVzIGNhbiBiZSBzb3J0ZWRcXG5cXHRcXHRnZXRLZXlmcmFtZU9yZGVyOiBmdW5jdGlvbiAoIHRpbWVzICkge1xcblxcblxcdFxcdFxcdGZ1bmN0aW9uIGNvbXBhcmVUaW1lKCBpLCBqICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aW1lc1sgaSBdIC0gdGltZXNbIGogXTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIG4gPSB0aW1lcy5sZW5ndGg7XFxuXFx0XFx0XFx0dmFyIHJlc3VsdCA9IG5ldyBBcnJheSggbiApO1xcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbjsgKysgaSApIHJlc3VsdFsgaSBdID0gaTtcXG5cXG5cXHRcXHRcXHRyZXN1bHQuc29ydCggY29tcGFyZVRpbWUgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gdXNlcyB0aGUgYXJyYXkgcHJldmlvdXNseSByZXR1cm5lZCBieSAnZ2V0S2V5ZnJhbWVPcmRlcicgdG8gc29ydCBkYXRhXFxuXFx0XFx0c29ydGVkQXJyYXk6IGZ1bmN0aW9uICggdmFsdWVzLCBzdHJpZGUsIG9yZGVyICkge1xcblxcblxcdFxcdFxcdHZhciBuVmFsdWVzID0gdmFsdWVzLmxlbmd0aDtcXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0gbmV3IHZhbHVlcy5jb25zdHJ1Y3RvciggblZhbHVlcyApO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgZHN0T2Zmc2V0ID0gMDsgZHN0T2Zmc2V0ICE9PSBuVmFsdWVzOyArKyBpICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBzcmNPZmZzZXQgPSBvcmRlclsgaSBdICogc3RyaWRlO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBqID0gMDsgaiAhPT0gc3RyaWRlOyArKyBqICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJlc3VsdFsgZHN0T2Zmc2V0ICsrIF0gPSB2YWx1ZXNbIHNyY09mZnNldCArIGogXTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiByZXN1bHQ7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBmdW5jdGlvbiBmb3IgcGFyc2luZyBBT1Mga2V5ZnJhbWUgZm9ybWF0c1xcblxcdFxcdGZsYXR0ZW5KU09OOiBmdW5jdGlvbiAoIGpzb25LZXlzLCB0aW1lcywgdmFsdWVzLCB2YWx1ZVByb3BlcnR5TmFtZSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgaSA9IDEsIGtleSA9IGpzb25LZXlzWyAwIF07XFxuXFxuXFx0XFx0XFx0d2hpbGUgKCBrZXkgIT09IHVuZGVmaW5lZCAmJiBrZXlbIHZhbHVlUHJvcGVydHlOYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRrZXkgPSBqc29uS2V5c1sgaSArKyBdO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuOyAvLyBubyBkYXRhXFxuXFxuXFx0XFx0XFx0dmFyIHZhbHVlID0ga2V5WyB2YWx1ZVByb3BlcnR5TmFtZSBdO1xcblxcdFxcdFxcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHJldHVybjsgLy8gbm8gZGF0YVxcblxcblxcdFxcdFxcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRkbyB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFsdWUgPSBrZXlbIHZhbHVlUHJvcGVydHlOYW1lIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRpbWVzLnB1c2goIGtleS50aW1lICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFsdWVzLnB1c2guYXBwbHkoIHZhbHVlcywgdmFsdWUgKTsgLy8gcHVzaCBhbGwgZWxlbWVudHNcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0a2V5ID0ganNvbktleXNbIGkgKysgXTtcXG5cXG5cXHRcXHRcXHRcXHR9IHdoaWxlICgga2V5ICE9PSB1bmRlZmluZWQgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCB2YWx1ZS50b0FycmF5ICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gLi4uYXNzdW1lIFRIUkVFLk1hdGgtaXNoXFxuXFxuXFx0XFx0XFx0XFx0ZG8ge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhbHVlID0ga2V5WyB2YWx1ZVByb3BlcnR5TmFtZSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aW1lcy5wdXNoKCBrZXkudGltZSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhbHVlLnRvQXJyYXkoIHZhbHVlcywgdmFsdWVzLmxlbmd0aCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRrZXkgPSBqc29uS2V5c1sgaSArKyBdO1xcblxcblxcdFxcdFxcdFxcdH0gd2hpbGUgKCBrZXkgIT09IHVuZGVmaW5lZCApO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gb3RoZXJ3aXNlIHB1c2ggYXMtaXNcXG5cXG5cXHRcXHRcXHRcXHRkbyB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFsdWUgPSBrZXlbIHZhbHVlUHJvcGVydHlOYW1lIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRpbWVzLnB1c2goIGtleS50aW1lICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGtleSA9IGpzb25LZXlzWyBpICsrIF07XFxuXFxuXFx0XFx0XFx0XFx0fSB3aGlsZSAoIGtleSAhPT0gdW5kZWZpbmVkICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqXFxuXFx0ICogQSB0aW1lZCBzZXF1ZW5jZSBvZiBrZXlmcmFtZXMgZm9yIGEgc3BlY2lmaWMgcHJvcGVydHkuXFxuXFx0ICpcXG5cXHQgKlxcblxcdCAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXFxuXFx0ICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXFxuXFx0ICogQGF1dGhvciB0c2Nod1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEtleWZyYW1lVHJhY2soIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKSB7XFxuXFxuXFx0XFx0aWYgKCBuYW1lID09PSB1bmRlZmluZWQgKSB0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5LZXlmcmFtZVRyYWNrOiB0cmFjayBuYW1lIGlzIHVuZGVmaW5lZCcgKTtcXG5cXHRcXHRpZiAoIHRpbWVzID09PSB1bmRlZmluZWQgfHwgdGltZXMubGVuZ3RoID09PSAwICkgdGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazogbm8ga2V5ZnJhbWVzIGluIHRyYWNrIG5hbWVkICcgKyBuYW1lICk7XFxuXFxuXFx0XFx0dGhpcy5uYW1lID0gbmFtZTtcXG5cXG5cXHRcXHR0aGlzLnRpbWVzID0gQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KCB0aW1lcywgdGhpcy5UaW1lQnVmZmVyVHlwZSApO1xcblxcdFxcdHRoaXMudmFsdWVzID0gQW5pbWF0aW9uVXRpbHMuY29udmVydEFycmF5KCB2YWx1ZXMsIHRoaXMuVmFsdWVCdWZmZXJUeXBlICk7XFxuXFxuXFx0XFx0dGhpcy5zZXRJbnRlcnBvbGF0aW9uKCBpbnRlcnBvbGF0aW9uIHx8IHRoaXMuRGVmYXVsdEludGVycG9sYXRpb24gKTtcXG5cXG5cXHRcXHR0aGlzLnZhbGlkYXRlKCk7XFxuXFx0XFx0dGhpcy5vcHRpbWl6ZSgpO1xcblxcblxcdH1cXG5cXG5cXHQvLyBTdGF0aWMgbWV0aG9kczpcXG5cXG5cXHRPYmplY3QuYXNzaWduKCBLZXlmcmFtZVRyYWNrLCB7XFxuXFxuXFx0XFx0Ly8gU2VyaWFsaXphdGlvbiAoaW4gc3RhdGljIGNvbnRleHQsIGJlY2F1c2Ugb2YgY29uc3RydWN0b3IgaW52b2NhdGlvblxcblxcdFxcdC8vIGFuZCBhdXRvbWF0aWMgaW52b2NhdGlvbiBvZiAudG9KU09OKTpcXG5cXG5cXHRcXHRwYXJzZTogZnVuY3Rpb24gKCBqc29uICkge1xcblxcblxcdFxcdFxcdGlmICgganNvbi50eXBlID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazogdHJhY2sgdHlwZSB1bmRlZmluZWQsIGNhbiBub3QgcGFyc2UnICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciB0cmFja1R5cGUgPSBLZXlmcmFtZVRyYWNrLl9nZXRUcmFja1R5cGVGb3JWYWx1ZVR5cGVOYW1lKCBqc29uLnR5cGUgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGpzb24udGltZXMgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdGltZXMgPSBbXSwgdmFsdWVzID0gW107XFxuXFxuXFx0XFx0XFx0XFx0QW5pbWF0aW9uVXRpbHMuZmxhdHRlbkpTT04oIGpzb24ua2V5cywgdGltZXMsIHZhbHVlcywgJ3ZhbHVlJyApO1xcblxcblxcdFxcdFxcdFxcdGpzb24udGltZXMgPSB0aW1lcztcXG5cXHRcXHRcXHRcXHRqc29uLnZhbHVlcyA9IHZhbHVlcztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gZGVyaXZlZCBjbGFzc2VzIGNhbiBkZWZpbmUgYSBzdGF0aWMgcGFyc2UgbWV0aG9kXFxuXFx0XFx0XFx0aWYgKCB0cmFja1R5cGUucGFyc2UgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJhY2tUeXBlLnBhcnNlKCBqc29uICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBieSBkZWZhdWx0LCB3ZSBhc3N1bWUgYSBjb25zdHJ1Y3RvciBjb21wYXRpYmxlIHdpdGggdGhlIGJhc2VcXG5cXHRcXHRcXHRcXHRyZXR1cm4gbmV3IHRyYWNrVHlwZSgganNvbi5uYW1lLCBqc29uLnRpbWVzLCBqc29uLnZhbHVlcywganNvbi5pbnRlcnBvbGF0aW9uICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dG9KU09OOiBmdW5jdGlvbiAoIHRyYWNrICkge1xcblxcblxcdFxcdFxcdHZhciB0cmFja1R5cGUgPSB0cmFjay5jb25zdHJ1Y3RvcjtcXG5cXG5cXHRcXHRcXHR2YXIganNvbjtcXG5cXG5cXHRcXHRcXHQvLyBkZXJpdmVkIGNsYXNzZXMgY2FuIGRlZmluZSBhIHN0YXRpYyB0b0pTT04gbWV0aG9kXFxuXFx0XFx0XFx0aWYgKCB0cmFja1R5cGUudG9KU09OICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0anNvbiA9IHRyYWNrVHlwZS50b0pTT04oIHRyYWNrICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBieSBkZWZhdWx0LCB3ZSBhc3N1bWUgdGhlIGRhdGEgY2FuIGJlIHNlcmlhbGl6ZWQgYXMtaXNcXG5cXHRcXHRcXHRcXHRqc29uID0ge1xcblxcblxcdFxcdFxcdFxcdFxcdCduYW1lJzogdHJhY2submFtZSxcXG5cXHRcXHRcXHRcXHRcXHQndGltZXMnOiBBbmltYXRpb25VdGlscy5jb252ZXJ0QXJyYXkoIHRyYWNrLnRpbWVzLCBBcnJheSApLFxcblxcdFxcdFxcdFxcdFxcdCd2YWx1ZXMnOiBBbmltYXRpb25VdGlscy5jb252ZXJ0QXJyYXkoIHRyYWNrLnZhbHVlcywgQXJyYXkgKVxcblxcblxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGludGVycG9sYXRpb24gPSB0cmFjay5nZXRJbnRlcnBvbGF0aW9uKCk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBpbnRlcnBvbGF0aW9uICE9PSB0cmFjay5EZWZhdWx0SW50ZXJwb2xhdGlvbiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRqc29uLmludGVycG9sYXRpb24gPSBpbnRlcnBvbGF0aW9uO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0anNvbi50eXBlID0gdHJhY2suVmFsdWVUeXBlTmFtZTsgLy8gbWFuZGF0b3J5XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGpzb247XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZ2V0VHJhY2tUeXBlRm9yVmFsdWVUeXBlTmFtZTogZnVuY3Rpb24gKCB0eXBlTmFtZSApIHtcXG5cXG5cXHRcXHRcXHRzd2l0Y2ggKCB0eXBlTmFtZS50b0xvd2VyQ2FzZSgpICkge1xcblxcblxcdFxcdFxcdFxcdGNhc2UgJ3NjYWxhcic6XFxuXFx0XFx0XFx0XFx0Y2FzZSAnZG91YmxlJzpcXG5cXHRcXHRcXHRcXHRjYXNlICdmbG9hdCc6XFxuXFx0XFx0XFx0XFx0Y2FzZSAnbnVtYmVyJzpcXG5cXHRcXHRcXHRcXHRjYXNlICdpbnRlZ2VyJzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gTnVtYmVyS2V5ZnJhbWVUcmFjaztcXG5cXG5cXHRcXHRcXHRcXHRjYXNlICd2ZWN0b3InOlxcblxcdFxcdFxcdFxcdGNhc2UgJ3ZlY3RvcjInOlxcblxcdFxcdFxcdFxcdGNhc2UgJ3ZlY3RvcjMnOlxcblxcdFxcdFxcdFxcdGNhc2UgJ3ZlY3RvcjQnOlxcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBWZWN0b3JLZXlmcmFtZVRyYWNrO1xcblxcblxcdFxcdFxcdFxcdGNhc2UgJ2NvbG9yJzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gQ29sb3JLZXlmcmFtZVRyYWNrO1xcblxcblxcdFxcdFxcdFxcdGNhc2UgJ3F1YXRlcm5pb24nOlxcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaztcXG5cXG5cXHRcXHRcXHRcXHRjYXNlICdib29sJzpcXG5cXHRcXHRcXHRcXHRjYXNlICdib29sZWFuJzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gQm9vbGVhbktleWZyYW1lVHJhY2s7XFxuXFxuXFx0XFx0XFx0XFx0Y2FzZSAnc3RyaW5nJzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gU3RyaW5nS2V5ZnJhbWVUcmFjaztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhyb3cgbmV3IEVycm9yKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazogVW5zdXBwb3J0ZWQgdHlwZU5hbWU6ICcgKyB0eXBlTmFtZSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRjb25zdHJ1Y3RvcjogS2V5ZnJhbWVUcmFjayxcXG5cXG5cXHRcXHRUaW1lQnVmZmVyVHlwZTogRmxvYXQzMkFycmF5LFxcblxcblxcdFxcdFZhbHVlQnVmZmVyVHlwZTogRmxvYXQzMkFycmF5LFxcblxcblxcdFxcdERlZmF1bHRJbnRlcnBvbGF0aW9uOiBJbnRlcnBvbGF0ZUxpbmVhcixcXG5cXG5cXHRcXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2REaXNjcmV0ZTogZnVuY3Rpb24gKCByZXN1bHQgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyBEaXNjcmV0ZUludGVycG9sYW50KCB0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSwgcmVzdWx0ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXI6IGZ1bmN0aW9uICggcmVzdWx0ICkge1xcblxcblxcdFxcdFxcdHJldHVybiBuZXcgTGluZWFySW50ZXJwb2xhbnQoIHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpLCByZXN1bHQgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdEludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aDogZnVuY3Rpb24gKCByZXN1bHQgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyBDdWJpY0ludGVycG9sYW50KCB0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSwgcmVzdWx0ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRJbnRlcnBvbGF0aW9uOiBmdW5jdGlvbiAoIGludGVycG9sYXRpb24gKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGZhY3RvcnlNZXRob2Q7XFxuXFxuXFx0XFx0XFx0c3dpdGNoICggaW50ZXJwb2xhdGlvbiApIHtcXG5cXG5cXHRcXHRcXHRcXHRjYXNlIEludGVycG9sYXRlRGlzY3JldGU6XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZmFjdG9yeU1ldGhvZCA9IHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kRGlzY3JldGU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0Y2FzZSBJbnRlcnBvbGF0ZUxpbmVhcjpcXG5cXG5cXHRcXHRcXHRcXHRcXHRmYWN0b3J5TWV0aG9kID0gdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXI7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0Y2FzZSBJbnRlcnBvbGF0ZVNtb290aDpcXG5cXG5cXHRcXHRcXHRcXHRcXHRmYWN0b3J5TWV0aG9kID0gdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggZmFjdG9yeU1ldGhvZCA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBtZXNzYWdlID0gXFxcInVuc3VwcG9ydGVkIGludGVycG9sYXRpb24gZm9yIFxcXCIgK1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuVmFsdWVUeXBlTmFtZSArIFxcXCIga2V5ZnJhbWUgdHJhY2sgbmFtZWQgXFxcIiArIHRoaXMubmFtZTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHRoaXMuY3JlYXRlSW50ZXJwb2xhbnQgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBmYWxsIGJhY2sgdG8gZGVmYXVsdCwgdW5sZXNzIHRoZSBkZWZhdWx0IGl0c2VsZiBpcyBtZXNzZWQgdXBcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGludGVycG9sYXRpb24gIT09IHRoaXMuRGVmYXVsdEludGVycG9sYXRpb24gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5zZXRJbnRlcnBvbGF0aW9uKCB0aGlzLkRlZmF1bHRJbnRlcnBvbGF0aW9uICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoIG1lc3NhZ2UgKTsgLy8gZmF0YWwsIGluIHRoaXMgY2FzZVxcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazonLCBtZXNzYWdlICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLmNyZWF0ZUludGVycG9sYW50ID0gZmFjdG9yeU1ldGhvZDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldEludGVycG9sYXRpb246IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRzd2l0Y2ggKCB0aGlzLmNyZWF0ZUludGVycG9sYW50ICkge1xcblxcblxcdFxcdFxcdFxcdGNhc2UgdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2REaXNjcmV0ZTpcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gSW50ZXJwb2xhdGVEaXNjcmV0ZTtcXG5cXG5cXHRcXHRcXHRcXHRjYXNlIHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyOlxcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBJbnRlcnBvbGF0ZUxpbmVhcjtcXG5cXG5cXHRcXHRcXHRcXHRjYXNlIHRoaXMuSW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoOlxcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBJbnRlcnBvbGF0ZVNtb290aDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRWYWx1ZVNpemU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy52YWx1ZXMubGVuZ3RoIC8gdGhpcy50aW1lcy5sZW5ndGg7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBtb3ZlIGFsbCBrZXlmcmFtZXMgZWl0aGVyIGZvcndhcmRzIG9yIGJhY2t3YXJkcyBpbiB0aW1lXFxuXFx0XFx0c2hpZnQ6IGZ1bmN0aW9uICggdGltZU9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRpbWVPZmZzZXQgIT09IDAuMCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdGltZXMgPSB0aGlzLnRpbWVzO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbiA9IHRpbWVzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aW1lc1sgaSBdICs9IHRpbWVPZmZzZXQ7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIHNjYWxlIGFsbCBrZXlmcmFtZSB0aW1lcyBieSBhIGZhY3RvciAodXNlZnVsIGZvciBmcmFtZSA8LT4gc2Vjb25kcyBjb252ZXJzaW9ucylcXG5cXHRcXHRzY2FsZTogZnVuY3Rpb24gKCB0aW1lU2NhbGUgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aW1lU2NhbGUgIT09IDEuMCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdGltZXMgPSB0aGlzLnRpbWVzO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbiA9IHRpbWVzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aW1lc1sgaSBdICo9IHRpbWVTY2FsZTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gcmVtb3ZlcyBrZXlmcmFtZXMgYmVmb3JlIGFuZCBhZnRlciBhbmltYXRpb24gd2l0aG91dCBjaGFuZ2luZyBhbnkgdmFsdWVzIHdpdGhpbiB0aGUgcmFuZ2UgW3N0YXJ0VGltZSwgZW5kVGltZV0uXFxuXFx0XFx0Ly8gSU1QT1JUQU5UOiBXZSBkbyBub3Qgc2hpZnQgYXJvdW5kIGtleXMgdG8gdGhlIHN0YXJ0IG9mIHRoZSB0cmFjayB0aW1lLCBiZWNhdXNlIGZvciBpbnRlcnBvbGF0ZWQga2V5cyB0aGlzIHdpbGwgY2hhbmdlIHRoZWlyIHZhbHVlc1xcblxcdFxcdHRyaW06IGZ1bmN0aW9uICggc3RhcnRUaW1lLCBlbmRUaW1lICkge1xcblxcblxcdFxcdFxcdHZhciB0aW1lcyA9IHRoaXMudGltZXMsXFxuXFx0XFx0XFx0XFx0bktleXMgPSB0aW1lcy5sZW5ndGgsXFxuXFx0XFx0XFx0XFx0ZnJvbSA9IDAsXFxuXFx0XFx0XFx0XFx0dG8gPSBuS2V5cyAtIDE7XFxuXFxuXFx0XFx0XFx0d2hpbGUgKCBmcm9tICE9PSBuS2V5cyAmJiB0aW1lc1sgZnJvbSBdIDwgc3RhcnRUaW1lICkge1xcblxcblxcdFxcdFxcdFxcdCsrIGZyb207XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHdoaWxlICggdG8gIT09IC0gMSAmJiB0aW1lc1sgdG8gXSA+IGVuZFRpbWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0LS0gdG87XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdCsrIHRvOyAvLyBpbmNsdXNpdmUgLT4gZXhjbHVzaXZlIGJvdW5kXFxuXFxuXFx0XFx0XFx0aWYgKCBmcm9tICE9PSAwIHx8IHRvICE9PSBuS2V5cyApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBlbXB0eSB0cmFja3MgYXJlIGZvcmJpZGRlbiwgc28ga2VlcCBhdCBsZWFzdCBvbmUga2V5ZnJhbWVcXG5cXHRcXHRcXHRcXHRpZiAoIGZyb20gPj0gdG8gKSB0byA9IE1hdGgubWF4KCB0bywgMSApLCBmcm9tID0gdG8gLSAxO1xcblxcblxcdFxcdFxcdFxcdHZhciBzdHJpZGUgPSB0aGlzLmdldFZhbHVlU2l6ZSgpO1xcblxcdFxcdFxcdFxcdHRoaXMudGltZXMgPSBBbmltYXRpb25VdGlscy5hcnJheVNsaWNlKCB0aW1lcywgZnJvbSwgdG8gKTtcXG5cXHRcXHRcXHRcXHR0aGlzLnZhbHVlcyA9IEFuaW1hdGlvblV0aWxzLmFycmF5U2xpY2UoIHRoaXMudmFsdWVzLCBmcm9tICogc3RyaWRlLCB0byAqIHN0cmlkZSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIGVuc3VyZSB3ZSBkbyBub3QgZ2V0IGEgR2FyYmFnZUluR2FyYmFnZU91dCBzaXR1YXRpb24sIG1ha2Ugc3VyZSB0cmFja3MgYXJlIGF0IGxlYXN0IG1pbmltYWxseSB2aWFibGVcXG5cXHRcXHR2YWxpZGF0ZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB2YWxpZCA9IHRydWU7XFxuXFxuXFx0XFx0XFx0dmFyIHZhbHVlU2l6ZSA9IHRoaXMuZ2V0VmFsdWVTaXplKCk7XFxuXFx0XFx0XFx0aWYgKCB2YWx1ZVNpemUgLSBNYXRoLmZsb29yKCB2YWx1ZVNpemUgKSAhPT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazogSW52YWxpZCB2YWx1ZSBzaXplIGluIHRyYWNrLicsIHRoaXMgKTtcXG5cXHRcXHRcXHRcXHR2YWxpZCA9IGZhbHNlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgdGltZXMgPSB0aGlzLnRpbWVzLFxcblxcdFxcdFxcdFxcdHZhbHVlcyA9IHRoaXMudmFsdWVzLFxcblxcblxcdFxcdFxcdFxcdG5LZXlzID0gdGltZXMubGVuZ3RoO1xcblxcblxcdFxcdFxcdGlmICggbktleXMgPT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLktleWZyYW1lVHJhY2s6IFRyYWNrIGlzIGVtcHR5LicsIHRoaXMgKTtcXG5cXHRcXHRcXHRcXHR2YWxpZCA9IGZhbHNlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgcHJldlRpbWUgPSBudWxsO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbktleXM7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGN1cnJUaW1lID0gdGltZXNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHR5cGVvZiBjdXJyVGltZSA9PT0gJ251bWJlcicgJiYgaXNOYU4oIGN1cnJUaW1lICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLktleWZyYW1lVHJhY2s6IFRpbWUgaXMgbm90IGEgdmFsaWQgbnVtYmVyLicsIHRoaXMsIGksIGN1cnJUaW1lICk7XFxuXFx0XFx0XFx0XFx0XFx0dmFsaWQgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBwcmV2VGltZSAhPT0gbnVsbCAmJiBwcmV2VGltZSA+IGN1cnJUaW1lICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5LZXlmcmFtZVRyYWNrOiBPdXQgb2Ygb3JkZXIga2V5cy4nLCB0aGlzLCBpLCBjdXJyVGltZSwgcHJldlRpbWUgKTtcXG5cXHRcXHRcXHRcXHRcXHR2YWxpZCA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRwcmV2VGltZSA9IGN1cnJUaW1lO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHZhbHVlcyAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggQW5pbWF0aW9uVXRpbHMuaXNUeXBlZEFycmF5KCB2YWx1ZXMgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIG4gPSB2YWx1ZXMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciB2YWx1ZSA9IHZhbHVlc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggaXNOYU4oIHZhbHVlICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLktleWZyYW1lVHJhY2s6IFZhbHVlIGlzIG5vdCBhIHZhbGlkIG51bWJlci4nLCB0aGlzLCBpLCB2YWx1ZSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhbGlkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB2YWxpZDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIHJlbW92ZXMgZXF1aXZhbGVudCBzZXF1ZW50aWFsIGtleXMgYXMgY29tbW9uIGluIG1vcnBoIHRhcmdldCBzZXF1ZW5jZXNcXG5cXHRcXHQvLyAoMCwwLDAsMCwxLDEsMSwwLDAsMCwwLDAsMCwwKSAtLT4gKDAsMCwxLDEsMCwwKVxcblxcdFxcdG9wdGltaXplOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHRpbWVzID0gdGhpcy50aW1lcyxcXG5cXHRcXHRcXHRcXHR2YWx1ZXMgPSB0aGlzLnZhbHVlcyxcXG5cXHRcXHRcXHRcXHRzdHJpZGUgPSB0aGlzLmdldFZhbHVlU2l6ZSgpLFxcblxcblxcdFxcdFxcdFxcdHNtb290aEludGVycG9sYXRpb24gPSB0aGlzLmdldEludGVycG9sYXRpb24oKSA9PT0gSW50ZXJwb2xhdGVTbW9vdGgsXFxuXFxuXFx0XFx0XFx0XFx0d3JpdGVJbmRleCA9IDEsXFxuXFx0XFx0XFx0XFx0bGFzdEluZGV4ID0gdGltZXMubGVuZ3RoIC0gMTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDE7IGkgPCBsYXN0SW5kZXg7ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGtlZXAgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdGltZSA9IHRpbWVzWyBpIF07XFxuXFx0XFx0XFx0XFx0dmFyIHRpbWVOZXh0ID0gdGltZXNbIGkgKyAxIF07XFxuXFxuXFx0XFx0XFx0XFx0Ly8gcmVtb3ZlIGFkamFjZW50IGtleWZyYW1lcyBzY2hlZHVsZWQgYXQgdGhlIHNhbWUgdGltZVxcblxcblxcdFxcdFxcdFxcdGlmICggdGltZSAhPT0gdGltZU5leHQgJiYgKCBpICE9PSAxIHx8IHRpbWUgIT09IHRpbWVbIDAgXSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggISBzbW9vdGhJbnRlcnBvbGF0aW9uICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHJlbW92ZSB1bm5lY2Vzc2FyeSBrZXlmcmFtZXMgc2FtZSBhcyB0aGVpciBuZWlnaGJvcnNcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgb2Zmc2V0ID0gaSAqIHN0cmlkZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRvZmZzZXRQID0gb2Zmc2V0IC0gc3RyaWRlLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG9mZnNldE4gPSBvZmZzZXQgKyBzdHJpZGU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGogPSAwOyBqICE9PSBzdHJpZGU7ICsrIGogKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIHZhbHVlID0gdmFsdWVzWyBvZmZzZXQgKyBqIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB2YWx1ZSAhPT0gdmFsdWVzWyBvZmZzZXRQICsgaiBdIHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFsdWUgIT09IHZhbHVlc1sgb2Zmc2V0TiArIGogXSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRrZWVwID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0a2VlcCA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBpbi1wbGFjZSBjb21wYWN0aW9uXFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBrZWVwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggaSAhPT0gd3JpdGVJbmRleCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aW1lc1sgd3JpdGVJbmRleCBdID0gdGltZXNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgcmVhZE9mZnNldCA9IGkgKiBzdHJpZGUsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0d3JpdGVPZmZzZXQgPSB3cml0ZUluZGV4ICogc3RyaWRlO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBqID0gMDsgaiAhPT0gc3RyaWRlOyArKyBqICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhbHVlc1sgd3JpdGVPZmZzZXQgKyBqIF0gPSB2YWx1ZXNbIHJlYWRPZmZzZXQgKyBqIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQrKyB3cml0ZUluZGV4O1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gZmx1c2ggbGFzdCBrZXlmcmFtZSAoY29tcGFjdGlvbiBsb29rcyBhaGVhZClcXG5cXG5cXHRcXHRcXHRpZiAoIGxhc3RJbmRleCA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGltZXNbIHdyaXRlSW5kZXggXSA9IHRpbWVzWyBsYXN0SW5kZXggXTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgcmVhZE9mZnNldCA9IGxhc3RJbmRleCAqIHN0cmlkZSwgd3JpdGVPZmZzZXQgPSB3cml0ZUluZGV4ICogc3RyaWRlLCBqID0gMDsgaiAhPT0gc3RyaWRlOyArKyBqICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhbHVlc1sgd3JpdGVPZmZzZXQgKyBqIF0gPSB2YWx1ZXNbIHJlYWRPZmZzZXQgKyBqIF07XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdCsrIHdyaXRlSW5kZXg7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggd3JpdGVJbmRleCAhPT0gdGltZXMubGVuZ3RoICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMudGltZXMgPSBBbmltYXRpb25VdGlscy5hcnJheVNsaWNlKCB0aW1lcywgMCwgd3JpdGVJbmRleCApO1xcblxcdFxcdFxcdFxcdHRoaXMudmFsdWVzID0gQW5pbWF0aW9uVXRpbHMuYXJyYXlTbGljZSggdmFsdWVzLCAwLCB3cml0ZUluZGV4ICogc3RyaWRlICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICpcXG5cXHQgKiBBIFRyYWNrIG9mIHZlY3RvcmVkIGtleWZyYW1lIHZhbHVlcy5cXG5cXHQgKlxcblxcdCAqXFxuXFx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cXG5cXHQgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cXG5cXHQgKiBAYXV0aG9yIHRzY2h3XFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gVmVjdG9yS2V5ZnJhbWVUcmFjayggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApIHtcXG5cXG5cXHRcXHRLZXlmcmFtZVRyYWNrLmNhbGwoIHRoaXMsIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKTtcXG5cXG5cXHR9XFxuXFxuXFx0VmVjdG9yS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBLZXlmcmFtZVRyYWNrLnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IFZlY3RvcktleWZyYW1lVHJhY2ssXFxuXFxuXFx0XFx0VmFsdWVUeXBlTmFtZTogJ3ZlY3RvcidcXG5cXG5cXHRcXHQvLyBWYWx1ZUJ1ZmZlclR5cGUgaXMgaW5oZXJpdGVkXFxuXFxuXFx0XFx0Ly8gRGVmYXVsdEludGVycG9sYXRpb24gaXMgaW5oZXJpdGVkXFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqXFxuXFx0ICogUmV1c2FibGUgc2V0IG9mIFRyYWNrcyB0aGF0IHJlcHJlc2VudCBhbiBhbmltYXRpb24uXFxuXFx0ICpcXG5cXHQgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xcblxcdCAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEFuaW1hdGlvbkNsaXAoIG5hbWUsIGR1cmF0aW9uLCB0cmFja3MgKSB7XFxuXFxuXFx0XFx0dGhpcy5uYW1lID0gbmFtZTtcXG5cXHRcXHR0aGlzLnRyYWNrcyA9IHRyYWNrcztcXG5cXHRcXHR0aGlzLmR1cmF0aW9uID0gKCBkdXJhdGlvbiAhPT0gdW5kZWZpbmVkICkgPyBkdXJhdGlvbiA6IC0gMTtcXG5cXG5cXHRcXHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcXG5cXG5cXHRcXHQvLyB0aGlzIG1lYW5zIGl0IHNob3VsZCBmaWd1cmUgb3V0IGl0cyBkdXJhdGlvbiBieSBzY2FubmluZyB0aGUgdHJhY2tzXFxuXFx0XFx0aWYgKCB0aGlzLmR1cmF0aW9uIDwgMCApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnJlc2V0RHVyYXRpb24oKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5vcHRpbWl6ZSgpO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBBbmltYXRpb25DbGlwLCB7XFxuXFxuXFx0XFx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdHJhY2tzID0gW10sXFxuXFx0XFx0XFx0XFx0anNvblRyYWNrcyA9IGpzb24udHJhY2tzLFxcblxcdFxcdFxcdFxcdGZyYW1lVGltZSA9IDEuMCAvICgganNvbi5mcHMgfHwgMS4wICk7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBuID0ganNvblRyYWNrcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dHJhY2tzLnB1c2goIEtleWZyYW1lVHJhY2sucGFyc2UoIGpzb25UcmFja3NbIGkgXSApLnNjYWxlKCBmcmFtZVRpbWUgKSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IEFuaW1hdGlvbkNsaXAoIGpzb24ubmFtZSwganNvbi5kdXJhdGlvbiwgdHJhY2tzICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0b0pTT046IGZ1bmN0aW9uICggY2xpcCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdHJhY2tzID0gW10sXFxuXFx0XFx0XFx0XFx0Y2xpcFRyYWNrcyA9IGNsaXAudHJhY2tzO1xcblxcblxcdFxcdFxcdHZhciBqc29uID0ge1xcblxcblxcdFxcdFxcdFxcdCduYW1lJzogY2xpcC5uYW1lLFxcblxcdFxcdFxcdFxcdCdkdXJhdGlvbic6IGNsaXAuZHVyYXRpb24sXFxuXFx0XFx0XFx0XFx0J3RyYWNrcyc6IHRyYWNrc1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBuID0gY2xpcFRyYWNrcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dHJhY2tzLnB1c2goIEtleWZyYW1lVHJhY2sudG9KU09OKCBjbGlwVHJhY2tzWyBpIF0gKSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4ganNvbjtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdENyZWF0ZUZyb21Nb3JwaFRhcmdldFNlcXVlbmNlOiBmdW5jdGlvbiAoIG5hbWUsIG1vcnBoVGFyZ2V0U2VxdWVuY2UsIGZwcywgbm9Mb29wICkge1xcblxcblxcdFxcdFxcdHZhciBudW1Nb3JwaFRhcmdldHMgPSBtb3JwaFRhcmdldFNlcXVlbmNlLmxlbmd0aDtcXG5cXHRcXHRcXHR2YXIgdHJhY2tzID0gW107XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbnVtTW9ycGhUYXJnZXRzOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB0aW1lcyA9IFtdO1xcblxcdFxcdFxcdFxcdHZhciB2YWx1ZXMgPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHR0aW1lcy5wdXNoKFxcblxcdFxcdFxcdFxcdFxcdCggaSArIG51bU1vcnBoVGFyZ2V0cyAtIDEgKSAlIG51bU1vcnBoVGFyZ2V0cyxcXG5cXHRcXHRcXHRcXHRcXHRpLFxcblxcdFxcdFxcdFxcdFxcdCggaSArIDEgKSAlIG51bU1vcnBoVGFyZ2V0cyApO1xcblxcblxcdFxcdFxcdFxcdHZhbHVlcy5wdXNoKCAwLCAxLCAwICk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG9yZGVyID0gQW5pbWF0aW9uVXRpbHMuZ2V0S2V5ZnJhbWVPcmRlciggdGltZXMgKTtcXG5cXHRcXHRcXHRcXHR0aW1lcyA9IEFuaW1hdGlvblV0aWxzLnNvcnRlZEFycmF5KCB0aW1lcywgMSwgb3JkZXIgKTtcXG5cXHRcXHRcXHRcXHR2YWx1ZXMgPSBBbmltYXRpb25VdGlscy5zb3J0ZWRBcnJheSggdmFsdWVzLCAxLCBvcmRlciApO1xcblxcblxcdFxcdFxcdFxcdC8vIGlmIHRoZXJlIGlzIGEga2V5IGF0IHRoZSBmaXJzdCBmcmFtZSwgZHVwbGljYXRlIGl0IGFzIHRoZVxcblxcdFxcdFxcdFxcdC8vIGxhc3QgZnJhbWUgYXMgd2VsbCBmb3IgcGVyZmVjdCBsb29wLlxcblxcdFxcdFxcdFxcdGlmICggISBub0xvb3AgJiYgdGltZXNbIDAgXSA9PT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aW1lcy5wdXNoKCBudW1Nb3JwaFRhcmdldHMgKTtcXG5cXHRcXHRcXHRcXHRcXHR2YWx1ZXMucHVzaCggdmFsdWVzWyAwIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dHJhY2tzLnB1c2goXFxuXFx0XFx0XFx0XFx0XFx0bmV3IE51bWJlcktleWZyYW1lVHJhY2soXFxuXFx0XFx0XFx0XFx0XFx0XFx0Jy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbJyArIG1vcnBoVGFyZ2V0U2VxdWVuY2VbIGkgXS5uYW1lICsgJ10nLFxcblxcdFxcdFxcdFxcdFxcdFxcdHRpbWVzLCB2YWx1ZXNcXG5cXHRcXHRcXHRcXHRcXHQpLnNjYWxlKCAxLjAgLyBmcHMgKSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IEFuaW1hdGlvbkNsaXAoIG5hbWUsIC0gMSwgdHJhY2tzICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRmaW5kQnlOYW1lOiBmdW5jdGlvbiAoIG9iamVjdE9yQ2xpcEFycmF5LCBuYW1lICkge1xcblxcblxcdFxcdFxcdHZhciBjbGlwQXJyYXkgPSBvYmplY3RPckNsaXBBcnJheTtcXG5cXG5cXHRcXHRcXHRpZiAoICEgQXJyYXkuaXNBcnJheSggb2JqZWN0T3JDbGlwQXJyYXkgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbyA9IG9iamVjdE9yQ2xpcEFycmF5O1xcblxcdFxcdFxcdFxcdGNsaXBBcnJheSA9IG8uZ2VvbWV0cnkgJiYgby5nZW9tZXRyeS5hbmltYXRpb25zIHx8IG8uYW5pbWF0aW9ucztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgY2xpcEFycmF5Lmxlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGNsaXBBcnJheVsgaSBdLm5hbWUgPT09IG5hbWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGNsaXBBcnJheVsgaSBdO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG51bGw7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRDcmVhdGVDbGlwc0Zyb21Nb3JwaFRhcmdldFNlcXVlbmNlczogZnVuY3Rpb24gKCBtb3JwaFRhcmdldHMsIGZwcywgbm9Mb29wICkge1xcblxcblxcdFxcdFxcdHZhciBhbmltYXRpb25Ub01vcnBoVGFyZ2V0cyA9IHt9O1xcblxcblxcdFxcdFxcdC8vIHRlc3RlZCB3aXRoIGh0dHBzOi8vcmVnZXgxMDEuY29tLyBvbiB0cmljayBzZXF1ZW5jZXNcXG5cXHRcXHRcXHQvLyBzdWNoIGZsYW1pbmdvX2ZseUFfMDAzLCBmbGFtaW5nb19ydW4xXzAwMywgY3JkZWF0aDAwNTlcXG5cXHRcXHRcXHR2YXIgcGF0dGVybiA9IC9eKFtcXFxcdy1dKj8pKFtcXFxcZF0rKSQvO1xcblxcblxcdFxcdFxcdC8vIHNvcnQgbW9ycGggdGFyZ2V0IG5hbWVzIGludG8gYW5pbWF0aW9uIGdyb3VwcyBiYXNlZFxcblxcdFxcdFxcdC8vIHBhdHRlcm5zIGxpa2UgV2Fsa18wMDEsIFdhbGtfMDAyLCBSdW5fMDAxLCBSdW5fMDAyXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbW9ycGhUYXJnZXQgPSBtb3JwaFRhcmdldHNbIGkgXTtcXG5cXHRcXHRcXHRcXHR2YXIgcGFydHMgPSBtb3JwaFRhcmdldC5uYW1lLm1hdGNoKCBwYXR0ZXJuICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBwYXJ0cyAmJiBwYXJ0cy5sZW5ndGggPiAxICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBuYW1lID0gcGFydHNbIDEgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgYW5pbWF0aW9uTW9ycGhUYXJnZXRzID0gYW5pbWF0aW9uVG9Nb3JwaFRhcmdldHNbIG5hbWUgXTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoICEgYW5pbWF0aW9uTW9ycGhUYXJnZXRzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzWyBuYW1lIF0gPSBhbmltYXRpb25Nb3JwaFRhcmdldHMgPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0YW5pbWF0aW9uTW9ycGhUYXJnZXRzLnB1c2goIG1vcnBoVGFyZ2V0ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgY2xpcHMgPSBbXTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgbmFtZSBpbiBhbmltYXRpb25Ub01vcnBoVGFyZ2V0cyApIHtcXG5cXG5cXHRcXHRcXHRcXHRjbGlwcy5wdXNoKCBBbmltYXRpb25DbGlwLkNyZWF0ZUZyb21Nb3JwaFRhcmdldFNlcXVlbmNlKCBuYW1lLCBhbmltYXRpb25Ub01vcnBoVGFyZ2V0c1sgbmFtZSBdLCBmcHMsIG5vTG9vcCApICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBjbGlwcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIHBhcnNlIHRoZSBhbmltYXRpb24uaGllcmFyY2h5IGZvcm1hdFxcblxcdFxcdHBhcnNlQW5pbWF0aW9uOiBmdW5jdGlvbiAoIGFuaW1hdGlvbiwgYm9uZXMgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCAhIGFuaW1hdGlvbiApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQW5pbWF0aW9uQ2xpcDogTm8gYW5pbWF0aW9uIGluIEpTT05Mb2FkZXIgZGF0YS4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIG51bGw7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBhZGROb25lbXB0eVRyYWNrID0gZnVuY3Rpb24gKCB0cmFja1R5cGUsIHRyYWNrTmFtZSwgYW5pbWF0aW9uS2V5cywgcHJvcGVydHlOYW1lLCBkZXN0VHJhY2tzICkge1xcblxcblxcdFxcdFxcdFxcdC8vIG9ubHkgcmV0dXJuIHRyYWNrIGlmIHRoZXJlIGFyZSBhY3R1YWxseSBrZXlzLlxcblxcdFxcdFxcdFxcdGlmICggYW5pbWF0aW9uS2V5cy5sZW5ndGggIT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHRpbWVzID0gW107XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHZhbHVlcyA9IFtdO1xcblxcblxcdFxcdFxcdFxcdFxcdEFuaW1hdGlvblV0aWxzLmZsYXR0ZW5KU09OKCBhbmltYXRpb25LZXlzLCB0aW1lcywgdmFsdWVzLCBwcm9wZXJ0eU5hbWUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBlbXB0eSBrZXlzIGFyZSBmaWx0ZXJlZCBvdXQsIHNvIGNoZWNrIGFnYWluXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0aW1lcy5sZW5ndGggIT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGVzdFRyYWNrcy5wdXNoKCBuZXcgdHJhY2tUeXBlKCB0cmFja05hbWUsIHRpbWVzLCB2YWx1ZXMgKSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHR2YXIgdHJhY2tzID0gW107XFxuXFxuXFx0XFx0XFx0dmFyIGNsaXBOYW1lID0gYW5pbWF0aW9uLm5hbWUgfHwgJ2RlZmF1bHQnO1xcblxcdFxcdFxcdC8vIGF1dG9tYXRpYyBsZW5ndGggZGV0ZXJtaW5hdGlvbiBpbiBBbmltYXRpb25DbGlwLlxcblxcdFxcdFxcdHZhciBkdXJhdGlvbiA9IGFuaW1hdGlvbi5sZW5ndGggfHwgLSAxO1xcblxcdFxcdFxcdHZhciBmcHMgPSBhbmltYXRpb24uZnBzIHx8IDMwO1xcblxcblxcdFxcdFxcdHZhciBoaWVyYXJjaHlUcmFja3MgPSBhbmltYXRpb24uaGllcmFyY2h5IHx8IFtdO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBoID0gMDsgaCA8IGhpZXJhcmNoeVRyYWNrcy5sZW5ndGg7IGggKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGFuaW1hdGlvbktleXMgPSBoaWVyYXJjaHlUcmFja3NbIGggXS5rZXlzO1xcblxcblxcdFxcdFxcdFxcdC8vIHNraXAgZW1wdHkgdHJhY2tzXFxuXFx0XFx0XFx0XFx0aWYgKCAhIGFuaW1hdGlvbktleXMgfHwgYW5pbWF0aW9uS2V5cy5sZW5ndGggPT09IDAgKSBjb250aW51ZTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBwcm9jZXNzIG1vcnBoIHRhcmdldHNcXG5cXHRcXHRcXHRcXHRpZiAoIGFuaW1hdGlvbktleXNbIDAgXS5tb3JwaFRhcmdldHMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gZmlndXJlIG91dCBhbGwgbW9ycGggdGFyZ2V0cyB1c2VkIGluIHRoaXMgdHJhY2tcXG5cXHRcXHRcXHRcXHRcXHR2YXIgbW9ycGhUYXJnZXROYW1lcyA9IHt9O1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBrID0gMDsgayA8IGFuaW1hdGlvbktleXMubGVuZ3RoOyBrICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggYW5pbWF0aW9uS2V5c1sgayBdLm1vcnBoVGFyZ2V0cyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgbSA9IDA7IG0gPCBhbmltYXRpb25LZXlzWyBrIF0ubW9ycGhUYXJnZXRzLmxlbmd0aDsgbSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRtb3JwaFRhcmdldE5hbWVzWyBhbmltYXRpb25LZXlzWyBrIF0ubW9ycGhUYXJnZXRzWyBtIF0gXSA9IC0gMTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBjcmVhdGUgYSB0cmFjayBmb3IgZWFjaCBtb3JwaCB0YXJnZXQgd2l0aCBhbGwgemVyb1xcblxcdFxcdFxcdFxcdFxcdC8vIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyBleGNlcHQgZm9yIHRoZSBrZXlzIGluIHdoaWNoXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdGhlIG1vcnBoVGFyZ2V0IGlzIG5hbWVkLlxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBtb3JwaFRhcmdldE5hbWUgaW4gbW9ycGhUYXJnZXROYW1lcyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgdGltZXMgPSBbXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgdmFsdWVzID0gW107XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIG0gPSAwOyBtICE9PSBhbmltYXRpb25LZXlzWyBrIF0ubW9ycGhUYXJnZXRzLmxlbmd0aDsgKysgbSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgYW5pbWF0aW9uS2V5ID0gYW5pbWF0aW9uS2V5c1sgayBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRpbWVzLnB1c2goIGFuaW1hdGlvbktleS50aW1lICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFsdWVzLnB1c2goICggYW5pbWF0aW9uS2V5Lm1vcnBoVGFyZ2V0ID09PSBtb3JwaFRhcmdldE5hbWUgKSA/IDEgOiAwICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRyYWNrcy5wdXNoKCBuZXcgTnVtYmVyS2V5ZnJhbWVUcmFjayggJy5tb3JwaFRhcmdldEluZmx1ZW5jZVsnICsgbW9ycGhUYXJnZXROYW1lICsgJ10nLCB0aW1lcywgdmFsdWVzICkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZHVyYXRpb24gPSBtb3JwaFRhcmdldE5hbWVzLmxlbmd0aCAqICggZnBzIHx8IDEuMCApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gLi4uYXNzdW1lIHNrZWxldGFsIGFuaW1hdGlvblxcblxcblxcdFxcdFxcdFxcdFxcdHZhciBib25lTmFtZSA9ICcuYm9uZXNbJyArIGJvbmVzWyBoIF0ubmFtZSArICddJztcXG5cXG5cXHRcXHRcXHRcXHRcXHRhZGROb25lbXB0eVRyYWNrKFxcblxcdFxcdFxcdFxcdFxcdFxcdFZlY3RvcktleWZyYW1lVHJhY2ssIGJvbmVOYW1lICsgJy5wb3NpdGlvbicsXFxuXFx0XFx0XFx0XFx0XFx0XFx0YW5pbWF0aW9uS2V5cywgJ3BvcycsIHRyYWNrcyApO1xcblxcblxcdFxcdFxcdFxcdFxcdGFkZE5vbmVtcHR5VHJhY2soXFxuXFx0XFx0XFx0XFx0XFx0XFx0UXVhdGVybmlvbktleWZyYW1lVHJhY2ssIGJvbmVOYW1lICsgJy5xdWF0ZXJuaW9uJyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRhbmltYXRpb25LZXlzLCAncm90JywgdHJhY2tzICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YWRkTm9uZW1wdHlUcmFjayhcXG5cXHRcXHRcXHRcXHRcXHRcXHRWZWN0b3JLZXlmcmFtZVRyYWNrLCBib25lTmFtZSArICcuc2NhbGUnLFxcblxcdFxcdFxcdFxcdFxcdFxcdGFuaW1hdGlvbktleXMsICdzY2wnLCB0cmFja3MgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggdHJhY2tzLmxlbmd0aCA9PT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gbnVsbDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIGNsaXAgPSBuZXcgQW5pbWF0aW9uQ2xpcCggY2xpcE5hbWUsIGR1cmF0aW9uLCB0cmFja3MgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gY2xpcDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdE9iamVjdC5hc3NpZ24oIEFuaW1hdGlvbkNsaXAucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0cmVzZXREdXJhdGlvbjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB0cmFja3MgPSB0aGlzLnRyYWNrcywgZHVyYXRpb24gPSAwO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbiA9IHRyYWNrcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHRyYWNrID0gdGhpcy50cmFja3NbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRkdXJhdGlvbiA9IE1hdGgubWF4KCBkdXJhdGlvbiwgdHJhY2sudGltZXNbIHRyYWNrLnRpbWVzLmxlbmd0aCAtIDEgXSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0cmltOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy50cmFja3MubGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMudHJhY2tzWyBpIF0udHJpbSggMCwgdGhpcy5kdXJhdGlvbiApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG9wdGltaXplOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy50cmFja3MubGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMudHJhY2tzWyBpIF0ub3B0aW1pemUoKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIE1hdGVyaWFsTG9hZGVyKCBtYW5hZ2VyICkge1xcblxcblxcdFxcdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xcblxcdFxcdHRoaXMudGV4dHVyZXMgPSB7fTtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggTWF0ZXJpYWxMb2FkZXIucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcXG5cXG5cXHRcXHRcXHR2YXIgc2NvcGUgPSB0aGlzO1xcblxcblxcdFxcdFxcdHZhciBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggc2NvcGUubWFuYWdlciApO1xcblxcdFxcdFxcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcXG5cXG5cXHRcXHRcXHRcXHRvbkxvYWQoIHNjb3BlLnBhcnNlKCBKU09OLnBhcnNlKCB0ZXh0ICkgKSApO1xcblxcblxcdFxcdFxcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFRleHR1cmVzOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdHRoaXMudGV4dHVyZXMgPSB2YWx1ZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHBhcnNlOiBmdW5jdGlvbiAoIGpzb24gKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHRleHR1cmVzID0gdGhpcy50ZXh0dXJlcztcXG5cXG5cXHRcXHRcXHRmdW5jdGlvbiBnZXRUZXh0dXJlKCBuYW1lICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggdGV4dHVyZXNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGVyaWFsTG9hZGVyOiBVbmRlZmluZWQgdGV4dHVyZScsIG5hbWUgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRleHR1cmVzWyBuYW1lIF07XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBtYXRlcmlhbCA9IG5ldyBNYXRlcmlhbHNbIGpzb24udHlwZSBdKCk7XFxuXFxuXFx0XFx0XFx0aWYgKCBqc29uLnV1aWQgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnV1aWQgPSBqc29uLnV1aWQ7XFxuXFx0XFx0XFx0aWYgKCBqc29uLm5hbWUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm5hbWUgPSBqc29uLm5hbWU7XFxuXFx0XFx0XFx0aWYgKCBqc29uLmNvbG9yICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5jb2xvci5zZXRIZXgoIGpzb24uY29sb3IgKTtcXG5cXHRcXHRcXHRpZiAoIGpzb24ucm91Z2huZXNzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5yb3VnaG5lc3MgPSBqc29uLnJvdWdobmVzcztcXG5cXHRcXHRcXHRpZiAoIGpzb24ubWV0YWxuZXNzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5tZXRhbG5lc3MgPSBqc29uLm1ldGFsbmVzcztcXG5cXHRcXHRcXHRpZiAoIGpzb24uZW1pc3NpdmUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmVtaXNzaXZlLnNldEhleCgganNvbi5lbWlzc2l2ZSApO1xcblxcdFxcdFxcdGlmICgganNvbi5zcGVjdWxhciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3BlY3VsYXIuc2V0SGV4KCBqc29uLnNwZWN1bGFyICk7XFxuXFx0XFx0XFx0aWYgKCBqc29uLnNoaW5pbmVzcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2hpbmluZXNzID0ganNvbi5zaGluaW5lc3M7XFxuXFx0XFx0XFx0aWYgKCBqc29uLmNsZWFyQ29hdCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY2xlYXJDb2F0ID0ganNvbi5jbGVhckNvYXQ7XFxuXFx0XFx0XFx0aWYgKCBqc29uLmNsZWFyQ29hdFJvdWdobmVzcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY2xlYXJDb2F0Um91Z2huZXNzID0ganNvbi5jbGVhckNvYXRSb3VnaG5lc3M7XFxuXFx0XFx0XFx0aWYgKCBqc29uLnVuaWZvcm1zICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC51bmlmb3JtcyA9IGpzb24udW5pZm9ybXM7XFxuXFx0XFx0XFx0aWYgKCBqc29uLnZlcnRleFNoYWRlciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudmVydGV4U2hhZGVyID0ganNvbi52ZXJ0ZXhTaGFkZXI7XFxuXFx0XFx0XFx0aWYgKCBqc29uLmZyYWdtZW50U2hhZGVyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5mcmFnbWVudFNoYWRlciA9IGpzb24uZnJhZ21lbnRTaGFkZXI7XFxuXFx0XFx0XFx0aWYgKCBqc29uLnZlcnRleENvbG9ycyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudmVydGV4Q29sb3JzID0ganNvbi52ZXJ0ZXhDb2xvcnM7XFxuXFx0XFx0XFx0aWYgKCBqc29uLmZvZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZm9nID0ganNvbi5mb2c7XFxuXFx0XFx0XFx0aWYgKCBqc29uLmZsYXRTaGFkaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5mbGF0U2hhZGluZyA9IGpzb24uZmxhdFNoYWRpbmc7XFxuXFx0XFx0XFx0aWYgKCBqc29uLmJsZW5kaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ibGVuZGluZyA9IGpzb24uYmxlbmRpbmc7XFxuXFx0XFx0XFx0aWYgKCBqc29uLnNpZGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNpZGUgPSBqc29uLnNpZGU7XFxuXFx0XFx0XFx0aWYgKCBqc29uLm9wYWNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm9wYWNpdHkgPSBqc29uLm9wYWNpdHk7XFxuXFx0XFx0XFx0aWYgKCBqc29uLnRyYW5zcGFyZW50ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC50cmFuc3BhcmVudCA9IGpzb24udHJhbnNwYXJlbnQ7XFxuXFx0XFx0XFx0aWYgKCBqc29uLmFscGhhVGVzdCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYWxwaGFUZXN0ID0ganNvbi5hbHBoYVRlc3Q7XFxuXFx0XFx0XFx0aWYgKCBqc29uLmRlcHRoVGVzdCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGVwdGhUZXN0ID0ganNvbi5kZXB0aFRlc3Q7XFxuXFx0XFx0XFx0aWYgKCBqc29uLmRlcHRoV3JpdGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRlcHRoV3JpdGUgPSBqc29uLmRlcHRoV3JpdGU7XFxuXFx0XFx0XFx0aWYgKCBqc29uLmNvbG9yV3JpdGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmNvbG9yV3JpdGUgPSBqc29uLmNvbG9yV3JpdGU7XFxuXFx0XFx0XFx0aWYgKCBqc29uLndpcmVmcmFtZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwud2lyZWZyYW1lID0ganNvbi53aXJlZnJhbWU7XFxuXFx0XFx0XFx0aWYgKCBqc29uLndpcmVmcmFtZUxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoID0ganNvbi53aXJlZnJhbWVMaW5ld2lkdGg7XFxuXFx0XFx0XFx0aWYgKCBqc29uLndpcmVmcmFtZUxpbmVjYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLndpcmVmcmFtZUxpbmVjYXAgPSBqc29uLndpcmVmcmFtZUxpbmVjYXA7XFxuXFx0XFx0XFx0aWYgKCBqc29uLndpcmVmcmFtZUxpbmVqb2luICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC53aXJlZnJhbWVMaW5lam9pbiA9IGpzb24ud2lyZWZyYW1lTGluZWpvaW47XFxuXFxuXFx0XFx0XFx0aWYgKCBqc29uLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5yb3RhdGlvbiA9IGpzb24ucm90YXRpb247XFxuXFxuXFx0XFx0XFx0aWYgKCBqc29uLmxpbmV3aWR0aCAhPT0gMSApIG1hdGVyaWFsLmxpbmV3aWR0aCA9IGpzb24ubGluZXdpZHRoO1xcblxcdFxcdFxcdGlmICgganNvbi5kYXNoU2l6ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGFzaFNpemUgPSBqc29uLmRhc2hTaXplO1xcblxcdFxcdFxcdGlmICgganNvbi5nYXBTaXplICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5nYXBTaXplID0ganNvbi5nYXBTaXplO1xcblxcdFxcdFxcdGlmICgganNvbi5zY2FsZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2NhbGUgPSBqc29uLnNjYWxlO1xcblxcblxcdFxcdFxcdGlmICgganNvbi5za2lubmluZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2tpbm5pbmcgPSBqc29uLnNraW5uaW5nO1xcblxcdFxcdFxcdGlmICgganNvbi5tb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9IGpzb24ubW9ycGhUYXJnZXRzO1xcblxcdFxcdFxcdGlmICgganNvbi5kaXRoZXJpbmcgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpdGhlcmluZyA9IGpzb24uZGl0aGVyaW5nO1xcblxcblxcdFxcdFxcdGlmICgganNvbi52aXNpYmxlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC52aXNpYmxlID0ganNvbi52aXNpYmxlO1xcblxcdFxcdFxcdGlmICgganNvbi51c2VyRGF0YSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudXNlckRhdGEgPSBqc29uLnVzZXJEYXRhO1xcblxcblxcdFxcdFxcdC8vIERlcHJlY2F0ZWRcXG5cXG5cXHRcXHRcXHRpZiAoIGpzb24uc2hhZGluZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZmxhdFNoYWRpbmcgPSBqc29uLnNoYWRpbmcgPT09IDE7IC8vIFRIUkVFLkZsYXRTaGFkaW5nXFxuXFxuXFx0XFx0XFx0Ly8gZm9yIFBvaW50c01hdGVyaWFsXFxuXFxuXFx0XFx0XFx0aWYgKCBqc29uLnNpemUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNpemUgPSBqc29uLnNpemU7XFxuXFx0XFx0XFx0aWYgKCBqc29uLnNpemVBdHRlbnVhdGlvbiAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uID0ganNvbi5zaXplQXR0ZW51YXRpb247XFxuXFxuXFx0XFx0XFx0Ly8gbWFwc1xcblxcblxcdFxcdFxcdGlmICgganNvbi5tYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm1hcCA9IGdldFRleHR1cmUoIGpzb24ubWFwICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBqc29uLmFscGhhTWFwICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0bWF0ZXJpYWwuYWxwaGFNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmFscGhhTWFwICk7XFxuXFx0XFx0XFx0XFx0bWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGpzb24uYnVtcE1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYnVtcE1hcCA9IGdldFRleHR1cmUoIGpzb24uYnVtcE1hcCApO1xcblxcdFxcdFxcdGlmICgganNvbi5idW1wU2NhbGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJ1bXBTY2FsZSA9IGpzb24uYnVtcFNjYWxlO1xcblxcblxcdFxcdFxcdGlmICgganNvbi5ub3JtYWxNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm5vcm1hbE1hcCA9IGdldFRleHR1cmUoIGpzb24ubm9ybWFsTWFwICk7XFxuXFx0XFx0XFx0aWYgKCBqc29uLm5vcm1hbFNjYWxlICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG5vcm1hbFNjYWxlID0ganNvbi5ub3JtYWxTY2FsZTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIEFycmF5LmlzQXJyYXkoIG5vcm1hbFNjYWxlICkgPT09IGZhbHNlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIEJsZW5kZXIgZXhwb3J0ZXIgdXNlZCB0byBleHBvcnQgYSBzY2FsYXIuIFNlZSAjNzQ1OVxcblxcblxcdFxcdFxcdFxcdFxcdG5vcm1hbFNjYWxlID0gWyBub3JtYWxTY2FsZSwgbm9ybWFsU2NhbGUgXTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0bWF0ZXJpYWwubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMigpLmZyb21BcnJheSggbm9ybWFsU2NhbGUgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBqc29uLmRpc3BsYWNlbWVudE1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwID0gZ2V0VGV4dHVyZSgganNvbi5kaXNwbGFjZW1lbnRNYXAgKTtcXG5cXHRcXHRcXHRpZiAoIGpzb24uZGlzcGxhY2VtZW50U2NhbGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRpc3BsYWNlbWVudFNjYWxlID0ganNvbi5kaXNwbGFjZW1lbnRTY2FsZTtcXG5cXHRcXHRcXHRpZiAoIGpzb24uZGlzcGxhY2VtZW50QmlhcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGlzcGxhY2VtZW50QmlhcyA9IGpzb24uZGlzcGxhY2VtZW50QmlhcztcXG5cXG5cXHRcXHRcXHRpZiAoIGpzb24ucm91Z2huZXNzTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5yb3VnaG5lc3NNYXAgPSBnZXRUZXh0dXJlKCBqc29uLnJvdWdobmVzc01hcCApO1xcblxcdFxcdFxcdGlmICgganNvbi5tZXRhbG5lc3NNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm1ldGFsbmVzc01hcCA9IGdldFRleHR1cmUoIGpzb24ubWV0YWxuZXNzTWFwICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBqc29uLmVtaXNzaXZlTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5lbWlzc2l2ZU1hcCA9IGdldFRleHR1cmUoIGpzb24uZW1pc3NpdmVNYXAgKTtcXG5cXHRcXHRcXHRpZiAoIGpzb24uZW1pc3NpdmVJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmVtaXNzaXZlSW50ZW5zaXR5ID0ganNvbi5lbWlzc2l2ZUludGVuc2l0eTtcXG5cXG5cXHRcXHRcXHRpZiAoIGpzb24uc3BlY3VsYXJNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNwZWN1bGFyTWFwID0gZ2V0VGV4dHVyZSgganNvbi5zcGVjdWxhck1hcCApO1xcblxcblxcdFxcdFxcdGlmICgganNvbi5lbnZNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmVudk1hcCA9IGdldFRleHR1cmUoIGpzb24uZW52TWFwICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBqc29uLnJlZmxlY3Rpdml0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwucmVmbGVjdGl2aXR5ID0ganNvbi5yZWZsZWN0aXZpdHk7XFxuXFxuXFx0XFx0XFx0aWYgKCBqc29uLmxpZ2h0TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5saWdodE1hcCA9IGdldFRleHR1cmUoIGpzb24ubGlnaHRNYXAgKTtcXG5cXHRcXHRcXHRpZiAoIGpzb24ubGlnaHRNYXBJbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmxpZ2h0TWFwSW50ZW5zaXR5ID0ganNvbi5saWdodE1hcEludGVuc2l0eTtcXG5cXG5cXHRcXHRcXHRpZiAoIGpzb24uYW9NYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmFvTWFwID0gZ2V0VGV4dHVyZSgganNvbi5hb01hcCApO1xcblxcdFxcdFxcdGlmICgganNvbi5hb01hcEludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYW9NYXBJbnRlbnNpdHkgPSBqc29uLmFvTWFwSW50ZW5zaXR5O1xcblxcblxcdFxcdFxcdGlmICgganNvbi5ncmFkaWVudE1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZ3JhZGllbnRNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmdyYWRpZW50TWFwICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG1hdGVyaWFsO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBCdWZmZXJHZW9tZXRyeUxvYWRlciggbWFuYWdlciApIHtcXG5cXG5cXHRcXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggQnVmZmVyR2VvbWV0cnlMb2FkZXIucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcXG5cXG5cXHRcXHRcXHR2YXIgc2NvcGUgPSB0aGlzO1xcblxcblxcdFxcdFxcdHZhciBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggc2NvcGUubWFuYWdlciApO1xcblxcdFxcdFxcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcXG5cXG5cXHRcXHRcXHRcXHRvbkxvYWQoIHNjb3BlLnBhcnNlKCBKU09OLnBhcnNlKCB0ZXh0ICkgKSApO1xcblxcblxcdFxcdFxcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHBhcnNlOiBmdW5jdGlvbiAoIGpzb24gKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XFxuXFxuXFx0XFx0XFx0dmFyIGluZGV4ID0ganNvbi5kYXRhLmluZGV4O1xcblxcblxcdFxcdFxcdGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdHlwZWRBcnJheSA9IG5ldyBUWVBFRF9BUlJBWVNbIGluZGV4LnR5cGUgXSggaW5kZXguYXJyYXkgKTtcXG5cXHRcXHRcXHRcXHRnZW9tZXRyeS5zZXRJbmRleCggbmV3IEJ1ZmZlckF0dHJpYnV0ZSggdHlwZWRBcnJheSwgMSApICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBhdHRyaWJ1dGVzID0ganNvbi5kYXRhLmF0dHJpYnV0ZXM7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcXG5cXHRcXHRcXHRcXHR2YXIgdHlwZWRBcnJheSA9IG5ldyBUWVBFRF9BUlJBWVNbIGF0dHJpYnV0ZS50eXBlIF0oIGF0dHJpYnV0ZS5hcnJheSApO1xcblxcblxcdFxcdFxcdFxcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgga2V5LCBuZXcgQnVmZmVyQXR0cmlidXRlKCB0eXBlZEFycmF5LCBhdHRyaWJ1dGUuaXRlbVNpemUsIGF0dHJpYnV0ZS5ub3JtYWxpemVkICkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIGdyb3VwcyA9IGpzb24uZGF0YS5ncm91cHMgfHwganNvbi5kYXRhLmRyYXdjYWxscyB8fCBqc29uLmRhdGEub2Zmc2V0cztcXG5cXG5cXHRcXHRcXHRpZiAoIGdyb3VwcyAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbiA9IGdyb3Vwcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkuYWRkR3JvdXAoIGdyb3VwLnN0YXJ0LCBncm91cC5jb3VudCwgZ3JvdXAubWF0ZXJpYWxJbmRleCApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIGJvdW5kaW5nU3BoZXJlID0ganNvbi5kYXRhLmJvdW5kaW5nU3BoZXJlO1xcblxcblxcdFxcdFxcdGlmICggYm91bmRpbmdTcGhlcmUgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgY2VudGVyID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGJvdW5kaW5nU3BoZXJlLmNlbnRlciAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNlbnRlci5mcm9tQXJyYXkoIGJvdW5kaW5nU3BoZXJlLmNlbnRlciApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9IG5ldyBTcGhlcmUoIGNlbnRlciwgYm91bmRpbmdTcGhlcmUucmFkaXVzICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBnZW9tZXRyeTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdHZhciBUWVBFRF9BUlJBWVMgPSB7XFxuXFx0XFx0SW50OEFycmF5OiBJbnQ4QXJyYXksXFxuXFx0XFx0VWludDhBcnJheTogVWludDhBcnJheSxcXG5cXHRcXHQvLyBXb3JrYXJvdW5kIGZvciBJRTExIHByZSBLQjI5Mjk0MzcuIFNlZSAjMTE0NDBcXG5cXHRcXHRVaW50OENsYW1wZWRBcnJheTogdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4Q2xhbXBlZEFycmF5IDogVWludDhBcnJheSxcXG5cXHRcXHRJbnQxNkFycmF5OiBJbnQxNkFycmF5LFxcblxcdFxcdFVpbnQxNkFycmF5OiBVaW50MTZBcnJheSxcXG5cXHRcXHRJbnQzMkFycmF5OiBJbnQzMkFycmF5LFxcblxcdFxcdFVpbnQzMkFycmF5OiBVaW50MzJBcnJheSxcXG5cXHRcXHRGbG9hdDMyQXJyYXk6IEZsb2F0MzJBcnJheSxcXG5cXHRcXHRGbG9hdDY0QXJyYXk6IEZsb2F0NjRBcnJheVxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBMb2FkZXIoKSB7XFxuXFxuXFx0XFx0dGhpcy5vbkxvYWRTdGFydCA9IGZ1bmN0aW9uICgpIHt9O1xcblxcdFxcdHRoaXMub25Mb2FkUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7fTtcXG5cXHRcXHR0aGlzLm9uTG9hZENvbXBsZXRlID0gZnVuY3Rpb24gKCkge307XFxuXFxuXFx0fVxcblxcblxcdExvYWRlci5IYW5kbGVycyA9IHtcXG5cXG5cXHRcXHRoYW5kbGVyczogW10sXFxuXFxuXFx0XFx0YWRkOiBmdW5jdGlvbiAoIHJlZ2V4LCBsb2FkZXIgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5oYW5kbGVycy5wdXNoKCByZWdleCwgbG9hZGVyICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXQ6IGZ1bmN0aW9uICggZmlsZSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMiApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcmVnZXggPSBoYW5kbGVyc1sgaSBdO1xcblxcdFxcdFxcdFxcdHZhciBsb2FkZXIgPSBoYW5kbGVyc1sgaSArIDEgXTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHJlZ2V4LnRlc3QoIGZpbGUgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gbG9hZGVyO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG51bGw7XFxuXFxuXFx0XFx0fVxcblxcblxcdH07XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggTG9hZGVyLnByb3RvdHlwZSwge1xcblxcblxcdFxcdGNyb3NzT3JpZ2luOiB1bmRlZmluZWQsXFxuXFxuXFx0XFx0aW5pdE1hdGVyaWFsczogZnVuY3Rpb24gKCBtYXRlcmlhbHMsIHRleHR1cmVQYXRoLCBjcm9zc09yaWdpbiApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYXJyYXkgPSBbXTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBtYXRlcmlhbHMubGVuZ3RoOyArKyBpICkge1xcblxcblxcdFxcdFxcdFxcdGFycmF5WyBpIF0gPSB0aGlzLmNyZWF0ZU1hdGVyaWFsKCBtYXRlcmlhbHNbIGkgXSwgdGV4dHVyZVBhdGgsIGNyb3NzT3JpZ2luICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBhcnJheTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNyZWF0ZU1hdGVyaWFsOiAoIGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgQmxlbmRpbmdNb2RlID0ge1xcblxcdFxcdFxcdFxcdE5vQmxlbmRpbmc6IE5vQmxlbmRpbmcsXFxuXFx0XFx0XFx0XFx0Tm9ybWFsQmxlbmRpbmc6IE5vcm1hbEJsZW5kaW5nLFxcblxcdFxcdFxcdFxcdEFkZGl0aXZlQmxlbmRpbmc6IEFkZGl0aXZlQmxlbmRpbmcsXFxuXFx0XFx0XFx0XFx0U3VidHJhY3RpdmVCbGVuZGluZzogU3VidHJhY3RpdmVCbGVuZGluZyxcXG5cXHRcXHRcXHRcXHRNdWx0aXBseUJsZW5kaW5nOiBNdWx0aXBseUJsZW5kaW5nLFxcblxcdFxcdFxcdFxcdEN1c3RvbUJsZW5kaW5nOiBDdXN0b21CbGVuZGluZ1xcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0dmFyIGNvbG9yID0gbmV3IENvbG9yKCk7XFxuXFx0XFx0XFx0dmFyIHRleHR1cmVMb2FkZXIgPSBuZXcgVGV4dHVyZUxvYWRlcigpO1xcblxcdFxcdFxcdHZhciBtYXRlcmlhbExvYWRlciA9IG5ldyBNYXRlcmlhbExvYWRlcigpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBjcmVhdGVNYXRlcmlhbCggbSwgdGV4dHVyZVBhdGgsIGNyb3NzT3JpZ2luICkge1xcblxcblxcdFxcdFxcdFxcdC8vIGNvbnZlcnQgZnJvbSBvbGQgbWF0ZXJpYWwgZm9ybWF0XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHRleHR1cmVzID0ge307XFxuXFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24gbG9hZFRleHR1cmUoIHBhdGgsIHJlcGVhdCwgb2Zmc2V0LCB3cmFwLCBhbmlzb3Ryb3B5ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBmdWxsUGF0aCA9IHRleHR1cmVQYXRoICsgcGF0aDtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgbG9hZGVyID0gTG9hZGVyLkhhbmRsZXJzLmdldCggZnVsbFBhdGggKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgdGV4dHVyZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGxvYWRlciAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0ZXh0dXJlID0gbG9hZGVyLmxvYWQoIGZ1bGxQYXRoICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0ZXh0dXJlTG9hZGVyLnNldENyb3NzT3JpZ2luKCBjcm9zc09yaWdpbiApO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRleHR1cmUgPSB0ZXh0dXJlTG9hZGVyLmxvYWQoIGZ1bGxQYXRoICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGlmICggcmVwZWF0ICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGV4dHVyZS5yZXBlYXQuZnJvbUFycmF5KCByZXBlYXQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHJlcGVhdFsgMCBdICE9PSAxICkgdGV4dHVyZS53cmFwUyA9IFJlcGVhdFdyYXBwaW5nO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggcmVwZWF0WyAxIF0gIT09IDEgKSB0ZXh0dXJlLndyYXBUID0gUmVwZWF0V3JhcHBpbmc7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGlmICggb2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGV4dHVyZS5vZmZzZXQuZnJvbUFycmF5KCBvZmZzZXQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB3cmFwICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB3cmFwWyAwIF0gPT09ICdyZXBlYXQnICkgdGV4dHVyZS53cmFwUyA9IFJlcGVhdFdyYXBwaW5nO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggd3JhcFsgMCBdID09PSAnbWlycm9yJyApIHRleHR1cmUud3JhcFMgPSBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggd3JhcFsgMSBdID09PSAncmVwZWF0JyApIHRleHR1cmUud3JhcFQgPSBSZXBlYXRXcmFwcGluZztcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHdyYXBbIDEgXSA9PT0gJ21pcnJvcicgKSB0ZXh0dXJlLndyYXBUID0gTWlycm9yZWRSZXBlYXRXcmFwcGluZztcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBhbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGV4dHVyZS5hbmlzb3Ryb3B5ID0gYW5pc290cm9weTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlc1sgdXVpZCBdID0gdGV4dHVyZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdXVpZDtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly9cXG5cXG5cXHRcXHRcXHRcXHR2YXIganNvbiA9IHtcXG5cXHRcXHRcXHRcXHRcXHR1dWlkOiBfTWF0aC5nZW5lcmF0ZVVVSUQoKSxcXG5cXHRcXHRcXHRcXHRcXHR0eXBlOiAnTWVzaExhbWJlcnRNYXRlcmlhbCdcXG5cXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBuYW1lIGluIG0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHZhbHVlID0gbVsgbmFtZSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdHN3aXRjaCAoIG5hbWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnRGJnQ29sb3InOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ0RiZ0luZGV4JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdvcHRpY2FsRGVuc2l0eSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnaWxsdW1pbmF0aW9uJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdEYmdOYW1lJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqc29uLm5hbWUgPSB2YWx1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdibGVuZGluZyc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0anNvbi5ibGVuZGluZyA9IEJsZW5kaW5nTW9kZVsgdmFsdWUgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdjb2xvckFtYmllbnQnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcEFtYmllbnQnOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxvYWRlci5jcmVhdGVNYXRlcmlhbDonLCBuYW1lLCAnaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4nICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnY29sb3JEaWZmdXNlJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqc29uLmNvbG9yID0gY29sb3IuZnJvbUFycmF5KCB2YWx1ZSApLmdldEhleCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ2NvbG9yU3BlY3VsYXInOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGpzb24uc3BlY3VsYXIgPSBjb2xvci5mcm9tQXJyYXkoIHZhbHVlICkuZ2V0SGV4KCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnY29sb3JFbWlzc2l2ZSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0anNvbi5lbWlzc2l2ZSA9IGNvbG9yLmZyb21BcnJheSggdmFsdWUgKS5nZXRIZXgoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdzcGVjdWxhckNvZWYnOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGpzb24uc2hpbmluZXNzID0gdmFsdWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnc2hhZGluZyc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAnYmFzaWMnICkganNvbi50eXBlID0gJ01lc2hCYXNpY01hdGVyaWFsJztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICdwaG9uZycgKSBqc29uLnR5cGUgPSAnTWVzaFBob25nTWF0ZXJpYWwnO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N0YW5kYXJkJyApIGpzb24udHlwZSA9ICdNZXNoU3RhbmRhcmRNYXRlcmlhbCc7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwRGlmZnVzZSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0anNvbi5tYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwRGlmZnVzZVJlcGVhdCwgbS5tYXBEaWZmdXNlT2Zmc2V0LCBtLm1hcERpZmZ1c2VXcmFwLCBtLm1hcERpZmZ1c2VBbmlzb3Ryb3B5ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwRGlmZnVzZVJlcGVhdCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwRGlmZnVzZU9mZnNldCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwRGlmZnVzZVdyYXAnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcERpZmZ1c2VBbmlzb3Ryb3B5JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBFbWlzc2l2ZSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0anNvbi5lbWlzc2l2ZU1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBFbWlzc2l2ZVJlcGVhdCwgbS5tYXBFbWlzc2l2ZU9mZnNldCwgbS5tYXBFbWlzc2l2ZVdyYXAsIG0ubWFwRW1pc3NpdmVBbmlzb3Ryb3B5ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwRW1pc3NpdmVSZXBlYXQnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcEVtaXNzaXZlT2Zmc2V0JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBFbWlzc2l2ZVdyYXAnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcEVtaXNzaXZlQW5pc290cm9weSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwTGlnaHQnOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGpzb24ubGlnaHRNYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwTGlnaHRSZXBlYXQsIG0ubWFwTGlnaHRPZmZzZXQsIG0ubWFwTGlnaHRXcmFwLCBtLm1hcExpZ2h0QW5pc290cm9weSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcExpZ2h0UmVwZWF0JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBMaWdodE9mZnNldCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwTGlnaHRXcmFwJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBMaWdodEFuaXNvdHJvcHknOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcEFPJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqc29uLmFvTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcEFPUmVwZWF0LCBtLm1hcEFPT2Zmc2V0LCBtLm1hcEFPV3JhcCwgbS5tYXBBT0FuaXNvdHJvcHkgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBBT1JlcGVhdCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwQU9PZmZzZXQnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcEFPV3JhcCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwQU9Bbmlzb3Ryb3B5JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBCdW1wJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqc29uLmJ1bXBNYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwQnVtcFJlcGVhdCwgbS5tYXBCdW1wT2Zmc2V0LCBtLm1hcEJ1bXBXcmFwLCBtLm1hcEJ1bXBBbmlzb3Ryb3B5ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwQnVtcFNjYWxlJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqc29uLmJ1bXBTY2FsZSA9IHZhbHVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcEJ1bXBSZXBlYXQnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcEJ1bXBPZmZzZXQnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcEJ1bXBXcmFwJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBCdW1wQW5pc290cm9weSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwTm9ybWFsJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqc29uLm5vcm1hbE1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBOb3JtYWxSZXBlYXQsIG0ubWFwTm9ybWFsT2Zmc2V0LCBtLm1hcE5vcm1hbFdyYXAsIG0ubWFwTm9ybWFsQW5pc290cm9weSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcE5vcm1hbEZhY3Rvcic6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0anNvbi5ub3JtYWxTY2FsZSA9IFsgdmFsdWUsIHZhbHVlIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwTm9ybWFsUmVwZWF0JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBOb3JtYWxPZmZzZXQnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcE5vcm1hbFdyYXAnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcE5vcm1hbEFuaXNvdHJvcHknOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcFNwZWN1bGFyJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqc29uLnNwZWN1bGFyTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcFNwZWN1bGFyUmVwZWF0LCBtLm1hcFNwZWN1bGFyT2Zmc2V0LCBtLm1hcFNwZWN1bGFyV3JhcCwgbS5tYXBTcGVjdWxhckFuaXNvdHJvcHkgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBTcGVjdWxhclJlcGVhdCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwU3BlY3VsYXJPZmZzZXQnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcFNwZWN1bGFyV3JhcCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwU3BlY3VsYXJBbmlzb3Ryb3B5JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBNZXRhbG5lc3MnOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGpzb24ubWV0YWxuZXNzTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcE1ldGFsbmVzc1JlcGVhdCwgbS5tYXBNZXRhbG5lc3NPZmZzZXQsIG0ubWFwTWV0YWxuZXNzV3JhcCwgbS5tYXBNZXRhbG5lc3NBbmlzb3Ryb3B5ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwTWV0YWxuZXNzUmVwZWF0JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBNZXRhbG5lc3NPZmZzZXQnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcE1ldGFsbmVzc1dyYXAnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcE1ldGFsbmVzc0FuaXNvdHJvcHknOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcFJvdWdobmVzcyc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0anNvbi5yb3VnaG5lc3NNYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwUm91Z2huZXNzUmVwZWF0LCBtLm1hcFJvdWdobmVzc09mZnNldCwgbS5tYXBSb3VnaG5lc3NXcmFwLCBtLm1hcFJvdWdobmVzc0FuaXNvdHJvcHkgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBSb3VnaG5lc3NSZXBlYXQnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcFJvdWdobmVzc09mZnNldCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwUm91Z2huZXNzV3JhcCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwUm91Z2huZXNzQW5pc290cm9weSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwQWxwaGEnOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGpzb24uYWxwaGFNYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwQWxwaGFSZXBlYXQsIG0ubWFwQWxwaGFPZmZzZXQsIG0ubWFwQWxwaGFXcmFwLCBtLm1hcEFscGhhQW5pc290cm9weSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcEFscGhhUmVwZWF0JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBBbHBoYU9mZnNldCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwQWxwaGFXcmFwJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBBbHBoYUFuaXNvdHJvcHknOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ2ZsaXBTaWRlZCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0anNvbi5zaWRlID0gQmFja1NpZGU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnZG91YmxlU2lkZWQnOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGpzb24uc2lkZSA9IERvdWJsZVNpZGU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAndHJhbnNwYXJlbmN5JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5Mb2FkZXIuY3JlYXRlTWF0ZXJpYWw6IHRyYW5zcGFyZW5jeSBoYXMgYmVlbiByZW5hbWVkIHRvIG9wYWNpdHknICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0anNvbi5vcGFjaXR5ID0gdmFsdWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnZGVwdGhUZXN0JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdkZXB0aFdyaXRlJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdjb2xvcldyaXRlJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdvcGFjaXR5JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdyZWZsZWN0aXZpdHknOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ3RyYW5zcGFyZW50JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICd2aXNpYmxlJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICd3aXJlZnJhbWUnOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGpzb25bIG5hbWUgXSA9IHZhbHVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ3ZlcnRleENvbG9ycyc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIGpzb24udmVydGV4Q29sb3JzID0gVmVydGV4Q29sb3JzO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggdmFsdWUgPT09ICdmYWNlJyApIGpzb24udmVydGV4Q29sb3JzID0gRmFjZUNvbG9ycztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRkZWZhdWx0OlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Mb2FkZXIuY3JlYXRlTWF0ZXJpYWw6IFVuc3VwcG9ydGVkJywgbmFtZSwgdmFsdWUgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICgganNvbi50eXBlID09PSAnTWVzaEJhc2ljTWF0ZXJpYWwnICkgZGVsZXRlIGpzb24uZW1pc3NpdmU7XFxuXFx0XFx0XFx0XFx0aWYgKCBqc29uLnR5cGUgIT09ICdNZXNoUGhvbmdNYXRlcmlhbCcgKSBkZWxldGUganNvbi5zcGVjdWxhcjtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGpzb24ub3BhY2l0eSA8IDEgKSBqc29uLnRyYW5zcGFyZW50ID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHRtYXRlcmlhbExvYWRlci5zZXRUZXh0dXJlcyggdGV4dHVyZXMgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gbWF0ZXJpYWxMb2FkZXIucGFyc2UoIGpzb24gKTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0gKSgpXFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgRG9uIE1jQ3VyZHkgLyBodHRwczovL3d3dy5kb25tY2N1cmR5LmNvbVxcblxcdCAqL1xcblxcblxcdHZhciBMb2FkZXJVdGlscyA9IHtcXG5cXG5cXHRcXHRkZWNvZGVUZXh0OiBmdW5jdGlvbiAoIGFycmF5ICkge1xcblxcblxcdFxcdFxcdGlmICggdHlwZW9mIFRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJyApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKCBhcnJheSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBBdm9pZCB0aGUgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhcnJheSkgc2hvcnRjdXQsIHdoaWNoXFxuXFx0XFx0XFx0Ly8gdGhyb3dzIGEgXFxcIm1heGltdW0gY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXFxcIiBlcnJvciBmb3IgbGFyZ2UgYXJyYXlzLlxcblxcblxcdFxcdFxcdHZhciBzID0gJyc7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdC8vIEltcGxpY2l0bHkgYXNzdW1lcyBsaXR0bGUtZW5kaWFuLlxcblxcdFxcdFxcdFxcdHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSggYXJyYXlbIGkgXSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGV4dHJhY3RVcmxCYXNlOiBmdW5jdGlvbiAoIHVybCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcGFydHMgPSB1cmwuc3BsaXQoICcvJyApO1xcblxcblxcdFxcdFxcdGlmICggcGFydHMubGVuZ3RoID09PSAxICkgcmV0dXJuICcuLyc7XFxuXFxuXFx0XFx0XFx0cGFydHMucG9wKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHBhcnRzLmpvaW4oICcvJyApICsgJy8nO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBKU09OTG9hZGVyKCBtYW5hZ2VyICkge1xcblxcblxcdFxcdGlmICggdHlwZW9mIG1hbmFnZXIgPT09ICdib29sZWFuJyApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5KU09OTG9hZGVyOiBzaG93U3RhdHVzIHBhcmFtZXRlciBoYXMgYmVlbiByZW1vdmVkIGZyb20gY29uc3RydWN0b3IuJyApO1xcblxcdFxcdFxcdG1hbmFnZXIgPSB1bmRlZmluZWQ7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xcblxcblxcdFxcdHRoaXMud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5hc3NpZ24oIEpTT05Mb2FkZXIucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcXG5cXG5cXHRcXHRcXHR2YXIgc2NvcGUgPSB0aGlzO1xcblxcblxcdFxcdFxcdHZhciB0ZXh0dXJlUGF0aCA9IHRoaXMudGV4dHVyZVBhdGggJiYgKCB0eXBlb2YgdGhpcy50ZXh0dXJlUGF0aCA9PT0gJ3N0cmluZycgKSA/IHRoaXMudGV4dHVyZVBhdGggOiBMb2FkZXJVdGlscy5leHRyYWN0VXJsQmFzZSggdXJsICk7XFxuXFxuXFx0XFx0XFx0dmFyIGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcXG5cXHRcXHRcXHRsb2FkZXIuc2V0V2l0aENyZWRlbnRpYWxzKCB0aGlzLndpdGhDcmVkZW50aWFscyApO1xcblxcdFxcdFxcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIganNvbiA9IEpTT04ucGFyc2UoIHRleHQgKTtcXG5cXHRcXHRcXHRcXHR2YXIgbWV0YWRhdGEgPSBqc29uLm1ldGFkYXRhO1xcblxcblxcdFxcdFxcdFxcdGlmICggbWV0YWRhdGEgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgdHlwZSA9IG1ldGFkYXRhLnR5cGU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0eXBlICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB0eXBlLnRvTG93ZXJDYXNlKCkgPT09ICdvYmplY3QnICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5KU09OTG9hZGVyOiAnICsgdXJsICsgJyBzaG91bGQgYmUgbG9hZGVkIHdpdGggVEhSRUUuT2JqZWN0TG9hZGVyIGluc3RlYWQuJyApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB0eXBlLnRvTG93ZXJDYXNlKCkgPT09ICdzY2VuZScgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkpTT05Mb2FkZXI6ICcgKyB1cmwgKyAnIHNob3VsZCBiZSBsb2FkZWQgd2l0aCBUSFJFRS5TY2VuZUxvYWRlciBpbnN0ZWFkLicgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG9iamVjdCA9IHNjb3BlLnBhcnNlKCBqc29uLCB0ZXh0dXJlUGF0aCApO1xcblxcdFxcdFxcdFxcdG9uTG9hZCggb2JqZWN0Lmdlb21ldHJ5LCBvYmplY3QubWF0ZXJpYWxzICk7XFxuXFxuXFx0XFx0XFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0VGV4dHVyZVBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy50ZXh0dXJlUGF0aCA9IHZhbHVlO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cGFyc2U6ICggZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGZ1bmN0aW9uIHBhcnNlTW9kZWwoIGpzb24sIGdlb21ldHJ5ICkge1xcblxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uIGlzQml0U2V0KCB2YWx1ZSwgcG9zaXRpb24gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHZhbHVlICYgKCAxIDw8IHBvc2l0aW9uICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHZhciBpLCBqLCBmaSxcXG5cXG5cXHRcXHRcXHRcXHRcXHRvZmZzZXQsIHpMZW5ndGgsXFxuXFxuXFx0XFx0XFx0XFx0XFx0Y29sb3JJbmRleCwgbm9ybWFsSW5kZXgsIHV2SW5kZXgsIG1hdGVyaWFsSW5kZXgsXFxuXFxuXFx0XFx0XFx0XFx0XFx0dHlwZSxcXG5cXHRcXHRcXHRcXHRcXHRpc1F1YWQsXFxuXFx0XFx0XFx0XFx0XFx0aGFzTWF0ZXJpYWwsXFxuXFx0XFx0XFx0XFx0XFx0aGFzRmFjZVZlcnRleFV2LFxcblxcdFxcdFxcdFxcdFxcdGhhc0ZhY2VOb3JtYWwsIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwsXFxuXFx0XFx0XFx0XFx0XFx0aGFzRmFjZUNvbG9yLCBoYXNGYWNlVmVydGV4Q29sb3IsXFxuXFxuXFx0XFx0XFx0XFx0XFx0dmVydGV4LCBmYWNlLCBmYWNlQSwgZmFjZUIsIGhleCwgbm9ybWFsLFxcblxcblxcdFxcdFxcdFxcdFxcdHV2TGF5ZXIsIHV2LCB1LCB2LFxcblxcblxcdFxcdFxcdFxcdFxcdGZhY2VzID0ganNvbi5mYWNlcyxcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0aWNlcyA9IGpzb24udmVydGljZXMsXFxuXFx0XFx0XFx0XFx0XFx0bm9ybWFscyA9IGpzb24ubm9ybWFscyxcXG5cXHRcXHRcXHRcXHRcXHRjb2xvcnMgPSBqc29uLmNvbG9ycyxcXG5cXG5cXHRcXHRcXHRcXHRcXHRzY2FsZSA9IGpzb24uc2NhbGUsXFxuXFxuXFx0XFx0XFx0XFx0XFx0blV2TGF5ZXJzID0gMDtcXG5cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGpzb24udXZzICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gZGlzcmVnYXJkIGVtcHR5IGFycmF5c1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDwganNvbi51dnMubGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICgganNvbi51dnNbIGkgXS5sZW5ndGggKSBuVXZMYXllcnMgKys7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDwgblV2TGF5ZXJzOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXSA9IFtdO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0b2Zmc2V0ID0gMDtcXG5cXHRcXHRcXHRcXHR6TGVuZ3RoID0gdmVydGljZXMubGVuZ3RoO1xcblxcblxcdFxcdFxcdFxcdHdoaWxlICggb2Zmc2V0IDwgekxlbmd0aCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdFxcdFxcdHZlcnRleC54ID0gdmVydGljZXNbIG9mZnNldCArKyBdICogc2NhbGU7XFxuXFx0XFx0XFx0XFx0XFx0dmVydGV4LnkgPSB2ZXJ0aWNlc1sgb2Zmc2V0ICsrIF0gKiBzY2FsZTtcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0ZXgueiA9IHZlcnRpY2VzWyBvZmZzZXQgKysgXSAqIHNjYWxlO1xcblxcblxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRvZmZzZXQgPSAwO1xcblxcdFxcdFxcdFxcdHpMZW5ndGggPSBmYWNlcy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0XFx0d2hpbGUgKCBvZmZzZXQgPCB6TGVuZ3RoICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHR5cGUgPSBmYWNlc1sgb2Zmc2V0ICsrIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0aXNRdWFkID0gaXNCaXRTZXQoIHR5cGUsIDAgKTtcXG5cXHRcXHRcXHRcXHRcXHRoYXNNYXRlcmlhbCA9IGlzQml0U2V0KCB0eXBlLCAxICk7XFxuXFx0XFx0XFx0XFx0XFx0aGFzRmFjZVZlcnRleFV2ID0gaXNCaXRTZXQoIHR5cGUsIDMgKTtcXG5cXHRcXHRcXHRcXHRcXHRoYXNGYWNlTm9ybWFsID0gaXNCaXRTZXQoIHR5cGUsIDQgKTtcXG5cXHRcXHRcXHRcXHRcXHRoYXNGYWNlVmVydGV4Tm9ybWFsID0gaXNCaXRTZXQoIHR5cGUsIDUgKTtcXG5cXHRcXHRcXHRcXHRcXHRoYXNGYWNlQ29sb3IgPSBpc0JpdFNldCggdHlwZSwgNiApO1xcblxcdFxcdFxcdFxcdFxcdGhhc0ZhY2VWZXJ0ZXhDb2xvciA9IGlzQml0U2V0KCB0eXBlLCA3ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gY29uc29sZS5sb2coXFxcInR5cGVcXFwiLCB0eXBlLCBcXFwiYml0c1xcXCIsIGlzUXVhZCwgaGFzTWF0ZXJpYWwsIGhhc0ZhY2VWZXJ0ZXhVdiwgaGFzRmFjZU5vcm1hbCwgaGFzRmFjZVZlcnRleE5vcm1hbCwgaGFzRmFjZUNvbG9yLCBoYXNGYWNlVmVydGV4Q29sb3IpO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggaXNRdWFkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGZhY2VBID0gbmV3IEZhY2UzKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmFjZUEuYSA9IGZhY2VzWyBvZmZzZXQgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmYWNlQS5iID0gZmFjZXNbIG9mZnNldCArIDEgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmYWNlQS5jID0gZmFjZXNbIG9mZnNldCArIDMgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmYWNlQiA9IG5ldyBGYWNlMygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGZhY2VCLmEgPSBmYWNlc1sgb2Zmc2V0ICsgMSBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdGZhY2VCLmIgPSBmYWNlc1sgb2Zmc2V0ICsgMiBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdGZhY2VCLmMgPSBmYWNlc1sgb2Zmc2V0ICsgMyBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdG9mZnNldCArPSA0O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggaGFzTWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmYWNlQS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmYWNlQi5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gdG8gZ2V0IGZhY2UgPD0+IHV2IGluZGV4IGNvcnJlc3BvbmRlbmNlXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmkgPSBnZW9tZXRyeS5mYWNlcy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBoYXNGYWNlVmVydGV4VXYgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPCBuVXZMYXllcnM7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dXZMYXllciA9IGpzb24udXZzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdID0gW107XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSArIDEgXSA9IFtdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIGogPSAwOyBqIDwgNDsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR1dkluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHUgPSB1dkxheWVyWyB1dkluZGV4ICogMiBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHYgPSB1dkxheWVyWyB1dkluZGV4ICogMiArIDEgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR1diA9IG5ldyBWZWN0b3IyKCB1LCB2ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBqICE9PSAyICkgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdLnB1c2goIHV2ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBqICE9PSAwICkgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSArIDEgXS5wdXNoKCB1diApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggaGFzRmFjZU5vcm1hbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXSAqIDM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZmFjZUEubm9ybWFsLnNldChcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggXVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZmFjZUIubm9ybWFsLmNvcHkoIGZhY2VBLm5vcm1hbCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPCA0OyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub3JtYWwgPSBuZXcgVmVjdG9yMyhcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggXVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdCk7XFxuXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBpICE9PSAyICkgZmFjZUEudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGkgIT09IDAgKSBmYWNlQi52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBoYXNGYWNlQ29sb3IgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRoZXggPSBjb2xvcnNbIGNvbG9ySW5kZXggXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmYWNlQS5jb2xvci5zZXRIZXgoIGhleCApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZhY2VCLmNvbG9yLnNldEhleCggaGV4ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggaGFzRmFjZVZlcnRleENvbG9yICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDwgNDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjb2xvckluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGhleCA9IGNvbG9yc1sgY29sb3JJbmRleCBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggaSAhPT0gMiApIGZhY2VBLnZlcnRleENvbG9ycy5wdXNoKCBuZXcgQ29sb3IoIGhleCApICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBpICE9PSAwICkgZmFjZUIudmVydGV4Q29sb3JzLnB1c2goIG5ldyBDb2xvciggaGV4ICkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5LmZhY2VzLnB1c2goIGZhY2VBICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkuZmFjZXMucHVzaCggZmFjZUIgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGZhY2UgPSBuZXcgRmFjZTMoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmYWNlLmEgPSBmYWNlc1sgb2Zmc2V0ICsrIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmFjZS5iID0gZmFjZXNbIG9mZnNldCArKyBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdGZhY2UuYyA9IGZhY2VzWyBvZmZzZXQgKysgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGhhc01hdGVyaWFsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZmFjZS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gdG8gZ2V0IGZhY2UgPD0+IHV2IGluZGV4IGNvcnJlc3BvbmRlbmNlXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmkgPSBnZW9tZXRyeS5mYWNlcy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBoYXNGYWNlVmVydGV4VXYgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPCBuVXZMYXllcnM7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dXZMYXllciA9IGpzb24udXZzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdID0gW107XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggaiA9IDA7IGogPCAzOyBqICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHV2SW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dSA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0diA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyICsgMSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHV2ID0gbmV3IFZlY3RvcjIoIHUsIHYgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0ucHVzaCggdXYgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGhhc0ZhY2VOb3JtYWwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZhY2Uubm9ybWFsLnNldChcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggXVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggaGFzRmFjZVZlcnRleE5vcm1hbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbCA9IG5ldyBWZWN0b3IzKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyBub3JtYWxJbmRleCBdXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRmYWNlLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGhhc0ZhY2VDb2xvciApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb2xvckluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZhY2UuY29sb3Iuc2V0SGV4KCBjb2xvcnNbIGNvbG9ySW5kZXggXSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGhhc0ZhY2VWZXJ0ZXhDb2xvciApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRmYWNlLnZlcnRleENvbG9ycy5wdXNoKCBuZXcgQ29sb3IoIGNvbG9yc1sgY29sb3JJbmRleCBdICkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5LmZhY2VzLnB1c2goIGZhY2UgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmdW5jdGlvbiBwYXJzZVNraW4oIGpzb24sIGdlb21ldHJ5ICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBpbmZsdWVuY2VzUGVyVmVydGV4ID0gKCBqc29uLmluZmx1ZW5jZXNQZXJWZXJ0ZXggIT09IHVuZGVmaW5lZCApID8ganNvbi5pbmZsdWVuY2VzUGVyVmVydGV4IDogMjtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGpzb24uc2tpbldlaWdodHMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5za2luV2VpZ2h0cy5sZW5ndGg7IGkgPCBsOyBpICs9IGluZmx1ZW5jZXNQZXJWZXJ0ZXggKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHggPSBqc29uLnNraW5XZWlnaHRzWyBpIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHkgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAxICkgPyBqc29uLnNraW5XZWlnaHRzWyBpICsgMSBdIDogMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgeiA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDIgKSA/IGpzb24uc2tpbldlaWdodHNbIGkgKyAyIF0gOiAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciB3ID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMyApID8ganNvbi5za2luV2VpZ2h0c1sgaSArIDMgXSA6IDA7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkuc2tpbldlaWdodHMucHVzaCggbmV3IFZlY3RvcjQoIHgsIHksIHosIHcgKSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBqc29uLnNraW5JbmRpY2VzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24uc2tpbkluZGljZXMubGVuZ3RoOyBpIDwgbDsgaSArPSBpbmZsdWVuY2VzUGVyVmVydGV4ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBhID0ganNvbi5za2luSW5kaWNlc1sgaSBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBiID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMSApID8ganNvbi5za2luSW5kaWNlc1sgaSArIDEgXSA6IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGMgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAyICkgPyBqc29uLnNraW5JbmRpY2VzWyBpICsgMiBdIDogMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgZCA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDMgKSA/IGpzb24uc2tpbkluZGljZXNbIGkgKyAzIF0gOiAwO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5LnNraW5JbmRpY2VzLnB1c2goIG5ldyBWZWN0b3I0KCBhLCBiLCBjLCBkICkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGdlb21ldHJ5LmJvbmVzID0ganNvbi5ib25lcztcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJ5LmJvbmVzICYmIGdlb21ldHJ5LmJvbmVzLmxlbmd0aCA+IDAgJiYgKCBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggIT09IGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCB8fCBnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggIT09IGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1doZW4gc2tpbm5pbmcsIG51bWJlciBvZiB2ZXJ0aWNlcyAoJyArIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCArICcpLCBza2luSW5kaWNlcyAoJyArXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoICsgJyksIGFuZCBza2luV2VpZ2h0cyAoJyArIGdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCArICcpIHNob3VsZCBtYXRjaC4nICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmdW5jdGlvbiBwYXJzZU1vcnBoaW5nKCBqc29uLCBnZW9tZXRyeSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgc2NhbGUgPSBqc29uLnNjYWxlO1xcblxcblxcdFxcdFxcdFxcdGlmICgganNvbi5tb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdID0ge307XFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0ubmFtZSA9IGpzb24ubW9ycGhUYXJnZXRzWyBpIF0ubmFtZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcyA9IFtdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBkc3RWZXJ0aWNlcyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBzcmNWZXJ0aWNlcyA9IGpzb24ubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIHYgPSAwLCB2bCA9IHNyY1ZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICs9IDMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmVydGV4LnggPSBzcmNWZXJ0aWNlc1sgdiBdICogc2NhbGU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmVydGV4LnkgPSBzcmNWZXJ0aWNlc1sgdiArIDEgXSAqIHNjYWxlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZlcnRleC56ID0gc3JjVmVydGljZXNbIHYgKyAyIF0gKiBzY2FsZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkc3RWZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGpzb24ubW9ycGhDb2xvcnMgIT09IHVuZGVmaW5lZCAmJiBqc29uLm1vcnBoQ29sb3JzLmxlbmd0aCA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSlNPTkxvYWRlcjogXFxcIm1vcnBoQ29sb3JzXFxcIiBubyBsb25nZXIgc3VwcG9ydGVkLiBVc2luZyB0aGVtIGFzIGZhY2UgY29sb3JzLicgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgZmFjZXMgPSBnZW9tZXRyeS5mYWNlcztcXG5cXHRcXHRcXHRcXHRcXHR2YXIgbW9ycGhDb2xvcnMgPSBqc29uLm1vcnBoQ29sb3JzWyAwIF0uY29sb3JzO1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmFjZXNbIGkgXS5jb2xvci5mcm9tQXJyYXkoIG1vcnBoQ29sb3JzLCBpICogMyApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGZ1bmN0aW9uIHBhcnNlQW5pbWF0aW9ucygganNvbiwgZ2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG91dHB1dEFuaW1hdGlvbnMgPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBwYXJzZSBvbGQgc3R5bGUgQm9uZS9IaWVyYXJjaHkgYW5pbWF0aW9uc1xcblxcdFxcdFxcdFxcdHZhciBhbmltYXRpb25zID0gW107XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBqc29uLmFuaW1hdGlvbiAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGFuaW1hdGlvbnMucHVzaCgganNvbi5hbmltYXRpb24gKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBqc29uLmFuaW1hdGlvbnMgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGpzb24uYW5pbWF0aW9ucy5sZW5ndGggKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YW5pbWF0aW9ucyA9IGFuaW1hdGlvbnMuY29uY2F0KCBqc29uLmFuaW1hdGlvbnMgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGFuaW1hdGlvbnMucHVzaCgganNvbi5hbmltYXRpb25zICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBhbmltYXRpb25zLmxlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgY2xpcCA9IEFuaW1hdGlvbkNsaXAucGFyc2VBbmltYXRpb24oIGFuaW1hdGlvbnNbIGkgXSwgZ2VvbWV0cnkuYm9uZXMgKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGNsaXAgKSBvdXRwdXRBbmltYXRpb25zLnB1c2goIGNsaXAgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gcGFyc2UgaW1wbGljaXQgbW9ycGggYW5pbWF0aW9uc1xcblxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cnkubW9ycGhUYXJnZXRzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFRPRE86IEZpZ3VyZSBvdXQgd2hhdCBhbiBhcHByb3ByYWl0ZSBGUFMgaXMgZm9yIG1vcnBoIHRhcmdldCBhbmltYXRpb25zIC0tIGRlZmF1bHRpbmcgdG8gMTAsIGJ1dCByZWFsbHkgaXQgaXMgY29tcGxldGVseSBhcmJpdHJhcnkuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIG1vcnBoQW5pbWF0aW9uQ2xpcHMgPSBBbmltYXRpb25DbGlwLkNyZWF0ZUNsaXBzRnJvbU1vcnBoVGFyZ2V0U2VxdWVuY2VzKCBnZW9tZXRyeS5tb3JwaFRhcmdldHMsIDEwICk7XFxuXFx0XFx0XFx0XFx0XFx0b3V0cHV0QW5pbWF0aW9ucyA9IG91dHB1dEFuaW1hdGlvbnMuY29uY2F0KCBtb3JwaEFuaW1hdGlvbkNsaXBzICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggb3V0cHV0QW5pbWF0aW9ucy5sZW5ndGggPiAwICkgZ2VvbWV0cnkuYW5pbWF0aW9ucyA9IG91dHB1dEFuaW1hdGlvbnM7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiAoIGpzb24sIHRleHR1cmVQYXRoICkge1xcblxcblxcdFxcdFxcdFxcdGlmICgganNvbi5kYXRhICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gR2VvbWV0cnkgNC4wIHNwZWNcXG5cXHRcXHRcXHRcXHRcXHRqc29uID0ganNvbi5kYXRhO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGpzb24uc2NhbGUgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRqc29uLnNjYWxlID0gMS4wIC8ganNvbi5zY2FsZTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdGpzb24uc2NhbGUgPSAxLjA7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHZhciBnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeSgpO1xcblxcblxcdFxcdFxcdFxcdHBhcnNlTW9kZWwoIGpzb24sIGdlb21ldHJ5ICk7XFxuXFx0XFx0XFx0XFx0cGFyc2VTa2luKCBqc29uLCBnZW9tZXRyeSApO1xcblxcdFxcdFxcdFxcdHBhcnNlTW9ycGhpbmcoIGpzb24sIGdlb21ldHJ5ICk7XFxuXFx0XFx0XFx0XFx0cGFyc2VBbmltYXRpb25zKCBqc29uLCBnZW9tZXRyeSApO1xcblxcblxcdFxcdFxcdFxcdGdlb21ldHJ5LmNvbXB1dGVGYWNlTm9ybWFscygpO1xcblxcdFxcdFxcdFxcdGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xcblxcblxcdFxcdFxcdFxcdGlmICgganNvbi5tYXRlcmlhbHMgPT09IHVuZGVmaW5lZCB8fCBqc29uLm1hdGVyaWFscy5sZW5ndGggPT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHsgZ2VvbWV0cnk6IGdlb21ldHJ5IH07XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgbWF0ZXJpYWxzID0gTG9hZGVyLnByb3RvdHlwZS5pbml0TWF0ZXJpYWxzKCBqc29uLm1hdGVyaWFscywgdGV4dHVyZVBhdGgsIHRoaXMuY3Jvc3NPcmlnaW4gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4geyBnZW9tZXRyeTogZ2VvbWV0cnksIG1hdGVyaWFsczogbWF0ZXJpYWxzIH07XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSApKClcXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBPYmplY3RMb2FkZXIoIG1hbmFnZXIgKSB7XFxuXFxuXFx0XFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XFxuXFx0XFx0dGhpcy50ZXh0dXJlUGF0aCA9ICcnO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBPYmplY3RMb2FkZXIucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMudGV4dHVyZVBhdGggPT09ICcnICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMudGV4dHVyZVBhdGggPSB1cmwuc3Vic3RyaW5nKCAwLCB1cmwubGFzdEluZGV4T2YoICcvJyApICsgMSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgc2NvcGUgPSB0aGlzO1xcblxcblxcdFxcdFxcdHZhciBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggc2NvcGUubWFuYWdlciApO1xcblxcdFxcdFxcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggdGV4dCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIganNvbiA9IG51bGw7XFxuXFxuXFx0XFx0XFx0XFx0dHJ5IHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRqc29uID0gSlNPTi5wYXJzZSggdGV4dCApO1xcblxcblxcdFxcdFxcdFxcdH0gY2F0Y2ggKCBlcnJvciApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG9uRXJyb3IgIT09IHVuZGVmaW5lZCApIG9uRXJyb3IoIGVycm9yICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFOk9iamVjdExvYWRlcjogQ2FuXFxcXCd0IHBhcnNlICcgKyB1cmwgKyAnLicsIGVycm9yLm1lc3NhZ2UgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHZhciBtZXRhZGF0YSA9IGpzb24ubWV0YWRhdGE7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBtZXRhZGF0YSA9PT0gdW5kZWZpbmVkIHx8IG1ldGFkYXRhLnR5cGUgPT09IHVuZGVmaW5lZCB8fCBtZXRhZGF0YS50eXBlLnRvTG93ZXJDYXNlKCkgPT09ICdnZW9tZXRyeScgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk9iamVjdExvYWRlcjogQ2FuXFxcXCd0IGxvYWQgJyArIHVybCArICcuIFVzZSBUSFJFRS5KU09OTG9hZGVyIGluc3RlYWQuJyApO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0c2NvcGUucGFyc2UoIGpzb24sIG9uTG9hZCApO1xcblxcblxcdFxcdFxcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFRleHR1cmVQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdHRoaXMudGV4dHVyZVBhdGggPSB2YWx1ZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHBhcnNlOiBmdW5jdGlvbiAoIGpzb24sIG9uTG9hZCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgc2hhcGVzID0gdGhpcy5wYXJzZVNoYXBlKCBqc29uLnNoYXBlcyApO1xcblxcdFxcdFxcdHZhciBnZW9tZXRyaWVzID0gdGhpcy5wYXJzZUdlb21ldHJpZXMoIGpzb24uZ2VvbWV0cmllcywgc2hhcGVzICk7XFxuXFxuXFx0XFx0XFx0dmFyIGltYWdlcyA9IHRoaXMucGFyc2VJbWFnZXMoIGpzb24uaW1hZ2VzLCBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBvbkxvYWQgIT09IHVuZGVmaW5lZCApIG9uTG9hZCggb2JqZWN0ICk7XFxuXFxuXFx0XFx0XFx0fSApO1xcblxcblxcdFxcdFxcdHZhciB0ZXh0dXJlcyA9IHRoaXMucGFyc2VUZXh0dXJlcygganNvbi50ZXh0dXJlcywgaW1hZ2VzICk7XFxuXFx0XFx0XFx0dmFyIG1hdGVyaWFscyA9IHRoaXMucGFyc2VNYXRlcmlhbHMoIGpzb24ubWF0ZXJpYWxzLCB0ZXh0dXJlcyApO1xcblxcblxcdFxcdFxcdHZhciBvYmplY3QgPSB0aGlzLnBhcnNlT2JqZWN0KCBqc29uLm9iamVjdCwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBqc29uLmFuaW1hdGlvbnMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0b2JqZWN0LmFuaW1hdGlvbnMgPSB0aGlzLnBhcnNlQW5pbWF0aW9ucygganNvbi5hbmltYXRpb25zICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICgganNvbi5pbWFnZXMgPT09IHVuZGVmaW5lZCB8fCBqc29uLmltYWdlcy5sZW5ndGggPT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBvbkxvYWQgIT09IHVuZGVmaW5lZCApIG9uTG9hZCggb2JqZWN0ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBvYmplY3Q7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRwYXJzZVNoYXBlOiBmdW5jdGlvbiAoIGpzb24gKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHNoYXBlcyA9IHt9O1xcblxcblxcdFxcdFxcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgc2hhcGUgPSBuZXcgU2hhcGUoKS5mcm9tSlNPTigganNvblsgaSBdICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0c2hhcGVzWyBzaGFwZS51dWlkIF0gPSBzaGFwZTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBzaGFwZXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRwYXJzZUdlb21ldHJpZXM6IGZ1bmN0aW9uICgganNvbiwgc2hhcGVzICkge1xcblxcblxcdFxcdFxcdHZhciBnZW9tZXRyaWVzID0ge307XFxuXFxuXFx0XFx0XFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGdlb21ldHJ5TG9hZGVyID0gbmV3IEpTT05Mb2FkZXIoKTtcXG5cXHRcXHRcXHRcXHR2YXIgYnVmZmVyR2VvbWV0cnlMb2FkZXIgPSBuZXcgQnVmZmVyR2VvbWV0cnlMb2FkZXIoKTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGdlb21ldHJ5O1xcblxcdFxcdFxcdFxcdFxcdHZhciBkYXRhID0ganNvblsgaSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdHN3aXRjaCAoIGRhdGEudHlwZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdQbGFuZUdlb21ldHJ5JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdQbGFuZUJ1ZmZlckdlb21ldHJ5JzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLndpZHRoLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEuaGVpZ2h0LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEud2lkdGhTZWdtZW50cyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLmhlaWdodFNlZ21lbnRzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdCb3hHZW9tZXRyeSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnQm94QnVmZmVyR2VvbWV0cnknOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ0N1YmVHZW9tZXRyeSc6IC8vIGJhY2t3YXJkcyBjb21wYXRpYmxlXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS53aWR0aCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLmhlaWdodCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLmRlcHRoLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEud2lkdGhTZWdtZW50cyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLmhlaWdodFNlZ21lbnRzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEuZGVwdGhTZWdtZW50c1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnQ2lyY2xlR2VvbWV0cnknOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ0NpcmNsZUJ1ZmZlckdlb21ldHJ5JzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnJhZGl1cyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnNlZ21lbnRzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEudGhldGFTdGFydCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnRoZXRhTGVuZ3RoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdDeWxpbmRlckdlb21ldHJ5JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdDeWxpbmRlckJ1ZmZlckdlb21ldHJ5JzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnJhZGl1c1RvcCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnJhZGl1c0JvdHRvbSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLmhlaWdodCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnJhZGlhbFNlZ21lbnRzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEuaGVpZ2h0U2VnbWVudHMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5vcGVuRW5kZWQsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS50aGV0YVN0YXJ0LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEudGhldGFMZW5ndGhcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ0NvbmVHZW9tZXRyeSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnQ29uZUJ1ZmZlckdlb21ldHJ5JzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnJhZGl1cyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLmhlaWdodCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnJhZGlhbFNlZ21lbnRzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEuaGVpZ2h0U2VnbWVudHMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5vcGVuRW5kZWQsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS50aGV0YVN0YXJ0LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEudGhldGFMZW5ndGhcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ1NwaGVyZUdlb21ldHJ5JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdTcGhlcmVCdWZmZXJHZW9tZXRyeSc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5yYWRpdXMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS53aWR0aFNlZ21lbnRzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEuaGVpZ2h0U2VnbWVudHMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5waGlTdGFydCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnBoaUxlbmd0aCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnRoZXRhU3RhcnQsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS50aGV0YUxlbmd0aFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnRG9kZWNhaGVkcm9uR2VvbWV0cnknOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ0RvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdJY29zYWhlZHJvbkdlb21ldHJ5JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdJY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdPY3RhaGVkcm9uR2VvbWV0cnknOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ09jdGFoZWRyb25CdWZmZXJHZW9tZXRyeSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnVGV0cmFoZWRyb25HZW9tZXRyeSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnVGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeSc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5yYWRpdXMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5kZXRhaWxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ1JpbmdHZW9tZXRyeSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnUmluZ0J1ZmZlckdlb21ldHJ5JzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLmlubmVyUmFkaXVzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEub3V0ZXJSYWRpdXMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS50aGV0YVNlZ21lbnRzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEucGhpU2VnbWVudHMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS50aGV0YVN0YXJ0LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEudGhldGFMZW5ndGhcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ1RvcnVzR2VvbWV0cnknOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ1RvcnVzQnVmZmVyR2VvbWV0cnknOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEucmFkaXVzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEudHViZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnJhZGlhbFNlZ21lbnRzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEudHVidWxhclNlZ21lbnRzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEuYXJjXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdUb3J1c0tub3RHZW9tZXRyeSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnVG9ydXNLbm90QnVmZmVyR2VvbWV0cnknOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEucmFkaXVzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEudHViZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnR1YnVsYXJTZWdtZW50cyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnJhZGlhbFNlZ21lbnRzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEucCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnFcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ0xhdGhlR2VvbWV0cnknOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ0xhdGhlQnVmZmVyR2VvbWV0cnknOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEucG9pbnRzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEuc2VnbWVudHMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5waGlTdGFydCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnBoaUxlbmd0aFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnUG9seWhlZHJvbkdlb21ldHJ5JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnknOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEudmVydGljZXMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5pbmRpY2VzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEucmFkaXVzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEuZGV0YWlsc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnU2hhcGVHZW9tZXRyeSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnU2hhcGVCdWZmZXJHZW9tZXRyeSc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGdlb21ldHJ5U2hhcGVzID0gW107XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZGF0YS5zaGFwZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgc2hhcGUgPSBzaGFwZXNbIGRhdGEuc2hhcGVzWyBpIF0gXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeVNoYXBlcy5wdXNoKCBzaGFwZSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeVNoYXBlcyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLmN1cnZlU2VnbWVudHNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ0J1ZmZlckdlb21ldHJ5JzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeSA9IGJ1ZmZlckdlb21ldHJ5TG9hZGVyLnBhcnNlKCBkYXRhICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnR2VvbWV0cnknOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5ID0gZ2VvbWV0cnlMb2FkZXIucGFyc2UoIGRhdGEsIHRoaXMudGV4dHVyZVBhdGggKS5nZW9tZXRyeTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRkZWZhdWx0OlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5zdXBwb3J0ZWQgZ2VvbWV0cnkgdHlwZSBcXFwiJyArIGRhdGEudHlwZSArICdcXFwiJyApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRnZW9tZXRyeS51dWlkID0gZGF0YS51dWlkO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSBnZW9tZXRyeS5uYW1lID0gZGF0YS5uYW1lO1xcblxcblxcdFxcdFxcdFxcdFxcdGdlb21ldHJpZXNbIGRhdGEudXVpZCBdID0gZ2VvbWV0cnk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gZ2VvbWV0cmllcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHBhcnNlTWF0ZXJpYWxzOiBmdW5jdGlvbiAoIGpzb24sIHRleHR1cmVzICkge1xcblxcblxcdFxcdFxcdHZhciBtYXRlcmlhbHMgPSB7fTtcXG5cXG5cXHRcXHRcXHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbG9hZGVyID0gbmV3IE1hdGVyaWFsTG9hZGVyKCk7XFxuXFx0XFx0XFx0XFx0bG9hZGVyLnNldFRleHR1cmVzKCB0ZXh0dXJlcyApO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgZGF0YSA9IGpzb25bIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEudHlwZSA9PT0gJ011bHRpTWF0ZXJpYWwnICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIERlcHJlY2F0ZWRcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgYXJyYXkgPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaiA9IDA7IGogPCBkYXRhLm1hdGVyaWFscy5sZW5ndGg7IGogKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YXJyYXkucHVzaCggbG9hZGVyLnBhcnNlKCBkYXRhLm1hdGVyaWFsc1sgaiBdICkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWxzWyBkYXRhLnV1aWQgXSA9IGFycmF5O1xcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWxzWyBkYXRhLnV1aWQgXSA9IGxvYWRlci5wYXJzZSggZGF0YSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBtYXRlcmlhbHM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRwYXJzZUFuaW1hdGlvbnM6IGZ1bmN0aW9uICgganNvbiApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYW5pbWF0aW9ucyA9IFtdO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IGpzb24ubGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBjbGlwID0gQW5pbWF0aW9uQ2xpcC5wYXJzZSgganNvblsgaSBdICk7XFxuXFxuXFx0XFx0XFx0XFx0YW5pbWF0aW9ucy5wdXNoKCBjbGlwICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBhbmltYXRpb25zO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cGFyc2VJbWFnZXM6IGZ1bmN0aW9uICgganNvbiwgb25Mb2FkICkge1xcblxcblxcdFxcdFxcdHZhciBzY29wZSA9IHRoaXM7XFxuXFx0XFx0XFx0dmFyIGltYWdlcyA9IHt9O1xcblxcblxcdFxcdFxcdGZ1bmN0aW9uIGxvYWRJbWFnZSggdXJsICkge1xcblxcblxcdFxcdFxcdFxcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gbG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdFxcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XFxuXFxuXFx0XFx0XFx0XFx0fSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcXG5cXHRcXHRcXHRcXHRcXHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XFxuXFxuXFx0XFx0XFx0XFx0fSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCAmJiBqc29uLmxlbmd0aCA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG1hbmFnZXIgPSBuZXcgTG9hZGluZ01hbmFnZXIoIG9uTG9hZCApO1xcblxcblxcdFxcdFxcdFxcdHZhciBsb2FkZXIgPSBuZXcgSW1hZ2VMb2FkZXIoIG1hbmFnZXIgKTtcXG5cXHRcXHRcXHRcXHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGltYWdlID0ganNvblsgaSBdO1xcblxcdFxcdFxcdFxcdFxcdHZhciBwYXRoID0gL14oXFxcXC9cXFxcLyl8KFthLXpdKzooXFxcXC9cXFxcLyk/KS9pLnRlc3QoIGltYWdlLnVybCApID8gaW1hZ2UudXJsIDogc2NvcGUudGV4dHVyZVBhdGggKyBpbWFnZS51cmw7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aW1hZ2VzWyBpbWFnZS51dWlkIF0gPSBsb2FkSW1hZ2UoIHBhdGggKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBpbWFnZXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRwYXJzZVRleHR1cmVzOiBmdW5jdGlvbiAoIGpzb24sIGltYWdlcyApIHtcXG5cXG5cXHRcXHRcXHRmdW5jdGlvbiBwYXJzZUNvbnN0YW50KCB2YWx1ZSwgdHlwZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgKSByZXR1cm4gdmFsdWU7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyLnBhcnNlVGV4dHVyZTogQ29uc3RhbnQgc2hvdWxkIGJlIGluIG51bWVyaWMgZm9ybS4nLCB2YWx1ZSApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0eXBlWyB2YWx1ZSBdO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgdGV4dHVyZXMgPSB7fTtcXG5cXG5cXHRcXHRcXHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGRhdGEgPSBqc29uWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLmltYWdlID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBObyBcXFwiaW1hZ2VcXFwiIHNwZWNpZmllZCBmb3InLCBkYXRhLnV1aWQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBpbWFnZXNbIGRhdGEuaW1hZ2UgXSA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIGltYWdlJywgZGF0YS5pbWFnZSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKCBpbWFnZXNbIGRhdGEuaW1hZ2UgXSApO1xcblxcdFxcdFxcdFxcdFxcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdFxcdHRleHR1cmUudXVpZCA9IGRhdGEudXVpZDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5uYW1lID0gZGF0YS5uYW1lO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS5tYXBwaW5nICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1hcHBpbmcgPSBwYXJzZUNvbnN0YW50KCBkYXRhLm1hcHBpbmcsIFRFWFRVUkVfTUFQUElORyApO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS5vZmZzZXQgIT09IHVuZGVmaW5lZCApIHRleHR1cmUub2Zmc2V0LmZyb21BcnJheSggZGF0YS5vZmZzZXQgKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEucmVwZWF0ICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLnJlcGVhdC5mcm9tQXJyYXkoIGRhdGEucmVwZWF0ICk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLmNlbnRlciAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5jZW50ZXIuZnJvbUFycmF5KCBkYXRhLmNlbnRlciApO1xcblxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5yb3RhdGlvbiA9IGRhdGEucm90YXRpb247XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLndyYXAgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLndyYXBTID0gcGFyc2VDb25zdGFudCggZGF0YS53cmFwWyAwIF0sIFRFWFRVUkVfV1JBUFBJTkcgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLndyYXBUID0gcGFyc2VDb25zdGFudCggZGF0YS53cmFwWyAxIF0sIFRFWFRVUkVfV1JBUFBJTkcgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLm1pbkZpbHRlciAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5taW5GaWx0ZXIgPSBwYXJzZUNvbnN0YW50KCBkYXRhLm1pbkZpbHRlciwgVEVYVFVSRV9GSUxURVIgKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEubWFnRmlsdGVyICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1hZ0ZpbHRlciA9IHBhcnNlQ29uc3RhbnQoIGRhdGEubWFnRmlsdGVyLCBURVhUVVJFX0ZJTFRFUiApO1xcblxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS5hbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLmFuaXNvdHJvcHkgPSBkYXRhLmFuaXNvdHJvcHk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLmZsaXBZICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLmZsaXBZID0gZGF0YS5mbGlwWTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlc1sgZGF0YS51dWlkIF0gPSB0ZXh0dXJlO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRleHR1cmVzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cGFyc2VPYmplY3Q6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gcGFyc2VPYmplY3QoIGRhdGEsIGdlb21ldHJpZXMsIG1hdGVyaWFscyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgb2JqZWN0O1xcblxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uIGdldEdlb21ldHJ5KCBuYW1lICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cmllc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgZ2VvbWV0cnknLCBuYW1lICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBnZW9tZXRyaWVzWyBuYW1lIF07XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uIGdldE1hdGVyaWFsKCBuYW1lICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggbmFtZSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIHVuZGVmaW5lZDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIEFycmF5LmlzQXJyYXkoIG5hbWUgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgYXJyYXkgPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBuYW1lLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIHV1aWQgPSBuYW1lWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBtYXRlcmlhbHNbIHV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIG1hdGVyaWFsJywgdXVpZCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRhcnJheS5wdXNoKCBtYXRlcmlhbHNbIHV1aWQgXSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gYXJyYXk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGlmICggbWF0ZXJpYWxzWyBuYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBtYXRlcmlhbCcsIG5hbWUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIG1hdGVyaWFsc1sgbmFtZSBdO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRzd2l0Y2ggKCBkYXRhLnR5cGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnU2NlbmUnOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdCA9IG5ldyBTY2VuZSgpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS5iYWNrZ3JvdW5kICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBOdW1iZXIuaXNJbnRlZ2VyKCBkYXRhLmJhY2tncm91bmQgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRvYmplY3QuYmFja2dyb3VuZCA9IG5ldyBDb2xvciggZGF0YS5iYWNrZ3JvdW5kICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEuZm9nICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLmZvZy50eXBlID09PSAnRm9nJyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRvYmplY3QuZm9nID0gbmV3IEZvZyggZGF0YS5mb2cuY29sb3IsIGRhdGEuZm9nLm5lYXIsIGRhdGEuZm9nLmZhciApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIGRhdGEuZm9nLnR5cGUgPT09ICdGb2dFeHAyJyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRvYmplY3QuZm9nID0gbmV3IEZvZ0V4cDIoIGRhdGEuZm9nLmNvbG9yLCBkYXRhLmZvZy5kZW5zaXR5ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdQZXJzcGVjdGl2ZUNhbWVyYSc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0ID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCBkYXRhLmZvdiwgZGF0YS5hc3BlY3QsIGRhdGEubmVhciwgZGF0YS5mYXIgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEuZm9jdXMgIT09IHVuZGVmaW5lZCApIG9iamVjdC5mb2N1cyA9IGRhdGEuZm9jdXM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLnpvb20gIT09IHVuZGVmaW5lZCApIG9iamVjdC56b29tID0gZGF0YS56b29tO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS5maWxtR2F1Z2UgIT09IHVuZGVmaW5lZCApIG9iamVjdC5maWxtR2F1Z2UgPSBkYXRhLmZpbG1HYXVnZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEuZmlsbU9mZnNldCAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmZpbG1PZmZzZXQgPSBkYXRhLmZpbG1PZmZzZXQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLnZpZXcgIT09IHVuZGVmaW5lZCApIG9iamVjdC52aWV3ID0gT2JqZWN0LmFzc2lnbigge30sIGRhdGEudmlldyApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ09ydGhvZ3JhcGhpY0NhbWVyYSc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0ID0gbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYSggZGF0YS5sZWZ0LCBkYXRhLnJpZ2h0LCBkYXRhLnRvcCwgZGF0YS5ib3R0b20sIGRhdGEubmVhciwgZGF0YS5mYXIgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdBbWJpZW50TGlnaHQnOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdCA9IG5ldyBBbWJpZW50TGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnRGlyZWN0aW9uYWxMaWdodCc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0ID0gbmV3IERpcmVjdGlvbmFsTGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnUG9pbnRMaWdodCc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0ID0gbmV3IFBvaW50TGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLmRpc3RhbmNlLCBkYXRhLmRlY2F5ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnUmVjdEFyZWFMaWdodCc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0ID0gbmV3IFJlY3RBcmVhTGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLndpZHRoLCBkYXRhLmhlaWdodCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ1Nwb3RMaWdodCc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0ID0gbmV3IFNwb3RMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHksIGRhdGEuZGlzdGFuY2UsIGRhdGEuYW5nbGUsIGRhdGEucGVudW1icmEsIGRhdGEuZGVjYXkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdIZW1pc3BoZXJlTGlnaHQnOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdCA9IG5ldyBIZW1pc3BoZXJlTGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuZ3JvdW5kQ29sb3IsIGRhdGEuaW50ZW5zaXR5ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnU2tpbm5lZE1lc2gnOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlci5wYXJzZU9iamVjdCgpIGRvZXMgbm90IHN1cHBvcnQgU2tpbm5lZE1lc2ggeWV0LicgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdNZXNoJzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgZ2VvbWV0cnkgPSBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBtYXRlcmlhbCA9IGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5ib25lcyAmJiBnZW9tZXRyeS5ib25lcy5sZW5ndGggPiAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdCA9IG5ldyBTa2lubmVkTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRvYmplY3QgPSBuZXcgTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ0xPRCc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0ID0gbmV3IExPRCgpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ0xpbmUnOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdCA9IG5ldyBMaW5lKCBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApLCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApLCBkYXRhLm1vZGUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdMaW5lTG9vcCc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0ID0gbmV3IExpbmVMb29wKCBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApLCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnTGluZVNlZ21lbnRzJzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRvYmplY3QgPSBuZXcgTGluZVNlZ21lbnRzKCBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApLCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnUG9pbnRDbG91ZCc6XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnUG9pbnRzJzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRvYmplY3QgPSBuZXcgUG9pbnRzKCBnZXRHZW9tZXRyeSggZGF0YS5nZW9tZXRyeSApLCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnU3ByaXRlJzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRvYmplY3QgPSBuZXcgU3ByaXRlKCBnZXRNYXRlcmlhbCggZGF0YS5tYXRlcmlhbCApICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnR3JvdXAnOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdCA9IG5ldyBHcm91cCgpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdGRlZmF1bHQ6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0ID0gbmV3IE9iamVjdDNEKCk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdG9iamVjdC51dWlkID0gZGF0YS51dWlkO1xcblxcblxcdFxcdFxcdFxcdGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSBvYmplY3QubmFtZSA9IGRhdGEubmFtZTtcXG5cXHRcXHRcXHRcXHRpZiAoIGRhdGEubWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bWF0cml4LmZyb21BcnJheSggZGF0YS5tYXRyaXggKTtcXG5cXHRcXHRcXHRcXHRcXHRtYXRyaXguZGVjb21wb3NlKCBvYmplY3QucG9zaXRpb24sIG9iamVjdC5xdWF0ZXJuaW9uLCBvYmplY3Quc2NhbGUgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS5wb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnBvc2l0aW9uLmZyb21BcnJheSggZGF0YS5wb3NpdGlvbiApO1xcblxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnJvdGF0aW9uLmZyb21BcnJheSggZGF0YS5yb3RhdGlvbiApO1xcblxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS5xdWF0ZXJuaW9uICE9PSB1bmRlZmluZWQgKSBvYmplY3QucXVhdGVybmlvbi5mcm9tQXJyYXkoIGRhdGEucXVhdGVybmlvbiApO1xcblxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS5zY2FsZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnNjYWxlLmZyb21BcnJheSggZGF0YS5zY2FsZSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGRhdGEuY2FzdFNoYWRvdyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmNhc3RTaGFkb3cgPSBkYXRhLmNhc3RTaGFkb3c7XFxuXFx0XFx0XFx0XFx0aWYgKCBkYXRhLnJlY2VpdmVTaGFkb3cgIT09IHVuZGVmaW5lZCApIG9iamVjdC5yZWNlaXZlU2hhZG93ID0gZGF0YS5yZWNlaXZlU2hhZG93O1xcblxcblxcdFxcdFxcdFxcdGlmICggZGF0YS5zaGFkb3cgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLnNoYWRvdy5iaWFzICE9PSB1bmRlZmluZWQgKSBvYmplY3Quc2hhZG93LmJpYXMgPSBkYXRhLnNoYWRvdy5iaWFzO1xcblxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS5zaGFkb3cucmFkaXVzICE9PSB1bmRlZmluZWQgKSBvYmplY3Quc2hhZG93LnJhZGl1cyA9IGRhdGEuc2hhZG93LnJhZGl1cztcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEuc2hhZG93Lm1hcFNpemUgIT09IHVuZGVmaW5lZCApIG9iamVjdC5zaGFkb3cubWFwU2l6ZS5mcm9tQXJyYXkoIGRhdGEuc2hhZG93Lm1hcFNpemUgKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEuc2hhZG93LmNhbWVyYSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnNoYWRvdy5jYW1lcmEgPSB0aGlzLnBhcnNlT2JqZWN0KCBkYXRhLnNoYWRvdy5jYW1lcmEgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBkYXRhLnZpc2libGUgIT09IHVuZGVmaW5lZCApIG9iamVjdC52aXNpYmxlID0gZGF0YS52aXNpYmxlO1xcblxcdFxcdFxcdFxcdGlmICggZGF0YS51c2VyRGF0YSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnVzZXJEYXRhID0gZGF0YS51c2VyRGF0YTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGRhdGEuY2hpbGRyZW4gIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgY2hpbGRyZW4gPSBkYXRhLmNoaWxkcmVuO1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRvYmplY3QuYWRkKCB0aGlzLnBhcnNlT2JqZWN0KCBjaGlsZHJlblsgaSBdLCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMgKSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBkYXRhLnR5cGUgPT09ICdMT0QnICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBsZXZlbHMgPSBkYXRhLmxldmVscztcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgbCA9IDA7IGwgPCBsZXZlbHMubGVuZ3RoOyBsICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBsZXZlbCA9IGxldmVsc1sgbCBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBjaGlsZCA9IG9iamVjdC5nZXRPYmplY3RCeVByb3BlcnR5KCAndXVpZCcsIGxldmVsLm9iamVjdCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggY2hpbGQgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRvYmplY3QuYWRkTGV2ZWwoIGNoaWxkLCBsZXZlbC5kaXN0YW5jZSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiBvYmplY3Q7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KClcXG5cXG5cXHR9ICk7XFxuXFxuXFx0dmFyIFRFWFRVUkVfTUFQUElORyA9IHtcXG5cXHRcXHRVVk1hcHBpbmc6IFVWTWFwcGluZyxcXG5cXHRcXHRDdWJlUmVmbGVjdGlvbk1hcHBpbmc6IEN1YmVSZWZsZWN0aW9uTWFwcGluZyxcXG5cXHRcXHRDdWJlUmVmcmFjdGlvbk1hcHBpbmc6IEN1YmVSZWZyYWN0aW9uTWFwcGluZyxcXG5cXHRcXHRFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZzogRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcsXFxuXFx0XFx0RXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmc6IEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nLFxcblxcdFxcdFNwaGVyaWNhbFJlZmxlY3Rpb25NYXBwaW5nOiBTcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZyxcXG5cXHRcXHRDdWJlVVZSZWZsZWN0aW9uTWFwcGluZzogQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmcsXFxuXFx0XFx0Q3ViZVVWUmVmcmFjdGlvbk1hcHBpbmc6IEN1YmVVVlJlZnJhY3Rpb25NYXBwaW5nXFxuXFx0fTtcXG5cXG5cXHR2YXIgVEVYVFVSRV9XUkFQUElORyA9IHtcXG5cXHRcXHRSZXBlYXRXcmFwcGluZzogUmVwZWF0V3JhcHBpbmcsXFxuXFx0XFx0Q2xhbXBUb0VkZ2VXcmFwcGluZzogQ2xhbXBUb0VkZ2VXcmFwcGluZyxcXG5cXHRcXHRNaXJyb3JlZFJlcGVhdFdyYXBwaW5nOiBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nXFxuXFx0fTtcXG5cXG5cXHR2YXIgVEVYVFVSRV9GSUxURVIgPSB7XFxuXFx0XFx0TmVhcmVzdEZpbHRlcjogTmVhcmVzdEZpbHRlcixcXG5cXHRcXHROZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlcjogTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIsXFxuXFx0XFx0TmVhcmVzdE1pcE1hcExpbmVhckZpbHRlcjogTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlcixcXG5cXHRcXHRMaW5lYXJGaWx0ZXI6IExpbmVhckZpbHRlcixcXG5cXHRcXHRMaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyOiBMaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyLFxcblxcdFxcdExpbmVhck1pcE1hcExpbmVhckZpbHRlcjogTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIHRoZXNwaXRlIC8gaHR0cDovL2NsaWNrdG9yZWxlYXNlLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBJbWFnZUJpdG1hcExvYWRlciggbWFuYWdlciApIHtcXG5cXG5cXHRcXHRpZiAoIHR5cGVvZiBjcmVhdGVJbWFnZUJpdG1hcCA9PT0gJ3VuZGVmaW5lZCcgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW1hZ2VCaXRtYXBMb2FkZXI6IGNyZWF0ZUltYWdlQml0bWFwKCkgbm90IHN1cHBvcnRlZC4nICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggdHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJyApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5JbWFnZUJpdG1hcExvYWRlcjogZmV0Y2goKSBub3Qgc3VwcG9ydGVkLicgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5tYW5hZ2VyID0gbWFuYWdlciAhPT0gdW5kZWZpbmVkID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcXG5cXHRcXHR0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XFxuXFxuXFx0fVxcblxcblxcdEltYWdlQml0bWFwTG9hZGVyLnByb3RvdHlwZSA9IHtcXG5cXG5cXHRcXHRjb25zdHJ1Y3RvcjogSW1hZ2VCaXRtYXBMb2FkZXIsXFxuXFxuXFx0XFx0c2V0T3B0aW9uczogZnVuY3Rpb24gc2V0T3B0aW9ucyggb3B0aW9ucyApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bG9hZDogZnVuY3Rpb24gbG9hZCggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB1cmwgPT09IHVuZGVmaW5lZCApIHVybCA9ICcnO1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5wYXRoICE9PSB1bmRlZmluZWQgKSB1cmwgPSB0aGlzLnBhdGggKyB1cmw7XFxuXFxuXFx0XFx0XFx0dmFyIHNjb3BlID0gdGhpcztcXG5cXG5cXHRcXHRcXHR2YXIgY2FjaGVkID0gQ2FjaGUuZ2V0KCB1cmwgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGNhY2hlZCAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcXG5cXG5cXHRcXHRcXHRcXHRzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIGNhY2hlZCApO1xcblxcblxcdFxcdFxcdFxcdFxcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XFxuXFxuXFx0XFx0XFx0XFx0fSwgMCApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBjYWNoZWQ7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGZldGNoKCB1cmwgKS50aGVuKCBmdW5jdGlvbiAoIHJlcyApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmVzLmJsb2IoKTtcXG5cXG5cXHRcXHRcXHR9ICkudGhlbiggZnVuY3Rpb24gKCBibG9iICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBjcmVhdGVJbWFnZUJpdG1hcCggYmxvYiwgc2NvcGUub3B0aW9ucyApO1xcblxcblxcdFxcdFxcdH0gKS50aGVuKCBmdW5jdGlvbiAoIGltYWdlQml0bWFwICkge1xcblxcblxcdFxcdFxcdFxcdENhY2hlLmFkZCggdXJsLCBpbWFnZUJpdG1hcCApO1xcblxcblxcdFxcdFxcdFxcdGlmICggb25Mb2FkICkgb25Mb2FkKCBpbWFnZUJpdG1hcCApO1xcblxcblxcdFxcdFxcdFxcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XFxuXFxuXFx0XFx0XFx0fSApLmNhdGNoKCBmdW5jdGlvbiAoIGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggZSApO1xcblxcblxcdFxcdFxcdFxcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XFxuXFx0XFx0XFx0XFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xcblxcblxcdFxcdFxcdH0gKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIC8qIHZhbHVlICovICkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0UGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnBhdGggPSB2YWx1ZTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXFxuXFx0ICogbWluaW1hbCBjbGFzcyBmb3IgcHJveGluZyBmdW5jdGlvbnMgdG8gUGF0aC4gUmVwbGFjZXMgb2xkIFxcXCJleHRyYWN0U3VicGF0aHMoKVxcXCJcXG5cXHQgKiovXFxuXFxuXFx0ZnVuY3Rpb24gU2hhcGVQYXRoKCkge1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdTaGFwZVBhdGgnO1xcblxcblxcdFxcdHRoaXMuc3ViUGF0aHMgPSBbXTtcXG5cXHRcXHR0aGlzLmN1cnJlbnRQYXRoID0gbnVsbDtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggU2hhcGVQYXRoLnByb3RvdHlwZSwge1xcblxcblxcdFxcdG1vdmVUbzogZnVuY3Rpb24gKCB4LCB5ICkge1xcblxcblxcdFxcdFxcdHRoaXMuY3VycmVudFBhdGggPSBuZXcgUGF0aCgpO1xcblxcdFxcdFxcdHRoaXMuc3ViUGF0aHMucHVzaCggdGhpcy5jdXJyZW50UGF0aCApO1xcblxcdFxcdFxcdHRoaXMuY3VycmVudFBhdGgubW92ZVRvKCB4LCB5ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRsaW5lVG86IGZ1bmN0aW9uICggeCwgeSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmN1cnJlbnRQYXRoLmxpbmVUbyggeCwgeSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cXVhZHJhdGljQ3VydmVUbzogZnVuY3Rpb24gKCBhQ1B4LCBhQ1B5LCBhWCwgYVkgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5jdXJyZW50UGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKCBhQ1B4LCBhQ1B5LCBhWCwgYVkgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGJlemllckN1cnZlVG86IGZ1bmN0aW9uICggYUNQMXgsIGFDUDF5LCBhQ1AyeCwgYUNQMnksIGFYLCBhWSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmN1cnJlbnRQYXRoLmJlemllckN1cnZlVG8oIGFDUDF4LCBhQ1AxeSwgYUNQMngsIGFDUDJ5LCBhWCwgYVkgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNwbGluZVRocnU6IGZ1bmN0aW9uICggcHRzICkge1xcblxcblxcdFxcdFxcdHRoaXMuY3VycmVudFBhdGguc3BsaW5lVGhydSggcHRzICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0b1NoYXBlczogZnVuY3Rpb24gKCBpc0NDVywgbm9Ib2xlcyApIHtcXG5cXG5cXHRcXHRcXHRmdW5jdGlvbiB0b1NoYXBlc05vSG9sZXMoIGluU3VicGF0aHMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHNoYXBlcyA9IFtdO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGluU3VicGF0aHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgdG1wUGF0aCA9IGluU3VicGF0aHNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgdG1wU2hhcGUgPSBuZXcgU2hhcGUoKTtcXG5cXHRcXHRcXHRcXHRcXHR0bXBTaGFwZS5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcXG5cXG5cXHRcXHRcXHRcXHRcXHRzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHNoYXBlcztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gaXNQb2ludEluc2lkZVBvbHlnb24oIGluUHQsIGluUG9seWdvbiApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcG9seUxlbiA9IGluUG9seWdvbi5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gaW5QdCBvbiBwb2x5Z29uIGNvbnRvdXIgPT4gaW1tZWRpYXRlIHN1Y2Nlc3MgICAgb3JcXG5cXHRcXHRcXHRcXHQvLyB0b2dnbGluZyBvZiBpbnNpZGUvb3V0c2lkZSBhdCBldmVyeSBzaW5nbGUhIGludGVyc2VjdGlvbiBwb2ludCBvZiBhbiBlZGdlXFxuXFx0XFx0XFx0XFx0Ly8gIHdpdGggdGhlIGhvcml6b250YWwgbGluZSB0aHJvdWdoIGluUHQsIGxlZnQgb2YgaW5QdFxcblxcdFxcdFxcdFxcdC8vICBub3QgY291bnRpbmcgbG93ZXJZIGVuZHBvaW50cyBvZiBlZGdlcyBhbmQgd2hvbGUgZWRnZXMgb24gdGhhdCBsaW5lXFxuXFx0XFx0XFx0XFx0dmFyIGluc2lkZSA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdGZvciAoIHZhciBwID0gcG9seUxlbiAtIDEsIHEgPSAwOyBxIDwgcG9seUxlbjsgcCA9IHEgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGVkZ2VMb3dQdCA9IGluUG9seWdvblsgcCBdO1xcblxcdFxcdFxcdFxcdFxcdHZhciBlZGdlSGlnaFB0ID0gaW5Qb2x5Z29uWyBxIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGVkZ2VEeCA9IGVkZ2VIaWdoUHQueCAtIGVkZ2VMb3dQdC54O1xcblxcdFxcdFxcdFxcdFxcdHZhciBlZGdlRHkgPSBlZGdlSGlnaFB0LnkgLSBlZGdlTG93UHQueTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIE1hdGguYWJzKCBlZGdlRHkgKSA+IE51bWJlci5FUFNJTE9OICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIG5vdCBwYXJhbGxlbFxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggZWRnZUR5IDwgMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRlZGdlTG93UHQgPSBpblBvbHlnb25bIHEgXTsgZWRnZUR4ID0gLSBlZGdlRHg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZWRnZUhpZ2hQdCA9IGluUG9seWdvblsgcCBdOyBlZGdlRHkgPSAtIGVkZ2VEeTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCAoIGluUHQueSA8IGVkZ2VMb3dQdC55ICkgfHwgKCBpblB0LnkgPiBlZGdlSGlnaFB0LnkgKSApIFxcdFxcdGNvbnRpbnVlO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggaW5QdC55ID09PSBlZGdlTG93UHQueSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGluUHQueCA9PT0gZWRnZUxvd1B0LnggKVxcdFxcdHJldHVyblxcdHRydWU7XFx0XFx0Ly8gaW5QdCBpcyBvbiBjb250b3VyID9cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBjb250aW51ZTtcXHRcXHRcXHRcXHQvLyBubyBpbnRlcnNlY3Rpb24gb3IgZWRnZUxvd1B0ID0+IGRvZXNuJ3QgY291bnQgISEhXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgcGVycEVkZ2UgPSBlZGdlRHkgKiAoIGluUHQueCAtIGVkZ2VMb3dQdC54ICkgLSBlZGdlRHggKiAoIGluUHQueSAtIGVkZ2VMb3dQdC55ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBwZXJwRWRnZSA9PT0gMCApXFx0XFx0XFx0XFx0cmV0dXJuXFx0dHJ1ZTtcXHRcXHQvLyBpblB0IGlzIG9uIGNvbnRvdXIgP1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggcGVycEVkZ2UgPCAwICkgXFx0XFx0XFx0XFx0Y29udGludWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aW5zaWRlID0gISBpbnNpZGU7XFx0XFx0Ly8gdHJ1ZSBpbnRlcnNlY3Rpb24gbGVmdCBvZiBpblB0XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gcGFyYWxsZWwgb3IgY29sbGluZWFyXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBpblB0LnkgIT09IGVkZ2VMb3dQdC55ICkgXFx0XFx0Y29udGludWU7XFx0XFx0XFx0Ly8gcGFyYWxsZWxcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBlZGdlIGxpZXMgb24gdGhlIHNhbWUgaG9yaXpvbnRhbCBsaW5lIGFzIGluUHRcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoICggKCBlZGdlSGlnaFB0LnggPD0gaW5QdC54ICkgJiYgKCBpblB0LnggPD0gZWRnZUxvd1B0LnggKSApIHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ICggKCBlZGdlTG93UHQueCA8PSBpblB0LnggKSAmJiAoIGluUHQueCA8PSBlZGdlSGlnaFB0LnggKSApIClcXHRcXHRyZXR1cm5cXHR0cnVlO1xcdC8vIGluUHQ6IFBvaW50IG9uIGNvbnRvdXIgIVxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGNvbnRpbnVlO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuXFx0aW5zaWRlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgaXNDbG9ja1dpc2UgPSBTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlO1xcblxcblxcdFxcdFxcdHZhciBzdWJQYXRocyA9IHRoaXMuc3ViUGF0aHM7XFxuXFx0XFx0XFx0aWYgKCBzdWJQYXRocy5sZW5ndGggPT09IDAgKSByZXR1cm4gW107XFxuXFxuXFx0XFx0XFx0aWYgKCBub0hvbGVzID09PSB0cnVlIClcXHRyZXR1cm5cXHR0b1NoYXBlc05vSG9sZXMoIHN1YlBhdGhzICk7XFxuXFxuXFxuXFx0XFx0XFx0dmFyIHNvbGlkLCB0bXBQYXRoLCB0bXBTaGFwZSwgc2hhcGVzID0gW107XFxuXFxuXFx0XFx0XFx0aWYgKCBzdWJQYXRocy5sZW5ndGggPT09IDEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dG1wUGF0aCA9IHN1YlBhdGhzWyAwIF07XFxuXFx0XFx0XFx0XFx0dG1wU2hhcGUgPSBuZXcgU2hhcGUoKTtcXG5cXHRcXHRcXHRcXHR0bXBTaGFwZS5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcXG5cXHRcXHRcXHRcXHRzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gc2hhcGVzO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgaG9sZXNGaXJzdCA9ICEgaXNDbG9ja1dpc2UoIHN1YlBhdGhzWyAwIF0uZ2V0UG9pbnRzKCkgKTtcXG5cXHRcXHRcXHRob2xlc0ZpcnN0ID0gaXNDQ1cgPyAhIGhvbGVzRmlyc3QgOiBob2xlc0ZpcnN0O1xcblxcblxcdFxcdFxcdC8vIGNvbnNvbGUubG9nKFxcXCJIb2xlcyBmaXJzdFxcXCIsIGhvbGVzRmlyc3QpO1xcblxcblxcdFxcdFxcdHZhciBiZXR0ZXJTaGFwZUhvbGVzID0gW107XFxuXFx0XFx0XFx0dmFyIG5ld1NoYXBlcyA9IFtdO1xcblxcdFxcdFxcdHZhciBuZXdTaGFwZUhvbGVzID0gW107XFxuXFx0XFx0XFx0dmFyIG1haW5JZHggPSAwO1xcblxcdFxcdFxcdHZhciB0bXBQb2ludHM7XFxuXFxuXFx0XFx0XFx0bmV3U2hhcGVzWyBtYWluSWR4IF0gPSB1bmRlZmluZWQ7XFxuXFx0XFx0XFx0bmV3U2hhcGVIb2xlc1sgbWFpbklkeCBdID0gW107XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gc3ViUGF0aHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR0bXBQYXRoID0gc3ViUGF0aHNbIGkgXTtcXG5cXHRcXHRcXHRcXHR0bXBQb2ludHMgPSB0bXBQYXRoLmdldFBvaW50cygpO1xcblxcdFxcdFxcdFxcdHNvbGlkID0gaXNDbG9ja1dpc2UoIHRtcFBvaW50cyApO1xcblxcdFxcdFxcdFxcdHNvbGlkID0gaXNDQ1cgPyAhIHNvbGlkIDogc29saWQ7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBzb2xpZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoICggISBob2xlc0ZpcnN0ICkgJiYgKCBuZXdTaGFwZXNbIG1haW5JZHggXSApIClcXHRtYWluSWR4ICsrO1xcblxcblxcdFxcdFxcdFxcdFxcdG5ld1NoYXBlc1sgbWFpbklkeCBdID0geyBzOiBuZXcgU2hhcGUoKSwgcDogdG1wUG9pbnRzIH07XFxuXFx0XFx0XFx0XFx0XFx0bmV3U2hhcGVzWyBtYWluSWR4IF0ucy5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGhvbGVzRmlyc3QgKVxcdG1haW5JZHggKys7XFxuXFx0XFx0XFx0XFx0XFx0bmV3U2hhcGVIb2xlc1sgbWFpbklkeCBdID0gW107XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly9jb25zb2xlLmxvZygnY3cnLCBpKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdG5ld1NoYXBlSG9sZXNbIG1haW5JZHggXS5wdXNoKCB7IGg6IHRtcFBhdGgsIHA6IHRtcFBvaW50c1sgMCBdIH0gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvL2NvbnNvbGUubG9nKCdjY3cnLCBpKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIG9ubHkgSG9sZXM/IC0+IHByb2JhYmx5IGFsbCBTaGFwZXMgd2l0aCB3cm9uZyBvcmllbnRhdGlvblxcblxcdFxcdFxcdGlmICggISBuZXdTaGFwZXNbIDAgXSApXFx0cmV0dXJuXFx0dG9TaGFwZXNOb0hvbGVzKCBzdWJQYXRocyApO1xcblxcblxcblxcdFxcdFxcdGlmICggbmV3U2hhcGVzLmxlbmd0aCA+IDEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGFtYmlndW91cyA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdHZhciB0b0NoYW5nZSA9IFtdO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBzSWR4ID0gMCwgc0xlbiA9IG5ld1NoYXBlcy5sZW5ndGg7IHNJZHggPCBzTGVuOyBzSWR4ICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGJldHRlclNoYXBlSG9sZXNbIHNJZHggXSA9IFtdO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgc0lkeCA9IDAsIHNMZW4gPSBuZXdTaGFwZXMubGVuZ3RoOyBzSWR4IDwgc0xlbjsgc0lkeCArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgc2hvID0gbmV3U2hhcGVIb2xlc1sgc0lkeCBdO1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBoSWR4ID0gMDsgaElkeCA8IHNoby5sZW5ndGg7IGhJZHggKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGhvID0gc2hvWyBoSWR4IF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGhvbGVfdW5hc3NpZ25lZCA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIHMySWR4ID0gMDsgczJJZHggPCBuZXdTaGFwZXMubGVuZ3RoOyBzMklkeCArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGlzUG9pbnRJbnNpZGVQb2x5Z29uKCBoby5wLCBuZXdTaGFwZXNbIHMySWR4IF0ucCApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggc0lkeCAhPT0gczJJZHggKVxcdHRvQ2hhbmdlLnB1c2goIHsgZnJvbXM6IHNJZHgsIHRvczogczJJZHgsIGhvbGU6IGhJZHggfSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggaG9sZV91bmFzc2lnbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGhvbGVfdW5hc3NpZ25lZCA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJldHRlclNoYXBlSG9sZXNbIHMySWR4IF0ucHVzaCggaG8gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGFtYmlndW91cyA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBob2xlX3VuYXNzaWduZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YmV0dGVyU2hhcGVIb2xlc1sgc0lkeCBdLnB1c2goIGhvICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Ly8gY29uc29sZS5sb2coXFxcImFtYmlndW91czogXFxcIiwgYW1iaWd1b3VzKTtcXG5cXHRcXHRcXHRcXHRpZiAoIHRvQ2hhbmdlLmxlbmd0aCA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gY29uc29sZS5sb2coXFxcInRvIGNoYW5nZTogXFxcIiwgdG9DaGFuZ2UpO1xcblxcdFxcdFxcdFxcdFxcdGlmICggISBhbWJpZ3VvdXMgKVxcdG5ld1NoYXBlSG9sZXMgPSBiZXR0ZXJTaGFwZUhvbGVzO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIHRtcEhvbGVzO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSBuZXdTaGFwZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dG1wU2hhcGUgPSBuZXdTaGFwZXNbIGkgXS5zO1xcblxcdFxcdFxcdFxcdHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xcblxcdFxcdFxcdFxcdHRtcEhvbGVzID0gbmV3U2hhcGVIb2xlc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBqID0gMCwgamwgPSB0bXBIb2xlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0bXBTaGFwZS5ob2xlcy5wdXNoKCB0bXBIb2xlc1sgaiBdLmggKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vY29uc29sZS5sb2coXFxcInNoYXBlXFxcIiwgc2hhcGVzKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gc2hhcGVzO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gRm9udCggZGF0YSApIHtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnRm9udCc7XFxuXFxuXFx0XFx0dGhpcy5kYXRhID0gZGF0YTtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggRm9udC5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRpc0ZvbnQ6IHRydWUsXFxuXFxuXFx0XFx0Z2VuZXJhdGVTaGFwZXM6IGZ1bmN0aW9uICggdGV4dCwgc2l6ZSwgZGl2aXNpb25zICkge1xcblxcblxcdFxcdFxcdGZ1bmN0aW9uIGNyZWF0ZVBhdGhzKCB0ZXh0ICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBjaGFycyA9IFN0cmluZyggdGV4dCApLnNwbGl0KCAnJyApO1xcblxcdFxcdFxcdFxcdHZhciBzY2FsZSA9IHNpemUgLyBkYXRhLnJlc29sdXRpb247XFxuXFx0XFx0XFx0XFx0dmFyIGxpbmVfaGVpZ2h0ID0gKCBkYXRhLmJvdW5kaW5nQm94LnlNYXggLSBkYXRhLmJvdW5kaW5nQm94LnlNaW4gKyBkYXRhLnVuZGVybGluZVRoaWNrbmVzcyApICogc2NhbGU7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG9mZnNldFggPSAwLCBvZmZzZXRZID0gMDtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcGF0aHMgPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGNoYXIgPSBjaGFyc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggY2hhciA9PT0gJ1xcXFxuJyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRvZmZzZXRYID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRvZmZzZXRZIC09IGxpbmVfaGVpZ2h0O1xcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHJldCA9IGNyZWF0ZVBhdGgoIGNoYXIsIHNjYWxlLCBvZmZzZXRYLCBvZmZzZXRZICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0b2Zmc2V0WCArPSByZXQub2Zmc2V0WDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwYXRocy5wdXNoKCByZXQucGF0aCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHBhdGhzO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmdW5jdGlvbiBjcmVhdGVQYXRoKCBjLCBzY2FsZSwgb2Zmc2V0WCwgb2Zmc2V0WSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZ2x5cGggPSBkYXRhLmdseXBoc1sgYyBdIHx8IGRhdGEuZ2x5cGhzWyAnPycgXTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoICEgZ2x5cGggKSByZXR1cm47XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHBhdGggPSBuZXcgU2hhcGVQYXRoKCk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHB0cyA9IFtdO1xcblxcdFxcdFxcdFxcdHZhciB4LCB5LCBjcHgsIGNweSwgY3B4MCwgY3B5MCwgY3B4MSwgY3B5MSwgY3B4MiwgY3B5MiwgbGFzdGU7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBnbHlwaC5vICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBvdXRsaW5lID0gZ2x5cGguX2NhY2hlZE91dGxpbmUgfHwgKCBnbHlwaC5fY2FjaGVkT3V0bGluZSA9IGdseXBoLm8uc3BsaXQoICcgJyApICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gb3V0bGluZS5sZW5ndGg7IGkgPCBsOyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgYWN0aW9uID0gb3V0bGluZVsgaSArKyBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHN3aXRjaCAoIGFjdGlvbiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtJzogLy8gbW92ZVRvXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0eCA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0WDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR5ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRZO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHBhdGgubW92ZVRvKCB4LCB5ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbCc6IC8vIGxpbmVUb1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHggPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldFg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0eSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0WTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwYXRoLmxpbmVUbyggeCwgeSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ3EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y3B4ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRYO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNweSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0WTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjcHgxID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRYO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNweTEgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldFk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKCBjcHgxLCBjcHkxLCBjcHgsIGNweSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGxhc3RlID0gcHRzWyBwdHMubGVuZ3RoIC0gMSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggbGFzdGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y3B4MCA9IGxhc3RlLng7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y3B5MCA9IGxhc3RlLnk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ2InOiAvLyBiZXppZXJDdXJ2ZVRvXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y3B4ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRYO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNweSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0WTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjcHgxID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRYO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNweTEgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldFk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y3B4MiA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0WDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjcHkyID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRZO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHBhdGguYmV6aWVyQ3VydmVUbyggY3B4MSwgY3B5MSwgY3B4MiwgY3B5MiwgY3B4LCBjcHkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRsYXN0ZSA9IHB0c1sgcHRzLmxlbmd0aCAtIDEgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGxhc3RlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNweDAgPSBsYXN0ZS54O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNweTAgPSBsYXN0ZS55O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4geyBvZmZzZXRYOiBnbHlwaC5oYSAqIHNjYWxlLCBwYXRoOiBwYXRoIH07XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vXFxuXFxuXFx0XFx0XFx0aWYgKCBzaXplID09PSB1bmRlZmluZWQgKSBzaXplID0gMTAwO1xcblxcdFxcdFxcdGlmICggZGl2aXNpb25zID09PSB1bmRlZmluZWQgKSBkaXZpc2lvbnMgPSA0O1xcblxcblxcdFxcdFxcdHZhciBkYXRhID0gdGhpcy5kYXRhO1xcblxcblxcdFxcdFxcdHZhciBwYXRocyA9IGNyZWF0ZVBhdGhzKCB0ZXh0ICk7XFxuXFx0XFx0XFx0dmFyIHNoYXBlcyA9IFtdO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBwID0gMCwgcGwgPSBwYXRocy5sZW5ndGg7IHAgPCBwbDsgcCArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSggc2hhcGVzLCBwYXRoc1sgcCBdLnRvU2hhcGVzKCkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHNoYXBlcztcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gRm9udExvYWRlciggbWFuYWdlciApIHtcXG5cXG5cXHRcXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggRm9udExvYWRlci5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xcblxcblxcdFxcdFxcdHZhciBzY29wZSA9IHRoaXM7XFxuXFxuXFx0XFx0XFx0dmFyIGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcXG5cXHRcXHRcXHRsb2FkZXIuc2V0UGF0aCggdGhpcy5wYXRoICk7XFxuXFx0XFx0XFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBqc29uO1xcblxcblxcdFxcdFxcdFxcdHRyeSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0anNvbiA9IEpTT04ucGFyc2UoIHRleHQgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGNhdGNoICggZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5Gb250TG9hZGVyOiB0eXBlZmFjZS5qcyBzdXBwb3J0IGlzIGJlaW5nIGRlcHJlY2F0ZWQuIFVzZSB0eXBlZmFjZS5qc29uIGluc3RlYWQuJyApO1xcblxcdFxcdFxcdFxcdFxcdGpzb24gPSBKU09OLnBhcnNlKCB0ZXh0LnN1YnN0cmluZyggNjUsIHRleHQubGVuZ3RoIC0gMiApICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHZhciBmb250ID0gc2NvcGUucGFyc2UoIGpzb24gKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG9uTG9hZCApIG9uTG9hZCggZm9udCApO1xcblxcblxcdFxcdFxcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHBhcnNlOiBmdW5jdGlvbiAoIGpzb24gKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyBGb250KCBqc29uICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdHRoaXMucGF0aCA9IHZhbHVlO1xcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHR2YXIgY29udGV4dDtcXG5cXG5cXHR2YXIgQXVkaW9Db250ZXh0ID0ge1xcblxcblxcdFxcdGdldENvbnRleHQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGNvbnRleHQgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb250ZXh0ID0gbmV3ICggd2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0ICkoKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGNvbnRleHQ7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRDb250ZXh0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdGNvbnRleHQgPSB2YWx1ZTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIFJlZWNlIEFhcm9uIExlY3JpdmFpbiAvIGh0dHA6Ly9yZWVjZW5vdGVzLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBBdWRpb0xvYWRlciggbWFuYWdlciApIHtcXG5cXG5cXHRcXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggQXVkaW9Mb2FkZXIucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcXG5cXG5cXHRcXHRcXHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xcblxcdFxcdFxcdGxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcXG5cXHRcXHRcXHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgY29udGV4dCA9IEF1ZGlvQ29udGV4dC5nZXRDb250ZXh0KCk7XFxuXFxuXFx0XFx0XFx0XFx0Y29udGV4dC5kZWNvZGVBdWRpb0RhdGEoIGJ1ZmZlciwgZnVuY3Rpb24gKCBhdWRpb0J1ZmZlciApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRvbkxvYWQoIGF1ZGlvQnVmZmVyICk7XFxuXFxuXFx0XFx0XFx0XFx0fSApO1xcblxcblxcdFxcdFxcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gU3RlcmVvQ2FtZXJhKCkge1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdTdGVyZW9DYW1lcmEnO1xcblxcblxcdFxcdHRoaXMuYXNwZWN0ID0gMTtcXG5cXG5cXHRcXHR0aGlzLmV5ZVNlcCA9IDAuMDY0O1xcblxcblxcdFxcdHRoaXMuY2FtZXJhTCA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSgpO1xcblxcdFxcdHRoaXMuY2FtZXJhTC5sYXllcnMuZW5hYmxlKCAxICk7XFxuXFx0XFx0dGhpcy5jYW1lcmFMLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcXG5cXG5cXHRcXHR0aGlzLmNhbWVyYVIgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoKTtcXG5cXHRcXHR0aGlzLmNhbWVyYVIubGF5ZXJzLmVuYWJsZSggMiApO1xcblxcdFxcdHRoaXMuY2FtZXJhUi5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5hc3NpZ24oIFN0ZXJlb0NhbWVyYS5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHR1cGRhdGU6ICggZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBpbnN0YW5jZSwgZm9jdXMsIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIsIHpvb20sIGV5ZVNlcDtcXG5cXG5cXHRcXHRcXHR2YXIgZXllUmlnaHQgPSBuZXcgTWF0cml4NCgpO1xcblxcdFxcdFxcdHZhciBleWVMZWZ0ID0gbmV3IE1hdHJpeDQoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCBjYW1lcmEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG5lZWRzVXBkYXRlID0gaW5zdGFuY2UgIT09IHRoaXMgfHwgZm9jdXMgIT09IGNhbWVyYS5mb2N1cyB8fCBmb3YgIT09IGNhbWVyYS5mb3YgfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRhc3BlY3QgIT09IGNhbWVyYS5hc3BlY3QgKiB0aGlzLmFzcGVjdCB8fCBuZWFyICE9PSBjYW1lcmEubmVhciB8fFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGZhciAhPT0gY2FtZXJhLmZhciB8fCB6b29tICE9PSBjYW1lcmEuem9vbSB8fCBleWVTZXAgIT09IHRoaXMuZXllU2VwO1xcblxcblxcdFxcdFxcdFxcdGlmICggbmVlZHNVcGRhdGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aW5zdGFuY2UgPSB0aGlzO1xcblxcdFxcdFxcdFxcdFxcdGZvY3VzID0gY2FtZXJhLmZvY3VzO1xcblxcdFxcdFxcdFxcdFxcdGZvdiA9IGNhbWVyYS5mb3Y7XFxuXFx0XFx0XFx0XFx0XFx0YXNwZWN0ID0gY2FtZXJhLmFzcGVjdCAqIHRoaXMuYXNwZWN0O1xcblxcdFxcdFxcdFxcdFxcdG5lYXIgPSBjYW1lcmEubmVhcjtcXG5cXHRcXHRcXHRcXHRcXHRmYXIgPSBjYW1lcmEuZmFyO1xcblxcdFxcdFxcdFxcdFxcdHpvb20gPSBjYW1lcmEuem9vbTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBPZmYtYXhpcyBzdGVyZW9zY29waWMgZWZmZWN0IGJhc2VkIG9uXFxuXFx0XFx0XFx0XFx0XFx0Ly8gaHR0cDovL3BhdWxib3Vya2UubmV0L3N0ZXJlb2dyYXBoaWNzL3N0ZXJlb3JlbmRlci9cXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgcHJvamVjdGlvbk1hdHJpeCA9IGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmNsb25lKCk7XFxuXFx0XFx0XFx0XFx0XFx0ZXllU2VwID0gdGhpcy5leWVTZXAgLyAyO1xcblxcdFxcdFxcdFxcdFxcdHZhciBleWVTZXBPblByb2plY3Rpb24gPSBleWVTZXAgKiBuZWFyIC8gZm9jdXM7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHltYXggPSAoIG5lYXIgKiBNYXRoLnRhbiggX01hdGguREVHMlJBRCAqIGZvdiAqIDAuNSApICkgLyB6b29tO1xcblxcdFxcdFxcdFxcdFxcdHZhciB4bWluLCB4bWF4O1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIHRyYW5zbGF0ZSB4T2Zmc2V0XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZXllTGVmdC5lbGVtZW50c1sgMTIgXSA9IC0gZXllU2VwO1xcblxcdFxcdFxcdFxcdFxcdGV5ZVJpZ2h0LmVsZW1lbnRzWyAxMiBdID0gZXllU2VwO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGZvciBsZWZ0IGV5ZVxcblxcblxcdFxcdFxcdFxcdFxcdHhtaW4gPSAtIHltYXggKiBhc3BlY3QgKyBleWVTZXBPblByb2plY3Rpb247XFxuXFx0XFx0XFx0XFx0XFx0eG1heCA9IHltYXggKiBhc3BlY3QgKyBleWVTZXBPblByb2plY3Rpb247XFxuXFxuXFx0XFx0XFx0XFx0XFx0cHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgMCBdID0gMiAqIG5lYXIgLyAoIHhtYXggLSB4bWluICk7XFxuXFx0XFx0XFx0XFx0XFx0cHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1sgOCBdID0gKCB4bWF4ICsgeG1pbiApIC8gKCB4bWF4IC0geG1pbiApO1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuY2FtZXJhTC5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIHByb2plY3Rpb25NYXRyaXggKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBmb3IgcmlnaHQgZXllXFxuXFxuXFx0XFx0XFx0XFx0XFx0eG1pbiA9IC0geW1heCAqIGFzcGVjdCAtIGV5ZVNlcE9uUHJvamVjdGlvbjtcXG5cXHRcXHRcXHRcXHRcXHR4bWF4ID0geW1heCAqIGFzcGVjdCAtIGV5ZVNlcE9uUHJvamVjdGlvbjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRwcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWyAwIF0gPSAyICogbmVhciAvICggeG1heCAtIHhtaW4gKTtcXG5cXHRcXHRcXHRcXHRcXHRwcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWyA4IF0gPSAoIHhtYXggKyB4bWluICkgLyAoIHhtYXggLSB4bWluICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5jYW1lcmFSLnByb2plY3Rpb25NYXRyaXguY29weSggcHJvamVjdGlvbk1hdHJpeCApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmNhbWVyYUwubWF0cml4V29ybGQuY29weSggY2FtZXJhLm1hdHJpeFdvcmxkICkubXVsdGlwbHkoIGV5ZUxlZnQgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLmNhbWVyYVIubWF0cml4V29ybGQuY29weSggY2FtZXJhLm1hdHJpeFdvcmxkICkubXVsdGlwbHkoIGV5ZVJpZ2h0ICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9ICkoKVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBDYW1lcmEgZm9yIHJlbmRlcmluZyBjdWJlIG1hcHNcXG5cXHQgKlxcdC0gcmVuZGVycyBzY2VuZSBpbnRvIGF4aXMtYWxpZ25lZCBjdWJlXFxuXFx0ICpcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEN1YmVDYW1lcmEoIG5lYXIsIGZhciwgY3ViZVJlc29sdXRpb24gKSB7XFxuXFxuXFx0XFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdDdWJlQ2FtZXJhJztcXG5cXG5cXHRcXHR2YXIgZm92ID0gOTAsIGFzcGVjdCA9IDE7XFxuXFxuXFx0XFx0dmFyIGNhbWVyYVBYID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XFxuXFx0XFx0Y2FtZXJhUFgudXAuc2V0KCAwLCAtIDEsIDAgKTtcXG5cXHRcXHRjYW1lcmFQWC5sb29rQXQoIG5ldyBWZWN0b3IzKCAxLCAwLCAwICkgKTtcXG5cXHRcXHR0aGlzLmFkZCggY2FtZXJhUFggKTtcXG5cXG5cXHRcXHR2YXIgY2FtZXJhTlggPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcXG5cXHRcXHRjYW1lcmFOWC51cC5zZXQoIDAsIC0gMSwgMCApO1xcblxcdFxcdGNhbWVyYU5YLmxvb2tBdCggbmV3IFZlY3RvcjMoIC0gMSwgMCwgMCApICk7XFxuXFx0XFx0dGhpcy5hZGQoIGNhbWVyYU5YICk7XFxuXFxuXFx0XFx0dmFyIGNhbWVyYVBZID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XFxuXFx0XFx0Y2FtZXJhUFkudXAuc2V0KCAwLCAwLCAxICk7XFxuXFx0XFx0Y2FtZXJhUFkubG9va0F0KCBuZXcgVmVjdG9yMyggMCwgMSwgMCApICk7XFxuXFx0XFx0dGhpcy5hZGQoIGNhbWVyYVBZICk7XFxuXFxuXFx0XFx0dmFyIGNhbWVyYU5ZID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XFxuXFx0XFx0Y2FtZXJhTlkudXAuc2V0KCAwLCAwLCAtIDEgKTtcXG5cXHRcXHRjYW1lcmFOWS5sb29rQXQoIG5ldyBWZWN0b3IzKCAwLCAtIDEsIDAgKSApO1xcblxcdFxcdHRoaXMuYWRkKCBjYW1lcmFOWSApO1xcblxcblxcdFxcdHZhciBjYW1lcmFQWiA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xcblxcdFxcdGNhbWVyYVBaLnVwLnNldCggMCwgLSAxLCAwICk7XFxuXFx0XFx0Y2FtZXJhUFoubG9va0F0KCBuZXcgVmVjdG9yMyggMCwgMCwgMSApICk7XFxuXFx0XFx0dGhpcy5hZGQoIGNhbWVyYVBaICk7XFxuXFxuXFx0XFx0dmFyIGNhbWVyYU5aID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XFxuXFx0XFx0Y2FtZXJhTloudXAuc2V0KCAwLCAtIDEsIDAgKTtcXG5cXHRcXHRjYW1lcmFOWi5sb29rQXQoIG5ldyBWZWN0b3IzKCAwLCAwLCAtIDEgKSApO1xcblxcdFxcdHRoaXMuYWRkKCBjYW1lcmFOWiApO1xcblxcblxcdFxcdHZhciBvcHRpb25zID0geyBmb3JtYXQ6IFJHQkZvcm1hdCwgbWFnRmlsdGVyOiBMaW5lYXJGaWx0ZXIsIG1pbkZpbHRlcjogTGluZWFyRmlsdGVyIH07XFxuXFxuXFx0XFx0dGhpcy5yZW5kZXJUYXJnZXQgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXRDdWJlKCBjdWJlUmVzb2x1dGlvbiwgY3ViZVJlc29sdXRpb24sIG9wdGlvbnMgKTtcXG5cXHRcXHR0aGlzLnJlbmRlclRhcmdldC50ZXh0dXJlLm5hbWUgPSBcXFwiQ3ViZUNhbWVyYVxcXCI7XFxuXFxuXFx0XFx0dGhpcy51cGRhdGUgPSBmdW5jdGlvbiAoIHJlbmRlcmVyLCBzY2VuZSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMucGFyZW50ID09PSBudWxsICkgdGhpcy51cGRhdGVNYXRyaXhXb3JsZCgpO1xcblxcblxcdFxcdFxcdHZhciByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRhcmdldDtcXG5cXHRcXHRcXHR2YXIgZ2VuZXJhdGVNaXBtYXBzID0gcmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzO1xcblxcblxcdFxcdFxcdHJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xcblxcblxcdFxcdFxcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDA7XFxuXFx0XFx0XFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUFgsIHJlbmRlclRhcmdldCApO1xcblxcblxcdFxcdFxcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDE7XFxuXFx0XFx0XFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhTlgsIHJlbmRlclRhcmdldCApO1xcblxcblxcdFxcdFxcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDI7XFxuXFx0XFx0XFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUFksIHJlbmRlclRhcmdldCApO1xcblxcblxcdFxcdFxcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDM7XFxuXFx0XFx0XFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhTlksIHJlbmRlclRhcmdldCApO1xcblxcblxcdFxcdFxcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDQ7XFxuXFx0XFx0XFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUFosIHJlbmRlclRhcmdldCApO1xcblxcblxcdFxcdFxcdHJlbmRlclRhcmdldC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGdlbmVyYXRlTWlwbWFwcztcXG5cXG5cXHRcXHRcXHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSA1O1xcblxcdFxcdFxcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5aLCByZW5kZXJUYXJnZXQgKTtcXG5cXG5cXHRcXHRcXHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIG51bGwgKTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoIHJlbmRlcmVyLCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVGFyZ2V0O1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gaTtcXG5cXHRcXHRcXHRcXHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xcblxcblxcdFxcdFxcdFxcdHJlbmRlcmVyLmNsZWFyKCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KCBudWxsICk7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHR9XFxuXFxuXFx0Q3ViZUNhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKTtcXG5cXHRDdWJlQ2FtZXJhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEN1YmVDYW1lcmE7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBBdWRpb0xpc3RlbmVyKCkge1xcblxcblxcdFxcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnQXVkaW9MaXN0ZW5lcic7XFxuXFxuXFx0XFx0dGhpcy5jb250ZXh0ID0gQXVkaW9Db250ZXh0LmdldENvbnRleHQoKTtcXG5cXG5cXHRcXHR0aGlzLmdhaW4gPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xcblxcdFxcdHRoaXMuZ2Fpbi5jb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcXG5cXG5cXHRcXHR0aGlzLmZpbHRlciA9IG51bGw7XFxuXFxuXFx0fVxcblxcblxcdEF1ZGlvTGlzdGVuZXIucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICksIHtcXG5cXG5cXHRcXHRjb25zdHJ1Y3RvcjogQXVkaW9MaXN0ZW5lcixcXG5cXG5cXHRcXHRnZXRJbnB1dDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmdhaW47XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyZW1vdmVGaWx0ZXI6IGZ1bmN0aW9uICggKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmZpbHRlciAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmdhaW4uZGlzY29ubmVjdCggdGhpcy5maWx0ZXIgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLmZpbHRlci5kaXNjb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcXG5cXHRcXHRcXHRcXHR0aGlzLmdhaW4uY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XFxuXFx0XFx0XFx0XFx0dGhpcy5maWx0ZXIgPSBudWxsO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldEZpbHRlcjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmZpbHRlcjtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldEZpbHRlcjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuZmlsdGVyICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuZ2Fpbi5kaXNjb25uZWN0KCB0aGlzLmZpbHRlciApO1xcblxcdFxcdFxcdFxcdHRoaXMuZmlsdGVyLmRpc2Nvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5nYWluLmRpc2Nvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLmZpbHRlciA9IHZhbHVlO1xcblxcdFxcdFxcdHRoaXMuZ2Fpbi5jb25uZWN0KCB0aGlzLmZpbHRlciApO1xcblxcdFxcdFxcdHRoaXMuZmlsdGVyLmNvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0TWFzdGVyVm9sdW1lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2Fpbi5nYWluLnZhbHVlO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0TWFzdGVyVm9sdW1lOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdHRoaXMuZ2Fpbi5nYWluLnZhbHVlID0gdmFsdWU7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR1cGRhdGVNYXRyaXhXb3JsZDogKCBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XFxuXFx0XFx0XFx0dmFyIHNjYWxlID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHR2YXIgb3JpZW50YXRpb24gPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiB1cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0T2JqZWN0M0QucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkLmNhbGwoIHRoaXMsIGZvcmNlICk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGxpc3RlbmVyID0gdGhpcy5jb250ZXh0Lmxpc3RlbmVyO1xcblxcdFxcdFxcdFxcdHZhciB1cCA9IHRoaXMudXA7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApO1xcblxcblxcdFxcdFxcdFxcdG9yaWVudGF0aW9uLnNldCggMCwgMCwgLSAxICkuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBsaXN0ZW5lci5wb3NpdGlvblggKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bGlzdGVuZXIucG9zaXRpb25YLnNldFZhbHVlQXRUaW1lKCBwb3NpdGlvbi54LCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgKTtcXG5cXHRcXHRcXHRcXHRcXHRsaXN0ZW5lci5wb3NpdGlvblkuc2V0VmFsdWVBdFRpbWUoIHBvc2l0aW9uLnksIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSApO1xcblxcdFxcdFxcdFxcdFxcdGxpc3RlbmVyLnBvc2l0aW9uWi5zZXRWYWx1ZUF0VGltZSggcG9zaXRpb24ueiwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lICk7XFxuXFx0XFx0XFx0XFx0XFx0bGlzdGVuZXIuZm9yd2FyZFguc2V0VmFsdWVBdFRpbWUoIG9yaWVudGF0aW9uLngsIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSApO1xcblxcdFxcdFxcdFxcdFxcdGxpc3RlbmVyLmZvcndhcmRZLnNldFZhbHVlQXRUaW1lKCBvcmllbnRhdGlvbi55LCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgKTtcXG5cXHRcXHRcXHRcXHRcXHRsaXN0ZW5lci5mb3J3YXJkWi5zZXRWYWx1ZUF0VGltZSggb3JpZW50YXRpb24ueiwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lICk7XFxuXFx0XFx0XFx0XFx0XFx0bGlzdGVuZXIudXBYLnNldFZhbHVlQXRUaW1lKCB1cC54LCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgKTtcXG5cXHRcXHRcXHRcXHRcXHRsaXN0ZW5lci51cFkuc2V0VmFsdWVBdFRpbWUoIHVwLnksIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSApO1xcblxcdFxcdFxcdFxcdFxcdGxpc3RlbmVyLnVwWi5zZXRWYWx1ZUF0VGltZSggdXAueiwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRsaXN0ZW5lci5zZXRQb3NpdGlvbiggcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueiApO1xcblxcdFxcdFxcdFxcdFxcdGxpc3RlbmVyLnNldE9yaWVudGF0aW9uKCBvcmllbnRhdGlvbi54LCBvcmllbnRhdGlvbi55LCBvcmllbnRhdGlvbi56LCB1cC54LCB1cC55LCB1cC56ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSApKClcXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIFJlZWNlIEFhcm9uIExlY3JpdmFpbiAvIGh0dHA6Ly9yZWVjZW5vdGVzLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBBdWRpbyggbGlzdGVuZXIgKSB7XFxuXFxuXFx0XFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdBdWRpbyc7XFxuXFxuXFx0XFx0dGhpcy5jb250ZXh0ID0gbGlzdGVuZXIuY29udGV4dDtcXG5cXG5cXHRcXHR0aGlzLmdhaW4gPSB0aGlzLmNvbnRleHQuY3JlYXRlR2FpbigpO1xcblxcdFxcdHRoaXMuZ2Fpbi5jb25uZWN0KCBsaXN0ZW5lci5nZXRJbnB1dCgpICk7XFxuXFxuXFx0XFx0dGhpcy5hdXRvcGxheSA9IGZhbHNlO1xcblxcblxcdFxcdHRoaXMuYnVmZmVyID0gbnVsbDtcXG5cXHRcXHR0aGlzLmxvb3AgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLnN0YXJ0VGltZSA9IDA7XFxuXFx0XFx0dGhpcy5vZmZzZXQgPSAwO1xcblxcdFxcdHRoaXMucGxheWJhY2tSYXRlID0gMTtcXG5cXHRcXHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xcblxcdFxcdHRoaXMuaGFzUGxheWJhY2tDb250cm9sID0gdHJ1ZTtcXG5cXHRcXHR0aGlzLnNvdXJjZVR5cGUgPSAnZW1wdHknO1xcblxcblxcdFxcdHRoaXMuZmlsdGVycyA9IFtdO1xcblxcblxcdH1cXG5cXG5cXHRBdWRpby5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBBdWRpbyxcXG5cXG5cXHRcXHRnZXRPdXRwdXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5nYWluO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0Tm9kZVNvdXJjZTogZnVuY3Rpb24gKCBhdWRpb05vZGUgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPSBmYWxzZTtcXG5cXHRcXHRcXHR0aGlzLnNvdXJjZVR5cGUgPSAnYXVkaW9Ob2RlJztcXG5cXHRcXHRcXHR0aGlzLnNvdXJjZSA9IGF1ZGlvTm9kZTtcXG5cXHRcXHRcXHR0aGlzLmNvbm5lY3QoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldEJ1ZmZlcjogZnVuY3Rpb24gKCBhdWRpb0J1ZmZlciApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmJ1ZmZlciA9IGF1ZGlvQnVmZmVyO1xcblxcdFxcdFxcdHRoaXMuc291cmNlVHlwZSA9ICdidWZmZXInO1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5hdXRvcGxheSApIHRoaXMucGxheSgpO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cGxheTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5pc1BsYXlpbmcgPT09IHRydWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IEF1ZGlvIGlzIGFscmVhZHkgcGxheWluZy4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgc291cmNlID0gdGhpcy5jb250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xcblxcblxcdFxcdFxcdHNvdXJjZS5idWZmZXIgPSB0aGlzLmJ1ZmZlcjtcXG5cXHRcXHRcXHRzb3VyY2UubG9vcCA9IHRoaXMubG9vcDtcXG5cXHRcXHRcXHRzb3VyY2Uub25lbmRlZCA9IHRoaXMub25FbmRlZC5iaW5kKCB0aGlzICk7XFxuXFx0XFx0XFx0c291cmNlLnBsYXliYWNrUmF0ZS5zZXRWYWx1ZUF0VGltZSggdGhpcy5wbGF5YmFja1JhdGUsIHRoaXMuc3RhcnRUaW1lICk7XFxuXFx0XFx0XFx0dGhpcy5zdGFydFRpbWUgPSB0aGlzLmNvbnRleHQuY3VycmVudFRpbWU7XFxuXFx0XFx0XFx0c291cmNlLnN0YXJ0KCB0aGlzLnN0YXJ0VGltZSwgdGhpcy5vZmZzZXQgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLmlzUGxheWluZyA9IHRydWU7XFxuXFxuXFx0XFx0XFx0dGhpcy5zb3VyY2UgPSBzb3VyY2U7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuY29ubmVjdCgpO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cGF1c2U6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuc291cmNlLnN0b3AoKTtcXG5cXHRcXHRcXHRcXHR0aGlzLm9mZnNldCArPSAoIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSAtIHRoaXMuc3RhcnRUaW1lICkgKiB0aGlzLnBsYXliYWNrUmF0ZTtcXG5cXHRcXHRcXHRcXHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHN0b3A6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLnNvdXJjZS5zdG9wKCk7XFxuXFx0XFx0XFx0dGhpcy5vZmZzZXQgPSAwO1xcblxcdFxcdFxcdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb25uZWN0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmZpbHRlcnMubGVuZ3RoID4gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnNvdXJjZS5jb25uZWN0KCB0aGlzLmZpbHRlcnNbIDAgXSApO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMSwgbCA9IHRoaXMuZmlsdGVycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuZmlsdGVyc1sgaSAtIDEgXS5jb25uZWN0KCB0aGlzLmZpbHRlcnNbIGkgXSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmZpbHRlcnNbIHRoaXMuZmlsdGVycy5sZW5ndGggLSAxIF0uY29ubmVjdCggdGhpcy5nZXRPdXRwdXQoKSApO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5zb3VyY2UuY29ubmVjdCggdGhpcy5nZXRPdXRwdXQoKSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGRpc2Nvbm5lY3Q6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuZmlsdGVycy5sZW5ndGggPiAwICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuc291cmNlLmRpc2Nvbm5lY3QoIHRoaXMuZmlsdGVyc1sgMCBdICk7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAxLCBsID0gdGhpcy5maWx0ZXJzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5maWx0ZXJzWyBpIC0gMSBdLmRpc2Nvbm5lY3QoIHRoaXMuZmlsdGVyc1sgaSBdICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHRoaXMuZmlsdGVyc1sgdGhpcy5maWx0ZXJzLmxlbmd0aCAtIDEgXS5kaXNjb25uZWN0KCB0aGlzLmdldE91dHB1dCgpICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnNvdXJjZS5kaXNjb25uZWN0KCB0aGlzLmdldE91dHB1dCgpICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0RmlsdGVyczogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmZpbHRlcnM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRGaWx0ZXJzOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdGlmICggISB2YWx1ZSApIHZhbHVlID0gW107XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmRpc2Nvbm5lY3QoKTtcXG5cXHRcXHRcXHRcXHR0aGlzLmZpbHRlcnMgPSB2YWx1ZTtcXG5cXHRcXHRcXHRcXHR0aGlzLmNvbm5lY3QoKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuZmlsdGVycyA9IHZhbHVlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldEZpbHRlcjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmdldEZpbHRlcnMoKVsgMCBdO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0RmlsdGVyOiBmdW5jdGlvbiAoIGZpbHRlciApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5zZXRGaWx0ZXJzKCBmaWx0ZXIgPyBbIGZpbHRlciBdIDogW10gKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFBsYXliYWNrUmF0ZTogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLnBsYXliYWNrUmF0ZSA9IHZhbHVlO1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5pc1BsYXlpbmcgPT09IHRydWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5zb3VyY2UucGxheWJhY2tSYXRlLnNldFZhbHVlQXRUaW1lKCB0aGlzLnBsYXliYWNrUmF0ZSwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0UGxheWJhY2tSYXRlOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMucGxheWJhY2tSYXRlO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0b25FbmRlZDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRMb29wOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubG9vcDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldExvb3A6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9PT0gZmFsc2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW86IHRoaXMgQXVkaW8gaGFzIG5vIHBsYXliYWNrIGNvbnRyb2wuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5sb29wID0gdmFsdWU7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnNvdXJjZS5sb29wID0gdGhpcy5sb29wO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldFZvbHVtZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmdhaW4uZ2Fpbi52YWx1ZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFZvbHVtZTogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmdhaW4uZ2Fpbi52YWx1ZSA9IHZhbHVlO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBQb3NpdGlvbmFsQXVkaW8oIGxpc3RlbmVyICkge1xcblxcblxcdFxcdEF1ZGlvLmNhbGwoIHRoaXMsIGxpc3RlbmVyICk7XFxuXFxuXFx0XFx0dGhpcy5wYW5uZXIgPSB0aGlzLmNvbnRleHQuY3JlYXRlUGFubmVyKCk7XFxuXFx0XFx0dGhpcy5wYW5uZXIuY29ubmVjdCggdGhpcy5nYWluICk7XFxuXFxuXFx0fVxcblxcblxcdFBvc2l0aW9uYWxBdWRpby5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBBdWRpby5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBQb3NpdGlvbmFsQXVkaW8sXFxuXFxuXFx0XFx0Z2V0T3V0cHV0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMucGFubmVyO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0UmVmRGlzdGFuY2U6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5wYW5uZXIucmVmRGlzdGFuY2U7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRSZWZEaXN0YW5jZTogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnBhbm5lci5yZWZEaXN0YW5jZSA9IHZhbHVlO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0Um9sbG9mZkZhY3RvcjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLnBhbm5lci5yb2xsb2ZmRmFjdG9yO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0Um9sbG9mZkZhY3RvcjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnBhbm5lci5yb2xsb2ZmRmFjdG9yID0gdmFsdWU7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXREaXN0YW5jZU1vZGVsOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMucGFubmVyLmRpc3RhbmNlTW9kZWw7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXREaXN0YW5jZU1vZGVsOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdHRoaXMucGFubmVyLmRpc3RhbmNlTW9kZWwgPSB2YWx1ZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldE1heERpc3RhbmNlOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMucGFubmVyLm1heERpc3RhbmNlO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0TWF4RGlzdGFuY2U6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5wYW5uZXIubWF4RGlzdGFuY2UgPSB2YWx1ZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHVwZGF0ZU1hdHJpeFdvcmxkOiAoIGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgcG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiB1cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0T2JqZWN0M0QucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkLmNhbGwoIHRoaXMsIGZvcmNlICk7XFxuXFxuXFx0XFx0XFx0XFx0cG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5wYW5uZXIuc2V0UG9zaXRpb24oIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnogKTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0gKSgpXFxuXFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gQXVkaW9BbmFseXNlciggYXVkaW8sIGZmdFNpemUgKSB7XFxuXFxuXFx0XFx0dGhpcy5hbmFseXNlciA9IGF1ZGlvLmNvbnRleHQuY3JlYXRlQW5hbHlzZXIoKTtcXG5cXHRcXHR0aGlzLmFuYWx5c2VyLmZmdFNpemUgPSBmZnRTaXplICE9PSB1bmRlZmluZWQgPyBmZnRTaXplIDogMjA0ODtcXG5cXG5cXHRcXHR0aGlzLmRhdGEgPSBuZXcgVWludDhBcnJheSggdGhpcy5hbmFseXNlci5mcmVxdWVuY3lCaW5Db3VudCApO1xcblxcblxcdFxcdGF1ZGlvLmdldE91dHB1dCgpLmNvbm5lY3QoIHRoaXMuYW5hbHlzZXIgKTtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggQXVkaW9BbmFseXNlci5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRnZXRGcmVxdWVuY3lEYXRhOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5hbmFseXNlci5nZXRCeXRlRnJlcXVlbmN5RGF0YSggdGhpcy5kYXRhICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZGF0YTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldEF2ZXJhZ2VGcmVxdWVuY3k6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdmFsdWUgPSAwLCBkYXRhID0gdGhpcy5nZXRGcmVxdWVuY3lEYXRhKCk7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFsdWUgKz0gZGF0YVsgaSBdO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdmFsdWUgLyBkYXRhLmxlbmd0aDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqXFxuXFx0ICogQnVmZmVyZWQgc2NlbmUgZ3JhcGggcHJvcGVydHkgdGhhdCBhbGxvd3Mgd2VpZ2h0ZWQgYWNjdW11bGF0aW9uLlxcblxcdCAqXFxuXFx0ICpcXG5cXHQgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xcblxcdCAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xcblxcdCAqIEBhdXRob3IgdHNjaHdcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBQcm9wZXJ0eU1peGVyKCBiaW5kaW5nLCB0eXBlTmFtZSwgdmFsdWVTaXplICkge1xcblxcblxcdFxcdHRoaXMuYmluZGluZyA9IGJpbmRpbmc7XFxuXFx0XFx0dGhpcy52YWx1ZVNpemUgPSB2YWx1ZVNpemU7XFxuXFxuXFx0XFx0dmFyIGJ1ZmZlclR5cGUgPSBGbG9hdDY0QXJyYXksXFxuXFx0XFx0XFx0bWl4RnVuY3Rpb247XFxuXFxuXFx0XFx0c3dpdGNoICggdHlwZU5hbWUgKSB7XFxuXFxuXFx0XFx0XFx0Y2FzZSAncXVhdGVybmlvbic6XFxuXFx0XFx0XFx0XFx0bWl4RnVuY3Rpb24gPSB0aGlzLl9zbGVycDtcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRjYXNlICdzdHJpbmcnOlxcblxcdFxcdFxcdGNhc2UgJ2Jvb2wnOlxcblxcdFxcdFxcdFxcdGJ1ZmZlclR5cGUgPSBBcnJheTtcXG5cXHRcXHRcXHRcXHRtaXhGdW5jdGlvbiA9IHRoaXMuX3NlbGVjdDtcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRkZWZhdWx0OlxcblxcdFxcdFxcdFxcdG1peEZ1bmN0aW9uID0gdGhpcy5fbGVycDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5idWZmZXIgPSBuZXcgYnVmZmVyVHlwZSggdmFsdWVTaXplICogNCApO1xcblxcdFxcdC8vIGxheW91dDogWyBpbmNvbWluZyB8IGFjY3UwIHwgYWNjdTEgfCBvcmlnIF1cXG5cXHRcXHQvL1xcblxcdFxcdC8vIGludGVycG9sYXRvcnMgY2FuIHVzZSAuYnVmZmVyIGFzIHRoZWlyIC5yZXN1bHRcXG5cXHRcXHQvLyB0aGUgZGF0YSB0aGVuIGdvZXMgdG8gJ2luY29taW5nJ1xcblxcdFxcdC8vXFxuXFx0XFx0Ly8gJ2FjY3UwJyBhbmQgJ2FjY3UxJyBhcmUgdXNlZCBmcmFtZS1pbnRlcmxlYXZlZCBmb3JcXG5cXHRcXHQvLyB0aGUgY3VtdWxhdGl2ZSByZXN1bHQgYW5kIGFyZSBjb21wYXJlZCB0byBkZXRlY3RcXG5cXHRcXHQvLyBjaGFuZ2VzXFxuXFx0XFx0Ly9cXG5cXHRcXHQvLyAnb3JpZycgc3RvcmVzIHRoZSBvcmlnaW5hbCBzdGF0ZSBvZiB0aGUgcHJvcGVydHlcXG5cXG5cXHRcXHR0aGlzLl9taXhCdWZmZXJSZWdpb24gPSBtaXhGdW5jdGlvbjtcXG5cXG5cXHRcXHR0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSAwO1xcblxcblxcdFxcdHRoaXMudXNlQ291bnQgPSAwO1xcblxcdFxcdHRoaXMucmVmZXJlbmNlQ291bnQgPSAwO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBQcm9wZXJ0eU1peGVyLnByb3RvdHlwZSwge1xcblxcblxcdFxcdC8vIGFjY3VtdWxhdGUgZGF0YSBpbiB0aGUgJ2luY29taW5nJyByZWdpb24gaW50byAnYWNjdTxpPidcXG5cXHRcXHRhY2N1bXVsYXRlOiBmdW5jdGlvbiAoIGFjY3VJbmRleCwgd2VpZ2h0ICkge1xcblxcblxcdFxcdFxcdC8vIG5vdGU6IGhhcHBpbHkgYWNjdW11bGF0aW5nIG5vdGhpbmcgd2hlbiB3ZWlnaHQgPSAwLCB0aGUgY2FsbGVyIGtub3dzXFxuXFx0XFx0XFx0Ly8gdGhlIHdlaWdodCBhbmQgc2hvdWxkbid0IGhhdmUgbWFkZSB0aGUgY2FsbCBpbiB0aGUgZmlyc3QgcGxhY2VcXG5cXG5cXHRcXHRcXHR2YXIgYnVmZmVyID0gdGhpcy5idWZmZXIsXFxuXFx0XFx0XFx0XFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXFxuXFx0XFx0XFx0XFx0b2Zmc2V0ID0gYWNjdUluZGV4ICogc3RyaWRlICsgc3RyaWRlLFxcblxcblxcdFxcdFxcdFxcdGN1cnJlbnRXZWlnaHQgPSB0aGlzLmN1bXVsYXRpdmVXZWlnaHQ7XFxuXFxuXFx0XFx0XFx0aWYgKCBjdXJyZW50V2VpZ2h0ID09PSAwICkge1xcblxcblxcdFxcdFxcdFxcdC8vIGFjY3VOIDo9IGluY29taW5nICogd2VpZ2h0XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YnVmZmVyWyBvZmZzZXQgKyBpIF0gPSBidWZmZXJbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Y3VycmVudFdlaWdodCA9IHdlaWdodDtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdC8vIGFjY3VOIDo9IGFjY3VOICsgaW5jb21pbmcgKiB3ZWlnaHRcXG5cXG5cXHRcXHRcXHRcXHRjdXJyZW50V2VpZ2h0ICs9IHdlaWdodDtcXG5cXHRcXHRcXHRcXHR2YXIgbWl4ID0gd2VpZ2h0IC8gY3VycmVudFdlaWdodDtcXG5cXHRcXHRcXHRcXHR0aGlzLl9taXhCdWZmZXJSZWdpb24oIGJ1ZmZlciwgb2Zmc2V0LCAwLCBtaXgsIHN0cmlkZSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLmN1bXVsYXRpdmVXZWlnaHQgPSBjdXJyZW50V2VpZ2h0O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gYXBwbHkgdGhlIHN0YXRlIG9mICdhY2N1PGk+JyB0byB0aGUgYmluZGluZyB3aGVuIGFjY3VzIGRpZmZlclxcblxcdFxcdGFwcGx5OiBmdW5jdGlvbiAoIGFjY3VJbmRleCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgc3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXFxuXFx0XFx0XFx0XFx0YnVmZmVyID0gdGhpcy5idWZmZXIsXFxuXFx0XFx0XFx0XFx0b2Zmc2V0ID0gYWNjdUluZGV4ICogc3RyaWRlICsgc3RyaWRlLFxcblxcblxcdFxcdFxcdFxcdHdlaWdodCA9IHRoaXMuY3VtdWxhdGl2ZVdlaWdodCxcXG5cXG5cXHRcXHRcXHRcXHRiaW5kaW5nID0gdGhpcy5iaW5kaW5nO1xcblxcblxcdFxcdFxcdHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA9IDA7XFxuXFxuXFx0XFx0XFx0aWYgKCB3ZWlnaHQgPCAxICkge1xcblxcblxcdFxcdFxcdFxcdC8vIGFjY3VOIDo9IGFjY3VOICsgb3JpZ2luYWwgKiAoIDEgLSBjdW11bGF0aXZlV2VpZ2h0IClcXG5cXG5cXHRcXHRcXHRcXHR2YXIgb3JpZ2luYWxWYWx1ZU9mZnNldCA9IHN0cmlkZSAqIDM7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5fbWl4QnVmZmVyUmVnaW9uKFxcblxcdFxcdFxcdFxcdFxcdGJ1ZmZlciwgb2Zmc2V0LCBvcmlnaW5hbFZhbHVlT2Zmc2V0LCAxIC0gd2VpZ2h0LCBzdHJpZGUgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSBzdHJpZGUsIGUgPSBzdHJpZGUgKyBzdHJpZGU7IGkgIT09IGU7ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBidWZmZXJbIGkgXSAhPT0gYnVmZmVyWyBpICsgc3RyaWRlIF0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdmFsdWUgaGFzIGNoYW5nZWQgLT4gdXBkYXRlIHNjZW5lIGdyYXBoXFxuXFxuXFx0XFx0XFx0XFx0XFx0YmluZGluZy5zZXRWYWx1ZSggYnVmZmVyLCBvZmZzZXQgKTtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gcmVtZW1iZXIgdGhlIHN0YXRlIG9mIHRoZSBib3VuZCBwcm9wZXJ0eSBhbmQgY29weSBpdCB0byBib3RoIGFjY3VzXFxuXFx0XFx0c2F2ZU9yaWdpbmFsU3RhdGU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgYmluZGluZyA9IHRoaXMuYmluZGluZztcXG5cXG5cXHRcXHRcXHR2YXIgYnVmZmVyID0gdGhpcy5idWZmZXIsXFxuXFx0XFx0XFx0XFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXFxuXFxuXFx0XFx0XFx0XFx0b3JpZ2luYWxWYWx1ZU9mZnNldCA9IHN0cmlkZSAqIDM7XFxuXFxuXFx0XFx0XFx0YmluZGluZy5nZXRWYWx1ZSggYnVmZmVyLCBvcmlnaW5hbFZhbHVlT2Zmc2V0ICk7XFxuXFxuXFx0XFx0XFx0Ly8gYWNjdVswLi4xXSA6PSBvcmlnIC0tIGluaXRpYWxseSBkZXRlY3QgY2hhbmdlcyBhZ2FpbnN0IHRoZSBvcmlnaW5hbFxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gc3RyaWRlLCBlID0gb3JpZ2luYWxWYWx1ZU9mZnNldDsgaSAhPT0gZTsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHRcXHRidWZmZXJbIGkgXSA9IGJ1ZmZlclsgb3JpZ2luYWxWYWx1ZU9mZnNldCArICggaSAlIHN0cmlkZSApIF07XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA9IDA7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBhcHBseSB0aGUgc3RhdGUgcHJldmlvdXNseSB0YWtlbiB2aWEgJ3NhdmVPcmlnaW5hbFN0YXRlJyB0byB0aGUgYmluZGluZ1xcblxcdFxcdHJlc3RvcmVPcmlnaW5hbFN0YXRlOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIG9yaWdpbmFsVmFsdWVPZmZzZXQgPSB0aGlzLnZhbHVlU2l6ZSAqIDM7XFxuXFx0XFx0XFx0dGhpcy5iaW5kaW5nLnNldFZhbHVlKCB0aGlzLmJ1ZmZlciwgb3JpZ2luYWxWYWx1ZU9mZnNldCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFxuXFx0XFx0Ly8gbWl4IGZ1bmN0aW9uc1xcblxcblxcdFxcdF9zZWxlY3Q6IGZ1bmN0aW9uICggYnVmZmVyLCBkc3RPZmZzZXQsIHNyY09mZnNldCwgdCwgc3RyaWRlICkge1xcblxcblxcdFxcdFxcdGlmICggdCA+PSAwLjUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YnVmZmVyWyBkc3RPZmZzZXQgKyBpIF0gPSBidWZmZXJbIHNyY09mZnNldCArIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3NsZXJwOiBmdW5jdGlvbiAoIGJ1ZmZlciwgZHN0T2Zmc2V0LCBzcmNPZmZzZXQsIHQgKSB7XFxuXFxuXFx0XFx0XFx0UXVhdGVybmlvbi5zbGVycEZsYXQoIGJ1ZmZlciwgZHN0T2Zmc2V0LCBidWZmZXIsIGRzdE9mZnNldCwgYnVmZmVyLCBzcmNPZmZzZXQsIHQgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9sZXJwOiBmdW5jdGlvbiAoIGJ1ZmZlciwgZHN0T2Zmc2V0LCBzcmNPZmZzZXQsIHQsIHN0cmlkZSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcyA9IDEgLSB0O1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBqID0gZHN0T2Zmc2V0ICsgaTtcXG5cXG5cXHRcXHRcXHRcXHRidWZmZXJbIGogXSA9IGJ1ZmZlclsgaiBdICogcyArIGJ1ZmZlclsgc3JjT2Zmc2V0ICsgaSBdICogdDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKlxcblxcdCAqIEEgcmVmZXJlbmNlIHRvIGEgcmVhbCBwcm9wZXJ0eSBpbiB0aGUgc2NlbmUgZ3JhcGguXFxuXFx0ICpcXG5cXHQgKlxcblxcdCAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXFxuXFx0ICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXFxuXFx0ICogQGF1dGhvciB0c2Nod1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIENvbXBvc2l0ZSggdGFyZ2V0R3JvdXAsIHBhdGgsIG9wdGlvbmFsUGFyc2VkUGF0aCApIHtcXG5cXG5cXHRcXHR2YXIgcGFyc2VkUGF0aCA9IG9wdGlvbmFsUGFyc2VkUGF0aCB8fCBQcm9wZXJ0eUJpbmRpbmcucGFyc2VUcmFja05hbWUoIHBhdGggKTtcXG5cXG5cXHRcXHR0aGlzLl90YXJnZXRHcm91cCA9IHRhcmdldEdyb3VwO1xcblxcdFxcdHRoaXMuX2JpbmRpbmdzID0gdGFyZ2V0R3JvdXAuc3Vic2NyaWJlXyggcGF0aCwgcGFyc2VkUGF0aCApO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBDb21wb3NpdGUucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0Z2V0VmFsdWU6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmJpbmQoKTsgLy8gYmluZCBhbGwgYmluZGluZ1xcblxcblxcdFxcdFxcdHZhciBmaXJzdFZhbGlkSW5kZXggPSB0aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sXFxuXFx0XFx0XFx0XFx0YmluZGluZyA9IHRoaXMuX2JpbmRpbmdzWyBmaXJzdFZhbGlkSW5kZXggXTtcXG5cXG5cXHRcXHRcXHQvLyBhbmQgb25seSBjYWxsIC5nZXRWYWx1ZSBvbiB0aGUgZmlyc3RcXG5cXHRcXHRcXHRpZiAoIGJpbmRpbmcgIT09IHVuZGVmaW5lZCApIGJpbmRpbmcuZ2V0VmFsdWUoIGFycmF5LCBvZmZzZXQgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFZhbHVlOiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSB0aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sXFxuXFx0XFx0XFx0XFx0XFx0ICBuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xcblxcblxcdFxcdFxcdFxcdGJpbmRpbmdzWyBpIF0uc2V0VmFsdWUoIGFycmF5LCBvZmZzZXQgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRiaW5kOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSB0aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sXFxuXFx0XFx0XFx0XFx0XFx0ICBuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xcblxcblxcdFxcdFxcdFxcdGJpbmRpbmdzWyBpIF0uYmluZCgpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHVuYmluZDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gdGhpcy5fdGFyZ2V0R3JvdXAubkNhY2hlZE9iamVjdHNfLFxcblxcdFxcdFxcdFxcdFxcdCAgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHRcXHRiaW5kaW5nc1sgaSBdLnVuYmluZCgpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcblxcdGZ1bmN0aW9uIFByb3BlcnR5QmluZGluZyggcm9vdE5vZGUsIHBhdGgsIHBhcnNlZFBhdGggKSB7XFxuXFxuXFx0XFx0dGhpcy5wYXRoID0gcGF0aDtcXG5cXHRcXHR0aGlzLnBhcnNlZFBhdGggPSBwYXJzZWRQYXRoIHx8IFByb3BlcnR5QmluZGluZy5wYXJzZVRyYWNrTmFtZSggcGF0aCApO1xcblxcblxcdFxcdHRoaXMubm9kZSA9IFByb3BlcnR5QmluZGluZy5maW5kTm9kZSggcm9vdE5vZGUsIHRoaXMucGFyc2VkUGF0aC5ub2RlTmFtZSApIHx8IHJvb3ROb2RlO1xcblxcblxcdFxcdHRoaXMucm9vdE5vZGUgPSByb290Tm9kZTtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggUHJvcGVydHlCaW5kaW5nLCB7XFxuXFxuXFx0XFx0Q29tcG9zaXRlOiBDb21wb3NpdGUsXFxuXFxuXFx0XFx0Y3JlYXRlOiBmdW5jdGlvbiAoIHJvb3QsIHBhdGgsIHBhcnNlZFBhdGggKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCAhICggcm9vdCAmJiByb290LmlzQW5pbWF0aW9uT2JqZWN0R3JvdXAgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gbmV3IFByb3BlcnR5QmluZGluZyggcm9vdCwgcGF0aCwgcGFyc2VkUGF0aCApO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIG5ldyBQcm9wZXJ0eUJpbmRpbmcuQ29tcG9zaXRlKCByb290LCBwYXRoLCBwYXJzZWRQYXRoICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0LyoqXFxuXFx0XFx0ICogUmVwbGFjZXMgc3BhY2VzIHdpdGggdW5kZXJzY29yZXMgYW5kIHJlbW92ZXMgdW5zdXBwb3J0ZWQgY2hhcmFjdGVycyBmcm9tXFxuXFx0XFx0ICogbm9kZSBuYW1lcywgdG8gZW5zdXJlIGNvbXBhdGliaWxpdHkgd2l0aCBwYXJzZVRyYWNrTmFtZSgpLlxcblxcdFxcdCAqXFxuXFx0XFx0ICogQHBhcmFtICB7c3RyaW5nfSBuYW1lIE5vZGUgbmFtZSB0byBiZSBzYW5pdGl6ZWQuXFxuXFx0XFx0ICogQHJldHVybiB7c3RyaW5nfVxcblxcdFxcdCAqL1xcblxcdFxcdHNhbml0aXplTm9kZU5hbWU6IGZ1bmN0aW9uICggbmFtZSApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmFtZS5yZXBsYWNlKCAvXFxcXHMvZywgJ18nICkucmVwbGFjZSggL1teXFxcXHctXS9nLCAnJyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cGFyc2VUcmFja05hbWU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHQvLyBQYXJlbnQgZGlyZWN0b3JpZXMsIGRlbGltaXRlZCBieSAnLycgb3IgJzonLiBDdXJyZW50bHkgdW51c2VkLCBidXQgbXVzdFxcblxcdFxcdFxcdC8vIGJlIG1hdGNoZWQgdG8gcGFyc2UgdGhlIHJlc3Qgb2YgdGhlIHRyYWNrIG5hbWUuXFxuXFx0XFx0XFx0dmFyIGRpcmVjdG9yeVJlID0gLygoPzpbXFxcXHctXStbXFxcXC86XSkqKS87XFxuXFxuXFx0XFx0XFx0Ly8gVGFyZ2V0IG5vZGUuIE1heSBjb250YWluIHdvcmQgY2hhcmFjdGVycyAoYS16QS1aMC05XykgYW5kICcuJyBvciAnLScuXFxuXFx0XFx0XFx0dmFyIG5vZGVSZSA9IC8oW1xcXFx3LVxcXFwuXSspPy87XFxuXFxuXFx0XFx0XFx0Ly8gT2JqZWN0IG9uIHRhcmdldCBub2RlLCBhbmQgYWNjZXNzb3IuIE5hbWUgbWF5IGNvbnRhaW4gb25seSB3b3JkXFxuXFx0XFx0XFx0Ly8gY2hhcmFjdGVycy4gQWNjZXNzb3IgbWF5IGNvbnRhaW4gYW55IGNoYXJhY3RlciBleGNlcHQgY2xvc2luZyBicmFja2V0LlxcblxcdFxcdFxcdHZhciBvYmplY3RSZSA9IC8oPzpcXFxcLihbXFxcXHctXSspKD86XFxcXFsoLispXFxcXF0pPyk/LztcXG5cXG5cXHRcXHRcXHQvLyBQcm9wZXJ0eSBhbmQgYWNjZXNzb3IuIE1heSBjb250YWluIG9ubHkgd29yZCBjaGFyYWN0ZXJzLiBBY2Nlc3NvciBtYXlcXG5cXHRcXHRcXHQvLyBjb250YWluIGFueSBub24tYnJhY2tldCBjaGFyYWN0ZXJzLlxcblxcdFxcdFxcdHZhciBwcm9wZXJ0eVJlID0gL1xcXFwuKFtcXFxcdy1dKykoPzpcXFxcWyguKylcXFxcXSk/LztcXG5cXG5cXHRcXHRcXHR2YXIgdHJhY2tSZSA9IG5ldyBSZWdFeHAoICcnXFxuXFx0XFx0XFx0XFx0KyAnXidcXG5cXHRcXHRcXHRcXHQrIGRpcmVjdG9yeVJlLnNvdXJjZVxcblxcdFxcdFxcdFxcdCsgbm9kZVJlLnNvdXJjZVxcblxcdFxcdFxcdFxcdCsgb2JqZWN0UmUuc291cmNlXFxuXFx0XFx0XFx0XFx0KyBwcm9wZXJ0eVJlLnNvdXJjZVxcblxcdFxcdFxcdFxcdCsgJyQnXFxuXFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHR2YXIgc3VwcG9ydGVkT2JqZWN0TmFtZXMgPSBbICdtYXRlcmlhbCcsICdtYXRlcmlhbHMnLCAnYm9uZXMnIF07XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uICggdHJhY2tOYW1lICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBtYXRjaGVzID0gdHJhY2tSZS5leGVjKCB0cmFja05hbWUgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoICEgbWF0Y2hlcyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoICdQcm9wZXJ0eUJpbmRpbmc6IENhbm5vdCBwYXJzZSB0cmFja05hbWU6ICcgKyB0cmFja05hbWUgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHJlc3VsdHMgPSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gZGlyZWN0b3J5TmFtZTogbWF0Y2hlc1sgMSBdLCAvLyAodHNjaHcpIGN1cnJlbnRseSB1bnVzZWRcXG5cXHRcXHRcXHRcXHRcXHRub2RlTmFtZTogbWF0Y2hlc1sgMiBdLFxcblxcdFxcdFxcdFxcdFxcdG9iamVjdE5hbWU6IG1hdGNoZXNbIDMgXSxcXG5cXHRcXHRcXHRcXHRcXHRvYmplY3RJbmRleDogbWF0Y2hlc1sgNCBdLFxcblxcdFxcdFxcdFxcdFxcdHByb3BlcnR5TmFtZTogbWF0Y2hlc1sgNSBdLCAvLyByZXF1aXJlZFxcblxcdFxcdFxcdFxcdFxcdHByb3BlcnR5SW5kZXg6IG1hdGNoZXNbIDYgXVxcblxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGxhc3REb3QgPSByZXN1bHRzLm5vZGVOYW1lICYmIHJlc3VsdHMubm9kZU5hbWUubGFzdEluZGV4T2YoICcuJyApO1xcblxcblxcdFxcdFxcdFxcdGlmICggbGFzdERvdCAhPT0gdW5kZWZpbmVkICYmIGxhc3REb3QgIT09IC0gMSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgb2JqZWN0TmFtZSA9IHJlc3VsdHMubm9kZU5hbWUuc3Vic3RyaW5nKCBsYXN0RG90ICsgMSApO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIE9iamVjdCBuYW1lcyBtdXN0IGJlIGNoZWNrZWQgYWdhaW5zdCBhIHdoaXRlbGlzdC4gT3RoZXJ3aXNlLCB0aGVyZVxcblxcdFxcdFxcdFxcdFxcdC8vIGlzIG5vIHdheSB0byBwYXJzZSAnZm9vLmJhci5iYXonOiAnYmF6JyBtdXN0IGJlIGEgcHJvcGVydHksIGJ1dFxcblxcdFxcdFxcdFxcdFxcdC8vICdiYXInIGNvdWxkIGJlIHRoZSBvYmplY3ROYW1lLCBvciBwYXJ0IG9mIGEgbm9kZU5hbWUgKHdoaWNoIGNhblxcblxcdFxcdFxcdFxcdFxcdC8vIGluY2x1ZGUgJy4nIGNoYXJhY3RlcnMpLlxcblxcdFxcdFxcdFxcdFxcdGlmICggc3VwcG9ydGVkT2JqZWN0TmFtZXMuaW5kZXhPZiggb2JqZWN0TmFtZSApICE9PSAtIDEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmVzdWx0cy5ub2RlTmFtZSA9IHJlc3VsdHMubm9kZU5hbWUuc3Vic3RyaW5nKCAwLCBsYXN0RG90ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmVzdWx0cy5vYmplY3ROYW1lID0gb2JqZWN0TmFtZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggcmVzdWx0cy5wcm9wZXJ0eU5hbWUgPT09IG51bGwgfHwgcmVzdWx0cy5wcm9wZXJ0eU5hbWUubGVuZ3RoID09PSAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRocm93IG5ldyBFcnJvciggJ1Byb3BlcnR5QmluZGluZzogY2FuIG5vdCBwYXJzZSBwcm9wZXJ0eU5hbWUgZnJvbSB0cmFja05hbWU6ICcgKyB0cmFja05hbWUgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdHM7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0ZmluZE5vZGU6IGZ1bmN0aW9uICggcm9vdCwgbm9kZU5hbWUgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCAhIG5vZGVOYW1lIHx8IG5vZGVOYW1lID09PSBcXFwiXFxcIiB8fCBub2RlTmFtZSA9PT0gXFxcInJvb3RcXFwiIHx8IG5vZGVOYW1lID09PSBcXFwiLlxcXCIgfHwgbm9kZU5hbWUgPT09IC0gMSB8fCBub2RlTmFtZSA9PT0gcm9vdC5uYW1lIHx8IG5vZGVOYW1lID09PSByb290LnV1aWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJvb3Q7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIHNlYXJjaCBpbnRvIHNrZWxldG9uIGJvbmVzLlxcblxcdFxcdFxcdGlmICggcm9vdC5za2VsZXRvbiApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgc2VhcmNoU2tlbGV0b24gPSBmdW5jdGlvbiAoIHNrZWxldG9uICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IHNrZWxldG9uLmJvbmVzLmxlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgYm9uZSA9IHNrZWxldG9uLmJvbmVzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBib25lLm5hbWUgPT09IG5vZGVOYW1lICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBib25lO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIG51bGw7XFxuXFxuXFx0XFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgYm9uZSA9IHNlYXJjaFNrZWxldG9uKCByb290LnNrZWxldG9uICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBib25lICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBib25lO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gc2VhcmNoIGludG8gbm9kZSBzdWJ0cmVlLlxcblxcdFxcdFxcdGlmICggcm9vdC5jaGlsZHJlbiApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgc2VhcmNoTm9kZVN1YnRyZWUgPSBmdW5jdGlvbiAoIGNoaWxkcmVuICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgY2hpbGROb2RlID0gY2hpbGRyZW5bIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGNoaWxkTm9kZS5uYW1lID09PSBub2RlTmFtZSB8fCBjaGlsZE5vZGUudXVpZCA9PT0gbm9kZU5hbWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGNoaWxkTm9kZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHJlc3VsdCA9IHNlYXJjaE5vZGVTdWJ0cmVlKCBjaGlsZE5vZGUuY2hpbGRyZW4gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHJlc3VsdCApIHJldHVybiByZXN1bHQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBudWxsO1xcblxcblxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHN1YlRyZWVOb2RlID0gc2VhcmNoTm9kZVN1YnRyZWUoIHJvb3QuY2hpbGRyZW4gKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHN1YlRyZWVOb2RlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBzdWJUcmVlTm9kZTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBudWxsO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZSwgeyAvLyBwcm90b3R5cGUsIGNvbnRpbnVlZFxcblxcblxcdFxcdC8vIHRoZXNlIGFyZSB1c2VkIHRvIFxcXCJiaW5kXFxcIiBhIG5vbmV4aXN0ZW50IHByb3BlcnR5XFxuXFx0XFx0X2dldFZhbHVlX3VuYXZhaWxhYmxlOiBmdW5jdGlvbiAoKSB7fSxcXG5cXHRcXHRfc2V0VmFsdWVfdW5hdmFpbGFibGU6IGZ1bmN0aW9uICgpIHt9LFxcblxcblxcdFxcdEJpbmRpbmdUeXBlOiB7XFxuXFx0XFx0XFx0RGlyZWN0OiAwLFxcblxcdFxcdFxcdEVudGlyZUFycmF5OiAxLFxcblxcdFxcdFxcdEFycmF5RWxlbWVudDogMixcXG5cXHRcXHRcXHRIYXNGcm9tVG9BcnJheTogM1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0VmVyc2lvbmluZzoge1xcblxcdFxcdFxcdE5vbmU6IDAsXFxuXFx0XFx0XFx0TmVlZHNVcGRhdGU6IDEsXFxuXFx0XFx0XFx0TWF0cml4V29ybGROZWVkc1VwZGF0ZTogMlxcblxcdFxcdH0sXFxuXFxuXFx0XFx0R2V0dGVyQnlCaW5kaW5nVHlwZTogW1xcblxcblxcdFxcdFxcdGZ1bmN0aW9uIGdldFZhbHVlX2RpcmVjdCggYnVmZmVyLCBvZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0YnVmZmVyWyBvZmZzZXQgXSA9IHRoaXMubm9kZVsgdGhpcy5wcm9wZXJ0eU5hbWUgXTtcXG5cXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdGZ1bmN0aW9uIGdldFZhbHVlX2FycmF5KCBidWZmZXIsIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgc291cmNlID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5O1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbiA9IHNvdXJjZS5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YnVmZmVyWyBvZmZzZXQgKysgXSA9IHNvdXJjZVsgaSBdO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdGZ1bmN0aW9uIGdldFZhbHVlX2FycmF5RWxlbWVudCggYnVmZmVyLCBvZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0YnVmZmVyWyBvZmZzZXQgXSA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eVsgdGhpcy5wcm9wZXJ0eUluZGV4IF07XFxuXFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRmdW5jdGlvbiBnZXRWYWx1ZV90b0FycmF5KCBidWZmZXIsIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnJlc29sdmVkUHJvcGVydHkudG9BcnJheSggYnVmZmVyLCBvZmZzZXQgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XSxcXG5cXG5cXHRcXHRTZXR0ZXJCeUJpbmRpbmdUeXBlQW5kVmVyc2lvbmluZzogW1xcblxcblxcdFxcdFxcdFtcXG5cXHRcXHRcXHRcXHQvLyBEaXJlY3RcXG5cXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiBzZXRWYWx1ZV9kaXJlY3QoIGJ1ZmZlciwgb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMudGFyZ2V0T2JqZWN0WyB0aGlzLnByb3BlcnR5TmFtZSBdID0gYnVmZmVyWyBvZmZzZXQgXTtcXG5cXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uIHNldFZhbHVlX2RpcmVjdF9zZXROZWVkc1VwZGF0ZSggYnVmZmVyLCBvZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy50YXJnZXRPYmplY3RbIHRoaXMucHJvcGVydHlOYW1lIF0gPSBidWZmZXJbIG9mZnNldCBdO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMudGFyZ2V0T2JqZWN0Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uIHNldFZhbHVlX2RpcmVjdF9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnRhcmdldE9iamVjdFsgdGhpcy5wcm9wZXJ0eU5hbWUgXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy50YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdF0sIFtcXG5cXG5cXHRcXHRcXHRcXHQvLyBFbnRpcmVBcnJheVxcblxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uIHNldFZhbHVlX2FycmF5KCBidWZmZXIsIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgZGVzdCA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBkZXN0Lmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRkZXN0WyBpIF0gPSBidWZmZXJbIG9mZnNldCArKyBdO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uIHNldFZhbHVlX2FycmF5X3NldE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgZGVzdCA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBkZXN0Lmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRkZXN0WyBpIF0gPSBidWZmZXJbIG9mZnNldCArKyBdO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiBzZXRWYWx1ZV9hcnJheV9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgZGVzdCA9IHRoaXMucmVzb2x2ZWRQcm9wZXJ0eTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBkZXN0Lmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRkZXN0WyBpIF0gPSBidWZmZXJbIG9mZnNldCArKyBdO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XSwgW1xcblxcblxcdFxcdFxcdFxcdC8vIEFycmF5RWxlbWVudFxcblxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uIHNldFZhbHVlX2FycmF5RWxlbWVudCggYnVmZmVyLCBvZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XFxuXFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiBzZXRWYWx1ZV9hcnJheUVsZW1lbnRfc2V0TmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eVsgdGhpcy5wcm9wZXJ0eUluZGV4IF0gPSBidWZmZXJbIG9mZnNldCBdO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMudGFyZ2V0T2JqZWN0Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uIHNldFZhbHVlX2FycmF5RWxlbWVudF9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnJlc29sdmVkUHJvcGVydHlbIHRoaXMucHJvcGVydHlJbmRleCBdID0gYnVmZmVyWyBvZmZzZXQgXTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XSwgW1xcblxcblxcdFxcdFxcdFxcdC8vIEhhc1RvRnJvbUFycmF5XFxuXFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24gc2V0VmFsdWVfZnJvbUFycmF5KCBidWZmZXIsIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnJlc29sdmVkUHJvcGVydHkuZnJvbUFycmF5KCBidWZmZXIsIG9mZnNldCApO1xcblxcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24gc2V0VmFsdWVfZnJvbUFycmF5X3NldE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnJlc29sdmVkUHJvcGVydHkuZnJvbUFycmF5KCBidWZmZXIsIG9mZnNldCApO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMudGFyZ2V0T2JqZWN0Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uIHNldFZhbHVlX2Zyb21BcnJheV9zZXRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnJlc29sdmVkUHJvcGVydHkuZnJvbUFycmF5KCBidWZmZXIsIG9mZnNldCApO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRdXFxuXFxuXFx0XFx0XSxcXG5cXG5cXHRcXHRnZXRWYWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWVfdW5ib3VuZCggdGFyZ2V0QXJyYXksIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmJpbmQoKTtcXG5cXHRcXHRcXHR0aGlzLmdldFZhbHVlKCB0YXJnZXRBcnJheSwgb2Zmc2V0ICk7XFxuXFxuXFx0XFx0XFx0Ly8gTm90ZTogVGhpcyBjbGFzcyB1c2VzIGEgU3RhdGUgcGF0dGVybiBvbiBhIHBlci1tZXRob2QgYmFzaXM6XFxuXFx0XFx0XFx0Ly8gJ2JpbmQnIHNldHMgJ3RoaXMuZ2V0VmFsdWUnIC8gJ3NldFZhbHVlJyBhbmQgc2hhZG93cyB0aGVcXG5cXHRcXHRcXHQvLyBwcm90b3R5cGUgdmVyc2lvbiBvZiB0aGVzZSBtZXRob2RzIHdpdGggb25lIHRoYXQgcmVwcmVzZW50c1xcblxcdFxcdFxcdC8vIHRoZSBib3VuZCBzdGF0ZS4gV2hlbiB0aGUgcHJvcGVydHkgaXMgbm90IGZvdW5kLCB0aGUgbWV0aG9kc1xcblxcdFxcdFxcdC8vIGJlY29tZSBuby1vcHMuXFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRWYWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWVfdW5ib3VuZCggc291cmNlQXJyYXksIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmJpbmQoKTtcXG5cXHRcXHRcXHR0aGlzLnNldFZhbHVlKCBzb3VyY2VBcnJheSwgb2Zmc2V0ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBjcmVhdGUgZ2V0dGVyIC8gc2V0dGVyIHBhaXIgZm9yIGEgcHJvcGVydHkgaW4gdGhlIHNjZW5lIGdyYXBoXFxuXFx0XFx0YmluZDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB0YXJnZXRPYmplY3QgPSB0aGlzLm5vZGUsXFxuXFx0XFx0XFx0XFx0cGFyc2VkUGF0aCA9IHRoaXMucGFyc2VkUGF0aCxcXG5cXG5cXHRcXHRcXHRcXHRvYmplY3ROYW1lID0gcGFyc2VkUGF0aC5vYmplY3ROYW1lLFxcblxcdFxcdFxcdFxcdHByb3BlcnR5TmFtZSA9IHBhcnNlZFBhdGgucHJvcGVydHlOYW1lLFxcblxcdFxcdFxcdFxcdHByb3BlcnR5SW5kZXggPSBwYXJzZWRQYXRoLnByb3BlcnR5SW5kZXg7XFxuXFxuXFx0XFx0XFx0aWYgKCAhIHRhcmdldE9iamVjdCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0YXJnZXRPYmplY3QgPSBQcm9wZXJ0eUJpbmRpbmcuZmluZE5vZGUoIHRoaXMucm9vdE5vZGUsIHBhcnNlZFBhdGgubm9kZU5hbWUgKSB8fCB0aGlzLnJvb3ROb2RlO1xcblxcblxcdFxcdFxcdFxcdHRoaXMubm9kZSA9IHRhcmdldE9iamVjdDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gc2V0IGZhaWwgc3RhdGUgc28gd2UgY2FuIGp1c3QgJ3JldHVybicgb24gZXJyb3JcXG5cXHRcXHRcXHR0aGlzLmdldFZhbHVlID0gdGhpcy5fZ2V0VmFsdWVfdW5hdmFpbGFibGU7XFxuXFx0XFx0XFx0dGhpcy5zZXRWYWx1ZSA9IHRoaXMuX3NldFZhbHVlX3VuYXZhaWxhYmxlO1xcblxcblxcdFxcdFxcdC8vIGVuc3VyZSB0aGVyZSBpcyBhIHZhbHVlIG5vZGVcXG5cXHRcXHRcXHRpZiAoICEgdGFyZ2V0T2JqZWN0ICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IFRyeWluZyB0byB1cGRhdGUgbm9kZSBmb3IgdHJhY2s6ICcgKyB0aGlzLnBhdGggKyAnIGJ1dCBpdCB3YXNuXFxcXCd0IGZvdW5kLicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggb2JqZWN0TmFtZSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgb2JqZWN0SW5kZXggPSBwYXJzZWRQYXRoLm9iamVjdEluZGV4O1xcblxcblxcdFxcdFxcdFxcdC8vIHNwZWNpYWwgY2FzZXMgd2VyZSB3ZSBuZWVkIHRvIHJlYWNoIGRlZXBlciBpbnRvIHRoZSBoaWVyYXJjaHkgdG8gZ2V0IHRoZSBmYWNlIG1hdGVyaWFscy4uLi5cXG5cXHRcXHRcXHRcXHRzd2l0Y2ggKCBvYmplY3ROYW1lICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hdGVyaWFscyc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCAhIHRhcmdldE9iamVjdC5tYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gbWF0ZXJpYWwgYXMgbm9kZSBkb2VzIG5vdCBoYXZlIGEgbWF0ZXJpYWwuJywgdGhpcyApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCAhIHRhcmdldE9iamVjdC5tYXRlcmlhbC5tYXRlcmlhbHMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIG1hdGVyaWFsLm1hdGVyaWFscyBhcyBub2RlLm1hdGVyaWFsIGRvZXMgbm90IGhhdmUgYSBtYXRlcmlhbHMgYXJyYXkuJywgdGhpcyApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0Lm1hdGVyaWFsLm1hdGVyaWFscztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdib25lcyc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCAhIHRhcmdldE9iamVjdC5za2VsZXRvbiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gYm9uZXMgYXMgbm9kZSBkb2VzIG5vdCBoYXZlIGEgc2tlbGV0b24uJywgdGhpcyApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gcG90ZW50aWFsIGZ1dHVyZSBvcHRpbWl6YXRpb246IHNraXAgdGhpcyBpZiBwcm9wZXJ0eUluZGV4IGlzIGFscmVhZHkgYW4gaW50ZWdlclxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGFuZCBjb252ZXJ0IHRoZSBpbnRlZ2VyIHN0cmluZyB0byBhIHRydWUgaW50ZWdlci5cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3Quc2tlbGV0b24uYm9uZXM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gc3VwcG9ydCByZXNvbHZpbmcgbW9ycGhUYXJnZXQgbmFtZXMgaW50byBpbmRpY2VzLlxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IHRhcmdldE9iamVjdC5sZW5ndGg7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB0YXJnZXRPYmplY3RbIGkgXS5uYW1lID09PSBvYmplY3RJbmRleCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRvYmplY3RJbmRleCA9IGk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRkZWZhdWx0OlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggdGFyZ2V0T2JqZWN0WyBvYmplY3ROYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gb2JqZWN0TmFtZSBvZiBub2RlIHVuZGVmaW5lZC4nLCB0aGlzICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3RbIG9iamVjdE5hbWUgXTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBvYmplY3RJbmRleCAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggdGFyZ2V0T2JqZWN0WyBvYmplY3RJbmRleCBdID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb3BlcnR5QmluZGluZzogVHJ5aW5nIHRvIGJpbmQgdG8gb2JqZWN0SW5kZXggb2Ygb2JqZWN0TmFtZSwgYnV0IGlzIHVuZGVmaW5lZC4nLCB0aGlzLCB0YXJnZXRPYmplY3QgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdFsgb2JqZWN0SW5kZXggXTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIHJlc29sdmUgcHJvcGVydHlcXG5cXHRcXHRcXHR2YXIgbm9kZVByb3BlcnR5ID0gdGFyZ2V0T2JqZWN0WyBwcm9wZXJ0eU5hbWUgXTtcXG5cXG5cXHRcXHRcXHRpZiAoIG5vZGVQcm9wZXJ0eSA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBub2RlTmFtZSA9IHBhcnNlZFBhdGgubm9kZU5hbWU7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb3BlcnR5QmluZGluZzogVHJ5aW5nIHRvIHVwZGF0ZSBwcm9wZXJ0eSBmb3IgdHJhY2s6ICcgKyBub2RlTmFtZSArXFxuXFx0XFx0XFx0XFx0XFx0Jy4nICsgcHJvcGVydHlOYW1lICsgJyBidXQgaXQgd2FzblxcXFwndCBmb3VuZC4nLCB0YXJnZXRPYmplY3QgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGRldGVybWluZSB2ZXJzaW9uaW5nIHNjaGVtZVxcblxcdFxcdFxcdHZhciB2ZXJzaW9uaW5nID0gdGhpcy5WZXJzaW9uaW5nLk5vbmU7XFxuXFxuXFx0XFx0XFx0aWYgKCB0YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgIT09IHVuZGVmaW5lZCApIHsgLy8gbWF0ZXJpYWxcXG5cXG5cXHRcXHRcXHRcXHR2ZXJzaW9uaW5nID0gdGhpcy5WZXJzaW9uaW5nLk5lZWRzVXBkYXRlO1xcblxcdFxcdFxcdFxcdHRoaXMudGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0O1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIHRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlICE9PSB1bmRlZmluZWQgKSB7IC8vIG5vZGUgdHJhbnNmb3JtXFxuXFxuXFx0XFx0XFx0XFx0dmVyc2lvbmluZyA9IHRoaXMuVmVyc2lvbmluZy5NYXRyaXhXb3JsZE5lZWRzVXBkYXRlO1xcblxcdFxcdFxcdFxcdHRoaXMudGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBkZXRlcm1pbmUgaG93IHRoZSBwcm9wZXJ0eSBnZXRzIGJvdW5kXFxuXFx0XFx0XFx0dmFyIGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5EaXJlY3Q7XFxuXFxuXFx0XFx0XFx0aWYgKCBwcm9wZXJ0eUluZGV4ICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gYWNjZXNzIGEgc3ViIGVsZW1lbnQgb2YgdGhlIHByb3BlcnR5IGFycmF5IChvbmx5IHByaW1pdGl2ZXMgYXJlIHN1cHBvcnRlZCByaWdodCBub3cpXFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBwcm9wZXJ0eU5hbWUgPT09IFxcXCJtb3JwaFRhcmdldEluZmx1ZW5jZXNcXFwiICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIHBvdGVudGlhbCBvcHRpbWl6YXRpb24sIHNraXAgdGhpcyBpZiBwcm9wZXJ0eUluZGV4IGlzIGFscmVhZHkgYW4gaW50ZWdlciwgYW5kIGNvbnZlcnQgdGhlIGludGVnZXIgc3RyaW5nIHRvIGEgdHJ1ZSBpbnRlZ2VyLlxcblxcblxcdFxcdFxcdFxcdFxcdC8vIHN1cHBvcnQgcmVzb2x2aW5nIG1vcnBoVGFyZ2V0IG5hbWVzIGludG8gaW5kaWNlcy5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoICEgdGFyZ2V0T2JqZWN0Lmdlb21ldHJ5ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBtb3JwaFRhcmdldEluZmx1ZW5jZXMgYmVjYXVzZSBub2RlIGRvZXMgbm90IGhhdmUgYSBnZW9tZXRyeS4nLCB0aGlzICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHRhcmdldE9iamVjdC5nZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggISB0YXJnZXRPYmplY3QuZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBtb3JwaFRhcmdldEluZmx1ZW5jZXMgYmVjYXVzZSBub2RlIGRvZXMgbm90IGhhdmUgYSBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMuJywgdGhpcyApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5ub2RlLmdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbi5sZW5ndGg7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB0YXJnZXRPYmplY3QuZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uWyBpIF0ubmFtZSA9PT0gcHJvcGVydHlJbmRleCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwcm9wZXJ0eUluZGV4ID0gaTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCAhIHRhcmdldE9iamVjdC5nZW9tZXRyeS5tb3JwaFRhcmdldHMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyBiZWNhdXNlIG5vZGUgZG9lcyBub3QgaGF2ZSBhIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy4nLCB0aGlzICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLm5vZGUuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHRhcmdldE9iamVjdC5nZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS5uYW1lID09PSBwcm9wZXJ0eUluZGV4ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHByb3BlcnR5SW5kZXggPSBpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRiaW5kaW5nVHlwZSA9IHRoaXMuQmluZGluZ1R5cGUuQXJyYXlFbGVtZW50O1xcblxcblxcdFxcdFxcdFxcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eSA9IG5vZGVQcm9wZXJ0eTtcXG5cXHRcXHRcXHRcXHR0aGlzLnByb3BlcnR5SW5kZXggPSBwcm9wZXJ0eUluZGV4O1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG5vZGVQcm9wZXJ0eS5mcm9tQXJyYXkgIT09IHVuZGVmaW5lZCAmJiBub2RlUHJvcGVydHkudG9BcnJheSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdC8vIG11c3QgdXNlIGNvcHkgZm9yIE9iamVjdDNELkV1bGVyL1F1YXRlcm5pb25cXG5cXG5cXHRcXHRcXHRcXHRiaW5kaW5nVHlwZSA9IHRoaXMuQmluZGluZ1R5cGUuSGFzRnJvbVRvQXJyYXk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5ID0gbm9kZVByb3BlcnR5O1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIEFycmF5LmlzQXJyYXkoIG5vZGVQcm9wZXJ0eSApICkge1xcblxcblxcdFxcdFxcdFxcdGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5FbnRpcmVBcnJheTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnJlc29sdmVkUHJvcGVydHkgPSBub2RlUHJvcGVydHk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gc2VsZWN0IGdldHRlciAvIHNldHRlclxcblxcdFxcdFxcdHRoaXMuZ2V0VmFsdWUgPSB0aGlzLkdldHRlckJ5QmluZGluZ1R5cGVbIGJpbmRpbmdUeXBlIF07XFxuXFx0XFx0XFx0dGhpcy5zZXRWYWx1ZSA9IHRoaXMuU2V0dGVyQnlCaW5kaW5nVHlwZUFuZFZlcnNpb25pbmdbIGJpbmRpbmdUeXBlIF1bIHZlcnNpb25pbmcgXTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHVuYmluZDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMubm9kZSA9IG51bGw7XFxuXFxuXFx0XFx0XFx0Ly8gYmFjayB0byB0aGUgcHJvdG90eXBlIHZlcnNpb24gb2YgZ2V0VmFsdWUgLyBzZXRWYWx1ZVxcblxcdFxcdFxcdC8vIG5vdGU6IGF2b2lkaW5nIHRvIG11dGF0ZSB0aGUgc2hhcGUgb2YgJ3RoaXMnIHZpYSAnZGVsZXRlJ1xcblxcdFxcdFxcdHRoaXMuZ2V0VmFsdWUgPSB0aGlzLl9nZXRWYWx1ZV91bmJvdW5kO1xcblxcdFxcdFxcdHRoaXMuc2V0VmFsdWUgPSB0aGlzLl9zZXRWYWx1ZV91bmJvdW5kO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0Ly8hXFxcXCBERUNMQVJFIEFMSUFTIEFGVEVSIGFzc2lnbiBwcm90b3R5cGUgIVxcblxcdE9iamVjdC5hc3NpZ24oIFByb3BlcnR5QmluZGluZy5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHQvLyBpbml0aWFsIHN0YXRlIG9mIHRoZXNlIG1ldGhvZHMgdGhhdCBjYWxscyAnYmluZCdcXG5cXHRcXHRfZ2V0VmFsdWVfdW5ib3VuZDogUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5nZXRWYWx1ZSxcXG5cXHRcXHRfc2V0VmFsdWVfdW5ib3VuZDogUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZS5zZXRWYWx1ZSxcXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICpcXG5cXHQgKiBBIGdyb3VwIG9mIG9iamVjdHMgdGhhdCByZWNlaXZlcyBhIHNoYXJlZCBhbmltYXRpb24gc3RhdGUuXFxuXFx0ICpcXG5cXHQgKiBVc2FnZTpcXG5cXHQgKlxcblxcdCAqIFxcdC1cXHRBZGQgb2JqZWN0cyB5b3Ugd291bGQgb3RoZXJ3aXNlIHBhc3MgYXMgJ3Jvb3QnIHRvIHRoZVxcblxcdCAqIFxcdFxcdGNvbnN0cnVjdG9yIG9yIHRoZSAuY2xpcEFjdGlvbiBtZXRob2Qgb2YgQW5pbWF0aW9uTWl4ZXIuXFxuXFx0ICpcXG5cXHQgKiBcXHQtXFx0SW5zdGVhZCBwYXNzIHRoaXMgb2JqZWN0IGFzICdyb290Jy5cXG5cXHQgKlxcblxcdCAqIFxcdC1cXHRZb3UgY2FuIGFsc28gYWRkIGFuZCByZW1vdmUgb2JqZWN0cyBsYXRlciB3aGVuIHRoZSBtaXhlclxcblxcdCAqIFxcdFxcdGlzIHJ1bm5pbmcuXFxuXFx0ICpcXG5cXHQgKiBOb3RlOlxcblxcdCAqXFxuXFx0ICogIFxcdE9iamVjdHMgb2YgdGhpcyBjbGFzcyBhcHBlYXIgYXMgb25lIG9iamVjdCB0byB0aGUgbWl4ZXIsXFxuXFx0ICogIFxcdHNvIGNhY2hlIGNvbnRyb2wgb2YgdGhlIGluZGl2aWR1YWwgb2JqZWN0cyBtdXN0IGJlIGRvbmVcXG5cXHQgKiAgXFx0b24gdGhlIGdyb3VwLlxcblxcdCAqXFxuXFx0ICogTGltaXRhdGlvbjpcXG5cXHQgKlxcblxcdCAqIFxcdC0gXFx0VGhlIGFuaW1hdGVkIHByb3BlcnRpZXMgbXVzdCBiZSBjb21wYXRpYmxlIGFtb25nIHRoZVxcblxcdCAqIFxcdFxcdGFsbCBvYmplY3RzIGluIHRoZSBncm91cC5cXG5cXHQgKlxcblxcdCAqICAtXFx0QSBzaW5nbGUgcHJvcGVydHkgY2FuIGVpdGhlciBiZSBjb250cm9sbGVkIHRocm91Z2ggYVxcblxcdCAqICBcXHR0YXJnZXQgZ3JvdXAgb3IgZGlyZWN0bHksIGJ1dCBub3QgYm90aC5cXG5cXHQgKlxcblxcdCAqIEBhdXRob3IgdHNjaHdcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBBbmltYXRpb25PYmplY3RHcm91cCgpIHtcXG5cXG5cXHRcXHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcXG5cXG5cXHRcXHQvLyBjYWNoZWQgb2JqZWN0cyBmb2xsb3dlZCBieSB0aGUgYWN0aXZlIG9uZXNcXG5cXHRcXHR0aGlzLl9vYmplY3RzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xcblxcblxcdFxcdHRoaXMubkNhY2hlZE9iamVjdHNfID0gMDtcXHRcXHRcXHQvLyB0aHJlc2hvbGRcXG5cXHRcXHQvLyBub3RlOiByZWFkIGJ5IFByb3BlcnR5QmluZGluZy5Db21wb3NpdGVcXG5cXG5cXHRcXHR2YXIgaW5kaWNlcyA9IHt9O1xcblxcdFxcdHRoaXMuX2luZGljZXNCeVVVSUQgPSBpbmRpY2VzO1xcdFxcdC8vIGZvciBib29ra2VlcGluZ1xcblxcblxcdFxcdGZvciAoIHZhciBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0aW5kaWNlc1sgYXJndW1lbnRzWyBpIF0udXVpZCBdID0gaTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5fcGF0aHMgPSBbXTtcXHRcXHRcXHRcXHRcXHQvLyBpbnNpZGU6IHN0cmluZ1xcblxcdFxcdHRoaXMuX3BhcnNlZFBhdGhzID0gW107XFx0XFx0XFx0XFx0Ly8gaW5zaWRlOiB7IHdlIGRvbid0IGNhcmUsIGhlcmUgfVxcblxcdFxcdHRoaXMuX2JpbmRpbmdzID0gW107IFxcdFxcdFxcdFxcdC8vIGluc2lkZTogQXJyYXk8IFByb3BlcnR5QmluZGluZyA+XFxuXFx0XFx0dGhpcy5fYmluZGluZ3NJbmRpY2VzQnlQYXRoID0ge307IFxcdC8vIGluc2lkZTogaW5kaWNlcyBpbiB0aGVzZSBhcnJheXNcXG5cXG5cXHRcXHR2YXIgc2NvcGUgPSB0aGlzO1xcblxcblxcdFxcdHRoaXMuc3RhdHMgPSB7XFxuXFxuXFx0XFx0XFx0b2JqZWN0czoge1xcblxcdFxcdFxcdFxcdGdldCB0b3RhbCgpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gc2NvcGUuX29iamVjdHMubGVuZ3RoO1xcblxcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0Z2V0IGluVXNlKCkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnRvdGFsIC0gc2NvcGUubkNhY2hlZE9iamVjdHNfO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGdldCBiaW5kaW5nc1Blck9iamVjdCgpIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gc2NvcGUuX2JpbmRpbmdzLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggQW5pbWF0aW9uT2JqZWN0R3JvdXAucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0aXNBbmltYXRpb25PYmplY3RHcm91cDogdHJ1ZSxcXG5cXG5cXHRcXHRhZGQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXFxuXFx0XFx0XFx0XFx0bk9iamVjdHMgPSBvYmplY3RzLmxlbmd0aCxcXG5cXHRcXHRcXHRcXHRuQ2FjaGVkT2JqZWN0cyA9IHRoaXMubkNhY2hlZE9iamVjdHNfLFxcblxcdFxcdFxcdFxcdGluZGljZXNCeVVVSUQgPSB0aGlzLl9pbmRpY2VzQnlVVUlELFxcblxcdFxcdFxcdFxcdHBhdGhzID0gdGhpcy5fcGF0aHMsXFxuXFx0XFx0XFx0XFx0cGFyc2VkUGF0aHMgPSB0aGlzLl9wYXJzZWRQYXRocyxcXG5cXHRcXHRcXHRcXHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxcblxcdFxcdFxcdFxcdG5CaW5kaW5ncyA9IGJpbmRpbmdzLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBvYmplY3QgPSBhcmd1bWVudHNbIGkgXSxcXG5cXHRcXHRcXHRcXHRcXHR1dWlkID0gb2JqZWN0LnV1aWQsXFxuXFx0XFx0XFx0XFx0XFx0aW5kZXggPSBpbmRpY2VzQnlVVUlEWyB1dWlkIF0sXFxuXFx0XFx0XFx0XFx0XFx0a25vd25PYmplY3QgPSB1bmRlZmluZWQ7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBpbmRleCA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIHVua25vd24gb2JqZWN0IC0+IGFkZCBpdCB0byB0aGUgQUNUSVZFIHJlZ2lvblxcblxcblxcdFxcdFxcdFxcdFxcdGluZGV4ID0gbk9iamVjdHMgKys7XFxuXFx0XFx0XFx0XFx0XFx0aW5kaWNlc0J5VVVJRFsgdXVpZCBdID0gaW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0b2JqZWN0cy5wdXNoKCBvYmplY3QgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArKyBqICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGJpbmRpbmdzWyBqIF0ucHVzaCggbmV3IFByb3BlcnR5QmluZGluZyggb2JqZWN0LCBwYXRoc1sgaiBdLCBwYXJzZWRQYXRoc1sgaiBdICkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggaW5kZXggPCBuQ2FjaGVkT2JqZWN0cyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRrbm93bk9iamVjdCA9IG9iamVjdHNbIGluZGV4IF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gbW92ZSBleGlzdGluZyBvYmplY3QgdG8gdGhlIEFDVElWRSByZWdpb25cXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgZmlyc3RBY3RpdmVJbmRleCA9IC0tIG5DYWNoZWRPYmplY3RzLFxcblxcdFxcdFxcdFxcdFxcdFxcdGxhc3RDYWNoZWRPYmplY3QgPSBvYmplY3RzWyBmaXJzdEFjdGl2ZUluZGV4IF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0aW5kaWNlc0J5VVVJRFsgbGFzdENhY2hlZE9iamVjdC51dWlkIF0gPSBpbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRvYmplY3RzWyBpbmRleCBdID0gbGFzdENhY2hlZE9iamVjdDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpbmRpY2VzQnlVVUlEWyB1dWlkIF0gPSBmaXJzdEFjdGl2ZUluZGV4O1xcblxcdFxcdFxcdFxcdFxcdG9iamVjdHNbIGZpcnN0QWN0aXZlSW5kZXggXSA9IG9iamVjdDtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArKyBqICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBiaW5kaW5nc0ZvclBhdGggPSBiaW5kaW5nc1sgaiBdLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGxhc3RDYWNoZWQgPSBiaW5kaW5nc0ZvclBhdGhbIGZpcnN0QWN0aXZlSW5kZXggXSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRiaW5kaW5nID0gYmluZGluZ3NGb3JQYXRoWyBpbmRleCBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXSA9IGxhc3RDYWNoZWQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBiaW5kaW5nID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gc2luY2Ugd2UgZG8gbm90IGJvdGhlciB0byBjcmVhdGUgbmV3IGJpbmRpbmdzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gZm9yIG9iamVjdHMgdGhhdCBhcmUgY2FjaGVkLCB0aGUgYmluZGluZyBtYXlcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBvciBtYXkgbm90IGV4aXN0XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YmluZGluZyA9IG5ldyBQcm9wZXJ0eUJpbmRpbmcoIG9iamVjdCwgcGF0aHNbIGogXSwgcGFyc2VkUGF0aHNbIGogXSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRiaW5kaW5nc0ZvclBhdGhbIGZpcnN0QWN0aXZlSW5kZXggXSA9IGJpbmRpbmc7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIG9iamVjdHNbIGluZGV4IF0gIT09IGtub3duT2JqZWN0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5BbmltYXRpb25PYmplY3RHcm91cDogRGlmZmVyZW50IG9iamVjdHMgd2l0aCB0aGUgc2FtZSBVVUlEICcgK1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCdkZXRlY3RlZC4gQ2xlYW4gdGhlIGNhY2hlcyBvciByZWNyZWF0ZSB5b3VyIGluZnJhc3RydWN0dXJlIHdoZW4gcmVsb2FkaW5nIHNjZW5lcy4nICk7XFxuXFxuXFx0XFx0XFx0XFx0fSAvLyBlbHNlIHRoZSBvYmplY3QgaXMgYWxyZWFkeSB3aGVyZSB3ZSB3YW50IGl0IHRvIGJlXFxuXFxuXFx0XFx0XFx0fSAvLyBmb3IgYXJndW1lbnRzXFxuXFxuXFx0XFx0XFx0dGhpcy5uQ2FjaGVkT2JqZWN0c18gPSBuQ2FjaGVkT2JqZWN0cztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHJlbW92ZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBvYmplY3RzID0gdGhpcy5fb2JqZWN0cyxcXG5cXHRcXHRcXHRcXHRuQ2FjaGVkT2JqZWN0cyA9IHRoaXMubkNhY2hlZE9iamVjdHNfLFxcblxcdFxcdFxcdFxcdGluZGljZXNCeVVVSUQgPSB0aGlzLl9pbmRpY2VzQnlVVUlELFxcblxcdFxcdFxcdFxcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXFxuXFx0XFx0XFx0XFx0bkJpbmRpbmdzID0gYmluZGluZ3MubGVuZ3RoO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG9iamVjdCA9IGFyZ3VtZW50c1sgaSBdLFxcblxcdFxcdFxcdFxcdFxcdHV1aWQgPSBvYmplY3QudXVpZCxcXG5cXHRcXHRcXHRcXHRcXHRpbmRleCA9IGluZGljZXNCeVVVSURbIHV1aWQgXTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgJiYgaW5kZXggPj0gbkNhY2hlZE9iamVjdHMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gbW92ZSBleGlzdGluZyBvYmplY3QgaW50byB0aGUgQ0FDSEVEIHJlZ2lvblxcblxcblxcdFxcdFxcdFxcdFxcdHZhciBsYXN0Q2FjaGVkSW5kZXggPSBuQ2FjaGVkT2JqZWN0cyArKyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRmaXJzdEFjdGl2ZU9iamVjdCA9IG9iamVjdHNbIGxhc3RDYWNoZWRJbmRleCBdO1xcblxcblxcdFxcdFxcdFxcdFxcdGluZGljZXNCeVVVSURbIGZpcnN0QWN0aXZlT2JqZWN0LnV1aWQgXSA9IGluZGV4O1xcblxcdFxcdFxcdFxcdFxcdG9iamVjdHNbIGluZGV4IF0gPSBmaXJzdEFjdGl2ZU9iamVjdDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpbmRpY2VzQnlVVUlEWyB1dWlkIF0gPSBsYXN0Q2FjaGVkSW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0b2JqZWN0c1sgbGFzdENhY2hlZEluZGV4IF0gPSBvYmplY3Q7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKysgaiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgYmluZGluZ3NGb3JQYXRoID0gYmluZGluZ3NbIGogXSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmaXJzdEFjdGl2ZSA9IGJpbmRpbmdzRm9yUGF0aFsgbGFzdENhY2hlZEluZGV4IF0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YmluZGluZyA9IGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRiaW5kaW5nc0ZvclBhdGhbIGluZGV4IF0gPSBmaXJzdEFjdGl2ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRiaW5kaW5nc0ZvclBhdGhbIGxhc3RDYWNoZWRJbmRleCBdID0gYmluZGluZztcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH0gLy8gZm9yIGFyZ3VtZW50c1xcblxcblxcdFxcdFxcdHRoaXMubkNhY2hlZE9iamVjdHNfID0gbkNhY2hlZE9iamVjdHM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyByZW1vdmUgJiBmb3JnZXRcXG5cXHRcXHR1bmNhY2hlOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxcblxcdFxcdFxcdFxcdG5PYmplY3RzID0gb2JqZWN0cy5sZW5ndGgsXFxuXFx0XFx0XFx0XFx0bkNhY2hlZE9iamVjdHMgPSB0aGlzLm5DYWNoZWRPYmplY3RzXyxcXG5cXHRcXHRcXHRcXHRpbmRpY2VzQnlVVUlEID0gdGhpcy5faW5kaWNlc0J5VVVJRCxcXG5cXHRcXHRcXHRcXHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxcblxcdFxcdFxcdFxcdG5CaW5kaW5ncyA9IGJpbmRpbmdzLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBvYmplY3QgPSBhcmd1bWVudHNbIGkgXSxcXG5cXHRcXHRcXHRcXHRcXHR1dWlkID0gb2JqZWN0LnV1aWQsXFxuXFx0XFx0XFx0XFx0XFx0aW5kZXggPSBpbmRpY2VzQnlVVUlEWyB1dWlkIF07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGRlbGV0ZSBpbmRpY2VzQnlVVUlEWyB1dWlkIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBpbmRleCA8IG5DYWNoZWRPYmplY3RzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIG9iamVjdCBpcyBjYWNoZWQsIHNocmluayB0aGUgQ0FDSEVEIHJlZ2lvblxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBmaXJzdEFjdGl2ZUluZGV4ID0gLS0gbkNhY2hlZE9iamVjdHMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bGFzdENhY2hlZE9iamVjdCA9IG9iamVjdHNbIGZpcnN0QWN0aXZlSW5kZXggXSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRsYXN0SW5kZXggPSAtLSBuT2JqZWN0cyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRsYXN0T2JqZWN0ID0gb2JqZWN0c1sgbGFzdEluZGV4IF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gbGFzdCBjYWNoZWQgb2JqZWN0IHRha2VzIHRoaXMgb2JqZWN0J3MgcGxhY2VcXG5cXHRcXHRcXHRcXHRcXHRcXHRpbmRpY2VzQnlVVUlEWyBsYXN0Q2FjaGVkT2JqZWN0LnV1aWQgXSA9IGluZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdHNbIGluZGV4IF0gPSBsYXN0Q2FjaGVkT2JqZWN0O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGxhc3Qgb2JqZWN0IGdvZXMgdG8gdGhlIGFjdGl2YXRlZCBzbG90IGFuZCBwb3BcXG5cXHRcXHRcXHRcXHRcXHRcXHRpbmRpY2VzQnlVVUlEWyBsYXN0T2JqZWN0LnV1aWQgXSA9IGZpcnN0QWN0aXZlSW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0c1sgZmlyc3RBY3RpdmVJbmRleCBdID0gbGFzdE9iamVjdDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRvYmplY3RzLnBvcCgpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsrIGogKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzWyBqIF0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bGFzdENhY2hlZCA9IGJpbmRpbmdzRm9yUGF0aFsgZmlyc3RBY3RpdmVJbmRleCBdLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGxhc3QgPSBiaW5kaW5nc0ZvclBhdGhbIGxhc3RJbmRleCBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXSA9IGxhc3RDYWNoZWQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YmluZGluZ3NGb3JQYXRoWyBmaXJzdEFjdGl2ZUluZGV4IF0gPSBsYXN0O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJpbmRpbmdzRm9yUGF0aC5wb3AoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBvYmplY3QgaXMgYWN0aXZlLCBqdXN0IHN3YXAgd2l0aCB0aGUgbGFzdCBhbmQgcG9wXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGxhc3RJbmRleCA9IC0tIG5PYmplY3RzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGxhc3RPYmplY3QgPSBvYmplY3RzWyBsYXN0SW5kZXggXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpbmRpY2VzQnlVVUlEWyBsYXN0T2JqZWN0LnV1aWQgXSA9IGluZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdHNbIGluZGV4IF0gPSBsYXN0T2JqZWN0O1xcblxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdHMucG9wKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKysgaiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgYmluZGluZ3NGb3JQYXRoID0gYmluZGluZ3NbIGogXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRiaW5kaW5nc0ZvclBhdGhbIGluZGV4IF0gPSBiaW5kaW5nc0ZvclBhdGhbIGxhc3RJbmRleCBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJpbmRpbmdzRm9yUGF0aC5wb3AoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSAvLyBjYWNoZWQgb3IgYWN0aXZlXFxuXFxuXFx0XFx0XFx0XFx0fSAvLyBpZiBvYmplY3QgaXMga25vd25cXG5cXG5cXHRcXHRcXHR9IC8vIGZvciBhcmd1bWVudHNcXG5cXG5cXHRcXHRcXHR0aGlzLm5DYWNoZWRPYmplY3RzXyA9IG5DYWNoZWRPYmplY3RzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gSW50ZXJuYWwgaW50ZXJmYWNlIHVzZWQgYnkgYmVmcmllbmRlZCBQcm9wZXJ0eUJpbmRpbmcuQ29tcG9zaXRlOlxcblxcblxcdFxcdHN1YnNjcmliZV86IGZ1bmN0aW9uICggcGF0aCwgcGFyc2VkUGF0aCApIHtcXG5cXG5cXHRcXHRcXHQvLyByZXR1cm5zIGFuIGFycmF5IG9mIGJpbmRpbmdzIGZvciB0aGUgZ2l2ZW4gcGF0aCB0aGF0IGlzIGNoYW5nZWRcXG5cXHRcXHRcXHQvLyBhY2NvcmRpbmcgdG8gdGhlIGNvbnRhaW5lZCBvYmplY3RzIGluIHRoZSBncm91cFxcblxcblxcdFxcdFxcdHZhciBpbmRpY2VzQnlQYXRoID0gdGhpcy5fYmluZGluZ3NJbmRpY2VzQnlQYXRoLFxcblxcdFxcdFxcdFxcdGluZGV4ID0gaW5kaWNlc0J5UGF0aFsgcGF0aCBdLFxcblxcdFxcdFxcdFxcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XFxuXFxuXFx0XFx0XFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkgcmV0dXJuIGJpbmRpbmdzWyBpbmRleCBdO1xcblxcblxcdFxcdFxcdHZhciBwYXRocyA9IHRoaXMuX3BhdGhzLFxcblxcdFxcdFxcdFxcdHBhcnNlZFBhdGhzID0gdGhpcy5fcGFyc2VkUGF0aHMsXFxuXFx0XFx0XFx0XFx0b2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXFxuXFx0XFx0XFx0XFx0bk9iamVjdHMgPSBvYmplY3RzLmxlbmd0aCxcXG5cXHRcXHRcXHRcXHRuQ2FjaGVkT2JqZWN0cyA9IHRoaXMubkNhY2hlZE9iamVjdHNfLFxcblxcdFxcdFxcdFxcdGJpbmRpbmdzRm9yUGF0aCA9IG5ldyBBcnJheSggbk9iamVjdHMgKTtcXG5cXG5cXHRcXHRcXHRpbmRleCA9IGJpbmRpbmdzLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRpbmRpY2VzQnlQYXRoWyBwYXRoIF0gPSBpbmRleDtcXG5cXG5cXHRcXHRcXHRwYXRocy5wdXNoKCBwYXRoICk7XFxuXFx0XFx0XFx0cGFyc2VkUGF0aHMucHVzaCggcGFyc2VkUGF0aCApO1xcblxcdFxcdFxcdGJpbmRpbmdzLnB1c2goIGJpbmRpbmdzRm9yUGF0aCApO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gbkNhY2hlZE9iamVjdHMsIG4gPSBvYmplY3RzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgb2JqZWN0ID0gb2JqZWN0c1sgaSBdO1xcblxcdFxcdFxcdFxcdGJpbmRpbmdzRm9yUGF0aFsgaSBdID0gbmV3IFByb3BlcnR5QmluZGluZyggb2JqZWN0LCBwYXRoLCBwYXJzZWRQYXRoICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBiaW5kaW5nc0ZvclBhdGg7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR1bnN1YnNjcmliZV86IGZ1bmN0aW9uICggcGF0aCApIHtcXG5cXG5cXHRcXHRcXHQvLyB0ZWxscyB0aGUgZ3JvdXAgdG8gZm9yZ2V0IGFib3V0IGEgcHJvcGVydHkgcGF0aCBhbmQgbm8gbG9uZ2VyXFxuXFx0XFx0XFx0Ly8gdXBkYXRlIHRoZSBhcnJheSBwcmV2aW91c2x5IG9idGFpbmVkIHdpdGggJ3N1YnNjcmliZV8nXFxuXFxuXFx0XFx0XFx0dmFyIGluZGljZXNCeVBhdGggPSB0aGlzLl9iaW5kaW5nc0luZGljZXNCeVBhdGgsXFxuXFx0XFx0XFx0XFx0aW5kZXggPSBpbmRpY2VzQnlQYXRoWyBwYXRoIF07XFxuXFxuXFx0XFx0XFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBwYXRocyA9IHRoaXMuX3BhdGhzLFxcblxcdFxcdFxcdFxcdFxcdHBhcnNlZFBhdGhzID0gdGhpcy5fcGFyc2VkUGF0aHMsXFxuXFx0XFx0XFx0XFx0XFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcXG5cXHRcXHRcXHRcXHRcXHRsYXN0QmluZGluZ3NJbmRleCA9IGJpbmRpbmdzLmxlbmd0aCAtIDEsXFxuXFx0XFx0XFx0XFx0XFx0bGFzdEJpbmRpbmdzID0gYmluZGluZ3NbIGxhc3RCaW5kaW5nc0luZGV4IF0sXFxuXFx0XFx0XFx0XFx0XFx0bGFzdEJpbmRpbmdzUGF0aCA9IHBhdGhbIGxhc3RCaW5kaW5nc0luZGV4IF07XFxuXFxuXFx0XFx0XFx0XFx0aW5kaWNlc0J5UGF0aFsgbGFzdEJpbmRpbmdzUGF0aCBdID0gaW5kZXg7XFxuXFxuXFx0XFx0XFx0XFx0YmluZGluZ3NbIGluZGV4IF0gPSBsYXN0QmluZGluZ3M7XFxuXFx0XFx0XFx0XFx0YmluZGluZ3MucG9wKCk7XFxuXFxuXFx0XFx0XFx0XFx0cGFyc2VkUGF0aHNbIGluZGV4IF0gPSBwYXJzZWRQYXRoc1sgbGFzdEJpbmRpbmdzSW5kZXggXTtcXG5cXHRcXHRcXHRcXHRwYXJzZWRQYXRocy5wb3AoKTtcXG5cXG5cXHRcXHRcXHRcXHRwYXRoc1sgaW5kZXggXSA9IHBhdGhzWyBsYXN0QmluZGluZ3NJbmRleCBdO1xcblxcdFxcdFxcdFxcdHBhdGhzLnBvcCgpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqXFxuXFx0ICogQWN0aW9uIHByb3ZpZGVkIGJ5IEFuaW1hdGlvbk1peGVyIGZvciBzY2hlZHVsaW5nIGNsaXAgcGxheWJhY2sgb24gc3BlY2lmaWNcXG5cXHQgKiBvYmplY3RzLlxcblxcdCAqXFxuXFx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cXG5cXHQgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cXG5cXHQgKiBAYXV0aG9yIHRzY2h3XFxuXFx0ICpcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBBbmltYXRpb25BY3Rpb24oIG1peGVyLCBjbGlwLCBsb2NhbFJvb3QgKSB7XFxuXFxuXFx0XFx0dGhpcy5fbWl4ZXIgPSBtaXhlcjtcXG5cXHRcXHR0aGlzLl9jbGlwID0gY2xpcDtcXG5cXHRcXHR0aGlzLl9sb2NhbFJvb3QgPSBsb2NhbFJvb3QgfHwgbnVsbDtcXG5cXG5cXHRcXHR2YXIgdHJhY2tzID0gY2xpcC50cmFja3MsXFxuXFx0XFx0XFx0blRyYWNrcyA9IHRyYWNrcy5sZW5ndGgsXFxuXFx0XFx0XFx0aW50ZXJwb2xhbnRzID0gbmV3IEFycmF5KCBuVHJhY2tzICk7XFxuXFxuXFx0XFx0dmFyIGludGVycG9sYW50U2V0dGluZ3MgPSB7XFxuXFx0XFx0XFx0ZW5kaW5nU3RhcnQ6IFplcm9DdXJ2YXR1cmVFbmRpbmcsXFxuXFx0XFx0XFx0ZW5kaW5nRW5kOiBaZXJvQ3VydmF0dXJlRW5kaW5nXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG5UcmFja3M7ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGludGVycG9sYW50ID0gdHJhY2tzWyBpIF0uY3JlYXRlSW50ZXJwb2xhbnQoIG51bGwgKTtcXG5cXHRcXHRcXHRpbnRlcnBvbGFudHNbIGkgXSA9IGludGVycG9sYW50O1xcblxcdFxcdFxcdGludGVycG9sYW50LnNldHRpbmdzID0gaW50ZXJwb2xhbnRTZXR0aW5ncztcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5faW50ZXJwb2xhbnRTZXR0aW5ncyA9IGludGVycG9sYW50U2V0dGluZ3M7XFxuXFxuXFx0XFx0dGhpcy5faW50ZXJwb2xhbnRzID0gaW50ZXJwb2xhbnRzO1xcdC8vIGJvdW5kIGJ5IHRoZSBtaXhlclxcblxcblxcdFxcdC8vIGluc2lkZTogUHJvcGVydHlNaXhlciAobWFuYWdlZCBieSB0aGUgbWl4ZXIpXFxuXFx0XFx0dGhpcy5fcHJvcGVydHlCaW5kaW5ncyA9IG5ldyBBcnJheSggblRyYWNrcyApO1xcblxcblxcdFxcdHRoaXMuX2NhY2hlSW5kZXggPSBudWxsO1xcdFxcdFxcdC8vIGZvciB0aGUgbWVtb3J5IG1hbmFnZXJcXG5cXHRcXHR0aGlzLl9ieUNsaXBDYWNoZUluZGV4ID0gbnVsbDtcXHRcXHQvLyBmb3IgdGhlIG1lbW9yeSBtYW5hZ2VyXFxuXFxuXFx0XFx0dGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQgPSBudWxsO1xcblxcdFxcdHRoaXMuX3dlaWdodEludGVycG9sYW50ID0gbnVsbDtcXG5cXG5cXHRcXHR0aGlzLmxvb3AgPSBMb29wUmVwZWF0O1xcblxcdFxcdHRoaXMuX2xvb3BDb3VudCA9IC0gMTtcXG5cXG5cXHRcXHQvLyBnbG9iYWwgbWl4ZXIgdGltZSB3aGVuIHRoZSBhY3Rpb24gaXMgdG8gYmUgc3RhcnRlZFxcblxcdFxcdC8vIGl0J3Mgc2V0IGJhY2sgdG8gJ251bGwnIHVwb24gc3RhcnQgb2YgdGhlIGFjdGlvblxcblxcdFxcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XFxuXFxuXFx0XFx0Ly8gc2NhbGVkIGxvY2FsIHRpbWUgb2YgdGhlIGFjdGlvblxcblxcdFxcdC8vIGdldHMgY2xhbXBlZCBvciB3cmFwcGVkIHRvIDAuLmNsaXAuZHVyYXRpb24gYWNjb3JkaW5nIHRvIGxvb3BcXG5cXHRcXHR0aGlzLnRpbWUgPSAwO1xcblxcblxcdFxcdHRoaXMudGltZVNjYWxlID0gMTtcXG5cXHRcXHR0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGUgPSAxO1xcblxcblxcdFxcdHRoaXMud2VpZ2h0ID0gMTtcXG5cXHRcXHR0aGlzLl9lZmZlY3RpdmVXZWlnaHQgPSAxO1xcblxcblxcdFxcdHRoaXMucmVwZXRpdGlvbnMgPSBJbmZpbml0eTsgXFx0XFx0Ly8gbm8uIG9mIHJlcGV0aXRpb25zIHdoZW4gbG9vcGluZ1xcblxcblxcdFxcdHRoaXMucGF1c2VkID0gZmFsc2U7XFx0XFx0XFx0XFx0Ly8gdHJ1ZSAtPiB6ZXJvIGVmZmVjdGl2ZSB0aW1lIHNjYWxlXFxuXFx0XFx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcXHRcXHRcXHRcXHQvLyBmYWxzZSAtPiB6ZXJvIGVmZmVjdGl2ZSB3ZWlnaHRcXG5cXG5cXHRcXHR0aGlzLmNsYW1wV2hlbkZpbmlzaGVkIFxcdD0gZmFsc2U7XFx0Ly8ga2VlcCBmZWVkaW5nIHRoZSBsYXN0IGZyYW1lP1xcblxcblxcdFxcdHRoaXMuemVyb1Nsb3BlQXRTdGFydCBcXHQ9IHRydWU7XFx0XFx0Ly8gZm9yIHNtb290aCBpbnRlcnBvbGF0aW9uIHcvbyBzZXBhcmF0ZVxcblxcdFxcdHRoaXMuemVyb1Nsb3BlQXRFbmRcXHRcXHQ9IHRydWU7XFx0XFx0Ly8gY2xpcHMgZm9yIHN0YXJ0LCBsb29wIGFuZCBlbmRcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggQW5pbWF0aW9uQWN0aW9uLnByb3RvdHlwZSwge1xcblxcblxcdFxcdC8vIFN0YXRlICYgU2NoZWR1bGluZ1xcblxcblxcdFxcdHBsYXk6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLl9taXhlci5fYWN0aXZhdGVBY3Rpb24oIHRoaXMgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHN0b3A6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLl9taXhlci5fZGVhY3RpdmF0ZUFjdGlvbiggdGhpcyApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLnJlc2V0KCk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyZXNldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMucGF1c2VkID0gZmFsc2U7XFxuXFx0XFx0XFx0dGhpcy5lbmFibGVkID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHR0aGlzLnRpbWUgPSAwO1xcdFxcdFxcdC8vIHJlc3RhcnQgY2xpcFxcblxcdFxcdFxcdHRoaXMuX2xvb3BDb3VudCA9IC0gMTtcXHQvLyBmb3JnZXQgcHJldmlvdXMgbG9vcHNcXG5cXHRcXHRcXHR0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xcdC8vIGZvcmdldCBzY2hlZHVsaW5nXFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuc3RvcEZhZGluZygpLnN0b3BXYXJwaW5nKCk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRpc1J1bm5pbmc6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5lbmFibGVkICYmICEgdGhpcy5wYXVzZWQgJiYgdGhpcy50aW1lU2NhbGUgIT09IDAgJiZcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9zdGFydFRpbWUgPT09IG51bGwgJiYgdGhpcy5fbWl4ZXIuX2lzQWN0aXZlQWN0aW9uKCB0aGlzICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyByZXR1cm4gdHJ1ZSB3aGVuIHBsYXkgaGFzIGJlZW4gY2FsbGVkXFxuXFx0XFx0aXNTY2hlZHVsZWQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5fbWl4ZXIuX2lzQWN0aXZlQWN0aW9uKCB0aGlzICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzdGFydEF0OiBmdW5jdGlvbiAoIHRpbWUgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5fc3RhcnRUaW1lID0gdGltZTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldExvb3A6IGZ1bmN0aW9uICggbW9kZSwgcmVwZXRpdGlvbnMgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5sb29wID0gbW9kZTtcXG5cXHRcXHRcXHR0aGlzLnJlcGV0aXRpb25zID0gcmVwZXRpdGlvbnM7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBXZWlnaHRcXG5cXG5cXHRcXHQvLyBzZXQgdGhlIHdlaWdodCBzdG9wcGluZyBhbnkgc2NoZWR1bGVkIGZhZGluZ1xcblxcdFxcdC8vIGFsdGhvdWdoIC5lbmFibGVkID0gZmFsc2UgeWllbGRzIGFuIGVmZmVjdGl2ZSB3ZWlnaHQgb2YgemVybywgdGhpc1xcblxcdFxcdC8vIG1ldGhvZCBkb2VzICpub3QqIGNoYW5nZSAuZW5hYmxlZCwgYmVjYXVzZSBpdCB3b3VsZCBiZSBjb25mdXNpbmdcXG5cXHRcXHRzZXRFZmZlY3RpdmVXZWlnaHQ6IGZ1bmN0aW9uICggd2VpZ2h0ICkge1xcblxcblxcdFxcdFxcdHRoaXMud2VpZ2h0ID0gd2VpZ2h0O1xcblxcblxcdFxcdFxcdC8vIG5vdGU6IHNhbWUgbG9naWMgYXMgd2hlbiB1cGRhdGVkIGF0IHJ1bnRpbWVcXG5cXHRcXHRcXHR0aGlzLl9lZmZlY3RpdmVXZWlnaHQgPSB0aGlzLmVuYWJsZWQgPyB3ZWlnaHQgOiAwO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLnN0b3BGYWRpbmcoKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIHJldHVybiB0aGUgd2VpZ2h0IGNvbnNpZGVyaW5nIGZhZGluZyBhbmQgLmVuYWJsZWRcXG5cXHRcXHRnZXRFZmZlY3RpdmVXZWlnaHQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5fZWZmZWN0aXZlV2VpZ2h0O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZmFkZUluOiBmdW5jdGlvbiAoIGR1cmF0aW9uICkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLl9zY2hlZHVsZUZhZGluZyggZHVyYXRpb24sIDAsIDEgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGZhZGVPdXQ6IGZ1bmN0aW9uICggZHVyYXRpb24gKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuX3NjaGVkdWxlRmFkaW5nKCBkdXJhdGlvbiwgMSwgMCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y3Jvc3NGYWRlRnJvbTogZnVuY3Rpb24gKCBmYWRlT3V0QWN0aW9uLCBkdXJhdGlvbiwgd2FycCApIHtcXG5cXG5cXHRcXHRcXHRmYWRlT3V0QWN0aW9uLmZhZGVPdXQoIGR1cmF0aW9uICk7XFxuXFx0XFx0XFx0dGhpcy5mYWRlSW4oIGR1cmF0aW9uICk7XFxuXFxuXFx0XFx0XFx0aWYgKCB3YXJwICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBmYWRlSW5EdXJhdGlvbiA9IHRoaXMuX2NsaXAuZHVyYXRpb24sXFxuXFx0XFx0XFx0XFx0XFx0ZmFkZU91dER1cmF0aW9uID0gZmFkZU91dEFjdGlvbi5fY2xpcC5kdXJhdGlvbixcXG5cXG5cXHRcXHRcXHRcXHRcXHRzdGFydEVuZFJhdGlvID0gZmFkZU91dER1cmF0aW9uIC8gZmFkZUluRHVyYXRpb24sXFxuXFx0XFx0XFx0XFx0XFx0ZW5kU3RhcnRSYXRpbyA9IGZhZGVJbkR1cmF0aW9uIC8gZmFkZU91dER1cmF0aW9uO1xcblxcblxcdFxcdFxcdFxcdGZhZGVPdXRBY3Rpb24ud2FycCggMS4wLCBzdGFydEVuZFJhdGlvLCBkdXJhdGlvbiApO1xcblxcdFxcdFxcdFxcdHRoaXMud2FycCggZW5kU3RhcnRSYXRpbywgMS4wLCBkdXJhdGlvbiApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNyb3NzRmFkZVRvOiBmdW5jdGlvbiAoIGZhZGVJbkFjdGlvbiwgZHVyYXRpb24sIHdhcnAgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZhZGVJbkFjdGlvbi5jcm9zc0ZhZGVGcm9tKCB0aGlzLCBkdXJhdGlvbiwgd2FycCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c3RvcEZhZGluZzogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB3ZWlnaHRJbnRlcnBvbGFudCA9IHRoaXMuX3dlaWdodEludGVycG9sYW50O1xcblxcblxcdFxcdFxcdGlmICggd2VpZ2h0SW50ZXJwb2xhbnQgIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQgPSBudWxsO1xcblxcdFxcdFxcdFxcdHRoaXMuX21peGVyLl90YWtlQmFja0NvbnRyb2xJbnRlcnBvbGFudCggd2VpZ2h0SW50ZXJwb2xhbnQgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBUaW1lIFNjYWxlIENvbnRyb2xcXG5cXG5cXHRcXHQvLyBzZXQgdGhlIHRpbWUgc2NhbGUgc3RvcHBpbmcgYW55IHNjaGVkdWxlZCB3YXJwaW5nXFxuXFx0XFx0Ly8gYWx0aG91Z2ggLnBhdXNlZCA9IHRydWUgeWllbGRzIGFuIGVmZmVjdGl2ZSB0aW1lIHNjYWxlIG9mIHplcm8sIHRoaXNcXG5cXHRcXHQvLyBtZXRob2QgZG9lcyAqbm90KiBjaGFuZ2UgLnBhdXNlZCwgYmVjYXVzZSBpdCB3b3VsZCBiZSBjb25mdXNpbmdcXG5cXHRcXHRzZXRFZmZlY3RpdmVUaW1lU2NhbGU6IGZ1bmN0aW9uICggdGltZVNjYWxlICkge1xcblxcblxcdFxcdFxcdHRoaXMudGltZVNjYWxlID0gdGltZVNjYWxlO1xcblxcdFxcdFxcdHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZSA9IHRoaXMucGF1c2VkID8gMCA6IHRpbWVTY2FsZTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5zdG9wV2FycGluZygpO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gcmV0dXJuIHRoZSB0aW1lIHNjYWxlIGNvbnNpZGVyaW5nIHdhcnBpbmcgYW5kIC5wYXVzZWRcXG5cXHRcXHRnZXRFZmZlY3RpdmVUaW1lU2NhbGU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0RHVyYXRpb246IGZ1bmN0aW9uICggZHVyYXRpb24gKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy50aW1lU2NhbGUgPSB0aGlzLl9jbGlwLmR1cmF0aW9uIC8gZHVyYXRpb247XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuc3RvcFdhcnBpbmcoKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHN5bmNXaXRoOiBmdW5jdGlvbiAoIGFjdGlvbiApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnRpbWUgPSBhY3Rpb24udGltZTtcXG5cXHRcXHRcXHR0aGlzLnRpbWVTY2FsZSA9IGFjdGlvbi50aW1lU2NhbGU7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuc3RvcFdhcnBpbmcoKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGhhbHQ6IGZ1bmN0aW9uICggZHVyYXRpb24gKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMud2FycCggdGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlLCAwLCBkdXJhdGlvbiApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0d2FycDogZnVuY3Rpb24gKCBzdGFydFRpbWVTY2FsZSwgZW5kVGltZVNjYWxlLCBkdXJhdGlvbiApIHtcXG5cXG5cXHRcXHRcXHR2YXIgbWl4ZXIgPSB0aGlzLl9taXhlciwgbm93ID0gbWl4ZXIudGltZSxcXG5cXHRcXHRcXHRcXHRpbnRlcnBvbGFudCA9IHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50LFxcblxcblxcdFxcdFxcdFxcdHRpbWVTY2FsZSA9IHRoaXMudGltZVNjYWxlO1xcblxcblxcdFxcdFxcdGlmICggaW50ZXJwb2xhbnQgPT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aW50ZXJwb2xhbnQgPSBtaXhlci5fbGVuZENvbnRyb2xJbnRlcnBvbGFudCgpO1xcblxcdFxcdFxcdFxcdHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50ID0gaW50ZXJwb2xhbnQ7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciB0aW1lcyA9IGludGVycG9sYW50LnBhcmFtZXRlclBvc2l0aW9ucyxcXG5cXHRcXHRcXHRcXHR2YWx1ZXMgPSBpbnRlcnBvbGFudC5zYW1wbGVWYWx1ZXM7XFxuXFxuXFx0XFx0XFx0dGltZXNbIDAgXSA9IG5vdztcXG5cXHRcXHRcXHR0aW1lc1sgMSBdID0gbm93ICsgZHVyYXRpb247XFxuXFxuXFx0XFx0XFx0dmFsdWVzWyAwIF0gPSBzdGFydFRpbWVTY2FsZSAvIHRpbWVTY2FsZTtcXG5cXHRcXHRcXHR2YWx1ZXNbIDEgXSA9IGVuZFRpbWVTY2FsZSAvIHRpbWVTY2FsZTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHN0b3BXYXJwaW5nOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHRpbWVTY2FsZUludGVycG9sYW50ID0gdGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQ7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aW1lU2NhbGVJbnRlcnBvbGFudCAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudCA9IG51bGw7XFxuXFx0XFx0XFx0XFx0dGhpcy5fbWl4ZXIuX3Rha2VCYWNrQ29udHJvbEludGVycG9sYW50KCB0aW1lU2NhbGVJbnRlcnBvbGFudCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIE9iamVjdCBBY2Nlc3NvcnNcXG5cXG5cXHRcXHRnZXRNaXhlcjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLl9taXhlcjtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldENsaXA6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5fY2xpcDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldFJvb3Q6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5fbG9jYWxSb290IHx8IHRoaXMuX21peGVyLl9yb290O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gSW50ZXJuYVxcblxcblxcdFxcdF91cGRhdGU6IGZ1bmN0aW9uICggdGltZSwgZGVsdGFUaW1lLCB0aW1lRGlyZWN0aW9uLCBhY2N1SW5kZXggKSB7XFxuXFxuXFx0XFx0XFx0Ly8gY2FsbGVkIGJ5IHRoZSBtaXhlclxcblxcblxcdFxcdFxcdGlmICggISB0aGlzLmVuYWJsZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gY2FsbCAuX3VwZGF0ZVdlaWdodCgpIHRvIHVwZGF0ZSAuX2VmZmVjdGl2ZVdlaWdodFxcblxcblxcdFxcdFxcdFxcdHRoaXMuX3VwZGF0ZVdlaWdodCggdGltZSApO1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIHN0YXJ0VGltZSA9IHRoaXMuX3N0YXJ0VGltZTtcXG5cXG5cXHRcXHRcXHRpZiAoIHN0YXJ0VGltZSAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBjaGVjayBmb3Igc2NoZWR1bGVkIHN0YXJ0IG9mIGFjdGlvblxcblxcblxcdFxcdFxcdFxcdHZhciB0aW1lUnVubmluZyA9ICggdGltZSAtIHN0YXJ0VGltZSApICogdGltZURpcmVjdGlvbjtcXG5cXHRcXHRcXHRcXHRpZiAoIHRpbWVSdW5uaW5nIDwgMCB8fCB0aW1lRGlyZWN0aW9uID09PSAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybjsgLy8geWV0IHRvIGNvbWUgLyBkb24ndCBkZWNpZGUgd2hlbiBkZWx0YSA9IDBcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gc3RhcnRcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl9zdGFydFRpbWUgPSBudWxsOyAvLyB1bnNjaGVkdWxlXFxuXFx0XFx0XFx0XFx0ZGVsdGFUaW1lID0gdGltZURpcmVjdGlvbiAqIHRpbWVSdW5uaW5nO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBhcHBseSB0aW1lIHNjYWxlIGFuZCBhZHZhbmNlIHRpbWVcXG5cXG5cXHRcXHRcXHRkZWx0YVRpbWUgKj0gdGhpcy5fdXBkYXRlVGltZVNjYWxlKCB0aW1lICk7XFxuXFx0XFx0XFx0dmFyIGNsaXBUaW1lID0gdGhpcy5fdXBkYXRlVGltZSggZGVsdGFUaW1lICk7XFxuXFxuXFx0XFx0XFx0Ly8gbm90ZTogX3VwZGF0ZVRpbWUgbWF5IGRpc2FibGUgdGhlIGFjdGlvbiByZXN1bHRpbmcgaW5cXG5cXHRcXHRcXHQvLyBhbiBlZmZlY3RpdmUgd2VpZ2h0IG9mIDBcXG5cXG5cXHRcXHRcXHR2YXIgd2VpZ2h0ID0gdGhpcy5fdXBkYXRlV2VpZ2h0KCB0aW1lICk7XFxuXFxuXFx0XFx0XFx0aWYgKCB3ZWlnaHQgPiAwICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBpbnRlcnBvbGFudHMgPSB0aGlzLl9pbnRlcnBvbGFudHM7XFxuXFx0XFx0XFx0XFx0dmFyIHByb3BlcnR5TWl4ZXJzID0gdGhpcy5fcHJvcGVydHlCaW5kaW5ncztcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaiA9IDAsIG0gPSBpbnRlcnBvbGFudHMubGVuZ3RoOyBqICE9PSBtOyArKyBqICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGludGVycG9sYW50c1sgaiBdLmV2YWx1YXRlKCBjbGlwVGltZSApO1xcblxcdFxcdFxcdFxcdFxcdHByb3BlcnR5TWl4ZXJzWyBqIF0uYWNjdW11bGF0ZSggYWNjdUluZGV4LCB3ZWlnaHQgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3VwZGF0ZVdlaWdodDogZnVuY3Rpb24gKCB0aW1lICkge1xcblxcblxcdFxcdFxcdHZhciB3ZWlnaHQgPSAwO1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5lbmFibGVkICkge1xcblxcblxcdFxcdFxcdFxcdHdlaWdodCA9IHRoaXMud2VpZ2h0O1xcblxcdFxcdFxcdFxcdHZhciBpbnRlcnBvbGFudCA9IHRoaXMuX3dlaWdodEludGVycG9sYW50O1xcblxcblxcdFxcdFxcdFxcdGlmICggaW50ZXJwb2xhbnQgIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGludGVycG9sYW50VmFsdWUgPSBpbnRlcnBvbGFudC5ldmFsdWF0ZSggdGltZSApWyAwIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0d2VpZ2h0ICo9IGludGVycG9sYW50VmFsdWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0aW1lID4gaW50ZXJwb2xhbnQucGFyYW1ldGVyUG9zaXRpb25zWyAxIF0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5zdG9wRmFkaW5nKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBpbnRlcnBvbGFudFZhbHVlID09PSAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGZhZGVkIG91dCwgZGlzYWJsZVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLl9lZmZlY3RpdmVXZWlnaHQgPSB3ZWlnaHQ7XFxuXFx0XFx0XFx0cmV0dXJuIHdlaWdodDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdF91cGRhdGVUaW1lU2NhbGU6IGZ1bmN0aW9uICggdGltZSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdGltZVNjYWxlID0gMDtcXG5cXG5cXHRcXHRcXHRpZiAoICEgdGhpcy5wYXVzZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGltZVNjYWxlID0gdGhpcy50aW1lU2NhbGU7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGludGVycG9sYW50ID0gdGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQ7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBpbnRlcnBvbGFudCAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgaW50ZXJwb2xhbnRWYWx1ZSA9IGludGVycG9sYW50LmV2YWx1YXRlKCB0aW1lIClbIDAgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aW1lU2NhbGUgKj0gaW50ZXJwb2xhbnRWYWx1ZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHRpbWUgPiBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnNbIDEgXSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnN0b3BXYXJwaW5nKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB0aW1lU2NhbGUgPT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gbW90aW9uIGhhcyBoYWx0ZWQsIHBhdXNlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5wYXVzZWQgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gd2FycCBkb25lIC0gYXBwbHkgZmluYWwgdGltZSBzY2FsZVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMudGltZVNjYWxlID0gdGltZVNjYWxlO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGUgPSB0aW1lU2NhbGU7XFxuXFx0XFx0XFx0cmV0dXJuIHRpbWVTY2FsZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdF91cGRhdGVUaW1lOiBmdW5jdGlvbiAoIGRlbHRhVGltZSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdGltZSA9IHRoaXMudGltZSArIGRlbHRhVGltZTtcXG5cXG5cXHRcXHRcXHRpZiAoIGRlbHRhVGltZSA9PT0gMCApIHJldHVybiB0aW1lO1xcblxcblxcdFxcdFxcdHZhciBkdXJhdGlvbiA9IHRoaXMuX2NsaXAuZHVyYXRpb24sXFxuXFxuXFx0XFx0XFx0XFx0bG9vcCA9IHRoaXMubG9vcCxcXG5cXHRcXHRcXHRcXHRsb29wQ291bnQgPSB0aGlzLl9sb29wQ291bnQ7XFxuXFxuXFx0XFx0XFx0aWYgKCBsb29wID09PSBMb29wT25jZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGxvb3BDb3VudCA9PT0gLSAxICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGp1c3Qgc3RhcnRlZFxcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2xvb3BDb3VudCA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fc2V0RW5kaW5ncyggdHJ1ZSwgdHJ1ZSwgZmFsc2UgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aGFuZGxlX3N0b3A6IHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHRpbWUgPj0gZHVyYXRpb24gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGltZSA9IGR1cmF0aW9uO1xcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIHRpbWUgPCAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRpbWUgPSAwO1xcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSBicmVhayBoYW5kbGVfc3RvcDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHRoaXMuY2xhbXBXaGVuRmluaXNoZWQgKSB0aGlzLnBhdXNlZCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0ZWxzZSB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9taXhlci5kaXNwYXRjaEV2ZW50KCB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dHlwZTogJ2ZpbmlzaGVkJywgYWN0aW9uOiB0aGlzLFxcblxcdFxcdFxcdFxcdFxcdFxcdGRpcmVjdGlvbjogZGVsdGFUaW1lIDwgMCA/IC0gMSA6IDFcXG5cXHRcXHRcXHRcXHRcXHR9ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH0gZWxzZSB7IC8vIHJlcGV0aXRpdmUgUmVwZWF0IG9yIFBpbmdQb25nXFxuXFxuXFx0XFx0XFx0XFx0dmFyIHBpbmdQb25nID0gKCBsb29wID09PSBMb29wUGluZ1BvbmcgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGxvb3BDb3VudCA9PT0gLSAxICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGp1c3Qgc3RhcnRlZFxcblxcblxcdFxcdFxcdFxcdFxcdGlmICggZGVsdGFUaW1lID49IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0bG9vcENvdW50ID0gMDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9zZXRFbmRpbmdzKCB0cnVlLCB0aGlzLnJlcGV0aXRpb25zID09PSAwLCBwaW5nUG9uZyApO1xcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gd2hlbiBsb29waW5nIGluIHJldmVyc2UgZGlyZWN0aW9uLCB0aGUgaW5pdGlhbFxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHRyYW5zaXRpb24gdGhyb3VnaCB6ZXJvIGNvdW50cyBhcyBhIHJlcGV0aXRpb24sXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gc28gbGVhdmUgbG9vcENvdW50IGF0IC0xXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fc2V0RW5kaW5ncyggdGhpcy5yZXBldGl0aW9ucyA9PT0gMCwgdHJ1ZSwgcGluZ1BvbmcgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggdGltZSA+PSBkdXJhdGlvbiB8fCB0aW1lIDwgMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyB3cmFwIGFyb3VuZFxcblxcblxcdFxcdFxcdFxcdFxcdHZhciBsb29wRGVsdGEgPSBNYXRoLmZsb29yKCB0aW1lIC8gZHVyYXRpb24gKTsgLy8gc2lnbmVkXFxuXFx0XFx0XFx0XFx0XFx0dGltZSAtPSBkdXJhdGlvbiAqIGxvb3BEZWx0YTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRsb29wQ291bnQgKz0gTWF0aC5hYnMoIGxvb3BEZWx0YSApO1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBwZW5kaW5nID0gdGhpcy5yZXBldGl0aW9ucyAtIGxvb3BDb3VudDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHBlbmRpbmcgPCAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGhhdmUgdG8gc3RvcCAoc3dpdGNoIHN0YXRlLCBjbGFtcCB0aW1lLCBmaXJlIGV2ZW50KVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggdGhpcy5jbGFtcFdoZW5GaW5pc2hlZCApIHRoaXMucGF1c2VkID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRlbHNlIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRpbWUgPSBkZWx0YVRpbWUgPiAwID8gZHVyYXRpb24gOiAwO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX21peGVyLmRpc3BhdGNoRXZlbnQoIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0eXBlOiAnZmluaXNoZWQnLCBhY3Rpb246IHRoaXMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGlyZWN0aW9uOiBkZWx0YVRpbWUgPiAwID8gMSA6IC0gMVxcblxcdFxcdFxcdFxcdFxcdFxcdH0gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGtlZXAgcnVubmluZ1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggcGVuZGluZyA9PT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBlbnRlcmluZyB0aGUgbGFzdCByb3VuZFxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBhdFN0YXJ0ID0gZGVsdGFUaW1lIDwgMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9zZXRFbmRpbmdzKCBhdFN0YXJ0LCAhIGF0U3RhcnQsIHBpbmdQb25nICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9zZXRFbmRpbmdzKCBmYWxzZSwgZmFsc2UsIHBpbmdQb25nICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2xvb3BDb3VudCA9IGxvb3BDb3VudDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9taXhlci5kaXNwYXRjaEV2ZW50KCB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dHlwZTogJ2xvb3AnLCBhY3Rpb246IHRoaXMsIGxvb3BEZWx0YTogbG9vcERlbHRhXFxuXFx0XFx0XFx0XFx0XFx0XFx0fSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBwaW5nUG9uZyAmJiAoIGxvb3BDb3VudCAmIDEgKSA9PT0gMSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBpbnZlcnQgdGltZSBmb3IgdGhlIFxcXCJwb25nIHJvdW5kXFxcIlxcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMudGltZSA9IHRpbWU7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGR1cmF0aW9uIC0gdGltZTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMudGltZSA9IHRpbWU7XFxuXFx0XFx0XFx0cmV0dXJuIHRpbWU7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfc2V0RW5kaW5nczogZnVuY3Rpb24gKCBhdFN0YXJ0LCBhdEVuZCwgcGluZ1BvbmcgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHNldHRpbmdzID0gdGhpcy5faW50ZXJwb2xhbnRTZXR0aW5ncztcXG5cXG5cXHRcXHRcXHRpZiAoIHBpbmdQb25nICkge1xcblxcblxcdFxcdFxcdFxcdHNldHRpbmdzLmVuZGluZ1N0YXJ0IFxcdD0gWmVyb1Nsb3BlRW5kaW5nO1xcblxcdFxcdFxcdFxcdHNldHRpbmdzLmVuZGluZ0VuZFxcdFxcdD0gWmVyb1Nsb3BlRW5kaW5nO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gYXNzdW1pbmcgZm9yIExvb3BPbmNlIGF0U3RhcnQgPT0gYXRFbmQgPT0gdHJ1ZVxcblxcblxcdFxcdFxcdFxcdGlmICggYXRTdGFydCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzZXR0aW5ncy5lbmRpbmdTdGFydCA9IHRoaXMuemVyb1Nsb3BlQXRTdGFydCA/IFplcm9TbG9wZUVuZGluZyA6IFplcm9DdXJ2YXR1cmVFbmRpbmc7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzZXR0aW5ncy5lbmRpbmdTdGFydCA9IFdyYXBBcm91bmRFbmRpbmc7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggYXRFbmQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0c2V0dGluZ3MuZW5kaW5nRW5kID0gdGhpcy56ZXJvU2xvcGVBdEVuZCA/IFplcm9TbG9wZUVuZGluZyA6IFplcm9DdXJ2YXR1cmVFbmRpbmc7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzZXR0aW5ncy5lbmRpbmdFbmQgXFx0ID0gV3JhcEFyb3VuZEVuZGluZztcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3NjaGVkdWxlRmFkaW5nOiBmdW5jdGlvbiAoIGR1cmF0aW9uLCB3ZWlnaHROb3csIHdlaWdodFRoZW4gKSB7XFxuXFxuXFx0XFx0XFx0dmFyIG1peGVyID0gdGhpcy5fbWl4ZXIsIG5vdyA9IG1peGVyLnRpbWUsXFxuXFx0XFx0XFx0XFx0aW50ZXJwb2xhbnQgPSB0aGlzLl93ZWlnaHRJbnRlcnBvbGFudDtcXG5cXG5cXHRcXHRcXHRpZiAoIGludGVycG9sYW50ID09PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdGludGVycG9sYW50ID0gbWl4ZXIuX2xlbmRDb250cm9sSW50ZXJwb2xhbnQoKTtcXG5cXHRcXHRcXHRcXHR0aGlzLl93ZWlnaHRJbnRlcnBvbGFudCA9IGludGVycG9sYW50O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgdGltZXMgPSBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnMsXFxuXFx0XFx0XFx0XFx0dmFsdWVzID0gaW50ZXJwb2xhbnQuc2FtcGxlVmFsdWVzO1xcblxcblxcdFxcdFxcdHRpbWVzWyAwIF0gPSBub3c7IFxcdFxcdFxcdFxcdHZhbHVlc1sgMCBdID0gd2VpZ2h0Tm93O1xcblxcdFxcdFxcdHRpbWVzWyAxIF0gPSBub3cgKyBkdXJhdGlvbjtcXHR2YWx1ZXNbIDEgXSA9IHdlaWdodFRoZW47XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKlxcblxcdCAqIFBsYXllciBmb3IgQW5pbWF0aW9uQ2xpcHMuXFxuXFx0ICpcXG5cXHQgKlxcblxcdCAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXFxuXFx0ICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXFxuXFx0ICogQGF1dGhvciB0c2Nod1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEFuaW1hdGlvbk1peGVyKCByb290ICkge1xcblxcblxcdFxcdHRoaXMuX3Jvb3QgPSByb290O1xcblxcdFxcdHRoaXMuX2luaXRNZW1vcnlNYW5hZ2VyKCk7XFxuXFx0XFx0dGhpcy5fYWNjdUluZGV4ID0gMDtcXG5cXG5cXHRcXHR0aGlzLnRpbWUgPSAwO1xcblxcblxcdFxcdHRoaXMudGltZVNjYWxlID0gMS4wO1xcblxcblxcdH1cXG5cXG5cXHRBbmltYXRpb25NaXhlci5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlICksIHtcXG5cXG5cXHRcXHRjb25zdHJ1Y3RvcjogQW5pbWF0aW9uTWl4ZXIsXFxuXFxuXFx0XFx0X2JpbmRBY3Rpb246IGZ1bmN0aW9uICggYWN0aW9uLCBwcm90b3R5cGVBY3Rpb24gKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHJvb3QgPSBhY3Rpb24uX2xvY2FsUm9vdCB8fCB0aGlzLl9yb290LFxcblxcdFxcdFxcdFxcdHRyYWNrcyA9IGFjdGlvbi5fY2xpcC50cmFja3MsXFxuXFx0XFx0XFx0XFx0blRyYWNrcyA9IHRyYWNrcy5sZW5ndGgsXFxuXFx0XFx0XFx0XFx0YmluZGluZ3MgPSBhY3Rpb24uX3Byb3BlcnR5QmluZGluZ3MsXFxuXFx0XFx0XFx0XFx0aW50ZXJwb2xhbnRzID0gYWN0aW9uLl9pbnRlcnBvbGFudHMsXFxuXFx0XFx0XFx0XFx0cm9vdFV1aWQgPSByb290LnV1aWQsXFxuXFx0XFx0XFx0XFx0YmluZGluZ3NCeVJvb3QgPSB0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUsXFxuXFx0XFx0XFx0XFx0YmluZGluZ3NCeU5hbWUgPSBiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXTtcXG5cXG5cXHRcXHRcXHRpZiAoIGJpbmRpbmdzQnlOYW1lID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0YmluZGluZ3NCeU5hbWUgPSB7fTtcXG5cXHRcXHRcXHRcXHRiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXSA9IGJpbmRpbmdzQnlOYW1lO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG5UcmFja3M7ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHRyYWNrID0gdHJhY2tzWyBpIF0sXFxuXFx0XFx0XFx0XFx0XFx0dHJhY2tOYW1lID0gdHJhY2submFtZSxcXG5cXHRcXHRcXHRcXHRcXHRiaW5kaW5nID0gYmluZGluZ3NCeU5hbWVbIHRyYWNrTmFtZSBdO1xcblxcblxcdFxcdFxcdFxcdGlmICggYmluZGluZyAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGJpbmRpbmdzWyBpIF0gPSBiaW5kaW5nO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YmluZGluZyA9IGJpbmRpbmdzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBiaW5kaW5nICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gZXhpc3RpbmcgYmluZGluZywgbWFrZSBzdXJlIHRoZSBjYWNoZSBrbm93c1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggYmluZGluZy5fY2FjaGVJbmRleCA9PT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQrKyBiaW5kaW5nLnJlZmVyZW5jZUNvdW50O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2FkZEluYWN0aXZlQmluZGluZyggYmluZGluZywgcm9vdFV1aWQsIHRyYWNrTmFtZSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHBhdGggPSBwcm90b3R5cGVBY3Rpb24gJiYgcHJvdG90eXBlQWN0aW9uLlxcblxcdFxcdFxcdFxcdFxcdFxcdF9wcm9wZXJ0eUJpbmRpbmdzWyBpIF0uYmluZGluZy5wYXJzZWRQYXRoO1xcblxcblxcdFxcdFxcdFxcdFxcdGJpbmRpbmcgPSBuZXcgUHJvcGVydHlNaXhlcihcXG5cXHRcXHRcXHRcXHRcXHRcXHRQcm9wZXJ0eUJpbmRpbmcuY3JlYXRlKCByb290LCB0cmFja05hbWUsIHBhdGggKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHR0cmFjay5WYWx1ZVR5cGVOYW1lLCB0cmFjay5nZXRWYWx1ZVNpemUoKSApO1xcblxcblxcdFxcdFxcdFxcdFxcdCsrIGJpbmRpbmcucmVmZXJlbmNlQ291bnQ7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fYWRkSW5hY3RpdmVCaW5kaW5nKCBiaW5kaW5nLCByb290VXVpZCwgdHJhY2tOYW1lICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YmluZGluZ3NbIGkgXSA9IGJpbmRpbmc7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGludGVycG9sYW50c1sgaSBdLnJlc3VsdEJ1ZmZlciA9IGJpbmRpbmcuYnVmZmVyO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9hY3RpdmF0ZUFjdGlvbjogZnVuY3Rpb24gKCBhY3Rpb24gKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCAhIHRoaXMuX2lzQWN0aXZlQWN0aW9uKCBhY3Rpb24gKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGFjdGlvbi5fY2FjaGVJbmRleCA9PT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyB0aGlzIGFjdGlvbiBoYXMgYmVlbiBmb3Jnb3R0ZW4gYnkgdGhlIGNhY2hlLCBidXQgdGhlIHVzZXJcXG5cXHRcXHRcXHRcXHRcXHQvLyBhcHBlYXJzIHRvIGJlIHN0aWxsIHVzaW5nIGl0IC0+IHJlYmluZFxcblxcblxcdFxcdFxcdFxcdFxcdHZhciByb290VXVpZCA9ICggYWN0aW9uLl9sb2NhbFJvb3QgfHwgdGhpcy5fcm9vdCApLnV1aWQsXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2xpcFV1aWQgPSBhY3Rpb24uX2NsaXAudXVpZCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRhY3Rpb25zRm9yQ2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fYmluZEFjdGlvbiggYWN0aW9uLFxcblxcdFxcdFxcdFxcdFxcdFxcdGFjdGlvbnNGb3JDbGlwICYmIGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9uc1sgMCBdICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fYWRkSW5hY3RpdmVBY3Rpb24oIGFjdGlvbiwgY2xpcFV1aWQsIHJvb3RVdWlkICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHZhciBiaW5kaW5ncyA9IGFjdGlvbi5fcHJvcGVydHlCaW5kaW5ncztcXG5cXG5cXHRcXHRcXHRcXHQvLyBpbmNyZW1lbnQgcmVmZXJlbmNlIGNvdW50cyAvIHNvcnQgb3V0IHN0YXRlXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBiaW5kaW5nID0gYmluZGluZ3NbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGJpbmRpbmcudXNlQ291bnQgKysgPT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fbGVuZEJpbmRpbmcoIGJpbmRpbmcgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRiaW5kaW5nLnNhdmVPcmlnaW5hbFN0YXRlKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl9sZW5kQWN0aW9uKCBhY3Rpb24gKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfZGVhY3RpdmF0ZUFjdGlvbjogZnVuY3Rpb24gKCBhY3Rpb24gKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLl9pc0FjdGl2ZUFjdGlvbiggYWN0aW9uICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGJpbmRpbmdzID0gYWN0aW9uLl9wcm9wZXJ0eUJpbmRpbmdzO1xcblxcblxcdFxcdFxcdFxcdC8vIGRlY3JlbWVudCByZWZlcmVuY2UgY291bnRzIC8gc29ydCBvdXQgc3RhdGVcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGJpbmRpbmcgPSBiaW5kaW5nc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggLS0gYmluZGluZy51c2VDb3VudCA9PT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRiaW5kaW5nLnJlc3RvcmVPcmlnaW5hbFN0YXRlKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fdGFrZUJhY2tCaW5kaW5nKCBiaW5kaW5nICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl90YWtlQmFja0FjdGlvbiggYWN0aW9uICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gTWVtb3J5IG1hbmFnZXJcXG5cXG5cXHRcXHRfaW5pdE1lbW9yeU1hbmFnZXI6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLl9hY3Rpb25zID0gW107IC8vICduQWN0aXZlQWN0aW9ucycgZm9sbG93ZWQgYnkgaW5hY3RpdmUgb25lc1xcblxcdFxcdFxcdHRoaXMuX25BY3RpdmVBY3Rpb25zID0gMDtcXG5cXG5cXHRcXHRcXHR0aGlzLl9hY3Rpb25zQnlDbGlwID0ge307XFxuXFx0XFx0XFx0Ly8gaW5zaWRlOlxcblxcdFxcdFxcdC8vIHtcXG5cXHRcXHRcXHQvLyBcXHRcXHRrbm93bkFjdGlvbnM6IEFycmF5PCBBbmltYXRpb25BY3Rpb24gPlxcdC0gdXNlZCBhcyBwcm90b3R5cGVzXFxuXFx0XFx0XFx0Ly8gXFx0XFx0YWN0aW9uQnlSb290OiBBbmltYXRpb25BY3Rpb25cXHRcXHRcXHQtIGxvb2t1cFxcblxcdFxcdFxcdC8vIH1cXG5cXG5cXG5cXHRcXHRcXHR0aGlzLl9iaW5kaW5ncyA9IFtdOyAvLyAnbkFjdGl2ZUJpbmRpbmdzJyBmb2xsb3dlZCBieSBpbmFjdGl2ZSBvbmVzXFxuXFx0XFx0XFx0dGhpcy5fbkFjdGl2ZUJpbmRpbmdzID0gMDtcXG5cXG5cXHRcXHRcXHR0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUgPSB7fTsgLy8gaW5zaWRlOiBNYXA8IG5hbWUsIFByb3BlcnR5TWl4ZXIgPlxcblxcblxcblxcdFxcdFxcdHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHMgPSBbXTsgLy8gc2FtZSBnYW1lIGFzIGFib3ZlXFxuXFx0XFx0XFx0dGhpcy5fbkFjdGl2ZUNvbnRyb2xJbnRlcnBvbGFudHMgPSAwO1xcblxcblxcdFxcdFxcdHZhciBzY29wZSA9IHRoaXM7XFxuXFxuXFx0XFx0XFx0dGhpcy5zdGF0cyA9IHtcXG5cXG5cXHRcXHRcXHRcXHRhY3Rpb25zOiB7XFxuXFx0XFx0XFx0XFx0XFx0Z2V0IHRvdGFsKCkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBzY29wZS5fYWN0aW9ucy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRcXHRnZXQgaW5Vc2UoKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHNjb3BlLl9uQWN0aXZlQWN0aW9ucztcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRiaW5kaW5nczoge1xcblxcdFxcdFxcdFxcdFxcdGdldCB0b3RhbCgpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gc2NvcGUuX2JpbmRpbmdzLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFxcdGdldCBpblVzZSgpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gc2NvcGUuX25BY3RpdmVCaW5kaW5ncztcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRjb250cm9sSW50ZXJwb2xhbnRzOiB7XFxuXFx0XFx0XFx0XFx0XFx0Z2V0IHRvdGFsKCkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBzY29wZS5fY29udHJvbEludGVycG9sYW50cy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRcXHRnZXQgaW5Vc2UoKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHNjb3BlLl9uQWN0aXZlQ29udHJvbEludGVycG9sYW50cztcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBNZW1vcnkgbWFuYWdlbWVudCBmb3IgQW5pbWF0aW9uQWN0aW9uIG9iamVjdHNcXG5cXG5cXHRcXHRfaXNBY3RpdmVBY3Rpb246IGZ1bmN0aW9uICggYWN0aW9uICkge1xcblxcblxcdFxcdFxcdHZhciBpbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleDtcXG5cXHRcXHRcXHRyZXR1cm4gaW5kZXggIT09IG51bGwgJiYgaW5kZXggPCB0aGlzLl9uQWN0aXZlQWN0aW9ucztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9hZGRJbmFjdGl2ZUFjdGlvbjogZnVuY3Rpb24gKCBhY3Rpb24sIGNsaXBVdWlkLCByb290VXVpZCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXFxuXFx0XFx0XFx0XFx0YWN0aW9uc0J5Q2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXAsXFxuXFx0XFx0XFx0XFx0YWN0aW9uc0ZvckNsaXAgPSBhY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdO1xcblxcblxcdFxcdFxcdGlmICggYWN0aW9uc0ZvckNsaXAgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRhY3Rpb25zRm9yQ2xpcCA9IHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRrbm93bkFjdGlvbnM6IFsgYWN0aW9uIF0sXFxuXFx0XFx0XFx0XFx0XFx0YWN0aW9uQnlSb290OiB7fVxcblxcblxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0XFx0YWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4ID0gMDtcXG5cXG5cXHRcXHRcXHRcXHRhY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdID0gYWN0aW9uc0ZvckNsaXA7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIga25vd25BY3Rpb25zID0gYWN0aW9uc0ZvckNsaXAua25vd25BY3Rpb25zO1xcblxcblxcdFxcdFxcdFxcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IGtub3duQWN0aW9ucy5sZW5ndGg7XFxuXFx0XFx0XFx0XFx0a25vd25BY3Rpb25zLnB1c2goIGFjdGlvbiApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRhY3Rpb24uX2NhY2hlSW5kZXggPSBhY3Rpb25zLmxlbmd0aDtcXG5cXHRcXHRcXHRhY3Rpb25zLnB1c2goIGFjdGlvbiApO1xcblxcblxcdFxcdFxcdGFjdGlvbnNGb3JDbGlwLmFjdGlvbkJ5Um9vdFsgcm9vdFV1aWQgXSA9IGFjdGlvbjtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9yZW1vdmVJbmFjdGl2ZUFjdGlvbjogZnVuY3Rpb24gKCBhY3Rpb24gKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxcblxcdFxcdFxcdFxcdGxhc3RJbmFjdGl2ZUFjdGlvbiA9IGFjdGlvbnNbIGFjdGlvbnMubGVuZ3RoIC0gMSBdLFxcblxcdFxcdFxcdFxcdGNhY2hlSW5kZXggPSBhY3Rpb24uX2NhY2hlSW5kZXg7XFxuXFxuXFx0XFx0XFx0bGFzdEluYWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gY2FjaGVJbmRleDtcXG5cXHRcXHRcXHRhY3Rpb25zWyBjYWNoZUluZGV4IF0gPSBsYXN0SW5hY3RpdmVBY3Rpb247XFxuXFx0XFx0XFx0YWN0aW9ucy5wb3AoKTtcXG5cXG5cXHRcXHRcXHRhY3Rpb24uX2NhY2hlSW5kZXggPSBudWxsO1xcblxcblxcblxcdFxcdFxcdHZhciBjbGlwVXVpZCA9IGFjdGlvbi5fY2xpcC51dWlkLFxcblxcdFxcdFxcdFxcdGFjdGlvbnNCeUNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwLFxcblxcdFxcdFxcdFxcdGFjdGlvbnNGb3JDbGlwID0gYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXSxcXG5cXHRcXHRcXHRcXHRrbm93bkFjdGlvbnNGb3JDbGlwID0gYWN0aW9uc0ZvckNsaXAua25vd25BY3Rpb25zLFxcblxcblxcdFxcdFxcdFxcdGxhc3RLbm93bkFjdGlvbiA9XFxuXFx0XFx0XFx0XFx0XFx0a25vd25BY3Rpb25zRm9yQ2xpcFsga25vd25BY3Rpb25zRm9yQ2xpcC5sZW5ndGggLSAxIF0sXFxuXFxuXFx0XFx0XFx0XFx0YnlDbGlwQ2FjaGVJbmRleCA9IGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleDtcXG5cXG5cXHRcXHRcXHRsYXN0S25vd25BY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXggPSBieUNsaXBDYWNoZUluZGV4O1xcblxcdFxcdFxcdGtub3duQWN0aW9uc0ZvckNsaXBbIGJ5Q2xpcENhY2hlSW5kZXggXSA9IGxhc3RLbm93bkFjdGlvbjtcXG5cXHRcXHRcXHRrbm93bkFjdGlvbnNGb3JDbGlwLnBvcCgpO1xcblxcblxcdFxcdFxcdGFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IG51bGw7XFxuXFxuXFxuXFx0XFx0XFx0dmFyIGFjdGlvbkJ5Um9vdCA9IGFjdGlvbnNGb3JDbGlwLmFjdGlvbkJ5Um9vdCxcXG5cXHRcXHRcXHRcXHRyb290VXVpZCA9ICggYWN0aW9uLl9sb2NhbFJvb3QgfHwgdGhpcy5fcm9vdCApLnV1aWQ7XFxuXFxuXFx0XFx0XFx0ZGVsZXRlIGFjdGlvbkJ5Um9vdFsgcm9vdFV1aWQgXTtcXG5cXG5cXHRcXHRcXHRpZiAoIGtub3duQWN0aW9uc0ZvckNsaXAubGVuZ3RoID09PSAwICkge1xcblxcblxcdFxcdFxcdFxcdGRlbGV0ZSBhY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUJpbmRpbmdzRm9yQWN0aW9uKCBhY3Rpb24gKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9yZW1vdmVJbmFjdGl2ZUJpbmRpbmdzRm9yQWN0aW9uOiBmdW5jdGlvbiAoIGFjdGlvbiApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYmluZGluZ3MgPSBhY3Rpb24uX3Byb3BlcnR5QmluZGluZ3M7XFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBiaW5kaW5nID0gYmluZGluZ3NbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIC0tIGJpbmRpbmcucmVmZXJlbmNlQ291bnQgPT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nKCBiaW5kaW5nICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9sZW5kQWN0aW9uOiBmdW5jdGlvbiAoIGFjdGlvbiApIHtcXG5cXG5cXHRcXHRcXHQvLyBbIGFjdGl2ZSBhY3Rpb25zIHwgIGluYWN0aXZlIGFjdGlvbnMgIF1cXG5cXHRcXHRcXHQvLyBbICBhY3RpdmUgYWN0aW9ucyA+fCBpbmFjdGl2ZSBhY3Rpb25zIF1cXG5cXHRcXHRcXHQvLyAgICAgICAgICAgICAgICAgcyAgICAgICAgYVxcblxcdFxcdFxcdC8vICAgICAgICAgICAgICAgICAgPC1zd2FwLT5cXG5cXHRcXHRcXHQvLyAgICAgICAgICAgICAgICAgYSAgICAgICAgc1xcblxcblxcdFxcdFxcdHZhciBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcXG5cXHRcXHRcXHRcXHRwcmV2SW5kZXggPSBhY3Rpb24uX2NhY2hlSW5kZXgsXFxuXFxuXFx0XFx0XFx0XFx0bGFzdEFjdGl2ZUluZGV4ID0gdGhpcy5fbkFjdGl2ZUFjdGlvbnMgKyssXFxuXFxuXFx0XFx0XFx0XFx0Zmlyc3RJbmFjdGl2ZUFjdGlvbiA9IGFjdGlvbnNbIGxhc3RBY3RpdmVJbmRleCBdO1xcblxcblxcdFxcdFxcdGFjdGlvbi5fY2FjaGVJbmRleCA9IGxhc3RBY3RpdmVJbmRleDtcXG5cXHRcXHRcXHRhY3Rpb25zWyBsYXN0QWN0aXZlSW5kZXggXSA9IGFjdGlvbjtcXG5cXG5cXHRcXHRcXHRmaXJzdEluYWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gcHJldkluZGV4O1xcblxcdFxcdFxcdGFjdGlvbnNbIHByZXZJbmRleCBdID0gZmlyc3RJbmFjdGl2ZUFjdGlvbjtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdF90YWtlQmFja0FjdGlvbjogZnVuY3Rpb24gKCBhY3Rpb24gKSB7XFxuXFxuXFx0XFx0XFx0Ly8gWyAgYWN0aXZlIGFjdGlvbnMgIHwgaW5hY3RpdmUgYWN0aW9ucyBdXFxuXFx0XFx0XFx0Ly8gWyBhY3RpdmUgYWN0aW9ucyB8PCBpbmFjdGl2ZSBhY3Rpb25zICBdXFxuXFx0XFx0XFx0Ly8gICAgICAgIGEgICAgICAgIHNcXG5cXHRcXHRcXHQvLyAgICAgICAgIDwtc3dhcC0+XFxuXFx0XFx0XFx0Ly8gICAgICAgIHMgICAgICAgIGFcXG5cXG5cXHRcXHRcXHR2YXIgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXFxuXFx0XFx0XFx0XFx0cHJldkluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4LFxcblxcblxcdFxcdFxcdFxcdGZpcnN0SW5hY3RpdmVJbmRleCA9IC0tIHRoaXMuX25BY3RpdmVBY3Rpb25zLFxcblxcblxcdFxcdFxcdFxcdGxhc3RBY3RpdmVBY3Rpb24gPSBhY3Rpb25zWyBmaXJzdEluYWN0aXZlSW5kZXggXTtcXG5cXG5cXHRcXHRcXHRhY3Rpb24uX2NhY2hlSW5kZXggPSBmaXJzdEluYWN0aXZlSW5kZXg7XFxuXFx0XFx0XFx0YWN0aW9uc1sgZmlyc3RJbmFjdGl2ZUluZGV4IF0gPSBhY3Rpb247XFxuXFxuXFx0XFx0XFx0bGFzdEFjdGl2ZUFjdGlvbi5fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcXG5cXHRcXHRcXHRhY3Rpb25zWyBwcmV2SW5kZXggXSA9IGxhc3RBY3RpdmVBY3Rpb247XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBNZW1vcnkgbWFuYWdlbWVudCBmb3IgUHJvcGVydHlNaXhlciBvYmplY3RzXFxuXFxuXFx0XFx0X2FkZEluYWN0aXZlQmluZGluZzogZnVuY3Rpb24gKCBiaW5kaW5nLCByb290VXVpZCwgdHJhY2tOYW1lICkge1xcblxcblxcdFxcdFxcdHZhciBiaW5kaW5nc0J5Um9vdCA9IHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSxcXG5cXHRcXHRcXHRcXHRiaW5kaW5nQnlOYW1lID0gYmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF0sXFxuXFxuXFx0XFx0XFx0XFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcXG5cXG5cXHRcXHRcXHRpZiAoIGJpbmRpbmdCeU5hbWUgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRiaW5kaW5nQnlOYW1lID0ge307XFxuXFx0XFx0XFx0XFx0YmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF0gPSBiaW5kaW5nQnlOYW1lO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRiaW5kaW5nQnlOYW1lWyB0cmFja05hbWUgXSA9IGJpbmRpbmc7XFxuXFxuXFx0XFx0XFx0YmluZGluZy5fY2FjaGVJbmRleCA9IGJpbmRpbmdzLmxlbmd0aDtcXG5cXHRcXHRcXHRiaW5kaW5ncy5wdXNoKCBiaW5kaW5nICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfcmVtb3ZlSW5hY3RpdmVCaW5kaW5nOiBmdW5jdGlvbiAoIGJpbmRpbmcgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXFxuXFx0XFx0XFx0XFx0cHJvcEJpbmRpbmcgPSBiaW5kaW5nLmJpbmRpbmcsXFxuXFx0XFx0XFx0XFx0cm9vdFV1aWQgPSBwcm9wQmluZGluZy5yb290Tm9kZS51dWlkLFxcblxcdFxcdFxcdFxcdHRyYWNrTmFtZSA9IHByb3BCaW5kaW5nLnBhdGgsXFxuXFx0XFx0XFx0XFx0YmluZGluZ3NCeVJvb3QgPSB0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUsXFxuXFx0XFx0XFx0XFx0YmluZGluZ0J5TmFtZSA9IGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdLFxcblxcblxcdFxcdFxcdFxcdGxhc3RJbmFjdGl2ZUJpbmRpbmcgPSBiaW5kaW5nc1sgYmluZGluZ3MubGVuZ3RoIC0gMSBdLFxcblxcdFxcdFxcdFxcdGNhY2hlSW5kZXggPSBiaW5kaW5nLl9jYWNoZUluZGV4O1xcblxcblxcdFxcdFxcdGxhc3RJbmFjdGl2ZUJpbmRpbmcuX2NhY2hlSW5kZXggPSBjYWNoZUluZGV4O1xcblxcdFxcdFxcdGJpbmRpbmdzWyBjYWNoZUluZGV4IF0gPSBsYXN0SW5hY3RpdmVCaW5kaW5nO1xcblxcdFxcdFxcdGJpbmRpbmdzLnBvcCgpO1xcblxcblxcdFxcdFxcdGRlbGV0ZSBiaW5kaW5nQnlOYW1lWyB0cmFja05hbWUgXTtcXG5cXG5cXHRcXHRcXHRyZW1vdmVfZW1wdHlfbWFwOiB7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIF8gaW4gYmluZGluZ0J5TmFtZSApIGJyZWFrIHJlbW92ZV9lbXB0eV9tYXA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcXG5cXG5cXHRcXHRcXHRcXHRkZWxldGUgYmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF07XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2xlbmRCaW5kaW5nOiBmdW5jdGlvbiAoIGJpbmRpbmcgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXFxuXFx0XFx0XFx0XFx0cHJldkluZGV4ID0gYmluZGluZy5fY2FjaGVJbmRleCxcXG5cXG5cXHRcXHRcXHRcXHRsYXN0QWN0aXZlSW5kZXggPSB0aGlzLl9uQWN0aXZlQmluZGluZ3MgKyssXFxuXFxuXFx0XFx0XFx0XFx0Zmlyc3RJbmFjdGl2ZUJpbmRpbmcgPSBiaW5kaW5nc1sgbGFzdEFjdGl2ZUluZGV4IF07XFxuXFxuXFx0XFx0XFx0YmluZGluZy5fY2FjaGVJbmRleCA9IGxhc3RBY3RpdmVJbmRleDtcXG5cXHRcXHRcXHRiaW5kaW5nc1sgbGFzdEFjdGl2ZUluZGV4IF0gPSBiaW5kaW5nO1xcblxcblxcdFxcdFxcdGZpcnN0SW5hY3RpdmVCaW5kaW5nLl9jYWNoZUluZGV4ID0gcHJldkluZGV4O1xcblxcdFxcdFxcdGJpbmRpbmdzWyBwcmV2SW5kZXggXSA9IGZpcnN0SW5hY3RpdmVCaW5kaW5nO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3Rha2VCYWNrQmluZGluZzogZnVuY3Rpb24gKCBiaW5kaW5nICkge1xcblxcblxcdFxcdFxcdHZhciBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxcblxcdFxcdFxcdFxcdHByZXZJbmRleCA9IGJpbmRpbmcuX2NhY2hlSW5kZXgsXFxuXFxuXFx0XFx0XFx0XFx0Zmlyc3RJbmFjdGl2ZUluZGV4ID0gLS0gdGhpcy5fbkFjdGl2ZUJpbmRpbmdzLFxcblxcblxcdFxcdFxcdFxcdGxhc3RBY3RpdmVCaW5kaW5nID0gYmluZGluZ3NbIGZpcnN0SW5hY3RpdmVJbmRleCBdO1xcblxcblxcdFxcdFxcdGJpbmRpbmcuX2NhY2hlSW5kZXggPSBmaXJzdEluYWN0aXZlSW5kZXg7XFxuXFx0XFx0XFx0YmluZGluZ3NbIGZpcnN0SW5hY3RpdmVJbmRleCBdID0gYmluZGluZztcXG5cXG5cXHRcXHRcXHRsYXN0QWN0aXZlQmluZGluZy5fY2FjaGVJbmRleCA9IHByZXZJbmRleDtcXG5cXHRcXHRcXHRiaW5kaW5nc1sgcHJldkluZGV4IF0gPSBsYXN0QWN0aXZlQmluZGluZztcXG5cXG5cXHRcXHR9LFxcblxcblxcblxcdFxcdC8vIE1lbW9yeSBtYW5hZ2VtZW50IG9mIEludGVycG9sYW50cyBmb3Igd2VpZ2h0IGFuZCB0aW1lIHNjYWxlXFxuXFxuXFx0XFx0X2xlbmRDb250cm9sSW50ZXJwb2xhbnQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgaW50ZXJwb2xhbnRzID0gdGhpcy5fY29udHJvbEludGVycG9sYW50cyxcXG5cXHRcXHRcXHRcXHRsYXN0QWN0aXZlSW5kZXggPSB0aGlzLl9uQWN0aXZlQ29udHJvbEludGVycG9sYW50cyArKyxcXG5cXHRcXHRcXHRcXHRpbnRlcnBvbGFudCA9IGludGVycG9sYW50c1sgbGFzdEFjdGl2ZUluZGV4IF07XFxuXFxuXFx0XFx0XFx0aWYgKCBpbnRlcnBvbGFudCA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGludGVycG9sYW50ID0gbmV3IExpbmVhckludGVycG9sYW50KFxcblxcdFxcdFxcdFxcdFxcdG5ldyBGbG9hdDMyQXJyYXkoIDIgKSwgbmV3IEZsb2F0MzJBcnJheSggMiApLFxcblxcdFxcdFxcdFxcdFxcdDEsIHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHNSZXN1bHRCdWZmZXIgKTtcXG5cXG5cXHRcXHRcXHRcXHRpbnRlcnBvbGFudC5fX2NhY2hlSW5kZXggPSBsYXN0QWN0aXZlSW5kZXg7XFxuXFx0XFx0XFx0XFx0aW50ZXJwb2xhbnRzWyBsYXN0QWN0aXZlSW5kZXggXSA9IGludGVycG9sYW50O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gaW50ZXJwb2xhbnQ7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfdGFrZUJhY2tDb250cm9sSW50ZXJwb2xhbnQ6IGZ1bmN0aW9uICggaW50ZXJwb2xhbnQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGludGVycG9sYW50cyA9IHRoaXMuX2NvbnRyb2xJbnRlcnBvbGFudHMsXFxuXFx0XFx0XFx0XFx0cHJldkluZGV4ID0gaW50ZXJwb2xhbnQuX19jYWNoZUluZGV4LFxcblxcblxcdFxcdFxcdFxcdGZpcnN0SW5hY3RpdmVJbmRleCA9IC0tIHRoaXMuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzLFxcblxcblxcdFxcdFxcdFxcdGxhc3RBY3RpdmVJbnRlcnBvbGFudCA9IGludGVycG9sYW50c1sgZmlyc3RJbmFjdGl2ZUluZGV4IF07XFxuXFxuXFx0XFx0XFx0aW50ZXJwb2xhbnQuX19jYWNoZUluZGV4ID0gZmlyc3RJbmFjdGl2ZUluZGV4O1xcblxcdFxcdFxcdGludGVycG9sYW50c1sgZmlyc3RJbmFjdGl2ZUluZGV4IF0gPSBpbnRlcnBvbGFudDtcXG5cXG5cXHRcXHRcXHRsYXN0QWN0aXZlSW50ZXJwb2xhbnQuX19jYWNoZUluZGV4ID0gcHJldkluZGV4O1xcblxcdFxcdFxcdGludGVycG9sYW50c1sgcHJldkluZGV4IF0gPSBsYXN0QWN0aXZlSW50ZXJwb2xhbnQ7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfY29udHJvbEludGVycG9sYW50c1Jlc3VsdEJ1ZmZlcjogbmV3IEZsb2F0MzJBcnJheSggMSApLFxcblxcblxcdFxcdC8vIHJldHVybiBhbiBhY3Rpb24gZm9yIGEgY2xpcCBvcHRpb25hbGx5IHVzaW5nIGEgY3VzdG9tIHJvb3QgdGFyZ2V0XFxuXFx0XFx0Ly8gb2JqZWN0ICh0aGlzIG1ldGhvZCBhbGxvY2F0ZXMgYSBsb3Qgb2YgZHluYW1pYyBtZW1vcnkgaW4gY2FzZSBhXFxuXFx0XFx0Ly8gcHJldmlvdXNseSB1bmtub3duIGNsaXAvcm9vdCBjb21iaW5hdGlvbiBpcyBzcGVjaWZpZWQpXFxuXFx0XFx0Y2xpcEFjdGlvbjogZnVuY3Rpb24gKCBjbGlwLCBvcHRpb25hbFJvb3QgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHJvb3QgPSBvcHRpb25hbFJvb3QgfHwgdGhpcy5fcm9vdCxcXG5cXHRcXHRcXHRcXHRyb290VXVpZCA9IHJvb3QudXVpZCxcXG5cXG5cXHRcXHRcXHRcXHRjbGlwT2JqZWN0ID0gdHlwZW9mIGNsaXAgPT09ICdzdHJpbmcnID9cXG5cXHRcXHRcXHRcXHRcXHRBbmltYXRpb25DbGlwLmZpbmRCeU5hbWUoIHJvb3QsIGNsaXAgKSA6IGNsaXAsXFxuXFxuXFx0XFx0XFx0XFx0Y2xpcFV1aWQgPSBjbGlwT2JqZWN0ICE9PSBudWxsID8gY2xpcE9iamVjdC51dWlkIDogY2xpcCxcXG5cXG5cXHRcXHRcXHRcXHRhY3Rpb25zRm9yQ2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF0sXFxuXFx0XFx0XFx0XFx0cHJvdG90eXBlQWN0aW9uID0gbnVsbDtcXG5cXG5cXHRcXHRcXHRpZiAoIGFjdGlvbnNGb3JDbGlwICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGV4aXN0aW5nQWN0aW9uID1cXG5cXHRcXHRcXHRcXHRcXHRcXHRhY3Rpb25zRm9yQ2xpcC5hY3Rpb25CeVJvb3RbIHJvb3RVdWlkIF07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBleGlzdGluZ0FjdGlvbiAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBleGlzdGluZ0FjdGlvbjtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gd2Uga25vdyB0aGUgY2xpcCwgc28gd2UgZG9uJ3QgaGF2ZSB0byBwYXJzZSBhbGxcXG5cXHRcXHRcXHRcXHQvLyB0aGUgYmluZGluZ3MgYWdhaW4gYnV0IGNhbiBqdXN0IGNvcHlcXG5cXHRcXHRcXHRcXHRwcm90b3R5cGVBY3Rpb24gPSBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnNbIDAgXTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBhbHNvLCB0YWtlIHRoZSBjbGlwIGZyb20gdGhlIHByb3RvdHlwZSBhY3Rpb25cXG5cXHRcXHRcXHRcXHRpZiAoIGNsaXBPYmplY3QgPT09IG51bGwgKVxcblxcdFxcdFxcdFxcdFxcdGNsaXBPYmplY3QgPSBwcm90b3R5cGVBY3Rpb24uX2NsaXA7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGNsaXAgbXVzdCBiZSBrbm93biB3aGVuIHNwZWNpZmllZCB2aWEgc3RyaW5nXFxuXFx0XFx0XFx0aWYgKCBjbGlwT2JqZWN0ID09PSBudWxsICkgcmV0dXJuIG51bGw7XFxuXFxuXFx0XFx0XFx0Ly8gYWxsb2NhdGUgYWxsIHJlc291cmNlcyByZXF1aXJlZCB0byBydW4gaXRcXG5cXHRcXHRcXHR2YXIgbmV3QWN0aW9uID0gbmV3IEFuaW1hdGlvbkFjdGlvbiggdGhpcywgY2xpcE9iamVjdCwgb3B0aW9uYWxSb290ICk7XFxuXFxuXFx0XFx0XFx0dGhpcy5fYmluZEFjdGlvbiggbmV3QWN0aW9uLCBwcm90b3R5cGVBY3Rpb24gKTtcXG5cXG5cXHRcXHRcXHQvLyBhbmQgbWFrZSB0aGUgYWN0aW9uIGtub3duIHRvIHRoZSBtZW1vcnkgbWFuYWdlclxcblxcdFxcdFxcdHRoaXMuX2FkZEluYWN0aXZlQWN0aW9uKCBuZXdBY3Rpb24sIGNsaXBVdWlkLCByb290VXVpZCApO1xcblxcblxcdFxcdFxcdHJldHVybiBuZXdBY3Rpb247XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBnZXQgYW4gZXhpc3RpbmcgYWN0aW9uXFxuXFx0XFx0ZXhpc3RpbmdBY3Rpb246IGZ1bmN0aW9uICggY2xpcCwgb3B0aW9uYWxSb290ICkge1xcblxcblxcdFxcdFxcdHZhciByb290ID0gb3B0aW9uYWxSb290IHx8IHRoaXMuX3Jvb3QsXFxuXFx0XFx0XFx0XFx0cm9vdFV1aWQgPSByb290LnV1aWQsXFxuXFxuXFx0XFx0XFx0XFx0Y2xpcE9iamVjdCA9IHR5cGVvZiBjbGlwID09PSAnc3RyaW5nJyA/XFxuXFx0XFx0XFx0XFx0XFx0QW5pbWF0aW9uQ2xpcC5maW5kQnlOYW1lKCByb290LCBjbGlwICkgOiBjbGlwLFxcblxcblxcdFxcdFxcdFxcdGNsaXBVdWlkID0gY2xpcE9iamVjdCA/IGNsaXBPYmplY3QudXVpZCA6IGNsaXAsXFxuXFxuXFx0XFx0XFx0XFx0YWN0aW9uc0ZvckNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdO1xcblxcblxcdFxcdFxcdGlmICggYWN0aW9uc0ZvckNsaXAgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gYWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290WyByb290VXVpZCBdIHx8IG51bGw7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBudWxsO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gZGVhY3RpdmF0ZXMgYWxsIHByZXZpb3VzbHkgc2NoZWR1bGVkIGFjdGlvbnNcXG5cXHRcXHRzdG9wQWxsQWN0aW9uOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxcblxcdFxcdFxcdFxcdG5BY3Rpb25zID0gdGhpcy5fbkFjdGl2ZUFjdGlvbnMsXFxuXFx0XFx0XFx0XFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcXG5cXHRcXHRcXHRcXHRuQmluZGluZ3MgPSB0aGlzLl9uQWN0aXZlQmluZGluZ3M7XFxuXFxuXFx0XFx0XFx0dGhpcy5fbkFjdGl2ZUFjdGlvbnMgPSAwO1xcblxcdFxcdFxcdHRoaXMuX25BY3RpdmVCaW5kaW5ncyA9IDA7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuQWN0aW9uczsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHRcXHRhY3Rpb25zWyBpIF0ucmVzZXQoKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuQmluZGluZ3M7ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0YmluZGluZ3NbIGkgXS51c2VDb3VudCA9IDA7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gYWR2YW5jZSB0aGUgdGltZSBhbmQgdXBkYXRlIGFwcGx5IHRoZSBhbmltYXRpb25cXG5cXHRcXHR1cGRhdGU6IGZ1bmN0aW9uICggZGVsdGFUaW1lICkge1xcblxcblxcdFxcdFxcdGRlbHRhVGltZSAqPSB0aGlzLnRpbWVTY2FsZTtcXG5cXG5cXHRcXHRcXHR2YXIgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXFxuXFx0XFx0XFx0XFx0bkFjdGlvbnMgPSB0aGlzLl9uQWN0aXZlQWN0aW9ucyxcXG5cXG5cXHRcXHRcXHRcXHR0aW1lID0gdGhpcy50aW1lICs9IGRlbHRhVGltZSxcXG5cXHRcXHRcXHRcXHR0aW1lRGlyZWN0aW9uID0gTWF0aC5zaWduKCBkZWx0YVRpbWUgKSxcXG5cXG5cXHRcXHRcXHRcXHRhY2N1SW5kZXggPSB0aGlzLl9hY2N1SW5kZXggXj0gMTtcXG5cXG5cXHRcXHRcXHQvLyBydW4gYWN0aXZlIGFjdGlvbnNcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG5BY3Rpb25zOyArKyBpICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBhY3Rpb24gPSBhY3Rpb25zWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0YWN0aW9uLl91cGRhdGUoIHRpbWUsIGRlbHRhVGltZSwgdGltZURpcmVjdGlvbiwgYWNjdUluZGV4ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIHVwZGF0ZSBzY2VuZSBncmFwaFxcblxcblxcdFxcdFxcdHZhciBiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxcblxcdFxcdFxcdFxcdG5CaW5kaW5ncyA9IHRoaXMuX25BY3RpdmVCaW5kaW5ncztcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG5CaW5kaW5nczsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHRcXHRiaW5kaW5nc1sgaSBdLmFwcGx5KCBhY2N1SW5kZXggKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyByZXR1cm4gdGhpcyBtaXhlcidzIHJvb3QgdGFyZ2V0IG9iamVjdFxcblxcdFxcdGdldFJvb3Q6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5fcm9vdDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIGZyZWUgYWxsIHJlc291cmNlcyBzcGVjaWZpYyB0byBhIHBhcnRpY3VsYXIgY2xpcFxcblxcdFxcdHVuY2FjaGVDbGlwOiBmdW5jdGlvbiAoIGNsaXAgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxcblxcdFxcdFxcdFxcdGNsaXBVdWlkID0gY2xpcC51dWlkLFxcblxcdFxcdFxcdFxcdGFjdGlvbnNCeUNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwLFxcblxcdFxcdFxcdFxcdGFjdGlvbnNGb3JDbGlwID0gYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXTtcXG5cXG5cXHRcXHRcXHRpZiAoIGFjdGlvbnNGb3JDbGlwICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gbm90ZToganVzdCBjYWxsaW5nIF9yZW1vdmVJbmFjdGl2ZUFjdGlvbiB3b3VsZCBtZXNzIHVwIHRoZVxcblxcdFxcdFxcdFxcdC8vIGl0ZXJhdGlvbiBzdGF0ZSBhbmQgYWxzbyByZXF1aXJlIHVwZGF0aW5nIHRoZSBzdGF0ZSB3ZSBjYW5cXG5cXHRcXHRcXHRcXHQvLyBqdXN0IHRocm93IGF3YXlcXG5cXG5cXHRcXHRcXHRcXHR2YXIgYWN0aW9uc1RvUmVtb3ZlID0gYWN0aW9uc0ZvckNsaXAua25vd25BY3Rpb25zO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbiA9IGFjdGlvbnNUb1JlbW92ZS5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGFjdGlvbiA9IGFjdGlvbnNUb1JlbW92ZVsgaSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2RlYWN0aXZhdGVBY3Rpb24oIGFjdGlvbiApO1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBjYWNoZUluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4LFxcblxcdFxcdFxcdFxcdFxcdFxcdGxhc3RJbmFjdGl2ZUFjdGlvbiA9IGFjdGlvbnNbIGFjdGlvbnMubGVuZ3RoIC0gMSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdGFjdGlvbi5fY2FjaGVJbmRleCA9IG51bGw7XFxuXFx0XFx0XFx0XFx0XFx0YWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4ID0gbnVsbDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRsYXN0SW5hY3RpdmVBY3Rpb24uX2NhY2hlSW5kZXggPSBjYWNoZUluZGV4O1xcblxcdFxcdFxcdFxcdFxcdGFjdGlvbnNbIGNhY2hlSW5kZXggXSA9IGxhc3RJbmFjdGl2ZUFjdGlvbjtcXG5cXHRcXHRcXHRcXHRcXHRhY3Rpb25zLnBvcCgpO1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZ3NGb3JBY3Rpb24oIGFjdGlvbiApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRkZWxldGUgYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBmcmVlIGFsbCByZXNvdXJjZXMgc3BlY2lmaWMgdG8gYSBwYXJ0aWN1bGFyIHJvb3QgdGFyZ2V0IG9iamVjdFxcblxcdFxcdHVuY2FjaGVSb290OiBmdW5jdGlvbiAoIHJvb3QgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHJvb3RVdWlkID0gcm9vdC51dWlkLFxcblxcdFxcdFxcdFxcdGFjdGlvbnNCeUNsaXAgPSB0aGlzLl9hY3Rpb25zQnlDbGlwO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBjbGlwVXVpZCBpbiBhY3Rpb25zQnlDbGlwICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBhY3Rpb25CeVJvb3QgPSBhY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdLmFjdGlvbkJ5Um9vdCxcXG5cXHRcXHRcXHRcXHRcXHRhY3Rpb24gPSBhY3Rpb25CeVJvb3RbIHJvb3RVdWlkIF07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBhY3Rpb24gIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9kZWFjdGl2YXRlQWN0aW9uKCBhY3Rpb24gKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUFjdGlvbiggYWN0aW9uICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgYmluZGluZ3NCeVJvb3QgPSB0aGlzLl9iaW5kaW5nc0J5Um9vdEFuZE5hbWUsXFxuXFx0XFx0XFx0XFx0YmluZGluZ0J5TmFtZSA9IGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdO1xcblxcblxcdFxcdFxcdGlmICggYmluZGluZ0J5TmFtZSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciB0cmFja05hbWUgaW4gYmluZGluZ0J5TmFtZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgYmluZGluZyA9IGJpbmRpbmdCeU5hbWVbIHRyYWNrTmFtZSBdO1xcblxcdFxcdFxcdFxcdFxcdGJpbmRpbmcucmVzdG9yZU9yaWdpbmFsU3RhdGUoKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUJpbmRpbmcoIGJpbmRpbmcgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gcmVtb3ZlIGEgdGFyZ2V0ZWQgY2xpcCBmcm9tIHRoZSBjYWNoZVxcblxcdFxcdHVuY2FjaGVBY3Rpb246IGZ1bmN0aW9uICggY2xpcCwgb3B0aW9uYWxSb290ICkge1xcblxcblxcdFxcdFxcdHZhciBhY3Rpb24gPSB0aGlzLmV4aXN0aW5nQWN0aW9uKCBjbGlwLCBvcHRpb25hbFJvb3QgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGFjdGlvbiAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl9kZWFjdGl2YXRlQWN0aW9uKCBhY3Rpb24gKTtcXG5cXHRcXHRcXHRcXHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUFjdGlvbiggYWN0aW9uICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBVbmlmb3JtKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVW5pZm9ybTogVHlwZSBwYXJhbWV0ZXIgaXMgbm8gbG9uZ2VyIG5lZWRlZC4nICk7XFxuXFx0XFx0XFx0dmFsdWUgPSBhcmd1bWVudHNbIDEgXTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xcblxcblxcdH1cXG5cXG5cXHRVbmlmb3JtLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRyZXR1cm4gbmV3IFVuaWZvcm0oIHRoaXMudmFsdWUuY2xvbmUgPT09IHVuZGVmaW5lZCA/IHRoaXMudmFsdWUgOiB0aGlzLnZhbHVlLmNsb25lKCkgKTtcXG5cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5KCkge1xcblxcblxcdFxcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnknO1xcblxcdFxcdHRoaXMubWF4SW5zdGFuY2VkQ291bnQgPSB1bmRlZmluZWQ7XFxuXFxuXFx0fVxcblxcblxcdEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IEluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LFxcblxcblxcdFxcdGlzSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnk6IHRydWUsXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxuXFxuXFx0XFx0XFx0QnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxuXFxuXFx0XFx0XFx0dGhpcy5tYXhJbnN0YW5jZWRDb3VudCA9IHNvdXJjZS5tYXhJbnN0YW5jZWRDb3VudDtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUoIGludGVybGVhdmVkQnVmZmVyLCBpdGVtU2l6ZSwgb2Zmc2V0LCBub3JtYWxpemVkICkge1xcblxcblxcdFxcdHRoaXMudXVpZCA9IF9NYXRoLmdlbmVyYXRlVVVJRCgpO1xcblxcblxcdFxcdHRoaXMuZGF0YSA9IGludGVybGVhdmVkQnVmZmVyO1xcblxcdFxcdHRoaXMuaXRlbVNpemUgPSBpdGVtU2l6ZTtcXG5cXHRcXHR0aGlzLm9mZnNldCA9IG9mZnNldDtcXG5cXG5cXHRcXHR0aGlzLm5vcm1hbGl6ZWQgPSBub3JtYWxpemVkID09PSB0cnVlO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0Y291bnQ6IHtcXG5cXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5kYXRhLmNvdW50O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGFycmF5OiB7XFxuXFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZGF0YS5hcnJheTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHRPYmplY3QuYXNzaWduKCBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRpc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlOiB0cnVlLFxcblxcblxcdFxcdHNldFg6IGZ1bmN0aW9uICggaW5kZXgsIHggKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCBdID0geDtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFk6IGZ1bmN0aW9uICggaW5kZXgsIHkgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDEgXSA9IHk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRaOiBmdW5jdGlvbiAoIGluZGV4LCB6ICkge1xcblxcblxcdFxcdFxcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAyIF0gPSB6O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0VzogZnVuY3Rpb24gKCBpbmRleCwgdyApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMyBdID0gdztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldFg6IGZ1bmN0aW9uICggaW5kZXggKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgXTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldFk6IGZ1bmN0aW9uICggaW5kZXggKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAxIF07XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRaOiBmdW5jdGlvbiAoIGluZGV4ICkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMiBdO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0VzogZnVuY3Rpb24gKCBpbmRleCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDMgXTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFhZOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5ICkge1xcblxcblxcdFxcdFxcdGluZGV4ID0gaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQ7XFxuXFxuXFx0XFx0XFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XFxuXFx0XFx0XFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRYWVo6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHksIHogKSB7XFxuXFxuXFx0XFx0XFx0aW5kZXggPSBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldDtcXG5cXG5cXHRcXHRcXHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcXG5cXHRcXHRcXHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcXG5cXHRcXHRcXHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFhZWlc6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHksIHosIHcgKSB7XFxuXFxuXFx0XFx0XFx0aW5kZXggPSBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldDtcXG5cXG5cXHRcXHRcXHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcXG5cXHRcXHRcXHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcXG5cXHRcXHRcXHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMiBdID0gejtcXG5cXHRcXHRcXHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMyBdID0gdztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEludGVybGVhdmVkQnVmZmVyKCBhcnJheSwgc3RyaWRlICkge1xcblxcblxcdFxcdHRoaXMudXVpZCA9IF9NYXRoLmdlbmVyYXRlVVVJRCgpO1xcblxcblxcdFxcdHRoaXMuYXJyYXkgPSBhcnJheTtcXG5cXHRcXHR0aGlzLnN0cmlkZSA9IHN0cmlkZTtcXG5cXHRcXHR0aGlzLmNvdW50ID0gYXJyYXkgIT09IHVuZGVmaW5lZCA/IGFycmF5Lmxlbmd0aCAvIHN0cmlkZSA6IDA7XFxuXFxuXFx0XFx0dGhpcy5keW5hbWljID0gZmFsc2U7XFxuXFx0XFx0dGhpcy51cGRhdGVSYW5nZSA9IHsgb2Zmc2V0OiAwLCBjb3VudDogLSAxIH07XFxuXFxuXFx0XFx0dGhpcy5vblVwbG9hZENhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XFxuXFxuXFx0XFx0dGhpcy52ZXJzaW9uID0gMDtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBJbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUsICduZWVkc1VwZGF0ZScsIHtcXG5cXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudmVyc2lvbiArKztcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdE9iamVjdC5hc3NpZ24oIEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSwge1xcblxcblxcdFxcdGlzSW50ZXJsZWF2ZWRCdWZmZXI6IHRydWUsXFxuXFxuXFx0XFx0c2V0QXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBBcnJheS5pc0FycmF5KCBhcnJheSApICkge1xcblxcblxcdFxcdFxcdFxcdHRocm93IG5ldyBUeXBlRXJyb3IoICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IGFycmF5IHNob3VsZCBiZSBhIFR5cGVkIEFycmF5LicgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5jb3VudCA9IGFycmF5ICE9PSB1bmRlZmluZWQgPyBhcnJheS5sZW5ndGggLyB0aGlzLnN0cmlkZSA6IDA7XFxuXFx0XFx0XFx0dGhpcy5hcnJheSA9IGFycmF5O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0RHluYW1pYzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmR5bmFtaWMgPSB2YWx1ZTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdFxcdHRoaXMuYXJyYXkgPSBuZXcgc291cmNlLmFycmF5LmNvbnN0cnVjdG9yKCBzb3VyY2UuYXJyYXkgKTtcXG5cXHRcXHRcXHR0aGlzLmNvdW50ID0gc291cmNlLmNvdW50O1xcblxcdFxcdFxcdHRoaXMuc3RyaWRlID0gc291cmNlLnN0cmlkZTtcXG5cXHRcXHRcXHR0aGlzLmR5bmFtaWMgPSBzb3VyY2UuZHluYW1pYztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHlBdDogZnVuY3Rpb24gKCBpbmRleDEsIGF0dHJpYnV0ZSwgaW5kZXgyICkge1xcblxcblxcdFxcdFxcdGluZGV4MSAqPSB0aGlzLnN0cmlkZTtcXG5cXHRcXHRcXHRpbmRleDIgKj0gYXR0cmlidXRlLnN0cmlkZTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLnN0cmlkZTsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5hcnJheVsgaW5kZXgxICsgaSBdID0gYXR0cmlidXRlLmFycmF5WyBpbmRleDIgKyBpIF07XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlLCBvZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XFxuXFxuXFx0XFx0XFx0dGhpcy5hcnJheS5zZXQoIHZhbHVlLCBvZmZzZXQgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0b25VcGxvYWQ6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5vblVwbG9hZENhbGxiYWNrID0gY2FsbGJhY2s7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciggYXJyYXksIHN0cmlkZSwgbWVzaFBlckF0dHJpYnV0ZSApIHtcXG5cXG5cXHRcXHRJbnRlcmxlYXZlZEJ1ZmZlci5jYWxsKCB0aGlzLCBhcnJheSwgc3RyaWRlICk7XFxuXFxuXFx0XFx0dGhpcy5tZXNoUGVyQXR0cmlidXRlID0gbWVzaFBlckF0dHJpYnV0ZSB8fCAxO1xcblxcblxcdH1cXG5cXG5cXHRJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBJbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBJbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlcixcXG5cXG5cXHRcXHRpc0luc3RhbmNlZEludGVybGVhdmVkQnVmZmVyOiB0cnVlLFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdFxcdEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcblxcblxcdFxcdFxcdHRoaXMubWVzaFBlckF0dHJpYnV0ZSA9IHNvdXJjZS5tZXNoUGVyQXR0cmlidXRlO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUsIG1lc2hQZXJBdHRyaWJ1dGUgKSB7XFxuXFxuXFx0XFx0QnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIGFycmF5LCBpdGVtU2l6ZSApO1xcblxcblxcdFxcdHRoaXMubWVzaFBlckF0dHJpYnV0ZSA9IG1lc2hQZXJBdHRyaWJ1dGUgfHwgMTtcXG5cXG5cXHR9XFxuXFxuXFx0SW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUsXFxuXFxuXFx0XFx0aXNJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGU6IHRydWUsXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxuXFxuXFx0XFx0XFx0QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcblxcblxcdFxcdFxcdHRoaXMubWVzaFBlckF0dHJpYnV0ZSA9IHNvdXJjZS5tZXNoUGVyQXR0cmlidXRlO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xcblxcdCAqIEBhdXRob3Igc3RlcGhvbWkgLyBodHRwOi8vc3RlcGhhbmVnaW5pZXIuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFJheWNhc3Rlciggb3JpZ2luLCBkaXJlY3Rpb24sIG5lYXIsIGZhciApIHtcXG5cXG5cXHRcXHR0aGlzLnJheSA9IG5ldyBSYXkoIG9yaWdpbiwgZGlyZWN0aW9uICk7XFxuXFx0XFx0Ly8gZGlyZWN0aW9uIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZCAoZm9yIGFjY3VyYXRlIGRpc3RhbmNlIGNhbGN1bGF0aW9ucylcXG5cXG5cXHRcXHR0aGlzLm5lYXIgPSBuZWFyIHx8IDA7XFxuXFx0XFx0dGhpcy5mYXIgPSBmYXIgfHwgSW5maW5pdHk7XFxuXFxuXFx0XFx0dGhpcy5wYXJhbXMgPSB7XFxuXFx0XFx0XFx0TWVzaDoge30sXFxuXFx0XFx0XFx0TGluZToge30sXFxuXFx0XFx0XFx0TE9EOiB7fSxcXG5cXHRcXHRcXHRQb2ludHM6IHsgdGhyZXNob2xkOiAxIH0sXFxuXFx0XFx0XFx0U3ByaXRlOiB7fVxcblxcdFxcdH07XFxuXFxuXFx0XFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMucGFyYW1zLCB7XFxuXFx0XFx0XFx0UG9pbnRDbG91ZDoge1xcblxcdFxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlJheWNhc3RlcjogcGFyYW1zLlBvaW50Q2xvdWQgaGFzIGJlZW4gcmVuYW1lZCB0byBwYXJhbXMuUG9pbnRzLicgKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5Qb2ludHM7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9ICk7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGFzY1NvcnQoIGEsIGIgKSB7XFxuXFxuXFx0XFx0cmV0dXJuIGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBpbnRlcnNlY3RPYmplY3QoIG9iamVjdCwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKSB7XFxuXFxuXFx0XFx0aWYgKCBvYmplY3QudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XFxuXFxuXFx0XFx0b2JqZWN0LnJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApO1xcblxcblxcdFxcdGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xcblxcblxcdFxcdFxcdHZhciBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdGludGVyc2VjdE9iamVjdCggY2hpbGRyZW5bIGkgXSwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzLCB0cnVlICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggUmF5Y2FzdGVyLnByb3RvdHlwZSwge1xcblxcblxcdFxcdGxpbmVQcmVjaXNpb246IDEsXFxuXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiAoIG9yaWdpbiwgZGlyZWN0aW9uICkge1xcblxcblxcdFxcdFxcdC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXFxuXFxuXFx0XFx0XFx0dGhpcy5yYXkuc2V0KCBvcmlnaW4sIGRpcmVjdGlvbiApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0RnJvbUNhbWVyYTogZnVuY3Rpb24gKCBjb29yZHMsIGNhbWVyYSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoICggY2FtZXJhICYmIGNhbWVyYS5pc1BlcnNwZWN0aXZlQ2FtZXJhICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5yYXkub3JpZ2luLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XFxuXFx0XFx0XFx0XFx0dGhpcy5yYXkuZGlyZWN0aW9uLnNldCggY29vcmRzLngsIGNvb3Jkcy55LCAwLjUgKS51bnByb2plY3QoIGNhbWVyYSApLnN1YiggdGhpcy5yYXkub3JpZ2luICkubm9ybWFsaXplKCk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggKCBjYW1lcmEgJiYgY2FtZXJhLmlzT3J0aG9ncmFwaGljQ2FtZXJhICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5yYXkub3JpZ2luLnNldCggY29vcmRzLngsIGNvb3Jkcy55LCAoIGNhbWVyYS5uZWFyICsgY2FtZXJhLmZhciApIC8gKCBjYW1lcmEubmVhciAtIGNhbWVyYS5mYXIgKSApLnVucHJvamVjdCggY2FtZXJhICk7IC8vIHNldCBvcmlnaW4gaW4gcGxhbmUgb2YgY2FtZXJhXFxuXFx0XFx0XFx0XFx0dGhpcy5yYXkuZGlyZWN0aW9uLnNldCggMCwgMCwgLSAxICkudHJhbnNmb3JtRGlyZWN0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5SYXljYXN0ZXI6IFVuc3VwcG9ydGVkIGNhbWVyYSB0eXBlLicgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRpbnRlcnNlY3RPYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0LCByZWN1cnNpdmUgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGludGVyc2VjdHMgPSBbXTtcXG5cXG5cXHRcXHRcXHRpbnRlcnNlY3RPYmplY3QoIG9iamVjdCwgdGhpcywgaW50ZXJzZWN0cywgcmVjdXJzaXZlICk7XFxuXFxuXFx0XFx0XFx0aW50ZXJzZWN0cy5zb3J0KCBhc2NTb3J0ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGludGVyc2VjdHM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRpbnRlcnNlY3RPYmplY3RzOiBmdW5jdGlvbiAoIG9iamVjdHMsIHJlY3Vyc2l2ZSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgaW50ZXJzZWN0cyA9IFtdO1xcblxcblxcdFxcdFxcdGlmICggQXJyYXkuaXNBcnJheSggb2JqZWN0cyApID09PSBmYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5SYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0czogb2JqZWN0cyBpcyBub3QgYW4gQXJyYXkuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybiBpbnRlcnNlY3RzO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBvYmplY3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aW50ZXJzZWN0T2JqZWN0KCBvYmplY3RzWyBpIF0sIHRoaXMsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpbnRlcnNlY3RzLnNvcnQoIGFzY1NvcnQgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gaW50ZXJzZWN0cztcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gQ2xvY2soIGF1dG9TdGFydCApIHtcXG5cXG5cXHRcXHR0aGlzLmF1dG9TdGFydCA9ICggYXV0b1N0YXJ0ICE9PSB1bmRlZmluZWQgKSA/IGF1dG9TdGFydCA6IHRydWU7XFxuXFxuXFx0XFx0dGhpcy5zdGFydFRpbWUgPSAwO1xcblxcdFxcdHRoaXMub2xkVGltZSA9IDA7XFxuXFx0XFx0dGhpcy5lbGFwc2VkVGltZSA9IDA7XFxuXFxuXFx0XFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5hc3NpZ24oIENsb2NrLnByb3RvdHlwZSwge1xcblxcblxcdFxcdHN0YXJ0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5zdGFydFRpbWUgPSAoIHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ3VuZGVmaW5lZCcgPyBEYXRlIDogcGVyZm9ybWFuY2UgKS5ub3coKTsgLy8gc2VlICMxMDczMlxcblxcblxcdFxcdFxcdHRoaXMub2xkVGltZSA9IHRoaXMuc3RhcnRUaW1lO1xcblxcdFxcdFxcdHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xcblxcdFxcdFxcdHRoaXMucnVubmluZyA9IHRydWU7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzdG9wOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5nZXRFbGFwc2VkVGltZSgpO1xcblxcdFxcdFxcdHRoaXMucnVubmluZyA9IGZhbHNlO1xcblxcdFxcdFxcdHRoaXMuYXV0b1N0YXJ0ID0gZmFsc2U7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRFbGFwc2VkVGltZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMuZ2V0RGVsdGEoKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5lbGFwc2VkVGltZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldERlbHRhOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGRpZmYgPSAwO1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5hdXRvU3RhcnQgJiYgISB0aGlzLnJ1bm5pbmcgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5zdGFydCgpO1xcblxcdFxcdFxcdFxcdHJldHVybiAwO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMucnVubmluZyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbmV3VGltZSA9ICggdHlwZW9mIHBlcmZvcm1hbmNlID09PSAndW5kZWZpbmVkJyA/IERhdGUgOiBwZXJmb3JtYW5jZSApLm5vdygpO1xcblxcblxcdFxcdFxcdFxcdGRpZmYgPSAoIG5ld1RpbWUgLSB0aGlzLm9sZFRpbWUgKSAvIDEwMDA7XFxuXFx0XFx0XFx0XFx0dGhpcy5vbGRUaW1lID0gbmV3VGltZTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmVsYXBzZWRUaW1lICs9IGRpZmY7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBkaWZmO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xcblxcdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxcblxcdCAqXFxuXFx0ICogUmVmOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TcGhlcmljYWxfY29vcmRpbmF0ZV9zeXN0ZW1cXG5cXHQgKlxcblxcdCAqIFRoZSBwb2xlcyAocGhpKSBhcmUgYXQgdGhlIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB5IGF4aXMuXFxuXFx0ICogVGhlIGVxdWF0b3Igc3RhcnRzIGF0IHBvc2l0aXZlIHouXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gU3BoZXJpY2FsKCByYWRpdXMsIHBoaSwgdGhldGEgKSB7XFxuXFxuXFx0XFx0dGhpcy5yYWRpdXMgPSAoIHJhZGl1cyAhPT0gdW5kZWZpbmVkICkgPyByYWRpdXMgOiAxLjA7XFxuXFx0XFx0dGhpcy5waGkgPSAoIHBoaSAhPT0gdW5kZWZpbmVkICkgPyBwaGkgOiAwOyAvLyB1cCAvIGRvd24gdG93YXJkcyB0b3AgYW5kIGJvdHRvbSBwb2xlXFxuXFx0XFx0dGhpcy50aGV0YSA9ICggdGhldGEgIT09IHVuZGVmaW5lZCApID8gdGhldGEgOiAwOyAvLyBhcm91bmQgdGhlIGVxdWF0b3Igb2YgdGhlIHNwaGVyZVxcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBTcGhlcmljYWwucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiAoIHJhZGl1cywgcGhpLCB0aGV0YSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnJhZGl1cyA9IHJhZGl1cztcXG5cXHRcXHRcXHR0aGlzLnBoaSA9IHBoaTtcXG5cXHRcXHRcXHR0aGlzLnRoZXRhID0gdGhldGE7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggb3RoZXIgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5yYWRpdXMgPSBvdGhlci5yYWRpdXM7XFxuXFx0XFx0XFx0dGhpcy5waGkgPSBvdGhlci5waGk7XFxuXFx0XFx0XFx0dGhpcy50aGV0YSA9IG90aGVyLnRoZXRhO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gcmVzdHJpY3QgcGhpIHRvIGJlIGJldHdlZSBFUFMgYW5kIFBJLUVQU1xcblxcdFxcdG1ha2VTYWZlOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIEVQUyA9IDAuMDAwMDAxO1xcblxcdFxcdFxcdHRoaXMucGhpID0gTWF0aC5tYXgoIEVQUywgTWF0aC5taW4oIE1hdGguUEkgLSBFUFMsIHRoaXMucGhpICkgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldEZyb21WZWN0b3IzOiBmdW5jdGlvbiAoIHZlYzMgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5yYWRpdXMgPSB2ZWMzLmxlbmd0aCgpO1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5yYWRpdXMgPT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy50aGV0YSA9IDA7XFxuXFx0XFx0XFx0XFx0dGhpcy5waGkgPSAwO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy50aGV0YSA9IE1hdGguYXRhbjIoIHZlYzMueCwgdmVjMy56ICk7IC8vIGVxdWF0b3IgYW5nbGUgYXJvdW5kIHktdXAgYXhpc1xcblxcdFxcdFxcdFxcdHRoaXMucGhpID0gTWF0aC5hY29zKCBfTWF0aC5jbGFtcCggdmVjMy55IC8gdGhpcy5yYWRpdXMsIC0gMSwgMSApICk7IC8vIHBvbGFyIGFuZ2xlXFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcXG5cXHQgKlxcblxcdCAqIFJlZjogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3lsaW5kcmljYWxfY29vcmRpbmF0ZV9zeXN0ZW1cXG5cXHQgKlxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEN5bGluZHJpY2FsKCByYWRpdXMsIHRoZXRhLCB5ICkge1xcblxcblxcdFxcdHRoaXMucmFkaXVzID0gKCByYWRpdXMgIT09IHVuZGVmaW5lZCApID8gcmFkaXVzIDogMS4wOyAvLyBkaXN0YW5jZSBmcm9tIHRoZSBvcmlnaW4gdG8gYSBwb2ludCBpbiB0aGUgeC16IHBsYW5lXFxuXFx0XFx0dGhpcy50aGV0YSA9ICggdGhldGEgIT09IHVuZGVmaW5lZCApID8gdGhldGEgOiAwOyAvLyBjb3VudGVyY2xvY2t3aXNlIGFuZ2xlIGluIHRoZSB4LXogcGxhbmUgbWVhc3VyZWQgaW4gcmFkaWFucyBmcm9tIHRoZSBwb3NpdGl2ZSB6LWF4aXNcXG5cXHRcXHR0aGlzLnkgPSAoIHkgIT09IHVuZGVmaW5lZCApID8geSA6IDA7IC8vIGhlaWdodCBhYm92ZSB0aGUgeC16IHBsYW5lXFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5hc3NpZ24oIEN5bGluZHJpY2FsLnByb3RvdHlwZSwge1xcblxcblxcdFxcdHNldDogZnVuY3Rpb24gKCByYWRpdXMsIHRoZXRhLCB5ICkge1xcblxcblxcdFxcdFxcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xcblxcdFxcdFxcdHRoaXMudGhldGEgPSB0aGV0YTtcXG5cXHRcXHRcXHR0aGlzLnkgPSB5O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIG90aGVyICkge1xcblxcblxcdFxcdFxcdHRoaXMucmFkaXVzID0gb3RoZXIucmFkaXVzO1xcblxcdFxcdFxcdHRoaXMudGhldGEgPSBvdGhlci50aGV0YTtcXG5cXHRcXHRcXHR0aGlzLnkgPSBvdGhlci55O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0RnJvbVZlY3RvcjM6IGZ1bmN0aW9uICggdmVjMyApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnJhZGl1cyA9IE1hdGguc3FydCggdmVjMy54ICogdmVjMy54ICsgdmVjMy56ICogdmVjMy56ICk7XFxuXFx0XFx0XFx0dGhpcy50aGV0YSA9IE1hdGguYXRhbjIoIHZlYzMueCwgdmVjMy56ICk7XFxuXFx0XFx0XFx0dGhpcy55ID0gdmVjMy55O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBJbW1lZGlhdGVSZW5kZXJPYmplY3QoIG1hdGVyaWFsICkge1xcblxcblxcdFxcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWw7XFxuXFx0XFx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIC8qIHJlbmRlckNhbGxiYWNrICovICkge307XFxuXFxuXFx0fVxcblxcblxcdEltbWVkaWF0ZVJlbmRlck9iamVjdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKTtcXG5cXHRJbW1lZGlhdGVSZW5kZXJPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW1tZWRpYXRlUmVuZGVyT2JqZWN0O1xcblxcblxcdEltbWVkaWF0ZVJlbmRlck9iamVjdC5wcm90b3R5cGUuaXNJbW1lZGlhdGVSZW5kZXJPYmplY3QgPSB0cnVlO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gVmVydGV4Tm9ybWFsc0hlbHBlciggb2JqZWN0LCBzaXplLCBoZXgsIGxpbmV3aWR0aCApIHtcXG5cXG5cXHRcXHR0aGlzLm9iamVjdCA9IG9iamVjdDtcXG5cXG5cXHRcXHR0aGlzLnNpemUgPSAoIHNpemUgIT09IHVuZGVmaW5lZCApID8gc2l6ZSA6IDE7XFxuXFxuXFx0XFx0dmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZjAwMDA7XFxuXFxuXFx0XFx0dmFyIHdpZHRoID0gKCBsaW5ld2lkdGggIT09IHVuZGVmaW5lZCApID8gbGluZXdpZHRoIDogMTtcXG5cXG5cXHRcXHQvL1xcblxcblxcdFxcdHZhciBuTm9ybWFscyA9IDA7XFxuXFxuXFx0XFx0dmFyIG9iakdlb21ldHJ5ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnk7XFxuXFxuXFx0XFx0aWYgKCBvYmpHZW9tZXRyeSAmJiBvYmpHZW9tZXRyeS5pc0dlb21ldHJ5ICkge1xcblxcblxcdFxcdFxcdG5Ob3JtYWxzID0gb2JqR2VvbWV0cnkuZmFjZXMubGVuZ3RoICogMztcXG5cXG5cXHRcXHR9IGVsc2UgaWYgKCBvYmpHZW9tZXRyeSAmJiBvYmpHZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkge1xcblxcblxcdFxcdFxcdG5Ob3JtYWxzID0gb2JqR2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWwuY291bnQ7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vXFxuXFxuXFx0XFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XFxuXFxuXFx0XFx0dmFyIHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBuTm9ybWFscyAqIDIgKiAzLCAzICk7XFxuXFxuXFx0XFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbnMgKTtcXG5cXG5cXHRcXHRMaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIGxpbmV3aWR0aDogd2lkdGggfSApICk7XFxuXFxuXFx0XFx0Ly9cXG5cXG5cXHRcXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcXG5cXG5cXHRcXHR0aGlzLnVwZGF0ZSgpO1xcblxcblxcdH1cXG5cXG5cXHRWZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcXG5cXHRWZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFZlcnRleE5vcm1hbHNIZWxwZXI7XFxuXFxuXFx0VmVydGV4Tm9ybWFsc0hlbHBlci5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHR2YXIgdjIgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdHZhciBub3JtYWxNYXRyaXggPSBuZXcgTWF0cml4MygpO1xcblxcblxcdFxcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGtleXMgPSBbICdhJywgJ2InLCAnYycgXTtcXG5cXG5cXHRcXHRcXHR0aGlzLm9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xcblxcblxcdFxcdFxcdG5vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkICk7XFxuXFxuXFx0XFx0XFx0dmFyIG1hdHJpeFdvcmxkID0gdGhpcy5vYmplY3QubWF0cml4V29ybGQ7XFxuXFxuXFx0XFx0XFx0dmFyIHBvc2l0aW9uID0gdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xcblxcblxcdFxcdFxcdC8vXFxuXFxuXFx0XFx0XFx0dmFyIG9iakdlb21ldHJ5ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnk7XFxuXFxuXFx0XFx0XFx0aWYgKCBvYmpHZW9tZXRyeSAmJiBvYmpHZW9tZXRyeS5pc0dlb21ldHJ5ICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB2ZXJ0aWNlcyA9IG9iakdlb21ldHJ5LnZlcnRpY2VzO1xcblxcblxcdFxcdFxcdFxcdHZhciBmYWNlcyA9IG9iakdlb21ldHJ5LmZhY2VzO1xcblxcblxcdFxcdFxcdFxcdHZhciBpZHggPSAwO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHZlcnRleCA9IHZlcnRpY2VzWyBmYWNlWyBrZXlzWyBqIF0gXSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBub3JtYWwgPSBmYWNlLnZlcnRleE5vcm1hbHNbIGogXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2MS5jb3B5KCB2ZXJ0ZXggKS5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0djIuY29weSggbm9ybWFsICkuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggdGhpcy5zaXplICkuYWRkKCB2MSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uLnNldFhZWiggaWR4LCB2MS54LCB2MS55LCB2MS56ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWR4ID0gaWR4ICsgMTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjIueCwgdjIueSwgdjIueiApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlkeCA9IGlkeCArIDE7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBvYmpHZW9tZXRyeSAmJiBvYmpHZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBvYmpQb3MgPSBvYmpHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xcblxcblxcdFxcdFxcdFxcdHZhciBvYmpOb3JtID0gb2JqR2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWw7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGlkeCA9IDA7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gZm9yIHNpbXBsaWNpdHksIGlnbm9yZSBpbmRleCBhbmQgZHJhd2NhbGxzLCBhbmQgcmVuZGVyIGV2ZXJ5IG5vcm1hbFxcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBqID0gMCwgamwgPSBvYmpQb3MuY291bnQ7IGogPCBqbDsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2MS5zZXQoIG9ialBvcy5nZXRYKCBqICksIG9ialBvcy5nZXRZKCBqICksIG9ialBvcy5nZXRaKCBqICkgKS5hcHBseU1hdHJpeDQoIG1hdHJpeFdvcmxkICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0djIuc2V0KCBvYmpOb3JtLmdldFgoIGogKSwgb2JqTm9ybS5nZXRZKCBqICksIG9iak5vcm0uZ2V0WiggaiApICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0djIuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggdGhpcy5zaXplICkuYWRkKCB2MSApO1xcblxcblxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uLnNldFhZWiggaWR4LCB2MS54LCB2MS55LCB2MS56ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWR4ID0gaWR4ICsgMTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjIueCwgdjIueSwgdjIueiApO1xcblxcblxcdFxcdFxcdFxcdFxcdGlkeCA9IGlkeCArIDE7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHR9KCkgKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gU3BvdExpZ2h0SGVscGVyKCBsaWdodCwgY29sb3IgKSB7XFxuXFxuXFx0XFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMubGlnaHQgPSBsaWdodDtcXG5cXHRcXHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XFxuXFxuXFx0XFx0dGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcXG5cXHRcXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcXG5cXG5cXHRcXHR0aGlzLmNvbG9yID0gY29sb3I7XFxuXFxuXFx0XFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XFxuXFxuXFx0XFx0dmFyIHBvc2l0aW9ucyA9IFtcXG5cXHRcXHRcXHQwLCAwLCAwLCBcXHQwLCAwLCAxLFxcblxcdFxcdFxcdDAsIDAsIDAsIFxcdDEsIDAsIDEsXFxuXFx0XFx0XFx0MCwgMCwgMCxcXHQtIDEsIDAsIDEsXFxuXFx0XFx0XFx0MCwgMCwgMCwgXFx0MCwgMSwgMSxcXG5cXHRcXHRcXHQwLCAwLCAwLCBcXHQwLCAtIDEsIDFcXG5cXHRcXHRdO1xcblxcblxcdFxcdGZvciAoIHZhciBpID0gMCwgaiA9IDEsIGwgPSAzMjsgaSA8IGw7IGkgKyssIGogKysgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHAxID0gKCBpIC8gbCApICogTWF0aC5QSSAqIDI7XFxuXFx0XFx0XFx0dmFyIHAyID0gKCBqIC8gbCApICogTWF0aC5QSSAqIDI7XFxuXFxuXFx0XFx0XFx0cG9zaXRpb25zLnB1c2goXFxuXFx0XFx0XFx0XFx0TWF0aC5jb3MoIHAxICksIE1hdGguc2luKCBwMSApLCAxLFxcblxcdFxcdFxcdFxcdE1hdGguY29zKCBwMiApLCBNYXRoLnNpbiggcDIgKSwgMVxcblxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XFxuXFxuXFx0XFx0dmFyIG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGZvZzogZmFsc2UgfSApO1xcblxcblxcdFxcdHRoaXMuY29uZSA9IG5ldyBMaW5lU2VnbWVudHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xcblxcdFxcdHRoaXMuYWRkKCB0aGlzLmNvbmUgKTtcXG5cXG5cXHRcXHR0aGlzLnVwZGF0ZSgpO1xcblxcblxcdH1cXG5cXG5cXHRTcG90TGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICk7XFxuXFx0U3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNwb3RMaWdodEhlbHBlcjtcXG5cXG5cXHRTcG90TGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0dGhpcy5jb25lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcXG5cXHRcXHR0aGlzLmNvbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xcblxcblxcdH07XFxuXFxuXFx0U3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0dmFyIHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0dmFyIHZlY3RvcjIgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xcblxcblxcdFxcdFxcdHZhciBjb25lTGVuZ3RoID0gdGhpcy5saWdodC5kaXN0YW5jZSA/IHRoaXMubGlnaHQuZGlzdGFuY2UgOiAxMDAwO1xcblxcdFxcdFxcdHZhciBjb25lV2lkdGggPSBjb25lTGVuZ3RoICogTWF0aC50YW4oIHRoaXMubGlnaHQuYW5nbGUgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLmNvbmUuc2NhbGUuc2V0KCBjb25lV2lkdGgsIGNvbmVXaWR0aCwgY29uZUxlbmd0aCApO1xcblxcblxcdFxcdFxcdHZlY3Rvci5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKTtcXG5cXHRcXHRcXHR2ZWN0b3IyLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLmNvbmUubG9va0F0KCB2ZWN0b3IyLnN1YiggdmVjdG9yICkgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuY29sb3IgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3Iuc2V0KCB0aGlzLmNvbG9yICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9O1xcblxcblxcdH0oKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIFNlYW4gR3JpZmZpbiAvIGh0dHA6Ly90d2l0dGVyLmNvbS9zZ3JpZlxcblxcdCAqIEBhdXRob3IgTWljaGFlbCBHdWVycmVybyAvIGh0dHA6Ly9yZWFsaXR5bWVsdGRvd24uY29tXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cXG5cXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIGdldEJvbmVMaXN0KCBvYmplY3QgKSB7XFxuXFxuXFx0XFx0dmFyIGJvbmVMaXN0ID0gW107XFxuXFxuXFx0XFx0aWYgKCBvYmplY3QgJiYgb2JqZWN0LmlzQm9uZSApIHtcXG5cXG5cXHRcXHRcXHRib25lTGlzdC5wdXNoKCBvYmplY3QgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgb2JqZWN0LmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRib25lTGlzdC5wdXNoLmFwcGx5KCBib25lTGlzdCwgZ2V0Qm9uZUxpc3QoIG9iamVjdC5jaGlsZHJlblsgaSBdICkgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGJvbmVMaXN0O1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBTa2VsZXRvbkhlbHBlciggb2JqZWN0ICkge1xcblxcblxcdFxcdHZhciBib25lcyA9IGdldEJvbmVMaXN0KCBvYmplY3QgKTtcXG5cXG5cXHRcXHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcXG5cXG5cXHRcXHR2YXIgdmVydGljZXMgPSBbXTtcXG5cXHRcXHR2YXIgY29sb3JzID0gW107XFxuXFxuXFx0XFx0dmFyIGNvbG9yMSA9IG5ldyBDb2xvciggMCwgMCwgMSApO1xcblxcdFxcdHZhciBjb2xvcjIgPSBuZXcgQ29sb3IoIDAsIDEsIDAgKTtcXG5cXG5cXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBib25lcy5sZW5ndGg7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGJvbmUgPSBib25lc1sgaSBdO1xcblxcblxcdFxcdFxcdGlmICggYm9uZS5wYXJlbnQgJiYgYm9uZS5wYXJlbnQuaXNCb25lICkge1xcblxcblxcdFxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIDAsIDAsIDAgKTtcXG5cXHRcXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCAwLCAwLCAwICk7XFxuXFx0XFx0XFx0XFx0Y29sb3JzLnB1c2goIGNvbG9yMS5yLCBjb2xvcjEuZywgY29sb3IxLmIgKTtcXG5cXHRcXHRcXHRcXHRjb2xvcnMucHVzaCggY29sb3IyLnIsIGNvbG9yMi5nLCBjb2xvcjIuYiApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xcblxcdFxcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApICk7XFxuXFxuXFx0XFx0dmFyIG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVmVydGV4Q29sb3JzLCBkZXB0aFRlc3Q6IGZhbHNlLCBkZXB0aFdyaXRlOiBmYWxzZSwgdHJhbnNwYXJlbnQ6IHRydWUgfSApO1xcblxcblxcdFxcdExpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcXG5cXG5cXHRcXHR0aGlzLnJvb3QgPSBvYmplY3Q7XFxuXFx0XFx0dGhpcy5ib25lcyA9IGJvbmVzO1xcblxcblxcdFxcdHRoaXMubWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xcblxcdFxcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xcblxcblxcdH1cXG5cXG5cXHRTa2VsZXRvbkhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaW5lU2VnbWVudHMucHJvdG90eXBlICk7XFxuXFx0U2tlbGV0b25IZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2tlbGV0b25IZWxwZXI7XFxuXFxuXFx0U2tlbGV0b25IZWxwZXIucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdHZhciBib25lTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcXG5cXHRcXHR2YXIgbWF0cml4V29ybGRJbnYgPSBuZXcgTWF0cml4NCgpO1xcblxcblxcdFxcdHJldHVybiBmdW5jdGlvbiB1cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGJvbmVzID0gdGhpcy5ib25lcztcXG5cXG5cXHRcXHRcXHR2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xcblxcdFxcdFxcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApO1xcblxcblxcdFxcdFxcdG1hdHJpeFdvcmxkSW52LmdldEludmVyc2UoIHRoaXMucm9vdC5tYXRyaXhXb3JsZCApO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaiA9IDA7IGkgPCBib25lcy5sZW5ndGg7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGJvbmUgPSBib25lc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdGlmICggYm9uZS5wYXJlbnQgJiYgYm9uZS5wYXJlbnQuaXNCb25lICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGJvbmVNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4V29ybGRJbnYsIGJvbmUubWF0cml4V29ybGQgKTtcXG5cXHRcXHRcXHRcXHRcXHR2ZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBib25lTWF0cml4ICk7XFxuXFx0XFx0XFx0XFx0XFx0cG9zaXRpb24uc2V0WFlaKCBqLCB2ZWN0b3IueCwgdmVjdG9yLnksIHZlY3Rvci56ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ym9uZU1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXhXb3JsZEludiwgYm9uZS5wYXJlbnQubWF0cml4V29ybGQgKTtcXG5cXHRcXHRcXHRcXHRcXHR2ZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBib25lTWF0cml4ICk7XFxuXFx0XFx0XFx0XFx0XFx0cG9zaXRpb24uc2V0WFlaKCBqICsgMSwgdmVjdG9yLngsIHZlY3Rvci55LCB2ZWN0b3IueiApO1xcblxcblxcdFxcdFxcdFxcdFxcdGogKz0gMjtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRPYmplY3QzRC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdH0oKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gUG9pbnRMaWdodEhlbHBlciggbGlnaHQsIHNwaGVyZVNpemUsIGNvbG9yICkge1xcblxcblxcdFxcdHRoaXMubGlnaHQgPSBsaWdodDtcXG5cXHRcXHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XFxuXFxuXFx0XFx0dGhpcy5jb2xvciA9IGNvbG9yO1xcblxcblxcdFxcdHZhciBnZW9tZXRyeSA9IG5ldyBTcGhlcmVCdWZmZXJHZW9tZXRyeSggc3BoZXJlU2l6ZSwgNCwgMiApO1xcblxcdFxcdHZhciBtYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyB3aXJlZnJhbWU6IHRydWUsIGZvZzogZmFsc2UgfSApO1xcblxcblxcdFxcdE1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XFxuXFxuXFx0XFx0dGhpcy5tYXRyaXggPSB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkO1xcblxcdFxcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xcblxcblxcdFxcdHRoaXMudXBkYXRlKCk7XFxuXFxuXFxuXFx0XFx0LypcXG5cXHRcXHR2YXIgZGlzdGFuY2VHZW9tZXRyeSA9IG5ldyBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5KCAxLCAyICk7XFxuXFx0XFx0dmFyIGRpc3RhbmNlTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGhleENvbG9yLCBmb2c6IGZhbHNlLCB3aXJlZnJhbWU6IHRydWUsIG9wYWNpdHk6IDAuMSwgdHJhbnNwYXJlbnQ6IHRydWUgfSApO1xcblxcblxcdFxcdHRoaXMubGlnaHRTcGhlcmUgPSBuZXcgVEhSRUUuTWVzaCggYnVsYkdlb21ldHJ5LCBidWxiTWF0ZXJpYWwgKTtcXG5cXHRcXHR0aGlzLmxpZ2h0RGlzdGFuY2UgPSBuZXcgVEhSRUUuTWVzaCggZGlzdGFuY2VHZW9tZXRyeSwgZGlzdGFuY2VNYXRlcmlhbCApO1xcblxcblxcdFxcdHZhciBkID0gbGlnaHQuZGlzdGFuY2U7XFxuXFxuXFx0XFx0aWYgKCBkID09PSAwLjAgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSBmYWxzZTtcXG5cXG5cXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdHRoaXMubGlnaHREaXN0YW5jZS5zY2FsZS5zZXQoIGQsIGQsIGQgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5hZGQoIHRoaXMubGlnaHREaXN0YW5jZSApO1xcblxcdFxcdCovXFxuXFxuXFx0fVxcblxcblxcdFBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWVzaC5wcm90b3R5cGUgKTtcXG5cXHRQb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvaW50TGlnaHRIZWxwZXI7XFxuXFxuXFx0UG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHR0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcXG5cXHRcXHR0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcXG5cXG5cXHR9O1xcblxcblxcdFBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRpZiAoIHRoaXMuY29sb3IgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm1hdGVyaWFsLmNvbG9yLnNldCggdGhpcy5jb2xvciApO1xcblxcblxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8qXFxuXFx0XFx0dmFyIGQgPSB0aGlzLmxpZ2h0LmRpc3RhbmNlO1xcblxcblxcdFxcdGlmICggZCA9PT0gMC4wICkge1xcblxcblxcdFxcdFxcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gZmFsc2U7XFxuXFxuXFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IHRydWU7XFxuXFx0XFx0XFx0dGhpcy5saWdodERpc3RhbmNlLnNjYWxlLnNldCggZCwgZCwgZCApO1xcblxcblxcdFxcdH1cXG5cXHRcXHQqL1xcblxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBhYmVsbmF0aW9uIC8gaHR0cDovL2dpdGh1Yi5jb20vYWJlbG5hdGlvblxcblxcdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHA6Ly9naXRodWIuY29tL011Z2VuODdcXG5cXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBSZWN0QXJlYUxpZ2h0SGVscGVyKCBsaWdodCwgY29sb3IgKSB7XFxuXFxuXFx0XFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMubGlnaHQgPSBsaWdodDtcXG5cXHRcXHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XFxuXFxuXFx0XFx0dGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcXG5cXHRcXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcXG5cXG5cXHRcXHR0aGlzLmNvbG9yID0gY29sb3I7XFxuXFxuXFx0XFx0dmFyIG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGZvZzogZmFsc2UgfSApO1xcblxcblxcdFxcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xcblxcblxcdFxcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggNSAqIDMgKSwgMyApICk7XFxuXFxuXFx0XFx0dGhpcy5saW5lID0gbmV3IExpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xcblxcdFxcdHRoaXMuYWRkKCB0aGlzLmxpbmUgKTtcXG5cXG5cXG5cXHRcXHR0aGlzLnVwZGF0ZSgpO1xcblxcblxcdH1cXG5cXG5cXHRSZWN0QXJlYUxpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApO1xcblxcdFJlY3RBcmVhTGlnaHRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVjdEFyZWFMaWdodEhlbHBlcjtcXG5cXG5cXHRSZWN0QXJlYUxpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdHRoaXMuY2hpbGRyZW5bIDAgXS5nZW9tZXRyeS5kaXNwb3NlKCk7XFxuXFx0XFx0dGhpcy5jaGlsZHJlblsgMCBdLm1hdGVyaWFsLmRpc3Bvc2UoKTtcXG5cXG5cXHR9O1xcblxcblxcdFJlY3RBcmVhTGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHQvLyBjYWxjdWxhdGUgbmV3IGRpbWVuc2lvbnMgb2YgdGhlIGhlbHBlclxcblxcblxcdFxcdHZhciBoeCA9IHRoaXMubGlnaHQud2lkdGggKiAwLjU7XFxuXFx0XFx0dmFyIGh5ID0gdGhpcy5saWdodC5oZWlnaHQgKiAwLjU7XFxuXFxuXFx0XFx0dmFyIHBvc2l0aW9uID0gdGhpcy5saW5lLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XFxuXFx0XFx0dmFyIGFycmF5ID0gcG9zaXRpb24uYXJyYXk7XFxuXFxuXFx0XFx0Ly8gdXBkYXRlIHZlcnRpY2VzXFxuXFxuXFx0XFx0YXJyYXlbIDAgXSA9IGh4OyBhcnJheVsgMSBdID0gLSBoeTsgYXJyYXlbIDIgXSA9IDA7XFxuXFx0XFx0YXJyYXlbIDMgXSA9IGh4OyBhcnJheVsgNCBdID0gaHk7IGFycmF5WyA1IF0gPSAwO1xcblxcdFxcdGFycmF5WyA2IF0gPSAtIGh4OyBhcnJheVsgNyBdID0gaHk7IGFycmF5WyA4IF0gPSAwO1xcblxcdFxcdGFycmF5WyA5IF0gPSAtIGh4OyBhcnJheVsgMTAgXSA9IC0gaHk7IGFycmF5WyAxMSBdID0gMDtcXG5cXHRcXHRhcnJheVsgMTIgXSA9IGh4OyBhcnJheVsgMTMgXSA9IC0gaHk7IGFycmF5WyAxNCBdID0gMDtcXG5cXG5cXHRcXHRwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XFxuXFxuXFx0XFx0aWYgKCB0aGlzLmNvbG9yICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5saW5lLm1hdGVyaWFsLmNvbG9yLnNldCggdGhpcy5jb2xvciApO1xcblxcblxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5saW5lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBIZW1pc3BoZXJlTGlnaHRIZWxwZXIoIGxpZ2h0LCBzaXplLCBjb2xvciApIHtcXG5cXG5cXHRcXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy5saWdodCA9IGxpZ2h0O1xcblxcdFxcdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcXG5cXG5cXHRcXHR0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xcblxcdFxcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xcblxcblxcdFxcdHRoaXMuY29sb3IgPSBjb2xvcjtcXG5cXG5cXHRcXHR2YXIgZ2VvbWV0cnkgPSBuZXcgT2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5KCBzaXplICk7XFxuXFx0XFx0Z2VvbWV0cnkucm90YXRlWSggTWF0aC5QSSAqIDAuNSApO1xcblxcblxcdFxcdHRoaXMubWF0ZXJpYWwgPSBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoIHsgd2lyZWZyYW1lOiB0cnVlLCBmb2c6IGZhbHNlIH0gKTtcXG5cXHRcXHRpZiAoIHRoaXMuY29sb3IgPT09IHVuZGVmaW5lZCApIHRoaXMubWF0ZXJpYWwudmVydGV4Q29sb3JzID0gVmVydGV4Q29sb3JzO1xcblxcblxcdFxcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApO1xcblxcdFxcdHZhciBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KCBwb3NpdGlvbi5jb3VudCAqIDMgKTtcXG5cXG5cXHRcXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApICk7XFxuXFxuXFx0XFx0dGhpcy5hZGQoIG5ldyBNZXNoKCBnZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApICk7XFxuXFxuXFx0XFx0dGhpcy51cGRhdGUoKTtcXG5cXG5cXHR9XFxuXFxuXFx0SGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApO1xcblxcdEhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIZW1pc3BoZXJlTGlnaHRIZWxwZXI7XFxuXFxuXFx0SGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdHRoaXMuY2hpbGRyZW5bIDAgXS5nZW9tZXRyeS5kaXNwb3NlKCk7XFxuXFx0XFx0dGhpcy5jaGlsZHJlblsgMCBdLm1hdGVyaWFsLmRpc3Bvc2UoKTtcXG5cXG5cXHR9O1xcblxcblxcdEhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdHZhciBjb2xvcjEgPSBuZXcgQ29sb3IoKTtcXG5cXHRcXHR2YXIgY29sb3IyID0gbmV3IENvbG9yKCk7XFxuXFxuXFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgbWVzaCA9IHRoaXMuY2hpbGRyZW5bIDAgXTtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuY29sb3IgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLm1hdGVyaWFsLmNvbG9yLnNldCggdGhpcy5jb2xvciApO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGNvbG9ycyA9IG1lc2guZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAnY29sb3InICk7XFxuXFxuXFx0XFx0XFx0XFx0Y29sb3IxLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKTtcXG5cXHRcXHRcXHRcXHRjb2xvcjIuY29weSggdGhpcy5saWdodC5ncm91bmRDb2xvciApO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGNvbG9ycy5jb3VudDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGNvbG9yID0gKCBpIDwgKCBsIC8gMiApICkgPyBjb2xvcjEgOiBjb2xvcjI7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y29sb3JzLnNldFhZWiggaSwgY29sb3IuciwgY29sb3IuZywgY29sb3IuYiApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRjb2xvcnMubmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRtZXNoLmxvb2tBdCggdmVjdG9yLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC5tYXRyaXhXb3JsZCApLm5lZ2F0ZSgpICk7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHR9KCk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBHcmlkSGVscGVyKCBzaXplLCBkaXZpc2lvbnMsIGNvbG9yMSwgY29sb3IyICkge1xcblxcblxcdFxcdHNpemUgPSBzaXplIHx8IDEwO1xcblxcdFxcdGRpdmlzaW9ucyA9IGRpdmlzaW9ucyB8fCAxMDtcXG5cXHRcXHRjb2xvcjEgPSBuZXcgQ29sb3IoIGNvbG9yMSAhPT0gdW5kZWZpbmVkID8gY29sb3IxIDogMHg0NDQ0NDQgKTtcXG5cXHRcXHRjb2xvcjIgPSBuZXcgQ29sb3IoIGNvbG9yMiAhPT0gdW5kZWZpbmVkID8gY29sb3IyIDogMHg4ODg4ODggKTtcXG5cXG5cXHRcXHR2YXIgY2VudGVyID0gZGl2aXNpb25zIC8gMjtcXG5cXHRcXHR2YXIgc3RlcCA9IHNpemUgLyBkaXZpc2lvbnM7XFxuXFx0XFx0dmFyIGhhbGZTaXplID0gc2l6ZSAvIDI7XFxuXFxuXFx0XFx0dmFyIHZlcnRpY2VzID0gW10sIGNvbG9ycyA9IFtdO1xcblxcblxcdFxcdGZvciAoIHZhciBpID0gMCwgaiA9IDAsIGsgPSAtIGhhbGZTaXplOyBpIDw9IGRpdmlzaW9uczsgaSArKywgayArPSBzdGVwICkge1xcblxcblxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIC0gaGFsZlNpemUsIDAsIGssIGhhbGZTaXplLCAwLCBrICk7XFxuXFx0XFx0XFx0dmVydGljZXMucHVzaCggaywgMCwgLSBoYWxmU2l6ZSwgaywgMCwgaGFsZlNpemUgKTtcXG5cXG5cXHRcXHRcXHR2YXIgY29sb3IgPSBpID09PSBjZW50ZXIgPyBjb2xvcjEgOiBjb2xvcjI7XFxuXFxuXFx0XFx0XFx0Y29sb3IudG9BcnJheSggY29sb3JzLCBqICk7IGogKz0gMztcXG5cXHRcXHRcXHRjb2xvci50b0FycmF5KCBjb2xvcnMsIGogKTsgaiArPSAzO1xcblxcdFxcdFxcdGNvbG9yLnRvQXJyYXkoIGNvbG9ycywgaiApOyBqICs9IDM7XFxuXFx0XFx0XFx0Y29sb3IudG9BcnJheSggY29sb3JzLCBqICk7IGogKz0gMztcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XFxuXFx0XFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xcblxcdFxcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApICk7XFxuXFxuXFx0XFx0dmFyIG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVmVydGV4Q29sb3JzIH0gKTtcXG5cXG5cXHRcXHRMaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XFxuXFxuXFx0fVxcblxcblxcdEdyaWRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xcblxcdEdyaWRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR3JpZEhlbHBlcjtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHA6Ly9naXRodWIuY29tL011Z2VuODdcXG5cXHQgKiBAYXV0aG9yIEhlY3RhdGUgLyBodHRwOi8vd3d3LmdpdGh1Yi5jb20vSGVjdGF0ZVxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFBvbGFyR3JpZEhlbHBlciggcmFkaXVzLCByYWRpYWxzLCBjaXJjbGVzLCBkaXZpc2lvbnMsIGNvbG9yMSwgY29sb3IyICkge1xcblxcblxcdFxcdHJhZGl1cyA9IHJhZGl1cyB8fCAxMDtcXG5cXHRcXHRyYWRpYWxzID0gcmFkaWFscyB8fCAxNjtcXG5cXHRcXHRjaXJjbGVzID0gY2lyY2xlcyB8fCA4O1xcblxcdFxcdGRpdmlzaW9ucyA9IGRpdmlzaW9ucyB8fCA2NDtcXG5cXHRcXHRjb2xvcjEgPSBuZXcgQ29sb3IoIGNvbG9yMSAhPT0gdW5kZWZpbmVkID8gY29sb3IxIDogMHg0NDQ0NDQgKTtcXG5cXHRcXHRjb2xvcjIgPSBuZXcgQ29sb3IoIGNvbG9yMiAhPT0gdW5kZWZpbmVkID8gY29sb3IyIDogMHg4ODg4ODggKTtcXG5cXG5cXHRcXHR2YXIgdmVydGljZXMgPSBbXTtcXG5cXHRcXHR2YXIgY29sb3JzID0gW107XFxuXFxuXFx0XFx0dmFyIHgsIHo7XFxuXFx0XFx0dmFyIHYsIGksIGosIHIsIGNvbG9yO1xcblxcblxcdFxcdC8vIGNyZWF0ZSB0aGUgcmFkaWFsc1xcblxcblxcdFxcdGZvciAoIGkgPSAwOyBpIDw9IHJhZGlhbHM7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0diA9ICggaSAvIHJhZGlhbHMgKSAqICggTWF0aC5QSSAqIDIgKTtcXG5cXG5cXHRcXHRcXHR4ID0gTWF0aC5zaW4oIHYgKSAqIHJhZGl1cztcXG5cXHRcXHRcXHR6ID0gTWF0aC5jb3MoIHYgKSAqIHJhZGl1cztcXG5cXG5cXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCAwLCAwLCAwICk7XFxuXFx0XFx0XFx0dmVydGljZXMucHVzaCggeCwgMCwgeiApO1xcblxcblxcdFxcdFxcdGNvbG9yID0gKCBpICYgMSApID8gY29sb3IxIDogY29sb3IyO1xcblxcblxcdFxcdFxcdGNvbG9ycy5wdXNoKCBjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iICk7XFxuXFx0XFx0XFx0Y29sb3JzLnB1c2goIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gY3JlYXRlIHRoZSBjaXJjbGVzXFxuXFxuXFx0XFx0Zm9yICggaSA9IDA7IGkgPD0gY2lyY2xlczsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRjb2xvciA9ICggaSAmIDEgKSA/IGNvbG9yMSA6IGNvbG9yMjtcXG5cXG5cXHRcXHRcXHRyID0gcmFkaXVzIC0gKCByYWRpdXMgLyBjaXJjbGVzICogaSApO1xcblxcblxcdFxcdFxcdGZvciAoIGogPSAwOyBqIDwgZGl2aXNpb25zOyBqICsrICkge1xcblxcblxcdFxcdFxcdFxcdC8vIGZpcnN0IHZlcnRleFxcblxcblxcdFxcdFxcdFxcdHYgPSAoIGogLyBkaXZpc2lvbnMgKSAqICggTWF0aC5QSSAqIDIgKTtcXG5cXG5cXHRcXHRcXHRcXHR4ID0gTWF0aC5zaW4oIHYgKSAqIHI7XFxuXFx0XFx0XFx0XFx0eiA9IE1hdGguY29zKCB2ICkgKiByO1xcblxcblxcdFxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIHgsIDAsIHogKTtcXG5cXHRcXHRcXHRcXHRjb2xvcnMucHVzaCggY29sb3IuciwgY29sb3IuZywgY29sb3IuYiApO1xcblxcblxcdFxcdFxcdFxcdC8vIHNlY29uZCB2ZXJ0ZXhcXG5cXG5cXHRcXHRcXHRcXHR2ID0gKCAoIGogKyAxICkgLyBkaXZpc2lvbnMgKSAqICggTWF0aC5QSSAqIDIgKTtcXG5cXG5cXHRcXHRcXHRcXHR4ID0gTWF0aC5zaW4oIHYgKSAqIHI7XFxuXFx0XFx0XFx0XFx0eiA9IE1hdGguY29zKCB2ICkgKiByO1xcblxcblxcdFxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIHgsIDAsIHogKTtcXG5cXHRcXHRcXHRcXHRjb2xvcnMucHVzaCggY29sb3IuciwgY29sb3IuZywgY29sb3IuYiApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XFxuXFx0XFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xcblxcdFxcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApICk7XFxuXFxuXFx0XFx0dmFyIG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IHZlcnRleENvbG9yczogVmVydGV4Q29sb3JzIH0gKTtcXG5cXG5cXHRcXHRMaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XFxuXFxuXFx0fVxcblxcblxcdFBvbGFyR3JpZEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaW5lU2VnbWVudHMucHJvdG90eXBlICk7XFxuXFx0UG9sYXJHcmlkSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvbGFyR3JpZEhlbHBlcjtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEZhY2VOb3JtYWxzSGVscGVyKCBvYmplY3QsIHNpemUsIGhleCwgbGluZXdpZHRoICkge1xcblxcblxcdFxcdC8vIEZhY2VOb3JtYWxzSGVscGVyIG9ubHkgc3VwcG9ydHMgVEhSRUUuR2VvbWV0cnlcXG5cXG5cXHRcXHR0aGlzLm9iamVjdCA9IG9iamVjdDtcXG5cXG5cXHRcXHR0aGlzLnNpemUgPSAoIHNpemUgIT09IHVuZGVmaW5lZCApID8gc2l6ZSA6IDE7XFxuXFxuXFx0XFx0dmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZmZmMDA7XFxuXFxuXFx0XFx0dmFyIHdpZHRoID0gKCBsaW5ld2lkdGggIT09IHVuZGVmaW5lZCApID8gbGluZXdpZHRoIDogMTtcXG5cXG5cXHRcXHQvL1xcblxcblxcdFxcdHZhciBuTm9ybWFscyA9IDA7XFxuXFxuXFx0XFx0dmFyIG9iakdlb21ldHJ5ID0gdGhpcy5vYmplY3QuZ2VvbWV0cnk7XFxuXFxuXFx0XFx0aWYgKCBvYmpHZW9tZXRyeSAmJiBvYmpHZW9tZXRyeS5pc0dlb21ldHJ5ICkge1xcblxcblxcdFxcdFxcdG5Ob3JtYWxzID0gb2JqR2VvbWV0cnkuZmFjZXMubGVuZ3RoO1xcblxcblxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRmFjZU5vcm1hbHNIZWxwZXI6IG9ubHkgVEhSRUUuR2VvbWV0cnkgaXMgc3VwcG9ydGVkLiBVc2UgVEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlciwgaW5zdGVhZC4nICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vXFxuXFxuXFx0XFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XFxuXFxuXFx0XFx0dmFyIHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBuTm9ybWFscyAqIDIgKiAzLCAzICk7XFxuXFxuXFx0XFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBwb3NpdGlvbnMgKTtcXG5cXG5cXHRcXHRMaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIGxpbmV3aWR0aDogd2lkdGggfSApICk7XFxuXFxuXFx0XFx0Ly9cXG5cXG5cXHRcXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLnVwZGF0ZSgpO1xcblxcblxcdH1cXG5cXG5cXHRGYWNlTm9ybWFsc0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaW5lU2VnbWVudHMucHJvdG90eXBlICk7XFxuXFx0RmFjZU5vcm1hbHNIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRmFjZU5vcm1hbHNIZWxwZXI7XFxuXFxuXFx0RmFjZU5vcm1hbHNIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0dmFyIHYyID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHR2YXIgbm9ybWFsTWF0cml4ID0gbmV3IE1hdHJpeDMoKTtcXG5cXG5cXHRcXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xcblxcblxcdFxcdFxcdHRoaXMub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XFxuXFxuXFx0XFx0XFx0bm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggdGhpcy5vYmplY3QubWF0cml4V29ybGQgKTtcXG5cXG5cXHRcXHRcXHR2YXIgbWF0cml4V29ybGQgPSB0aGlzLm9iamVjdC5tYXRyaXhXb3JsZDtcXG5cXG5cXHRcXHRcXHR2YXIgcG9zaXRpb24gPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XFxuXFxuXFx0XFx0XFx0Ly9cXG5cXG5cXHRcXHRcXHR2YXIgb2JqR2VvbWV0cnkgPSB0aGlzLm9iamVjdC5nZW9tZXRyeTtcXG5cXG5cXHRcXHRcXHR2YXIgdmVydGljZXMgPSBvYmpHZW9tZXRyeS52ZXJ0aWNlcztcXG5cXG5cXHRcXHRcXHR2YXIgZmFjZXMgPSBvYmpHZW9tZXRyeS5mYWNlcztcXG5cXG5cXHRcXHRcXHR2YXIgaWR4ID0gMDtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbm9ybWFsID0gZmFjZS5ub3JtYWw7XFxuXFxuXFx0XFx0XFx0XFx0djEuY29weSggdmVydGljZXNbIGZhY2UuYSBdIClcXG5cXHRcXHRcXHRcXHRcXHQuYWRkKCB2ZXJ0aWNlc1sgZmFjZS5iIF0gKVxcblxcdFxcdFxcdFxcdFxcdC5hZGQoIHZlcnRpY2VzWyBmYWNlLmMgXSApXFxuXFx0XFx0XFx0XFx0XFx0LmRpdmlkZVNjYWxhciggMyApXFxuXFx0XFx0XFx0XFx0XFx0LmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcXG5cXG5cXHRcXHRcXHRcXHR2Mi5jb3B5KCBub3JtYWwgKS5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCB0aGlzLnNpemUgKS5hZGQoIHYxICk7XFxuXFxuXFx0XFx0XFx0XFx0cG9zaXRpb24uc2V0WFlaKCBpZHgsIHYxLngsIHYxLnksIHYxLnogKTtcXG5cXG5cXHRcXHRcXHRcXHRpZHggPSBpZHggKyAxO1xcblxcblxcdFxcdFxcdFxcdHBvc2l0aW9uLnNldFhZWiggaWR4LCB2Mi54LCB2Mi55LCB2Mi56ICk7XFxuXFxuXFx0XFx0XFx0XFx0aWR4ID0gaWR4ICsgMTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdH07XFxuXFxuXFx0fSgpICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIERpcmVjdGlvbmFsTGlnaHRIZWxwZXIoIGxpZ2h0LCBzaXplLCBjb2xvciApIHtcXG5cXG5cXHRcXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy5saWdodCA9IGxpZ2h0O1xcblxcdFxcdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcXG5cXG5cXHRcXHR0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xcblxcdFxcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xcblxcblxcdFxcdHRoaXMuY29sb3IgPSBjb2xvcjtcXG5cXG5cXHRcXHRpZiAoIHNpemUgPT09IHVuZGVmaW5lZCApIHNpemUgPSAxO1xcblxcblxcdFxcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xcblxcdFxcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIFtcXG5cXHRcXHRcXHQtIHNpemUsIHNpemUsIDAsXFxuXFx0XFx0XFx0c2l6ZSwgc2l6ZSwgMCxcXG5cXHRcXHRcXHRzaXplLCAtIHNpemUsIDAsXFxuXFx0XFx0XFx0LSBzaXplLCAtIHNpemUsIDAsXFxuXFx0XFx0XFx0LSBzaXplLCBzaXplLCAwXFxuXFx0XFx0XSwgMyApICk7XFxuXFxuXFx0XFx0dmFyIG1hdGVyaWFsID0gbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGZvZzogZmFsc2UgfSApO1xcblxcblxcdFxcdHRoaXMubGlnaHRQbGFuZSA9IG5ldyBMaW5lKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcXG5cXHRcXHR0aGlzLmFkZCggdGhpcy5saWdodFBsYW5lICk7XFxuXFxuXFx0XFx0Z2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcXG5cXHRcXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBbIDAsIDAsIDAsIDAsIDAsIDEgXSwgMyApICk7XFxuXFxuXFx0XFx0dGhpcy50YXJnZXRMaW5lID0gbmV3IExpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xcblxcdFxcdHRoaXMuYWRkKCB0aGlzLnRhcmdldExpbmUgKTtcXG5cXG5cXHRcXHR0aGlzLnVwZGF0ZSgpO1xcblxcblxcdH1cXG5cXG5cXHREaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApO1xcblxcdERpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGlyZWN0aW9uYWxMaWdodEhlbHBlcjtcXG5cXG5cXHREaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdHRoaXMubGlnaHRQbGFuZS5nZW9tZXRyeS5kaXNwb3NlKCk7XFxuXFx0XFx0dGhpcy5saWdodFBsYW5lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcXG5cXHRcXHR0aGlzLnRhcmdldExpbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xcblxcdFxcdHRoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5kaXNwb3NlKCk7XFxuXFxuXFx0fTtcXG5cXG5cXHREaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHR2YXIgdjIgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdHZhciB2MyA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcXG5cXG5cXHRcXHRcXHR2MS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQubWF0cml4V29ybGQgKTtcXG5cXHRcXHRcXHR2Mi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XFxuXFx0XFx0XFx0djMuc3ViVmVjdG9ycyggdjIsIHYxICk7XFxuXFxuXFx0XFx0XFx0dGhpcy5saWdodFBsYW5lLmxvb2tBdCggdjMgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuY29sb3IgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuY29sb3Iuc2V0KCB0aGlzLmNvbG9yICk7XFxuXFx0XFx0XFx0XFx0dGhpcy50YXJnZXRMaW5lLm1hdGVyaWFsLmNvbG9yLnNldCggdGhpcy5jb2xvciApO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5saWdodFBsYW5lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLnRhcmdldExpbmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLnRhcmdldExpbmUubG9va0F0KCB2MyApO1xcblxcdFxcdFxcdHRoaXMudGFyZ2V0TGluZS5zY2FsZS56ID0gdjMubGVuZ3RoKCk7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHR9KCk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xcblxcdCAqXFxuXFx0ICpcXHQtIHNob3dzIGZydXN0dW0sIGxpbmUgb2Ygc2lnaHQgYW5kIHVwIG9mIHRoZSBjYW1lcmFcXG5cXHQgKlxcdC0gc3VpdGFibGUgZm9yIGZhc3QgdXBkYXRlc1xcblxcdCAqIFxcdC0gYmFzZWQgb24gZnJ1c3R1bSB2aXN1YWxpemF0aW9uIGluIGxpZ2h0Z2wuanMgc2hhZG93bWFwIGV4YW1wbGVcXG5cXHQgKlxcdFxcdGh0dHA6Ly9ldmFudy5naXRodWIuY29tL2xpZ2h0Z2wuanMvdGVzdHMvc2hhZG93bWFwLmh0bWxcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBDYW1lcmFIZWxwZXIoIGNhbWVyYSApIHtcXG5cXG5cXHRcXHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcXG5cXHRcXHR2YXIgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4ZmZmZmZmLCB2ZXJ0ZXhDb2xvcnM6IEZhY2VDb2xvcnMgfSApO1xcblxcblxcdFxcdHZhciB2ZXJ0aWNlcyA9IFtdO1xcblxcdFxcdHZhciBjb2xvcnMgPSBbXTtcXG5cXG5cXHRcXHR2YXIgcG9pbnRNYXAgPSB7fTtcXG5cXG5cXHRcXHQvLyBjb2xvcnNcXG5cXG5cXHRcXHR2YXIgY29sb3JGcnVzdHVtID0gbmV3IENvbG9yKCAweGZmYWEwMCApO1xcblxcdFxcdHZhciBjb2xvckNvbmUgPSBuZXcgQ29sb3IoIDB4ZmYwMDAwICk7XFxuXFx0XFx0dmFyIGNvbG9yVXAgPSBuZXcgQ29sb3IoIDB4MDBhYWZmICk7XFxuXFx0XFx0dmFyIGNvbG9yVGFyZ2V0ID0gbmV3IENvbG9yKCAweGZmZmZmZiApO1xcblxcdFxcdHZhciBjb2xvckNyb3NzID0gbmV3IENvbG9yKCAweDMzMzMzMyApO1xcblxcblxcdFxcdC8vIG5lYXJcXG5cXG5cXHRcXHRhZGRMaW5lKCAnbjEnLCAnbjInLCBjb2xvckZydXN0dW0gKTtcXG5cXHRcXHRhZGRMaW5lKCAnbjInLCAnbjQnLCBjb2xvckZydXN0dW0gKTtcXG5cXHRcXHRhZGRMaW5lKCAnbjQnLCAnbjMnLCBjb2xvckZydXN0dW0gKTtcXG5cXHRcXHRhZGRMaW5lKCAnbjMnLCAnbjEnLCBjb2xvckZydXN0dW0gKTtcXG5cXG5cXHRcXHQvLyBmYXJcXG5cXG5cXHRcXHRhZGRMaW5lKCAnZjEnLCAnZjInLCBjb2xvckZydXN0dW0gKTtcXG5cXHRcXHRhZGRMaW5lKCAnZjInLCAnZjQnLCBjb2xvckZydXN0dW0gKTtcXG5cXHRcXHRhZGRMaW5lKCAnZjQnLCAnZjMnLCBjb2xvckZydXN0dW0gKTtcXG5cXHRcXHRhZGRMaW5lKCAnZjMnLCAnZjEnLCBjb2xvckZydXN0dW0gKTtcXG5cXG5cXHRcXHQvLyBzaWRlc1xcblxcblxcdFxcdGFkZExpbmUoICduMScsICdmMScsIGNvbG9yRnJ1c3R1bSApO1xcblxcdFxcdGFkZExpbmUoICduMicsICdmMicsIGNvbG9yRnJ1c3R1bSApO1xcblxcdFxcdGFkZExpbmUoICduMycsICdmMycsIGNvbG9yRnJ1c3R1bSApO1xcblxcdFxcdGFkZExpbmUoICduNCcsICdmNCcsIGNvbG9yRnJ1c3R1bSApO1xcblxcblxcdFxcdC8vIGNvbmVcXG5cXG5cXHRcXHRhZGRMaW5lKCAncCcsICduMScsIGNvbG9yQ29uZSApO1xcblxcdFxcdGFkZExpbmUoICdwJywgJ24yJywgY29sb3JDb25lICk7XFxuXFx0XFx0YWRkTGluZSggJ3AnLCAnbjMnLCBjb2xvckNvbmUgKTtcXG5cXHRcXHRhZGRMaW5lKCAncCcsICduNCcsIGNvbG9yQ29uZSApO1xcblxcblxcdFxcdC8vIHVwXFxuXFxuXFx0XFx0YWRkTGluZSggJ3UxJywgJ3UyJywgY29sb3JVcCApO1xcblxcdFxcdGFkZExpbmUoICd1MicsICd1MycsIGNvbG9yVXAgKTtcXG5cXHRcXHRhZGRMaW5lKCAndTMnLCAndTEnLCBjb2xvclVwICk7XFxuXFxuXFx0XFx0Ly8gdGFyZ2V0XFxuXFxuXFx0XFx0YWRkTGluZSggJ2MnLCAndCcsIGNvbG9yVGFyZ2V0ICk7XFxuXFx0XFx0YWRkTGluZSggJ3AnLCAnYycsIGNvbG9yQ3Jvc3MgKTtcXG5cXG5cXHRcXHQvLyBjcm9zc1xcblxcblxcdFxcdGFkZExpbmUoICdjbjEnLCAnY24yJywgY29sb3JDcm9zcyApO1xcblxcdFxcdGFkZExpbmUoICdjbjMnLCAnY240JywgY29sb3JDcm9zcyApO1xcblxcblxcdFxcdGFkZExpbmUoICdjZjEnLCAnY2YyJywgY29sb3JDcm9zcyApO1xcblxcdFxcdGFkZExpbmUoICdjZjMnLCAnY2Y0JywgY29sb3JDcm9zcyApO1xcblxcblxcdFxcdGZ1bmN0aW9uIGFkZExpbmUoIGEsIGIsIGNvbG9yICkge1xcblxcblxcdFxcdFxcdGFkZFBvaW50KCBhLCBjb2xvciApO1xcblxcdFxcdFxcdGFkZFBvaW50KCBiLCBjb2xvciApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBhZGRQb2ludCggaWQsIGNvbG9yICkge1xcblxcblxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIDAsIDAsIDAgKTtcXG5cXHRcXHRcXHRjb2xvcnMucHVzaCggY29sb3IuciwgY29sb3IuZywgY29sb3IuYiApO1xcblxcblxcdFxcdFxcdGlmICggcG9pbnRNYXBbIGlkIF0gPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRwb2ludE1hcFsgaWQgXSA9IFtdO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRwb2ludE1hcFsgaWQgXS5wdXNoKCAoIHZlcnRpY2VzLmxlbmd0aCAvIDMgKSAtIDEgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xcblxcdFxcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGNvbG9ycywgMyApICk7XFxuXFxuXFx0XFx0TGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xcblxcblxcdFxcdHRoaXMuY2FtZXJhID0gY2FtZXJhO1xcblxcdFxcdGlmICggdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCApIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcXG5cXG5cXHRcXHR0aGlzLm1hdHJpeCA9IGNhbWVyYS5tYXRyaXhXb3JsZDtcXG5cXHRcXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcXG5cXG5cXHRcXHR0aGlzLnBvaW50TWFwID0gcG9pbnRNYXA7XFxuXFxuXFx0XFx0dGhpcy51cGRhdGUoKTtcXG5cXG5cXHR9XFxuXFxuXFx0Q2FtZXJhSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcXG5cXHRDYW1lcmFIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2FtZXJhSGVscGVyO1xcblxcblxcdENhbWVyYUhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdHZhciBnZW9tZXRyeSwgcG9pbnRNYXA7XFxuXFxuXFx0XFx0dmFyIHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0dmFyIGNhbWVyYSA9IG5ldyBDYW1lcmEoKTtcXG5cXG5cXHRcXHRmdW5jdGlvbiBzZXRQb2ludCggcG9pbnQsIHgsIHksIHogKSB7XFxuXFxuXFx0XFx0XFx0dmVjdG9yLnNldCggeCwgeSwgeiApLnVucHJvamVjdCggY2FtZXJhICk7XFxuXFxuXFx0XFx0XFx0dmFyIHBvaW50cyA9IHBvaW50TWFwWyBwb2ludCBdO1xcblxcblxcdFxcdFxcdGlmICggcG9pbnRzICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHBvc2l0aW9uID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICk7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cG9zaXRpb24uc2V0WFlaKCBwb2ludHNbIGkgXSwgdmVjdG9yLngsIHZlY3Rvci55LCB2ZWN0b3IueiApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XFxuXFxuXFx0XFx0XFx0Z2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xcblxcdFxcdFxcdHBvaW50TWFwID0gdGhpcy5wb2ludE1hcDtcXG5cXG5cXHRcXHRcXHR2YXIgdyA9IDEsIGggPSAxO1xcblxcblxcdFxcdFxcdC8vIHdlIG5lZWQganVzdCBjYW1lcmEgcHJvamVjdGlvbiBtYXRyaXhcXG5cXHRcXHRcXHQvLyB3b3JsZCBtYXRyaXggbXVzdCBiZSBpZGVudGl0eVxcblxcblxcdFxcdFxcdGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIHRoaXMuY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcXG5cXG5cXHRcXHRcXHQvLyBjZW50ZXIgLyB0YXJnZXRcXG5cXG5cXHRcXHRcXHRzZXRQb2ludCggJ2MnLCAwLCAwLCAtIDEgKTtcXG5cXHRcXHRcXHRzZXRQb2ludCggJ3QnLCAwLCAwLCAxICk7XFxuXFxuXFx0XFx0XFx0Ly8gbmVhclxcblxcblxcdFxcdFxcdHNldFBvaW50KCAnbjEnLCAtIHcsIC0gaCwgLSAxICk7XFxuXFx0XFx0XFx0c2V0UG9pbnQoICduMicsIHcsIC0gaCwgLSAxICk7XFxuXFx0XFx0XFx0c2V0UG9pbnQoICduMycsIC0gdywgaCwgLSAxICk7XFxuXFx0XFx0XFx0c2V0UG9pbnQoICduNCcsIHcsIGgsIC0gMSApO1xcblxcblxcdFxcdFxcdC8vIGZhclxcblxcblxcdFxcdFxcdHNldFBvaW50KCAnZjEnLCAtIHcsIC0gaCwgMSApO1xcblxcdFxcdFxcdHNldFBvaW50KCAnZjInLCB3LCAtIGgsIDEgKTtcXG5cXHRcXHRcXHRzZXRQb2ludCggJ2YzJywgLSB3LCBoLCAxICk7XFxuXFx0XFx0XFx0c2V0UG9pbnQoICdmNCcsIHcsIGgsIDEgKTtcXG5cXG5cXHRcXHRcXHQvLyB1cFxcblxcblxcdFxcdFxcdHNldFBvaW50KCAndTEnLCB3ICogMC43LCBoICogMS4xLCAtIDEgKTtcXG5cXHRcXHRcXHRzZXRQb2ludCggJ3UyJywgLSB3ICogMC43LCBoICogMS4xLCAtIDEgKTtcXG5cXHRcXHRcXHRzZXRQb2ludCggJ3UzJywgMCwgaCAqIDIsIC0gMSApO1xcblxcblxcdFxcdFxcdC8vIGNyb3NzXFxuXFxuXFx0XFx0XFx0c2V0UG9pbnQoICdjZjEnLCAtIHcsIDAsIDEgKTtcXG5cXHRcXHRcXHRzZXRQb2ludCggJ2NmMicsIHcsIDAsIDEgKTtcXG5cXHRcXHRcXHRzZXRQb2ludCggJ2NmMycsIDAsIC0gaCwgMSApO1xcblxcdFxcdFxcdHNldFBvaW50KCAnY2Y0JywgMCwgaCwgMSApO1xcblxcblxcdFxcdFxcdHNldFBvaW50KCAnY24xJywgLSB3LCAwLCAtIDEgKTtcXG5cXHRcXHRcXHRzZXRQb2ludCggJ2NuMicsIHcsIDAsIC0gMSApO1xcblxcdFxcdFxcdHNldFBvaW50KCAnY24zJywgMCwgLSBoLCAtIDEgKTtcXG5cXHRcXHRcXHRzZXRQb2ludCggJ2NuNCcsIDAsIGgsIC0gMSApO1xcblxcblxcdFxcdFxcdGdlb21ldHJ5LmdldEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJyApLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdH0oKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHA6Ly9naXRodWIuY29tL011Z2VuODdcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBCb3hIZWxwZXIoIG9iamVjdCwgY29sb3IgKSB7XFxuXFxuXFx0XFx0dGhpcy5vYmplY3QgPSBvYmplY3Q7XFxuXFxuXFx0XFx0aWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkICkgY29sb3IgPSAweGZmZmYwMDtcXG5cXG5cXHRcXHR2YXIgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSggWyAwLCAxLCAxLCAyLCAyLCAzLCAzLCAwLCA0LCA1LCA1LCA2LCA2LCA3LCA3LCA0LCAwLCA0LCAxLCA1LCAyLCA2LCAzLCA3IF0gKTtcXG5cXHRcXHR2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSggOCAqIDMgKTtcXG5cXG5cXHRcXHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcXG5cXHRcXHRnZW9tZXRyeS5zZXRJbmRleCggbmV3IEJ1ZmZlckF0dHJpYnV0ZSggaW5kaWNlcywgMSApICk7XFxuXFx0XFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKSApO1xcblxcblxcdFxcdExpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciB9ICkgKTtcXG5cXG5cXHRcXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcXG5cXG5cXHRcXHR0aGlzLnVwZGF0ZSgpO1xcblxcblxcdH1cXG5cXG5cXHRCb3hIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xcblxcdEJveEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCb3hIZWxwZXI7XFxuXFxuXFx0Qm94SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSAoIGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHR2YXIgYm94ID0gbmV3IEJveDMoKTtcXG5cXG5cXHRcXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCBvYmplY3QgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBvYmplY3QgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3hIZWxwZXI6IC51cGRhdGUoKSBoYXMgbm8gbG9uZ2VyIGFyZ3VtZW50cy4nICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggdGhpcy5vYmplY3QgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRib3guc2V0RnJvbU9iamVjdCggdGhpcy5vYmplY3QgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBib3guaXNFbXB0eSgpICkgcmV0dXJuO1xcblxcblxcdFxcdFxcdHZhciBtaW4gPSBib3gubWluO1xcblxcdFxcdFxcdHZhciBtYXggPSBib3gubWF4O1xcblxcblxcdFxcdFxcdC8qXFxuXFx0XFx0XFx0ICA1X19fXzRcXG5cXHRcXHRcXHQxL19fXzAvfFxcblxcdFxcdFxcdHwgNl9ffF83XFxuXFx0XFx0XFx0Mi9fX18zL1xcblxcblxcdFxcdFxcdDA6IG1heC54LCBtYXgueSwgbWF4LnpcXG5cXHRcXHRcXHQxOiBtaW4ueCwgbWF4LnksIG1heC56XFxuXFx0XFx0XFx0MjogbWluLngsIG1pbi55LCBtYXguelxcblxcdFxcdFxcdDM6IG1heC54LCBtaW4ueSwgbWF4LnpcXG5cXHRcXHRcXHQ0OiBtYXgueCwgbWF4LnksIG1pbi56XFxuXFx0XFx0XFx0NTogbWluLngsIG1heC55LCBtaW4uelxcblxcdFxcdFxcdDY6IG1pbi54LCBtaW4ueSwgbWluLnpcXG5cXHRcXHRcXHQ3OiBtYXgueCwgbWluLnksIG1pbi56XFxuXFx0XFx0XFx0Ki9cXG5cXG5cXHRcXHRcXHR2YXIgcG9zaXRpb24gPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XFxuXFx0XFx0XFx0dmFyIGFycmF5ID0gcG9zaXRpb24uYXJyYXk7XFxuXFxuXFx0XFx0XFx0YXJyYXlbIDAgXSA9IG1heC54OyBhcnJheVsgMSBdID0gbWF4Lnk7IGFycmF5WyAyIF0gPSBtYXguejtcXG5cXHRcXHRcXHRhcnJheVsgMyBdID0gbWluLng7IGFycmF5WyA0IF0gPSBtYXgueTsgYXJyYXlbIDUgXSA9IG1heC56O1xcblxcdFxcdFxcdGFycmF5WyA2IF0gPSBtaW4ueDsgYXJyYXlbIDcgXSA9IG1pbi55OyBhcnJheVsgOCBdID0gbWF4Lno7XFxuXFx0XFx0XFx0YXJyYXlbIDkgXSA9IG1heC54OyBhcnJheVsgMTAgXSA9IG1pbi55OyBhcnJheVsgMTEgXSA9IG1heC56O1xcblxcdFxcdFxcdGFycmF5WyAxMiBdID0gbWF4Lng7IGFycmF5WyAxMyBdID0gbWF4Lnk7IGFycmF5WyAxNCBdID0gbWluLno7XFxuXFx0XFx0XFx0YXJyYXlbIDE1IF0gPSBtaW4ueDsgYXJyYXlbIDE2IF0gPSBtYXgueTsgYXJyYXlbIDE3IF0gPSBtaW4uejtcXG5cXHRcXHRcXHRhcnJheVsgMTggXSA9IG1pbi54OyBhcnJheVsgMTkgXSA9IG1pbi55OyBhcnJheVsgMjAgXSA9IG1pbi56O1xcblxcdFxcdFxcdGFycmF5WyAyMSBdID0gbWF4Lng7IGFycmF5WyAyMiBdID0gbWluLnk7IGFycmF5WyAyMyBdID0gbWluLno7XFxuXFxuXFx0XFx0XFx0cG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdFxcdHRoaXMuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHR9ICkoKTtcXG5cXG5cXHRCb3hIZWxwZXIucHJvdG90eXBlLnNldEZyb21PYmplY3QgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcXG5cXG5cXHRcXHR0aGlzLm9iamVjdCA9IG9iamVjdDtcXG5cXHRcXHR0aGlzLnVwZGF0ZSgpO1xcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gQm94M0hlbHBlciggYm94LCBoZXggKSB7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ0JveDNIZWxwZXInO1xcblxcblxcdFxcdHRoaXMuYm94ID0gYm94O1xcblxcblxcdFxcdHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ZmZmZjAwO1xcblxcblxcdFxcdHZhciBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDAsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDQsIDAsIDQsIDEsIDUsIDIsIDYsIDMsIDcgXSApO1xcblxcblxcdFxcdHZhciBwb3NpdGlvbnMgPSBbIDEsIDEsIDEsIC0gMSwgMSwgMSwgLSAxLCAtIDEsIDEsIDEsIC0gMSwgMSwgMSwgMSwgLSAxLCAtIDEsIDEsIC0gMSwgLSAxLCAtIDEsIC0gMSwgMSwgLSAxLCAtIDEgXTtcXG5cXG5cXHRcXHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcXG5cXG5cXHRcXHRnZW9tZXRyeS5zZXRJbmRleCggbmV3IEJ1ZmZlckF0dHJpYnV0ZSggaW5kaWNlcywgMSApICk7XFxuXFxuXFx0XFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCAzICkgKTtcXG5cXG5cXHRcXHRMaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XFxuXFxuXFx0XFx0dGhpcy5nZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcXG5cXG5cXHR9XFxuXFxuXFx0Qm94M0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaW5lU2VnbWVudHMucHJvdG90eXBlICk7XFxuXFx0Qm94M0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCb3gzSGVscGVyO1xcblxcblxcdEJveDNIZWxwZXIucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gZnVuY3Rpb24gKCBmb3JjZSApIHtcXG5cXG5cXHRcXHR2YXIgYm94ID0gdGhpcy5ib3g7XFxuXFxuXFx0XFx0aWYgKCBib3guaXNFbXB0eSgpICkgcmV0dXJuO1xcblxcblxcdFxcdGJveC5nZXRDZW50ZXIoIHRoaXMucG9zaXRpb24gKTtcXG5cXG5cXHRcXHRib3guZ2V0U2l6ZSggdGhpcy5zY2FsZSApO1xcblxcblxcdFxcdHRoaXMuc2NhbGUubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xcblxcblxcdFxcdE9iamVjdDNELnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKCB0aGlzLCBmb3JjZSApO1xcblxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gUGxhbmVIZWxwZXIoIHBsYW5lLCBzaXplLCBoZXggKSB7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1BsYW5lSGVscGVyJztcXG5cXG5cXHRcXHR0aGlzLnBsYW5lID0gcGxhbmU7XFxuXFxuXFx0XFx0dGhpcy5zaXplID0gKCBzaXplID09PSB1bmRlZmluZWQgKSA/IDEgOiBzaXplO1xcblxcblxcdFxcdHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ZmZmZjAwO1xcblxcblxcdFxcdHZhciBwb3NpdGlvbnMgPSBbIDEsIC0gMSwgMSwgLSAxLCAxLCAxLCAtIDEsIC0gMSwgMSwgMSwgMSwgMSwgLSAxLCAxLCAxLCAtIDEsIC0gMSwgMSwgMSwgLSAxLCAxLCAxLCAxLCAxLCAwLCAwLCAxLCAwLCAwLCAwIF07XFxuXFxuXFx0XFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XFxuXFx0XFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCAzICkgKTtcXG5cXHRcXHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcXG5cXG5cXHRcXHRMaW5lLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xcblxcblxcdFxcdC8vXFxuXFxuXFx0XFx0dmFyIHBvc2l0aW9uczIgPSBbIDEsIDEsIDEsIC0gMSwgMSwgMSwgLSAxLCAtIDEsIDEsIDEsIDEsIDEsIC0gMSwgLSAxLCAxLCAxLCAtIDEsIDEgXTtcXG5cXG5cXHRcXHR2YXIgZ2VvbWV0cnkyID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XFxuXFx0XFx0Z2VvbWV0cnkyLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uczIsIDMgKSApO1xcblxcdFxcdGdlb21ldHJ5Mi5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcXG5cXG5cXHRcXHR0aGlzLmFkZCggbmV3IE1lc2goIGdlb21ldHJ5MiwgbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciwgb3BhY2l0eTogMC4yLCB0cmFuc3BhcmVudDogdHJ1ZSwgZGVwdGhXcml0ZTogZmFsc2UgfSApICkgKTtcXG5cXG5cXHR9XFxuXFxuXFx0UGxhbmVIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGluZS5wcm90b3R5cGUgKTtcXG5cXHRQbGFuZUhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQbGFuZUhlbHBlcjtcXG5cXG5cXHRQbGFuZUhlbHBlci5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQgPSBmdW5jdGlvbiAoIGZvcmNlICkge1xcblxcblxcdFxcdHZhciBzY2FsZSA9IC0gdGhpcy5wbGFuZS5jb25zdGFudDtcXG5cXG5cXHRcXHRpZiAoIE1hdGguYWJzKCBzY2FsZSApIDwgMWUtOCApIHNjYWxlID0gMWUtODsgLy8gc2lnbiBkb2VzIG5vdCBtYXR0ZXJcXG5cXG5cXHRcXHR0aGlzLnNjYWxlLnNldCggMC41ICogdGhpcy5zaXplLCAwLjUgKiB0aGlzLnNpemUsIHNjYWxlICk7XFxuXFxuXFx0XFx0dGhpcy5sb29rQXQoIHRoaXMucGxhbmUubm9ybWFsICk7XFxuXFxuXFx0XFx0T2JqZWN0M0QucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkLmNhbGwoIHRoaXMsIGZvcmNlICk7XFxuXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcXG5cXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vZ2l0aHViLmNvbS96ejg1XFxuXFx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xcblxcdCAqXFxuXFx0ICogQ3JlYXRlcyBhbiBhcnJvdyBmb3IgdmlzdWFsaXppbmcgZGlyZWN0aW9uc1xcblxcdCAqXFxuXFx0ICogUGFyYW1ldGVyczpcXG5cXHQgKiAgZGlyIC0gVmVjdG9yM1xcblxcdCAqICBvcmlnaW4gLSBWZWN0b3IzXFxuXFx0ICogIGxlbmd0aCAtIE51bWJlclxcblxcdCAqICBjb2xvciAtIGNvbG9yIGluIGhleCB2YWx1ZVxcblxcdCAqICBoZWFkTGVuZ3RoIC0gTnVtYmVyXFxuXFx0ICogIGhlYWRXaWR0aCAtIE51bWJlclxcblxcdCAqL1xcblxcblxcdHZhciBsaW5lR2VvbWV0cnk7XFxuXFx0dmFyIGNvbmVHZW9tZXRyeTtcXG5cXG5cXHRmdW5jdGlvbiBBcnJvd0hlbHBlciggZGlyLCBvcmlnaW4sIGxlbmd0aCwgY29sb3IsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApIHtcXG5cXG5cXHRcXHQvLyBkaXIgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXFxuXFxuXFx0XFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdGlmICggY29sb3IgPT09IHVuZGVmaW5lZCApIGNvbG9yID0gMHhmZmZmMDA7XFxuXFx0XFx0aWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCApIGxlbmd0aCA9IDE7XFxuXFx0XFx0aWYgKCBoZWFkTGVuZ3RoID09PSB1bmRlZmluZWQgKSBoZWFkTGVuZ3RoID0gMC4yICogbGVuZ3RoO1xcblxcdFxcdGlmICggaGVhZFdpZHRoID09PSB1bmRlZmluZWQgKSBoZWFkV2lkdGggPSAwLjIgKiBoZWFkTGVuZ3RoO1xcblxcblxcdFxcdGlmICggbGluZUdlb21ldHJ5ID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0bGluZUdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XFxuXFx0XFx0XFx0bGluZUdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIFsgMCwgMCwgMCwgMCwgMSwgMCBdLCAzICkgKTtcXG5cXG5cXHRcXHRcXHRjb25lR2VvbWV0cnkgPSBuZXcgQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeSggMCwgMC41LCAxLCA1LCAxICk7XFxuXFx0XFx0XFx0Y29uZUdlb21ldHJ5LnRyYW5zbGF0ZSggMCwgLSAwLjUsIDAgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5wb3NpdGlvbi5jb3B5KCBvcmlnaW4gKTtcXG5cXG5cXHRcXHR0aGlzLmxpbmUgPSBuZXcgTGluZSggbGluZUdlb21ldHJ5LCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xcblxcdFxcdHRoaXMubGluZS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XFxuXFx0XFx0dGhpcy5hZGQoIHRoaXMubGluZSApO1xcblxcblxcdFxcdHRoaXMuY29uZSA9IG5ldyBNZXNoKCBjb25lR2VvbWV0cnksIG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XFxuXFx0XFx0dGhpcy5jb25lLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLmFkZCggdGhpcy5jb25lICk7XFxuXFxuXFx0XFx0dGhpcy5zZXREaXJlY3Rpb24oIGRpciApO1xcblxcdFxcdHRoaXMuc2V0TGVuZ3RoKCBsZW5ndGgsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApO1xcblxcblxcdH1cXG5cXG5cXHRBcnJvd0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKTtcXG5cXHRBcnJvd0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBcnJvd0hlbHBlcjtcXG5cXG5cXHRBcnJvd0hlbHBlci5wcm90b3R5cGUuc2V0RGlyZWN0aW9uID0gKCBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0dmFyIGF4aXMgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdHZhciByYWRpYW5zO1xcblxcblxcdFxcdHJldHVybiBmdW5jdGlvbiBzZXREaXJlY3Rpb24oIGRpciApIHtcXG5cXG5cXHRcXHRcXHQvLyBkaXIgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXFxuXFxuXFx0XFx0XFx0aWYgKCBkaXIueSA+IDAuOTk5OTkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5xdWF0ZXJuaW9uLnNldCggMCwgMCwgMCwgMSApO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGRpci55IDwgLSAwLjk5OTk5ICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMucXVhdGVybmlvbi5zZXQoIDEsIDAsIDAsIDAgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdGF4aXMuc2V0KCBkaXIueiwgMCwgLSBkaXIueCApLm5vcm1hbGl6ZSgpO1xcblxcblxcdFxcdFxcdFxcdHJhZGlhbnMgPSBNYXRoLmFjb3MoIGRpci55ICk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIHJhZGlhbnMgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHR9KCkgKTtcXG5cXG5cXHRBcnJvd0hlbHBlci5wcm90b3R5cGUuc2V0TGVuZ3RoID0gZnVuY3Rpb24gKCBsZW5ndGgsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApIHtcXG5cXG5cXHRcXHRpZiAoIGhlYWRMZW5ndGggPT09IHVuZGVmaW5lZCApIGhlYWRMZW5ndGggPSAwLjIgKiBsZW5ndGg7XFxuXFx0XFx0aWYgKCBoZWFkV2lkdGggPT09IHVuZGVmaW5lZCApIGhlYWRXaWR0aCA9IDAuMiAqIGhlYWRMZW5ndGg7XFxuXFxuXFx0XFx0dGhpcy5saW5lLnNjYWxlLnNldCggMSwgTWF0aC5tYXgoIDAsIGxlbmd0aCAtIGhlYWRMZW5ndGggKSwgMSApO1xcblxcdFxcdHRoaXMubGluZS51cGRhdGVNYXRyaXgoKTtcXG5cXG5cXHRcXHR0aGlzLmNvbmUuc2NhbGUuc2V0KCBoZWFkV2lkdGgsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApO1xcblxcdFxcdHRoaXMuY29uZS5wb3NpdGlvbi55ID0gbGVuZ3RoO1xcblxcdFxcdHRoaXMuY29uZS51cGRhdGVNYXRyaXgoKTtcXG5cXG5cXHR9O1xcblxcblxcdEFycm93SGVscGVyLnByb3RvdHlwZS5zZXRDb2xvciA9IGZ1bmN0aW9uICggY29sb3IgKSB7XFxuXFxuXFx0XFx0dGhpcy5saW5lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIGNvbG9yICk7XFxuXFx0XFx0dGhpcy5jb25lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIGNvbG9yICk7XFxuXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIHNyb3VjaGVyYXkgLyBodHRwOi8vc3JvdWNoZXJheS5vcmcvXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBBeGVzSGVscGVyKCBzaXplICkge1xcblxcblxcdFxcdHNpemUgPSBzaXplIHx8IDE7XFxuXFxuXFx0XFx0dmFyIHZlcnRpY2VzID0gW1xcblxcdFxcdFxcdDAsIDAsIDAsXFx0c2l6ZSwgMCwgMCxcXG5cXHRcXHRcXHQwLCAwLCAwLFxcdDAsIHNpemUsIDAsXFxuXFx0XFx0XFx0MCwgMCwgMCxcXHQwLCAwLCBzaXplXFxuXFx0XFx0XTtcXG5cXG5cXHRcXHR2YXIgY29sb3JzID0gW1xcblxcdFxcdFxcdDEsIDAsIDAsXFx0MSwgMC42LCAwLFxcblxcdFxcdFxcdDAsIDEsIDAsXFx0MC42LCAxLCAwLFxcblxcdFxcdFxcdDAsIDAsIDEsXFx0MCwgMC42LCAxXFxuXFx0XFx0XTtcXG5cXG5cXHRcXHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcXG5cXHRcXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XFxuXFx0XFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcXG5cXG5cXHRcXHR2YXIgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgdmVydGV4Q29sb3JzOiBWZXJ0ZXhDb2xvcnMgfSApO1xcblxcblxcdFxcdExpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcXG5cXG5cXHR9XFxuXFxuXFx0QXhlc0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaW5lU2VnbWVudHMucHJvdG90eXBlICk7XFxuXFx0QXhlc0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBeGVzSGVscGVyO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICovXFxuXFxuXFx0dmFyIFNjZW5lVXRpbHMgPSB7XFxuXFxuXFx0XFx0Y3JlYXRlTXVsdGlNYXRlcmlhbE9iamVjdDogZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWxzICkge1xcblxcblxcdFxcdFxcdHZhciBncm91cCA9IG5ldyBHcm91cCgpO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IG1hdGVyaWFscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdGdyb3VwLmFkZCggbmV3IE1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbHNbIGkgXSApICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBncm91cDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGRldGFjaDogZnVuY3Rpb24gKCBjaGlsZCwgcGFyZW50LCBzY2VuZSApIHtcXG5cXG5cXHRcXHRcXHRjaGlsZC5hcHBseU1hdHJpeCggcGFyZW50Lm1hdHJpeFdvcmxkICk7XFxuXFx0XFx0XFx0cGFyZW50LnJlbW92ZSggY2hpbGQgKTtcXG5cXHRcXHRcXHRzY2VuZS5hZGQoIGNoaWxkICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRhdHRhY2g6IGZ1bmN0aW9uICggY2hpbGQsIHNjZW5lLCBwYXJlbnQgKSB7XFxuXFxuXFx0XFx0XFx0Y2hpbGQuYXBwbHlNYXRyaXgoIG5ldyBNYXRyaXg0KCkuZ2V0SW52ZXJzZSggcGFyZW50Lm1hdHJpeFdvcmxkICkgKTtcXG5cXG5cXHRcXHRcXHRzY2VuZS5yZW1vdmUoIGNoaWxkICk7XFxuXFx0XFx0XFx0cGFyZW50LmFkZCggY2hpbGQgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEZhY2U0KCBhLCBiLCBjLCBkLCBub3JtYWwsIGNvbG9yLCBtYXRlcmlhbEluZGV4ICkge1xcblxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkZhY2U0IGhhcyBiZWVuIHJlbW92ZWQuIEEgVEhSRUUuRmFjZTMgd2lsbCBiZSBjcmVhdGVkIGluc3RlYWQuJyApO1xcblxcdFxcdHJldHVybiBuZXcgRmFjZTMoIGEsIGIsIGMsIG5vcm1hbCwgY29sb3IsIG1hdGVyaWFsSW5kZXggKTtcXG5cXG5cXHR9XFxuXFxuXFx0dmFyIExpbmVTdHJpcCA9IDA7XFxuXFxuXFx0dmFyIExpbmVQaWVjZXMgPSAxO1xcblxcblxcdGZ1bmN0aW9uIE1lc2hGYWNlTWF0ZXJpYWwoIG1hdGVyaWFscyApIHtcXG5cXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5NZXNoRmFjZU1hdGVyaWFsIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBhbiBBcnJheSBpbnN0ZWFkLicgKTtcXG5cXHRcXHRyZXR1cm4gbWF0ZXJpYWxzO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBNdWx0aU1hdGVyaWFsKCBtYXRlcmlhbHMgKSB7XFxuXFxuXFx0XFx0aWYgKCBtYXRlcmlhbHMgPT09IHVuZGVmaW5lZCApIG1hdGVyaWFscyA9IFtdO1xcblxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk11bHRpTWF0ZXJpYWwgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIGFuIEFycmF5IGluc3RlYWQuJyApO1xcblxcdFxcdG1hdGVyaWFscy5pc011bHRpTWF0ZXJpYWwgPSB0cnVlO1xcblxcdFxcdG1hdGVyaWFscy5tYXRlcmlhbHMgPSBtYXRlcmlhbHM7XFxuXFx0XFx0bWF0ZXJpYWxzLmNsb25lID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBtYXRlcmlhbHMuc2xpY2UoKTtcXG5cXG5cXHRcXHR9O1xcblxcdFxcdHJldHVybiBtYXRlcmlhbHM7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIFBvaW50Q2xvdWQoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5Qb2ludENsb3VkIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzLicgKTtcXG5cXHRcXHRyZXR1cm4gbmV3IFBvaW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICk7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIFBhcnRpY2xlKCBtYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5QYXJ0aWNsZSBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlNwcml0ZS4nICk7XFxuXFx0XFx0cmV0dXJuIG5ldyBTcHJpdGUoIG1hdGVyaWFsICk7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIFBhcnRpY2xlU3lzdGVtKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUGFydGljbGVTeXN0ZW0gaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHMuJyApO1xcblxcdFxcdHJldHVybiBuZXcgUG9pbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gUG9pbnRDbG91ZE1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xcblxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlBvaW50Q2xvdWRNYXRlcmlhbCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50c01hdGVyaWFsLicgKTtcXG5cXHRcXHRyZXR1cm4gbmV3IFBvaW50c01hdGVyaWFsKCBwYXJhbWV0ZXJzICk7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIFBhcnRpY2xlQmFzaWNNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcXG5cXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5QYXJ0aWNsZUJhc2ljTWF0ZXJpYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHNNYXRlcmlhbC4nICk7XFxuXFx0XFx0cmV0dXJuIG5ldyBQb2ludHNNYXRlcmlhbCggcGFyYW1ldGVycyApO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBQYXJ0aWNsZVN5c3RlbU1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xcblxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlBhcnRpY2xlU3lzdGVtTWF0ZXJpYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHNNYXRlcmlhbC4nICk7XFxuXFx0XFx0cmV0dXJuIG5ldyBQb2ludHNNYXRlcmlhbCggcGFyYW1ldGVycyApO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBWZXJ0ZXgoIHgsIHksIHogKSB7XFxuXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVydGV4IGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5WZWN0b3IzIGluc3RlYWQuJyApO1xcblxcdFxcdHJldHVybiBuZXcgVmVjdG9yMyggeCwgeSwgeiApO1xcblxcblxcdH1cXG5cXG5cXHQvL1xcblxcblxcdGZ1bmN0aW9uIER5bmFtaWNCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIHtcXG5cXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5EeW5hbWljQnVmZmVyQXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCkuc2V0RHluYW1pYyggdHJ1ZSApIGluc3RlYWQuJyApO1xcblxcdFxcdHJldHVybiBuZXcgQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKS5zZXREeW5hbWljKCB0cnVlICk7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIEludDhBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIHtcXG5cXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5JbnQ4QXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuSW50OEJ1ZmZlckF0dHJpYnV0ZSgpIGluc3RlYWQuJyApO1xcblxcdFxcdHJldHVybiBuZXcgSW50OEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICk7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIFVpbnQ4QXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XFxuXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVWludDhBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5VaW50OEJ1ZmZlckF0dHJpYnV0ZSgpIGluc3RlYWQuJyApO1xcblxcdFxcdHJldHVybiBuZXcgVWludDhCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBVaW50OENsYW1wZWRBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIHtcXG5cXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5VaW50OENsYW1wZWRBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5VaW50OENsYW1wZWRCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLicgKTtcXG5cXHRcXHRyZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICk7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIEludDE2QXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XFxuXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW50MTZBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5JbnQxNkJ1ZmZlckF0dHJpYnV0ZSgpIGluc3RlYWQuJyApO1xcblxcdFxcdHJldHVybiBuZXcgSW50MTZCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBVaW50MTZBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIHtcXG5cXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5VaW50MTZBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5VaW50MTZCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLicgKTtcXG5cXHRcXHRyZXR1cm4gbmV3IFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICk7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIEludDMyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKSB7XFxuXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW50MzJBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5JbnQzMkJ1ZmZlckF0dHJpYnV0ZSgpIGluc3RlYWQuJyApO1xcblxcdFxcdHJldHVybiBuZXcgSW50MzJCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBVaW50MzJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIHtcXG5cXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5VaW50MzJBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5VaW50MzJCdWZmZXJBdHRyaWJ1dGUoKSBpbnN0ZWFkLicgKTtcXG5cXHRcXHRyZXR1cm4gbmV3IFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICk7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIEZsb2F0MzJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIHtcXG5cXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5GbG9hdDMyQXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSgpIGluc3RlYWQuJyApO1xcblxcdFxcdHJldHVybiBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICk7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIEZsb2F0NjRBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIHtcXG5cXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5GbG9hdDY0QXR0cmlidXRlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuRmxvYXQ2NEJ1ZmZlckF0dHJpYnV0ZSgpIGluc3RlYWQuJyApO1xcblxcdFxcdHJldHVybiBuZXcgRmxvYXQ2NEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICk7XFxuXFxuXFx0fVxcblxcblxcdC8vXFxuXFxuXFx0Q3VydmUuY3JlYXRlID0gZnVuY3Rpb24gKCBjb25zdHJ1Y3QsIGdldFBvaW50ICkge1xcblxcblxcdFxcdGNvbnNvbGUubG9nKCAnVEhSRUUuQ3VydmUuY3JlYXRlKCkgaGFzIGJlZW4gZGVwcmVjYXRlZCcgKTtcXG5cXG5cXHRcXHRjb25zdHJ1Y3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XFxuXFx0XFx0Y29uc3RydWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdDtcXG5cXHRcXHRjb25zdHJ1Y3QucHJvdG90eXBlLmdldFBvaW50ID0gZ2V0UG9pbnQ7XFxuXFxuXFx0XFx0cmV0dXJuIGNvbnN0cnVjdDtcXG5cXG5cXHR9O1xcblxcblxcdC8vXFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggQ3VydmVQYXRoLnByb3RvdHlwZSwge1xcblxcblxcdFxcdGNyZWF0ZVBvaW50c0dlb21ldHJ5OiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5DdXJ2ZVBhdGg6IC5jcmVhdGVQb2ludHNHZW9tZXRyeSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuR2VvbWV0cnkoKS5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKSBpbnN0ZWFkLicgKTtcXG5cXG5cXHRcXHRcXHQvLyBnZW5lcmF0ZSBnZW9tZXRyeSBmcm9tIHBhdGggcG9pbnRzIChmb3IgTGluZSBvciBQb2ludHMgb2JqZWN0cylcXG5cXG5cXHRcXHRcXHR2YXIgcHRzID0gdGhpcy5nZXRQb2ludHMoIGRpdmlzaW9ucyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5KCBwdHMgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNyZWF0ZVNwYWNlZFBvaW50c0dlb21ldHJ5OiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5DdXJ2ZVBhdGg6IC5jcmVhdGVTcGFjZWRQb2ludHNHZW9tZXRyeSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuR2VvbWV0cnkoKS5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKSBpbnN0ZWFkLicgKTtcXG5cXG5cXHRcXHRcXHQvLyBnZW5lcmF0ZSBnZW9tZXRyeSBmcm9tIGVxdWlkaXN0YW50IHNhbXBsaW5nIGFsb25nIHRoZSBwYXRoXFxuXFxuXFx0XFx0XFx0dmFyIHB0cyA9IHRoaXMuZ2V0U3BhY2VkUG9pbnRzKCBkaXZpc2lvbnMgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeSggcHRzICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjcmVhdGVHZW9tZXRyeTogZnVuY3Rpb24gKCBwb2ludHMgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ3VydmVQYXRoOiAuY3JlYXRlR2VvbWV0cnkoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkdlb21ldHJ5KCkuc2V0RnJvbVBvaW50cyggcG9pbnRzICkgaW5zdGVhZC4nICk7XFxuXFxuXFx0XFx0XFx0dmFyIGdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5KCk7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHBvaW50ID0gcG9pbnRzWyBpIF07XFxuXFx0XFx0XFx0XFx0Z2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFZlY3RvcjMoIHBvaW50LngsIHBvaW50LnksIHBvaW50LnogfHwgMCApICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBnZW9tZXRyeTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8vXFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggUGF0aC5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRmcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHBvaW50cyApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5QYXRoOiAuZnJvbVBvaW50cygpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21Qb2ludHMoKS4nICk7XFxuXFx0XFx0XFx0dGhpcy5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8vXFxuXFxuXFx0ZnVuY3Rpb24gQ2xvc2VkU3BsaW5lQ3VydmUzKCBwb2ludHMgKSB7XFxuXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ2xvc2VkU3BsaW5lQ3VydmUzIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBUSFJFRS5DYXRtdWxsUm9tQ3VydmUzIGluc3RlYWQuJyApO1xcblxcblxcdFxcdENhdG11bGxSb21DdXJ2ZTMuY2FsbCggdGhpcywgcG9pbnRzICk7XFxuXFx0XFx0dGhpcy50eXBlID0gJ2NhdG11bGxyb20nO1xcblxcdFxcdHRoaXMuY2xvc2VkID0gdHJ1ZTtcXG5cXG5cXHR9XFxuXFxuXFx0Q2xvc2VkU3BsaW5lQ3VydmUzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlICk7XFxuXFxuXFx0Ly9cXG5cXG5cXHRmdW5jdGlvbiBTcGxpbmVDdXJ2ZTMoIHBvaW50cyApIHtcXG5cXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5TcGxpbmVDdXJ2ZTMgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIFRIUkVFLkNhdG11bGxSb21DdXJ2ZTMgaW5zdGVhZC4nICk7XFxuXFxuXFx0XFx0Q2F0bXVsbFJvbUN1cnZlMy5jYWxsKCB0aGlzLCBwb2ludHMgKTtcXG5cXHRcXHR0aGlzLnR5cGUgPSAnY2F0bXVsbHJvbSc7XFxuXFxuXFx0fVxcblxcblxcdFNwbGluZUN1cnZlMy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDYXRtdWxsUm9tQ3VydmUzLnByb3RvdHlwZSApO1xcblxcblxcdC8vXFxuXFxuXFx0ZnVuY3Rpb24gU3BsaW5lKCBwb2ludHMgKSB7XFxuXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU3BsaW5lIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5DYXRtdWxsUm9tQ3VydmUzIGluc3RlYWQuJyApO1xcblxcblxcdFxcdENhdG11bGxSb21DdXJ2ZTMuY2FsbCggdGhpcywgcG9pbnRzICk7XFxuXFx0XFx0dGhpcy50eXBlID0gJ2NhdG11bGxyb20nO1xcblxcblxcdH1cXG5cXG5cXHRTcGxpbmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ2F0bXVsbFJvbUN1cnZlMy5wcm90b3R5cGUgKTtcXG5cXG5cXHRPYmplY3QuYXNzaWduKCBTcGxpbmUucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0aW5pdEZyb21BcnJheTogZnVuY3Rpb24gKCAvKiBhICovICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5TcGxpbmU6IC5pbml0RnJvbUFycmF5KCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRnZXRDb250cm9sUG9pbnRzQXJyYXk6IGZ1bmN0aW9uICggLyogb3B0aW9uYWxUYXJnZXQgKi8gKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlNwbGluZTogLmdldENvbnRyb2xQb2ludHNBcnJheSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0cmVwYXJhbWV0cml6ZUJ5QXJjTGVuZ3RoOiBmdW5jdGlvbiAoIC8qIHNhbXBsaW5nQ29lZiAqLyApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuU3BsaW5lOiAucmVwYXJhbWV0cml6ZUJ5QXJjTGVuZ3RoKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvL1xcblxcblxcdGZ1bmN0aW9uIEF4aXNIZWxwZXIoIHNpemUgKSB7XFxuXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXhpc0hlbHBlciBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLkF4ZXNIZWxwZXIuJyApO1xcblxcdFxcdHJldHVybiBuZXcgQXhlc0hlbHBlciggc2l6ZSApO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBCb3VuZGluZ0JveEhlbHBlciggb2JqZWN0LCBjb2xvciApIHtcXG5cXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3VuZGluZ0JveEhlbHBlciBoYXMgYmVlbiBkZXByZWNhdGVkLiBDcmVhdGluZyBhIFRIUkVFLkJveEhlbHBlciBpbnN0ZWFkLicgKTtcXG5cXHRcXHRyZXR1cm4gbmV3IEJveEhlbHBlciggb2JqZWN0LCBjb2xvciApO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBFZGdlc0hlbHBlciggb2JqZWN0LCBoZXggKSB7XFxuXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRWRnZXNIZWxwZXIgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkVkZ2VzR2VvbWV0cnkgaW5zdGVhZC4nICk7XFxuXFx0XFx0cmV0dXJuIG5ldyBMaW5lU2VnbWVudHMoIG5ldyBFZGdlc0dlb21ldHJ5KCBvYmplY3QuZ2VvbWV0cnkgKSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBoZXggIT09IHVuZGVmaW5lZCA/IGhleCA6IDB4ZmZmZmZmIH0gKSApO1xcblxcblxcdH1cXG5cXG5cXHRHcmlkSGVscGVyLnByb3RvdHlwZS5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkdyaWRIZWxwZXI6IHNldENvbG9ycygpIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHBhc3MgdGhlbSBpbiB0aGUgY29uc3RydWN0b3IgaW5zdGVhZC4nICk7XFxuXFxuXFx0fTtcXG5cXG5cXHRTa2VsZXRvbkhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Ta2VsZXRvbkhlbHBlcjogdXBkYXRlKCkgbm8gbG9uZ2VyIG5lZWRzIHRvIGJlIGNhbGxlZC4nICk7XFxuXFxuXFx0fTtcXG5cXG5cXHRmdW5jdGlvbiBXaXJlZnJhbWVIZWxwZXIoIG9iamVjdCwgaGV4ICkge1xcblxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldpcmVmcmFtZUhlbHBlciBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuV2lyZWZyYW1lR2VvbWV0cnkgaW5zdGVhZC4nICk7XFxuXFx0XFx0cmV0dXJuIG5ldyBMaW5lU2VnbWVudHMoIG5ldyBXaXJlZnJhbWVHZW9tZXRyeSggb2JqZWN0Lmdlb21ldHJ5ICksIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogaGV4ICE9PSB1bmRlZmluZWQgPyBoZXggOiAweGZmZmZmZiB9ICkgKTtcXG5cXG5cXHR9XFxuXFxuXFx0Ly9cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBMb2FkZXIucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0ZXh0cmFjdFVybEJhc2U6IGZ1bmN0aW9uICggdXJsICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxvYWRlcjogLmV4dHJhY3RVcmxCYXNlKCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIFRIUkVFLkxvYWRlclV0aWxzLmV4dHJhY3RVcmxCYXNlKCkgaW5zdGVhZC4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIExvYWRlclV0aWxzLmV4dHJhY3RVcmxCYXNlKCB1cmwgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdGZ1bmN0aW9uIFhIUkxvYWRlciggbWFuYWdlciApIHtcXG5cXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5YSFJMb2FkZXIgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5GaWxlTG9hZGVyLicgKTtcXG5cXHRcXHRyZXR1cm4gbmV3IEZpbGVMb2FkZXIoIG1hbmFnZXIgKTtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gQmluYXJ5VGV4dHVyZUxvYWRlciggbWFuYWdlciApIHtcXG5cXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5CaW5hcnlUZXh0dXJlTG9hZGVyIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuRGF0YVRleHR1cmVMb2FkZXIuJyApO1xcblxcdFxcdHJldHVybiBuZXcgRGF0YVRleHR1cmVMb2FkZXIoIG1hbmFnZXIgKTtcXG5cXG5cXHR9XFxuXFxuXFx0Ly9cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBCb3gyLnByb3RvdHlwZSwge1xcblxcblxcdFxcdGNlbnRlcjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3gyOiAuY2VudGVyKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0Q2VudGVyKCkuJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmdldENlbnRlciggb3B0aW9uYWxUYXJnZXQgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdGVtcHR5OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MjogLmVtcHR5KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaXNFbXB0eSgpLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5pc0VtcHR5KCk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRpc0ludGVyc2VjdGlvbkJveDogZnVuY3Rpb24gKCBib3ggKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MjogLmlzSW50ZXJzZWN0aW9uQm94KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c0JveCgpLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzQm94KCBib3ggKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdHNpemU6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MjogLnNpemUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRTaXplKCkuJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmdldFNpemUoIG9wdGlvbmFsVGFyZ2V0ICk7XFxuXFxuXFx0XFx0fVxcblxcdH0gKTtcXG5cXG5cXHRPYmplY3QuYXNzaWduKCBCb3gzLnByb3RvdHlwZSwge1xcblxcblxcdFxcdGNlbnRlcjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3gzOiAuY2VudGVyKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0Q2VudGVyKCkuJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmdldENlbnRlciggb3B0aW9uYWxUYXJnZXQgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdGVtcHR5OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MzogLmVtcHR5KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaXNFbXB0eSgpLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5pc0VtcHR5KCk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRpc0ludGVyc2VjdGlvbkJveDogZnVuY3Rpb24gKCBib3ggKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQm94MzogLmlzSW50ZXJzZWN0aW9uQm94KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c0JveCgpLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzQm94KCBib3ggKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdGlzSW50ZXJzZWN0aW9uU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3gzOiAuaXNJbnRlcnNlY3Rpb25TcGhlcmUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzU3BoZXJlKCkuJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0c2l6ZTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3gzOiAuc2l6ZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldFNpemUoKS4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2V0U2l6ZSggb3B0aW9uYWxUYXJnZXQgKTtcXG5cXG5cXHRcXHR9XFxuXFx0fSApO1xcblxcblxcdExpbmUzLnByb3RvdHlwZS5jZW50ZXIgPSBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpbmUzOiAuY2VudGVyKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0Q2VudGVyKCkuJyApO1xcblxcdFxcdHJldHVybiB0aGlzLmdldENlbnRlciggb3B0aW9uYWxUYXJnZXQgKTtcXG5cXG5cXHR9O1xcblxcblxcdE9iamVjdC5hc3NpZ24oIF9NYXRoLCB7XFxuXFxuXFx0XFx0cmFuZG9tMTY6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRoOiAucmFuZG9tMTYoKSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgTWF0aC5yYW5kb20oKSBpbnN0ZWFkLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gTWF0aC5yYW5kb20oKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG5lYXJlc3RQb3dlck9mVHdvOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGg6IC5uZWFyZXN0UG93ZXJPZlR3bygpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmZsb29yUG93ZXJPZlR3bygpLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gX01hdGguZmxvb3JQb3dlck9mVHdvKCB2YWx1ZSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bmV4dFBvd2VyT2ZUd286IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0aDogLm5leHRQb3dlck9mVHdvKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuY2VpbFBvd2VyT2ZUd28oKS4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIF9NYXRoLmNlaWxQb3dlck9mVHdvKCB2YWx1ZSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggTWF0cml4My5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRmbGF0dGVuVG9BcnJheU9mZnNldDogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggXFxcIlRIUkVFLk1hdHJpeDM6IC5mbGF0dGVuVG9BcnJheU9mZnNldCgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAudG9BcnJheSgpIGluc3RlYWQuXFxcIiApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLnRvQXJyYXkoIGFycmF5LCBvZmZzZXQgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdG11bHRpcGx5VmVjdG9yMzogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4MzogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXgzKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4MyggdGhpcyApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0bXVsdGlwbHlWZWN0b3IzQXJyYXk6IGZ1bmN0aW9uICggLyogYSAqLyApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4MzogLm11bHRpcGx5VmVjdG9yM0FycmF5KCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRhcHBseVRvQnVmZmVyOiBmdW5jdGlvbiAoIGJ1ZmZlciAvKiwgb2Zmc2V0LCBsZW5ndGggKi8gKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4MzogLmFwcGx5VG9CdWZmZXIoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbWF0cml4LmFwcGx5VG9CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIGluc3RlYWQuJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmFwcGx5VG9CdWZmZXJBdHRyaWJ1dGUoIGJ1ZmZlciApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0YXBwbHlUb1ZlY3RvcjNBcnJheTogZnVuY3Rpb24gKCAvKiBhcnJheSwgb2Zmc2V0LCBsZW5ndGggKi8gKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDM6IC5hcHBseVRvVmVjdG9yM0FycmF5KCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHRPYmplY3QuYXNzaWduKCBNYXRyaXg0LnByb3RvdHlwZSwge1xcblxcblxcdFxcdGV4dHJhY3RQb3NpdGlvbjogZnVuY3Rpb24gKCBtICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5leHRyYWN0UG9zaXRpb24oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5jb3B5UG9zaXRpb24oKS4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuY29weVBvc2l0aW9uKCBtICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRmbGF0dGVuVG9BcnJheU9mZnNldDogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggXFxcIlRIUkVFLk1hdHJpeDQ6IC5mbGF0dGVuVG9BcnJheU9mZnNldCgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSAudG9BcnJheSgpIGluc3RlYWQuXFxcIiApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLnRvQXJyYXkoIGFycmF5LCBvZmZzZXQgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHYxO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBnZXRQb3NpdGlvbigpIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLmdldFBvc2l0aW9uKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdjEuc2V0RnJvbU1hdHJpeENvbHVtbiggdGhpcywgMyApO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcdFxcdHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCkuJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRtdWx0aXBseVRvQXJyYXk6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlUb0FycmF5KCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRtdWx0aXBseVZlY3RvcjM6IGZ1bmN0aW9uICggdmVjdG9yICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgaW5zdGVhZC4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdG11bHRpcGx5VmVjdG9yNDogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5VmVjdG9yNCgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcyApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0bXVsdGlwbHlWZWN0b3IzQXJyYXk6IGZ1bmN0aW9uICggLyogYSAqLyApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5VmVjdG9yM0FycmF5KCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRyb3RhdGVBeGlzOiBmdW5jdGlvbiAoIHYgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZUF4aXMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVmVjdG9yMy50cmFuc2Zvcm1EaXJlY3Rpb24oIG1hdHJpeCApIGluc3RlYWQuJyApO1xcblxcdFxcdFxcdHYudHJhbnNmb3JtRGlyZWN0aW9uKCB0aGlzICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRjcm9zc1ZlY3RvcjogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLmNyb3NzVmVjdG9yKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIGluc3RlYWQuJyApO1xcblxcdFxcdFxcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCB0aGlzICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnRyYW5zbGF0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0cm90YXRlWDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlWCgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0cm90YXRlWTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlWSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0cm90YXRlWjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlWigpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0cm90YXRlQnlBeGlzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVCeUF4aXMoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdGFwcGx5VG9CdWZmZXI6IGZ1bmN0aW9uICggYnVmZmVyIC8qLCBvZmZzZXQsIGxlbmd0aCAqLyApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuYXBwbHlUb0J1ZmZlcigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBtYXRyaXguYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlICkgaW5zdGVhZC4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZSggYnVmZmVyICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRhcHBseVRvVmVjdG9yM0FycmF5OiBmdW5jdGlvbiAoIC8qIGFycmF5LCBvZmZzZXQsIGxlbmd0aCAqLyApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLmFwcGx5VG9WZWN0b3IzQXJyYXkoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdG1ha2VGcnVzdHVtOiBmdW5jdGlvbiAoIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tYWtlRnJ1c3R1bSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAubWFrZVBlcnNwZWN0aXZlKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciApIGluc3RlYWQuJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLm1ha2VQZXJzcGVjdGl2ZSggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdFBsYW5lLnByb3RvdHlwZS5pc0ludGVyc2VjdGlvbkxpbmUgPSBmdW5jdGlvbiAoIGxpbmUgKSB7XFxuXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUGxhbmU6IC5pc0ludGVyc2VjdGlvbkxpbmUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzTGluZSgpLicgKTtcXG5cXHRcXHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzTGluZSggbGluZSApO1xcblxcblxcdH07XFxuXFxuXFx0UXVhdGVybmlvbi5wcm90b3R5cGUubXVsdGlwbHlWZWN0b3IzID0gZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XFxuXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUXVhdGVybmlvbjogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBpcyBub3cgdmVjdG9yLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApIGluc3RlYWQuJyApO1xcblxcdFxcdHJldHVybiB2ZWN0b3IuYXBwbHlRdWF0ZXJuaW9uKCB0aGlzICk7XFxuXFxuXFx0fTtcXG5cXG5cXHRPYmplY3QuYXNzaWduKCBSYXkucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0aXNJbnRlcnNlY3Rpb25Cb3g6IGZ1bmN0aW9uICggYm94ICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlJheTogLmlzSW50ZXJzZWN0aW9uQm94KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c0JveCgpLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzQm94KCBib3ggKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdGlzSW50ZXJzZWN0aW9uUGxhbmU6IGZ1bmN0aW9uICggcGxhbmUgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUmF5OiAuaXNJbnRlcnNlY3Rpb25QbGFuZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNQbGFuZSgpLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzUGxhbmUoIHBsYW5lICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRpc0ludGVyc2VjdGlvblNwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUmF5OiAuaXNJbnRlcnNlY3Rpb25TcGhlcmUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzU3BoZXJlKCkuJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggU2hhcGUucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0ZXh0cmFjdEFsbFBvaW50czogZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU2hhcGU6IC5leHRyYWN0QWxsUG9pbnRzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIC5leHRyYWN0UG9pbnRzKCkgaW5zdGVhZC4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZXh0cmFjdFBvaW50cyggZGl2aXNpb25zICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRleHRydWRlOiBmdW5jdGlvbiAoIG9wdGlvbnMgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU2hhcGU6IC5leHRydWRlKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIEV4dHJ1ZGVHZW9tZXRyeSgpIGluc3RlYWQuJyApO1xcblxcdFxcdFxcdHJldHVybiBuZXcgRXh0cnVkZUdlb21ldHJ5KCB0aGlzLCBvcHRpb25zICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRtYWtlR2VvbWV0cnk6IGZ1bmN0aW9uICggb3B0aW9ucyApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5TaGFwZTogLm1ha2VHZW9tZXRyeSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBTaGFwZUdlb21ldHJ5KCkgaW5zdGVhZC4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIG5ldyBTaGFwZUdlb21ldHJ5KCB0aGlzLCBvcHRpb25zICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHRPYmplY3QuYXNzaWduKCBWZWN0b3IyLnByb3RvdHlwZSwge1xcblxcblxcdFxcdGZyb21BdHRyaWJ1dGU6IGZ1bmN0aW9uICggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjI6IC5mcm9tQXR0cmlidXRlKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5mcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdGRpc3RhbmNlVG9NYW5oYXR0YW46IGZ1bmN0aW9uICggdiApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IyOiAuZGlzdGFuY2VUb01hbmhhdHRhbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLm1hbmhhdHRhbkRpc3RhbmNlVG8oKS4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubWFuaGF0dGFuRGlzdGFuY2VUbyggdiApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0bGVuZ3RoTWFuaGF0dGFuOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMjogLmxlbmd0aE1hbmhhdHRhbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLm1hbmhhdHRhbkxlbmd0aCgpLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5tYW5oYXR0YW5MZW5ndGgoKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdE9iamVjdC5hc3NpZ24oIFZlY3RvcjMucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0c2V0RXVsZXJGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLnNldEV1bGVyRnJvbVJvdGF0aW9uTWF0cml4KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIEV1bGVyLnNldEZyb21Sb3RhdGlvbk1hdHJpeCgpIGluc3RlYWQuJyApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0c2V0RXVsZXJGcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5WZWN0b3IzOiAuc2V0RXVsZXJGcm9tUXVhdGVybmlvbigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBFdWxlci5zZXRGcm9tUXVhdGVybmlvbigpIGluc3RlYWQuJyApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0Z2V0UG9zaXRpb25Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmdldFBvc2l0aW9uRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhQb3NpdGlvbigpLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG0gKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdGdldFNjYWxlRnJvbU1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5nZXRTY2FsZUZyb21NYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tTWF0cml4U2NhbGUoKS4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeFNjYWxlKCBtICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRnZXRDb2x1bW5Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIGluZGV4LCBtYXRyaXggKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmdldENvbHVtbkZyb21NYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tTWF0cml4Q29sdW1uKCkuJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIG1hdHJpeCwgaW5kZXggKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdGFwcGx5UHJvamVjdGlvbjogZnVuY3Rpb24gKCBtICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5hcHBseVByb2plY3Rpb24oKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgLmFwcGx5TWF0cml4NCggbSApIGluc3RlYWQuJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmFwcGx5TWF0cml4NCggbSApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0ZnJvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmZyb21BdHRyaWJ1dGUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5mcm9tQnVmZmVyQXR0cmlidXRlKCkuJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0ZGlzdGFuY2VUb01hbmhhdHRhbjogZnVuY3Rpb24gKCB2ICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5kaXN0YW5jZVRvTWFuaGF0dGFuKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAubWFuaGF0dGFuRGlzdGFuY2VUbygpLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5tYW5oYXR0YW5EaXN0YW5jZVRvKCB2ICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRsZW5ndGhNYW5oYXR0YW46IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAubGVuZ3RoTWFuaGF0dGFuKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAubWFuaGF0dGFuTGVuZ3RoKCkuJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLm1hbmhhdHRhbkxlbmd0aCgpO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggVmVjdG9yNC5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRmcm9tQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3I0OiAuZnJvbUF0dHJpYnV0ZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmZyb21CdWZmZXJBdHRyaWJ1dGUoKS4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRsZW5ndGhNYW5oYXR0YW46IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3I0OiAubGVuZ3RoTWFuaGF0dGFuKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAubWFuaGF0dGFuTGVuZ3RoKCkuJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLm1hbmhhdHRhbkxlbmd0aCgpO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0Ly9cXG5cXG5cXHRHZW9tZXRyeS5wcm90b3R5cGUuY29tcHV0ZVRhbmdlbnRzID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdlb21ldHJ5OiAuY29tcHV0ZVRhbmdlbnRzKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxuXFxuXFx0fTtcXG5cXG5cXHRPYmplY3QuYXNzaWduKCBPYmplY3QzRC5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRnZXRDaGlsZEJ5TmFtZTogZnVuY3Rpb24gKCBuYW1lICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAuZ2V0Q2hpbGRCeU5hbWUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRPYmplY3RCeU5hbWUoKS4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlOYW1lKCBuYW1lICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRyZW5kZXJEZXB0aDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAucmVuZGVyRGVwdGggaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIC5yZW5kZXJPcmRlciwgaW5zdGVhZC4nICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggZGlzdGFuY2UsIGF4aXMgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC50cmFuc2xhdGUoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgLnRyYW5zbGF0ZU9uQXhpcyggYXhpcywgZGlzdGFuY2UgKSBpbnN0ZWFkLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoIGF4aXMsIGRpc3RhbmNlICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggT2JqZWN0M0QucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0ZXVsZXJPcmRlcjoge1xcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAuZXVsZXJPcmRlciBpcyBub3cgLnJvdGF0aW9uLm9yZGVyLicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5yb3RhdGlvbi5vcmRlcjtcXG5cXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLmV1bGVyT3JkZXIgaXMgbm93IC5yb3RhdGlvbi5vcmRlci4nICk7XFxuXFx0XFx0XFx0XFx0dGhpcy5yb3RhdGlvbi5vcmRlciA9IHZhbHVlO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdHVzZVF1YXRlcm5pb246IHtcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLnVzZVF1YXRlcm5pb24gaGFzIGJlZW4gcmVtb3ZlZC4gVGhlIGxpYnJhcnkgbm93IHVzZXMgcXVhdGVybmlvbnMgYnkgZGVmYXVsdC4nICk7XFxuXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLnVzZVF1YXRlcm5pb24gaGFzIGJlZW4gcmVtb3ZlZC4gVGhlIGxpYnJhcnkgbm93IHVzZXMgcXVhdGVybmlvbnMgYnkgZGVmYXVsdC4nICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIExPRC5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRvYmplY3RzOiB7XFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTE9EOiAub2JqZWN0cyBoYXMgYmVlbiByZW5hbWVkIHRvIC5sZXZlbHMuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmxldmVscztcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIFNrZWxldG9uLnByb3RvdHlwZSwgJ3VzZVZlcnRleFRleHR1cmUnLCB7XFxuXFxuXFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuU2tlbGV0b246IHVzZVZlcnRleFRleHR1cmUgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5Ta2VsZXRvbjogdXNlVmVydGV4VGV4dHVyZSBoYXMgYmVlbiByZW1vdmVkLicgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggQ3VydmUucHJvdG90eXBlLCAnX19hcmNMZW5ndGhEaXZpc2lvbnMnLCB7XFxuXFxuXFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ3VydmU6IC5fX2FyY0xlbmd0aERpdmlzaW9ucyBpcyBub3cgLmFyY0xlbmd0aERpdmlzaW9ucy4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkN1cnZlOiAuX19hcmNMZW5ndGhEaXZpc2lvbnMgaXMgbm93IC5hcmNMZW5ndGhEaXZpc2lvbnMuJyApO1xcblxcdFxcdFxcdHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zID0gdmFsdWU7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvL1xcblxcblxcdFBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS5zZXRMZW5zID0gZnVuY3Rpb24gKCBmb2NhbExlbmd0aCwgZmlsbUdhdWdlICkge1xcblxcblxcdFxcdGNvbnNvbGUud2FybiggXFxcIlRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnNldExlbnMgaXMgZGVwcmVjYXRlZC4gXFxcIiArXFxuXFx0XFx0XFx0XFx0XFxcIlVzZSAuc2V0Rm9jYWxMZW5ndGggYW5kIC5maWxtR2F1Z2UgZm9yIGEgcGhvdG9ncmFwaGljIHNldHVwLlxcXCIgKTtcXG5cXG5cXHRcXHRpZiAoIGZpbG1HYXVnZSAhPT0gdW5kZWZpbmVkICkgdGhpcy5maWxtR2F1Z2UgPSBmaWxtR2F1Z2U7XFxuXFx0XFx0dGhpcy5zZXRGb2NhbExlbmd0aCggZm9jYWxMZW5ndGggKTtcXG5cXG5cXHR9O1xcblxcblxcdC8vXFxuXFxuXFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIExpZ2h0LnByb3RvdHlwZSwge1xcblxcdFxcdG9ubHlTaGFkb3c6IHtcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLm9ubHlTaGFkb3cgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0c2hhZG93Q2FtZXJhRm92OiB7XFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhRm92IGlzIG5vdyAuc2hhZG93LmNhbWVyYS5mb3YuJyApO1xcblxcdFxcdFxcdFxcdHRoaXMuc2hhZG93LmNhbWVyYS5mb3YgPSB2YWx1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHRzaGFkb3dDYW1lcmFMZWZ0OiB7XFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhTGVmdCBpcyBub3cgLnNoYWRvdy5jYW1lcmEubGVmdC4nICk7XFxuXFx0XFx0XFx0XFx0dGhpcy5zaGFkb3cuY2FtZXJhLmxlZnQgPSB2YWx1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHRzaGFkb3dDYW1lcmFSaWdodDoge1xcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYVJpZ2h0IGlzIG5vdyAuc2hhZG93LmNhbWVyYS5yaWdodC4nICk7XFxuXFx0XFx0XFx0XFx0dGhpcy5zaGFkb3cuY2FtZXJhLnJpZ2h0ID0gdmFsdWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0c2hhZG93Q2FtZXJhVG9wOiB7XFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhVG9wIGlzIG5vdyAuc2hhZG93LmNhbWVyYS50b3AuJyApO1xcblxcdFxcdFxcdFxcdHRoaXMuc2hhZG93LmNhbWVyYS50b3AgPSB2YWx1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHRzaGFkb3dDYW1lcmFCb3R0b206IHtcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFCb3R0b20gaXMgbm93IC5zaGFkb3cuY2FtZXJhLmJvdHRvbS4nICk7XFxuXFx0XFx0XFx0XFx0dGhpcy5zaGFkb3cuY2FtZXJhLmJvdHRvbSA9IHZhbHVlO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdHNoYWRvd0NhbWVyYU5lYXI6IHtcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFOZWFyIGlzIG5vdyAuc2hhZG93LmNhbWVyYS5uZWFyLicgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLnNoYWRvdy5jYW1lcmEubmVhciA9IHZhbHVlO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdHNoYWRvd0NhbWVyYUZhcjoge1xcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYUZhciBpcyBub3cgLnNoYWRvdy5jYW1lcmEuZmFyLicgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLnNoYWRvdy5jYW1lcmEuZmFyID0gdmFsdWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0c2hhZG93Q2FtZXJhVmlzaWJsZToge1xcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhVmlzaWJsZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkNhbWVyYUhlbHBlciggbGlnaHQuc2hhZG93LmNhbWVyYSApIGluc3RlYWQuJyApO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdHNoYWRvd0JpYXM6IHtcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dCaWFzIGlzIG5vdyAuc2hhZG93LmJpYXMuJyApO1xcblxcdFxcdFxcdFxcdHRoaXMuc2hhZG93LmJpYXMgPSB2YWx1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHRzaGFkb3dEYXJrbmVzczoge1xcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93RGFya25lc3MgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0c2hhZG93TWFwV2lkdGg6IHtcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dNYXBXaWR0aCBpcyBub3cgLnNoYWRvdy5tYXBTaXplLndpZHRoLicgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLnNoYWRvdy5tYXBTaXplLndpZHRoID0gdmFsdWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0c2hhZG93TWFwSGVpZ2h0OiB7XFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93TWFwSGVpZ2h0IGlzIG5vdyAuc2hhZG93Lm1hcFNpemUuaGVpZ2h0LicgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLnNoYWRvdy5tYXBTaXplLmhlaWdodCA9IHZhbHVlO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fSApO1xcblxcblxcdC8vXFxuXFxuXFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRsZW5ndGg6IHtcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IC5sZW5ndGggaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5jb3VudCBpbnN0ZWFkLicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5hcnJheS5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0YWRkSW5kZXg6IGZ1bmN0aW9uICggaW5kZXggKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGRJbmRleCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEluZGV4KCkuJyApO1xcblxcdFxcdFxcdHRoaXMuc2V0SW5kZXgoIGluZGV4ICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRhZGREcmF3Q2FsbDogZnVuY3Rpb24gKCBzdGFydCwgY291bnQsIGluZGV4T2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdGlmICggaW5kZXhPZmZzZXQgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZERyYXdDYWxsKCkgbm8gbG9uZ2VyIHN1cHBvcnRzIGluZGV4T2Zmc2V0LicgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5hZGREcmF3Q2FsbCgpIGlzIG5vdyAuYWRkR3JvdXAoKS4nICk7XFxuXFx0XFx0XFx0dGhpcy5hZGRHcm91cCggc3RhcnQsIGNvdW50ICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRjbGVhckRyYXdDYWxsczogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuY2xlYXJEcmF3Q2FsbHMoKSBpcyBub3cgLmNsZWFyR3JvdXBzKCkuJyApO1xcblxcdFxcdFxcdHRoaXMuY2xlYXJHcm91cHMoKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdGNvbXB1dGVUYW5nZW50czogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuY29tcHV0ZVRhbmdlbnRzKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRjb21wdXRlT2Zmc2V0czogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuY29tcHV0ZU9mZnNldHMoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRkcmF3Y2FsbHM6IHtcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5kcmF3Y2FsbHMgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ3JvdXBzLicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5ncm91cHM7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0b2Zmc2V0czoge1xcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAub2Zmc2V0cyBoYXMgYmVlbiByZW5hbWVkIHRvIC5ncm91cHMuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmdyb3VwcztcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvL1xcblxcblxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBVbmlmb3JtLnByb3RvdHlwZSwge1xcblxcblxcdFxcdGR5bmFtaWM6IHtcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5Vbmlmb3JtOiAuZHluYW1pYyBoYXMgYmVlbiByZW1vdmVkLiBVc2Ugb2JqZWN0Lm9uQmVmb3JlUmVuZGVyKCkgaW5zdGVhZC4nICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0b25VcGRhdGU6IHtcXG5cXHRcXHRcXHR2YWx1ZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlVuaWZvcm06IC5vblVwZGF0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBvYmplY3Qub25CZWZvcmVSZW5kZXIoKSBpbnN0ZWFkLicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvL1xcblxcblxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBNYXRlcmlhbC5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHR3cmFwQXJvdW5kOiB7XFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0ZXJpYWw6IC53cmFwQXJvdW5kIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcblxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0ZXJpYWw6IC53cmFwQXJvdW5kIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdHdyYXBSR0I6IHtcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRlcmlhbDogLndyYXBSR0IgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIG5ldyBDb2xvcigpO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNoYWRpbmc6IHtcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuJyArIHRoaXMudHlwZSArICc6IC5zaGFkaW5nIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB0aGUgYm9vbGVhbiAuZmxhdFNoYWRpbmcgaW5zdGVhZC4nICk7XFxuXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuJyArIHRoaXMudHlwZSArICc6IC5zaGFkaW5nIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB0aGUgYm9vbGVhbiAuZmxhdFNoYWRpbmcgaW5zdGVhZC4nICk7XFxuXFx0XFx0XFx0XFx0dGhpcy5mbGF0U2hhZGluZyA9ICggdmFsdWUgPT09IEZsYXRTaGFkaW5nICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZSwge1xcblxcblxcdFxcdG1ldGFsOiB7XFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWVzaFBob25nTWF0ZXJpYWw6IC5tZXRhbCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwgaW5zdGVhZC4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWVzaFBob25nTWF0ZXJpYWw6IC5tZXRhbCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwgaW5zdGVhZCcgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0ZGVyaXZhdGl2ZXM6IHtcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5TaGFkZXJNYXRlcmlhbDogLmRlcml2YXRpdmVzIGhhcyBiZWVuIG1vdmVkIHRvIC5leHRlbnNpb25zLmRlcml2YXRpdmVzLicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmRlcml2YXRpdmVzO1xcblxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLiBTaGFkZXJNYXRlcmlhbDogLmRlcml2YXRpdmVzIGhhcyBiZWVuIG1vdmVkIHRvIC5leHRlbnNpb25zLmRlcml2YXRpdmVzLicgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLmV4dGVuc2lvbnMuZGVyaXZhdGl2ZXMgPSB2YWx1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvL1xcblxcblxcdE9iamVjdC5hc3NpZ24oIFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0Z2V0Q3VycmVudFJlbmRlclRhcmdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5nZXRDdXJyZW50UmVuZGVyVGFyZ2V0KCkgaXMgbm93IC5nZXRSZW5kZXJUYXJnZXQoKS4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2V0UmVuZGVyVGFyZ2V0KCk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRNYXhBbmlzb3Ryb3B5OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmdldE1heEFuaXNvdHJvcHkoKSBpcyBub3cgLmNhcGFiaWxpdGllcy5nZXRNYXhBbmlzb3Ryb3B5KCkuJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmNhcGFiaWxpdGllcy5nZXRNYXhBbmlzb3Ryb3B5KCk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRQcmVjaXNpb246IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuZ2V0UHJlY2lzaW9uKCkgaXMgbm93IC5jYXBhYmlsaXRpZXMucHJlY2lzaW9uLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5jYXBhYmlsaXRpZXMucHJlY2lzaW9uO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cmVzZXRHTFN0YXRlOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnJlc2V0R0xTdGF0ZSgpIGlzIG5vdyAuc3RhdGUucmVzZXQoKS4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuc3RhdGUucmVzZXQoKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHN1cHBvcnRzRmxvYXRUZXh0dXJlczogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0Zsb2F0VGV4dHVyZXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXFxcJ09FU190ZXh0dXJlX2Zsb2F0XFxcXCcgKS4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdCcgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdHN1cHBvcnRzSGFsZkZsb2F0VGV4dHVyZXM6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNIYWxmRmxvYXRUZXh0dXJlcygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcXFwnT0VTX3RleHR1cmVfaGFsZl9mbG9hdFxcXFwnICkuJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdHN1cHBvcnRzU3RhbmRhcmREZXJpdmF0aXZlczogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c1N0YW5kYXJkRGVyaXZhdGl2ZXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXFxcJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlc1xcXFwnICkuJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KCAnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJyApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0c3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVMzVEM6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVMzVEMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXFxcJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjXFxcXCcgKS4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdHN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVQVlJUQzogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUFZSVEMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXFxcJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0Y1xcXFwnICkuJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0c3VwcG9ydHNCbGVuZE1pbk1heDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0JsZW5kTWluTWF4KCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFxcXCdFWFRfYmxlbmRfbWlubWF4XFxcXCcgKS4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdFWFRfYmxlbmRfbWlubWF4JyApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0c3VwcG9ydHNWZXJ0ZXhUZXh0dXJlczogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c1ZlcnRleFRleHR1cmVzKCkgaXMgbm93IC5jYXBhYmlsaXRpZXMudmVydGV4VGV4dHVyZXMuJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmNhcGFiaWxpdGllcy52ZXJ0ZXhUZXh0dXJlcztcXG5cXG5cXHRcXHR9LFxcblxcdFxcdHN1cHBvcnRzSW5zdGFuY2VkQXJyYXlzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzSW5zdGFuY2VkQXJyYXlzKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFxcXCdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXFxcXCcgKS4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0ZW5hYmxlU2Npc3NvclRlc3Q6IGZ1bmN0aW9uICggYm9vbGVhbiApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuZW5hYmxlU2Npc3NvclRlc3QoKSBpcyBub3cgLnNldFNjaXNzb3JUZXN0KCkuJyApO1xcblxcdFxcdFxcdHRoaXMuc2V0U2Npc3NvclRlc3QoIGJvb2xlYW4gKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdGluaXRNYXRlcmlhbDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5pbml0TWF0ZXJpYWwoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdGFkZFByZVBsdWdpbjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5hZGRQcmVQbHVnaW4oKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdGFkZFBvc3RQbHVnaW46IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuYWRkUG9zdFBsdWdpbigpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0dXBkYXRlU2hhZG93TWFwOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnVwZGF0ZVNoYWRvd01hcCgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0c2hhZG93TWFwRW5hYmxlZDoge1xcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnNoYWRvd01hcC5lbmFibGVkO1xcblxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBFbmFibGVkIGlzIG5vdyAuc2hhZG93TWFwLmVuYWJsZWQuJyApO1xcblxcdFxcdFxcdFxcdHRoaXMuc2hhZG93TWFwLmVuYWJsZWQgPSB2YWx1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHRzaGFkb3dNYXBUeXBlOiB7XFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuc2hhZG93TWFwLnR5cGU7XFxuXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcFR5cGUgaXMgbm93IC5zaGFkb3dNYXAudHlwZS4nICk7XFxuXFx0XFx0XFx0XFx0dGhpcy5zaGFkb3dNYXAudHlwZSA9IHZhbHVlO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdHNoYWRvd01hcEN1bGxGYWNlOiB7XFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuc2hhZG93TWFwLmN1bGxGYWNlO1xcblxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBDdWxsRmFjZSBpcyBub3cgLnNoYWRvd01hcC5jdWxsRmFjZS4nICk7XFxuXFx0XFx0XFx0XFx0dGhpcy5zaGFkb3dNYXAuY3VsbEZhY2UgPSB2YWx1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH0gKTtcXG5cXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggV2ViR0xTaGFkb3dNYXAucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0Y3VsbEZhY2U6IHtcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5yZW5kZXJSZXZlcnNlU2lkZWQgPyBDdWxsRmFjZUZyb250IDogQ3VsbEZhY2VCYWNrO1xcblxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIGN1bGxGYWNlICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB2YWx1ZSA9ICggY3VsbEZhY2UgIT09IEN1bGxGYWNlQmFjayApO1xcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggXFxcIldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXAuY3VsbEZhY2UgaXMgZGVwcmVjYXRlZC4gU2V0IC5zaGFkb3dNYXAucmVuZGVyUmV2ZXJzZVNpZGVkIHRvIFxcXCIgKyB2YWx1ZSArIFxcXCIuXFxcIiApO1xcblxcdFxcdFxcdFxcdHRoaXMucmVuZGVyUmV2ZXJzZVNpZGVkID0gdmFsdWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0Ly9cXG5cXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggV2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0d3JhcFM6IHtcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLndyYXBTIGlzIG5vdyAudGV4dHVyZS53cmFwUy4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMudGV4dHVyZS53cmFwUztcXG5cXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLndyYXBTIGlzIG5vdyAudGV4dHVyZS53cmFwUy4nICk7XFxuXFx0XFx0XFx0XFx0dGhpcy50ZXh0dXJlLndyYXBTID0gdmFsdWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0d3JhcFQ6IHtcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLndyYXBUIGlzIG5vdyAudGV4dHVyZS53cmFwVC4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMudGV4dHVyZS53cmFwVDtcXG5cXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLndyYXBUIGlzIG5vdyAudGV4dHVyZS53cmFwVC4nICk7XFxuXFx0XFx0XFx0XFx0dGhpcy50ZXh0dXJlLndyYXBUID0gdmFsdWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0bWFnRmlsdGVyOiB7XFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5tYWdGaWx0ZXIgaXMgbm93IC50ZXh0dXJlLm1hZ0ZpbHRlci4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMudGV4dHVyZS5tYWdGaWx0ZXI7XFxuXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5tYWdGaWx0ZXIgaXMgbm93IC50ZXh0dXJlLm1hZ0ZpbHRlci4nICk7XFxuXFx0XFx0XFx0XFx0dGhpcy50ZXh0dXJlLm1hZ0ZpbHRlciA9IHZhbHVlO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdG1pbkZpbHRlcjoge1xcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAubWluRmlsdGVyIGlzIG5vdyAudGV4dHVyZS5taW5GaWx0ZXIuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnRleHR1cmUubWluRmlsdGVyO1xcblxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAubWluRmlsdGVyIGlzIG5vdyAudGV4dHVyZS5taW5GaWx0ZXIuJyApO1xcblxcdFxcdFxcdFxcdHRoaXMudGV4dHVyZS5taW5GaWx0ZXIgPSB2YWx1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHRhbmlzb3Ryb3B5OiB7XFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5hbmlzb3Ryb3B5IGlzIG5vdyAudGV4dHVyZS5hbmlzb3Ryb3B5LicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy50ZXh0dXJlLmFuaXNvdHJvcHk7XFxuXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5hbmlzb3Ryb3B5IGlzIG5vdyAudGV4dHVyZS5hbmlzb3Ryb3B5LicgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLnRleHR1cmUuYW5pc290cm9weSA9IHZhbHVlO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdG9mZnNldDoge1xcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAub2Zmc2V0IGlzIG5vdyAudGV4dHVyZS5vZmZzZXQuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnRleHR1cmUub2Zmc2V0O1xcblxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAub2Zmc2V0IGlzIG5vdyAudGV4dHVyZS5vZmZzZXQuJyApO1xcblxcdFxcdFxcdFxcdHRoaXMudGV4dHVyZS5vZmZzZXQgPSB2YWx1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHRyZXBlYXQ6IHtcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLnJlcGVhdCBpcyBub3cgLnRleHR1cmUucmVwZWF0LicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy50ZXh0dXJlLnJlcGVhdDtcXG5cXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLnJlcGVhdCBpcyBub3cgLnRleHR1cmUucmVwZWF0LicgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLnRleHR1cmUucmVwZWF0ID0gdmFsdWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0Zm9ybWF0OiB7XFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5mb3JtYXQgaXMgbm93IC50ZXh0dXJlLmZvcm1hdC4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMudGV4dHVyZS5mb3JtYXQ7XFxuXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5mb3JtYXQgaXMgbm93IC50ZXh0dXJlLmZvcm1hdC4nICk7XFxuXFx0XFx0XFx0XFx0dGhpcy50ZXh0dXJlLmZvcm1hdCA9IHZhbHVlO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdHR5cGU6IHtcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLnR5cGUgaXMgbm93IC50ZXh0dXJlLnR5cGUuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnRleHR1cmUudHlwZTtcXG5cXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLnR5cGUgaXMgbm93IC50ZXh0dXJlLnR5cGUuJyApO1xcblxcdFxcdFxcdFxcdHRoaXMudGV4dHVyZS50eXBlID0gdmFsdWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0Z2VuZXJhdGVNaXBtYXBzOiB7XFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5nZW5lcmF0ZU1pcG1hcHMgaXMgbm93IC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcy4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM7XFxuXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5nZW5lcmF0ZU1pcG1hcHMgaXMgbm93IC50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcy4nICk7XFxuXFx0XFx0XFx0XFx0dGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IHZhbHVlO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8vXFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggV2ViVlJNYW5hZ2VyLnByb3RvdHlwZSwge1xcblxcblxcdFxcdGdldFN0YW5kaW5nTWF0cml4OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViVlJNYW5hZ2VyOiAuZ2V0U3RhbmRpbmdNYXRyaXgoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBXZWJWUk1hbmFnZXIucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0c3RhbmRpbmc6IHtcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggLyogdmFsdWUgKi8gKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViVlJNYW5hZ2VyOiAuc3RhbmRpbmcgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0Ly9cXG5cXG5cXHRBdWRpby5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICggZmlsZSApIHtcXG5cXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogLmxvYWQgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIFRIUkVFLkF1ZGlvTG9hZGVyIGluc3RlYWQuJyApO1xcblxcdFxcdHZhciBzY29wZSA9IHRoaXM7XFxuXFx0XFx0dmFyIGF1ZGlvTG9hZGVyID0gbmV3IEF1ZGlvTG9hZGVyKCk7XFxuXFx0XFx0YXVkaW9Mb2FkZXIubG9hZCggZmlsZSwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XFxuXFxuXFx0XFx0XFx0c2NvcGUuc2V0QnVmZmVyKCBidWZmZXIgKTtcXG5cXG5cXHRcXHR9ICk7XFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0fTtcXG5cXG5cXHRBdWRpb0FuYWx5c2VyLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvQW5hbHlzZXI6IC5nZXREYXRhKCkgaXMgbm93IC5nZXRGcmVxdWVuY3lEYXRhKCkuJyApO1xcblxcdFxcdHJldHVybiB0aGlzLmdldEZyZXF1ZW5jeURhdGEoKTtcXG5cXG5cXHR9O1xcblxcblxcdC8vXFxuXFxuXFx0Q3ViZUNhbWVyYS5wcm90b3R5cGUudXBkYXRlQ3ViZU1hcCA9IGZ1bmN0aW9uICggcmVuZGVyZXIsIHNjZW5lICkge1xcblxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkN1YmVDYW1lcmE6IC51cGRhdGVDdWJlTWFwKCkgaXMgbm93IC51cGRhdGUoKS4nICk7XFxuXFx0XFx0cmV0dXJuIHRoaXMudXBkYXRlKCByZW5kZXJlciwgc2NlbmUgKTtcXG5cXG5cXHR9O1xcblxcblxcdC8vXFxuXFxuXFx0dmFyIEdlb21ldHJ5VXRpbHMgPSB7XFxuXFxuXFx0XFx0bWVyZ2U6IGZ1bmN0aW9uICggZ2VvbWV0cnkxLCBnZW9tZXRyeTIsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR2VvbWV0cnlVdGlsczogLm1lcmdlKCkgaGFzIGJlZW4gbW92ZWQgdG8gR2VvbWV0cnkuIFVzZSBnZW9tZXRyeS5tZXJnZSggZ2VvbWV0cnkyLCBtYXRyaXgsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKSBpbnN0ZWFkLicgKTtcXG5cXHRcXHRcXHR2YXIgbWF0cml4O1xcblxcblxcdFxcdFxcdGlmICggZ2VvbWV0cnkyLmlzTWVzaCApIHtcXG5cXG5cXHRcXHRcXHRcXHRnZW9tZXRyeTIubWF0cml4QXV0b1VwZGF0ZSAmJiBnZW9tZXRyeTIudXBkYXRlTWF0cml4KCk7XFxuXFxuXFx0XFx0XFx0XFx0bWF0cml4ID0gZ2VvbWV0cnkyLm1hdHJpeDtcXG5cXHRcXHRcXHRcXHRnZW9tZXRyeTIgPSBnZW9tZXRyeTIuZ2VvbWV0cnk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGdlb21ldHJ5MS5tZXJnZSggZ2VvbWV0cnkyLCBtYXRyaXgsIG1hdGVyaWFsSW5kZXhPZmZzZXQgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNlbnRlcjogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5HZW9tZXRyeVV0aWxzOiAuY2VudGVyKCkgaGFzIGJlZW4gbW92ZWQgdG8gR2VvbWV0cnkuIFVzZSBnZW9tZXRyeS5jZW50ZXIoKSBpbnN0ZWFkLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gZ2VvbWV0cnkuY2VudGVyKCk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH07XFxuXFxuXFx0dmFyIEltYWdlVXRpbHMgPSB7XFxuXFxuXFx0XFx0Y3Jvc3NPcmlnaW46IHVuZGVmaW5lZCxcXG5cXG5cXHRcXHRsb2FkVGV4dHVyZTogZnVuY3Rpb24gKCB1cmwsIG1hcHBpbmcsIG9uTG9hZCwgb25FcnJvciApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5JbWFnZVV0aWxzLmxvYWRUZXh0dXJlIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBUSFJFRS5UZXh0dXJlTG9hZGVyKCkgaW5zdGVhZC4nICk7XFxuXFxuXFx0XFx0XFx0dmFyIGxvYWRlciA9IG5ldyBUZXh0dXJlTG9hZGVyKCk7XFxuXFx0XFx0XFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XFxuXFxuXFx0XFx0XFx0dmFyIHRleHR1cmUgPSBsb2FkZXIubG9hZCggdXJsLCBvbkxvYWQsIHVuZGVmaW5lZCwgb25FcnJvciApO1xcblxcblxcdFxcdFxcdGlmICggbWFwcGluZyApIHRleHR1cmUubWFwcGluZyA9IG1hcHBpbmc7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRleHR1cmU7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRsb2FkVGV4dHVyZUN1YmU6IGZ1bmN0aW9uICggdXJscywgbWFwcGluZywgb25Mb2FkLCBvbkVycm9yICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmVDdWJlIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBUSFJFRS5DdWJlVGV4dHVyZUxvYWRlcigpIGluc3RlYWQuJyApO1xcblxcblxcdFxcdFxcdHZhciBsb2FkZXIgPSBuZXcgQ3ViZVRleHR1cmVMb2FkZXIoKTtcXG5cXHRcXHRcXHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcXG5cXG5cXHRcXHRcXHR2YXIgdGV4dHVyZSA9IGxvYWRlci5sb2FkKCB1cmxzLCBvbkxvYWQsIHVuZGVmaW5lZCwgb25FcnJvciApO1xcblxcblxcdFxcdFxcdGlmICggbWFwcGluZyApIHRleHR1cmUubWFwcGluZyA9IG1hcHBpbmc7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRleHR1cmU7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRsb2FkQ29tcHJlc3NlZFRleHR1cmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkQ29tcHJlc3NlZFRleHR1cmUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkREU0xvYWRlciBpbnN0ZWFkLicgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGxvYWRDb21wcmVzc2VkVGV4dHVyZUN1YmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkQ29tcHJlc3NlZFRleHR1cmVDdWJlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5ERFNMb2FkZXIgaW5zdGVhZC4nICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH07XFxuXFxuXFx0Ly9cXG5cXG5cXHRmdW5jdGlvbiBQcm9qZWN0b3IoKSB7XFxuXFxuXFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb2plY3RvciBoYXMgYmVlbiBtb3ZlZCB0byAvZXhhbXBsZXMvanMvcmVuZGVyZXJzL1Byb2plY3Rvci5qcy4nICk7XFxuXFxuXFx0XFx0dGhpcy5wcm9qZWN0VmVjdG9yID0gZnVuY3Rpb24gKCB2ZWN0b3IsIGNhbWVyYSApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5Qcm9qZWN0b3I6IC5wcm9qZWN0VmVjdG9yKCkgaXMgbm93IHZlY3Rvci5wcm9qZWN0KCkuJyApO1xcblxcdFxcdFxcdHZlY3Rvci5wcm9qZWN0KCBjYW1lcmEgKTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMudW5wcm9qZWN0VmVjdG9yID0gZnVuY3Rpb24gKCB2ZWN0b3IsIGNhbWVyYSApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5Qcm9qZWN0b3I6IC51bnByb2plY3RWZWN0b3IoKSBpcyBub3cgdmVjdG9yLnVucHJvamVjdCgpLicgKTtcXG5cXHRcXHRcXHR2ZWN0b3IudW5wcm9qZWN0KCBjYW1lcmEgKTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMucGlja2luZ1JheSA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvamVjdG9yOiAucGlja2luZ1JheSgpIGlzIG5vdyByYXljYXN0ZXIuc2V0RnJvbUNhbWVyYSgpLicgKTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdH1cXG5cXG5cXHQvL1xcblxcblxcdGZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyKCkge1xcblxcblxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5DYW52YXNSZW5kZXJlciBoYXMgYmVlbiBtb3ZlZCB0byAvZXhhbXBsZXMvanMvcmVuZGVyZXJzL0NhbnZhc1JlbmRlcmVyLmpzJyApO1xcblxcblxcdFxcdHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCAnY2FudmFzJyApO1xcblxcdFxcdHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoKSB7fTtcXG5cXHRcXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICgpIHt9O1xcblxcdFxcdHRoaXMuc2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uICgpIHt9O1xcblxcdFxcdHRoaXMuc2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHt9O1xcblxcblxcdH1cXG5cXG5cXHRleHBvcnRzLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSA9IFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZTtcXG5cXHRleHBvcnRzLldlYkdMUmVuZGVyVGFyZ2V0ID0gV2ViR0xSZW5kZXJUYXJnZXQ7XFxuXFx0ZXhwb3J0cy5XZWJHTFJlbmRlcmVyID0gV2ViR0xSZW5kZXJlcjtcXG5cXHRleHBvcnRzLlNoYWRlckxpYiA9IFNoYWRlckxpYjtcXG5cXHRleHBvcnRzLlVuaWZvcm1zTGliID0gVW5pZm9ybXNMaWI7XFxuXFx0ZXhwb3J0cy5Vbmlmb3Jtc1V0aWxzID0gVW5pZm9ybXNVdGlscztcXG5cXHRleHBvcnRzLlNoYWRlckNodW5rID0gU2hhZGVyQ2h1bms7XFxuXFx0ZXhwb3J0cy5Gb2dFeHAyID0gRm9nRXhwMjtcXG5cXHRleHBvcnRzLkZvZyA9IEZvZztcXG5cXHRleHBvcnRzLlNjZW5lID0gU2NlbmU7XFxuXFx0ZXhwb3J0cy5MZW5zRmxhcmUgPSBMZW5zRmxhcmU7XFxuXFx0ZXhwb3J0cy5TcHJpdGUgPSBTcHJpdGU7XFxuXFx0ZXhwb3J0cy5MT0QgPSBMT0Q7XFxuXFx0ZXhwb3J0cy5Ta2lubmVkTWVzaCA9IFNraW5uZWRNZXNoO1xcblxcdGV4cG9ydHMuU2tlbGV0b24gPSBTa2VsZXRvbjtcXG5cXHRleHBvcnRzLkJvbmUgPSBCb25lO1xcblxcdGV4cG9ydHMuTWVzaCA9IE1lc2g7XFxuXFx0ZXhwb3J0cy5MaW5lU2VnbWVudHMgPSBMaW5lU2VnbWVudHM7XFxuXFx0ZXhwb3J0cy5MaW5lTG9vcCA9IExpbmVMb29wO1xcblxcdGV4cG9ydHMuTGluZSA9IExpbmU7XFxuXFx0ZXhwb3J0cy5Qb2ludHMgPSBQb2ludHM7XFxuXFx0ZXhwb3J0cy5Hcm91cCA9IEdyb3VwO1xcblxcdGV4cG9ydHMuVmlkZW9UZXh0dXJlID0gVmlkZW9UZXh0dXJlO1xcblxcdGV4cG9ydHMuRGF0YVRleHR1cmUgPSBEYXRhVGV4dHVyZTtcXG5cXHRleHBvcnRzLkNvbXByZXNzZWRUZXh0dXJlID0gQ29tcHJlc3NlZFRleHR1cmU7XFxuXFx0ZXhwb3J0cy5DdWJlVGV4dHVyZSA9IEN1YmVUZXh0dXJlO1xcblxcdGV4cG9ydHMuQ2FudmFzVGV4dHVyZSA9IENhbnZhc1RleHR1cmU7XFxuXFx0ZXhwb3J0cy5EZXB0aFRleHR1cmUgPSBEZXB0aFRleHR1cmU7XFxuXFx0ZXhwb3J0cy5UZXh0dXJlID0gVGV4dHVyZTtcXG5cXHRleHBvcnRzLkNvbXByZXNzZWRUZXh0dXJlTG9hZGVyID0gQ29tcHJlc3NlZFRleHR1cmVMb2FkZXI7XFxuXFx0ZXhwb3J0cy5EYXRhVGV4dHVyZUxvYWRlciA9IERhdGFUZXh0dXJlTG9hZGVyO1xcblxcdGV4cG9ydHMuQ3ViZVRleHR1cmVMb2FkZXIgPSBDdWJlVGV4dHVyZUxvYWRlcjtcXG5cXHRleHBvcnRzLlRleHR1cmVMb2FkZXIgPSBUZXh0dXJlTG9hZGVyO1xcblxcdGV4cG9ydHMuT2JqZWN0TG9hZGVyID0gT2JqZWN0TG9hZGVyO1xcblxcdGV4cG9ydHMuTWF0ZXJpYWxMb2FkZXIgPSBNYXRlcmlhbExvYWRlcjtcXG5cXHRleHBvcnRzLkJ1ZmZlckdlb21ldHJ5TG9hZGVyID0gQnVmZmVyR2VvbWV0cnlMb2FkZXI7XFxuXFx0ZXhwb3J0cy5EZWZhdWx0TG9hZGluZ01hbmFnZXIgPSBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XFxuXFx0ZXhwb3J0cy5Mb2FkaW5nTWFuYWdlciA9IExvYWRpbmdNYW5hZ2VyO1xcblxcdGV4cG9ydHMuSlNPTkxvYWRlciA9IEpTT05Mb2FkZXI7XFxuXFx0ZXhwb3J0cy5JbWFnZUxvYWRlciA9IEltYWdlTG9hZGVyO1xcblxcdGV4cG9ydHMuSW1hZ2VCaXRtYXBMb2FkZXIgPSBJbWFnZUJpdG1hcExvYWRlcjtcXG5cXHRleHBvcnRzLkZvbnRMb2FkZXIgPSBGb250TG9hZGVyO1xcblxcdGV4cG9ydHMuRmlsZUxvYWRlciA9IEZpbGVMb2FkZXI7XFxuXFx0ZXhwb3J0cy5Mb2FkZXIgPSBMb2FkZXI7XFxuXFx0ZXhwb3J0cy5Mb2FkZXJVdGlscyA9IExvYWRlclV0aWxzO1xcblxcdGV4cG9ydHMuQ2FjaGUgPSBDYWNoZTtcXG5cXHRleHBvcnRzLkF1ZGlvTG9hZGVyID0gQXVkaW9Mb2FkZXI7XFxuXFx0ZXhwb3J0cy5TcG90TGlnaHRTaGFkb3cgPSBTcG90TGlnaHRTaGFkb3c7XFxuXFx0ZXhwb3J0cy5TcG90TGlnaHQgPSBTcG90TGlnaHQ7XFxuXFx0ZXhwb3J0cy5Qb2ludExpZ2h0ID0gUG9pbnRMaWdodDtcXG5cXHRleHBvcnRzLlJlY3RBcmVhTGlnaHQgPSBSZWN0QXJlYUxpZ2h0O1xcblxcdGV4cG9ydHMuSGVtaXNwaGVyZUxpZ2h0ID0gSGVtaXNwaGVyZUxpZ2h0O1xcblxcdGV4cG9ydHMuRGlyZWN0aW9uYWxMaWdodFNoYWRvdyA9IERpcmVjdGlvbmFsTGlnaHRTaGFkb3c7XFxuXFx0ZXhwb3J0cy5EaXJlY3Rpb25hbExpZ2h0ID0gRGlyZWN0aW9uYWxMaWdodDtcXG5cXHRleHBvcnRzLkFtYmllbnRMaWdodCA9IEFtYmllbnRMaWdodDtcXG5cXHRleHBvcnRzLkxpZ2h0U2hhZG93ID0gTGlnaHRTaGFkb3c7XFxuXFx0ZXhwb3J0cy5MaWdodCA9IExpZ2h0O1xcblxcdGV4cG9ydHMuU3RlcmVvQ2FtZXJhID0gU3RlcmVvQ2FtZXJhO1xcblxcdGV4cG9ydHMuUGVyc3BlY3RpdmVDYW1lcmEgPSBQZXJzcGVjdGl2ZUNhbWVyYTtcXG5cXHRleHBvcnRzLk9ydGhvZ3JhcGhpY0NhbWVyYSA9IE9ydGhvZ3JhcGhpY0NhbWVyYTtcXG5cXHRleHBvcnRzLkN1YmVDYW1lcmEgPSBDdWJlQ2FtZXJhO1xcblxcdGV4cG9ydHMuQXJyYXlDYW1lcmEgPSBBcnJheUNhbWVyYTtcXG5cXHRleHBvcnRzLkNhbWVyYSA9IENhbWVyYTtcXG5cXHRleHBvcnRzLkF1ZGlvTGlzdGVuZXIgPSBBdWRpb0xpc3RlbmVyO1xcblxcdGV4cG9ydHMuUG9zaXRpb25hbEF1ZGlvID0gUG9zaXRpb25hbEF1ZGlvO1xcblxcdGV4cG9ydHMuQXVkaW9Db250ZXh0ID0gQXVkaW9Db250ZXh0O1xcblxcdGV4cG9ydHMuQXVkaW9BbmFseXNlciA9IEF1ZGlvQW5hbHlzZXI7XFxuXFx0ZXhwb3J0cy5BdWRpbyA9IEF1ZGlvO1xcblxcdGV4cG9ydHMuVmVjdG9yS2V5ZnJhbWVUcmFjayA9IFZlY3RvcktleWZyYW1lVHJhY2s7XFxuXFx0ZXhwb3J0cy5TdHJpbmdLZXlmcmFtZVRyYWNrID0gU3RyaW5nS2V5ZnJhbWVUcmFjaztcXG5cXHRleHBvcnRzLlF1YXRlcm5pb25LZXlmcmFtZVRyYWNrID0gUXVhdGVybmlvbktleWZyYW1lVHJhY2s7XFxuXFx0ZXhwb3J0cy5OdW1iZXJLZXlmcmFtZVRyYWNrID0gTnVtYmVyS2V5ZnJhbWVUcmFjaztcXG5cXHRleHBvcnRzLkNvbG9yS2V5ZnJhbWVUcmFjayA9IENvbG9yS2V5ZnJhbWVUcmFjaztcXG5cXHRleHBvcnRzLkJvb2xlYW5LZXlmcmFtZVRyYWNrID0gQm9vbGVhbktleWZyYW1lVHJhY2s7XFxuXFx0ZXhwb3J0cy5Qcm9wZXJ0eU1peGVyID0gUHJvcGVydHlNaXhlcjtcXG5cXHRleHBvcnRzLlByb3BlcnR5QmluZGluZyA9IFByb3BlcnR5QmluZGluZztcXG5cXHRleHBvcnRzLktleWZyYW1lVHJhY2sgPSBLZXlmcmFtZVRyYWNrO1xcblxcdGV4cG9ydHMuQW5pbWF0aW9uVXRpbHMgPSBBbmltYXRpb25VdGlscztcXG5cXHRleHBvcnRzLkFuaW1hdGlvbk9iamVjdEdyb3VwID0gQW5pbWF0aW9uT2JqZWN0R3JvdXA7XFxuXFx0ZXhwb3J0cy5BbmltYXRpb25NaXhlciA9IEFuaW1hdGlvbk1peGVyO1xcblxcdGV4cG9ydHMuQW5pbWF0aW9uQ2xpcCA9IEFuaW1hdGlvbkNsaXA7XFxuXFx0ZXhwb3J0cy5Vbmlmb3JtID0gVW5pZm9ybTtcXG5cXHRleHBvcnRzLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ID0gSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5CdWZmZXJHZW9tZXRyeSA9IEJ1ZmZlckdlb21ldHJ5O1xcblxcdGV4cG9ydHMuR2VvbWV0cnkgPSBHZW9tZXRyeTtcXG5cXHRleHBvcnRzLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlID0gSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGU7XFxuXFx0ZXhwb3J0cy5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciA9IEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyO1xcblxcdGV4cG9ydHMuSW50ZXJsZWF2ZWRCdWZmZXIgPSBJbnRlcmxlYXZlZEJ1ZmZlcjtcXG5cXHRleHBvcnRzLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSA9IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZTtcXG5cXHRleHBvcnRzLkZhY2UzID0gRmFjZTM7XFxuXFx0ZXhwb3J0cy5PYmplY3QzRCA9IE9iamVjdDNEO1xcblxcdGV4cG9ydHMuUmF5Y2FzdGVyID0gUmF5Y2FzdGVyO1xcblxcdGV4cG9ydHMuTGF5ZXJzID0gTGF5ZXJzO1xcblxcdGV4cG9ydHMuRXZlbnREaXNwYXRjaGVyID0gRXZlbnREaXNwYXRjaGVyO1xcblxcdGV4cG9ydHMuQ2xvY2sgPSBDbG9jaztcXG5cXHRleHBvcnRzLlF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudCA9IFF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudDtcXG5cXHRleHBvcnRzLkxpbmVhckludGVycG9sYW50ID0gTGluZWFySW50ZXJwb2xhbnQ7XFxuXFx0ZXhwb3J0cy5EaXNjcmV0ZUludGVycG9sYW50ID0gRGlzY3JldGVJbnRlcnBvbGFudDtcXG5cXHRleHBvcnRzLkN1YmljSW50ZXJwb2xhbnQgPSBDdWJpY0ludGVycG9sYW50O1xcblxcdGV4cG9ydHMuSW50ZXJwb2xhbnQgPSBJbnRlcnBvbGFudDtcXG5cXHRleHBvcnRzLlRyaWFuZ2xlID0gVHJpYW5nbGU7XFxuXFx0ZXhwb3J0cy5NYXRoID0gX01hdGg7XFxuXFx0ZXhwb3J0cy5TcGhlcmljYWwgPSBTcGhlcmljYWw7XFxuXFx0ZXhwb3J0cy5DeWxpbmRyaWNhbCA9IEN5bGluZHJpY2FsO1xcblxcdGV4cG9ydHMuUGxhbmUgPSBQbGFuZTtcXG5cXHRleHBvcnRzLkZydXN0dW0gPSBGcnVzdHVtO1xcblxcdGV4cG9ydHMuU3BoZXJlID0gU3BoZXJlO1xcblxcdGV4cG9ydHMuUmF5ID0gUmF5O1xcblxcdGV4cG9ydHMuTWF0cml4NCA9IE1hdHJpeDQ7XFxuXFx0ZXhwb3J0cy5NYXRyaXgzID0gTWF0cml4MztcXG5cXHRleHBvcnRzLkJveDMgPSBCb3gzO1xcblxcdGV4cG9ydHMuQm94MiA9IEJveDI7XFxuXFx0ZXhwb3J0cy5MaW5lMyA9IExpbmUzO1xcblxcdGV4cG9ydHMuRXVsZXIgPSBFdWxlcjtcXG5cXHRleHBvcnRzLlZlY3RvcjQgPSBWZWN0b3I0O1xcblxcdGV4cG9ydHMuVmVjdG9yMyA9IFZlY3RvcjM7XFxuXFx0ZXhwb3J0cy5WZWN0b3IyID0gVmVjdG9yMjtcXG5cXHRleHBvcnRzLlF1YXRlcm5pb24gPSBRdWF0ZXJuaW9uO1xcblxcdGV4cG9ydHMuQ29sb3IgPSBDb2xvcjtcXG5cXHRleHBvcnRzLkltbWVkaWF0ZVJlbmRlck9iamVjdCA9IEltbWVkaWF0ZVJlbmRlck9iamVjdDtcXG5cXHRleHBvcnRzLlZlcnRleE5vcm1hbHNIZWxwZXIgPSBWZXJ0ZXhOb3JtYWxzSGVscGVyO1xcblxcdGV4cG9ydHMuU3BvdExpZ2h0SGVscGVyID0gU3BvdExpZ2h0SGVscGVyO1xcblxcdGV4cG9ydHMuU2tlbGV0b25IZWxwZXIgPSBTa2VsZXRvbkhlbHBlcjtcXG5cXHRleHBvcnRzLlBvaW50TGlnaHRIZWxwZXIgPSBQb2ludExpZ2h0SGVscGVyO1xcblxcdGV4cG9ydHMuUmVjdEFyZWFMaWdodEhlbHBlciA9IFJlY3RBcmVhTGlnaHRIZWxwZXI7XFxuXFx0ZXhwb3J0cy5IZW1pc3BoZXJlTGlnaHRIZWxwZXIgPSBIZW1pc3BoZXJlTGlnaHRIZWxwZXI7XFxuXFx0ZXhwb3J0cy5HcmlkSGVscGVyID0gR3JpZEhlbHBlcjtcXG5cXHRleHBvcnRzLlBvbGFyR3JpZEhlbHBlciA9IFBvbGFyR3JpZEhlbHBlcjtcXG5cXHRleHBvcnRzLkZhY2VOb3JtYWxzSGVscGVyID0gRmFjZU5vcm1hbHNIZWxwZXI7XFxuXFx0ZXhwb3J0cy5EaXJlY3Rpb25hbExpZ2h0SGVscGVyID0gRGlyZWN0aW9uYWxMaWdodEhlbHBlcjtcXG5cXHRleHBvcnRzLkNhbWVyYUhlbHBlciA9IENhbWVyYUhlbHBlcjtcXG5cXHRleHBvcnRzLkJveEhlbHBlciA9IEJveEhlbHBlcjtcXG5cXHRleHBvcnRzLkJveDNIZWxwZXIgPSBCb3gzSGVscGVyO1xcblxcdGV4cG9ydHMuUGxhbmVIZWxwZXIgPSBQbGFuZUhlbHBlcjtcXG5cXHRleHBvcnRzLkFycm93SGVscGVyID0gQXJyb3dIZWxwZXI7XFxuXFx0ZXhwb3J0cy5BeGVzSGVscGVyID0gQXhlc0hlbHBlcjtcXG5cXHRleHBvcnRzLlNoYXBlID0gU2hhcGU7XFxuXFx0ZXhwb3J0cy5QYXRoID0gUGF0aDtcXG5cXHRleHBvcnRzLlNoYXBlUGF0aCA9IFNoYXBlUGF0aDtcXG5cXHRleHBvcnRzLkZvbnQgPSBGb250O1xcblxcdGV4cG9ydHMuQ3VydmVQYXRoID0gQ3VydmVQYXRoO1xcblxcdGV4cG9ydHMuQ3VydmUgPSBDdXJ2ZTtcXG5cXHRleHBvcnRzLlNoYXBlVXRpbHMgPSBTaGFwZVV0aWxzO1xcblxcdGV4cG9ydHMuU2NlbmVVdGlscyA9IFNjZW5lVXRpbHM7XFxuXFx0ZXhwb3J0cy5XZWJHTFV0aWxzID0gV2ViR0xVdGlscztcXG5cXHRleHBvcnRzLldpcmVmcmFtZUdlb21ldHJ5ID0gV2lyZWZyYW1lR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5QYXJhbWV0cmljR2VvbWV0cnkgPSBQYXJhbWV0cmljR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5QYXJhbWV0cmljQnVmZmVyR2VvbWV0cnkgPSBQYXJhbWV0cmljQnVmZmVyR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5UZXRyYWhlZHJvbkdlb21ldHJ5ID0gVGV0cmFoZWRyb25HZW9tZXRyeTtcXG5cXHRleHBvcnRzLlRldHJhaGVkcm9uQnVmZmVyR2VvbWV0cnkgPSBUZXRyYWhlZHJvbkJ1ZmZlckdlb21ldHJ5O1xcblxcdGV4cG9ydHMuT2N0YWhlZHJvbkdlb21ldHJ5ID0gT2N0YWhlZHJvbkdlb21ldHJ5O1xcblxcdGV4cG9ydHMuT2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5ID0gT2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5O1xcblxcdGV4cG9ydHMuSWNvc2FoZWRyb25HZW9tZXRyeSA9IEljb3NhaGVkcm9uR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5JY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5ID0gSWNvc2FoZWRyb25CdWZmZXJHZW9tZXRyeTtcXG5cXHRleHBvcnRzLkRvZGVjYWhlZHJvbkdlb21ldHJ5ID0gRG9kZWNhaGVkcm9uR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5Eb2RlY2FoZWRyb25CdWZmZXJHZW9tZXRyeSA9IERvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5O1xcblxcdGV4cG9ydHMuUG9seWhlZHJvbkdlb21ldHJ5ID0gUG9seWhlZHJvbkdlb21ldHJ5O1xcblxcdGV4cG9ydHMuUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5ID0gUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5O1xcblxcdGV4cG9ydHMuVHViZUdlb21ldHJ5ID0gVHViZUdlb21ldHJ5O1xcblxcdGV4cG9ydHMuVHViZUJ1ZmZlckdlb21ldHJ5ID0gVHViZUJ1ZmZlckdlb21ldHJ5O1xcblxcdGV4cG9ydHMuVG9ydXNLbm90R2VvbWV0cnkgPSBUb3J1c0tub3RHZW9tZXRyeTtcXG5cXHRleHBvcnRzLlRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5ID0gVG9ydXNLbm90QnVmZmVyR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5Ub3J1c0dlb21ldHJ5ID0gVG9ydXNHZW9tZXRyeTtcXG5cXHRleHBvcnRzLlRvcnVzQnVmZmVyR2VvbWV0cnkgPSBUb3J1c0J1ZmZlckdlb21ldHJ5O1xcblxcdGV4cG9ydHMuVGV4dEdlb21ldHJ5ID0gVGV4dEdlb21ldHJ5O1xcblxcdGV4cG9ydHMuVGV4dEJ1ZmZlckdlb21ldHJ5ID0gVGV4dEJ1ZmZlckdlb21ldHJ5O1xcblxcdGV4cG9ydHMuU3BoZXJlR2VvbWV0cnkgPSBTcGhlcmVHZW9tZXRyeTtcXG5cXHRleHBvcnRzLlNwaGVyZUJ1ZmZlckdlb21ldHJ5ID0gU3BoZXJlQnVmZmVyR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5SaW5nR2VvbWV0cnkgPSBSaW5nR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5SaW5nQnVmZmVyR2VvbWV0cnkgPSBSaW5nQnVmZmVyR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5QbGFuZUdlb21ldHJ5ID0gUGxhbmVHZW9tZXRyeTtcXG5cXHRleHBvcnRzLlBsYW5lQnVmZmVyR2VvbWV0cnkgPSBQbGFuZUJ1ZmZlckdlb21ldHJ5O1xcblxcdGV4cG9ydHMuTGF0aGVHZW9tZXRyeSA9IExhdGhlR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5MYXRoZUJ1ZmZlckdlb21ldHJ5ID0gTGF0aGVCdWZmZXJHZW9tZXRyeTtcXG5cXHRleHBvcnRzLlNoYXBlR2VvbWV0cnkgPSBTaGFwZUdlb21ldHJ5O1xcblxcdGV4cG9ydHMuU2hhcGVCdWZmZXJHZW9tZXRyeSA9IFNoYXBlQnVmZmVyR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5FeHRydWRlR2VvbWV0cnkgPSBFeHRydWRlR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5FeHRydWRlQnVmZmVyR2VvbWV0cnkgPSBFeHRydWRlQnVmZmVyR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5FZGdlc0dlb21ldHJ5ID0gRWRnZXNHZW9tZXRyeTtcXG5cXHRleHBvcnRzLkNvbmVHZW9tZXRyeSA9IENvbmVHZW9tZXRyeTtcXG5cXHRleHBvcnRzLkNvbmVCdWZmZXJHZW9tZXRyeSA9IENvbmVCdWZmZXJHZW9tZXRyeTtcXG5cXHRleHBvcnRzLkN5bGluZGVyR2VvbWV0cnkgPSBDeWxpbmRlckdlb21ldHJ5O1xcblxcdGV4cG9ydHMuQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeSA9IEN5bGluZGVyQnVmZmVyR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5DaXJjbGVHZW9tZXRyeSA9IENpcmNsZUdlb21ldHJ5O1xcblxcdGV4cG9ydHMuQ2lyY2xlQnVmZmVyR2VvbWV0cnkgPSBDaXJjbGVCdWZmZXJHZW9tZXRyeTtcXG5cXHRleHBvcnRzLkJveEdlb21ldHJ5ID0gQm94R2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5Cb3hCdWZmZXJHZW9tZXRyeSA9IEJveEJ1ZmZlckdlb21ldHJ5O1xcblxcdGV4cG9ydHMuU2hhZG93TWF0ZXJpYWwgPSBTaGFkb3dNYXRlcmlhbDtcXG5cXHRleHBvcnRzLlNwcml0ZU1hdGVyaWFsID0gU3ByaXRlTWF0ZXJpYWw7XFxuXFx0ZXhwb3J0cy5SYXdTaGFkZXJNYXRlcmlhbCA9IFJhd1NoYWRlck1hdGVyaWFsO1xcblxcdGV4cG9ydHMuU2hhZGVyTWF0ZXJpYWwgPSBTaGFkZXJNYXRlcmlhbDtcXG5cXHRleHBvcnRzLlBvaW50c01hdGVyaWFsID0gUG9pbnRzTWF0ZXJpYWw7XFxuXFx0ZXhwb3J0cy5NZXNoUGh5c2ljYWxNYXRlcmlhbCA9IE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xcblxcdGV4cG9ydHMuTWVzaFN0YW5kYXJkTWF0ZXJpYWwgPSBNZXNoU3RhbmRhcmRNYXRlcmlhbDtcXG5cXHRleHBvcnRzLk1lc2hQaG9uZ01hdGVyaWFsID0gTWVzaFBob25nTWF0ZXJpYWw7XFxuXFx0ZXhwb3J0cy5NZXNoVG9vbk1hdGVyaWFsID0gTWVzaFRvb25NYXRlcmlhbDtcXG5cXHRleHBvcnRzLk1lc2hOb3JtYWxNYXRlcmlhbCA9IE1lc2hOb3JtYWxNYXRlcmlhbDtcXG5cXHRleHBvcnRzLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgPSBNZXNoTGFtYmVydE1hdGVyaWFsO1xcblxcdGV4cG9ydHMuTWVzaERlcHRoTWF0ZXJpYWwgPSBNZXNoRGVwdGhNYXRlcmlhbDtcXG5cXHRleHBvcnRzLk1lc2hEaXN0YW5jZU1hdGVyaWFsID0gTWVzaERpc3RhbmNlTWF0ZXJpYWw7XFxuXFx0ZXhwb3J0cy5NZXNoQmFzaWNNYXRlcmlhbCA9IE1lc2hCYXNpY01hdGVyaWFsO1xcblxcdGV4cG9ydHMuTGluZURhc2hlZE1hdGVyaWFsID0gTGluZURhc2hlZE1hdGVyaWFsO1xcblxcdGV4cG9ydHMuTGluZUJhc2ljTWF0ZXJpYWwgPSBMaW5lQmFzaWNNYXRlcmlhbDtcXG5cXHRleHBvcnRzLk1hdGVyaWFsID0gTWF0ZXJpYWw7XFxuXFx0ZXhwb3J0cy5GbG9hdDY0QnVmZmVyQXR0cmlidXRlID0gRmxvYXQ2NEJ1ZmZlckF0dHJpYnV0ZTtcXG5cXHRleHBvcnRzLkZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUgPSBGbG9hdDMyQnVmZmVyQXR0cmlidXRlO1xcblxcdGV4cG9ydHMuVWludDMyQnVmZmVyQXR0cmlidXRlID0gVWludDMyQnVmZmVyQXR0cmlidXRlO1xcblxcdGV4cG9ydHMuSW50MzJCdWZmZXJBdHRyaWJ1dGUgPSBJbnQzMkJ1ZmZlckF0dHJpYnV0ZTtcXG5cXHRleHBvcnRzLlVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSA9IFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZTtcXG5cXHRleHBvcnRzLkludDE2QnVmZmVyQXR0cmlidXRlID0gSW50MTZCdWZmZXJBdHRyaWJ1dGU7XFxuXFx0ZXhwb3J0cy5VaW50OENsYW1wZWRCdWZmZXJBdHRyaWJ1dGUgPSBVaW50OENsYW1wZWRCdWZmZXJBdHRyaWJ1dGU7XFxuXFx0ZXhwb3J0cy5VaW50OEJ1ZmZlckF0dHJpYnV0ZSA9IFVpbnQ4QnVmZmVyQXR0cmlidXRlO1xcblxcdGV4cG9ydHMuSW50OEJ1ZmZlckF0dHJpYnV0ZSA9IEludDhCdWZmZXJBdHRyaWJ1dGU7XFxuXFx0ZXhwb3J0cy5CdWZmZXJBdHRyaWJ1dGUgPSBCdWZmZXJBdHRyaWJ1dGU7XFxuXFx0ZXhwb3J0cy5BcmNDdXJ2ZSA9IEFyY0N1cnZlO1xcblxcdGV4cG9ydHMuQ2F0bXVsbFJvbUN1cnZlMyA9IENhdG11bGxSb21DdXJ2ZTM7XFxuXFx0ZXhwb3J0cy5DdWJpY0JlemllckN1cnZlID0gQ3ViaWNCZXppZXJDdXJ2ZTtcXG5cXHRleHBvcnRzLkN1YmljQmV6aWVyQ3VydmUzID0gQ3ViaWNCZXppZXJDdXJ2ZTM7XFxuXFx0ZXhwb3J0cy5FbGxpcHNlQ3VydmUgPSBFbGxpcHNlQ3VydmU7XFxuXFx0ZXhwb3J0cy5MaW5lQ3VydmUgPSBMaW5lQ3VydmU7XFxuXFx0ZXhwb3J0cy5MaW5lQ3VydmUzID0gTGluZUN1cnZlMztcXG5cXHRleHBvcnRzLlF1YWRyYXRpY0JlemllckN1cnZlID0gUXVhZHJhdGljQmV6aWVyQ3VydmU7XFxuXFx0ZXhwb3J0cy5RdWFkcmF0aWNCZXppZXJDdXJ2ZTMgPSBRdWFkcmF0aWNCZXppZXJDdXJ2ZTM7XFxuXFx0ZXhwb3J0cy5TcGxpbmVDdXJ2ZSA9IFNwbGluZUN1cnZlO1xcblxcdGV4cG9ydHMuUkVWSVNJT04gPSBSRVZJU0lPTjtcXG5cXHRleHBvcnRzLk1PVVNFID0gTU9VU0U7XFxuXFx0ZXhwb3J0cy5DdWxsRmFjZU5vbmUgPSBDdWxsRmFjZU5vbmU7XFxuXFx0ZXhwb3J0cy5DdWxsRmFjZUJhY2sgPSBDdWxsRmFjZUJhY2s7XFxuXFx0ZXhwb3J0cy5DdWxsRmFjZUZyb250ID0gQ3VsbEZhY2VGcm9udDtcXG5cXHRleHBvcnRzLkN1bGxGYWNlRnJvbnRCYWNrID0gQ3VsbEZhY2VGcm9udEJhY2s7XFxuXFx0ZXhwb3J0cy5Gcm9udEZhY2VEaXJlY3Rpb25DVyA9IEZyb250RmFjZURpcmVjdGlvbkNXO1xcblxcdGV4cG9ydHMuRnJvbnRGYWNlRGlyZWN0aW9uQ0NXID0gRnJvbnRGYWNlRGlyZWN0aW9uQ0NXO1xcblxcdGV4cG9ydHMuQmFzaWNTaGFkb3dNYXAgPSBCYXNpY1NoYWRvd01hcDtcXG5cXHRleHBvcnRzLlBDRlNoYWRvd01hcCA9IFBDRlNoYWRvd01hcDtcXG5cXHRleHBvcnRzLlBDRlNvZnRTaGFkb3dNYXAgPSBQQ0ZTb2Z0U2hhZG93TWFwO1xcblxcdGV4cG9ydHMuRnJvbnRTaWRlID0gRnJvbnRTaWRlO1xcblxcdGV4cG9ydHMuQmFja1NpZGUgPSBCYWNrU2lkZTtcXG5cXHRleHBvcnRzLkRvdWJsZVNpZGUgPSBEb3VibGVTaWRlO1xcblxcdGV4cG9ydHMuRmxhdFNoYWRpbmcgPSBGbGF0U2hhZGluZztcXG5cXHRleHBvcnRzLlNtb290aFNoYWRpbmcgPSBTbW9vdGhTaGFkaW5nO1xcblxcdGV4cG9ydHMuTm9Db2xvcnMgPSBOb0NvbG9ycztcXG5cXHRleHBvcnRzLkZhY2VDb2xvcnMgPSBGYWNlQ29sb3JzO1xcblxcdGV4cG9ydHMuVmVydGV4Q29sb3JzID0gVmVydGV4Q29sb3JzO1xcblxcdGV4cG9ydHMuTm9CbGVuZGluZyA9IE5vQmxlbmRpbmc7XFxuXFx0ZXhwb3J0cy5Ob3JtYWxCbGVuZGluZyA9IE5vcm1hbEJsZW5kaW5nO1xcblxcdGV4cG9ydHMuQWRkaXRpdmVCbGVuZGluZyA9IEFkZGl0aXZlQmxlbmRpbmc7XFxuXFx0ZXhwb3J0cy5TdWJ0cmFjdGl2ZUJsZW5kaW5nID0gU3VidHJhY3RpdmVCbGVuZGluZztcXG5cXHRleHBvcnRzLk11bHRpcGx5QmxlbmRpbmcgPSBNdWx0aXBseUJsZW5kaW5nO1xcblxcdGV4cG9ydHMuQ3VzdG9tQmxlbmRpbmcgPSBDdXN0b21CbGVuZGluZztcXG5cXHRleHBvcnRzLkFkZEVxdWF0aW9uID0gQWRkRXF1YXRpb247XFxuXFx0ZXhwb3J0cy5TdWJ0cmFjdEVxdWF0aW9uID0gU3VidHJhY3RFcXVhdGlvbjtcXG5cXHRleHBvcnRzLlJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uID0gUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb247XFxuXFx0ZXhwb3J0cy5NaW5FcXVhdGlvbiA9IE1pbkVxdWF0aW9uO1xcblxcdGV4cG9ydHMuTWF4RXF1YXRpb24gPSBNYXhFcXVhdGlvbjtcXG5cXHRleHBvcnRzLlplcm9GYWN0b3IgPSBaZXJvRmFjdG9yO1xcblxcdGV4cG9ydHMuT25lRmFjdG9yID0gT25lRmFjdG9yO1xcblxcdGV4cG9ydHMuU3JjQ29sb3JGYWN0b3IgPSBTcmNDb2xvckZhY3RvcjtcXG5cXHRleHBvcnRzLk9uZU1pbnVzU3JjQ29sb3JGYWN0b3IgPSBPbmVNaW51c1NyY0NvbG9yRmFjdG9yO1xcblxcdGV4cG9ydHMuU3JjQWxwaGFGYWN0b3IgPSBTcmNBbHBoYUZhY3RvcjtcXG5cXHRleHBvcnRzLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSBPbmVNaW51c1NyY0FscGhhRmFjdG9yO1xcblxcdGV4cG9ydHMuRHN0QWxwaGFGYWN0b3IgPSBEc3RBbHBoYUZhY3RvcjtcXG5cXHRleHBvcnRzLk9uZU1pbnVzRHN0QWxwaGFGYWN0b3IgPSBPbmVNaW51c0RzdEFscGhhRmFjdG9yO1xcblxcdGV4cG9ydHMuRHN0Q29sb3JGYWN0b3IgPSBEc3RDb2xvckZhY3RvcjtcXG5cXHRleHBvcnRzLk9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgPSBPbmVNaW51c0RzdENvbG9yRmFjdG9yO1xcblxcdGV4cG9ydHMuU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciA9IFNyY0FscGhhU2F0dXJhdGVGYWN0b3I7XFxuXFx0ZXhwb3J0cy5OZXZlckRlcHRoID0gTmV2ZXJEZXB0aDtcXG5cXHRleHBvcnRzLkFsd2F5c0RlcHRoID0gQWx3YXlzRGVwdGg7XFxuXFx0ZXhwb3J0cy5MZXNzRGVwdGggPSBMZXNzRGVwdGg7XFxuXFx0ZXhwb3J0cy5MZXNzRXF1YWxEZXB0aCA9IExlc3NFcXVhbERlcHRoO1xcblxcdGV4cG9ydHMuRXF1YWxEZXB0aCA9IEVxdWFsRGVwdGg7XFxuXFx0ZXhwb3J0cy5HcmVhdGVyRXF1YWxEZXB0aCA9IEdyZWF0ZXJFcXVhbERlcHRoO1xcblxcdGV4cG9ydHMuR3JlYXRlckRlcHRoID0gR3JlYXRlckRlcHRoO1xcblxcdGV4cG9ydHMuTm90RXF1YWxEZXB0aCA9IE5vdEVxdWFsRGVwdGg7XFxuXFx0ZXhwb3J0cy5NdWx0aXBseU9wZXJhdGlvbiA9IE11bHRpcGx5T3BlcmF0aW9uO1xcblxcdGV4cG9ydHMuTWl4T3BlcmF0aW9uID0gTWl4T3BlcmF0aW9uO1xcblxcdGV4cG9ydHMuQWRkT3BlcmF0aW9uID0gQWRkT3BlcmF0aW9uO1xcblxcdGV4cG9ydHMuTm9Ub25lTWFwcGluZyA9IE5vVG9uZU1hcHBpbmc7XFxuXFx0ZXhwb3J0cy5MaW5lYXJUb25lTWFwcGluZyA9IExpbmVhclRvbmVNYXBwaW5nO1xcblxcdGV4cG9ydHMuUmVpbmhhcmRUb25lTWFwcGluZyA9IFJlaW5oYXJkVG9uZU1hcHBpbmc7XFxuXFx0ZXhwb3J0cy5VbmNoYXJ0ZWQyVG9uZU1hcHBpbmcgPSBVbmNoYXJ0ZWQyVG9uZU1hcHBpbmc7XFxuXFx0ZXhwb3J0cy5DaW5lb25Ub25lTWFwcGluZyA9IENpbmVvblRvbmVNYXBwaW5nO1xcblxcdGV4cG9ydHMuVVZNYXBwaW5nID0gVVZNYXBwaW5nO1xcblxcdGV4cG9ydHMuQ3ViZVJlZmxlY3Rpb25NYXBwaW5nID0gQ3ViZVJlZmxlY3Rpb25NYXBwaW5nO1xcblxcdGV4cG9ydHMuQ3ViZVJlZnJhY3Rpb25NYXBwaW5nID0gQ3ViZVJlZnJhY3Rpb25NYXBwaW5nO1xcblxcdGV4cG9ydHMuRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcgPSBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZztcXG5cXHRleHBvcnRzLkVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nID0gRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmc7XFxuXFx0ZXhwb3J0cy5TcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZyA9IFNwaGVyaWNhbFJlZmxlY3Rpb25NYXBwaW5nO1xcblxcdGV4cG9ydHMuQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmcgPSBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZztcXG5cXHRleHBvcnRzLkN1YmVVVlJlZnJhY3Rpb25NYXBwaW5nID0gQ3ViZVVWUmVmcmFjdGlvbk1hcHBpbmc7XFxuXFx0ZXhwb3J0cy5SZXBlYXRXcmFwcGluZyA9IFJlcGVhdFdyYXBwaW5nO1xcblxcdGV4cG9ydHMuQ2xhbXBUb0VkZ2VXcmFwcGluZyA9IENsYW1wVG9FZGdlV3JhcHBpbmc7XFxuXFx0ZXhwb3J0cy5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nID0gTWlycm9yZWRSZXBlYXRXcmFwcGluZztcXG5cXHRleHBvcnRzLk5lYXJlc3RGaWx0ZXIgPSBOZWFyZXN0RmlsdGVyO1xcblxcdGV4cG9ydHMuTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgPSBOZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlcjtcXG5cXHRleHBvcnRzLk5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgPSBOZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyO1xcblxcdGV4cG9ydHMuTGluZWFyRmlsdGVyID0gTGluZWFyRmlsdGVyO1xcblxcdGV4cG9ydHMuTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlciA9IExpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXI7XFxuXFx0ZXhwb3J0cy5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIgPSBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7XFxuXFx0ZXhwb3J0cy5VbnNpZ25lZEJ5dGVUeXBlID0gVW5zaWduZWRCeXRlVHlwZTtcXG5cXHRleHBvcnRzLkJ5dGVUeXBlID0gQnl0ZVR5cGU7XFxuXFx0ZXhwb3J0cy5TaG9ydFR5cGUgPSBTaG9ydFR5cGU7XFxuXFx0ZXhwb3J0cy5VbnNpZ25lZFNob3J0VHlwZSA9IFVuc2lnbmVkU2hvcnRUeXBlO1xcblxcdGV4cG9ydHMuSW50VHlwZSA9IEludFR5cGU7XFxuXFx0ZXhwb3J0cy5VbnNpZ25lZEludFR5cGUgPSBVbnNpZ25lZEludFR5cGU7XFxuXFx0ZXhwb3J0cy5GbG9hdFR5cGUgPSBGbG9hdFR5cGU7XFxuXFx0ZXhwb3J0cy5IYWxmRmxvYXRUeXBlID0gSGFsZkZsb2F0VHlwZTtcXG5cXHRleHBvcnRzLlVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSA9IFVuc2lnbmVkU2hvcnQ0NDQ0VHlwZTtcXG5cXHRleHBvcnRzLlVuc2lnbmVkU2hvcnQ1NTUxVHlwZSA9IFVuc2lnbmVkU2hvcnQ1NTUxVHlwZTtcXG5cXHRleHBvcnRzLlVuc2lnbmVkU2hvcnQ1NjVUeXBlID0gVW5zaWduZWRTaG9ydDU2NVR5cGU7XFxuXFx0ZXhwb3J0cy5VbnNpZ25lZEludDI0OFR5cGUgPSBVbnNpZ25lZEludDI0OFR5cGU7XFxuXFx0ZXhwb3J0cy5BbHBoYUZvcm1hdCA9IEFscGhhRm9ybWF0O1xcblxcdGV4cG9ydHMuUkdCRm9ybWF0ID0gUkdCRm9ybWF0O1xcblxcdGV4cG9ydHMuUkdCQUZvcm1hdCA9IFJHQkFGb3JtYXQ7XFxuXFx0ZXhwb3J0cy5MdW1pbmFuY2VGb3JtYXQgPSBMdW1pbmFuY2VGb3JtYXQ7XFxuXFx0ZXhwb3J0cy5MdW1pbmFuY2VBbHBoYUZvcm1hdCA9IEx1bWluYW5jZUFscGhhRm9ybWF0O1xcblxcdGV4cG9ydHMuUkdCRUZvcm1hdCA9IFJHQkVGb3JtYXQ7XFxuXFx0ZXhwb3J0cy5EZXB0aEZvcm1hdCA9IERlcHRoRm9ybWF0O1xcblxcdGV4cG9ydHMuRGVwdGhTdGVuY2lsRm9ybWF0ID0gRGVwdGhTdGVuY2lsRm9ybWF0O1xcblxcdGV4cG9ydHMuUkdCX1MzVENfRFhUMV9Gb3JtYXQgPSBSR0JfUzNUQ19EWFQxX0Zvcm1hdDtcXG5cXHRleHBvcnRzLlJHQkFfUzNUQ19EWFQxX0Zvcm1hdCA9IFJHQkFfUzNUQ19EWFQxX0Zvcm1hdDtcXG5cXHRleHBvcnRzLlJHQkFfUzNUQ19EWFQzX0Zvcm1hdCA9IFJHQkFfUzNUQ19EWFQzX0Zvcm1hdDtcXG5cXHRleHBvcnRzLlJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCA9IFJHQkFfUzNUQ19EWFQ1X0Zvcm1hdDtcXG5cXHRleHBvcnRzLlJHQl9QVlJUQ180QlBQVjFfRm9ybWF0ID0gUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQ7XFxuXFx0ZXhwb3J0cy5SR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCA9IFJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0O1xcblxcdGV4cG9ydHMuUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ID0gUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0O1xcblxcdGV4cG9ydHMuUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0O1xcblxcdGV4cG9ydHMuUkdCX0VUQzFfRm9ybWF0ID0gUkdCX0VUQzFfRm9ybWF0O1xcblxcdGV4cG9ydHMuTG9vcE9uY2UgPSBMb29wT25jZTtcXG5cXHRleHBvcnRzLkxvb3BSZXBlYXQgPSBMb29wUmVwZWF0O1xcblxcdGV4cG9ydHMuTG9vcFBpbmdQb25nID0gTG9vcFBpbmdQb25nO1xcblxcdGV4cG9ydHMuSW50ZXJwb2xhdGVEaXNjcmV0ZSA9IEludGVycG9sYXRlRGlzY3JldGU7XFxuXFx0ZXhwb3J0cy5JbnRlcnBvbGF0ZUxpbmVhciA9IEludGVycG9sYXRlTGluZWFyO1xcblxcdGV4cG9ydHMuSW50ZXJwb2xhdGVTbW9vdGggPSBJbnRlcnBvbGF0ZVNtb290aDtcXG5cXHRleHBvcnRzLlplcm9DdXJ2YXR1cmVFbmRpbmcgPSBaZXJvQ3VydmF0dXJlRW5kaW5nO1xcblxcdGV4cG9ydHMuWmVyb1Nsb3BlRW5kaW5nID0gWmVyb1Nsb3BlRW5kaW5nO1xcblxcdGV4cG9ydHMuV3JhcEFyb3VuZEVuZGluZyA9IFdyYXBBcm91bmRFbmRpbmc7XFxuXFx0ZXhwb3J0cy5UcmlhbmdsZXNEcmF3TW9kZSA9IFRyaWFuZ2xlc0RyYXdNb2RlO1xcblxcdGV4cG9ydHMuVHJpYW5nbGVTdHJpcERyYXdNb2RlID0gVHJpYW5nbGVTdHJpcERyYXdNb2RlO1xcblxcdGV4cG9ydHMuVHJpYW5nbGVGYW5EcmF3TW9kZSA9IFRyaWFuZ2xlRmFuRHJhd01vZGU7XFxuXFx0ZXhwb3J0cy5MaW5lYXJFbmNvZGluZyA9IExpbmVhckVuY29kaW5nO1xcblxcdGV4cG9ydHMuc1JHQkVuY29kaW5nID0gc1JHQkVuY29kaW5nO1xcblxcdGV4cG9ydHMuR2FtbWFFbmNvZGluZyA9IEdhbW1hRW5jb2Rpbmc7XFxuXFx0ZXhwb3J0cy5SR0JFRW5jb2RpbmcgPSBSR0JFRW5jb2Rpbmc7XFxuXFx0ZXhwb3J0cy5Mb2dMdXZFbmNvZGluZyA9IExvZ0x1dkVuY29kaW5nO1xcblxcdGV4cG9ydHMuUkdCTTdFbmNvZGluZyA9IFJHQk03RW5jb2Rpbmc7XFxuXFx0ZXhwb3J0cy5SR0JNMTZFbmNvZGluZyA9IFJHQk0xNkVuY29kaW5nO1xcblxcdGV4cG9ydHMuUkdCREVuY29kaW5nID0gUkdCREVuY29kaW5nO1xcblxcdGV4cG9ydHMuQmFzaWNEZXB0aFBhY2tpbmcgPSBCYXNpY0RlcHRoUGFja2luZztcXG5cXHRleHBvcnRzLlJHQkFEZXB0aFBhY2tpbmcgPSBSR0JBRGVwdGhQYWNraW5nO1xcblxcdGV4cG9ydHMuQ3ViZUdlb21ldHJ5ID0gQm94R2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5GYWNlNCA9IEZhY2U0O1xcblxcdGV4cG9ydHMuTGluZVN0cmlwID0gTGluZVN0cmlwO1xcblxcdGV4cG9ydHMuTGluZVBpZWNlcyA9IExpbmVQaWVjZXM7XFxuXFx0ZXhwb3J0cy5NZXNoRmFjZU1hdGVyaWFsID0gTWVzaEZhY2VNYXRlcmlhbDtcXG5cXHRleHBvcnRzLk11bHRpTWF0ZXJpYWwgPSBNdWx0aU1hdGVyaWFsO1xcblxcdGV4cG9ydHMuUG9pbnRDbG91ZCA9IFBvaW50Q2xvdWQ7XFxuXFx0ZXhwb3J0cy5QYXJ0aWNsZSA9IFBhcnRpY2xlO1xcblxcdGV4cG9ydHMuUGFydGljbGVTeXN0ZW0gPSBQYXJ0aWNsZVN5c3RlbTtcXG5cXHRleHBvcnRzLlBvaW50Q2xvdWRNYXRlcmlhbCA9IFBvaW50Q2xvdWRNYXRlcmlhbDtcXG5cXHRleHBvcnRzLlBhcnRpY2xlQmFzaWNNYXRlcmlhbCA9IFBhcnRpY2xlQmFzaWNNYXRlcmlhbDtcXG5cXHRleHBvcnRzLlBhcnRpY2xlU3lzdGVtTWF0ZXJpYWwgPSBQYXJ0aWNsZVN5c3RlbU1hdGVyaWFsO1xcblxcdGV4cG9ydHMuVmVydGV4ID0gVmVydGV4O1xcblxcdGV4cG9ydHMuRHluYW1pY0J1ZmZlckF0dHJpYnV0ZSA9IER5bmFtaWNCdWZmZXJBdHRyaWJ1dGU7XFxuXFx0ZXhwb3J0cy5JbnQ4QXR0cmlidXRlID0gSW50OEF0dHJpYnV0ZTtcXG5cXHRleHBvcnRzLlVpbnQ4QXR0cmlidXRlID0gVWludDhBdHRyaWJ1dGU7XFxuXFx0ZXhwb3J0cy5VaW50OENsYW1wZWRBdHRyaWJ1dGUgPSBVaW50OENsYW1wZWRBdHRyaWJ1dGU7XFxuXFx0ZXhwb3J0cy5JbnQxNkF0dHJpYnV0ZSA9IEludDE2QXR0cmlidXRlO1xcblxcdGV4cG9ydHMuVWludDE2QXR0cmlidXRlID0gVWludDE2QXR0cmlidXRlO1xcblxcdGV4cG9ydHMuSW50MzJBdHRyaWJ1dGUgPSBJbnQzMkF0dHJpYnV0ZTtcXG5cXHRleHBvcnRzLlVpbnQzMkF0dHJpYnV0ZSA9IFVpbnQzMkF0dHJpYnV0ZTtcXG5cXHRleHBvcnRzLkZsb2F0MzJBdHRyaWJ1dGUgPSBGbG9hdDMyQXR0cmlidXRlO1xcblxcdGV4cG9ydHMuRmxvYXQ2NEF0dHJpYnV0ZSA9IEZsb2F0NjRBdHRyaWJ1dGU7XFxuXFx0ZXhwb3J0cy5DbG9zZWRTcGxpbmVDdXJ2ZTMgPSBDbG9zZWRTcGxpbmVDdXJ2ZTM7XFxuXFx0ZXhwb3J0cy5TcGxpbmVDdXJ2ZTMgPSBTcGxpbmVDdXJ2ZTM7XFxuXFx0ZXhwb3J0cy5TcGxpbmUgPSBTcGxpbmU7XFxuXFx0ZXhwb3J0cy5BeGlzSGVscGVyID0gQXhpc0hlbHBlcjtcXG5cXHRleHBvcnRzLkJvdW5kaW5nQm94SGVscGVyID0gQm91bmRpbmdCb3hIZWxwZXI7XFxuXFx0ZXhwb3J0cy5FZGdlc0hlbHBlciA9IEVkZ2VzSGVscGVyO1xcblxcdGV4cG9ydHMuV2lyZWZyYW1lSGVscGVyID0gV2lyZWZyYW1lSGVscGVyO1xcblxcdGV4cG9ydHMuWEhSTG9hZGVyID0gWEhSTG9hZGVyO1xcblxcdGV4cG9ydHMuQmluYXJ5VGV4dHVyZUxvYWRlciA9IEJpbmFyeVRleHR1cmVMb2FkZXI7XFxuXFx0ZXhwb3J0cy5HZW9tZXRyeVV0aWxzID0gR2VvbWV0cnlVdGlscztcXG5cXHRleHBvcnRzLkltYWdlVXRpbHMgPSBJbWFnZVV0aWxzO1xcblxcdGV4cG9ydHMuUHJvamVjdG9yID0gUHJvamVjdG9yO1xcblxcdGV4cG9ydHMuQ2FudmFzUmVuZGVyZXIgPSBDYW52YXNSZW5kZXJlcjtcXG5cXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xcblxcbn0pKSk7XFxuXCIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///11\n")},function(module,exports,__webpack_require__){eval("__webpack_require__(7)(__webpack_require__(11))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi92ZW5kb3IvdGhyZWUuanM/YjM3NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxMi5qcyIsInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIS9Vc2Vycy9tYXR0L2NvZGUvc2VsZl9kcml2aW5nX2Nhci9kYXNoL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvVXNlcnMvbWF0dC9jb2RlL3NlbGZfZHJpdmluZ19jYXIvZGFzaC9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvVXNlcnMvbWF0dC9jb2RlL3NlbGZfZHJpdmluZ19jYXIvZGFzaC92ZW5kb3IvdGhyZWUuanNcIikpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///12\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var script_loader_vendor_three_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);\n/* harmony import */ var script_loader_vendor_three_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(script_loader_vendor_three_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var script_loader_js_Utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);\n/* harmony import */ var script_loader_js_Utils_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(script_loader_js_Utils_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _js_autonomy_path_planning_PathPlanner_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);\n/* harmony import */ var _js_autonomy_LanePath_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3);\n/* harmony import */ var _js_autonomy_StaticObstacle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1);\n/* harmony import */ var _js_autonomy_DynamicObstacle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4);\n\n\n\n\n\n\n\nfunction init() {\n  let pathPlanner;\n  try {\n    pathPlanner = new _js_autonomy_path_planning_PathPlanner_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]();\n  } catch (e) {\n    console.log(\'Error initializing path planner:\');\n    console.log(e);\n\n    self.postMessage({ error: true });\n\n    return;\n  }\n\n  self.onmessage = function(event) {\n    const { config, vehiclePose, vehicleStation, lanePath, startTime, staticObstacles, dynamicObstacles, reset } = event.data;\n\n    _js_autonomy_LanePath_js__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].hydrate(lanePath);\n    staticObstacles.forEach(o => _js_autonomy_StaticObstacle_js__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].hydrate(o));\n    dynamicObstacles.forEach(o => _js_autonomy_DynamicObstacle_js__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].hydrate(o));\n\n    if (reset) pathPlanner.reset();\n\n    pathPlanner.config = config;\n\n    try {\n      const { path, fromVehicleSegment, fromVehicleParams, latticeStartStation, dynamicObstacleGrid } = pathPlanner.plan(vehiclePose, vehicleStation, lanePath, startTime, staticObstacles, dynamicObstacles);\n\n      self.postMessage({ path, fromVehicleSegment, fromVehicleParams, vehiclePose, vehicleStation, latticeStartStation, config, dynamicObstacleGrid });\n    } catch (error) {\n      console.log(\'PathPlannerWorker error\');\n      console.log(error);\n    }\n  };\n}\n\nif (typeof(window) === \'undefined\') {\n  init();\n} else {\n  window.dash_initPathPlannerWorker = init;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi93b3JrZXJzL1BhdGhQbGFubmVyV29ya2VyLmpzPzRlNzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsc0JBQXNCLGNBQWM7O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHFHQUFxRzs7QUFFaEg7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSx3RkFBd0Y7O0FBRXJHLHdCQUF3Qiw2SEFBNkg7QUFDckosS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBIiwiZmlsZSI6IjEzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFRIUkVFIGZyb20gXCJzY3JpcHQtbG9hZGVyIS4uL3ZlbmRvci90aHJlZS5qc1wiO1xuaW1wb3J0IFV0aWxzIGZyb20gXCJzY3JpcHQtbG9hZGVyIS4uL2pzL1V0aWxzLmpzXCI7XG5pbXBvcnQgUGF0aFBsYW5uZXIgZnJvbSBcIi4uL2pzL2F1dG9ub215L3BhdGgtcGxhbm5pbmcvUGF0aFBsYW5uZXIuanNcIjtcbmltcG9ydCBMYW5lUGF0aCBmcm9tIFwiLi4vanMvYXV0b25vbXkvTGFuZVBhdGguanNcIjtcbmltcG9ydCBTdGF0aWNPYnN0YWNsZSBmcm9tIFwiLi4vanMvYXV0b25vbXkvU3RhdGljT2JzdGFjbGUuanNcIjtcbmltcG9ydCBEeW5hbWljT2JzdGFjbGUgZnJvbSBcIi4uL2pzL2F1dG9ub215L0R5bmFtaWNPYnN0YWNsZS5qc1wiO1xuXG5mdW5jdGlvbiBpbml0KCkge1xuICBsZXQgcGF0aFBsYW5uZXI7XG4gIHRyeSB7XG4gICAgcGF0aFBsYW5uZXIgPSBuZXcgUGF0aFBsYW5uZXIoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUubG9nKCdFcnJvciBpbml0aWFsaXppbmcgcGF0aCBwbGFubmVyOicpO1xuICAgIGNvbnNvbGUubG9nKGUpO1xuXG4gICAgc2VsZi5wb3N0TWVzc2FnZSh7IGVycm9yOiB0cnVlIH0pO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc2VsZi5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgIGNvbnN0IHsgY29uZmlnLCB2ZWhpY2xlUG9zZSwgdmVoaWNsZVN0YXRpb24sIGxhbmVQYXRoLCBzdGFydFRpbWUsIHN0YXRpY09ic3RhY2xlcywgZHluYW1pY09ic3RhY2xlcywgcmVzZXQgfSA9IGV2ZW50LmRhdGE7XG5cbiAgICBMYW5lUGF0aC5oeWRyYXRlKGxhbmVQYXRoKTtcbiAgICBzdGF0aWNPYnN0YWNsZXMuZm9yRWFjaChvID0+IFN0YXRpY09ic3RhY2xlLmh5ZHJhdGUobykpO1xuICAgIGR5bmFtaWNPYnN0YWNsZXMuZm9yRWFjaChvID0+IER5bmFtaWNPYnN0YWNsZS5oeWRyYXRlKG8pKTtcblxuICAgIGlmIChyZXNldCkgcGF0aFBsYW5uZXIucmVzZXQoKTtcblxuICAgIHBhdGhQbGFubmVyLmNvbmZpZyA9IGNvbmZpZztcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IHBhdGgsIGZyb21WZWhpY2xlU2VnbWVudCwgZnJvbVZlaGljbGVQYXJhbXMsIGxhdHRpY2VTdGFydFN0YXRpb24sIGR5bmFtaWNPYnN0YWNsZUdyaWQgfSA9IHBhdGhQbGFubmVyLnBsYW4odmVoaWNsZVBvc2UsIHZlaGljbGVTdGF0aW9uLCBsYW5lUGF0aCwgc3RhcnRUaW1lLCBzdGF0aWNPYnN0YWNsZXMsIGR5bmFtaWNPYnN0YWNsZXMpO1xuXG4gICAgICBzZWxmLnBvc3RNZXNzYWdlKHsgcGF0aCwgZnJvbVZlaGljbGVTZWdtZW50LCBmcm9tVmVoaWNsZVBhcmFtcywgdmVoaWNsZVBvc2UsIHZlaGljbGVTdGF0aW9uLCBsYXR0aWNlU3RhcnRTdGF0aW9uLCBjb25maWcsIGR5bmFtaWNPYnN0YWNsZUdyaWQgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdQYXRoUGxhbm5lcldvcmtlciBlcnJvcicpO1xuICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xuICAgIH1cbiAgfTtcbn1cblxuaWYgKHR5cGVvZih3aW5kb3cpID09PSAndW5kZWZpbmVkJykge1xuICBpbml0KCk7XG59IGVsc2Uge1xuICB3aW5kb3cuZGFzaF9pbml0UGF0aFBsYW5uZXJXb3JrZXIgPSBpbml0O1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13\n')}])}void 0===typeof window&&dash_initPathPlannerWorker();